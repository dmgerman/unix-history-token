begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)breakpoint.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Everything about breakpoints, for GDB.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* This is the sequence of bytes we insert for a breakpoint.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* States of enablement of breakpoint.    `temporary' means disable when hit.    `delete' means delete when hit.  */
end_comment

begin_enum
enum|enum
name|enable
block|{
name|disabled
block|,
name|enabled
block|,
name|temporary
block|,
name|delete
block|}
enum|;
end_enum

begin_comment
comment|/* Not that the ->silent field is not currently used by any commands    (though the code is in there if it was to be and set_raw_breakpoint    does set it to 0).  I implemented it because I thought it would be    useful for a hack I had to put in; I'm going to leave it in because    I can see how there might be times when it would indeed be useful */
end_comment

begin_struct
struct|struct
name|breakpoint
block|{
name|struct
name|breakpoint
modifier|*
name|next
decl_stmt|;
comment|/* Number assigned to distinguish breakpoints.  */
name|int
name|number
decl_stmt|;
comment|/* Address to break at.  */
name|CORE_ADDR
name|address
decl_stmt|;
comment|/* Line number of this address.  Redundant.  */
name|int
name|line_number
decl_stmt|;
comment|/* Symtab of file of this address.  Redundant.  */
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
comment|/* Zero means disabled; remember the info but don't break here.  */
name|enum
name|enable
name|enable
decl_stmt|;
comment|/* Non-zero means a silent breakpoint (don't print frame info      if we stop here). */
name|unsigned
name|char
name|silent
decl_stmt|;
comment|/* Number of stops at this breakpoint that should      be continued automatically before really stopping.  */
name|int
name|ignore_count
decl_stmt|;
comment|/* "Real" contents of byte where breakpoint has been inserted.      Valid only when breakpoints are in the program.  */
name|char
name|shadow_contents
index|[
sizeof|sizeof
name|break_insn
index|]
decl_stmt|;
comment|/* Nonzero if this breakpoint is now inserted.  */
name|char
name|inserted
decl_stmt|;
comment|/* Nonzero if this is not the first breakpoint in the list      for the given address.  */
name|char
name|duplicate
decl_stmt|;
comment|/* Chain of command lines to execute when this breakpoint is hit.  */
name|struct
name|command_line
modifier|*
name|commands
decl_stmt|;
comment|/* Stack depth (address of frame).  If nonzero, break only if fp      equals this.  */
name|FRAME_ADDR
name|frame
decl_stmt|;
comment|/* Conditional.  Break only if this expression's value is nonzero.  */
name|struct
name|expression
modifier|*
name|cond
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ALL_BREAKPOINTS
parameter_list|(
name|b
parameter_list|)
value|for (b = breakpoint_chain; b; b = b->next)
end_define

begin_comment
comment|/* Chain of all breakpoints defined.  */
end_comment

begin_decl_stmt
name|struct
name|breakpoint
modifier|*
name|breakpoint_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last breakpoint made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoint_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default address, symtab and line to put a breakpoint at    for "break" command with no arg.    if default_breakpoint_valid is zero, the other three are    not valid, and "break" with no arg is an error.     This set by print_stack_frame, which calls set_default_breakpoint.  */
end_comment

begin_decl_stmt
name|int
name|default_breakpoint_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|default_breakpoint_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|default_breakpoint_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_breakpoint_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remaining commands (not yet executed)    of last breakpoint hit.  */
end_comment

begin_decl_stmt
name|struct
name|command_line
modifier|*
name|breakpoint_commands
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|delete_breakpoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clear_momentary_breakpoints
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|breakpoint_auto_delete
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Flag indicating extra verbosity for xgdb.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|xgdb_verbose
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* condition N EXP -- set break condition of breakpoint N to EXP.  */
end_comment

begin_function
specifier|static
name|void
name|condition_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|arg
condition|)
comment|/* There is no number here.  (e.g. "cond a == b").  */
name|error_no_arg
argument_list|(
literal|"breakpoint number"
argument_list|)
expr_stmt|;
name|bnum
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|free
argument_list|(
name|b
operator|->
name|cond
argument_list|)
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
comment|/* parse_c_1 can leave this unchanged. */
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Breakpoint %d now unconditional.\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be an integer (breakpoint number) and an expression."
argument_list|)
expr_stmt|;
comment|/* Find start of expression */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|arg
operator|=
name|p
expr_stmt|;
name|b
operator|->
name|cond
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|parse_c_1
argument_list|(
operator|&
name|arg
argument_list|,
name|block_for_pc
argument_list|(
name|b
operator|->
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of expression"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|commands_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|bnum
decl_stmt|;
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
comment|/* If we allowed this, we would have problems with when to      free the storage, if we change the commands currently      being read from.  */
if|if
condition|(
name|breakpoint_commands
condition|)
name|error
argument_list|(
literal|"Can't use the \"commands\" command among a breakpoint's commands."
argument_list|)
expr_stmt|;
comment|/* Allow commands by itself to refer to the last breakpoint.  */
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|bnum
operator|=
name|breakpoint_count
expr_stmt|;
else|else
block|{
name|p
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
condition|)
name|error
argument_list|(
literal|"Argument must be integer (a breakpoint number)."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"Unexpected extra arguments following breakpoint number."
argument_list|)
expr_stmt|;
name|bnum
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|from_tty
operator|&&
name|input_from_terminal_p
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"Type commands for when breakpoint %d is hit, one per line.\n\ End with a line saying just \"end\".\n"
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|read_command_lines
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
name|b
operator|->
name|commands
argument_list|)
expr_stmt|;
name|b
operator|->
name|commands
operator|=
name|l
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from command loop to execute the commands    associated with the breakpoint we just stopped at.  */
end_comment

begin_function
name|void
name|do_breakpoint_commands
parameter_list|()
block|{
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
while|while
condition|(
name|cmd
operator|=
name|breakpoint_commands
condition|)
block|{
name|breakpoint_commands
operator|=
literal|0
expr_stmt|;
name|execute_command_lines
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* If command was "cont", breakpoint_commands is now 0, 	 of if we stopped at yet another breakpoint which has commands, 	 it is now the commands for the new breakpoint.  */
block|}
name|clear_momentary_breakpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used when the program is proceeded, to eliminate any remaining    commands attached to the previous breakpoint we stopped at.  */
end_comment

begin_function
name|void
name|clear_breakpoint_commands
parameter_list|()
block|{
name|breakpoint_commands
operator|=
literal|0
expr_stmt|;
name|breakpoint_auto_delete
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions to get and set the current list of pending    breakpoint commands.  These are used by run_stack_dummy    to preserve the commands around a function call.  */
end_comment

begin_function
name|struct
name|command_line
modifier|*
name|get_breakpoint_commands
parameter_list|()
block|{
return|return
name|breakpoint_commands
return|;
block|}
end_function

begin_function
name|void
name|set_breakpoint_commands
parameter_list|(
name|cmds
parameter_list|)
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
block|{
name|breakpoint_commands
operator|=
name|cmds
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* insert_breakpoints is used when starting or continuing the program.    remove_breakpoints is used when the program stops.    Both return zero if successful,    or an `errno' value if could not write the inferior.  */
end_comment

begin_function
name|int
name|insert_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|BREAKPOINT_DEBUG
name|printf
argument_list|(
literal|"Inserting breakpoints.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BREAKPOINT_DEBUG */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
operator|!
name|b
operator|->
name|inserted
operator|&&
operator|!
name|b
operator|->
name|duplicate
condition|)
block|{
name|read_memory
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
name|val
operator|=
name|write_memory
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|break_insn
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
ifdef|#
directive|ifdef
name|BREAKPOINT_DEBUG
name|printf
argument_list|(
literal|"Inserted breakpoint at 0x%x, shadow 0x%x, 0x%x.\n"
argument_list|,
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
index|[
literal|0
index|]
argument_list|,
name|b
operator|->
name|shadow_contents
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BREAKPOINT_DEBUG */
name|b
operator|->
name|inserted
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|remove_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|BREAKPOINT_DEBUG
name|printf
argument_list|(
literal|"Removing breakpoints.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BREAKPOINT_DEBUG */
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|inserted
condition|)
block|{
name|val
operator|=
name|write_memory
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BREAKPOINT_DEBUG
name|printf
argument_list|(
literal|"Removed breakpoint at 0x%x, shadow 0x%x, 0x%x.\n"
argument_list|,
name|b
operator|->
name|address
argument_list|,
name|b
operator|->
name|shadow_contents
index|[
literal|0
index|]
argument_list|,
name|b
operator|->
name|shadow_contents
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BREAKPOINT_DEBUG */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear the "inserted" flag in all breakpoints.    This is done when the inferior is loaded.  */
end_comment

begin_function
name|void
name|mark_breakpoints_out
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|inserted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* breakpoint_here_p (PC) returns 1 if an enabled breakpoint exists at PC.    When continuing from a location with a breakpoint,    we actually single step once before calling insert_breakpoints.  */
end_comment

begin_function
name|int
name|breakpoint_here_p
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Evaluate the expression EXP and return 1 if value is zero.    This is used inside a catch_errors to evaluate the breakpoint condition.  */
end_comment

begin_function
name|int
name|breakpoint_cond_eval
parameter_list|(
name|exp
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
block|{
return|return
name|value_zerop
argument_list|(
name|evaluate_expression
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if PC is not the address just after a breakpoint,    or -1 if breakpoint says do not stop now,    or -2 if breakpoint says it has deleted itself and don't stop,    or -3 if hit a breakpoint number -3 (delete when program stops),    or else the number of the breakpoint,    with 0x1000000 added (or subtracted, for a negative return value) for    a silent breakpoint.  */
end_comment

begin_function
name|int
name|breakpoint_stop_status
parameter_list|(
name|pc
parameter_list|,
name|frame_address
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|FRAME_ADDR
name|frame_address
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|cont
init|=
literal|0
decl_stmt|;
comment|/* Get the address where the breakpoint would have been.  */
name|pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|pc
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|frame
operator|&&
name|b
operator|->
name|frame
operator|!=
name|frame_address
condition|)
name|cont
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|int
name|value_zero
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
comment|/* Need to select the frame, with all that implies 		   so that the conditions will have the right context.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value_zero
operator|=
name|catch_errors
argument_list|(
name|breakpoint_cond_eval
argument_list|,
name|b
operator|->
name|cond
argument_list|,
literal|"Error occurred in testing breakpoint condition."
argument_list|)
expr_stmt|;
name|free_all_values
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|cond
operator|&&
name|value_zero
condition|)
block|{
name|cont
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|ignore_count
operator|>
literal|0
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|--
expr_stmt|;
name|cont
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|temporary
condition|)
name|b
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
name|breakpoint_commands
operator|=
name|b
operator|->
name|commands
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|silent
operator|||
operator|(
name|breakpoint_commands
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"silent"
argument_list|,
name|breakpoint_commands
operator|->
name|line
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|breakpoint_commands
condition|)
name|breakpoint_commands
operator|=
name|breakpoint_commands
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|b
operator|->
name|number
operator|>
literal|0
condition|?
literal|0x1000000
operator|+
name|b
operator|->
name|number
else|:
name|b
operator|->
name|number
operator|-
literal|0x1000000
operator|)
return|;
block|}
return|return
name|b
operator|->
name|number
return|;
block|}
block|}
block|}
return|return
name|cont
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|breakpoint_1
parameter_list|(
name|bnum
parameter_list|)
name|int
name|bnum
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|bnum
operator|==
operator|-
literal|1
operator|||
name|bnum
operator|==
name|b
operator|->
name|number
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"#%-3d %c  0x%08x"
argument_list|,
name|b
operator|->
name|number
argument_list|,
literal|"nyod"
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|enable
index|]
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
name|last_addr
operator|=
name|b
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|symtab
condition|)
block|{
name|sym
operator|=
name|find_pc_function
argument_list|(
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" in "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stdout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|b
operator|->
name|symtab
operator|->
name|filename
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" line %d"
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|print_address_symbolic
argument_list|(
name|b
operator|->
name|address
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ignore_count
condition|)
name|printf_filtered
argument_list|(
literal|"\tignore next %d hits\n"
argument_list|,
name|b
operator|->
name|ignore_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|frame
condition|)
name|printf_filtered
argument_list|(
literal|"\tstop only in stack frame at 0x%x\n"
argument_list|,
name|b
operator|->
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cond
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tbreak only if "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|b
operator|->
name|cond
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|=
name|b
operator|->
name|commands
condition|)
while|while
condition|(
name|l
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%s\n"
argument_list|,
name|l
operator|->
name|line
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Compare against (CORE_ADDR)-1 in case some compiler decides      that a comparison of an unsigned with -1 is always false.  */
if|if
condition|(
name|last_addr
operator|!=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
name|set_next_address
argument_list|(
name|last_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|breakpoints_info
parameter_list|(
name|bnum_exp
parameter_list|)
name|char
modifier|*
name|bnum_exp
decl_stmt|;
block|{
name|int
name|bnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bnum_exp
condition|)
name|bnum
operator|=
name|parse_and_eval_address
argument_list|(
name|bnum_exp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|breakpoint_chain
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"No breakpoints.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Breakpoints:\n\ Num Enb   Address    Where\n"
argument_list|)
expr_stmt|;
name|breakpoint_1
argument_list|(
name|bnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a message describing any breakpoints set at PC.  */
end_comment

begin_function
specifier|static
name|void
name|describe_other_breakpoints
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|int
name|others
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
name|others
operator|++
expr_stmt|;
if|if
condition|(
name|others
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Note: breakpoint%s "
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|address
operator|==
name|pc
condition|)
block|{
name|others
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%d%s%s "
argument_list|,
name|b
operator|->
name|number
argument_list|,
operator|(
name|b
operator|->
name|enable
operator|==
name|disabled
operator|)
condition|?
literal|" (disabled)"
else|:
literal|""
argument_list|,
operator|(
name|others
operator|>
literal|1
operator|)
condition|?
literal|","
else|:
operator|(
operator|(
name|others
operator|==
literal|1
operator|)
condition|?
literal|" and"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"also set at pc 0x%x.\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the default place to put a breakpoint    for the `break' command with no arguments.  */
end_comment

begin_function
name|void
name|set_default_breakpoint
parameter_list|(
name|valid
parameter_list|,
name|addr
parameter_list|,
name|symtab
parameter_list|,
name|line
parameter_list|)
name|int
name|valid
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|default_breakpoint_valid
operator|=
name|valid
expr_stmt|;
name|default_breakpoint_address
operator|=
name|addr
expr_stmt|;
name|default_breakpoint_symtab
operator|=
name|symtab
expr_stmt|;
name|default_breakpoint_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rescan breakpoints at address ADDRESS,    marking the first one as "first" and any others as "duplicates".    This is so that the bpt instruction is only inserted once.  */
end_comment

begin_function
specifier|static
name|void
name|check_duplicates
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|enable
operator|!=
name|disabled
operator|&&
name|b
operator|->
name|address
operator|==
name|address
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|b
operator|->
name|duplicate
operator|=
name|count
operator|>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Low level routine to set a breakpoint.    Takes as args the three things that every breakpoint must have.    Returns the breakpoint object so caller can set other things.    Does not set the breakpoint number!    Does not print anything.  */
end_comment

begin_function
specifier|static
name|struct
name|breakpoint
modifier|*
name|set_raw_breakpoint
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|breakpoint
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|address
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
name|b
operator|->
name|symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|b
operator|->
name|line_number
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
name|b
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|silent
operator|=
literal|0
expr_stmt|;
comment|/* Add this breakpoint to the end of the chain      so that a list of breakpoints will come out in order      of increasing numbers.  */
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
if|if
condition|(
name|b1
operator|==
literal|0
condition|)
name|breakpoint_chain
operator|=
name|b
expr_stmt|;
else|else
block|{
while|while
condition|(
name|b1
operator|->
name|next
condition|)
name|b1
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|b
expr_stmt|;
block|}
name|check_duplicates
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Set a breakpoint that will evaporate an end of command    at address specified by SAL.    Restrict it to frame FRAME if FRAME is nonzero.  */
end_comment

begin_function
name|void
name|set_momentary_breakpoint
parameter_list|(
name|sal
parameter_list|,
name|frame
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
operator|-
literal|3
expr_stmt|;
name|b
operator|->
name|enable
operator|=
name|delete
expr_stmt|;
name|b
operator|->
name|frame
operator|=
operator|(
name|frame
condition|?
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_momentary_breakpoints
parameter_list|()
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
operator|-
literal|3
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set a breakpoint from a symtab and line.    If TEMPFLAG is nonzero, it is a temporary breakpoint.    Print the same confirmation messages that the breakpoint command prints.  */
end_comment

begin_function
name|void
name|set_breakpoint
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|tempflag
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|tempflag
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\".\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
block|{
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
operator|++
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tempflag
condition|)
name|b
operator|->
name|enable
operator|=
name|temporary
expr_stmt|;
name|printf
argument_list|(
literal|"Breakpoint %d at 0x%x"
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|symtab
condition|)
name|printf
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|b
operator|->
name|symtab
operator|->
name|filename
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set a breakpoint according to ARG (function, linenum or *address)    and make it temporary if TEMPFLAG is nonzero. */
end_comment

begin_function
specifier|static
name|void
name|break_command_1
parameter_list|(
name|arg
parameter_list|,
name|tempflag
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|tempflag
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|cond
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|save_arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|sals
operator|.
name|sals
operator|=
name|NULL
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|sal
operator|.
name|pc
operator|=
name|sal
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
comment|/* If no arg given, or if first arg is 'if ', use the default breakpoint. */
if|if
condition|(
operator|!
name|arg
operator|||
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|default_breakpoint_valid
condition|)
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|default_breakpoint_address
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"No default breakpoint address now."
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Force almost all breakpoints to be in terms of the        current_source_symtab (which is decode_line_1's default).  This        should produce the results we want almost all of the time while        leaving default_breakpoint_* alone.  */
if|if
condition|(
name|default_breakpoint_valid
operator|&&
operator|(
operator|!
name|current_source_symtab
operator|||
operator|(
name|arg
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|'+'
operator|||
operator|*
name|arg
operator|==
literal|'-'
operator|)
operator|)
operator|)
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
name|save_arg
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|==
literal|0
operator|&&
name|sal
operator|.
name|symtab
operator|!=
literal|0
condition|)
block|{
name|pc
operator|=
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\"."
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|pc
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
while|while
condition|(
name|arg
operator|&&
operator|*
name|arg
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
literal|2
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|cond
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|parse_c_1
argument_list|(
operator|(
name|arg
operator|+=
literal|2
operator|,
operator|&
name|arg
operator|)
argument_list|,
name|block_for_pc
argument_list|(
name|pc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|save_arg
expr_stmt|;
name|sals
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|describe_other_breakpoints
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|b
operator|=
name|set_raw_breakpoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|b
operator|->
name|number
operator|=
operator|++
name|breakpoint_count
expr_stmt|;
name|b
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|tempflag
condition|)
name|b
operator|->
name|enable
operator|=
name|temporary
expr_stmt|;
name|printf
argument_list|(
literal|"Breakpoint %d at 0x%x"
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|b
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|symtab
condition|)
name|printf
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|b
operator|->
name|symtab
operator|->
name|filename
argument_list|,
name|b
operator|->
name|line_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Multiple breakpoints were set.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use the \"delete\" command to delete unwanted breakpoints.\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbreak_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|break_command_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Helper routine for the until_command routine in infcmd.c.  Here  * because it uses the mechanisms of breakpoints.  */
end_comment

begin_function
name|void
name|until_break_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|FRAME
name|prev_frame
init|=
name|get_prev_frame
argument_list|(
name|selected_frame
argument_list|)
decl_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Set a breakpoint where the user wants it and at return from      this function */
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Couldn't get information on specified line."
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* malloc'd, so freed */
if|if
condition|(
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|==
literal|0
operator|&&
name|sal
operator|.
name|symtab
operator|!=
literal|0
condition|)
name|sal
operator|.
name|pc
operator|=
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\"."
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|selected_frame
argument_list|)
expr_stmt|;
comment|/* Keep within the current frame */
if|if
condition|(
name|prev_frame
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|prev_frame
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|prev_frame
argument_list|)
expr_stmt|;
block|}
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|clear_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|default_breakpoint_line
expr_stmt|;
name|sal
operator|.
name|symtab
operator|=
name|default_breakpoint_symtab
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file specified."
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* If exact pc given, clear bpts at that pc. 	 But if sal.pc is zero, clear all bpts on specified line.  */
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
name|found
operator|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|breakpoint_chain
operator|&&
operator|(
name|sal
operator|.
name|pc
condition|?
name|breakpoint_chain
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
else|:
operator|(
name|breakpoint_chain
operator|->
name|symtab
operator|==
name|sal
operator|.
name|symtab
operator|&&
name|breakpoint_chain
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|breakpoint_chain
expr_stmt|;
name|breakpoint_chain
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
while|while
condition|(
name|b
operator|->
name|next
operator|&&
operator|(
name|sal
operator|.
name|pc
condition|?
name|b
operator|->
name|next
operator|->
name|address
operator|==
name|sal
operator|.
name|pc
else|:
operator|(
name|b
operator|->
name|next
operator|->
name|symtab
operator|==
name|sal
operator|.
name|symtab
operator|&&
name|b
operator|->
name|next
operator|->
name|line_number
operator|==
name|sal
operator|.
name|line
operator|)
operator|)
condition|)
block|{
name|b1
operator|=
name|b
operator|->
name|next
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|b1
operator|->
name|next
expr_stmt|;
name|b1
operator|->
name|next
operator|=
name|found
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No breakpoint at %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|->
name|next
condition|)
name|from_tty
operator|=
literal|1
expr_stmt|;
comment|/* Always report if deleted more than one */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Deleted breakpoint%s "
argument_list|,
name|found
operator|->
name|next
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|found
operator|->
name|number
argument_list|)
expr_stmt|;
name|b1
operator|=
name|found
operator|->
name|next
expr_stmt|;
name|delete_breakpoint
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|found
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete breakpoint number BNUM if it is a `delete' breakpoint.    This is called after breakpoint BNUM has been hit.    Also delete any breakpoint numbered -3 unless there are breakpoint    commands to be executed.  */
end_comment

begin_function
name|void
name|breakpoint_auto_delete
parameter_list|(
name|bnum
parameter_list|)
name|int
name|bnum
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|bnum
operator|!=
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bnum
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|enable
operator|==
name|delete
condition|)
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|breakpoint_commands
operator|==
literal|0
condition|)
name|clear_momentary_breakpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|bpt
operator|->
name|inserted
condition|)
name|write_memory
argument_list|(
name|bpt
operator|->
name|address
argument_list|,
name|bpt
operator|->
name|shadow_contents
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoint_chain
operator|==
name|bpt
condition|)
name|breakpoint_chain
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|next
operator|==
name|bpt
condition|)
block|{
name|b
operator|->
name|next
operator|=
name|bpt
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
name|free_command_lines
argument_list|(
name|bpt
operator|->
name|commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpt
operator|->
name|cond
condition|)
name|free
argument_list|(
name|bpt
operator|->
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|xgdb_verbose
operator|&&
name|bpt
operator|->
name|number
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"breakpoint #%d deleted\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|map_breakpoint_numbers
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|delete_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
comment|/* Ask user only if there are some breakpoints to delete.  */
if|if
condition|(
operator|!
name|from_tty
operator|||
name|breakpoint_chain
operator|&&
name|query
argument_list|(
literal|"Delete all breakpoints? "
argument_list|)
condition|)
block|{
comment|/* No arg; clear all breakpoints.  */
while|while
condition|(
name|breakpoint_chain
condition|)
name|delete_breakpoint
argument_list|(
name|breakpoint_chain
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|map_breakpoint_numbers
argument_list|(
name|arg
argument_list|,
name|delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all breakpoints.    Done when new symtabs are loaded, since the break condition expressions    may become invalid, and the breakpoints are probably wrong anyway.  */
end_comment

begin_function
name|void
name|clear_breakpoints
parameter_list|()
block|{
name|delete_command
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set ignore-count of breakpoint number BPTNUM to COUNT.    If from_tty is nonzero, it prints a message to that effect,    which ends with a period (no newline).  */
end_comment

begin_function
name|void
name|set_ignore_count
parameter_list|(
name|bptnum
parameter_list|,
name|count
parameter_list|,
name|from_tty
parameter_list|)
name|int
name|bptnum
decl_stmt|,
name|count
decl_stmt|,
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|bptnum
condition|)
block|{
name|b
operator|->
name|ignore_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|from_tty
condition|)
return|return;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Will stop next time breakpoint %d is reached."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"Will ignore next crossing of breakpoint %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Will ignore next %d crossings of breakpoint %d."
argument_list|,
name|count
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"No breakpoint number %d."
argument_list|,
name|bptnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the ignore counts of all breakpoints.  */
end_comment

begin_function
name|void
name|breakpoint_clear_ignore_counts
parameter_list|()
block|{
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
name|b
operator|->
name|ignore_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command to set ignore-count of breakpoint N to COUNT.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"a breakpoint number"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"First argument must be a breakpoint number."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Second argument (specified ignore-count) is missing."
argument_list|)
expr_stmt|;
name|set_ignore_count
argument_list|(
name|num
argument_list|,
name|parse_and_eval_address
argument_list|(
name|p
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call FUNCTION on each of the breakpoints    whose numbers are given in ARGS.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|function
argument_list|)
name|char
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more breakpoint numbers"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be breakpoint numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ALL_BREAKPOINTS
argument_list|(
argument|b
argument_list|)
if|if
condition|(
name|b
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|function
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|win
goto|;
block|}
name|printf
argument_list|(
literal|"No breakpoint number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|win
label|:
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|enable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|enabled
expr_stmt|;
if|if
condition|(
name|xgdb_verbose
operator|&&
name|bpt
operator|->
name|number
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"breakpoint #%d enabled\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_command
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
name|enable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|disabled
expr_stmt|;
if|if
condition|(
name|xgdb_verbose
operator|&&
name|bpt
operator|->
name|number
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"breakpoint #%d disabled\n"
argument_list|,
name|bpt
operator|->
name|number
argument_list|)
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_command
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|ALL_BREAKPOINTS
argument_list|(
argument|bpt
argument_list|)
name|disable_breakpoint
argument_list|(
name|bpt
argument_list|)
expr_stmt|;
else|else
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|disable_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_once_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|temporary
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_once_command
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_once_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_delete_breakpoint
parameter_list|(
name|bpt
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|bpt
decl_stmt|;
block|{
name|bpt
operator|->
name|enable
operator|=
name|delete
expr_stmt|;
name|check_duplicates
argument_list|(
name|bpt
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_delete_command
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|map_breakpoint_numbers
argument_list|(
name|args
argument_list|,
name|enable_delete_breakpoint
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Use default_breakpoint_'s, or nothing if they aren't valid.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec_1
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_breakpoint_valid
condition|)
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|default_breakpoint_symtab
argument_list|,
name|default_breakpoint_line
argument_list|)
expr_stmt|;
else|else
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Chain containing all defined enable commands.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|,
modifier|*
name|disablelist
decl_stmt|,
modifier|*
name|deletelist
decl_stmt|,
modifier|*
name|enablebreaklist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_breakpoint
parameter_list|()
block|{
name|breakpoint_chain
operator|=
literal|0
expr_stmt|;
name|breakpoint_count
operator|=
literal|0
expr_stmt|;
name|add_com
argument_list|(
literal|"ignore"
argument_list|,
name|class_breakpoint
argument_list|,
name|ignore_command
argument_list|,
literal|"Set ignore-count of breakpoint number N to COUNT."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"commands"
argument_list|,
name|class_breakpoint
argument_list|,
name|commands_command
argument_list|,
literal|"Set commands to be executed when a breakpoint is hit.\n\ Give breakpoint number as argument after \"commands\".\n\ With no argument, the targeted breakpoint is the last one set.\n\ The commands themselves follow starting on the next line.\n\ Type a line containing \"end\" to indicate the end of them.\n\ Give \"silent\" as the first line to make the breakpoint silent;\n\ then no output is printed when it is hit, except what the commands print."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"condition"
argument_list|,
name|class_breakpoint
argument_list|,
name|condition_command
argument_list|,
literal|"Specify breakpoint number N to break only if COND is true.\n\ N is an integer; COND is a C expression to be evaluated whenever\n\ breakpoint N is reached.  Actually break only when COND is nonzero."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tbreak"
argument_list|,
name|class_breakpoint
argument_list|,
name|tbreak_command
argument_list|,
literal|"Set a temporary breakpoint.  Args like \"break\" command.\n\ Like \"break\" except the breakpoint is only enabled temporarily,\n\ so it will be disabled when hit.  Equivalent to \"break\" followed\n\ by using \"enable once\" on the breakpoint number."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"enable"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints or auto-display expressions.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ With a subcommand you can enable temporarily.\n\ \n\ The \"display\" subcommand applies to auto-displays instead of breakpoints."
argument_list|,
operator|&
name|enablelist
argument_list|,
literal|"enable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_abbrev_prefix_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|enable_command
argument_list|,
literal|"Enable some breakpoints or auto-display expressions.\n\ Give breakpoint numbers (separated by spaces) as arguments.\n\ With no subcommand, breakpoints are enabled until you command otherwise.\n\ This is used to cancel the effect of the \"disable\" command.\n\ May be abbreviates to simply \"enable\".\n\ With a subcommand you can enable temporarily."
argument_list|,
operator|&
name|enablebreaklist
argument_list|,
literal|"enable breakpoints "
argument_list|,
literal|1
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled.\n\ See the \"tbreak\" command which sets a breakpoint and enables it once."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablebreaklist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"delete"
argument_list|,
name|no_class
argument_list|,
name|enable_delete_command
argument_list|,
literal|"Enable breakpoints and delete when hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it is deleted."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"once"
argument_list|,
name|no_class
argument_list|,
name|enable_once_command
argument_list|,
literal|"Enable breakpoints for one hit.  Give breakpoint numbers.\n\ If a breakpoint is hit while enabled in this fashion, it becomes disabled.\n\ See the \"tbreak\" command which sets a breakpoint and enables it once."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled.\n\ \n\ The \"display\" subcommand applies to auto-displays instead of breakpoints."
argument_list|,
operator|&
name|disablelist
argument_list|,
literal|"disable "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"dis"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"disa"
argument_list|,
literal|"disable"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_abbrev_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
name|disable_command
argument_list|,
literal|"Disable some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To disable all breakpoints, give no argument.\n\ A disabled breakpoint is not forgotten, but has no effect until reenabled.\n\ This command may be abbreviated \"disable\"."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ \n\ Also a prefix command for deletion of other GDB objects.\n\ The \"unset\" command is also an alias for \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|,
literal|"delete "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"d"
argument_list|,
literal|"delete"
argument_list|,
name|class_breakpoint
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"unset"
argument_list|,
literal|"delete"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_alias
argument_list|,
name|delete_command
argument_list|,
literal|"Delete some breakpoints or auto-display expressions.\n\ Arguments are breakpoint numbers with spaces in between.\n\ To delete all breakpoints, give no argument.\n\ This command may be abbreviated \"delete\"."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"clear"
argument_list|,
name|class_breakpoint
argument_list|,
name|clear_command
argument_list|,
literal|"Clear breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, all breakpoints in that line are cleared.\n\ If function is specified, breakpoints at beginning of function are cleared.\n\ If an address is specified, breakpoints at that address are cleared.\n\n\ With no argument, clears all breakpoints in the line that the selected frame\n\ is executing in.\n\ \n\ See also the \"delete\" command which clears breakpoints by number."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"break"
argument_list|,
name|class_breakpoint
argument_list|,
name|break_command
argument_list|,
literal|"Set breakpoint at specified line or function.\n\ Argument may be line number, function name, or \"*\" and an address.\n\ If line number is specified, break at start of code for that line.\n\ If function is specified, break at start of code for that function.\n\ If an address is specified, break at that exact address.\n\ With no arg, uses current execution address of selected stack frame.\n\ This is useful for breaking on return to a stack frame.\n\ \n\ Multiple breakpoints at one place are permitted, and useful if conditional.\n\ \n\ Do \"help breakpoints\" for info on other commands dealing with breakpoints."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"b"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"br"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bre"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"brea"
argument_list|,
literal|"break"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"breakpoints"
argument_list|,
name|breakpoints_info
argument_list|,
literal|"Status of all breakpoints, or breakpoint number NUMBER.\n\ Second column is \"y\" for enabled breakpoint, \"n\" for disabled,\n\ \"o\" for enabled once (disable when hit), \"d\" for enable but delete when hit.\n\ Then come the address and the file/line number.\n\n\ Convenience variable \"$_\" and default examine address for \"x\"\n\ are set to the address of the last breakpoint listed."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

