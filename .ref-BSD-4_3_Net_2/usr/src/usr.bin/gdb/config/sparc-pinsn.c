begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassembler for the sparc.    Copyright (C) 1989 Free Software Foundation, Inc.  This file is part of GDB, the GNU disassembler.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"sparc-opcode.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reg_names
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|freg_names
value|(&reg_names[4 * 8])
end_define

begin_union
union|union
name|sparc_insn
block|{
name|unsigned
name|long
name|int
name|code
decl_stmt|;
struct|struct
block|{
name|unsigned
name|int
name|OP
range|:
literal|2
decl_stmt|;
define|#
directive|define
name|op
value|ldst.OP
name|unsigned
name|int
name|RD
range|:
literal|5
decl_stmt|;
define|#
directive|define
name|rd
value|ldst.RD
name|unsigned
name|int
name|op3
range|:
literal|6
decl_stmt|;
name|unsigned
name|int
name|RS1
range|:
literal|5
decl_stmt|;
define|#
directive|define
name|rs1
value|ldst.RS1
name|unsigned
name|int
name|i
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|ASI
range|:
literal|8
decl_stmt|;
define|#
directive|define
name|asi
value|ldst.ASI
name|unsigned
name|int
name|RS2
range|:
literal|5
decl_stmt|;
define|#
directive|define
name|rs2
value|ldst.RS2
define|#
directive|define
name|shcnt
value|rs2
block|}
name|ldst
struct|;
struct|struct
block|{
name|unsigned
name|int
name|OP
range|:
literal|2
decl_stmt|,
name|RD
range|:
literal|5
decl_stmt|,
name|op3
range|:
literal|6
decl_stmt|,
name|RS1
range|:
literal|5
decl_stmt|,
name|i
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|IMM13
range|:
literal|13
decl_stmt|;
define|#
directive|define
name|imm13
value|IMM13.IMM13
block|}
name|IMM13
struct|;
struct|struct
block|{
name|unsigned
name|int
name|OP
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|a
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|cond
range|:
literal|4
decl_stmt|;
name|unsigned
name|int
name|op2
range|:
literal|3
decl_stmt|;
name|unsigned
name|int
name|DISP22
range|:
literal|22
decl_stmt|;
define|#
directive|define
name|disp22
value|branch.DISP22
block|}
name|branch
struct|;
define|#
directive|define
name|imm22
value|disp22
struct|struct
block|{
name|unsigned
name|int
name|OP
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|DISP30
range|:
literal|30
decl_stmt|;
define|#
directive|define
name|disp30
value|call.DISP30
block|}
name|call
struct|;
block|}
union|;
end_union

begin_comment
comment|/* Nonzero if INSN is the opcode for a delayed branch.  */
end_comment

begin_function
specifier|static
name|int
name|is_delayed_branch
parameter_list|(
name|insn
parameter_list|)
name|union
name|sparc_insn
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMOPCODES
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|opcode
init|=
operator|&
name|sparc_opcodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|->
name|match
operator|&
name|insn
operator|.
name|code
operator|)
operator|==
name|opcode
operator|->
name|match
operator|&&
operator|(
name|opcode
operator|->
name|lose
operator|&
name|insn
operator|.
name|code
operator|)
operator|==
literal|0
operator|&&
operator|(
name|opcode
operator|->
name|delayed
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|opcodes_sorted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print one instruction from MEMADDR on STREAM.  */
end_comment

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|union
name|sparc_insn
name|insn
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|opcodes_sorted
condition|)
block|{
specifier|static
name|int
name|compare_opcodes
parameter_list|()
function_decl|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sparc_opcodes
argument_list|,
name|NUMOPCODES
argument_list|,
sizeof|sizeof
argument_list|(
name|sparc_opcodes
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_opcodes
argument_list|)
expr_stmt|;
name|opcodes_sorted
operator|=
literal|1
expr_stmt|;
block|}
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|insn
argument_list|,
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMOPCODES
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|opcode
init|=
operator|&
name|sparc_opcodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|->
name|match
operator|&
name|insn
operator|.
name|code
operator|)
operator|==
name|opcode
operator|->
name|match
operator|&&
operator|(
name|opcode
operator|->
name|lose
operator|&
name|insn
operator|.
name|code
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Nonzero means that we have found an instruction which has 	     the effect of adding or or'ing the imm13 field to rs1.  */
name|int
name|imm_added_to_rs1
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means that we have found a plus sign in the args 	     field of the opcode table.  */
name|int
name|found_plus
init|=
literal|0
decl_stmt|;
comment|/* Do we have an 'or' instruction where rs1 is the same 	     as rsd, and which has the i bit set?  */
if|if
condition|(
name|opcode
operator|->
name|match
operator|==
literal|0x80102000
operator|&&
name|insn
operator|.
name|rs1
operator|==
name|insn
operator|.
name|rd
condition|)
name|imm_added_to_rs1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|opcode
operator|->
name|args
argument_list|,
literal|'S'
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Reject the special case for `set'. 	       The real `sethi' will match.  */
continue|continue;
if|if
condition|(
name|insn
operator|.
name|rs1
operator|!=
name|insn
operator|.
name|rd
operator|&&
name|index
argument_list|(
name|opcode
operator|->
name|args
argument_list|,
literal|'r'
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Can't do simple format if source and dest are different.  */
continue|continue;
name|fputs_filtered
argument_list|(
name|opcode
operator|->
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|opcode
operator|->
name|args
index|[
literal|0
index|]
operator|!=
literal|','
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|opcode
operator|->
name|args
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'a'
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'+'
case|:
name|found_plus
operator|=
literal|1
expr_stmt|;
comment|/* note fall-through */
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|fputs_filtered
argument_list|(
literal|"0"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
define|#
directive|define
name|reg
parameter_list|(
name|n
parameter_list|)
value|fprintf_filtered (stream, "%%%s", reg_names[n])
case|case
literal|'1'
case|:
case|case
literal|'r'
case|:
name|reg
argument_list|(
name|insn
operator|.
name|rs1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|reg
argument_list|(
name|insn
operator|.
name|rs2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|reg
argument_list|(
name|insn
operator|.
name|rd
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|reg
define|#
directive|define
name|freg
parameter_list|(
name|n
parameter_list|)
value|fprintf_filtered (stream, "%%%s", freg_names[n])
case|case
literal|'e'
case|:
name|freg
argument_list|(
name|insn
operator|.
name|rs1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|freg
argument_list|(
name|insn
operator|.
name|rs2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|freg
argument_list|(
name|insn
operator|.
name|rd
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|freg
define|#
directive|define
name|creg
parameter_list|(
name|n
parameter_list|)
value|fprintf_filtered (stream, "%%c%u", (unsigned int) (n))
case|case
literal|'b'
case|:
name|creg
argument_list|(
name|insn
operator|.
name|rs1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|creg
argument_list|(
name|insn
operator|.
name|rs2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|creg
argument_list|(
name|insn
operator|.
name|rd
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|creg
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%%hi(%#x)"
argument_list|,
operator|(
name|int
operator|)
name|insn
operator|.
name|imm22
operator|<<
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
block|{
comment|/* We cannot trust the compiler to sign-extend 			 when extracting the bitfield, hence the shifts.  */
name|int
name|imm
init|=
operator|(
operator|(
name|int
operator|)
name|insn
operator|.
name|imm13
operator|<<
literal|19
operator|)
operator|>>
literal|19
decl_stmt|;
comment|/* Check to see whether we have a 1+i, and take 			 note of that fact.  			 Note: because of the way we sort the table, 			 we will be matching 1+i rather than i+1, 			 so it is OK to assume that i is after +, 			 not before it.  */
if|if
condition|(
name|found_plus
condition|)
name|imm_added_to_rs1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm
operator|<=
literal|9
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%#x"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
name|print_address
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|memaddr
operator|+
name|insn
operator|.
name|disp30
operator|*
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|(
name|insn
operator|.
name|code
operator|>>
literal|22
operator|)
operator|==
literal|0
condition|)
comment|/* Special case for `unimp'.  Don't try to turn 			 it's operand into a function offset.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%#x"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|insn
operator|.
name|disp22
operator|<<
literal|10
operator|)
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* We cannot trust the compiler to sign-extend 			 when extracting the bitfield, hence the shifts.  */
name|print_address
argument_list|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|memaddr
operator|+
operator|(
operator|(
operator|(
name|int
operator|)
name|insn
operator|.
name|disp22
operator|<<
literal|10
operator|)
operator|>>
literal|10
operator|)
operator|*
literal|4
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%d)"
argument_list|,
operator|(
name|int
operator|)
name|insn
operator|.
name|asi
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fputs_filtered
argument_list|(
literal|"%csr"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fputs_filtered
argument_list|(
literal|"%fsr"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|fputs_filtered
argument_list|(
literal|"%psr"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|fputs_filtered
argument_list|(
literal|"%fq"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|fputs_filtered
argument_list|(
literal|"%cq"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fputs_filtered
argument_list|(
literal|"%tbr"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fputs_filtered
argument_list|(
literal|"%wim"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|fputs_filtered
argument_list|(
literal|"%y"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we are adding or or'ing something to rs1, then 	     check to see whether the previous instruction was 	     a sethi to the same register as in the sethi. 	     If so, attempt to print the result of the add or 	     or (in this context add and or do the same thing) 	     and its symbolic value.  */
if|if
condition|(
name|imm_added_to_rs1
condition|)
block|{
name|union
name|sparc_insn
name|prev_insn
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|errcode
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|-
literal|4
argument_list|,
operator|&
name|prev_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* If it is a delayed branch, we need to look at the 		     instruction before the delayed branch.  This handles 		     sequences such as  		     sethi %o1, %hi(_foo), %o1 		     call _printf 		     or %o1, %lo(_foo), %o1 		     */
if|if
condition|(
name|is_delayed_branch
argument_list|(
name|prev_insn
argument_list|)
condition|)
name|errcode
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|-
literal|8
argument_list|,
operator|&
name|prev_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If there was a problem reading memory, then assume 		 the previous instruction was not sethi.  */
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* Is it sethi to the same register?  */
if|if
condition|(
operator|(
name|prev_insn
operator|.
name|code
operator|&
literal|0xc1c00000
operator|)
operator|==
literal|0x01000000
operator|&&
name|prev_insn
operator|.
name|rd
operator|==
name|insn
operator|.
name|rs1
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t! "
argument_list|)
expr_stmt|;
comment|/* We cannot trust the compiler to sign-extend 			 when extracting the bitfield, hence the shifts.  */
name|print_address
argument_list|(
operator|(
operator|(
name|int
operator|)
name|prev_insn
operator|.
name|imm22
operator|<<
literal|10
operator|)
operator||
operator|(
name|insn
operator|.
name|imm13
operator|<<
literal|19
operator|)
operator|>>
literal|19
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
return|;
block|}
block|}
name|fprintf_filtered
argument_list|(
literal|"%#8x"
argument_list|,
name|insn
operator|.
name|code
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare opcodes A and B.  */
end_comment

begin_function
specifier|static
name|int
name|compare_opcodes
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|sparc_opcode
modifier|*
name|op0
init|=
operator|(
expr|struct
name|sparc_opcode
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|sparc_opcode
modifier|*
name|op1
init|=
operator|(
expr|struct
name|sparc_opcode
operator|*
operator|)
name|b
decl_stmt|;
name|unsigned
name|long
name|int
name|match0
init|=
name|op0
operator|->
name|match
decl_stmt|,
name|match1
init|=
name|op1
operator|->
name|match
decl_stmt|;
name|unsigned
name|long
name|int
name|lose0
init|=
name|op0
operator|->
name|lose
decl_stmt|,
name|lose1
init|=
name|op1
operator|->
name|lose
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If a bit is set in both match and lose, there is something      wrong with the opcode table.  */
if|if
condition|(
name|match0
operator|&
name|lose0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error:  bad sparc-opcode.h: \"%s\", %#.8x, %#.8x\n"
argument_list|,
name|op0
operator|->
name|name
argument_list|,
name|match0
argument_list|,
name|lose0
argument_list|)
expr_stmt|;
name|op0
operator|->
name|lose
operator|&=
operator|~
name|op0
operator|->
name|match
expr_stmt|;
name|lose0
operator|=
name|op0
operator|->
name|lose
expr_stmt|;
block|}
if|if
condition|(
name|match1
operator|&
name|lose1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error: bad sparc-opcode.h: \"%s\", %#.8x, %#.8x\n"
argument_list|,
name|op1
operator|->
name|name
argument_list|,
name|match1
argument_list|,
name|lose1
argument_list|)
expr_stmt|;
name|op1
operator|->
name|lose
operator|&=
operator|~
name|op1
operator|->
name|match
expr_stmt|;
name|lose1
operator|=
name|op1
operator|->
name|lose
expr_stmt|;
block|}
comment|/* Because the bits that are variable in one opcode are constant in      another, it is important to order the opcodes in the right order.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|int
name|x
init|=
literal|1
operator|<<
name|i
decl_stmt|;
name|int
name|x0
init|=
operator|(
name|match0
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|x1
init|=
operator|(
name|match1
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|x1
condition|)
return|return
name|x1
operator|-
name|x0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|int
name|x
init|=
literal|1
operator|<<
name|i
decl_stmt|;
name|int
name|x0
init|=
operator|(
name|lose0
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|x1
init|=
operator|(
name|lose1
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|x1
condition|)
return|return
name|x1
operator|-
name|x0
return|;
block|}
comment|/* They are functionally equal.  So as long as the opcode table is      valid, we can put whichever one first we want, on aesthetic grounds.  */
block|{
name|int
name|length_diff
init|=
name|strlen
argument_list|(
name|op0
operator|->
name|args
argument_list|)
operator|-
name|strlen
argument_list|(
name|op1
operator|->
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|length_diff
operator|!=
literal|0
condition|)
comment|/* Put the one with fewer arguments first.  */
return|return
name|length_diff
return|;
block|}
comment|/* Put 1+i before i+1.  */
block|{
name|char
modifier|*
name|p0
init|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|op0
operator|->
name|args
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p1
init|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|op1
operator|->
name|args
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p0
operator|&&
name|p1
condition|)
block|{
comment|/* There is a plus in both operands.  Note that a plus 	   sign cannot be the first character in args, 	   so the following [-1]'s are valid.  */
if|if
condition|(
name|p0
index|[
operator|-
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
comment|/* op0 is i+1 and op1 is 1+i, so op1 goes first.  */
return|return
literal|1
return|;
if|if
condition|(
name|p0
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'i'
condition|)
comment|/* op0 is 1+i and op1 is i+1, so op0 goes first.  */
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* They are, as far as we can tell, identical.      Since qsort may have rearranged the table partially, there is      no way to tell which one was first in the opcode table as      written, so just say there are equal.  */
return|return
literal|0
return|;
block|}
end_block

end_unit

