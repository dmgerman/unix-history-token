begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for GDB when running under Unix.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* many 387-specific items of use taken from i386-dep.c */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_function_decl
specifier|static
name|long
name|i386_get_frame_setup
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|i386_follow_jump
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XPT_DEBUG doesn't work yet under Dynix 3.0.12, but UNDEBUG does... */
end_comment

begin_define
define|#
directive|define
name|PTRACE_ATTACH
value|XPT_DEBUG
end_define

begin_define
define|#
directive|define
name|PTRACE_DETACH
value|XPT_UNDEBUG
end_define

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|TERMINAL
value|struct sgttyb
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are debugging an attached outside process    rather than an inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function simply calls ptrace with the given arguments.      It exists so that all calls to ptrace are isolated in this     machine-dependent file. */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|int
name|request
decl_stmt|,
name|pid
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|;
block|{
return|return
name|ptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
return|;
block|}
end_function

begin_macro
name|kill_inferior
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
literal|8
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This is used when GDB is exiting.  It gives less chance of error.*/
end_comment

begin_macro
name|kill_inferior_fast
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
literal|8
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_resume
argument_list|(
name|step
argument_list|,
name|signal
argument_list|)
expr_stmt|;
else|else
block|{
name|ptrace
argument_list|(
name|step
condition|?
literal|9
else|:
literal|7
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/* Start debugging the process whose number is PID.  */
end_comment

begin_macro
name|attach
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_ATTACH
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
name|pid
return|;
block|}
end_block

begin_comment
comment|/* Stop debugging the process whose number is PID    and continue it with signal number SIGNAL.    SIGNAL = 0 means just continue it.  */
end_comment

begin_function
name|void
name|detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_DETACH
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_escape
end_escape

begin_macro
name|store_inferior_registers
argument_list|(
argument|regno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|regno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|pt_regset
name|regs
decl_stmt|;
name|int
name|reg_tmp
decl_stmt|,
name|i
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|regno
condition|)
block|{
name|regs
operator|.
name|pr_eax
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ebx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|5
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ecx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|2
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_edx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_esi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|6
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_edi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|7
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_esp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|14
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ebp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|15
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_eip
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_flags
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|17
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|regs
operator|.
name|pr_fpa
operator|.
name|fpa_regs
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP1_REGNUM
operator|+
name|i
argument_list|)
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_tmp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
expr_stmt|;
name|ptrace
argument_list|(
name|XPT_RREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
literal|0
case|:
name|regs
operator|.
name|pr_eax
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|regs
operator|.
name|pr_ebx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|5
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|regs
operator|.
name|pr_ecx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|2
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|regs
operator|.
name|pr_edx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|regs
operator|.
name|pr_esi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|6
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|regs
operator|.
name|pr_edi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|7
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|regs
operator|.
name|pr_ebp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|15
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|regs
operator|.
name|pr_esp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|14
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|regs
operator|.
name|pr_eip
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|regs
operator|.
name|pr_flags
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|17
argument_list|)
index|]
expr_stmt|;
break|break;
block|}
block|}
name|ptrace
argument_list|(
name|XPT_WREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|fetch_inferior_registers
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pt_regset
name|regs
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|ptrace
argument_list|(
name|XPT_RREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_eax
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|5
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ebx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|2
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ecx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_edx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|6
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_esi
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|7
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_edi
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|15
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ebp
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|14
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_esp
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_eip
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|17
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FPA_NREGS
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP1_REGNUM
operator|+
name|i
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_fpa
operator|.
name|fpa_regs
index|[
name|i
index|]
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|0
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|3
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|1
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|4
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|2
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|8
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|3
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|9
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|4
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|10
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|5
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|11
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|6
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|12
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|7
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|13
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  */
end_comment

begin_macro
name|read_inferior_memory
argument_list|(
argument|memaddr
argument_list|,
argument|myaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|memaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|buffer
index|[
name|i
index|]
operator|=
name|remote_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|remote_debugging
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
name|remote_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|remote_debugging
condition|)
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|remote_fetch_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|bcopy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_store_word
argument_list|(
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|ptrace
argument_list|(
literal|4
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Recognize COFF format systems because a.out.h defines AOUTHDR.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AOUTHDR
end_ifdef

begin_define
define|#
directive|define
name|COFF_FORMAT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|N_TXTADDR
end_ifndef

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|hdr
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_TXTADDR */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_DATADDR
end_ifndef

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|hdr
parameter_list|)
value|hdr.a_text
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_DATADDR */
end_comment

begin_comment
comment|/* Make COFF and non-COFF names for things a little more compatible    to reduce conditionals later.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_FORMAT
end_ifdef

begin_define
define|#
directive|define
name|a_magic
value|magic
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|AOUTHDR
value|struct exec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|exec_file_display_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* File names of core file and executable file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|corefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|execfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptors on which core file and executable file are open.    Note that the execchan is closed when an inferior is created    and reopened if the inferior dies or is killed.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|corechan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|execchan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last modification time of executable file.    Also used in source.c to compare against mtime of a source file.  */
end_comment

begin_decl_stmt
name|int
name|exec_mtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of the two areas of memory in the core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of two areas of memory in the exec file.    Note that the data area in the exec file is used only when there is no core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of text area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|text_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of stack area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stack_offset
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_FORMAT
end_ifdef

begin_comment
comment|/* various coff data structures */
end_comment

begin_decl_stmt
specifier|extern
name|FILHDR
name|file_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SCNHDR
name|text_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SCNHDR
name|data_hdr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not COFF_FORMAT */
end_comment

begin_comment
comment|/* a.out header saved in core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|core_aouthdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header of exec file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|exec_aouthdr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|validate_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|int
name|register_addr
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|core_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 4.2-style (and perhaps also sysV-style) core dump file.  */
block|{
name|struct
name|user
name|u
decl_stmt|;
name|int
name|reg_offset
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|NBPG
operator|*
operator|(
name|u
operator|.
name|u_dsize
operator|-
name|u
operator|.
name|u_tsize
operator|)
expr_stmt|;
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|data_offset
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|stack_offset
operator|=
name|ctob
argument_list|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|-
name|u
operator|.
name|u_tsize
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
name|printf
argument_list|(
literal|"u.u_tsize= %#x, u.u_dsize= %#x, u.u_ssize= %#x, stack_off= %#x\n"
argument_list|,
name|u
operator|.
name|u_tsize
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|,
name|stack_offset
argument_list|)
expr_stmt|;
name|core_aouthdr
operator|.
name|a_magic
operator|=
literal|0
expr_stmt|;
comment|/* Read the register values out of the core file and store 	   them where `read_register' will find them.  */
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|register_addr
argument_list|(
name|regno
argument_list|,
name|reg_offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      set_current_frame (read_register (FP_REGNUM));*/
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|exec_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
if|if
condition|(
name|execfile
condition|)
name|free
argument_list|(
name|execfile
argument_list|)
expr_stmt|;
name|execfile
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|-=
name|exec_data_start
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|text_end
operator|=
literal|0
expr_stmt|;
name|exec_data_start
operator|=
literal|0
expr_stmt|;
name|exec_data_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execchan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
name|execchan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|execchan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|execchan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_FORMAT
block|{
name|int
name|aout_hdrsize
decl_stmt|;
name|int
name|num_sections
decl_stmt|;
if|if
condition|(
name|read_file_hdr
argument_list|(
name|execchan
argument_list|,
operator|&
name|file_hdr
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": not in executable format."
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
name|aout_hdrsize
operator|=
name|file_hdr
operator|.
name|f_opthdr
expr_stmt|;
name|num_sections
operator|=
name|file_hdr
operator|.
name|f_nscns
expr_stmt|;
if|if
condition|(
name|read_aout_hdr
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read optional aouthdr"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_section_hdr
argument_list|(
name|execchan
argument_list|,
name|_TEXT
argument_list|,
operator|&
name|text_hdr
argument_list|,
name|num_sections
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read text section header"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_section_hdr
argument_list|(
name|execchan
argument_list|,
name|_DATA
argument_list|,
operator|&
name|data_hdr
argument_list|,
name|num_sections
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read data section header"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
name|text_start
operator|=
name|exec_aouthdr
operator|.
name|text_start
expr_stmt|;
name|text_end
operator|=
name|text_start
operator|+
name|exec_aouthdr
operator|.
name|tsize
expr_stmt|;
name|text_offset
operator|=
name|text_hdr
operator|.
name|s_scnptr
expr_stmt|;
name|exec_data_start
operator|=
name|exec_aouthdr
operator|.
name|data_start
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|dsize
expr_stmt|;
name|exec_data_offset
operator|=
name|data_hdr
operator|.
name|s_scnptr
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|+=
name|exec_data_start
expr_stmt|;
name|exec_mtime
operator|=
name|file_hdr
operator|.
name|f_timdat
expr_stmt|;
block|}
else|#
directive|else
comment|/* not COFF_FORMAT */
block|{
name|struct
name|stat
name|st_exec
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|text_start
operator|=
name|N_ADDRADJ
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_start
operator|=
name|round
argument_list|(
name|exec_aouthdr
operator|.
name|a_text
argument_list|,
name|NBPG
operator|*
name|CLSIZE
argument_list|)
expr_stmt|;
name|text_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|text_end
operator|=
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|exec_data_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|execchan
argument_list|,
operator|&
name|st_exec
argument_list|)
expr_stmt|;
name|exec_mtime
operator|=
name|st_exec
operator|.
name|st_mtime
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not COFF_FORMAT */
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* rounds 'one' up to divide evenly by 'two' */
end_comment

begin_function
name|int
name|round
parameter_list|(
name|one
parameter_list|,
name|two
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|,
name|two
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|one
operator|/
name|two
operator|)
operator|*
name|two
expr_stmt|;
if|if
condition|(
name|one
operator|!=
name|temp
condition|)
block|{
name|temp
operator|+=
name|two
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|codestream_buf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_cnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|codestream_tell
parameter_list|()
value|(codestream_addr + codestream_off)
end_define

begin_define
define|#
directive|define
name|codestream_peek
parameter_list|()
value|(codestream_cnt == 0 ? \ 			   codestream_fill(1): codestream_buf[codestream_off])
end_define

begin_define
define|#
directive|define
name|codestream_get
parameter_list|()
value|(codestream_cnt-- == 0 ? \ 			 codestream_fill(0) : codestream_buf[codestream_off++])
end_define

begin_function
specifier|static
name|unsigned
name|char
name|codestream_fill
parameter_list|(
name|peek_flag
parameter_list|)
block|{
name|codestream_addr
operator|=
name|codestream_next_addr
expr_stmt|;
name|codestream_next_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|codestream_off
operator|=
literal|0
expr_stmt|;
name|codestream_cnt
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|codestream_addr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|codestream_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_flag
condition|)
return|return
operator|(
name|codestream_peek
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_seek
parameter_list|(
name|place
parameter_list|)
block|{
name|codestream_next_addr
operator|=
name|place
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|codestream_cnt
operator|=
literal|0
expr_stmt|;
name|codestream_fill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|codestream_tell
argument_list|()
operator|!=
name|place
condition|)
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_read
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Following macro translates i386 opcode register numbers to Symmetry  * register numbers.  This is used by FRAME_FIND_SAVED_REGS.  *  *           %eax  %ecx  %edx  %ebx  %esp  %ebp  %esi  %edi  * i386        0     1     2     3     4     5     6     7  * Symmetry    0     2     1     5    14    15     6     7  *  */
end_comment

begin_define
define|#
directive|define
name|I386_REGNO_TO_SYMMETRY
parameter_list|(
name|n
parameter_list|)
define|\
value|((n)==0?0 :(n)==1?2 :(n)==2?1 :(n)==3?5 :(n)==4?14 :(n)==5?15 :(n))
end_define

begin_comment
comment|/* from i386-dep.c */
end_comment

begin_macro
name|i386_frame_find_saved_regs
argument_list|(
argument|fip
argument_list|,
argument|fsrp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|fip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame_saved_regs
modifier|*
name|fsrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|long
name|locals
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|CORE_ADDR
name|dummy_bottom
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|fsrp
argument_list|,
sizeof|sizeof
expr|*
name|fsrp
argument_list|)
expr_stmt|;
comment|/* if frame is the end of a dummy, compute where the    * beginning would be    */
name|dummy_bottom
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|NUM_REGS
operator|*
literal|4
operator|-
name|CALL_DUMMY_LENGTH
expr_stmt|;
comment|/* check if the PC is in the stack, in a dummy frame */
if|if
condition|(
name|dummy_bottom
operator|<=
name|fip
operator|->
name|pc
operator|&&
name|fip
operator|->
name|pc
operator|<=
name|fip
operator|->
name|frame
condition|)
block|{
comment|/* all regs were saved by push_call_dummy () */
name|adr
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|fsrp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|adr
expr_stmt|;
name|adr
operator|-=
literal|4
expr_stmt|;
block|}
return|return;
block|}
name|locals
operator|=
name|i386_get_frame_setup
argument_list|(
name|get_pc_function_start
argument_list|(
name|fip
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|>=
literal|0
condition|)
block|{
name|adr
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|locals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|fsrp
operator|->
name|regs
index|[
name|I386_REGNO_TO_SYMMETRY
argument_list|(
name|op
operator|-
literal|0x50
argument_list|)
index|]
operator|=
name|adr
expr_stmt|;
name|adr
operator|-=
literal|4
expr_stmt|;
block|}
block|}
name|fsrp
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
operator|+
literal|4
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
block|}
end_block

begin_comment
comment|/* from i386-dep.c */
end_comment

begin_expr_stmt
specifier|static
name|print_387_control_word
argument_list|(
argument|control
argument_list|)
name|unsigned
name|short
name|control
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"control 0x%04x: "
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"compute to "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|8
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"24 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"(bad); "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"53 bits; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"64 bits; "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"round "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|control
operator|>>
literal|10
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"NEAREST; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"DOWN; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"UP; "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"CHOP; "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|control
operator|&
literal|0x3f
condition|)
block|{
name|printf
argument_list|(
literal|"mask:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" INVALID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" DENORM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" DIVZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" OVERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" UNDERF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" LOS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
literal|0xe080
condition|)
name|printf
argument_list|(
literal|"warning: reserved bits on 0x%x\n"
argument_list|,
name|control
operator|&
literal|0xe080
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|print_387_status_word
argument_list|(
argument|status
argument_list|)
name|unsigned
name|short
name|status
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"status %#04x: "
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"exceptions:"
argument_list|)
expr_stmt|;
comment|/* exception names match<machine/fpu.h> */
if|if
condition|(
name|status
operator|&
literal|0x0001
condition|)
name|printf
argument_list|(
literal|" FLTINV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0002
condition|)
name|printf
argument_list|(
literal|" FLTDEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0004
condition|)
name|printf
argument_list|(
literal|" FLTDIV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0008
condition|)
name|printf
argument_list|(
literal|" FLTOVF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0010
condition|)
name|printf
argument_list|(
literal|" FLTUND"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0020
condition|)
name|printf
argument_list|(
literal|" FLTPRE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0040
condition|)
name|printf
argument_list|(
literal|" FLTSTK"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"flags: %d%d%d%d; "
argument_list|,
operator|(
name|status
operator|&
literal|0x4000
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0400
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0200
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|status
operator|&
literal|0x0100
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"top %d\n"
argument_list|,
operator|(
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|print_fpu_status
argument_list|(
argument|ep
argument_list|)
expr|struct
name|pt_regset
name|ep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"80387:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_ip
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" not in use.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
operator|!=
literal|0
condition|)
block|{
name|print_387_status_word
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"last exception: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opcode 0x%x; "
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pc 0x%x:0x%x; "
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_cs
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"operand 0x%x:0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_data_offset
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_op_sel
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|"regno  tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|double
name|val
decl_stmt|;
name|printf
argument_list|(
literal|"%s %d: "
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|,
name|fpreg
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
name|fpreg
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
name|fpreg
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd1
condition|)
name|printf
argument_list|(
literal|"warning: rsvd1 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd2
condition|)
name|printf
argument_list|(
literal|"warning: rsvd2 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd3
condition|)
name|printf
argument_list|(
literal|"warning: rsvd3 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd5
condition|)
name|printf
argument_list|(
literal|"warning: rsvd5 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd5
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_1167_control_word
argument_list|(
argument|pcr
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|int
name|pcr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pcr_tmp
decl_stmt|;
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_MODE
expr_stmt|;
name|printf
argument_list|(
literal|"\tMODE= %#x; RND= %#x "
argument_list|,
name|pcr_tmp
argument_list|,
name|pcr_tmp
operator|&
literal|12
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcr_tmp
operator|&
literal|12
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"RN (Nearest Value)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"RZ (Zero)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"RP (Positive Infinity)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"RM (Negative Infinity)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"; IRND= %d "
argument_list|,
name|pcr_tmp
operator|&
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|pcr_tmp
operator|&
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"(same as RND)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(toward zero)\n"
argument_list|)
expr_stmt|;
block|}
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_EM
expr_stmt|;
name|printf
argument_list|(
literal|"\tEM= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_DM
condition|)
name|printf
argument_list|(
literal|" DM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_UOM
condition|)
name|printf
argument_list|(
literal|" UOM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_PM
condition|)
name|printf
argument_list|(
literal|" PM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_UM
condition|)
name|printf
argument_list|(
literal|" UM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_OM
condition|)
name|printf
argument_list|(
literal|" OM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_ZM
condition|)
name|printf
argument_list|(
literal|" ZM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_IM
condition|)
name|printf
argument_list|(
literal|" IM"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pcr_tmp
operator|=
name|FPA_PCR_CC
expr_stmt|;
name|printf
argument_list|(
literal|"\tCC= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_20MHZ
condition|)
name|printf
argument_list|(
literal|" 20MHZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_Z
condition|)
name|printf
argument_list|(
literal|" Z"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_C2
condition|)
name|printf
argument_list|(
literal|" C2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_C1
condition|)
name|printf
argument_list|(
literal|" C1"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcr_tmp
condition|)
block|{
case|case
name|FPA_PCR_CC_Z
case|:
name|printf
argument_list|(
literal|" (Equal)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPA_PCR_CC_C1
case|:
name|printf
argument_list|(
literal|" (Less than)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|" (Greater than)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPA_PCR_CC_Z
operator||
name|FPA_PCR_CC_C1
operator||
name|FPA_PCR_CC_C2
case|:
name|printf
argument_list|(
literal|" (Unordered)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" (Undefined)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_AE
expr_stmt|;
name|printf
argument_list|(
literal|"\tAE= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_DE
condition|)
name|printf
argument_list|(
literal|" DE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_UOE
condition|)
name|printf
argument_list|(
literal|" UOE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_PE
condition|)
name|printf
argument_list|(
literal|" PE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_UE
condition|)
name|printf
argument_list|(
literal|" UE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_OE
condition|)
name|printf
argument_list|(
literal|" OE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_ZE
condition|)
name|printf
argument_list|(
literal|" ZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_EE
condition|)
name|printf
argument_list|(
literal|" EE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_IE
condition|)
name|printf
argument_list|(
literal|" IE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_1167_regs
argument_list|(
argument|regs
argument_list|)
end_macro

begin_decl_stmt
name|long
name|regs
index|[
name|FPA_NREGS
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
block|}
name|xd
union|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|long
name|l
decl_stmt|;
block|}
name|xf
union|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FPA_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|xf
operator|.
name|l
operator|=
name|regs
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%%fp%d: raw= %#x, single= %f"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|,
name|xf
operator|.
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xd
operator|.
name|l
index|[
literal|1
index|]
operator|=
name|regs
index|[
name|i
index|]
expr_stmt|;
name|xd
operator|.
name|l
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|printf
argument_list|(
literal|", double= %f\n"
argument_list|,
name|xd
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|print_fpa_status
argument_list|(
argument|ep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pt_regset
name|ep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"WTL 1167:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_pcr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_1167_control_word
argument_list|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_pcr
argument_list|)
expr_stmt|;
name|print_1167_regs
argument_list|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_regs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" not in use.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|i386_float_info
argument_list|()
end_macro

begin_block
block|{
name|char
name|ubuf
index|[
name|UPAGES
operator|*
name|NBPG
index|]
decl_stmt|;
name|struct
name|pt_regset
name|regset
decl_stmt|;
specifier|extern
name|int
name|corechan
decl_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|call_ptrace
argument_list|(
name|XPT_RREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|regset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lseek
argument_list|(
name|corechan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"seek on core file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
name|ubuf
argument_list|,
name|UPAGES
operator|*
name|NBPG
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"read on core file"
argument_list|)
expr_stmt|;
block|}
comment|/* only interested in the floating point registers */
name|regset
operator|.
name|pr_fpu
operator|=
operator|(
operator|(
expr|struct
name|user
operator|*
operator|)
name|ubuf
operator|)
operator|->
name|u_fpusave
expr_stmt|;
name|regset
operator|.
name|pr_fpa
operator|=
operator|(
operator|(
expr|struct
name|user
operator|*
operator|)
name|ubuf
operator|)
operator|->
name|u_fpasave
expr_stmt|;
block|}
name|print_fpu_status
argument_list|(
name|regset
argument_list|)
expr_stmt|;
name|print_fpa_status
argument_list|(
name|regset
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|i387_to_double
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* push extended mode on 387 stack, then pop in double mode    *    * first, set exception masks so no error is generated -    * number will be rounded to inf or 0, if necessary     */
asm|asm ("pushl %eax");
comment|/* grab a stack slot */
asm|asm ("fstcw (%esp)");
comment|/* get 387 control word */
asm|asm ("movl (%esp),%eax");
comment|/* save old value */
asm|asm ("orl $0x3f,%eax");
comment|/* mask all exceptions */
asm|asm ("pushl %eax");
asm|asm ("fldcw (%esp)");
comment|/* load new value into 387 */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldt (%eax)");
comment|/* push extended number on 387 stack */
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpl (%eax)");
comment|/* pop double */
asm|asm ("fwait");
asm|asm ("popl %eax");
comment|/* flush modified control word */
asm|asm ("fnclex");
comment|/* clear exceptions */
asm|asm ("fldcw (%esp)");
comment|/* restore original control word */
asm|asm ("popl %eax");
comment|/* flush saved copy */
block|}
end_block

begin_macro
name|double_to_i387
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* push double mode on 387 stack, then pop in extended mode    * no errors are possible because every 64-bit pattern    * can be converted to an extended    */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldl (%eax)");
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpt (%eax)");
asm|asm ("fwait");
block|}
end_block

begin_function
specifier|static
name|long
name|i386_get_frame_setup
parameter_list|(
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|codestream_seek
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|i386_follow_jump
argument_list|()
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x58
condition|)
comment|/* popl %eax */
block|{
comment|/*        * this function must start with        *         *    popl %eax		  0x58        *    xchgl %eax, (%esp)  0x87 0x04 0x24        * or xchgl %eax, 0(%esp) 0x87 0x44 0x24 0x00        *        * (the system 5 compiler puts out the second xchg        * inst, and the assembler doesn't try to optimize it,        * so the 'sib' form gets generated)        *         * this sequence is used to get the address of the return        * buffer for a function that returns a structure        */
name|int
name|pos
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto1
index|[
literal|3
index|]
init|=
block|{
literal|0x87
block|,
literal|0x04
block|,
literal|0x24
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto2
index|[
literal|4
index|]
init|=
block|{
literal|0x87
block|,
literal|0x44
block|,
literal|0x24
block|,
literal|0x00
block|}
decl_stmt|;
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|proto1
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|proto2
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|4
expr_stmt|;
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* update next opcode */
block|}
if|if
condition|(
name|op
operator|==
literal|0x55
condition|)
comment|/* pushl %esp */
block|{
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0x8b
condition|)
comment|/* movl %esp, %ebp (2bytes) */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*        * check for stack adjustment         *        *  subl $XXX, %esp        *        * note: you can't subtract a 16 bit immediate        * from a 32 bit reg, so we don't have to worry        * about a data16 prefix         */
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
comment|/* subl with 8 bit immed */
block|{
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* subl with signed byte immediate  	   * (though it wouldn't make sense to be negative) 	   */
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
comment|/* subl with 32 bit immed */
block|{
name|int
name|locals
decl_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* subl with 32 bit immediate */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|locals
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|locals
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0xc8
condition|)
block|{
comment|/* enter instruction: arg is 16 unsigned immed */
name|unsigned
name|short
name|slocals
decl_stmt|;
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|slocals
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* flush final byte of enter instruction */
return|return
operator|(
name|slocals
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* next instruction is a jump, move to target */
end_comment

begin_expr_stmt
specifier|static
name|i386_follow_jump
argument_list|()
block|{
name|int
name|long_delta
block|;
name|short
name|short_delta
block|;
name|char
name|byte_delta
block|;
name|int
name|data16
block|;
name|int
name|pos
block|;
name|pos
operator|=
name|codestream_tell
argument_list|()
block|;
name|data16
operator|=
literal|0
block|;
if|if
condition|(
name|codestream_peek
argument_list|()
operator|==
literal|0x66
condition|)
block|{
name|codestream_get
argument_list|()
expr_stmt|;
name|data16
operator|=
literal|1
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0xe9
case|:
comment|/* relative jump: if data16 == 0, disp32, else disp16 */
if|if
condition|(
name|data16
condition|)
block|{
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|short_delta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|short_delta
operator|+
literal|3
expr_stmt|;
comment|/* include size of jmp inst */
block|}
else|else
block|{
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|long_delta
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|long_delta
operator|+
literal|5
expr_stmt|;
block|}
break|break;
case|case
literal|0xeb
case|:
comment|/* relative jump, disp8 (ignore data16) */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|byte_delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|byte_delta
operator|+
literal|2
expr_stmt|;
break|break;
block|}
end_switch

begin_expr_stmt
name|codestream_seek
argument_list|(
name|pos
operator|+
name|data16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* return pc of first real instruction */
end_comment

begin_comment
comment|/* from i386-dep.c */
end_comment

begin_expr_stmt
unit|i386_skip_prologue
operator|(
name|pc
operator|)
block|{
name|unsigned
name|char
name|op
block|;
name|int
name|i
block|;
if|if
condition|(
name|i386_get_frame_setup
argument_list|(
name|pc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|pc
operator|)
return|;
end_expr_stmt

begin_comment
comment|/* found valid frame setup - codestream now points to     * start of push instructions for saving registers    */
end_comment

begin_comment
comment|/* skip over register saves */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
comment|/* break if not pushl inst */
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|i386_follow_jump
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|codestream_tell
argument_list|()
operator|)
return|;
end_return

begin_expr_stmt
unit|}  symmetry_extract_return_value
operator|(
name|type
operator|,
name|regbuf
operator|,
name|valbuf
operator|)
expr|struct
name|type
operator|*
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|regbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|valbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|l
index|[
literal|2
index|]
decl_stmt|;
block|}
name|xd
union|;
name|int
name|i
decl_stmt|;
name|float
name|f
decl_stmt|;
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_function_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"1167_flt"
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|misc_function_count
condition|)
block|{
comment|/* found "1167_flt" means 1167, %fp2-%fp3 */
comment|/* float& double; 19= %fp2, 20= %fp3 */
comment|/* no single precision on 1167 */
name|xd
operator|.
name|l
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
literal|19
argument_list|)
index|]
operator|)
expr_stmt|;
name|xd
operator|.
name|l
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
literal|20
argument_list|)
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|f
operator|=
operator|(
name|float
operator|)
name|xd
operator|.
name|d
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|f
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|bcopy
argument_list|(
operator|&
name|xd
operator|.
name|d
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unknown floating point size"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 387 %st(0), gcc uses this */
name|i387_to_double
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
literal|3
argument_list|)
index|]
operator|)
argument_list|,
operator|&
name|xd
operator|.
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
comment|/* float */
name|f
operator|=
operator|(
name|float
operator|)
name|xd
operator|.
name|d
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|f
argument_list|,
name|valbuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* double */
name|bcopy
argument_list|(
operator|&
name|xd
operator|.
name|d
argument_list|,
name|valbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unknown floating point size"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|regbuf
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

