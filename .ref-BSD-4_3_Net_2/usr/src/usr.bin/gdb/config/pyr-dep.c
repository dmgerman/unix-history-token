begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for GDB when running under Unix.    Copyright (C) 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* #include<fcntl.h>  Can we live without this?  */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|N_SET_MAGIC
end_ifndef

begin_define
define|#
directive|define
name|N_SET_MAGIC
parameter_list|(
name|exec
parameter_list|,
name|val
parameter_list|)
value|((exec).a_magic = (val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This function simply calls ptrace with the given arguments.      It exists so that all calls to ptrace are isolated in this     machine-dependent file. */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|int
name|request
decl_stmt|,
name|pid
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|;
block|{
return|return
name|ptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
return|;
block|}
end_function

begin_macro
name|kill_inferior
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
literal|8
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This is used when GDB is exiting.  It gives less chance of error.*/
end_comment

begin_macro
name|kill_inferior_fast
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ptrace
argument_list|(
literal|8
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_resume
argument_list|(
name|step
argument_list|,
name|signal
argument_list|)
expr_stmt|;
else|else
block|{
name|ptrace
argument_list|(
name|step
condition|?
literal|9
else|:
literal|7
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|fetch_inferior_registers
parameter_list|()
block|{
specifier|register
name|int
name|regno
decl_stmt|,
name|datum
decl_stmt|;
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|int
name|reg_buf
index|[
name|NUM_REGS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
specifier|register
name|int
name|skipped_frames
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_fetch_registers
argument_list|()
expr_stmt|;
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|64
condition|;
name|regno
operator|++
control|)
block|{
name|reg_buf
index|[
name|regno
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
name|regno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf
argument_list|(
literal|"Fetching %s from inferior, got %0x\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_buf
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
if|if
condition|(
name|reg_buf
index|[
name|regno
index|]
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EIO
condition|)
block|{
name|printf
argument_list|(
literal|"fetch_interior_registers: fetching %s from inferior\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|reg_buf
operator|+
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* that leaves regs 64, 65, and 66 */
name|datum
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_csp
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: Find the Current Frame Pointer (CFP). CFP is a global 	 register (ie, NOT windowed), that gets saved in a frame iff 	 the code for that frame has a prologue (ie, "adsf N").  If 	 there is a prologue, the adsf insn saves the old cfp in 	 pr13, cfp is set to sp, and N bytes of locals are allocated 	 (sp is decremented by n). 	 This makes finding CFP hard. I guess the right way to do it 	 is:  	     - If this is the innermost frame, believe ptrace() or 	     the core area. 	     - Otherwise: 		 Find the first insn of the current frame. 		 - find the saved pc; 		 - find the call insn that saved it; 		 - figure out where the call is to; 		 - if the first insn is an adsf, we got a frame 		   pointer. */
comment|/* Normal processors have separate stack pointers for user and          kernel mode. Getting the last user mode frame on such 	 machines is easy: the kernel context of the ptrace()'d 	 process is on the kernel stack, and the USP points to what 	 we want. But Pyramids only have a single cfp for both user and 	 kernel mode.  And processes being ptrace()'d have some 	 kernel-context control frames on their stack. 	 To avoid tracing back into the kernel context of an inferior, 	 we skip 0 or more contiguous control frames where the pc is 	 in the kernel. */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|inferior_saved_pc
decl_stmt|;
name|inferior_saved_pc
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|datum
operator|+
operator|(
operator|(
literal|32
operator|+
literal|15
operator|)
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_saved_pc
operator|>
literal|0
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf
argument_list|(
literal|"skipping kernel frame %08x, pc=%08x\n"
argument_list|,
name|datum
argument_list|,
name|inferior_saved_pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
name|skipped_frames
operator|++
expr_stmt|;
name|datum
operator|-=
name|CONTROL_STACK_FRAME_SIZE
expr_stmt|;
block|}
name|reg_buf
index|[
name|CSP_REGNUM
index|]
operator|=
name|datum
expr_stmt|;
name|supply_register
argument_list|(
name|CSP_REGNUM
argument_list|,
name|reg_buf
operator|+
name|CSP_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
if|if
condition|(
name|skipped_frames
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"skipped %d frames from %x to %x; cfp was %x, now %x\n"
argument_list|,
name|skipped_frames
argument_list|,
name|reg_buf
index|[
name|CSP_REGNUM
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_macro
name|store_inferior_registers
argument_list|(
argument|regno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|regno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
literal|0
operator|<=
name|regno
operator|)
operator|&&
operator|(
name|regno
operator|<
literal|64
operator|)
condition|)
block|{
comment|/*regaddr = register_addr (regno, offset);*/
name|regaddr
operator|=
name|regno
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
comment|/*regaddr = register_addr (regno, offset);*/
name|regaddr
operator|=
name|regno
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing all regs, number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.     On failure (cannot read from inferior, usually because address is out    of bounds) returns the value of errno. */
end_comment

begin_function
name|int
name|read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/*This is now done by read_memory, because when this function did it,   reading a byte or short int hardware port read whole longs, causing   serious side effects   such as bus errors and unexpected hardware operation.  This would   also be a problem with ptrace if the inferior process could read   or write hardware registers, but that's not usually the case.  */
block|if (remote_debugging) 	buffer[i] = remote_fetch_word (addr);       else
endif|#
directive|endif
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|remote_debugging
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
name|remote_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|remote_debugging
condition|)
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|remote_fetch_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|bcopy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_store_word
argument_list|(
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|ptrace
argument_list|(
literal|4
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Extensions to  core and dump files, for GDB. */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|last_frame_offset
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PYRAMID_CORE
end_ifdef

begin_comment
comment|/* Can't make definitions here static, since core.c needs them    to do bounds checking on the core-file areas. O well. */
end_comment

begin_comment
comment|/* have two stacks: one for data, one for register windows. */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|reg_stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|reg_stack_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need this so we can find the global registers: they never get saved. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|global_reg_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|last_frame_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|last_frame_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of register window stack area.    Don't know if is this any of meaningful, useful or necessary.   */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|reg_stack_offset
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PYRAMID_CORE */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Work with core dump and executable files, for GDB.     This code would be in core.c if it weren't machine-dependent. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_TXTADDR
end_ifndef

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|hdr
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_TXTADDR */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_DATADDR
end_ifndef

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|hdr
parameter_list|)
value|hdr.a_text
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_DATADDR */
end_comment

begin_comment
comment|/* Make COFF and non-COFF names for things a little more compatible    to reduce conditionals later.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_FORMAT
end_ifdef

begin_define
define|#
directive|define
name|a_magic
value|magic
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_FORMAT
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|AOUTHDR
end_ifndef

begin_define
define|#
directive|define
name|AOUTHDR
value|struct exec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|exec_file_display_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* File names of core file and executable file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|corefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|execfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptors on which core file and executable file are open.    Note that the execchan is closed when an inferior is created    and reopened if the inferior dies or is killed.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|corechan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|execchan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last modification time of executable file.    Also used in source.c to compare against mtime of a source file.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_mtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of the two areas of memory in the core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_end
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PYRAMID_CORE
end_ifdef

begin_comment
comment|/* Well, "two areas of memory" on most machines; but pyramids have a    third area, for the register-window stack, and we need its    base and  bound too.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|reg_stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|reg_stack_start
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PYRAMID_CORE */
end_comment

begin_comment
comment|/* Virtual addresses of bounds of two areas of memory in the exec file.    Note that the data area in the exec file is used only when there is no core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of text area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|text_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of stack area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stack_offset
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_FORMAT
end_ifdef

begin_comment
comment|/* various coff data structures */
end_comment

begin_decl_stmt
specifier|extern
name|FILHDR
name|file_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SCNHDR
name|text_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SCNHDR
name|data_hdr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not COFF_FORMAT */
end_comment

begin_comment
comment|/* a.out header saved in core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|core_aouthdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header of exec file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|exec_aouthdr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|validate_files
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_macro
name|core_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CORE
name|reg_stack_start
operator|=
name|CONTROL_STACK_ADDR
expr_stmt|;
name|reg_stack_end
operator|=
name|CONTROL_STACK_ADDR
expr_stmt|;
comment|/* this isn't strictly true...*/
endif|#
directive|endif
comment|/* PYRAMID_CORE */
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 4.2-style (and perhaps also sysV-style) core dump file.  */
block|{
name|struct
name|user
name|u
decl_stmt|;
name|unsigned
name|int
name|reg_offset
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Not a core file: reading upage"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|u
condition|)
name|error
argument_list|(
literal|"Not a core file: could only read %d bytes"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
expr_stmt|;
name|data_offset
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|stack_offset
operator|=
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|)
expr_stmt|;
comment|/* find registers in core file */
ifdef|#
directive|ifdef
name|PYRAMID_PTRACE
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ussize
expr_stmt|;
name|reg_stack_offset
operator|=
name|stack_offset
operator|+
operator|(
name|NBPG
operator|*
name|u
operator|.
name|u_ussize
operator|)
expr_stmt|;
name|reg_stack_end
operator|=
name|reg_stack_start
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_cssize
expr_stmt|;
name|last_frame_address
operator|=
operator|(
operator|(
name|int
operator|)
name|u
operator|.
name|u_pcb
operator|.
name|pcb_csp
operator|)
expr_stmt|;
name|last_frame_offset
operator|=
name|reg_stack_offset
operator|+
name|last_frame_address
operator|-
name|CONTROL_STACK_ADDR
expr_stmt|;
name|global_reg_offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_gr0
expr_stmt|;
comment|/* skip any control-stack frames that were executed in the 	   kernel. */
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|last_frame_offset
operator|+
operator|(
literal|47
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|buf
operator|>=
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"skipping frame %0x\n"
argument_list|,
name|last_frame_address
argument_list|)
expr_stmt|;
name|last_frame_offset
operator|-=
name|CONTROL_STACK_FRAME_SIZE
expr_stmt|;
name|last_frame_address
operator|-=
name|CONTROL_STACK_FRAME_SIZE
expr_stmt|;
block|}
name|reg_offset
operator|=
name|last_frame_offset
expr_stmt|;
if|#
directive|if
literal|1
operator|||
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf
argument_list|(
literal|"Control stack pointer = 0x%08x\n"
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_csp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"offset to control stack %d outermost frame %d (%0x)\n"
argument_list|,
name|reg_stack_offset
argument_list|,
name|reg_offset
argument_list|,
name|last_frame_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
else|#
directive|else
comment|/* not PYRAMID_CORE */
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
endif|#
directive|endif
comment|/* not PYRAMID_CORE */
ifdef|#
directive|ifdef
name|__not_on_pyr_yet
comment|/* Some machines put an absolute address in here and some put 	   the offset in the upage of the regs.  */
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
expr_stmt|;
if|if
condition|(
name|reg_offset
operator|>
name|NBPG
operator|*
name|UPAGES
condition|)
name|reg_offset
operator|-=
name|KERNEL_U_ADDR
expr_stmt|;
endif|#
directive|endif
comment|/* I don't know where to find this info. 	   So, for now, mark it as not available.  */
name|N_SET_MAGIC
argument_list|(
name|core_aouthdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read the register values out of the core file and store 	   them where `read_register' will find them.  */
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|64
condition|;
name|regno
operator|++
control|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|register_addr
argument_list|(
name|regno
argument_list|,
name|reg_offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|reg_names
index|[
name|regno
index|]
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"Reading register "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
name|printf
argument_list|(
literal|"[reg %s(%d), offset in file %s=0x%0x, addr =0x%0x, =%0x]\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|regno
argument_list|,
name|filename
argument_list|,
name|register_addr
argument_list|(
name|regno
argument_list|,
name|reg_offset
argument_list|)
argument_list|,
name|regno
operator|*
literal|4
operator|+
name|last_frame_address
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buf
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
operator|||
name|defined
argument_list|(
name|PYRAMID_CONTROL_FRAME_DEBUGGING
argument_list|)
name|printf
argument_list|(
literal|"Providing CSP (%0x) as nominal address of current frame.\n"
argument_list|,
name|last_frame_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PYRAMID_CONTROL_FRAME_DEBUGGING
comment|/* FIXME: Which of the following is correct? */
if|#
directive|if
literal|0
block|set_current_frame ( create_new_frame (read_register (FP_REGNUM), 					    read_pc ()));
else|#
directive|else
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|last_frame_address
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|exec_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
if|if
condition|(
name|execfile
condition|)
name|free
argument_list|(
name|execfile
argument_list|)
expr_stmt|;
name|execfile
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|-=
name|exec_data_start
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|text_end
operator|=
literal|0
expr_stmt|;
name|exec_data_start
operator|=
literal|0
expr_stmt|;
name|exec_data_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execchan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
name|execchan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|execchan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|execchan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_FORMAT
else|#
directive|else
comment|/* not COFF_FORMAT */
block|{
name|struct
name|stat
name|st_exec
decl_stmt|;
ifdef|#
directive|ifdef
name|gould
endif|#
directive|endif
comment|/* gould */
name|val
operator|=
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|text_start
operator|=
name|N_TXTADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_start
operator|=
name|N_DATADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|gould
else|#
directive|else
name|text_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
endif|#
directive|endif
name|text_end
operator|=
name|text_start
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|+=
name|exec_data_start
expr_stmt|;
name|fstat
argument_list|(
name|execchan
argument_list|,
operator|&
name|st_exec
argument_list|)
expr_stmt|;
name|exec_mtime
operator|=
name|st_exec
operator|.
name|st_mtime
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not COFF_FORMAT */
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*** Prettier register printing. ***/
end_comment

begin_comment
comment|/* Print registers in the same format as pyramid's dbx, adb, sdb.  */
end_comment

begin_macro
name|pyr_print_registers
argument_list|(
argument|reg_buf
argument_list|,
argument|regnum
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|reg_buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|usp
decl_stmt|,
name|ksp
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
name|regno
operator|++
control|)
block|{
name|printf
comment|/*_filtered*/
argument_list|(
literal|"%6.6s: %8x  %6.6s: %8x  %6s: %8x  %6s: %8x\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|reg_buf
index|[
name|regno
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|16
index|]
argument_list|,
name|reg_buf
index|[
name|regno
operator|+
literal|16
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|32
index|]
argument_list|,
name|reg_buf
index|[
name|regno
operator|+
literal|32
index|]
argument_list|,
name|reg_names
index|[
name|regno
operator|+
literal|48
index|]
argument_list|,
name|reg_buf
index|[
name|regno
operator|+
literal|48
index|]
argument_list|)
expr_stmt|;
block|}
name|usp
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_usp
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ksp
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|u_pcb
operator|.
name|pcb_ksp
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
comment|/*_filtered*/
argument_list|(
literal|"\n%6.6s: %8x  %6.6s: %8x (%08x) %6.6s %8x\n"
argument_list|,
name|reg_names
index|[
name|CSP_REGNUM
index|]
argument_list|,
name|reg_buf
index|[
name|CSP_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|KSP_REGNUM
index|]
argument_list|,
name|reg_buf
index|[
name|KSP_REGNUM
index|]
argument_list|,
name|ksp
argument_list|,
literal|"usp"
argument_list|,
name|usp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print the register regnum, or all registers if regnum is -1. */
end_comment

begin_macro
name|pyr_do_registers_info
argument_list|(
argument|regnum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|regnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* On a pyr, we know a virtual register can always fit in an long.      Here (and elsewhere) we take advantage of that.  Yuk.  */
name|long
name|raw_regs
index|[
name|MAX_REGISTER_RAW_SIZE
operator|*
name|NUM_REGS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|read_relative_register_raw_bytes
argument_list|(
name|i
argument_list|,
name|raw_regs
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
condition|)
name|pyr_print_registers
argument_list|(
name|raw_regs
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|regnum
condition|)
block|{
name|long
name|val
init|=
name|raw_regs
index|[
name|i
index|]
decl_stmt|;
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|6
operator|-
name|strlen
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"0x%08x  %d"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*** Debugging editions of various macros from m-pyr.h ****/
end_comment

begin_function
name|CORE_ADDR
name|frame_locals_address
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|int
name|addr
init|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|CFP_REGNUM
argument_list|)
decl_stmt|;
specifier|register
name|int
name|result
init|=
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t[[..frame_locals:%8x, %s= %x @%x fcfp= %x foo= %x\n\t gr13=%x pr13=%x tr13=%x @%x]]\n"
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|reg_names
index|[
name|CFP_REGNUM
index|]
argument_list|,
name|result
argument_list|,
name|addr
argument_list|,
name|frame
operator|->
name|frame_cfp
argument_list|,
operator|(
name|CFP_REGNUM
operator|)
argument_list|,
name|read_register
argument_list|(
literal|13
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|29
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|61
argument_list|)
argument_list|,
name|find_saved_register
argument_list|(
name|frame
argument_list|,
literal|61
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PYRAMID_CONTROL_FRAME_DEBUGGING */
comment|/* FIXME: I thought read_register (CFP_REGNUM) should be the right answer;      or at least CFP_REGNUM relative to FRAME (ie, result).      There seems to be a bug in the way the innermost frame is set up.  */
return|return
operator|(
operator|(
name|frame
operator|->
name|next
operator|)
condition|?
name|result
else|:
name|frame
operator|->
name|frame_cfp
operator|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|frame_args_addr
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|int
name|addr
init|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|CFP_REGNUM
argument_list|)
decl_stmt|;
specifier|register
name|int
name|result
init|=
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
literal|4
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PYRAMID_CONTROL_FRAME_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t[[..frame_args:%8x, %s= %x @%x fcfp= %x r_r= %x\n\t gr13=%x pr13=%x tr13=%x @%x]]\n"
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|reg_names
index|[
name|CFP_REGNUM
index|]
argument_list|,
name|result
argument_list|,
name|addr
argument_list|,
name|frame
operator|->
name|frame_cfp
argument_list|,
name|read_register
argument_list|(
name|CFP_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|13
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|29
argument_list|)
argument_list|,
name|read_register
argument_list|(
literal|61
argument_list|)
argument_list|,
name|find_saved_register
argument_list|(
name|frame
argument_list|,
literal|61
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  PYRAMID_CONTROL_FRAME_DEBUGGING */
comment|/* FIXME: I thought read_register (CFP_REGNUM) should be the right answer;      or at least CFP_REGNUM relative to FRAME (ie, result).      There seems to be a bug in the way the innermost frame is set up.  */
return|return
operator|(
operator|(
name|frame
operator|->
name|next
operator|)
condition|?
name|result
else|:
name|frame
operator|->
name|frame_cfp
operator|)
return|;
block|}
end_function

end_unit

