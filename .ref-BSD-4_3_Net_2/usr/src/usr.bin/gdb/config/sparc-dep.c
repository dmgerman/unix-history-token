begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sparc-dep.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Machine-dependent code which would otherwise be in inflow.c and core.c,    for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.    This code is for the sparc cpu.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kvm_t
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|cur_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|intstack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|intstack_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|kernstack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|kernstack_bottom
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function simply calls ptrace with the given arguments.      It exists so that all calls to ptrace are isolated in this     machine-dependent file. */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|int
name|request
decl_stmt|,
name|pid
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|;
block|{
return|return
name|ptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|kill_inferior
parameter_list|()
block|{
if|if
condition|(
name|remote_debugging
condition|)
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
block|{
comment|/* 			 * It's a very, very bad idea to go away leaving 			 * breakpoints in a remote kernel or to leave it 			 * stopped at a breakpoint.  			 */
name|clear_breakpoints
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|remote_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|ptrace
argument_list|(
literal|8
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is used when GDB is exiting.  It gives less chance of error.*/
end_comment

begin_function
name|void
name|kill_inferior_fast
parameter_list|()
block|{
if|if
condition|(
name|remote_debugging
condition|)
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
name|clear_breakpoints
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|remote_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|ptrace
argument_list|(
literal|8
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Simulate single-step ptrace call for sun4.  Code written by Gary  * Beihl (beihl@mcc.com); modified by Steven McCanne (mccanne@ee.lbl.gov).  */
end_comment

begin_union
union|union
name|sparcinsn
block|{
name|u_long
name|code
decl_stmt|;
struct|struct
block|{
name|u_int
name|op
range|:
literal|2
decl_stmt|;
name|u_int
name|a
range|:
literal|1
decl_stmt|;
name|u_int
name|cond
range|:
literal|4
decl_stmt|;
name|u_int
name|op2
range|:
literal|3
decl_stmt|;
name|u_int
name|disp22
range|:
literal|22
decl_stmt|;
block|}
name|b
struct|;
block|}
union|;
end_union

begin_comment
comment|/*  * Return the address, other than npc, that could be executed next.  * If only the possibility is npc, return 0.  * (There is only one such "other" possible address.)  */
end_comment

begin_function
name|CORE_ADDR
name|annulled_dest
parameter_list|(
name|insn
parameter_list|,
name|pc
parameter_list|,
name|npc
parameter_list|)
name|union
name|sparcinsn
name|insn
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|,
name|npc
decl_stmt|;
block|{
name|long
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|insn
operator|.
name|b
operator|.
name|op
operator|==
literal|0
operator|&&
name|insn
operator|.
name|b
operator|.
name|a
operator|&&
operator|(
name|insn
operator|.
name|b
operator|.
name|op2
operator|==
literal|2
operator|||
name|insn
operator|.
name|b
operator|.
name|op2
operator|==
literal|6
operator|||
name|insn
operator|.
name|b
operator|.
name|op2
operator|==
literal|7
operator|)
condition|)
block|{
name|offset
operator|=
literal|4
operator|*
operator|(
call|(
name|int
call|)
argument_list|(
name|insn
operator|.
name|b
operator|.
name|disp22
operator|<<
literal|10
argument_list|)
operator|>>
literal|10
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|.
name|b
operator|.
name|cond
operator|==
literal|8
condition|)
return|return
name|pc
operator|+
name|offset
return|;
else|else
return|return
name|npc
operator|+
literal|4
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Duplicated from breakpoint.c because (at least for now) this is a  * machine dependent routine.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From infrun.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stop_after_trap
decl_stmt|,
name|stop_after_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|target0_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|target0_shadow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|target1_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|target1_shadow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Non-zero if we just simulated a single-step ptrace call.  This is  * needed because we cannot remove the breakpoints in the inferior  * process until after the `wait' in `wait_for_inferior'.   * Used for sun4.  */
end_comment

begin_decl_stmt
name|int
name|one_stepped
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|single_step
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|,
name|target0
decl_stmt|,
name|target1
decl_stmt|;
name|union
name|sparcinsn
name|insn
decl_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read_memory
argument_list|(
name|pc
argument_list|,
operator|&
name|insn
operator|.
name|code
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|one_stepped
condition|)
block|{
comment|/* 		 * This is a hack to special case call instructions. 		 * If we are stepping over subroutines, find each call 		 * and trap on return, rather than single step until 		 * wait_for_inferior() discovers that we hit a new routine. 		 * The reason is that stepping over functions in a remote  		 * kernel can have bad results when the function being  		 * stepped over is used by the kernel in between traps. 		 * (i.e., a trap instruction gets poked into the function 		 * being stepped over). 		 */
if|if
condition|(
name|step_over_calls
operator|>
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|.
name|code
operator|&
literal|0xc0000000
operator|)
operator|==
literal|0x40000000
operator|||
operator|(
name|insn
operator|.
name|code
operator|&
literal|0xfff80000
operator|)
operator|==
literal|0x9fc00000
operator|)
condition|)
block|{
name|target0
operator|=
name|PC_ADJUST
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|target1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|target0
operator|=
name|read_register
argument_list|(
name|NPC_REGNUM
argument_list|)
expr_stmt|;
name|target1
operator|=
name|annulled_dest
argument_list|(
name|insn
argument_list|,
name|pc
argument_list|,
name|target0
argument_list|)
expr_stmt|;
block|}
name|target0_addr
operator|=
name|target0
expr_stmt|;
name|read_memory
argument_list|(
name|target0
argument_list|,
operator|&
name|target0_shadow
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|target0
argument_list|,
name|break_insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|target1_addr
operator|=
name|target1
expr_stmt|;
if|if
condition|(
name|target1
condition|)
block|{
name|read_memory
argument_list|(
name|target1
argument_list|,
operator|&
name|target1_shadow
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|target1
argument_list|,
name|break_insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Resume the inferior. 		 */
if|if
condition|(
name|remote_debugging
condition|)
name|remote_resume
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ptrace
argument_list|(
literal|7
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|one_stepped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove breakpoints */
name|write_memory
argument_list|(
name|target0_addr
argument_list|,
operator|&
name|target0_shadow
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|target1_addr
condition|)
name|write_memory
argument_list|(
name|target1_addr
argument_list|,
operator|&
name|target1_shadow
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|one_stepped
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
block|{
comment|/* invalidate the kernel stack limits */
name|cur_proc
operator|=
literal|0
expr_stmt|;
name|remote_resume
argument_list|(
name|step
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sparc doesn't have single step on ptrace */
if|if
condition|(
name|step
condition|)
name|single_step
argument_list|(
name|signal
argument_list|)
expr_stmt|;
else|else
name|ptrace
argument_list|(
literal|7
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/* Start debugging the process whose number is PID.  */
end_comment

begin_function
name|int
name|attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_ATTACH
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Stop debugging the process whose number is PID    and continue it with signal number SIGNAL.    SIGNAL = 0 means just continue it.  */
end_comment

begin_function
name|void
name|detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_DETACH
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_escape
end_escape

begin_function
name|void
name|fetch_inferior_registers
parameter_list|()
block|{
name|struct
name|regs
name|inferior_registers
decl_stmt|;
name|struct
name|fp_status
name|inferior_fp_registers
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|int
name|cwp
decl_stmt|;
name|struct
name|rwindow
name|local_and_ins
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
block|{
name|remote_fetch_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|inferior_fp_registers
argument_list|)
expr_stmt|;
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|inferior_registers
operator|.
name|r_g1
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
argument_list|,
literal|15
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|inferior_fp_registers
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|fpu_fr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
operator|=
name|inferior_registers
operator|.
name|r_ps
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
operator|=
name|inferior_registers
operator|.
name|r_pc
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|NPC_REGNUM
argument_list|)
index|]
operator|=
name|inferior_registers
operator|.
name|r_npc
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|Y_REGNUM
argument_list|)
index|]
operator|=
name|inferior_registers
operator|.
name|r_y
expr_stmt|;
comment|/*      *(int *)&registers[REGISTER_BYTE (RP_REGNUM)] = 		inferior_registers.r_o7 + 8; 		bcopy (&inferior_fp_registers.Fpu_fsr,&registers[REGISTER_BYTE (FPS_REGNUM)], 		sizeof (FPU_FSR_TYPE)); */
name|read_inferior_memory
argument_list|(
name|inferior_registers
operator|.
name|r_sp
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|regs
name|inferior_registers
decl_stmt|;
name|struct
name|fp_status
name|inferior_fp_registers
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_store_registers
argument_list|(
name|registers
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|in_regs
init|=
literal|1
decl_stmt|,
name|in_fpregs
init|=
literal|1
decl_stmt|,
name|in_fparegs
decl_stmt|,
name|in_cpregs
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
if|if
condition|(
name|FP0_REGNUM
operator|<=
name|regno
operator|&&
name|regno
operator|<=
name|FP0_REGNUM
operator|+
literal|32
condition|)
name|in_regs
operator|=
literal|0
expr_stmt|;
else|else
name|in_fpregs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|in_regs
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_registers
operator|.
name|r_g1
argument_list|,
literal|15
operator|*
literal|4
argument_list|)
expr_stmt|;
name|inferior_registers
operator|.
name|r_ps
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
expr_stmt|;
name|inferior_registers
operator|.
name|r_pc
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
expr_stmt|;
name|inferior_registers
operator|.
name|r_npc
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|NPC_REGNUM
argument_list|)
index|]
expr_stmt|;
name|inferior_registers
operator|.
name|r_y
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|Y_REGNUM
argument_list|)
index|]
expr_stmt|;
name|write_inferior_memory
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SP_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_fpregs
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_fp_registers
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|fpu_fr
argument_list|)
expr_stmt|;
comment|/*      bcopy (&registers[REGISTER_BYTE (FPS_REGNUM)],&inferior_fp_registers.Fpu_fsr, 		 sizeof (FPU_FSR_TYPE));   ****/
block|}
if|if
condition|(
name|in_regs
condition|)
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_fpregs
condition|)
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|&
name|inferior_fp_registers
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory    in the NEW_SUN_PTRACE case.    It ought to be straightforward.  But it appears that writing did    not write the data that I specified.  I cannot understand where    it got the data that it actually did write.  */
end_comment

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.     On failure (cannot read from inferior, usually because address is out    of bounds) returns the value of errno. */
end_comment

begin_function
name|int
name|read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
return|return
operator|(
name|remote_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
comment|/* Read all the longwords */
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
name|errno
operator|==
literal|0
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy appropriate bytes out of the buffer.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    On failure (cannot write the inferior)    returns the value of errno.  */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|remote_debugging
condition|)
return|return
operator|(
name|remote_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
literal|1
argument_list|,
name|inferior_pid
argument_list|,
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy data to be written over corresponding part of buffer */
name|bcopy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
name|errno
operator|==
literal|0
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
name|ptrace
argument_list|(
literal|4
argument_list|,
name|inferior_pid
argument_list|,
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Machine-dependent code which would otherwise be in core.c */
end_comment

begin_comment
comment|/* Work with core dump and executable files, for GDB. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_TXTADDR
end_ifndef

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|hdr
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_TXTADDR */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_DATADDR
end_ifndef

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|hdr
parameter_list|)
value|hdr.a_text
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_DATADDR */
end_comment

begin_comment
comment|/* Non-zero if this is an object (.o) file, rather than an executable.    Distinguishing between the two is rarely necessary (and seems like    a hack, but there is no other way to get the text and data    addresses--N_TXTADDR should probably take care of    this, but it doesn't).  */
end_comment

begin_comment
comment|/* This definition will not work    if someone decides to make ld preserve relocation info.  */
end_comment

begin_define
define|#
directive|define
name|IS_OBJECT_FILE
parameter_list|(
name|hdr
parameter_list|)
value|(hdr.a_trsize != 0)
end_define

begin_comment
comment|/* Make COFF and non-COFF names for things a little more compatible    to reduce conditionals later.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_FORMAT
end_ifdef

begin_define
define|#
directive|define
name|a_magic
value|magic
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_FORMAT
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|AOUTHDR
end_ifndef

begin_define
define|#
directive|define
name|AOUTHDR
value|struct exec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|exec_file_display_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* File names of core file and executable file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|corefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|execfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptors on which core file and executable file are open.    Note that the execchan is closed when an inferior is created    and reopened if the inferior dies or is killed.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|corechan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|execchan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last modification time of executable file.    Also used in source.c to compare against mtime of a source file.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_mtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of the two areas of memory in the core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of two areas of memory in the exec file.    Note that the data area in the exec file is used only when there is no core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of text area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|text_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of stack area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stack_offset
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_FORMAT
end_ifdef

begin_comment
comment|/* various coff data structures */
end_comment

begin_decl_stmt
specifier|extern
name|FILHDR
name|file_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SCNHDR
name|text_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SCNHDR
name|data_hdr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not COFF_FORMAT */
end_comment

begin_comment
comment|/* a.out header saved in core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|core_aouthdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header of exec file.  */
end_comment

begin_decl_stmt
specifier|extern
name|AOUTHDR
name|exec_aouthdr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|validate_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|core_file_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/*  * Process control block.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Floating point unit.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fpu
name|fpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX For misc_function_vector. */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_comment
comment|/*  * Read the "thing" at kernel address 'addr' into the space pointed to  * by point.  The length of the "thing" is determined by the type of p.  * Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|kvread
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(read_memory((CORE_ADDR)(addr), (char *)(p), sizeof(*(p))))
end_define

begin_function
specifier|static
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|lookup_misc_func
argument_list|(
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current proc.  masterprocp points to  * current proc which points to current u area.  */
end_comment

begin_function
name|struct
name|proc
modifier|*
name|curProc
parameter_list|()
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|ksym_lookup
argument_list|(
literal|"masterprocp"
argument_list|)
decl_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|addr
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * (re-)set the variables that make inside_kernstack() work.  */
end_comment

begin_macro
name|set_kernel_boundaries
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CORE_ADDR
name|kstack
decl_stmt|;
if|if
condition|(
name|intstack_top
operator|==
literal|0
condition|)
block|{
name|intstack_top
operator|=
name|ksym_lookup
argument_list|(
literal|"eintstack"
argument_list|)
expr_stmt|;
name|intstack_bottom
operator|=
name|ksym_lookup
argument_list|(
literal|"intstack"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kvread
argument_list|(
operator|&
name|p
operator|->
name|p_segu
argument_list|,
operator|&
name|kstack
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read kernel stack pointer at %x\n"
argument_list|,
operator|&
name|p
operator|->
name|p_segu
argument_list|)
expr_stmt|;
name|kernstack_bottom
operator|=
name|kstack
expr_stmt|;
name|kernstack_top
operator|=
name|kstack
operator|+
name|KERNSTACK
expr_stmt|;
block|}
end_block

begin_macro
name|inside_kernstack
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cur_proc
operator|==
literal|0
condition|)
block|{
name|cur_proc
operator|=
name|curProc
argument_list|()
expr_stmt|;
name|set_kernel_boundaries
argument_list|(
name|cur_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addr
operator|>
name|intstack_bottom
operator|&&
name|addr
operator|<
name|intstack_top
operator|)
operator|||
operator|(
name|addr
operator|>
name|kernstack_bottom
operator|&&
name|addr
operator|<
name|kernstack_top
operator|)
return|;
block|}
end_block

begin_macro
name|clear_regs
argument_list|()
end_macro

begin_block
block|{
name|u_long
name|reg
init|=
literal|0
decl_stmt|;
name|float
name|freg
init|=
literal|0.0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FP0_REGNUM
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|;
operator|++
name|i
control|)
comment|/* XXX */
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|freg
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|read_pcb
parameter_list|()
block|{
name|struct
name|user
modifier|*
name|uaddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|cps
decl_stmt|,
name|reg
decl_stmt|,
name|sp
decl_stmt|;
name|float
name|freg
decl_stmt|;
name|struct
name|rwindow
name|win
decl_stmt|;
comment|/* find the pcb for the current process */
if|if
condition|(
name|kvread
argument_list|(
operator|&
name|cur_proc
operator|->
name|p_uarea
argument_list|,
operator|&
name|uaddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot u area ptr for proc at 0x%x"
argument_list|,
name|cur_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|,
operator|&
name|pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at 0x%x"
argument_list|,
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|)
expr_stmt|;
comment|/* 	 * Zero out register set then fill in the ones we know about. 	 */
name|clear_regs
argument_list|()
expr_stmt|;
name|sp
operator|=
name|pcb
operator|.
name|pcb_sp
expr_stmt|;
name|printf
argument_list|(
literal|"sp=%x pc=%x sr=%x\n"
argument_list|,
name|sp
argument_list|,
name|pcb
operator|.
name|pcb_pc
argument_list|,
name|pcb
operator|.
name|pcb_psr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_sp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
comment|/* PC came from o7. */
name|supply_register
argument_list|(
literal|15
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_psr
argument_list|)
expr_stmt|;
comment|/* XXX There should be a WIM_REGNUM. */
name|supply_register
argument_list|(
literal|66
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_uwm
argument_list|)
expr_stmt|;
comment|/* 	 * Read last register window saved on stack. 	 */
if|if
condition|(
name|kvread
argument_list|(
name|sp
argument_list|,
operator|&
name|win
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot read register window at sp=%x\n"
argument_list|,
name|pcb
operator|.
name|pcb_sp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|,
sizeof|sizeof
name|win
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|win
operator|.
name|rw_local
argument_list|)
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
operator|+
literal|16
argument_list|,
operator|&
name|win
operator|.
name|rw_local
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|win
operator|.
name|rw_in
argument_list|)
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
operator|+
literal|24
argument_list|,
operator|&
name|win
operator|.
name|rw_in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * read the globals& outs saved on the stack (for a trap frame). 	 */
name|sp
operator|+=
literal|92
operator|+
literal|12
expr_stmt|;
comment|/* XXX - MINFRAME + R_Y */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|14
condition|;
operator|++
name|i
control|)
block|{
name|u_long
name|val
decl_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|sp
operator|+
name|i
operator|*
literal|4
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kvread
argument_list|(
name|pcb
operator|.
name|pcb_cpctxp
argument_list|,
operator|&
name|cps
argument_list|)
operator|==
literal|0
condition|)
name|supply_register
argument_list|(
name|CPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the process context to that of the proc structure at  * system address paddr.  *  * This is REALLY STUPID.  The only way to tell libkvm that we want to   * change user address maps is with kvm_getu.  */
end_comment

begin_macro
name|set_procaddr
argument_list|(
argument|paddr
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|paddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
name|p
decl_stmt|;
name|struct
name|user
modifier|*
name|uaddr
decl_stmt|;
if|if
condition|(
name|paddr
operator|<
name|KERNELBASE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cur_proc
operator|==
name|NULL
condition|)
if|if
condition|(
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"proc"
argument_list|)
argument_list|,
operator|&
name|cur_proc
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot find proc table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvread
argument_list|(
name|paddr
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc struct at 0x%x"
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
condition|)
if|if
condition|(
name|kvm_getu
argument_list|(
name|kd
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|kvread
argument_list|(
name|cur_proc
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kvm_getu
argument_list|(
name|kd
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"cannot read uarea for proc at 0x%x"
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cur_proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|paddr
expr_stmt|;
name|read_pcb
argument_list|()
expr_stmt|;
name|set_kernel_boundaries
argument_list|(
name|cur_proc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|setup_kernel_corefile
parameter_list|(
name|namefile
parameter_list|,
name|corefile
parameter_list|)
name|char
modifier|*
name|namefile
decl_stmt|,
decl|*
name|corefile
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|stb
decl_stmt|;
name|int
name|kmem
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|,
name|paddr
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|corefile
argument_list|,
literal|"/dev/mem"
argument_list|)
operator|==
literal|0
condition|)
comment|/* XXX - Sun libkvm botch: this is only way to get 		 * correct mappings for swap set up. */
name|kd
operator|=
name|kvm_open
argument_list|(
name|namefile
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|O_RDONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|kd
operator|=
name|kvm_open
argument_list|(
name|namefile
argument_list|,
name|corefile
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|O_RDONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot open '%s' as core file of '%s'\n"
argument_list|,
name|corefile
argument_list|,
name|namefile
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Need to find current u area to get kernel stack and pcb 	 * where "panic" saved registers.   	 * (libkvm also needs to know current u area to get user 	 * address space mapping). 	 */
operator|(
name|void
operator|)
name|set_procaddr
argument_list|(
name|curProc
argument_list|()
argument_list|)
expr_stmt|;
comment|/* print out the panic string if there is one */
if|if
condition|(
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
operator|||
name|addr
operator|==
literal|0
operator|||
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_paddr_command
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_int
name|paddr
decl_stmt|,
name|uaddr
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"proc address for new current process"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
name|error
argument_list|(
literal|"not debugging kernel"
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
name|u_int
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_procaddr
argument_list|(
name|paddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read len bytes from kernel virtual address 'addr' into local   * buffer 'buf'.  Return 0 if read ok, 1 otherwise.  On read  * errors, portion of buffer not read is zeroed.  */
end_comment

begin_macro
name|kernel_core_file_hook
argument_list|(
argument|addr
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|cc
decl_stmt|;
if|if
condition|(
name|kd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"no kernel core file"
argument_list|)
expr_stmt|;
name|cc
operator|=
name|kvm_read
argument_list|(
name|kd
argument_list|,
operator|(
name|u_long
operator|)
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
name|cc
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
operator|-
name|cc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|is_a_vmunix
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|name
operator|&&
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"vmunix"
argument_list|)
operator|)
operator|&&
operator|(
name|cp
operator|==
name|name
operator|||
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|val
decl_stmt|,
name|sp
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|kd
operator|!=
literal|0
condition|)
block|{
name|kvm_close
argument_list|(
name|kd
argument_list|)
expr_stmt|;
name|kd
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Discard all vestiges of any previous core file 	   and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
operator|!
name|kernel_debugging
operator|&&
name|is_a_vmunix
argument_list|(
name|execfile
argument_list|)
condition|)
block|{
name|kernel_debugging
operator|=
literal|1
expr_stmt|;
name|set_prompt_command
argument_list|(
literal|"(kgdb)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kernel_debugging
condition|)
block|{
name|core_file_hook
operator|=
name|kernel_core_file_hook
expr_stmt|;
name|setup_kernel_corefile
argument_list|(
name|execfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
endif|#
directive|endif
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
name|fstat
argument_list|(
name|corechan
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
operator|&&
name|stb
operator|.
name|st_rdev
operator|==
name|makedev
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* looking at /dev/kmem */
name|data_offset
operator|=
name|data_start
operator|=
name|KERNELBASE
expr_stmt|;
name|data_end
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* XXX */
name|stack_end
operator|=
name|stack_start
operator|=
name|data_end
expr_stmt|;
name|set_kernel_boundaries
argument_list|(
name|curProc
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
endif|#
directive|endif
block|{
name|struct
name|core
name|corestr
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|corestr
argument_list|,
sizeof|sizeof
name|corestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|corestr
operator|.
name|c_magic
operator|!=
name|CORE_MAGIC
condition|)
name|error
argument_list|(
literal|"\"%s\" does not appear to be a core dump file (magic 0x%x, expected 0x%x)"
argument_list|,
name|filename
argument_list|,
name|corestr
operator|.
name|c_magic
argument_list|,
operator|(
name|int
operator|)
name|CORE_MAGIC
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|core
argument_list|)
operator|!=
name|corestr
operator|.
name|c_len
condition|)
name|error
argument_list|(
literal|"\"%s\" has an invalid struct core length (%d, expected %d)"
argument_list|,
name|filename
argument_list|,
name|corestr
operator|.
name|c_len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|core
argument_list|)
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|corestr
operator|.
name|c_dsize
expr_stmt|;
name|stack_start
operator|=
name|stack_end
operator|-
name|corestr
operator|.
name|c_ssize
expr_stmt|;
name|data_offset
operator|=
sizeof|sizeof
name|corestr
expr_stmt|;
name|stack_offset
operator|=
sizeof|sizeof
name|corestr
operator|+
name|corestr
operator|.
name|c_dsize
expr_stmt|;
comment|/* G0 *always* holds 0.  */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The globals and output registers.  */
name|bcopy
argument_list|(
operator|&
name|corestr
operator|.
name|c_regs
operator|.
name|r_g1
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|registers
operator|)
operator|+
literal|1
argument_list|,
literal|15
operator|*
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
operator|=
name|corestr
operator|.
name|c_regs
operator|.
name|r_ps
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
operator|=
name|corestr
operator|.
name|c_regs
operator|.
name|r_pc
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|NPC_REGNUM
argument_list|)
index|]
operator|=
name|corestr
operator|.
name|c_regs
operator|.
name|r_npc
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|Y_REGNUM
argument_list|)
index|]
operator|=
name|corestr
operator|.
name|c_regs
operator|.
name|r_y
expr_stmt|;
comment|/* My best guess at where to get the locals and input 		   registers is exactly where they usually are, right above 		   the stack pointer.  If the core dump was caused by a bus 		   writing off the stack pointer (as is possible) then this 		   won't work, but it's worth the try. */
name|sp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SP_REGNUM
argument_list|)
index|]
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|sp
operator|-
name|stack_start
operator|+
name|stack_offset
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
literal|16
operator|*
literal|4
operator|!=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
condition|)
comment|/* fprintf so user can still use gdb */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't read input and local registers from core file\n"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|corestr
operator|.
name|c_fpu
operator|.
name|fpu_regs
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|corestr
operator|.
name|c_fpu
operator|.
name|fpu_regs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FPU
name|bcopy
argument_list|(
operator|&
name|corestr
operator|.
name|c_fpu
operator|.
name|fpu_fsr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPS_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|FPU_FSR_TYPE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|corestr
operator|.
name|c_aouthdr
argument_list|,
operator|&
name|core_aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Core file is from \"%s\".\n"
argument_list|,
name|corestr
operator|.
name|c_cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|corestr
operator|.
name|c_signo
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Program terminated with signal %d, %s.\n"
argument_list|,
name|corestr
operator|.
name|c_signo
argument_list|,
name|corestr
operator|.
name|c_signo
operator|<
name|NSIG
condition|?
name|sys_siglist
index|[
name|corestr
operator|.
name|c_signo
index|]
else|:
literal|"(undocumented)"
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|exec_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
if|if
condition|(
name|execfile
condition|)
name|free
argument_list|(
name|execfile
argument_list|)
expr_stmt|;
name|execfile
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|-=
name|exec_data_start
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|text_end
operator|=
literal|0
expr_stmt|;
name|exec_data_start
operator|=
literal|0
expr_stmt|;
name|exec_data_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execchan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
name|execchan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|execchan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|execchan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_FORMAT
block|{
name|int
name|aout_hdrsize
decl_stmt|;
name|int
name|num_sections
decl_stmt|;
if|if
condition|(
name|read_file_hdr
argument_list|(
name|execchan
argument_list|,
operator|&
name|file_hdr
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": not in executable format."
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
name|aout_hdrsize
operator|=
name|file_hdr
operator|.
name|f_opthdr
expr_stmt|;
name|num_sections
operator|=
name|file_hdr
operator|.
name|f_nscns
expr_stmt|;
if|if
condition|(
name|read_aout_hdr
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read optional aouthdr"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_section_hdr
argument_list|(
name|execchan
argument_list|,
name|_TEXT
argument_list|,
operator|&
name|text_hdr
argument_list|,
name|num_sections
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read text section header"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_section_hdr
argument_list|(
name|execchan
argument_list|,
name|_DATA
argument_list|,
operator|&
name|data_hdr
argument_list|,
name|num_sections
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read data section header"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
name|text_start
operator|=
name|exec_aouthdr
operator|.
name|text_start
expr_stmt|;
name|text_end
operator|=
name|text_start
operator|+
name|exec_aouthdr
operator|.
name|tsize
expr_stmt|;
name|text_offset
operator|=
name|text_hdr
operator|.
name|s_scnptr
expr_stmt|;
name|exec_data_start
operator|=
name|exec_aouthdr
operator|.
name|data_start
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|dsize
expr_stmt|;
name|exec_data_offset
operator|=
name|data_hdr
operator|.
name|s_scnptr
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|+=
name|exec_data_start
expr_stmt|;
name|exec_mtime
operator|=
name|file_hdr
operator|.
name|f_timdat
expr_stmt|;
block|}
else|#
directive|else
comment|/* not COFF_FORMAT */
block|{
name|struct
name|stat
name|st_exec
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel_debugging
condition|)
name|text_start
operator|=
name|exec_aouthdr
operator|.
name|a_entry
expr_stmt|;
else|else
name|text_start
operator|=
name|IS_OBJECT_FILE
argument_list|(
name|exec_aouthdr
argument_list|)
condition|?
literal|0
else|:
name|N_TXTADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_start
operator|=
name|IS_OBJECT_FILE
argument_list|(
name|exec_aouthdr
argument_list|)
condition|?
name|exec_aouthdr
operator|.
name|a_text
else|:
name|N_DATADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|text_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_offset
operator|=
name|N_DATOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|text_end
operator|=
name|text_start
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|+=
name|exec_data_start
expr_stmt|;
name|fstat
argument_list|(
name|execchan
argument_list|,
operator|&
name|st_exec
argument_list|)
expr_stmt|;
name|exec_mtime
operator|=
name|st_exec
operator|.
name|st_mtime
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not COFF_FORMAT */
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
value|((int)(&((t *)0)->f))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the address of the saved pc in frame.  */
end_comment

begin_function
name|CORE_ADDR
name|addr_of_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
comment|/* 	 * If we are kernel debugging, we must special case trap frames. 	 * We can tell if we are a trap frame by looking at the return  	 * address of the frame below us.  If it is in locore, then 	 * we are such a frame and we can find our saved pc in %l1. 	 */
if|if
condition|(
name|kernel_debugging
operator|&&
name|frame
operator|->
name|next
condition|)
block|{
specifier|static
name|CORE_ADDR
name|locore_h
decl_stmt|,
name|locore_t
decl_stmt|;
if|if
condition|(
name|locore_h
operator|==
literal|0
condition|)
block|{
name|locore_h
operator|=
name|ksym_lookup
argument_list|(
literal|"sys_trap"
argument_list|)
expr_stmt|;
name|locore_t
operator|=
name|ksym_lookup
argument_list|(
literal|"kadb_tcode"
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|GET_RWINDOW_REG
argument_list|(
name|frame
operator|->
name|next
operator|->
name|bottom
argument_list|,
name|rw_in
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|locore_h
operator|&&
name|addr
operator|<
name|locore_t
condition|)
return|return
name|frame
operator|->
name|bottom
operator|+
name|offsetof
argument_list|(
expr|struct
name|rwindow
argument_list|,
name|rw_local
index|[
literal|1
index|]
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|CORE_ADDR
operator|)
operator|&
operator|(
operator|(
expr|struct
name|rwindow
operator|*
operator|)
name|frame
operator|->
name|bottom
operator|)
operator|->
name|rw_in
index|[
literal|7
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Find the pc saved in frame FRAME.    */
end_comment

begin_function
name|CORE_ADDR
name|frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
return|return
name|PC_ADJUST
argument_list|(
name|read_memory_integer
argument_list|(
name|addr_of_pc
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Since an individual frame in the frame cache is defined by two  * arguments (a frame pointer and a stack pointer), we need two  * arguments to get info for an arbitrary stack frame.  This routine  * takes two arguments and makes the cached frames look as if these  * two arguments defined a frame on the cache.  This allows the rest  * of info frame to extract the important arguments without  * difficulty.   */
end_comment

begin_function
name|FRAME
name|setup_arbitrary_frame
parameter_list|(
name|frame
parameter_list|,
name|stack
parameter_list|)
name|FRAME_ADDR
name|frame
decl_stmt|,
name|stack
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fci
decl_stmt|;
name|FRAME
name|fid
init|=
name|create_new_frame
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fid
condition|)
name|fatal
argument_list|(
literal|"internal: create_new_frame returned invalid frame id"
argument_list|)
expr_stmt|;
name|fid
operator|->
name|bottom
operator|=
name|stack
expr_stmt|;
return|return
name|fid
return|;
block|}
end_function

begin_comment
comment|/* This code was written by Gary Beihl (beihl@mcc.com).    It was modified by Michael Tiemann (tiemann@corto.inria.fr). */
end_comment

begin_function_decl
name|struct
name|command_line
modifier|*
name|get_breakpoint_commands
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * This routine takes a program counter value.  It restores the  * register window system to the frame above the current one, and sets  * the pc and npc to the correct values.  */
end_comment

begin_comment
comment|/*    The following insns translate to:    	restore  	t g0,0x1,o0  	sethi %hi(0x0), g0	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|restore_insn_opcodes
index|[]
init|=
block|{
literal|0x81e80000
block|,
literal|0x91d02001
block|,
literal|0x01000000
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|do_restore_insn
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|npc
init|=
name|pc
operator|+
literal|4
decl_stmt|;
name|CORE_ADDR
name|fake_pc
init|=
name|sp
operator|-
sizeof|sizeof
argument_list|(
name|restore_insn_opcodes
argument_list|)
decl_stmt|;
name|struct
name|inferior_status
name|inf_status
decl_stmt|;
name|save_inferior_status
argument_list|(
operator|&
name|inf_status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't restore stack info */
if|if
condition|(
operator|!
name|pc
condition|)
name|abort
argument_list|()
expr_stmt|;
name|write_memory
argument_list|(
name|fake_pc
argument_list|,
name|restore_insn_opcodes
argument_list|,
sizeof|sizeof
argument_list|(
name|restore_insn_opcodes
argument_list|)
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
name|proceed
argument_list|(
name|fake_pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|npc
argument_list|)
expr_stmt|;
name|restore_inferior_status
argument_list|(
operator|&
name|inf_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine should be more specific in it's actions; making sure  * that it uses the same register in the initial prologue section.  */
end_comment

begin_function
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
union|union
block|{
name|unsigned
name|long
name|int
name|code
decl_stmt|;
struct|struct
block|{
name|unsigned
name|int
name|op
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|rd
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|op2
range|:
literal|3
decl_stmt|;
name|unsigned
name|int
name|imm22
range|:
literal|22
decl_stmt|;
block|}
name|sethi
struct|;
struct|struct
block|{
name|unsigned
name|int
name|op
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|rd
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|op3
range|:
literal|6
decl_stmt|;
name|unsigned
name|int
name|rs1
range|:
literal|5
decl_stmt|;
name|unsigned
name|int
name|i
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|simm13
range|:
literal|13
decl_stmt|;
block|}
name|add
struct|;
name|int
name|i
decl_stmt|;
block|}
name|x
union|;
name|int
name|dest
init|=
operator|-
literal|1
decl_stmt|;
name|x
operator|.
name|i
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Recognize the `sethi' insn and record its destination.  */
if|if
condition|(
name|x
operator|.
name|sethi
operator|.
name|op
operator|==
literal|0
operator|&&
name|x
operator|.
name|sethi
operator|.
name|op2
operator|==
literal|4
condition|)
block|{
name|dest
operator|=
name|x
operator|.
name|sethi
operator|.
name|rd
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
name|x
operator|.
name|i
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Recognize an add immediate value to register to either %g1 or      the destination register recorded above.  Actually, this might      well recognize several different arithmetic operations.  */
if|if
condition|(
name|x
operator|.
name|add
operator|.
name|op
operator|==
literal|2
operator|&&
name|x
operator|.
name|add
operator|.
name|i
operator|&&
operator|(
name|x
operator|.
name|add
operator|.
name|rd
operator|==
literal|1
operator|||
name|x
operator|.
name|add
operator|.
name|rd
operator|==
name|dest
operator|)
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|x
operator|.
name|i
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* This recognizes any SAVE insn.  But why do the XOR and then      the compare?  That's identical to comparing against 60 (as long      as there isn't any sign extension).  */
if|if
condition|(
name|x
operator|.
name|add
operator|.
name|op
operator|==
literal|2
operator|&&
operator|(
name|x
operator|.
name|add
operator|.
name|op3
operator|^
literal|32
operator|)
operator|==
literal|28
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|x
operator|.
name|i
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to recognize stores into the frame from the input      registers.  This recognizes all non alternate stores of input      register, into a location offset from the frame pointer.  */
while|while
condition|(
name|x
operator|.
name|add
operator|.
name|op
operator|==
literal|3
operator|&&
operator|(
name|x
operator|.
name|add
operator|.
name|op3
operator|&
literal|0x3c
operator|)
operator|==
literal|4
comment|/* Store, non-alternate.  */
operator|&&
operator|(
name|x
operator|.
name|add
operator|.
name|rd
operator|&
literal|0x18
operator|)
operator|==
literal|0x18
comment|/* Input register.  */
operator|&&
name|x
operator|.
name|add
operator|.
name|i
comment|/* Immediate mode.  */
operator|&&
name|x
operator|.
name|add
operator|.
name|rs1
operator|==
literal|30
comment|/* Off of frame pointer.  */
comment|/* Into reserved stack space.  */
operator|&&
name|x
operator|.
name|add
operator|.
name|simm13
operator|>=
literal|0x44
operator|&&
name|x
operator|.
name|add
operator|.
name|simm13
operator|<
literal|0x5b
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|x
operator|.
name|i
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_decl_stmt
name|int
name|dummy_code
index|[]
init|=
block|{
literal|0xd003a044
block|,
comment|/* ld	[%sp + 68], %o0 */
literal|0xd203a048
block|,
comment|/* ld	[%sp + 72], %o1 */
literal|0xd403a04c
block|,
comment|/* ld	[%sp + 76], %o2 */
literal|0xd603a050
block|,
comment|/* ld	[%sp + 80], %o3 */
literal|0xd803a054
block|,
comment|/* ld	[%sp + 84], %o4 */
define|#
directive|define
name|DUMMY_CALL_INDEX
value|5
literal|0x40000000
block|,
comment|/* call .		*/
literal|0xda03a058
block|,
comment|/* ld	[%sp + 88], %o5 */
literal|0x01000000
block|,
comment|/* nop - extra insn for Sun cc */
literal|0x91d02001
block|,
comment|/* ta	1		*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Leave room on the stack for the kernel save area and the pointer  * for structure return values.  */
end_comment

begin_define
define|#
directive|define
name|KSA_AND_STRUCT_ADJUST
value|68
end_define

begin_comment
comment|/*  * Build `dummy' call instructions on inferior's stack to cause  * it to call a subroutine.  *  * N.B. - code in wait_for_inferior requires that sp< pc< fp when  * we take the trap 2 above so it will recognize that we stopped  * at a `dummy' call.  So, after the call sp is *not* decremented  * to clean the arguments, code& other stuff we lay on the stack.  * Since the regs are restored to saved values at the breakpoint,  * sp will get reset correctly.  Also, this restore means we don't  * have to construct frame linkage info to save pc& fp.  The lack  * of frame linkage means we can't do a backtrace, etc., if the  * called function gets a fault or hits a breakpoint but code in  * run_stack_dummy makes this impossible anyway.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|setup_dummy
argument_list|(
name|sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|struct_return_bytes
argument_list|,
name|pushfn
argument_list|)
name|CORE_ADDR
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|funaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|struct_return_bytes
decl_stmt|;
end_decl_stmt

begin_function_decl
name|CORE_ADDR
function_decl|(
modifier|*
name|pushfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|len
decl_stmt|,
name|padding
decl_stmt|,
name|i
decl_stmt|;
name|CORE_ADDR
name|top
init|=
name|sp
decl_stmt|,
name|struct_addr
decl_stmt|,
name|pc
decl_stmt|;
name|pc
operator|=
name|sp
operator|-
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
expr_stmt|;
name|len
operator|=
name|arg_stacklen
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
operator|+
name|KSA_AND_STRUCT_ADJUST
operator|+
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
operator|+
name|struct_return_bytes
expr_stmt|;
name|padding
operator|=
name|STACK_ALIGN
argument_list|(
name|len
argument_list|)
operator|-
name|len
expr_stmt|;
name|sp
operator|=
name|pc
operator|-
name|padding
operator|-
name|struct_return_bytes
expr_stmt|;
name|struct_addr
operator|=
name|sp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
comment|/* pushfn doesn't actually change SP_REGNUM */
name|sp
operator|=
call|(
modifier|*
name|pushfn
call|)
argument_list|(
name|sp
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sp
operator|-=
name|KSA_AND_STRUCT_ADJUST
expr_stmt|;
if|if
condition|(
name|struct_return_bytes
condition|)
name|write_memory
argument_list|(
name|sp
operator|+
name|KSA_AND_STRUCT_ADJUST
operator|-
literal|4
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|struct_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|dummy_code
index|[
name|DUMMY_CALL_INDEX
index|]
operator|=
literal|0x40000000
operator||
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|funaddr
operator|-
operator|(
name|pc
operator|+
literal|4
operator|*
name|DUMMY_CALL_INDEX
operator|)
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|write_memory
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy_code
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_block

begin_decl_stmt
name|int
name|default_function_nargs
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_macro
name|set_default_funargs_command
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|default_function_nargs
argument_list|)
expr_stmt|;
else|else
name|default_function_nargs
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|frame_find_saved_regs
argument_list|(
argument|fi
argument_list|,
argument|srp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame_saved_regs
modifier|*
name|srp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|FRAME_ADDR
name|frame
init|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
decl_stmt|;
name|FRAME
name|fid
init|=
name|FRAME_INFO_ID
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fid
condition|)
name|fatal
argument_list|(
literal|"Bad frame info struct in FRAME_FIND_SAVED_REGS"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|srp
argument_list|,
sizeof|sizeof
expr|*
name|srp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|>=
operator|(
name|fi
operator|->
name|bottom
condition|?
name|fi
operator|->
name|bottom
else|:
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|)
operator|&&
name|fi
operator|->
name|pc
operator|<=
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
name|i
operator|*
literal|4
operator|-
literal|0xa0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
operator|(
name|i
operator|-
literal|24
operator|)
operator|*
literal|4
operator|-
literal|0xc0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
operator|(
name|i
operator|-
name|FP0_REGNUM
operator|)
operator|*
literal|4
operator|-
literal|0x80
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|64
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
operator|(
name|i
operator|-
literal|64
operator|)
operator|*
literal|4
operator|-
literal|0xe0
expr_stmt|;
name|frame
operator|=
name|fi
operator|->
name|bottom
condition|?
name|fi
operator|->
name|bottom
else|:
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frame
operator|=
name|fi
operator|->
name|bottom
condition|?
name|fi
operator|->
name|bottom
else|:
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
operator|(
name|i
operator|-
literal|16
operator|)
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|fi
operator|->
name|next
condition|)
block|{
comment|/* Pull off either the next frame pointer or 		   the stack pointer */
name|FRAME_ADDR
name|next_next_frame
init|=
operator|(
name|fi
operator|->
name|next
operator|->
name|bottom
condition|?
name|fi
operator|->
name|next
operator|->
name|bottom
else|:
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|next_next_frame
operator|+
name|i
operator|*
literal|4
expr_stmt|;
block|}
comment|/* Otherwise, whatever we would get from ptrace(GETREGS) */
comment|/* is accurate */
for|for
control|(
name|i
operator|=
literal|30
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
operator|(
name|i
operator|-
literal|16
operator|)
operator|*
literal|4
expr_stmt|;
name|srp
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|srp
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
ifdef|#
directive|ifdef
name|KERNELDEBUG
name|kernel_debugging
condition|?
name|addr_of_pc
argument_list|(
name|fi
argument_list|)
else|:
endif|#
directive|endif
name|frame
operator|+
literal|15
operator|*
literal|4
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_function
name|void
name|_initialize_sparc_dep
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
name|set_paddr_command
argument_list|,
literal|"The process with proc structure at ADDR becomes the\n\ \"current\" process context for kernel debugging."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"paddr"
argument_list|,
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"default-funargs"
argument_list|,
name|class_support
argument_list|,
name|set_default_funargs_command
argument_list|,
literal|"Set the number of arguments to be printed for functions with\n\ no debugging info.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

