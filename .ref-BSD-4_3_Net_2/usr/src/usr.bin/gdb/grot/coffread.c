begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read coff symbol tables and convert to internal format, for GDB.    Design and support routines derived from dbxread.c, and UMAX COFF    specific routines written 9/1/87 by David D. Johnson, Brown University.    Revised 11/27/87 ddj@cs.brown.edu    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_FORMAT
end_ifdef

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_function_decl
specifier|static
name|void
name|add_symbol_to_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_coff_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patch_opaque_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|decode_function_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|decode_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|decode_base_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|blockvector
modifier|*
name|make_blockvector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|process_coff_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_stringtab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_stringtab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getfilename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getsymname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_lineno
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enter_linenos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_all_symtabs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_all_psymtabs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Name of source file whose symbol data we are now processing.    This comes from a symbol named ".file".  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_source_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of start and end of text of current source file.    This comes from a ".text" symbol where x_nlinno> 0.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cur_src_start_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cur_src_end_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of the end of the first object file.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|first_object_file_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of the text segment of the executable file,    as found in the symbol _etext.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|end_of_text_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The addresses of the symbol table stream and number of symbols    of the object file we are reading (as copied into core).  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|nlist_stream_global
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlist_nsyms_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file, a.out  and text section headers of the symbol file */
end_comment

begin_decl_stmt
specifier|static
name|FILHDR
name|file_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SCNHDR
name|text_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|AOUTHDR
name|aout_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index in the symbol table of the last coff symbol that was processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of types defined so far, indexed by their coff symnum.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|typevector
modifier|*
name|type_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated for type_vector currently.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|type_vector_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|line_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of next entry to go in line_vector_index.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last line number recorded in the line vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated for line_vector currently.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of typedefs of pointers to empty struct/union types.    They are chained thru the SYMBOL_VALUE.  */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|127
end_define

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|opaque_type_chain
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the symbols defined for each context in a list.    We don't create a struct block for the context until we    know how long to make it.  */
end_comment

begin_struct
struct|struct
name|pending
block|{
name|struct
name|pending
modifier|*
name|next
decl_stmt|;
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Here are the three lists that symbols are put on.  */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|file_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static at top level, and types */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|global_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global functions and variables */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|local_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* everything local to lexical context */
end_comment

begin_comment
comment|/* List of unclosed lexical contexts    (that will become blocks, eventually).  */
end_comment

begin_struct
struct|struct
name|context_stack
block|{
name|struct
name|context_stack
modifier|*
name|next
decl_stmt|;
name|struct
name|pending
modifier|*
name|locals
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|old_blocks
decl_stmt|;
name|struct
name|symbol
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|context_stack
modifier|*
name|context_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if within a function (so symbols should be local,    if nothing says specifically).  */
end_comment

begin_decl_stmt
name|int
name|within_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of blocks already made (lexical contexts already closed).    This is used at the end to make the blockvector.  */
end_comment

begin_struct
struct|struct
name|pending_block
block|{
name|struct
name|pending_block
modifier|*
name|next
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pending_block
modifier|*
name|pending_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|startup_file_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From blockframe.c */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|startup_file_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From blockframe.c */
end_comment

begin_comment
comment|/* File name symbols were loaded from.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symfile
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Look up a coff type-number index.  Return the address of the slot    where the type for that index is stored.    The type-number is in INDEX.      This can be used for finding the type associated with that index    or for associating a new type with the index.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|coff_lookup_type
parameter_list|(
name|index
parameter_list|)
specifier|register
name|int
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|int
name|old_vector_length
init|=
name|type_vector_length
decl_stmt|;
name|type_vector_length
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|type_vector_length
operator|<
name|index
condition|)
block|{
name|type_vector_length
operator|=
name|index
operator|*
literal|2
expr_stmt|;
block|}
name|type_vector
operator|=
operator|(
expr|struct
name|typevector
operator|*
operator|)
name|xrealloc
argument_list|(
name|type_vector
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|typevector
argument_list|)
operator|+
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|type_vector
operator|->
name|type
index|[
name|old_vector_length
index|]
argument_list|,
operator|(
name|type_vector_length
operator|-
name|old_vector_length
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|type_vector
operator|->
name|type
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Make sure there is a type allocated for type number index    and return the type object.    This can create an empty (zeroed) type object.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|coff_alloc_type
parameter_list|(
name|index
parameter_list|)
name|int
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
modifier|*
name|type_addr
init|=
name|coff_lookup_type
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
operator|*
name|type_addr
decl_stmt|;
comment|/* If we are referring to a type not known at all yet,      allocate an empty type for it.      We will fill it in later if we find out how.  */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|type_addr
operator|=
name|type
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* maintain the lists of symbols and blocks */
end_comment

begin_comment
comment|/* Add a symbol to one of the lists of symbols.  */
end_comment

begin_function
specifier|static
name|void
name|add_symbol_to_list
parameter_list|(
name|symbol
parameter_list|,
name|listhead
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|listhead
decl_stmt|;
block|{
specifier|register
name|struct
name|pending
modifier|*
name|link
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending
argument_list|)
argument_list|)
decl_stmt|;
name|link
operator|->
name|next
operator|=
operator|*
name|listhead
expr_stmt|;
name|link
operator|->
name|symbol
operator|=
name|symbol
expr_stmt|;
operator|*
name|listhead
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take one of the lists of symbols and make a block from it.    Put the block on the list of pending blocks.  */
end_comment

begin_function
specifier|static
name|void
name|finish_block
parameter_list|(
name|symbol
parameter_list|,
name|listhead
parameter_list|,
name|old_blocks
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|listhead
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|old_blocks
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|struct
name|pending
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|register
name|struct
name|pending_block
modifier|*
name|pblock
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|opblock
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Count the length of the list of symbols.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|block
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the symbols into the block.  */
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|symbol
expr_stmt|;
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|=
name|start
expr_stmt|;
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|=
name|end
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Filled in when containing block is made */
comment|/* Put the block in as the value of the symbol that names it.  */
if|if
condition|(
name|symbol
condition|)
block|{
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
operator|=
name|block
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
name|symbol
expr_stmt|;
block|}
else|else
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now free the links of the list, and empty the list.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|listhead
operator|=
literal|0
expr_stmt|;
comment|/* Install this block as the superblock      of all blocks made since the start of this scope      that don't have superblocks yet.  */
name|opblock
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pblock
operator|=
name|pending_blocks
init|;
name|pblock
operator|!=
name|old_blocks
condition|;
name|pblock
operator|=
name|pblock
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|==
literal|0
condition|)
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|block
expr_stmt|;
name|opblock
operator|=
name|pblock
expr_stmt|;
block|}
comment|/* Record this block on the list of all blocks in the file.      Put it after opblock, or at the beginning if opblock is 0.      This puts the block in the list after all its subblocks.  */
name|pblock
operator|=
operator|(
expr|struct
name|pending_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_block
argument_list|)
argument_list|)
expr_stmt|;
name|pblock
operator|->
name|block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|opblock
condition|)
block|{
name|pblock
operator|->
name|next
operator|=
name|opblock
operator|->
name|next
expr_stmt|;
name|opblock
operator|->
name|next
operator|=
name|pblock
expr_stmt|;
block|}
else|else
block|{
name|pblock
operator|->
name|next
operator|=
name|pending_blocks
expr_stmt|;
name|pending_blocks
operator|=
name|pblock
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|blockvector
modifier|*
name|make_blockvector
parameter_list|()
block|{
specifier|register
name|struct
name|pending_block
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Count the length of the list of blocks.  */
for|for
control|(
name|next
operator|=
name|pending_blocks
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|blockvector
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the blocks into the blockvector.      This is done in reverse order, which happens to put      the blocks into the proper order (ascending starting address).      finish_block has hair to insert each block into the list      after its subblocks in order to make sure this is true.  */
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
name|pending_blocks
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|block
expr_stmt|;
comment|/* Now free the links of the list, and empty the list.  */
for|for
control|(
name|next
operator|=
name|pending_blocks
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|pending_blocks
operator|=
literal|0
expr_stmt|;
return|return
name|blockvector
return|;
block|}
end_function

begin_comment
comment|/* Manage the vector of line numbers.  */
end_comment

begin_expr_stmt
specifier|static
name|record_line
argument_list|(
argument|line
argument_list|,
argument|pc
argument_list|)
name|int
name|line
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|CORE_ADDR
name|pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|linetable_entry
modifier|*
name|e
decl_stmt|;
comment|/* Make sure line vector is big enough.  */
if|if
condition|(
name|line_vector_index
operator|+
literal|2
operator|>=
name|line_vector_length
condition|)
block|{
name|line_vector_length
operator|*=
literal|2
expr_stmt|;
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|line_vector
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|line_vector
operator|->
name|item
operator|+
name|line_vector_index
operator|++
expr_stmt|;
name|e
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|e
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Start a new symtab for a new source file.    This is called when a COFF ".file" symbol is seen;    it indicates the start of data for one original source file.  */
end_comment

begin_function
specifier|static
name|void
name|start_symtab
parameter_list|()
block|{
name|file_symbols
operator|=
literal|0
expr_stmt|;
name|global_symbols
operator|=
literal|0
expr_stmt|;
name|context_stack
operator|=
literal|0
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the source file information for this file.  */
name|line_vector_index
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
literal|1000
expr_stmt|;
name|prev_line_number
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Force first line number to be explicit */
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the vital information for use when closing off the current file.    NAME is the file name the symbols came from, START_ADDR is the first    text address for the file, and SIZE is the number of bytes of text.  */
end_comment

begin_function
specifier|static
name|void
name|complete_symtab
parameter_list|(
name|name
parameter_list|,
name|start_addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|last_source_file
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|cur_src_start_addr
operator|=
name|start_addr
expr_stmt|;
name|cur_src_end_addr
operator|=
name|start_addr
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|aout_hdr
operator|.
name|entry
operator|<
name|cur_src_end_addr
operator|&&
name|aout_hdr
operator|.
name|entry
operator|>=
name|cur_src_start_addr
condition|)
block|{
name|startup_file_start
operator|=
name|cur_src_start_addr
expr_stmt|;
name|startup_file_end
operator|=
name|cur_src_end_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish the symbol definitions for one main source file,    close off all the lexical contexts for that file    (creating struct block's for them), then make the    struct symtab for that file and put it in the list of all such. */
end_comment

begin_function
specifier|static
name|void
name|end_symtab
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
specifier|register
name|struct
name|context_stack
modifier|*
name|cstk
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|lv
decl_stmt|;
comment|/* Finish the lexical context of the last function in the file.  */
if|if
condition|(
name|context_stack
condition|)
block|{
name|cstk
operator|=
name|context_stack
expr_stmt|;
name|context_stack
operator|=
literal|0
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|cstk
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|cstk
operator|->
name|old_blocks
argument_list|,
name|cstk
operator|->
name|start_addr
argument_list|,
name|cur_src_end_addr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cstk
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore a file that has no functions with real debugging info.  */
if|if
condition|(
name|pending_blocks
operator|==
literal|0
operator|&&
name|file_symbols
operator|==
literal|0
operator|&&
name|global_symbols
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|line_vector
argument_list|)
expr_stmt|;
name|line_vector
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
operator|-
literal|1
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Create the two top-level blocks for this file.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|file_symbols
argument_list|,
literal|0
argument_list|,
name|cur_src_start_addr
argument_list|,
name|cur_src_end_addr
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|global_symbols
argument_list|,
literal|0
argument_list|,
name|cur_src_start_addr
argument_list|,
name|cur_src_end_addr
argument_list|)
expr_stmt|;
comment|/* Create the blockvector that points to all the file's blocks.  */
name|blockvector
operator|=
name|make_blockvector
argument_list|()
expr_stmt|;
comment|/* Now create the symtab object for this source file.  */
name|symtab
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Fill in its components.  */
name|symtab
operator|->
name|blockvector
operator|=
name|blockvector
expr_stmt|;
name|symtab
operator|->
name|free_code
operator|=
name|free_linetable
expr_stmt|;
name|symtab
operator|->
name|filename
operator|=
name|last_source_file
expr_stmt|;
name|lv
operator|=
name|line_vector
expr_stmt|;
name|lv
operator|->
name|nitems
operator|=
name|line_vector_index
expr_stmt|;
name|symtab
operator|->
name|linetable
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|lv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|lv
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|symtab
operator|->
name|line_charpos
operator|=
literal|0
expr_stmt|;
comment|/* Link the new symtab into the list of such.  */
name|symtab
operator|->
name|next
operator|=
name|symtab_list
expr_stmt|;
name|symtab_list
operator|=
name|symtab
expr_stmt|;
comment|/* Reinitialize for beginning of new file. */
name|line_vector
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
operator|-
literal|1
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Accumulate the misc functions in bunches of 127.    At the end, copy them all into one newly allocated structure.  */
end_comment

begin_define
define|#
directive|define
name|MISC_BUNCH_SIZE
value|127
end_define

begin_struct
struct|struct
name|misc_bunch
block|{
name|struct
name|misc_bunch
modifier|*
name|next
decl_stmt|;
name|struct
name|misc_function
name|contents
index|[
name|MISC_BUNCH_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bunch currently being filled up.    The next field points to chain of filled bunches.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|misc_bunch
modifier|*
name|misc_bunch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots filled in current bunch.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|misc_bunch_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of misc functions recorded so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|misc_count
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_misc_functions
parameter_list|()
block|{
name|misc_count
operator|=
literal|0
expr_stmt|;
name|misc_bunch
operator|=
literal|0
expr_stmt|;
name|misc_bunch_index
operator|=
name|MISC_BUNCH_SIZE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_misc_function
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|misc_bunch
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|misc_bunch_index
operator|==
name|MISC_BUNCH_SIZE
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|misc_bunch
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|misc_bunch
argument_list|)
argument_list|)
expr_stmt|;
name|misc_bunch_index
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|misc_bunch
expr_stmt|;
name|misc_bunch
operator|=
name|new
expr_stmt|;
block|}
name|misc_bunch
operator|->
name|contents
index|[
name|misc_bunch_index
index|]
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|misc_bunch
operator|->
name|contents
index|[
name|misc_bunch_index
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|misc_bunch
operator|->
name|contents
index|[
name|misc_bunch_index
index|]
operator|.
name|type
operator|=
name|mf_unknown
expr_stmt|;
name|misc_bunch_index
operator|++
expr_stmt|;
name|misc_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* if we see a function symbol, we do record_misc_function.  * however, if it turns out the next symbol is '.bf', then  * we call here to undo the misc definition  */
end_comment

begin_function
specifier|static
name|void
name|unrecord_misc_function
parameter_list|()
block|{
if|if
condition|(
name|misc_bunch_index
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Internal error processing symbol table, at symbol %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|misc_bunch_index
operator|--
expr_stmt|;
name|misc_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_misc_functions
parameter_list|(
name|fn1
parameter_list|,
name|fn2
parameter_list|)
name|struct
name|misc_function
modifier|*
name|fn1
decl_stmt|,
decl|*
name|fn2
decl_stmt|;
end_function

begin_block
block|{
comment|/* Return a signed result based on unsigned comparisons      so that we sort into unsigned numeric order.  */
if|if
condition|(
name|fn1
operator|->
name|address
operator|<
name|fn2
operator|->
name|address
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fn1
operator|->
name|address
operator|>
name|fn2
operator|->
name|address
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|discard_misc_bunches
parameter_list|()
block|{
specifier|register
name|struct
name|misc_bunch
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|misc_bunch
condition|)
block|{
name|next
operator|=
name|misc_bunch
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|misc_bunch
argument_list|)
expr_stmt|;
name|misc_bunch
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|condense_misc_bunches
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|misc_bunch
modifier|*
name|bunch
decl_stmt|;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
name|int
name|offset
init|=
literal|1
decl_stmt|;
else|#
directive|else
name|int
name|offset
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|misc_function_vector
operator|=
operator|(
expr|struct
name|misc_function
operator|*
operator|)
name|xmalloc
argument_list|(
name|misc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|misc_function
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|bunch
operator|=
name|misc_bunch
expr_stmt|;
while|while
condition|(
name|bunch
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_bunch_index
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|tmp
decl_stmt|;
name|misc_function_vector
index|[
name|j
index|]
operator|=
name|bunch
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
expr_stmt|;
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
operator|=
operator|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'_'
condition|?
name|tmp
operator|+
name|offset
else|:
name|tmp
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|bunch
operator|=
name|bunch
operator|->
name|next
expr_stmt|;
name|misc_bunch_index
operator|=
name|MISC_BUNCH_SIZE
expr_stmt|;
block|}
name|misc_function_count
operator|=
name|j
expr_stmt|;
comment|/* Sort the misc functions by address.  */
name|qsort
argument_list|(
name|misc_function_vector
argument_list|,
name|j
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|misc_function
argument_list|)
argument_list|,
name|compare_misc_functions
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call sort_syms to sort alphabetically    the symbols of each block of each symtab.  */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|struct
name|symbol
modifier|*
modifier|*
name|s1
decl_stmt|,
decl|*
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
comment|/* Names that are less should come first.  */
specifier|register
name|int
name|namediff
init|=
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namediff
operator|!=
literal|0
condition|)
return|return
name|namediff
return|;
comment|/* For symbols of the same name, registers should come first.  */
return|return
operator|(
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s2
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|-
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|sort_syms
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nbl
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nbl
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbl
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|qsort
argument_list|(
operator|&
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the symbol-file command.  Read the file, analyze its symbols,    and add a struct symtab to symtab_list.  */
end_comment

begin_function
name|void
name|symbol_file_command
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|desc
decl_stmt|;
name|int
name|num_symbols
decl_stmt|;
name|int
name|num_sections
decl_stmt|;
name|int
name|symtab_offset
decl_stmt|;
specifier|extern
name|void
name|close
parameter_list|()
function_decl|;
specifier|register
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symtab_list
operator|&&
operator|!
name|query
argument_list|(
literal|"Discard symbol table? "
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile
condition|)
name|free
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
name|symfile
operator|=
literal|0
expr_stmt|;
name|free_all_symtabs
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab_list
operator|&&
operator|!
name|query
argument_list|(
literal|"Load new symbol table from \"%s\"? "
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile
condition|)
name|free
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
name|symfile
operator|=
literal|0
expr_stmt|;
block|{
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|absolute_name
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|close
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num_symbols
operator|=
name|read_file_hdr
argument_list|(
name|desc
argument_list|,
operator|&
name|file_hdr
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"File \"%s\" not in executable format."
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If an a.out header is present, read it in.  If not (e.g. a .o file)      deal with its absence.  */
if|if
condition|(
name|file_hdr
operator|.
name|f_opthdr
operator|==
literal|0
operator|||
name|read_aout_hdr
argument_list|(
name|desc
argument_list|,
operator|&
name|aout_hdr
argument_list|,
name|file_hdr
operator|.
name|f_opthdr
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We will not actually be able to run code, since backtraces would 	 fly off the bottom of the stack (there is no way to reliably 	 detect bottom of stack), but that's fine since the kernel won't 	 run something without an a.out header anyway.  Passive examination 	 of .o files is one place this might make sense.  */
comment|/* ~0 will not be in any file.  */
name|aout_hdr
operator|.
name|entry
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* set the startup file to be an empty range.  */
name|startup_file_start
operator|=
literal|0
expr_stmt|;
name|startup_file_end
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_symbols
operator|==
literal|0
condition|)
block|{
name|free_all_symtabs
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"%s does not have a symbol-table.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Reading symbol data from %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Throw away the old symbol table.  */
name|free_all_symtabs
argument_list|()
expr_stmt|;
name|free_all_psymtabs
argument_list|()
expr_stmt|;
comment|/* Make sure that partial_symtab_list */
comment|/* is 0 also. */
name|num_sections
operator|=
name|file_hdr
operator|.
name|f_nscns
expr_stmt|;
name|symtab_offset
operator|=
name|file_hdr
operator|.
name|f_symptr
expr_stmt|;
if|if
condition|(
name|read_section_hdr
argument_list|(
name|desc
argument_list|,
name|_TEXT
argument_list|,
operator|&
name|text_hdr
argument_list|,
name|num_sections
argument_list|,
name|file_hdr
operator|.
name|f_opthdr
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read text section header"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Read the line number table, all at once.  */
name|val
operator|=
name|init_lineno
argument_list|(
name|desc
argument_list|,
name|text_hdr
operator|.
name|s_lnnoptr
argument_list|,
name|text_hdr
operator|.
name|s_nlnno
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": error reading line numbers\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Now read the string table, all at once.  */
name|val
operator|=
name|init_stringtab
argument_list|(
name|desc
argument_list|,
name|symtab_offset
operator|+
name|num_symbols
operator|*
name|SYMESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|free_all_symtabs
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\"%s\": can't get string table"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
name|make_cleanup
argument_list|(
name|free_stringtab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Position to read the symbol table.  Do not read it all at once. */
name|val
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
operator|(
name|long
operator|)
name|symtab_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|init_misc_functions
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_misc_bunches
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the executable file is positioned at symbol table,      process it and define symbols accordingly.  */
name|read_coff_symtab
argument_list|(
name|desc
argument_list|,
name|num_symbols
argument_list|)
expr_stmt|;
name|patch_opaque_types
argument_list|()
expr_stmt|;
comment|/* Sort symbols alphabetically within each block.  */
name|sort_syms
argument_list|()
expr_stmt|;
comment|/* Go over the misc functions and install them in vector.  */
name|condense_misc_bunches
argument_list|()
expr_stmt|;
comment|/* Don't allow char * to have a typename (else would get caddr_t.)  */
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Make a default for file to list.  */
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|symfile
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return name of file symbols were loaded from, or 0 if none..  */
end_comment

begin_function
name|char
modifier|*
name|get_sym_file
parameter_list|()
block|{
return|return
name|symfile
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simplified internal version of coff symbol table information */
end_comment

begin_struct
struct|struct
name|coff_symbol
block|{
name|char
modifier|*
name|c_name
decl_stmt|;
name|int
name|c_symnum
decl_stmt|;
comment|/* symbol number of this entry */
name|int
name|c_nsyms
decl_stmt|;
comment|/* 1 if syment only, 2 if syment + auxent */
name|long
name|c_value
decl_stmt|;
name|int
name|c_sclass
decl_stmt|;
name|int
name|c_secnum
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Given pointers to a symbol table in coff style exec file,    analyze them and create struct symtab's describing the symbols.    NSYMS is the number of symbols in the symbol table.    We read them one at a time using read_one_sym ().  */
end_comment

begin_function
specifier|static
name|void
name|read_coff_symtab
parameter_list|(
name|desc
parameter_list|,
name|nsyms
parameter_list|)
name|int
name|desc
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
block|{
name|int
name|newfd
decl_stmt|;
comment|/* Avoid multiple closes on same desc */
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|struct
name|coff_symbol
name|coff_symbol
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
init|=
operator|&
name|coff_symbol
decl_stmt|;
specifier|static
name|SYMENT
name|main_sym
decl_stmt|;
specifier|static
name|AUXENT
name|main_aux
decl_stmt|;
name|struct
name|coff_symbol
name|fcn_cs_saved
decl_stmt|;
specifier|static
name|SYMENT
name|fcn_sym_saved
decl_stmt|;
specifier|static
name|AUXENT
name|fcn_aux_saved
decl_stmt|;
name|int
name|num_object_files
init|=
literal|0
decl_stmt|;
name|int
name|next_file_symnum
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Name of the current file.  */
name|char
modifier|*
name|filestring
init|=
literal|""
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|fcn_first_line
decl_stmt|;
name|int
name|fcn_last_line
decl_stmt|;
name|int
name|fcn_start_addr
decl_stmt|;
name|long
name|fcn_line_ptr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|newfd
operator|=
name|dup
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"Too many open files"
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fdopen
argument_list|(
name|newfd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_all_symtabs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|nlist_stream_global
operator|=
name|stream
expr_stmt|;
name|nlist_nsyms_global
operator|=
name|nsyms
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|opaque_type_chain
argument_list|,
sizeof|sizeof
name|opaque_type_chain
argument_list|)
expr_stmt|;
name|type_vector_length
operator|=
literal|160
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|typevector
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|typevector
argument_list|)
operator|+
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|type_vector
operator|->
name|type
argument_list|,
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|start_symtab
argument_list|()
expr_stmt|;
name|symnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|symnum
operator|<
name|nsyms
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* Make this command interruptable.  */
name|read_one_sym
argument_list|(
name|cs
argument_list|,
operator|&
name|main_sym
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_symnum
operator|==
name|next_file_symnum
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_FILE
condition|)
block|{
name|CORE_ADDR
name|last_file_end
init|=
name|cur_src_end_addr
decl_stmt|;
if|if
condition|(
name|last_source_file
condition|)
name|end_symtab
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|()
expr_stmt|;
name|complete_symtab
argument_list|(
literal|"_globals_"
argument_list|,
literal|0
argument_list|,
name|first_object_file_end
argument_list|)
expr_stmt|;
comment|/* done with all files, everything from here on out is globals */
block|}
comment|/* Special case for file with type declarations only, no text.  */
if|if
condition|(
operator|!
name|last_source_file
operator|&&
name|cs
operator|->
name|c_type
operator|!=
name|T_NULL
operator|&&
name|cs
operator|->
name|c_secnum
operator|==
name|N_DEBUG
condition|)
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Typedefs should not be treated as symbol definitions.  */
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_TPDEF
condition|)
block|{
comment|/* record as misc function.  if we get '.bf' next, 	   * then we undo this step 	   */
name|record_misc_function
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
name|fcn_line_ptr
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
expr_stmt|;
name|fcn_start_addr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|fcn_cs_saved
operator|=
operator|*
name|cs
expr_stmt|;
name|fcn_sym_saved
operator|=
name|main_sym
expr_stmt|;
name|fcn_aux_saved
operator|=
name|main_aux
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_EFCN
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
case|case
name|C_USTATIC
case|:
case|case
name|C_LINE
case|:
case|case
name|C_ALIAS
case|:
case|case
name|C_HIDDEN
case|:
name|printf
argument_list|(
literal|"Bad n_sclass = %d\n"
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_FILE
case|:
comment|/* 	     * c_value field contains symnum of next .file entry in table 	     * or symnum of first global after last .file. 	     */
name|next_file_symnum
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|filestring
operator|=
name|getfilename
argument_list|(
operator|&
name|main_aux
argument_list|)
expr_stmt|;
comment|/* 	     * Complete symbol table for last object file 	     * containing debugging information. 	     */
if|if
condition|(
name|last_source_file
condition|)
block|{
name|end_symtab
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|()
expr_stmt|;
block|}
name|num_object_files
operator|++
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|num_object_files
operator|==
literal|1
condition|)
block|{
comment|/* last address of startup file */
name|first_object_file_end
operator|=
name|cs
operator|->
name|c_value
operator|+
name|main_aux
operator|.
name|x_scn
operator|.
name|x_scnlen
expr_stmt|;
block|}
comment|/* for some reason the old code didn't do 			     * this if this section entry had 			     * main_aux.x_scn.x_nlinno equal to 0 			     */
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|main_aux
operator|.
name|x_scn
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
block|}
comment|/* flush rest of '.' symbols */
break|break;
block|}
comment|/* fall in for static symbols that don't start with '.' */
case|case
name|C_EXT
case|:
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|&&
name|cs
operator|->
name|c_secnum
operator|==
name|N_ABS
operator|&&
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|_ETEXT
argument_list|)
operator|==
literal|0
condition|)
name|end_of_text_addr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_type
operator|==
name|T_NULL
condition|)
block|{
if|if
condition|(
name|cs
operator|->
name|c_secnum
operator|<=
literal|1
condition|)
block|{
comment|/* text or abs */
name|record_misc_function
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|cs
operator|->
name|c_type
operator|=
name|T_INT
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|process_coff_symbol
argument_list|(
name|cs
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_FCN
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bf"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Don't do this; we want all functions to be on the 		   mfl now.  */
block|unrecord_misc_function ();
endif|#
directive|endif
name|within_function
operator|=
literal|1
expr_stmt|;
comment|/* value contains address of first non-init type code */
comment|/* main_aux.x_sym.x_misc.x_lnsz.x_lnno 			    contains line number of '{' } */
name|fcn_first_line
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|depth
operator|=
name|depth
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|context_stack
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|locals
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|old_blocks
operator|=
name|pending_blocks
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|fcn_start_addr
expr_stmt|;
name|fcn_cs_saved
operator|.
name|c_name
operator|=
name|getsymname
argument_list|(
operator|&
name|fcn_sym_saved
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|process_coff_symbol
argument_list|(
operator|&
name|fcn_cs_saved
argument_list|,
operator|&
name|fcn_aux_saved
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".ef"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* the value of .ef is the address of epilogue code; 		       * not useful for gdb 		       */
comment|/* { main_aux.x_sym.x_misc.x_lnsz.x_lnno 			    contains number of lines to '}' */
name|fcn_last_line
operator|=
name|main_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
name|enter_linenos
argument_list|(
name|fcn_line_ptr
argument_list|,
name|fcn_first_line
argument_list|,
name|fcn_last_line
argument_list|)
expr_stmt|;
name|new
operator|=
name|context_stack
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid symbol data; .bf/.ef/.bb/.eb symbol mismatch, at symbol %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|fcn_cs_saved
operator|.
name|c_value
operator|+
name|fcn_aux_saved
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
name|context_stack
operator|=
literal|0
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C_BLOCK
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
name|new
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|context_stack
expr_stmt|;
name|context_stack
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|locals
operator|=
name|local_symbols
expr_stmt|;
name|new
operator|->
name|old_blocks
operator|=
name|pending_blocks
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|new
operator|->
name|name
operator|=
literal|0
expr_stmt|;
name|local_symbols
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".eb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|context_stack
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|||
name|depth
operator|!=
name|new
operator|->
name|depth
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: .bb/.eb symbol mismatch at symbol %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_symbols
operator|&&
name|context_stack
operator|->
name|next
condition|)
block|{
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
block|}
name|depth
operator|--
expr_stmt|;
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
name|context_stack
operator|=
name|new
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
operator|(
name|void
operator|)
name|process_coff_symbol
argument_list|(
name|cs
argument_list|,
operator|&
name|main_aux
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|last_source_file
condition|)
name|end_symtab
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for reading headers and symbols from executable.  */
end_comment

begin_comment
comment|/* Read COFF file header, check magic number,    and return number of symbols. */
end_comment

begin_macro
name|read_file_hdr
argument_list|(
argument|chan
argument_list|,
argument|file_hdr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILHDR
modifier|*
name|file_hdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lseek
argument_list|(
name|chan
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|chan
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file_hdr
argument_list|,
name|FILHSZ
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|file_hdr
operator|->
name|f_magic
condition|)
block|{
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|MC68MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS32GMAGIC
case|case
name|NS32GMAGIC
case|:
case|case
name|NS32SMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|I386MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLIPPERMAGIC
case|case
name|CLIPPERMAGIC
case|:
endif|#
directive|endif
return|return
name|file_hdr
operator|->
name|f_nsyms
return|;
default|default:
ifdef|#
directive|ifdef
name|BADMAG
if|if
condition|(
name|BADMAG
argument_list|(
name|file_hdr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|file_hdr
operator|->
name|f_nsyms
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|read_aout_hdr
argument_list|(
argument|chan
argument_list|,
argument|aout_hdr
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AOUTHDR
modifier|*
name|aout_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lseek
argument_list|(
name|chan
argument_list|,
operator|(
name|long
operator|)
name|FILHSZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|myread
argument_list|(
name|chan
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aout_hdr
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Read a section header.  OPTIONAL_HEADER_SIZE is the size of the    optional header (normally f_opthdr from the file header).     Return nonnegative for success, -1 for failure.  */
end_comment

begin_function
name|int
name|read_section_hdr
parameter_list|(
name|chan
parameter_list|,
name|section_name
parameter_list|,
name|section_hdr
parameter_list|,
name|nsects
parameter_list|,
name|optional_header_size
parameter_list|)
specifier|register
name|int
name|chan
decl_stmt|;
specifier|register
name|char
modifier|*
name|section_name
decl_stmt|;
name|SCNHDR
modifier|*
name|section_hdr
decl_stmt|;
specifier|register
name|int
name|nsects
decl_stmt|;
name|int
name|optional_header_size
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|chan
argument_list|,
name|FILHSZ
operator|+
name|optional_header_size
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsects
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|myread
argument_list|(
name|chan
argument_list|,
operator|(
name|char
operator|*
operator|)
name|section_hdr
argument_list|,
name|SCNHSZ
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|section_hdr
operator|->
name|s_name
argument_list|,
name|section_name
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|read_one_sym
argument_list|(
name|cs
argument_list|,
name|sym
argument_list|,
name|aux
argument_list|)
specifier|register
expr|struct
name|coff_symbol
operator|*
name|cs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|SYMENT
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|AUXENT
modifier|*
name|aux
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cs
operator|->
name|c_symnum
operator|=
name|symnum
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
argument_list|,
name|SYMESZ
argument_list|,
literal|1
argument_list|,
name|nlist_stream_global
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_nsyms
operator|=
operator|(
name|sym
operator|->
name|n_numaux
operator|&
literal|0xff
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_nsyms
operator|==
literal|2
condition|)
block|{
comment|/* doc for coff says there is either no aux entry or just one */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
argument_list|,
name|AUXESZ
argument_list|,
literal|1
argument_list|,
name|nlist_stream_global
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_nsyms
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"more than one aux symbol table entry at symnum=%d\n"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_name
operator|=
name|getsymname
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_value
operator|=
name|sym
operator|->
name|n_value
expr_stmt|;
name|cs
operator|->
name|c_sclass
operator|=
operator|(
name|sym
operator|->
name|n_sclass
operator|&
literal|0xff
operator|)
expr_stmt|;
name|cs
operator|->
name|c_secnum
operator|=
name|sym
operator|->
name|n_scnum
expr_stmt|;
name|cs
operator|->
name|c_type
operator|=
operator|(
name|unsigned
operator|)
name|sym
operator|->
name|n_type
expr_stmt|;
name|symnum
operator|+=
name|cs
operator|->
name|c_nsyms
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Support for string table handling */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stringtab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_stringtab
parameter_list|(
name|chan
parameter_list|,
name|offset
parameter_list|)
name|int
name|chan
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|long
name|buffer
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|stringtab
condition|)
block|{
name|free
argument_list|(
name|stringtab
argument_list|)
expr_stmt|;
name|stringtab
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|chan
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|myread
argument_list|(
name|chan
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
comment|/* If no string table is needed, then the file may end immediately      after the symbols.  Just return with `stringtab' set to null. */
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|buffer
operator|||
name|buffer
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|stringtab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringtab
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bcopy
argument_list|(
operator|&
name|buffer
argument_list|,
name|stringtab
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|chan
argument_list|,
name|stringtab
operator|+
sizeof|sizeof
name|buffer
argument_list|,
name|buffer
operator|-
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|buffer
operator|-
sizeof|sizeof
name|buffer
operator|||
name|stringtab
index|[
name|buffer
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_stringtab
parameter_list|()
block|{
if|if
condition|(
name|stringtab
condition|)
name|free
argument_list|(
name|stringtab
argument_list|)
expr_stmt|;
name|stringtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getsymname
parameter_list|(
name|symbol_entry
parameter_list|)
name|SYMENT
modifier|*
name|symbol_entry
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|symbol_entry
operator|->
name|n_zeroes
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|stringtab
operator|+
name|symbol_entry
operator|->
name|n_offset
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|symbol_entry
operator|->
name|n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buffer
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|buffer
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getfilename
parameter_list|(
name|aux_entry
parameter_list|)
name|AUXENT
modifier|*
name|aux_entry
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|COFF_NO_LONG_FILE_NAMES
if|if
condition|(
name|aux_entry
operator|->
name|x_file
operator|.
name|x_foff
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|stringtab
operator|+
name|aux_entry
operator|->
name|x_file
operator|.
name|x_foff
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|aux_entry
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
name|buffer
index|[
name|FILNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|result
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|rindex
argument_list|(
name|result
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|result
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Support for line number handling */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linetab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|linetab_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linetab_count
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_lineno
parameter_list|(
name|chan
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|int
name|chan
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|chan
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|linetab
condition|)
name|free
argument_list|(
name|linetab
argument_list|)
expr_stmt|;
name|linetab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
name|LINESZ
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|chan
argument_list|,
name|linetab
argument_list|,
name|count
operator|*
name|LINESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|count
operator|*
name|LINESZ
condition|)
return|return
operator|-
literal|1
return|;
name|linetab_offset
operator|=
name|offset
expr_stmt|;
name|linetab_count
operator|=
name|count
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|enter_linenos
parameter_list|(
name|file_offset
parameter_list|,
name|first_line
parameter_list|,
name|last_line
parameter_list|)
name|long
name|file_offset
decl_stmt|;
specifier|register
name|int
name|first_line
decl_stmt|;
specifier|register
name|int
name|last_line
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|rawptr
init|=
operator|&
name|linetab
index|[
name|file_offset
operator|-
name|linetab_offset
index|]
decl_stmt|;
name|struct
name|lineno
name|lptr
decl_stmt|;
comment|/* skip first line entry for each function */
name|rawptr
operator|+=
name|LINESZ
expr_stmt|;
comment|/* line numbers start at one for the first line of the function */
name|first_line
operator|--
expr_stmt|;
comment|/* Bcopy since occaisionally rawptr isn't pointing at long      boundaries.  */
for|for
control|(
name|bcopy
argument_list|(
name|rawptr
argument_list|,
operator|&
name|lptr
argument_list|,
name|LINESZ
argument_list|)
init|;
name|lptr
operator|.
name|l_lnno
operator|&&
name|lptr
operator|.
name|l_lnno
operator|<=
name|last_line
condition|;
name|rawptr
operator|+=
name|LINESZ
operator|,
name|bcopy
argument_list|(
name|rawptr
argument_list|,
operator|&
name|lptr
argument_list|,
name|LINESZ
argument_list|)
control|)
block|{
name|record_line
argument_list|(
name|first_line
operator|+
name|lptr
operator|.
name|l_lnno
argument_list|,
name|lptr
operator|.
name|l_addr
operator|.
name|l_paddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|hashname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|;
specifier|register
name|int
name|total
init|=
name|p
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|total
operator|+=
name|p
index|[
literal|3
index|]
operator|<<
literal|6
expr_stmt|;
block|}
return|return
name|total
operator|%
name|HASHSIZE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|patch_type
parameter_list|(
name|type
parameter_list|,
name|real_type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|real_target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|real_type
argument_list|)
decl_stmt|;
name|int
name|field_size
init|=
name|TYPE_NFIELDS
argument_list|(
name|real_target
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
decl_stmt|;
name|TYPE_LENGTH
argument_list|(
name|target
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|real_target
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|target
argument_list|)
operator|=
name|TYPE_NFIELDS
argument_list|(
name|real_target
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|target
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
name|field_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|real_target
argument_list|)
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|target
argument_list|)
argument_list|,
name|field_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|real_target
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
condition|)
name|free
argument_list|(
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
operator|=
name|concat
argument_list|(
name|TYPE_NAME
argument_list|(
name|real_target
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Patch up all appropriate typdef symbols in the opaque_type_chains    so that they can be used to print out opaque data structures properly */
end_comment

begin_function
specifier|static
name|void
name|patch_opaque_types
parameter_list|()
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
comment|/* Look at each symbol in the per-file block of each symtab.  */
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Go through the per-file symbols only */
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|real_sym
decl_stmt|;
comment|/* Find completed typedefs to use to fix opaque ones. 	     Remove syms from the chain when their types are stored, 	     but search the whole chain, as there may be several syms 	     from different files with the same name.  */
name|real_sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|real_sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|real_sym
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|SYMBOL_NAME
argument_list|(
name|real_sym
argument_list|)
decl_stmt|;
specifier|register
name|int
name|hash
init|=
name|hashname
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|opaque_type_chain
index|[
name|hash
index|]
init|;
name|sym
condition|;
control|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|SYMBOL_VALUE
argument_list|(
name|prev
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|opaque_type_chain
index|[
name|hash
index|]
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|patch_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|real_sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|prev
argument_list|)
expr_stmt|;
else|else
name|sym
operator|=
name|opaque_type_chain
index|[
name|hash
index|]
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|process_coff_symbol
parameter_list|(
name|cs
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
specifier|register
name|AUXENT
modifier|*
name|aux
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|dot
decl_stmt|;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
name|int
name|offset
init|=
literal|1
decl_stmt|;
else|#
directive|else
name|int
name|offset
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|?
name|name
operator|+
name|offset
else|:
name|name
operator|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
name|symbol_obstack
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* default assumptions */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|decode_function_type
argument_list|(
name|cs
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_STAT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_NULL
case|:
break|break;
case|case
name|C_AUTO
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
block|{
comment|/* Static symbol of local scope */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Static symbol at top level of file */
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C_REG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
break|break;
case|case
name|C_ARG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|clipper
comment|/* If PCC says a parameter is a short or a char, 	       it is really an int.  */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_char
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_short
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_char
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_short
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_unsigned_int
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|C_REGPARM
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|clipper
comment|/* If PCC says a parameter is a short or a char, 	       it is really an int.  */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_char
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_short
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_char
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_short
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_unsigned_int
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|C_TPDEF
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* If type has no name, give it one */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|concat
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Keep track of any type which points to empty structured type, 		so it can be filled from a definition from another file */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|int
operator|)
name|opaque_type_chain
index|[
name|i
index|]
expr_stmt|;
name|opaque_type_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
operator|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_ENTAG
condition|?
literal|"enum "
else|:
operator|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_STRTAG
condition|?
literal|"struct "
else|:
literal|"union "
operator|)
operator|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|sym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a coff type specifier;    return the type that is meant.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|AUXENT
modifier|*
name|aux
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|new_c_type
decl_stmt|;
if|if
condition|(
name|c_type
operator|&
operator|~
name|N_BTMASK
condition|)
block|{
name|new_c_type
operator|=
name|DECREF
argument_list|(
name|c_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPTR
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISFCN
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|c_type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|dim
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
comment|/* Define an array type.  */
comment|/* auxent refers to array, not base type */
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|==
literal|0
condition|)
name|cs
operator|->
name|c_nsyms
operator|=
literal|1
expr_stmt|;
comment|/* shift the indices down */
name|dim
operator|=
operator|&
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|dim
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|dim
operator|&&
name|i
operator|<
name|DIMNUM
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|dim
operator|++
control|)
operator|*
name|dim
operator|=
operator|*
operator|(
name|dim
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dim
operator|=
literal|0
expr_stmt|;
name|type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|decode_type
argument_list|(
name|cs
argument_list|,
name|new_c_type
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|base_type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|n
operator|*
name|TYPE_LENGTH
argument_list|(
name|base_type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
comment|/* Reference to existing type */
if|if
condition|(
name|cs
operator|->
name|c_nsyms
operator|>
literal|1
operator|&&
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
return|return
name|decode_base_type
argument_list|(
name|cs
argument_list|,
name|BTYPE
argument_list|(
name|c_type
argument_list|)
argument_list|,
name|aux
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a coff type specifier for function definition;    return the type that the function returns.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_function_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|AUXENT
modifier|*
name|aux
decl_stmt|;
block|{
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|==
literal|0
condition|)
name|cs
operator|->
name|c_nsyms
operator|=
literal|1
expr_stmt|;
comment|/* auxent refers to function, not base type */
return|return
name|decode_type
argument_list|(
name|cs
argument_list|,
name|DECREF
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
argument_list|,
name|aux
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* basic C types */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_base_type
parameter_list|(
name|cs
parameter_list|,
name|c_type
parameter_list|,
name|aux
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
specifier|register
name|AUXENT
modifier|*
name|aux
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|c_type
condition|)
block|{
case|case
name|T_NULL
case|:
comment|/* shows up with "void (*foo)();" structure members */
return|return
name|builtin_type_void
return|;
case|case
name|T_ARG
case|:
comment|/* shouldn't show up here */
break|break;
case|case
name|T_CHAR
case|:
return|return
name|builtin_type_char
return|;
case|case
name|T_SHORT
case|:
return|return
name|builtin_type_short
return|;
case|case
name|T_INT
case|:
return|return
name|builtin_type_int
return|;
case|case
name|T_LONG
case|:
return|return
name|builtin_type_long
return|;
case|case
name|T_FLOAT
case|:
return|return
name|builtin_type_float
return|;
case|case
name|T_DOUBLE
case|:
return|return
name|builtin_type_double
return|;
case|case
name|T_STRUCT
case|:
if|if
condition|(
name|cs
operator|->
name|c_nsyms
operator|!=
literal|2
condition|)
block|{
comment|/* anonymous structure type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|concat
argument_list|(
literal|"struct "
argument_list|,
literal|"<opaque>"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|read_struct_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|T_UNION
case|:
if|if
condition|(
name|cs
operator|->
name|c_nsyms
operator|!=
literal|2
condition|)
block|{
comment|/* anonymous union type */
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|concat
argument_list|(
literal|"union "
argument_list|,
literal|"<opaque>"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|read_struct_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
return|return
name|type
return|;
case|case
name|T_ENUM
case|:
return|return
name|read_enum_type
argument_list|(
name|cs
operator|->
name|c_symnum
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
return|;
case|case
name|T_MOE
case|:
comment|/* shouldn't show up here */
break|break;
case|case
name|T_UCHAR
case|:
return|return
name|builtin_type_unsigned_char
return|;
case|case
name|T_USHORT
case|:
return|return
name|builtin_type_unsigned_short
return|;
case|case
name|T_UINT
case|:
return|return
name|builtin_type_unsigned_int
return|;
case|case
name|T_ULONG
case|:
return|return
name|builtin_type_unsigned_long
return|;
block|}
name|printf
argument_list|(
literal|"unexpected type %d at symnum %d\n"
argument_list|,
name|c_type
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
return|return
name|builtin_type_void
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines of read_type.  */
end_comment

begin_comment
comment|/* Read the description of a structure (or union type)    and return an object describing the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|(
name|index
parameter_list|,
name|length
parameter_list|,
name|lastsym
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|lastsym
decl_stmt|;
block|{
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|struct
name|nextfield
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|int
name|nfields
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
name|int
name|offset
init|=
literal|1
decl_stmt|;
else|#
directive|else
name|int
name|offset
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|struct
name|coff_symbol
name|member_sym
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|ms
init|=
operator|&
name|member_sym
decl_stmt|;
name|SYMENT
name|sub_sym
decl_stmt|;
name|AUXENT
name|sub_aux
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|symnum
operator|<
name|lastsym
operator|&&
name|symnum
operator|<
name|nlist_nsyms_global
condition|)
block|{
name|read_one_sym
argument_list|(
name|ms
argument_list|,
operator|&
name|sub_sym
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|name
operator|=
name|ms
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|?
name|name
operator|+
name|offset
else|:
name|name
operator|)
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_MOS
case|:
case|case
name|C_MOU
case|:
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Save the data.  */
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|decode_type
argument_list|(
name|ms
argument_list|,
name|ms
operator|->
name|c_type
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
literal|8
operator|*
name|ms
operator|->
name|c_value
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
break|break;
case|case
name|C_FIELD
case|:
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Save the data.  */
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|decode_type
argument_list|(
name|ms
argument_list|,
name|ms
operator|->
name|c_type
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
name|ms
operator|->
name|c_value
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
name|sub_aux
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now create the vector of fields, and record how big it is.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
operator|--
name|n
argument_list|)
operator|=
name|list
operator|->
name|field
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a definition of an enumeration type,    and create and return a suitable type object.    Also defines the symbols that represent the values of the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|(
name|index
parameter_list|,
name|length
parameter_list|,
name|lastsym
parameter_list|)
name|int
name|index
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|lastsym
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|;
name|struct
name|coff_symbol
name|member_sym
decl_stmt|;
specifier|register
name|struct
name|coff_symbol
modifier|*
name|ms
init|=
operator|&
name|member_sym
decl_stmt|;
name|SYMENT
name|sub_sym
decl_stmt|;
name|AUXENT
name|sub_aux
decl_stmt|;
name|struct
name|pending
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
name|int
name|offset
init|=
literal|1
decl_stmt|;
else|#
directive|else
name|int
name|offset
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|type
operator|=
name|coff_alloc_type
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
name|symlist
operator|=
operator|&
name|local_symbols
expr_stmt|;
else|else
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
while|while
condition|(
name|symnum
operator|<
name|lastsym
operator|&&
name|symnum
operator|<
name|nlist_nsyms_global
condition|)
block|{
name|read_one_sym
argument_list|(
name|ms
argument_list|,
operator|&
name|sub_sym
argument_list|,
operator|&
name|sub_aux
argument_list|)
expr_stmt|;
name|name
operator|=
name|ms
operator|->
name|c_name
expr_stmt|;
name|name
operator|=
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|?
name|name
operator|+
name|offset
else|:
name|name
operator|)
expr_stmt|;
switch|switch
condition|(
name|ms
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_MOE
case|:
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|ms
operator|->
name|c_value
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
break|break;
case|case
name|C_EOS
case|:
break|break;
block|}
block|}
comment|/* Now fill in the fields of the type-structure.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the values and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
name|nsyms
init|;
name|syms
operator|!=
name|osyms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|syms
operator|->
name|symbol
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
operator|--
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|syms
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VALUE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|syms
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* This function is really horrible, but to avoid it, there would need    to be more filling in of forward references.  THIS SHOULD BE MOVED    OUT OF COFFREAD.C AND DBXREAD.C TO SOME PLACE WHERE IT CAN BE SHARED. */
end_comment

begin_function
name|int
name|fill_in_vptr_fieldno
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|fill_in_vptr_fieldno
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* partial symbol tables are not implemented in coff, therefore    block_for_pc() (and others) will never decide to call this. */
end_comment

begin_function
specifier|extern
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"error: Someone called psymtab_to_symtab\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These will stay zero all the time */
end_comment

begin_decl_stmt
name|struct
name|psymbol_allocation_list
name|global_psymbols
decl_stmt|,
name|static_psymbols
decl_stmt|;
end_decl_stmt

begin_macro
name|_initialize_coff
argument_list|()
end_macro

begin_block
block|{
name|symfile
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|global_psymbols
argument_list|,
sizeof|sizeof
argument_list|(
name|global_psymbols
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|static_psymbols
argument_list|,
sizeof|sizeof
argument_list|(
name|static_psymbols
argument_list|)
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"symbol-file"
argument_list|,
name|class_files
argument_list|,
name|symbol_file_command
argument_list|,
literal|"Load symbol table (in coff format) from executable file FILE."
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF_FORMAT */
end_comment

end_unit

