begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)blockframe.c	6.4 (Berkeley) 5/11/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Get info from stack frames;    convert between frames, blocks, functions and pc values.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEWVM
argument_list|)
operator|&&
name|defined
argument_list|(
name|KERNELDEBUG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* XXX for FRAME_CHAIN_VALID */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Start and end of object file containing the entry point.    STARTUP_FILE_END is the first address of the next file.    This file is assumed to be a startup file    and frames with pc's inside it    are treated as nonexistent.     Setting these variables is necessary so that backtraces do not fly off    the bottom of the stack.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|startup_file_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|startup_file_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is ADDR outside the startup file?  */
end_comment

begin_function
name|int
name|outside_startup_file
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
return|return
operator|!
operator|(
name|addr
operator|>=
name|startup_file_start
operator|&&
name|addr
operator|<
name|startup_file_end
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Address of innermost stack frame (contents of FP register) */
end_comment

begin_decl_stmt
specifier|static
name|FRAME
name|current_frame
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|block
modifier|*
name|block_for_pc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|CORE_ADDR
name|get_pc_function_start
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Cache for frame addresses already read by gdb.  Valid only while  * inferior is stopped.  Control variables for the frame cache should  * be local to this module.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the innermost (currently executing) stack frame.  */
end_comment

begin_function
name|FRAME
name|get_current_frame
parameter_list|()
block|{
comment|/* We assume its address is kept in a general register;      param.h says which register.  */
return|return
name|current_frame
return|;
block|}
end_function

begin_function
name|void
name|set_current_frame
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|current_frame
operator|=
name|frame
expr_stmt|;
block|}
end_function

begin_function
name|FRAME
name|create_new_frame
parameter_list|(
name|addr
parameter_list|,
name|pc
parameter_list|)
name|FRAME_ADDR
name|addr
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fci
decl_stmt|;
comment|/* Same type as FRAME */
name|fci
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Arbitrary frame */
name|fci
operator|->
name|next
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
expr_stmt|;
name|fci
operator|->
name|prev
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
expr_stmt|;
name|fci
operator|->
name|frame
operator|=
name|addr
expr_stmt|;
name|fci
operator|->
name|next_frame
operator|=
literal|0
expr_stmt|;
comment|/* Since arbitrary */
name|fci
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXTRA_FRAME_INFO
name|INIT_EXTRA_FRAME_INFO
argument_list|(
name|fci
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fci
return|;
block|}
end_function

begin_comment
comment|/* Return the frame that called FRAME.    If FRAME is the original frame (it has no caller), return 0.  */
end_comment

begin_function
name|FRAME
name|get_prev_frame
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
comment|/* We're allowed to know that FRAME and "struct frame_info *" are      the same */
return|return
name|get_prev_frame_info
argument_list|(
name|frame
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the frame that FRAME calls (0 if FRAME is the innermost    frame).  */
end_comment

begin_function
name|FRAME
name|get_next_frame
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
comment|/* We're allowed to know that FRAME and "struct frame_info *" are      the same */
return|return
name|frame
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the entire frame cache.  */
end_comment

begin_function
name|void
name|flush_cached_frames
parameter_list|()
block|{
comment|/* Since we can't really be sure what the first object allocated was */
name|obstack_free
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
name|current_frame
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Invalidate cache */
block|}
end_function

begin_comment
comment|/* Return a structure containing various interesting information    about a specified stack frame.  */
end_comment

begin_comment
comment|/* How do I justify including this function?  Well, the FRAME    identifier format has gone through several changes recently, and    it's not completely inconceivable that it could happen again.  If    it does, have this routine around will help */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_frame_info
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* If a machine allows frameless functions, it should define a macro    FRAMELESS_FUNCTION_INVOCATION(FI, FRAMELESS) in param.h.  FI is the struct    frame_info for the frame, and FRAMELESS should be set to nonzero    if it represents a frameless function invocation.  */
end_comment

begin_comment
comment|/* Many machines which allow frameless functions can detect them using    this macro.  Such machines should define FRAMELESS_FUNCTION_INVOCATION    to just call this macro.  */
end_comment

begin_define
define|#
directive|define
name|FRAMELESS_LOOK_FOR_PROLOGUE
parameter_list|(
name|FI
parameter_list|,
name|FRAMELESS
parameter_list|)
define|\
value|{      	       	       	       	       	       	       	       	       	 \   CORE_ADDR func_start, after_prologue;			                 \   func_start = (get_pc_function_start ((FI)->pc) +	                 \ 		FUNCTION_START_OFFSET);			                 \   if (func_start)                                                        \     {									 \       after_prologue = func_start;					 \       SKIP_PROLOGUE (after_prologue);					 \       (FRAMELESS) = (after_prologue == func_start);			 \     }									 \   else									 \
comment|/* If we can't find the start of the function, we don't really */
value|\
comment|/* know whether the function is frameless, but we should be	   */
value|\
comment|/* able to get a reasonable (i.e. best we can do under the	   */
value|\
comment|/* circumstances) backtrace by saying that it isn't.  */
value|\     (FRAMELESS) = 0;							 \ }
end_define

begin_comment
comment|/* Return a structure containing various interesting information    about the frame that called NEXT_FRAME.  Returns NULL    if there is no such frame.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|get_prev_frame_info
parameter_list|(
name|next_frame
parameter_list|)
name|FRAME
name|next_frame
decl_stmt|;
block|{
name|FRAME_ADDR
name|address
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|prev
decl_stmt|;
name|int
name|fromleaf
init|=
literal|0
decl_stmt|;
comment|/* If the requested entry is in the cache, return it.      Otherwise, figure out what the address should be for the entry      we're about to add to the cache. */
if|if
condition|(
operator|!
name|next_frame
condition|)
block|{
if|if
condition|(
operator|!
name|current_frame
condition|)
block|{
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
operator|&&
operator|!
name|have_core_file_p
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"get_prev_frame_info: Called before cache primed.  \"Shouldn't happen.\""
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
block|}
return|return
name|current_frame
return|;
block|}
comment|/* If we have the prev one, return it */
if|if
condition|(
name|next_frame
operator|->
name|prev
condition|)
return|return
name|next_frame
operator|->
name|prev
return|;
comment|/* On some machines it is possible to call a function without      setting up a stack frame for it.  On these machines, we      define this macro to take two args; a frameinfo pointer      identifying a frame and a variable to set or clear if it is      or isn't leafless.  */
ifdef|#
directive|ifdef
name|FRAMELESS_FUNCTION_INVOCATION
comment|/* Still don't want to worry about this except on the innermost      frame.  This macro will set FROMLEAF if NEXT_FRAME is a      frameless function invocation.  */
if|if
condition|(
operator|!
operator|(
name|next_frame
operator|->
name|next
operator|)
condition|)
block|{
name|FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|next_frame
argument_list|,
name|fromleaf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromleaf
condition|)
name|address
operator|=
name|next_frame
operator|->
name|frame
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|fromleaf
condition|)
block|{
comment|/* Two macros defined in param.h specify the machine-dependent 	 actions to be performed here. 	 First, get the frame's chain-pointer. 	 If that is zero, the frame is the outermost frame or a leaf 	 called by the outermost frame.  This means that if start 	 calls main without a frame, we'll return 0 (which is fine 	 anyway).  	 Nope; there's a problem.  This also returns when the current 	 routine is a leaf of main.  This is unacceptable.  We move 	 this to after the ffi test; I'd rather have backtraces from 	 start go curfluy than have an abort called from main not show 	 main.  */
name|address
operator|=
name|FRAME_CHAIN
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FRAME_CHAIN_VALID
argument_list|(
name|address
argument_list|,
name|next_frame
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this frame is a leaf, this will be superceeded by the 	 code below.  */
name|address
operator|=
name|FRAME_CHAIN_COMBINE
argument_list|(
name|address
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|address
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|prev
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_frame
condition|)
name|next_frame
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|next_frame
expr_stmt|;
name|prev
operator|->
name|prev
operator|=
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
expr_stmt|;
name|prev
operator|->
name|frame
operator|=
name|address
expr_stmt|;
name|prev
operator|->
name|next_frame
operator|=
name|prev
operator|->
name|next
condition|?
name|prev
operator|->
name|next
operator|->
name|frame
else|:
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXTRA_FRAME_INFO
name|INIT_EXTRA_FRAME_INFO
argument_list|(
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This entry is in the frame queue now, which is good since      FRAME_SAVED_PC may use that queue to figure out it's value      (see m-sparc.h).  We want the pc saved in the inferior frame. */
name|prev
operator|->
name|pc
operator|=
operator|(
name|fromleaf
condition|?
name|SAVED_PC_AFTER_CALL
argument_list|(
name|next_frame
argument_list|)
else|:
name|next_frame
condition|?
name|FRAME_SAVED_PC
argument_list|(
name|next_frame
argument_list|)
else|:
name|read_pc
argument_list|()
operator|)
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_frame_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Find the addresses in which registers are saved in FRAME.  */
end_comment

begin_function
name|void
name|get_frame_saved_regs
parameter_list|(
name|frame_info_addr
parameter_list|,
name|saved_regs_addr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame_info_addr
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|saved_regs_addr
decl_stmt|;
block|{
name|FRAME_FIND_SAVED_REGS
argument_list|(
name|frame_info_addr
argument_list|,
operator|*
name|saved_regs_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the innermost lexical block in execution    in a specified stack frame.  The frame address is assumed valid.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_frame_block
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next_frame
operator|!=
literal|0
condition|)
comment|/* We are not in the innermost frame.  We need to subtract one to        get the correct block, in case the call instruction was the        last instruction of the block.  If there are any machines on        which the saved pc does not point to after the call insn, we        probably want to make fi->pc point after the call insn anyway.  */
operator|--
name|pc
expr_stmt|;
return|return
name|block_for_pc
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|block
modifier|*
name|get_current_block
parameter_list|()
block|{
return|return
name|block_for_pc
argument_list|(
name|read_pc
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|get_pc_function_start
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|bl
init|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
operator|||
operator|(
name|symbol
operator|=
name|block_function
argument_list|(
name|bl
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|misc_index
init|=
name|find_pc_misc_function
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|misc_index
operator|>=
literal|0
condition|)
return|return
name|misc_function_vector
index|[
name|misc_index
index|]
operator|.
name|address
return|;
return|return
literal|0
return|;
block|}
name|bl
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
return|return
name|BLOCK_START
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol for the function executing in frame FRAME.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|get_frame_function
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|bl
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|bl
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the innermost lexical block containing the specified pc value,    or 0 if there is none.  */
end_comment

begin_function_decl
specifier|extern
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|struct
name|block
modifier|*
name|block_for_pc
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bl
decl_stmt|;
comment|/* First search all symtabs for one whose file contains our pc */
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bl
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
condition|)
break|break;
block|}
if|if
condition|(
name|s
operator|==
literal|0
condition|)
for|for
control|(
name|ps
operator|=
name|partial_symtab_list
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ps
operator|->
name|textlow
operator|<=
name|pc
operator|&&
name|ps
operator|->
name|texthigh
operator|>
name|pc
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|fatal
argument_list|(
literal|"Internal error: pc found in readin psymtab and not in any symtab."
argument_list|)
expr_stmt|;
name|s
operator|=
name|psymtab_to_symtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bl
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Then search that symtab for the smallest block that wins.  */
comment|/* Use binary search to find the last block that starts before PC.  */
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bl
argument_list|)
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
operator|+
name|half
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
comment|/* Now search backward for a block that ends after PC.  */
while|while
condition|(
name|bot
operator|>=
literal|0
condition|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bl
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
condition|)
return|return
name|b
return|;
name|bot
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the function containing pc value PC.    Returns 0 if function is not known.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_pc_function
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|block_function
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finds the "function" (text symbol) that is smaller than PC    but greatest of all of the potential text symbols.  Sets    *NAME and/or *ADDRESS conditionally if that pointer is non-zero.    Returns 0 if it couldn't find anything, 1 if it did.  On a zero    return, *NAME and *ADDRESS are always set to zero.  On a 1 return,    *NAME and *ADDRESS contain real information.  */
end_comment

begin_function
name|int
name|find_pc_partial_function
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|,
name|address
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|address
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
init|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|f
decl_stmt|;
name|int
name|miscfunc
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psb
decl_stmt|;
if|if
condition|(
name|pst
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* The information we want has already been read in. 	     We can go to the already readin symbols and we'll get 	     the best possible answer.  */
name|f
operator|=
name|find_pc_function
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|return_error
label|:
comment|/* No availible symbol.  */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|address
operator|!=
literal|0
condition|)
operator|*
name|address
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|SYMBOL_NAME
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Get the information from a combination of the pst 	 (static symbols), and the misc function vector (extern 	 symbols).  */
name|miscfunc
operator|=
name|find_pc_misc_function
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|psb
operator|=
name|find_pc_psymbol
argument_list|(
name|pst
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psb
operator|&&
name|miscfunc
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|return_error
goto|;
block|}
if|if
condition|(
operator|!
name|psb
operator|||
operator|(
name|miscfunc
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|SYMBOL_VALUE
argument_list|(
name|psb
argument_list|)
operator|<
name|misc_function_vector
index|[
name|miscfunc
index|]
operator|.
name|address
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|misc_function_vector
index|[
name|miscfunc
index|]
operator|.
name|address
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|misc_function_vector
index|[
name|miscfunc
index|]
operator|.
name|name
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|SYMBOL_VALUE
argument_list|(
name|psb
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|SYMBOL_NAME
argument_list|(
name|psb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
comment|/* Must be in the misc function stuff.  */
block|{
name|miscfunc
operator|=
name|find_pc_misc_function
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|miscfunc
operator|==
operator|-
literal|1
condition|)
goto|goto
name|return_error
goto|;
if|if
condition|(
name|address
condition|)
operator|*
name|address
operator|=
name|misc_function_vector
index|[
name|miscfunc
index|]
operator|.
name|address
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
name|misc_function_vector
index|[
name|miscfunc
index|]
operator|.
name|name
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Find the misc function whose address is the largest    while being less than PC.  Return its index in misc_function_vector.    Returns -1 if PC is not in suitable range.  */
end_comment

begin_function
name|int
name|find_pc_misc_function
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|int
name|lo
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|hi
init|=
name|misc_function_count
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
specifier|register
name|int
name|distance
decl_stmt|;
comment|/* Note that the last thing in the vector is always _etext.  */
comment|/* Actually, "end", now that non-functions      go on the misc_function_vector.  */
comment|/* Above statement is not *always* true - fix for case where there are */
comment|/* no misc functions at all (ie no symbol table has been read). */
if|if
condition|(
name|hi
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* no misc functions recorded */
comment|/* trivial reject range test */
if|if
condition|(
name|pc
operator|<
name|misc_function_vector
index|[
literal|0
index|]
operator|.
name|address
operator|||
name|pc
operator|>
name|misc_function_vector
index|[
name|hi
index|]
operator|.
name|address
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Note that the following search will not return hi if      pc == misc_function_vector[hi].address.  If "end" points to the      first unused location, this is correct and the above test      simply needs to be changed to      "pc>= misc_function_vector[hi].address".  */
do|do
block|{
name|new
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
expr_stmt|;
name|distance
operator|=
name|misc_function_vector
index|[
name|new
index|]
operator|.
name|address
operator|-
name|pc
expr_stmt|;
if|if
condition|(
name|distance
operator|==
literal|0
condition|)
return|return
name|new
return|;
comment|/* an exact match */
elseif|else
if|if
condition|(
name|distance
operator|>
literal|0
condition|)
name|hi
operator|=
name|new
expr_stmt|;
else|else
name|lo
operator|=
name|new
expr_stmt|;
block|}
do|while
condition|(
name|hi
operator|-
name|lo
operator|!=
literal|1
condition|)
do|;
comment|/* if here, we had no exact match, so return the lower choice */
return|return
name|lo
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost stack frame executing inside of the specified block,    or zero if there is no such frame.  */
end_comment

begin_function
name|FRAME
name|block_innermost_frame
parameter_list|(
name|block
parameter_list|)
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|CORE_ADDR
name|start
init|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|register
name|CORE_ADDR
name|end
init|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|frame
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|>=
name|start
operator|&&
name|fi
operator|->
name|pc
operator|<
name|end
condition|)
return|return
name|frame
return|;
block|}
block|}
end_function

begin_function
name|void
name|_initialize_blockframe
parameter_list|()
block|{
name|obstack_init
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

