begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)put.c	5.4 (Berkeley) 4/16/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_include
include|#
directive|include
file|"align.h"
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|short
modifier|*
name|obufp
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * If DEBUG is defined, include the table  * of the printing opcode names.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"OPnames.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|showit
index|[]
init|=
literal|"'x'"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ
end_ifdef

begin_comment
comment|/*  * Put is responsible for the interpreter equivalent of code  * generation.  Since the interpreter is specifically designed  * for Pascal, little work is required here.  *  * FIXME, this should be converted to use<varargs.h> or<stdarg.h>.  */
end_comment

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|put
argument_list|(
argument|a
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|long
modifier|*
name|lp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|subop
decl_stmt|,
name|suboppr
decl_stmt|,
name|op
decl_stmt|,
name|oldlc
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
specifier|static
name|int
name|casewrd
decl_stmt|;
comment|/* 	 * It would be nice to do some more 	 * optimizations here.  The work 	 * done to collapse offsets in lval 	 * should be done here, the IFEQ etc 	 * relational operators could be used 	 * etc. 	 */
name|oldlc
operator|=
operator|(
name|int
operator|)
name|lc
expr_stmt|;
comment|/* its either this or change put to return a char * */
if|if
condition|(
operator|!
name|CGENNING
condition|)
comment|/* 		 * code disabled - do nothing 		 */
return|return
operator|(
name|oldlc
operator|)
return|;
name|p
operator|=
operator|&
name|a
expr_stmt|;
name|n
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|suboppr
operator|=
name|subop
operator|=
operator|(
operator|*
name|p
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
name|op
operator|=
operator|*
name|p
operator|&
literal|0377
expr_stmt|;
name|string
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|cp
operator|=
name|otext
index|[
name|op
index|]
operator|)
operator|==
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|"op= %o\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"put"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|O_ABORT
case|:
name|cp
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|O_AS
case|:
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|O_AS2
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|O_AS4
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|op
operator|=
name|O_AS8
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|pack
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|cp
operator|=
name|otext
index|[
name|op
index|]
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
break|break;
case|case
name|O_FOR1U
case|:
case|case
name|O_FOR2U
case|:
case|case
name|O_FOR4U
case|:
case|case
name|O_FOR1D
case|:
case|case
name|O_FOR2D
case|:
case|case
name|O_FOR4D
case|:
comment|/* relative addressing */
name|p
index|[
literal|1
index|]
operator|-=
operator|(
name|unsigned
operator|)
name|lc
operator|+
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* try to pack the jump */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<=
literal|127
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
operator|-
literal|128
condition|)
block|{
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* have to allow for extra displacement */
name|p
index|[
literal|1
index|]
operator|-=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_CONG
case|:
case|case
name|O_LVCON
case|:
case|case
name|O_CON
case|:
case|case
name|O_LINO
case|:
case|case
name|O_NEW
case|:
case|case
name|O_DISPOSE
case|:
case|case
name|O_DFDISP
case|:
case|case
name|O_IND
case|:
case|case
name|O_OFF
case|:
case|case
name|O_INX2
case|:
case|case
name|O_INX4
case|:
case|case
name|O_CARD
case|:
case|case
name|O_ADDT
case|:
case|case
name|O_SUBT
case|:
case|case
name|O_MULT
case|:
case|case
name|O_IN
case|:
case|case
name|O_CASE1OP
case|:
case|case
name|O_CASE2OP
case|:
case|case
name|O_CASE4OP
case|:
case|case
name|O_FRTN
case|:
case|case
name|O_WRITES
case|:
case|case
name|O_WRITEC
case|:
case|case
name|O_WRITEF
case|:
case|case
name|O_MAX
case|:
case|case
name|O_MIN
case|:
case|case
name|O_ARGV
case|:
case|case
name|O_CTTOT
case|:
case|case
name|O_INCT
case|:
case|case
name|O_RANG2
case|:
case|case
name|O_RSNG2
case|:
case|case
name|O_RANG42
case|:
case|case
name|O_RSNG42
case|:
case|case
name|O_SUCC2
case|:
case|case
name|O_SUCC24
case|:
case|case
name|O_PRED2
case|:
case|case
name|O_PRED24
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
case|case
name|O_CON2
case|:
case|case
name|O_CON24
case|:
name|pack
label|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<=
literal|127
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
operator|-
literal|128
condition|)
block|{
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_CON2
condition|)
block|{
name|op
operator|=
name|O_CON1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cp
operator|=
name|otext
index|[
name|O_CON1
index|]
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
if|if
condition|(
name|op
operator|==
name|O_CON24
condition|)
block|{
name|op
operator|=
name|O_CON14
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cp
operator|=
name|otext
index|[
name|O_CON14
index|]
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
block|}
break|break;
case|case
name|O_CON8
case|:
block|{
name|short
modifier|*
name|sp
init|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|&
name|p
index|[
literal|1
index|]
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\tCON8\t%22.14e\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEC11
name|word
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|#
directive|else
name|word
argument_list|(
name|op
operator|<<
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEC11
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
name|word
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
default|default:
if|if
condition|(
name|op
operator|>=
name|O_REL2
operator|&&
name|op
operator|<=
name|O_REL84
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|subop
operator|>>
name|INDX
operator|)
operator|*
literal|5
operator|)
operator|>=
literal|30
condition|)
name|i
operator|-=
literal|30
expr_stmt|;
else|else
name|i
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|string
operator|=
operator|&
literal|"IFEQ\0IFNE\0IFLT\0IFGT\0IFLE\0IFGE"
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_IF
case|:
case|case
name|O_TRA
case|:
comment|/***** 			codeline = 0; *****/
comment|/* relative addressing */
name|p
index|[
literal|1
index|]
operator|-=
operator|(
name|unsigned
operator|)
name|lc
operator|+
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_CONC
case|:
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|string
operator|=
name|showit
operator|)
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_CON1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cp
operator|=
name|otext
index|[
name|O_CON1
index|]
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|around
goto|;
case|case
name|O_CONC4
case|:
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|string
operator|=
name|showit
operator|)
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|suboppr
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|O_CON14
expr_stmt|;
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|around
goto|;
case|case
name|O_CON1
case|:
case|case
name|O_CON14
case|:
name|suboppr
operator|=
name|subop
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|around
label|:
name|n
operator|--
expr_stmt|;
break|break;
case|case
name|O_CASEBEG
case|:
name|casewrd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASEEND
case|:
if|if
condition|(
operator|(
name|unsigned
operator|)
name|lc
operator|&
literal|1
condition|)
block|{
name|lc
operator|--
expr_stmt|;
name|word
argument_list|(
name|casewrd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASE1
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\tCASE1\t%d\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * this to build a byte size case table  			 * saving bytes across calls in casewrd 			 * so they can be put out by word() 			 */
name|lc
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|lc
operator|&
literal|1
condition|)
ifdef|#
directive|ifdef
name|DEC11
name|casewrd
operator|=
name|p
index|[
literal|1
index|]
operator|&
literal|0377
expr_stmt|;
else|#
directive|else
name|casewrd
operator|=
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0377
operator|)
operator|<<
literal|8
expr_stmt|;
endif|#
directive|endif
endif|DEC11
else|else
block|{
name|lc
operator|-=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC11
name|word
argument_list|(
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
operator||
name|casewrd
argument_list|)
expr_stmt|;
else|#
directive|else
name|word
argument_list|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0377
operator|)
operator||
name|casewrd
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEC11
block|}
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_CASE2
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\tCASE2\t%d\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|word
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
case|case
name|O_PUSH
case|:
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|==
literal|0
condition|)
return|return
operator|(
name|oldlc
operator|)
return|;
comment|/* and fall through */
case|case
name|O_RANG4
case|:
case|case
name|O_RANG24
case|:
case|case
name|O_RSNG4
case|:
case|case
name|O_RSNG24
case|:
case|case
name|O_SUCC4
case|:
case|case
name|O_PRED4
case|:
comment|/* sub opcode optimization */
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|<
literal|128
operator|&&
operator|*
name|lp
operator|>=
operator|-
literal|128
operator|&&
operator|*
name|lp
operator|!=
literal|0
condition|)
block|{
name|suboppr
operator|=
name|subop
operator|=
operator|*
name|lp
expr_stmt|;
name|p
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
goto|goto
name|longgen
goto|;
case|case
name|O_TRA4
case|:
case|case
name|O_CALL
case|:
case|case
name|O_FSAV
case|:
case|case
name|O_GOTO
case|:
case|case
name|O_NAM
case|:
case|case
name|O_READE
case|:
comment|/* absolute long addressing */
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|lp
operator|-=
name|HEADER_BYTES
expr_stmt|;
goto|goto
name|longgen
goto|;
case|case
name|O_RV1
case|:
case|case
name|O_RV14
case|:
case|case
name|O_RV2
case|:
case|case
name|O_RV24
case|:
case|case
name|O_RV4
case|:
case|case
name|O_RV8
case|:
case|case
name|O_RV
case|:
case|case
name|O_LV
case|:
comment|/* 			 * positive offsets represent arguments 			 * and must use "ap" display entry rather 			 * than the "fp" entry 			 */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
block|{
name|subop
operator|++
expr_stmt|;
name|suboppr
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PDP11
break|break;
else|#
directive|else
comment|/* 			     * offsets out of range of word addressing 			     * must use long offset opcodes 			     */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|<
name|SHORTADDR
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
operator|-
name|SHORTADDR
condition|)
break|break;
else|else
block|{
name|op
operator|+=
name|O_LRV
operator|-
name|O_RV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cp
operator|=
name|otext
index|[
name|op
index|]
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
comment|/* and fall through */
endif|#
directive|endif
endif|PDP11
case|case
name|O_BEG
case|:
case|case
name|O_NODUMP
case|:
case|case
name|O_CON4
case|:
case|case
name|O_CASE4
case|:
name|longgen
label|:
name|n
operator|=
operator|(
name|n
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_LRV
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ADDR32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEC11
argument_list|)
name|p
index|[
name|n
operator|/
literal|2
index|]
operator|<<=
literal|16
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%5d\t%s"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|suboppr
condition|)
name|printf
argument_list|(
literal|":%d"
argument_list|,
name|suboppr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
control|)
name|printf
argument_list|(
literal|"\t%D "
argument_list|,
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
name|lp
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d "
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
block|}
name|pchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|op
operator|!=
name|O_CASE4
condition|)
ifdef|#
directive|ifdef
name|DEC11
name|word
argument_list|(
operator|(
name|op
operator|&
literal|0377
operator|)
operator||
name|subop
operator|<<
literal|8
argument_list|)
expr_stmt|;
else|#
directive|else
name|word
argument_list|(
name|op
operator|<<
literal|8
operator||
operator|(
name|subop
operator|&
literal|0377
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEC11
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|p
index|[
literal|1
index|]
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|word
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%5d\t%s"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|suboppr
condition|)
name|printf
argument_list|(
literal|":%d"
argument_list|,
name|suboppr
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|pchr
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|op
operator|!=
name|NIL
condition|)
ifdef|#
directive|ifdef
name|DEC11
name|word
argument_list|(
operator|(
name|op
operator|&
literal|0377
operator|)
operator||
name|subop
operator|<<
literal|8
argument_list|)
expr_stmt|;
else|#
directive|else
name|word
argument_list|(
name|op
operator|<<
literal|8
operator||
operator|(
name|subop
operator|&
literal|0377
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEC11
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|word
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldlc
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * listnames outputs a list of enumerated type names which  * can then be selected from to output a TSCAL  * a pointer to the address in the code of the namelist  * is kept in value[ NL_ELABEL ].  */
end_comment

begin_expr_stmt
name|listnames
argument_list|(
name|ap
argument_list|)
specifier|register
expr|struct
name|nl
operator|*
name|ap
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|nl
modifier|*
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ
specifier|register
name|int
name|oldlc
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|unsigned
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|strptr
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
comment|/* code is off - do nothing */
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|class
operator|!=
name|TYPE
condition|)
name|ap
operator|=
name|ap
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* the list already exists */
return|return
operator|(
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|OBJ
name|oldlc
operator|=
operator|(
name|int
operator|)
name|lc
expr_stmt|;
comment|/* same problem as put */
operator|(
name|void
operator|)
name|put
argument_list|(
literal|2
argument_list|,
name|O_TRA
argument_list|,
name|lc
argument_list|)
expr_stmt|;
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|=
operator|(
name|int
operator|)
name|lc
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aligndot
argument_list|(
name|A_STRUCT
argument_list|)
expr_stmt|;
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|=
operator|(
name|int
operator|)
name|getlab
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|putlab
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
comment|/* number of scalars */
name|next
operator|=
name|ap
operator|->
name|type
expr_stmt|;
name|len
operator|=
name|next
operator|->
name|range
index|[
literal|1
index|]
operator|-
name|next
operator|->
name|range
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
operator|(
name|void
operator|)
name|put
argument_list|(
literal|2
argument_list|,
name|O_CASE2
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.word %d"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
comment|/* offsets of each scalar name */
name|len
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
operator|(
name|void
operator|)
name|put
argument_list|(
literal|2
argument_list|,
name|O_CASE2
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.word %d"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
name|next
operator|=
name|ap
operator|->
name|chain
expr_stmt|;
do|do
block|{
for|for
control|(
name|strptr
operator|=
name|next
operator|->
name|symbol
init|;
operator|*
name|strptr
operator|++
condition|;
name|len
operator|++
control|)
continue|continue;
name|len
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
operator|(
name|void
operator|)
name|put
argument_list|(
literal|2
argument_list|,
name|O_CASE2
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
literal|"	.word %d"
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
block|}
do|while
condition|(
name|next
operator|=
name|next
operator|->
name|chain
condition|)
do|;
comment|/* list of scalar names */
name|strptr
operator|=
name|getnext
argument_list|(
name|ap
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ
do|do
block|{
ifdef|#
directive|ifdef
name|DEC11
name|w
operator|=
operator|(
name|unsigned
operator|)
operator|*
name|strptr
expr_stmt|;
else|#
directive|else
name|w
operator|=
operator|*
name|strptr
operator|<<
literal|8
expr_stmt|;
endif|#
directive|endif
endif|DEC11
if|if
condition|(
operator|!
operator|*
name|strptr
operator|++
condition|)
name|strptr
operator|=
name|getnext
argument_list|(
name|next
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC11
name|w
operator||=
operator|*
name|strptr
operator|<<
literal|8
expr_stmt|;
else|#
directive|else
name|w
operator||=
operator|(
name|unsigned
operator|)
operator|*
name|strptr
expr_stmt|;
endif|#
directive|endif
endif|DEC11
if|if
condition|(
operator|!
operator|*
name|strptr
operator|++
condition|)
name|strptr
operator|=
name|getnext
argument_list|(
name|next
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
name|word
argument_list|(
operator|(
name|int
operator|)
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
comment|/* jump over the mess */
name|patch
argument_list|(
operator|(
name|PTR_DCL
operator|)
name|oldlc
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
while|while
condition|(
name|next
condition|)
block|{
while|while
condition|(
operator|*
name|strptr
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.byte	0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|strptr
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
literal|2
init|;
operator|(
name|w
operator|<=
literal|8
operator|)
operator|&&
operator|*
name|strptr
condition|;
name|w
operator|++
control|)
block|{
name|putprintf
argument_list|(
literal|",0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|strptr
operator|++
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.byte	0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strptr
operator|=
name|getnext
argument_list|(
name|next
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
return|return
operator|(
name|ap
operator|->
name|value
index|[
name|NL_ELABEL
index|]
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|getnext
parameter_list|(
name|next
parameter_list|,
name|new
parameter_list|)
name|struct
name|nl
modifier|*
name|next
decl_stmt|,
decl|*
modifier|*
name|new
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|next
operator|!=
name|NIL
condition|)
block|{
name|next
operator|=
name|next
operator|->
name|chain
expr_stmt|;
operator|*
name|new
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
name|NLNIL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
ifdef|#
directive|ifdef
name|OBJ
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
operator|&&
name|CGENNING
condition|)
name|printf
argument_list|(
literal|"%5d\t\t\"%s\"\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|next
operator|->
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
return|return
operator|(
name|next
operator|->
name|symbol
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ
end_ifdef

begin_comment
comment|/*  * Putspace puts out a table  * of nothing to leave space  * for the case branch table e.g.  */
end_comment

begin_macro
name|putspace
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
comment|/* 		 * code disabled - do nothing 		 */
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\t.=.+%d\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|2
control|)
name|word
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putstr
argument_list|(
argument|sptr
argument_list|,
argument|padding
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|padding
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|short
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|strptr
init|=
name|sptr
decl_stmt|;
specifier|register
name|int
name|pad
init|=
name|padding
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
comment|/* 		 * code disabled - do nothing 		 */
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%5d\t\t\"%s\"\n"
argument_list|,
name|lc
operator|-
name|HEADER_BYTES
argument_list|,
name|strptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pad
operator|==
literal|0
condition|)
block|{
do|do
block|{
ifdef|#
directive|ifdef
name|DEC11
name|w
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|*
name|strptr
expr_stmt|;
else|#
directive|else
name|w
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|*
name|strptr
operator|<<
literal|8
expr_stmt|;
endif|#
directive|endif
endif|DEC11
if|if
condition|(
name|w
condition|)
ifdef|#
directive|ifdef
name|DEC11
name|w
operator||=
operator|*
operator|++
name|strptr
operator|<<
literal|8
expr_stmt|;
else|#
directive|else
name|w
operator||=
operator|*
operator|++
name|strptr
expr_stmt|;
endif|#
directive|endif
endif|DEC11
name|word
argument_list|(
operator|(
name|int
operator|)
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|strptr
operator|++
condition|)
do|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEC11
do|do
block|{
name|w
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|*
name|strptr
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|strptr
condition|)
name|w
operator||=
operator|*
name|strptr
operator|<<
literal|8
expr_stmt|;
else|else
block|{
name|w
operator||=
literal|' '
operator|<<
literal|8
expr_stmt|;
name|pad
operator|--
expr_stmt|;
block|}
name|word
argument_list|(
operator|(
name|int
operator|)
name|w
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|strptr
operator|++
condition|)
do|;
else|#
directive|else
do|do
block|{
name|w
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|*
name|strptr
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|w
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|strptr
condition|)
name|w
operator||=
operator|*
name|strptr
expr_stmt|;
else|else
block|{
name|w
operator||=
literal|' '
expr_stmt|;
name|pad
operator|--
expr_stmt|;
block|}
name|word
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|strptr
operator|++
condition|)
do|;
endif|#
directive|endif
endif|DEC11
while|while
condition|(
name|pad
operator|>
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEC11
name|word
argument_list|(
literal|' '
operator||
operator|(
literal|' '
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|word
argument_list|(
operator|(
literal|' '
operator|<<
literal|8
operator|)
operator||
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEC11
name|pad
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pad
operator|==
literal|1
condition|)
ifdef|#
directive|ifdef
name|DEC11
name|word
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|#
directive|else
name|word
argument_list|(
literal|' '
operator|<<
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEC11
else|else
name|word
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PC
end_ifndef

begin_macro
name|lenstr
argument_list|(
argument|sptr
argument_list|,
argument|padding
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|padding
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|strptr
init|=
name|sptr
decl_stmt|;
name|cnt
operator|=
name|padding
expr_stmt|;
do|do
block|{
name|cnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|strptr
operator|++
condition|)
do|;
return|return
operator|(
operator|(
operator|++
name|cnt
operator|)
operator|&
operator|~
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Patch repairs the branch  * at location loc to come  * to the current location.  *	for PC, this puts down the label  *	and the branch just references that label.  *	lets here it for two pass assemblers.  */
end_comment

begin_macro
name|patch
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|PTR_DCL
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|OBJ
name|patchfil
argument_list|(
name|loc
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lc
operator|-
name|loc
operator|-
literal|2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
operator|(
name|void
operator|)
name|putlab
argument_list|(
operator|(
name|char
operator|*
operator|)
name|loc
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ
end_ifdef

begin_macro
name|patch4
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|PTR_DCL
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|patchfil
argument_list|(
name|loc
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lc
operator|-
name|HEADER_BYTES
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Patchfil makes loc+2 have jmploc  * as its contents.  */
end_comment

begin_macro
name|patchfil
argument_list|(
argument|loc
argument_list|,
argument|jmploc
argument_list|,
argument|words
argument_list|)
end_macro

begin_decl_stmt
name|PTR_DCL
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|jmploc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|words
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
name|short
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|CGENNING
condition|)
return|return;
if|if
condition|(
name|loc
operator|>
operator|(
name|unsigned
operator|)
name|lc
condition|)
name|panic
argument_list|(
literal|"patchfil"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tpatch %u %D\n"
argument_list|,
name|loc
operator|-
name|HEADER_BYTES
argument_list|,
name|jmploc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|jmploc
expr_stmt|;
do|do
block|{
ifndef|#
directive|ifndef
name|DEC11
if|if
condition|(
name|words
operator|>
literal|1
condition|)
name|val
operator|=
name|jmploc
operator|>>
literal|16
expr_stmt|;
else|else
name|val
operator|=
name|jmploc
expr_stmt|;
endif|#
directive|endif
endif|DEC11
name|i
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|loc
operator|+
literal|2
operator|-
operator|(
operator|(
name|unsigned
operator|)
name|lc
operator|&
operator|~
literal|01777
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|1024
condition|)
block|{
name|obuf
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|ofil
argument_list|,
operator|(
name|long
operator|)
name|loc
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|ofil
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|val
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|ofil
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|loc
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC11
name|val
operator|=
name|jmploc
operator|>>
literal|16
expr_stmt|;
endif|#
directive|endif
endif|DEC11
block|}
do|while
condition|(
operator|--
name|words
condition|)
do|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Put the word o into the code  */
end_comment

begin_macro
name|word
argument_list|(
argument|o
argument_list|)
end_macro

begin_decl_stmt
name|int
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|obufp
operator|=
name|o
expr_stmt|;
name|obufp
operator|++
expr_stmt|;
name|lc
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|obufp
operator|>=
name|obuf
operator|+
literal|512
condition|)
name|pflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flush the code buffer  */
end_comment

begin_macro
name|pflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
operator|(
name|obufp
operator|-
operator|(
operator|(
name|short
operator|*
operator|)
name|obuf
operator|)
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|write
argument_list|(
name|ofil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obuf
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|perror
argument_list|(
name|obj
argument_list|)
operator|,
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
name|obufp
operator|=
name|obuf
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

begin_comment
comment|/*  * Getlab - returns the location counter.  * included here for the eventual code generator.  *	for PC, thank you!  */
end_comment

begin_function
name|char
modifier|*
name|getlab
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|OBJ
return|return
operator|(
name|lc
operator|)
return|;
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
specifier|static
name|long
name|lastlabel
decl_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|++
name|lastlabel
operator|)
return|;
endif|#
directive|endif
endif|PC
block|}
end_function

begin_comment
comment|/*  * Putlab - lay down a label.  *	for PC, just print the label name with a colon after it.  */
end_comment

begin_function
name|char
modifier|*
name|putlab
parameter_list|(
name|l
parameter_list|)
name|char
modifier|*
name|l
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PC
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|LABELPREFIX
argument_list|,
operator|(
name|int
operator|)
name|l
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|":"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

end_unit

