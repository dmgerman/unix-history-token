begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)callproc.c	5.4 (Berkeley) 4/16/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Evaluate a call to a procedure.  *  * This file is a botch as far as modularity is concerned.  *  * In fact, FIXME, it does not work on either the Vax or Tahoe  * at this point (Sep 22, 1988).  It possibly doesn't work because  * the ptrace interface never sets "pc" back into the interpreter's  * program counter location.  *  * Due to portability changes  * in px for ANSI C, it is now even further broken, since the operand  * stack is no longer the system stack and since the interpreter's  * "pc" that we see is never read by the interpreter.  We could fix  * this, and increase the modularity, by:  *  *    * changing this whole module to build a string of bytecodes  *	that would: push a series of constant parameters, then call a  *	procedure, then take a breakpoint.  *    * Having px allocate a place for us to do this, and pass us the  *	address of this (otherwise unused) variable.  *    * Creating an entry point into the px interpreter which would  *	pick up the pc value from "*addrpc" and then enter the main loop.  *	Currently we never pick up *addrpc for speed.  *    * Fix the code below to use the new entry point rather than "loopaddr".  *  * But I suspect this code is dead enough that nobody will ever get  * around to it.		-- gnu@toad.com, 22Sep88  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"frame.rep"
end_include

begin_include
include|#
directive|include
file|"sym/classes.h"
end_include

begin_include
include|#
directive|include
file|"sym/sym.rep"
end_include

begin_include
include|#
directive|include
file|"tree/tree.rep"
end_include

begin_include
include|#
directive|include
file|"process/process.rep"
end_include

begin_include
include|#
directive|include
file|"process/pxinfo.h"
end_include

begin_decl_stmt
name|LOCAL
name|ADDRESS
name|retaddr
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_decl_stmt
name|BOOLEAN
name|didret
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Controlling logic of procedure calling.  * Calling a procedure before ever executing the program must  * be special cased.  */
end_comment

begin_macro
name|callproc
argument_list|(
argument|procnode
argument_list|,
argument|arglist
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|procnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SYM
modifier|*
name|proc
decl_stmt|;
ifdef|#
directive|ifdef
name|tahoe
specifier|register
name|int
name|tmpsp
decl_stmt|,
name|tmptmp
decl_stmt|;
specifier|extern
name|BOOLEAN
name|shouldrestart
decl_stmt|;
if|if
condition|(
name|shouldrestart
condition|)
block|{
name|initstart
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
block|{
name|curline
operator|=
name|firstline
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|setbp
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|resume
argument_list|()
expr_stmt|;
name|unsetbp
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
name|proc
operator|=
name|procnode
operator|->
name|nameval
expr_stmt|;
if|if
condition|(
operator|!
name|isblock
argument_list|(
name|proc
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not a procedure or function"
argument_list|,
name|proc
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|tahoe
name|doret
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|tmpsp
operator|=
name|process
operator|->
name|sp
expr_stmt|;
endif|#
directive|endif
name|pushargs
argument_list|(
name|proc
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
name|tmptmp
operator|=
name|tmpsp
expr_stmt|;
name|tmpsp
operator|=
name|process
operator|->
name|sp
expr_stmt|;
name|process
operator|->
name|sp
operator|=
name|tmptmp
expr_stmt|;
endif|#
directive|endif
name|pushenv
argument_list|(
name|proc
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|codeloc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
name|process
operator|->
name|sp
operator|=
name|tmpsp
expr_stmt|;
endif|#
directive|endif
name|pushframe
argument_list|(
name|proc
operator|->
name|blkno
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|proc
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * Push the arguments on the process' stack.  We do this by first  * evaluating them on the "eval" stack, then copying into the process'  * space.  */
end_comment

begin_function
name|LOCAL
name|pushargs
parameter_list|(
name|proc
parameter_list|,
name|arglist
parameter_list|)
name|SYM
modifier|*
name|proc
decl_stmt|;
name|NODE
modifier|*
name|arglist
decl_stmt|;
block|{
name|STACK
modifier|*
name|savesp
decl_stmt|;
name|int
name|args_size
decl_stmt|;
name|savesp
operator|=
name|sp
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
comment|/* 	 * evalargs hopefully keeps stack aligned, so we won't bother 	 * aligning it afterwards, neither will we align process->sp 	 * after subtracting args_size. 	 */
endif|#
directive|endif
name|evalargs
argument_list|(
name|proc
operator|->
name|symbol
argument_list|,
name|proc
operator|->
name|chain
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|args_size
operator|=
name|sp
operator|-
name|savesp
expr_stmt|;
name|process
operator|->
name|sp
operator|-=
name|args_size
expr_stmt|;
name|dwrite
argument_list|(
name|savesp
argument_list|,
name|process
operator|->
name|sp
argument_list|,
name|args_size
argument_list|)
expr_stmt|;
name|sp
operator|=
name|savesp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Evaluate arguments right-to-left because the eval stack  * grows up, px's stack grows down.  */
end_comment

begin_function
name|LOCAL
name|evalargs
parameter_list|(
name|procname
parameter_list|,
name|arg
parameter_list|,
name|explist
parameter_list|)
name|char
modifier|*
name|procname
decl_stmt|;
name|SYM
modifier|*
name|arg
decl_stmt|;
name|NODE
modifier|*
name|explist
decl_stmt|;
block|{
name|NODE
modifier|*
name|exp
decl_stmt|;
name|STACK
modifier|*
name|savesp
decl_stmt|;
name|ADDRESS
name|addr
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NIL
condition|)
block|{
if|if
condition|(
name|explist
operator|!=
name|NIL
condition|)
block|{
name|error
argument_list|(
literal|"too many parameters to \"%s\""
argument_list|,
name|procname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|explist
operator|==
name|NIL
condition|)
block|{
name|error
argument_list|(
literal|"not enough parameters to \"%s\""
argument_list|,
name|procname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|explist
operator|->
name|op
operator|!=
name|O_COMMA
condition|)
block|{
name|panic
argument_list|(
literal|"evalargs: arglist missing comma"
argument_list|)
expr_stmt|;
block|}
name|savesp
operator|=
name|sp
expr_stmt|;
name|evalargs
argument_list|(
name|procname
argument_list|,
name|arg
operator|->
name|chain
argument_list|,
name|explist
operator|->
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|explist
operator|->
name|left
expr_stmt|;
if|if
condition|(
operator|!
name|compatible
argument_list|(
name|arg
operator|->
name|type
argument_list|,
name|exp
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|sp
operator|=
name|savesp
expr_stmt|;
name|trerror
argument_list|(
literal|"%t is not the same type as parameter \"%s\""
argument_list|,
name|exp
argument_list|,
name|arg
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|class
operator|==
name|REF
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|op
operator|!=
name|O_RVAL
condition|)
block|{
name|sp
operator|=
name|savesp
expr_stmt|;
name|error
argument_list|(
literal|"variable expected for parameter \"%s\""
argument_list|,
name|arg
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|lval
argument_list|(
name|exp
operator|->
name|left
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|ADDRESS
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eval
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Simulate a CALL instruction by pushing the appropriate  * stack frame information.  *  * Massage register 10 or 11 appropriately since it contains the  * stack frame pointer.  */
end_comment

begin_function
name|LOCAL
name|pushframe
parameter_list|(
name|b
parameter_list|)
name|int
name|b
decl_stmt|;
block|{
name|ADDRESS
modifier|*
name|newdp
decl_stmt|;
name|FRAME
name|callframe
decl_stmt|;
name|retaddr
operator|=
name|program
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|codeloc
expr_stmt|;
comment|/*  * This stuff is set by the callee, just here to take up space.  */
name|callframe
operator|.
name|stackref
operator|=
literal|0
expr_stmt|;
name|callframe
operator|.
name|file
operator|=
literal|0
expr_stmt|;
name|callframe
operator|.
name|blockp
operator|=
literal|0
expr_stmt|;
name|callframe
operator|.
name|save_loc
operator|=
name|NIL
expr_stmt|;
name|callframe
operator|.
name|save_disp
operator|=
name|NIL
expr_stmt|;
comment|/*  * This is the useful stuff.  */
name|callframe
operator|.
name|save_dp
operator|=
name|curdp
argument_list|()
expr_stmt|;
name|callframe
operator|.
name|save_pc
operator|=
name|retaddr
operator|+
name|ENDOFF
expr_stmt|;
name|callframe
operator|.
name|save_lino
operator|=
literal|0
expr_stmt|;
name|newdp
operator|=
name|DISPLAY
operator|+
operator|(
literal|2
operator|*
name|b
operator|)
expr_stmt|;
name|dwrite
argument_list|(
operator|&
name|newdp
argument_list|,
name|DP
argument_list|,
sizeof|sizeof
argument_list|(
name|newdp
argument_list|)
argument_list|)
expr_stmt|;
name|process
operator|->
name|sp
operator|-=
sizeof|sizeof
argument_list|(
name|callframe
argument_list|)
expr_stmt|;
name|dwrite
argument_list|(
operator|&
name|callframe
argument_list|,
name|process
operator|->
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|callframe
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
name|process
operator|->
name|reg
index|[
literal|11
index|]
operator|=
name|process
operator|->
name|sp
expr_stmt|;
else|#
directive|else
name|process
operator|->
name|reg
index|[
literal|10
index|]
operator|=
name|process
operator|->
name|sp
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Execute the procedure.  This routine does NOT return because it  * calls "cont", which doesn't return.  We set a CALLPROC breakpoint  * at "retaddr", the address where the called routine will return.  *  * The action for a CALLPROC is to call "procreturn" where we restore  * the environment.  */
end_comment

begin_function
name|LOCAL
name|execute
parameter_list|(
name|f
parameter_list|)
name|SYM
modifier|*
name|f
decl_stmt|;
block|{
name|isstopped
operator|=
name|TRUE
expr_stmt|;
name|addbp
argument_list|(
name|retaddr
argument_list|,
name|CALLPROC
argument_list|,
name|f
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cont
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|procreturn
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|SYM
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|tahoe
name|doret
argument_list|(
name|process
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s returns "
argument_list|,
name|f
operator|->
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|class
operator|==
name|FUNC
condition|)
block|{
name|len
operator|=
name|size
argument_list|(
name|f
operator|->
name|type
argument_list|)
expr_stmt|;
name|dread
argument_list|(
name|sp
argument_list|,
name|process
operator|->
name|sp
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
name|len
operator|=
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
endif|#
directive|endif
name|sp
operator|+=
name|len
expr_stmt|;
name|printval
argument_list|(
name|f
operator|->
name|type
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"successfully\n"
argument_list|)
expr_stmt|;
block|}
name|popenv
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Push the current environment.  *  * This involves both saving pdx and interpreter values.  * LOOPADDR is the address of the main interpreter loop.  */
end_comment

begin_function
name|LOCAL
name|pushenv
parameter_list|(
name|newpc
parameter_list|)
name|ADDRESS
name|newpc
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|tahoe
comment|/* this should be done somewhere else, but... */
name|INTFP
operator|=
name|process
operator|->
name|fp
expr_stmt|;
endif|#
directive|endif
name|push
argument_list|(
name|ADDRESS
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|LINENO
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|char
operator|*
argument_list|,
name|cursource
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|BOOLEAN
argument_list|,
name|isstopped
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|SYM
operator|*
argument_list|,
name|curfunc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|WORD
argument_list|,
name|process
operator|->
name|pc
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|WORD
argument_list|,
name|process
operator|->
name|sp
argument_list|)
expr_stmt|;
name|process
operator|->
name|pc
operator|=
name|LOOPADDR
expr_stmt|;
name|pc
operator|=
name|newpc
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
name|process
operator|->
name|reg
index|[
literal|12
index|]
operator|=
name|pc
operator|+
name|ENDOFF
expr_stmt|;
else|#
directive|else
name|process
operator|->
name|reg
index|[
literal|11
index|]
operator|=
name|pc
operator|+
name|ENDOFF
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Pop back to the real world.  */
end_comment

begin_macro
name|popenv
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|p
operator|=
name|process
expr_stmt|;
name|p
operator|->
name|sp
operator|=
name|pop
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|p
operator|->
name|pc
operator|=
name|pop
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|pop
argument_list|(
name|SYM
operator|*
argument_list|)
expr_stmt|;
name|isstopped
operator|=
name|pop
argument_list|(
name|BOOLEAN
argument_list|)
expr_stmt|;
name|filename
operator|=
name|pop
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|curline
operator|=
name|pop
argument_list|(
name|LINENO
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pop
argument_list|(
name|ADDRESS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|tahoe
name|p
operator|->
name|reg
index|[
literal|12
index|]
operator|=
name|pc
operator|+
literal|1
operator|+
name|ENDOFF
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|filename
operator|!=
name|cursource
condition|)
block|{
name|skimsource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

