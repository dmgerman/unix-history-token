begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: fex4.c,v 1.5 85/03/13 17:19:04 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 12:40:56 1983 by jkf]-  * 	fex4.c				$Locker:  $  * nlambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"lfuncs.h"
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
operator|(
name|os_4_2
operator|||
name|os_4_3
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this is now a lambda function instead of a nlambda.    the only reason that it wasn't a lambda to begin with is that     the person who wrote it didn't know how to write a lexpr 						- jkf */
end_comment

begin_function
name|lispval
name|Lsyscall
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|aptr
decl_stmt|;
specifier|register
name|int
name|acount
init|=
literal|1
decl_stmt|;
extern|extern syscall(
block|)
function|;
end_function

begin_decl_stmt
name|int
name|args
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* there must be at least one argument */
end_comment

begin_if
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"syscall"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|aptr
operator|=
name|lbot
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
argument_list|(
literal|"syscall: bad first argument "
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|args
index|[
name|acount
operator|++
index|]
operator|=
name|temp
operator|->
name|i
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|aptr
operator|<
name|np
operator|&&
name|acount
operator|<
literal|48
condition|)
block|{
name|temp
operator|=
name|aptr
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
name|args
index|[
name|acount
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|temp
operator|->
name|a
operator|.
name|pname
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|args
index|[
name|acount
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|args
index|[
name|acount
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|temp
operator|->
name|i
expr_stmt|;
break|break;
default|default:
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
argument_list|(
literal|"syscall: arg not symbol, string or fixnum"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
block|}
end_while

begin_expr_stmt
name|Restorestack
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|args
index|[
literal|0
index|]
operator|=
name|acount
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|inewint
argument_list|(
name|callg_
argument_list|(
name|syscall
argument_list|,
name|args
argument_list|)
argument_list|)
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* eval-when: this has the form (eval-when<list><form1><form2> ...)    where the list may contain any combination of `eval', `load', `compile'.    The interpreter (us) looks for the atom `eval', if it is present    we treat the rest of the forms as a progn. */
end_comment

begin_macro
unit|lispval
name|Nevwhen
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|lispval
name|handy2
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|handy
operator|=
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|car
operator|==
operator|(
name|lispval
operator|)
name|Veval
condition|)
block|{
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
operator|(
operator|(
name|lbot
operator|-
literal|1
operator|)
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|cdr
argument_list|)
expr_stmt|;
name|handy2
operator|=
name|Nprogn
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy2
operator|)
return|;
block|}
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
comment|/* eval not seen */
block|}
end_block

begin_comment
comment|/*	Status functions.   *  These operate on the statuslist stlist which has the form:  *	( status_elem_1 status_elem_2 status_elem_3 ...)  *  where each status element has the form:  *	( name readcode setcode .  readvalue)  *  where  *	name - name of the status feature (the first arg to the status  *		function).  *	readcode - fixnum which tells status how to read the value of  *		this status name.  The codes are #defined.  *	setcode - fixnum which tells sstatus how to set the value of  *		this status name  *	readvalue - the value of the status feature is usually stored  *		here.  *	  * Readcodes:  *  *	ST_READ - if no second arg, return readvalue.  *		  if the second arg is given, we return t if it is eq to  *		  the readvalue.  *	ST_FEATR - used in (status feature xxx) where we test for xxx being  *		  in the status features list  *	ST_SYNT - used in (status syntax c) where we return c's syntax code  *	ST_INTB - read stattab entry  *	ST_NFETR - used in (status nofeature xxx) where we test for xxx not  *		  being in the status features list  *	ST_DMPR - read the dumpmode   *	ST_UNDEF - return the undefined functions in the transfer table  *   * Setcodes:  *	ST_NO -  if not allowed to set this status through sstatus.  *	ST_SET - if the second arg is made the readvalue.  *	ST_FEATW - for (sstatus feature xxx), we add xxx to the   *		  (status features) list.  *	ST_TOLC - if non nil, map upper case chars in atoms to lc.  *	ST_CORE - if non nil, have bus errors and segmentation violations  *		  dump core, if nil have them produce a bad-mem err msg  *	ST_INTB - set stattab table entry  *	ST_NFETW - use in (sstatus nofeature xxx) where we wish to remove xxx  *		   from the status feature list.  *	ST_DMPW - set the dumpmode  *	ST_BCDTR - (ifdef RSET) if non nil, creat trace stack entries for  *		   calls from BCD functions to BCD functions  *	ST_GCSTR - (ifdef GCSTRINGS) garbage collect strings  */
end_comment

begin_function
name|lispval
name|Nstatus
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|curitm
decl_stmt|,
name|valarg
decl_stmt|;
name|int
name|indx
decl_stmt|,
name|ctim
decl_stmt|;
name|int
name|typ
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|struct
name|tm
modifier|*
name|lctime
decl_stmt|,
modifier|*
name|localtime
argument_list|()
decl_stmt|;
specifier|extern
name|unsigned
name|char
modifier|*
name|ctable
decl_stmt|;
specifier|extern
name|int
name|dmpmode
decl_stmt|;
specifier|extern
name|lispval
name|chktt
parameter_list|()
function_decl|;
name|lispval
name|Istsrch
parameter_list|()
function_decl|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/* arg list */
while|while
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|DTPR
condition|)
name|handy
operator|=
name|error
argument_list|(
literal|"status: bad arg list"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|curitm
operator|=
name|Istsrch
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* look for feature */
if|if
condition|(
name|curitm
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* non existant */
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|)
name|valarg
operator|=
operator|(
name|lispval
operator|)
name|CNIL
expr_stmt|;
else|else
name|valarg
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
expr_stmt|;
comment|/* now do the processing with curitm pointing to the requested 	   item in the status list  	 */
switch|switch
condition|(
name|typ
operator|=
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
operator|->
name|i
condition|)
block|{
comment|/* look at readcode */
case|case
name|ST_READ
case|:
name|curitm
operator|=
name|Istsrch
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* look for name */
if|if
condition|(
name|curitm
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
if|if
condition|(
name|valarg
operator|!=
operator|(
name|lispval
operator|)
name|CNIL
condition|)
name|error
argument_list|(
literal|"status: Second arg not allowed."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|)
return|;
case|case
name|ST_NFETR
case|:
comment|/* look for feature present */
case|case
name|ST_FEATR
case|:
comment|/* look for feature */
name|curitm
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"features"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valarg
operator|==
operator|(
name|lispval
operator|)
name|CNIL
condition|)
name|error
argument_list|(
literal|"status: need second arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|handy
operator|=
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|car
operator|==
name|valarg
condition|)
return|return
operator|(
name|typ
operator|==
name|ST_FEATR
condition|?
name|tatom
else|:
name|nil
operator|)
return|;
return|return
operator|(
name|typ
operator|==
name|ST_FEATR
condition|?
name|nil
else|:
name|tatom
operator|)
return|;
case|case
name|ST_SYNT
case|:
comment|/* want character syntax */
name|handy
operator|=
name|Vreadtable
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|chkrtab
argument_list|(
name|handy
argument_list|)
expr_stmt|;
if|if
condition|(
name|valarg
operator|==
operator|(
name|lispval
operator|)
name|CNIL
condition|)
name|error
argument_list|(
literal|"status: need second arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|valarg
argument_list|)
operator|!=
name|ATOM
condition|)
name|valarg
operator|=
name|error
argument_list|(
literal|"status: second arg must be atom"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|indx
operator|=
name|valarg
operator|->
name|a
operator|.
name|pname
index|[
literal|0
index|]
expr_stmt|;
comment|/* get first char */
if|if
condition|(
name|valarg
operator|->
name|a
operator|.
name|pname
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|"status: only one character atom allowed"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|handy
operator|=
name|inewint
argument_list|(
operator|(
name|long
operator|)
name|ctable
index|[
name|indx
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
case|case
name|ST_RINTB
case|:
return|return
operator|(
name|stattab
index|[
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
index|]
operator|)
return|;
case|case
name|ST_DMPR
case|:
return|return
operator|(
name|inewint
argument_list|(
name|dmpmode
argument_list|)
operator|)
return|;
case|case
name|ST_CTIM
case|:
name|ctim
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|ctim
argument_list|)
expr_stmt|;
name|cp
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|matom
argument_list|(
name|cp
argument_list|)
operator|)
return|;
case|case
name|ST_LOCT
case|:
name|ctim
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lctime
operator|=
name|localtime
argument_list|(
operator|&
name|ctim
argument_list|)
expr_stmt|;
operator|(
name|handy
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|valarg
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_min
argument_list|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|curitm
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|curitm
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_hour
argument_list|)
expr_stmt|;
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|valarg
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|curitm
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|curitm
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_mon
argument_list|)
expr_stmt|;
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|valarg
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_year
argument_list|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|curitm
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|curitm
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_wday
argument_list|)
expr_stmt|;
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|valarg
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_yday
argument_list|)
expr_stmt|;
name|valarg
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|curitm
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|curitm
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lctime
operator|->
name|tm_isdst
argument_list|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
case|case
name|ST_ISTTY
case|:
return|return
operator|(
operator|(
name|isatty
argument_list|(
literal|0
argument_list|)
operator|==
name|TRUE
condition|?
name|tatom
else|:
name|nil
operator|)
operator|)
return|;
case|case
name|ST_UNDEF
case|:
return|return
operator|(
name|chktt
argument_list|()
operator|)
return|;
block|}
name|error
argument_list|(
literal|"Internal error in status: Couldn't figure out request"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|lispval
name|Nsstatus
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
name|Isstatus
parameter_list|()
function_decl|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|DTPR
operator|||
name|TYPE
argument_list|(
name|handy
operator|->
name|d
operator|.
name|cdr
argument_list|)
operator|!=
name|DTPR
condition|)
name|handy
operator|=
name|error
argument_list|(
literal|"sstatus: Bad args"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|Isstatus
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|,
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Isstatus - internal routine to do a set status.	*/
end_comment

begin_function
name|lispval
name|Isstatus
parameter_list|(
name|curnam
parameter_list|,
name|curval
parameter_list|)
name|lispval
name|curnam
decl_stmt|,
name|curval
decl_stmt|;
block|{
specifier|register
name|lispval
name|curitm
decl_stmt|,
name|head
decl_stmt|;
name|lispval
name|Istsrch
argument_list|()
decl_stmt|,
name|Iaddstat
argument_list|()
decl_stmt|;
name|int
name|badmr
argument_list|()
decl_stmt|,
name|clrtt
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|uctolc
decl_stmt|,
name|dmpmode
decl_stmt|,
name|bcdtrsw
decl_stmt|,
name|gcstrings
decl_stmt|;
name|curitm
operator|=
name|Istsrch
argument_list|(
name|curnam
argument_list|)
expr_stmt|;
comment|/* if doesnt exist, make one up */
if|if
condition|(
name|curitm
operator|==
name|nil
condition|)
name|curitm
operator|=
name|Iaddstat
argument_list|(
name|curnam
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
operator|->
name|i
condition|)
block|{
case|case
name|ST_NO
case|:
name|error
argument_list|(
literal|"sstatus: cannot set this status"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
case|case
name|ST_SET
case|:
goto|goto
name|setit
goto|;
case|case
name|ST_FEATW
case|:
name|curitm
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"features"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|curnam
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|curval
expr_stmt|;
name|curnam
operator|->
name|d
operator|.
name|cdr
operator|=
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* old val */
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|=
name|curnam
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
case|case
name|ST_NFETW
case|:
comment|/* remove from features list */
name|curitm
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"features"
argument_list|)
argument_list|)
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
for|for
control|(
name|head
operator|=
name|curitm
operator|->
name|d
operator|.
name|cdr
init|;
name|head
operator|!=
name|nil
condition|;
name|head
operator|=
name|head
operator|->
name|d
operator|.
name|cdr
control|)
block|{
if|if
condition|(
name|head
operator|->
name|d
operator|.
name|car
operator|==
name|curval
condition|)
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|=
name|head
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
else|else
name|curitm
operator|=
name|head
expr_stmt|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
case|case
name|ST_TOLC
case|:
if|if
condition|(
name|curval
operator|==
name|nil
condition|)
name|uctolc
operator|=
name|FALSE
expr_stmt|;
else|else
name|uctolc
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|setit
goto|;
case|case
name|ST_CORE
case|:
if|if
condition|(
name|curval
operator|==
name|nil
condition|)
block|{
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|badmr
argument_list|)
expr_stmt|;
comment|/* catch bus errors */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|badmr
argument_list|)
expr_stmt|;
comment|/* and segmentation viols */
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* let them core dump */
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
goto|goto
name|setit
goto|;
case|case
name|ST_INTB
case|:
name|stattab
index|[
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
index|]
operator|=
name|curval
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
case|case
name|ST_DMPW
case|:
if|if
condition|(
name|TYPE
argument_list|(
name|curval
argument_list|)
operator|!=
name|INT
operator|||
operator|(
name|curval
operator|->
name|i
operator|!=
literal|413
operator|&&
name|curval
operator|->
name|i
operator|!=
literal|407
operator|&&
name|curval
operator|->
name|i
operator|!=
literal|410
operator|)
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"sstatus: bad dump mode:"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|curval
argument_list|)
expr_stmt|;
name|dmpmode
operator|=
name|curval
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
case|case
name|ST_AUTR
case|:
if|if
condition|(
name|curval
operator|!=
name|nil
condition|)
name|Sautor
operator|=
operator|(
name|lispval
operator|)
name|TRUE
expr_stmt|;
else|else
name|Sautor
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|setit
goto|;
case|case
name|ST_TRAN
case|:
if|if
condition|(
name|curval
operator|!=
name|nil
condition|)
block|{
name|Strans
operator|=
operator|(
name|lispval
operator|)
name|TRUE
expr_stmt|;
comment|/* the atom `on' set to set up all table 			      * to their bcd fcn if possible 			      */
if|if
condition|(
name|curval
operator|==
name|matom
argument_list|(
literal|"on"
argument_list|)
condition|)
name|clrtt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Strans
operator|=
operator|(
name|lispval
operator|)
name|FALSE
expr_stmt|;
name|clrtt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* clear all transfer tables */
block|}
goto|goto
name|setit
goto|;
case|case
name|ST_BCDTR
case|:
if|if
condition|(
name|curval
operator|==
name|nil
condition|)
name|bcdtrsw
operator|=
name|FALSE
expr_stmt|;
else|else
name|bcdtrsw
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|setit
goto|;
case|case
name|ST_GCSTR
case|:
if|if
condition|(
name|curval
operator|==
name|nil
condition|)
name|gcstrings
operator|=
name|FALSE
expr_stmt|;
else|else
name|gcstrings
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|setit
goto|;
block|}
name|setit
label|:
comment|/* store value in status list */
name|curitm
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|=
name|curval
expr_stmt|;
return|return
operator|(
name|curval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Istsrch - utility routine to search the status list for the    name given as an argument.  If such an entry is not found,    we return nil  */
end_comment

begin_function
name|lispval
name|Istsrch
parameter_list|(
name|nam
parameter_list|)
name|lispval
name|nam
decl_stmt|;
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
for|for
control|(
name|handy
operator|=
name|stlist
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|car
operator|->
name|d
operator|.
name|car
operator|==
name|nam
condition|)
return|return
operator|(
name|handy
operator|->
name|d
operator|.
name|car
operator|)
return|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Iaddstat - add a status entry to the status list	*/
end_comment

begin_comment
comment|/*	return new entry in status list */
end_comment

begin_function
name|lispval
name|Iaddstat
parameter_list|(
name|name
parameter_list|,
name|readcode
parameter_list|,
name|setcode
parameter_list|,
name|valu
parameter_list|)
name|lispval
name|name
decl_stmt|,
name|valu
decl_stmt|;
name|int
name|readcode
decl_stmt|,
name|setcode
decl_stmt|;
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|handy2
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|handy
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
comment|/* build status list here */
operator|(
name|handy2
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|name
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|handy2
expr_stmt|;
operator|(
operator|(
name|handy2
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|readcode
expr_stmt|;
name|handy2
operator|=
name|handy2
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
operator|(
operator|(
name|handy2
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|setcode
expr_stmt|;
name|handy2
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|=
name|valu
expr_stmt|;
comment|/* link this one in */
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|stlist
expr_stmt|;
name|stlist
operator|=
name|handy
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|->
name|d
operator|.
name|car
operator|)
return|;
comment|/* return new item in stlist */
block|}
end_function

end_unit

