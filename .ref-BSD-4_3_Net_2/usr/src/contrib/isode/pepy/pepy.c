begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pepy.c - PE parser (yacc-based) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepy/RCS/pepy.c,v 7.3 91/02/22 09:34:58 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/pepy/RCS/pepy.c,v 7.3 91/02/22 09:34:58 mrose Interim $  *  *  * $Log:	pepy.c,v $  * Revision 7.3  91/02/22  09:34:58  mrose  * Interim 6.8  *   * Revision 7.2  90/11/21  11:32:19  mrose  * sun  *   * Revision 7.1  90/09/07  17:35:02  mrose  * touch-up  *   * Revision 7.0  89/11/23  22:11:44  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"pepy.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aflag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Cflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pepy */
end_comment

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bflag
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bwidth
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|module_actions
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pepydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doexternals
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linepos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eval
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mymodule
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OID
name|mymoduleid
init|=
name|NULLOID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yysection
init|=
name|YP_DECODER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencpref
init|=
literal|"build"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecpref
init|=
literal|"parse"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfpref
init|=
literal|"print"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencdflt
init|=
literal|"build"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecdflt
init|=
literal|"parse"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfdflt
init|=
literal|"print"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|yyprefix
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|section
block|{
name|char
modifier|*
name|s_name
decl_stmt|;
name|int
name|s_mode
decl_stmt|;
block|}
name|sections
index|[]
init|=
block|{
literal|"ENCODE"
block|,
name|YP_ENCODER
block|,
literal|"DECODE"
block|,
name|YP_DECODER
block|,
literal|"PRINT"
block|,
name|YP_PRINTER
block|,
name|NULL
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|sysin
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysout
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|modlist
block|{
name|char
modifier|*
name|md_module
decl_stmt|;
name|OID
name|md_oid
decl_stmt|;
name|struct
name|modlist
modifier|*
name|md_next
decl_stmt|;
block|}
name|modlist
operator|,
typedef|*
name|MD
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLMD
value|((MD) 0)
end_define

begin_decl_stmt
specifier|static
name|MD
name|mymodules
init|=
name|NULLMD
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|symlist
block|{
name|char
modifier|*
name|sy_encpref
decl_stmt|;
name|char
modifier|*
name|sy_decpref
decl_stmt|;
name|char
modifier|*
name|sy_prfpref
decl_stmt|;
name|char
modifier|*
name|sy_module
decl_stmt|;
name|char
modifier|*
name|sy_name
decl_stmt|;
name|YP
name|sy_type
decl_stmt|;
name|struct
name|symlist
modifier|*
name|sy_next
decl_stmt|;
block|}
name|symlist
operator|,
typedef|*
name|SY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLSY
value|((SY) 0)
end_define

begin_decl_stmt
specifier|static
name|SY
name|mysymbols
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gensym
argument_list|()
decl_stmt|,
modifier|*
name|modsym
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|MD
name|lookup_module
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|open_ph_file
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|SY
name|new_symbol
argument_list|()
decl_stmt|,
name|add_symbol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|lookup_type
argument_list|()
decl_stmt|,
name|lookup_binding
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|YT
name|lookup_tag
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|section
modifier|*
name|sectp
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|pepyversion
argument_list|)
expr_stmt|;
name|sysout
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|cp
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|aflag
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|*
name|aflag
operator|==
literal|'-'
condition|)
goto|goto
name|usage
goto|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-A"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yysection
operator|=
name|YP_ENCODER
operator||
name|YP_DECODER
operator||
name|YP_PRINTER
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-m"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-P"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Pflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-p"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sysout
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many output files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bflag
condition|)
block|{
name|not_practical
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-b& -o together is not practical\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|)
condition|)
goto|goto
name|usage
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sysout
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-S"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
goto|goto
name|usage
goto|;
for|for
control|(
name|sectp
operator|=
name|sections
init|;
name|sectp
operator|->
name|s_name
condition|;
name|sectp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sectp
operator|->
name|s_name
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yysection
operator|=
name|sectp
operator|->
name|s_mode
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sectp
operator|->
name|s_name
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown section name \"%s\"\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-b"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many prefixes\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sysout
index|[
literal|0
index|]
condition|)
goto|goto
name|not_practical
goto|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|bflag
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|*
name|bflag
operator|==
literal|'-'
condition|)
goto|goto
name|usage
goto|;
continue|continue;
block|}
if|if
condition|(
name|sysin
condition|)
block|{
name|usage
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: pepy [-d] [-h] [-p] [-o module.c] [-r] [-s] [-S section] [-b prefix] module.py\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
name|NULL
condition|)
goto|goto
name|usage
goto|;
name|sysin
operator|=
literal|""
expr_stmt|;
block|}
name|sysin
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|sysout
index|[
literal|0
index|]
operator|||
name|bflag
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
condition|)
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
operator|*
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|cp
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|cp
operator|=
name|sp
argument_list|)
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|sp
operator|>
name|cp
operator|&&
name|strcmp
argument_list|(
name|sp
argument_list|,
literal|".py"
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysout
argument_list|,
literal|"%.*s.c"
argument_list|,
name|sp
operator|-
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysout
argument_list|,
literal|"%s.c"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|pepydebug
operator|=
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"PEPYTEST"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|0
condition|)
block|{
case|case
literal|2
case|:
name|yydebug
operator|++
expr_stmt|;
comment|/* fall */
case|case
literal|1
case|:
name|sflag
operator|++
expr_stmt|;
comment|/*   .. */
case|case
literal|0
case|:
break|break;
block|}
if|if
condition|(
name|sysin
operator|==
name|NULLCP
condition|)
name|sysin
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|sysin
operator|&&
name|freopen
argument_list|(
name|sysin
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to read "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysin
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pflag
condition|)
name|exit
argument_list|(
name|pp
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sysout
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|sysout
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bflag
operator|&&
operator|*
name|sysout
operator|&&
name|freopen
argument_list|(
name|sysout
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to write "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bflag
condition|)
name|prologue
argument_list|()
expr_stmt|;
name|initoidtbl
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|yyparse
argument_list|()
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_expr_stmt
specifier|static
name|prologue
argument_list|()
block|{
name|char
operator|*
name|cp
block|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|pepyversion
argument_list|,
literal|')'
argument_list|)
condition|)
for|for
control|(
name|cp
operator|++
init|;
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|pepyversion
operator|+
name|strlen
argument_list|(
name|pepyversion
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|printf
argument_list|(
literal|"/* automatically generated by %*.*s, do not edit! */\n\n"
argument_list|,
name|cp
operator|-
name|pepyversion
argument_list|,
name|cp
operator|-
name|pepyversion
argument_list|,
name|pepyversion
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|"#include %s\n\n"
argument_list|,
name|mflag
condition|?
literal|"\"psap.h\""
else|:
literal|"<isode/psap.h>"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|bflag
condition|)
name|printf
argument_list|(
literal|"static char *pepyid = \"%s\";\n\n"
argument_list|,
name|pepyversion
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|aflag
condition|)
name|printf
argument_list|(
literal|"#define\tadvise\t%s\n\n"
argument_list|,
name|aflag
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|printf
argument_list|(
literal|"void\tadvise ();\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|ERRORS */
end_comment

begin_expr_stmt
unit|yyerror
operator|(
name|s
operator|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|yyerror_aux
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|warning
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buffer2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer2
argument_list|,
literal|"Warning: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|yyerror_aux
argument_list|(
name|buffer2
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|warning
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warning
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|yyerror_aux
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type %s: "
argument_list|,
name|eval
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %d: "
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last token read was \"%s\"\n"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|myyerror
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|myyerror
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|myyerror
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|pyyerror
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|YP
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yyerror_aux
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|pyyerror
argument_list|(
argument|yp
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pyyerror
argument_list|(
name|yp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|yyprint
argument_list|(
argument|s
argument_list|,
argument|f
argument_list|,
argument|top
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|didf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|nameoutput
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|outputlinelen
init|=
literal|79
decl_stmt|;
if|if
condition|(
name|sflag
condition|)
return|return;
if|if
condition|(
name|f
operator|&&
name|didf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|linepos
operator|=
operator|(
name|nameoutput
operator|=
name|strlen
argument_list|(
name|mymodule
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|didf
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nameoutput
operator|||
name|top
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|nameoutput
operator|=
operator|(
name|linepos
operator|=
name|strlen
argument_list|(
name|mymodule
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
define|#
directive|define
name|section
parameter_list|(
name|flag
parameter_list|,
name|prefix
parameter_list|)
define|\
value|if (yysection& (flag)) { \ 	    fprintf (stderr, " %s", (prefix)); \ 	    linepos += strlen (prefix) + 1; \ 	} \ 	else \ 	    fprintf (stderr, " none"), linepos += 5
name|section
argument_list|(
name|YP_ENCODER
argument_list|,
name|yyencpref
argument_list|)
expr_stmt|;
name|section
argument_list|(
name|YP_DECODER
argument_list|,
name|yydecpref
argument_list|)
expr_stmt|;
name|section
argument_list|(
name|YP_PRINTER
argument_list|,
name|yyprfpref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|linepos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|top
condition|)
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
operator|(
name|f
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|linepos
operator|!=
name|nameoutput
condition|)
if|if
condition|(
name|len
operator|+
name|linepos
operator|+
literal|1
operator|>
name|outputlinelen
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%*s"
argument_list|,
name|linepos
operator|=
name|nameoutput
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
operator|,
name|linepos
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
condition|?
literal|"(%s)"
else|:
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|linepos
operator|+=
name|len
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS1 */
end_comment

begin_macro
name|pass1
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|bflag
condition|)
name|prologue3
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|prologue3
argument_list|()
block|{
name|printf
argument_list|(
literal|"\n/* Generated from module %s"
argument_list|,
name|mymodule
argument_list|)
block|;
if|if
condition|(
name|mymoduleid
condition|)
name|printf
argument_list|(
literal|", Object Identifier %s"
argument_list|,
name|sprintoid
argument_list|(
name|mymoduleid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" */\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_expr_stmt
unit|pass1_type
operator|(
name|encpref
operator|,
name|decpref
operator|,
name|prfpref
operator|,
name|mod
operator|,
name|id
operator|,
name|yp
operator|)
specifier|register
name|char
operator|*
name|encpref
operator|,
operator|*
name|decpref
operator|,
operator|*
name|prfpref
operator|,
operator|*
name|mod
operator|,
operator|*
name|id
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|pepydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
operator|)
condition|)
name|yyprint
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|mysymbols
operator|=
name|add_symbol
argument_list|(
name|mysymbols
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS2 */
end_comment

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|!
name|sflag
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
literal|2
operator|,
name|j
operator|=
literal|10
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
if|if
condition|(
operator|!
operator|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
operator|)
condition|)
if|if
condition|(
operator|++
name|i
operator|>=
name|j
condition|)
name|bwidth
operator|++
operator|,
name|j
operator|*=
literal|10
expr_stmt|;
block|}
else|else
name|prologue2
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mymodule
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_module
argument_list|(
literal|"UNIV"
argument_list|,
name|NULLOID
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_ENCODER
condition|)
block|{
if|if
condition|(
name|bflag
condition|)
name|init_new_file
argument_list|()
expr_stmt|;
name|yyprefix
operator|=
name|sy
operator|->
name|sy_encpref
expr_stmt|;
name|printf
argument_list|(
literal|"\n/* ARGSUSED */\n\n%sint\t%s "
argument_list|,
operator|!
name|doexternals
operator|&&
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_EXPORTED
operator|)
condition|?
literal|"static "
else|:
literal|""
argument_list|,
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|YP_ENCODER
argument_list|)
argument_list|)
expr_stmt|;
name|do_type
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
name|eval
argument_list|,
literal|"(*pe)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n    return OK;\n}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|end_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_DECODER
condition|)
block|{
if|if
condition|(
name|bflag
condition|)
name|init_new_file
argument_list|()
expr_stmt|;
name|yyprefix
operator|=
name|sy
operator|->
name|sy_decpref
expr_stmt|;
name|printf
argument_list|(
literal|"\n/* ARGSUSED */\n\n%sint\t%s "
argument_list|,
operator|!
name|doexternals
operator|&&
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_EXPORTED
operator|)
condition|?
literal|"static "
else|:
literal|""
argument_list|,
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|YP_DECODER
argument_list|)
argument_list|)
expr_stmt|;
name|undo_type
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
name|eval
argument_list|,
literal|"pe"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n    return OK;\n}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|end_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_PRINTER
condition|)
block|{
if|if
condition|(
name|bflag
condition|)
name|init_new_file
argument_list|()
expr_stmt|;
name|yyprefix
operator|=
name|sy
operator|->
name|sy_prfpref
expr_stmt|;
name|printf
argument_list|(
literal|"\n/* ARGSUSED */\n\n%sint\t%s "
argument_list|,
operator|!
name|doexternals
operator|&&
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_EXPORTED
operator|)
condition|?
literal|"static "
else|:
literal|""
argument_list|,
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|YP_PRINTER
argument_list|)
argument_list|)
expr_stmt|;
name|undo_type
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
name|eval
argument_list|,
literal|"pe"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n    return OK;\n}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|end_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bflag
operator|&&
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_ph_file
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|prologue2
argument_list|()
block|{
name|printf
argument_list|(
literal|"\n#ifndef PEPYPARM\n#define PEPYPARM char *\n"
argument_list|)
block|;
name|printf
argument_list|(
literal|"#endif /* PEPYPARM */\n"
argument_list|)
block|;
comment|/* keep ansi happy ... */
name|printf
argument_list|(
literal|"extern PEPYPARM NullParm;\n"
argument_list|)
block|; }
comment|/*
comment|*/
expr|struct
name|tuple
name|tuples
index|[]
operator|=
block|{
name|YP_BOOL
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_BOOL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_BOOL
block|,
name|YP_INT
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_INT"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_INT
block|,
name|YP_INTLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_INT"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_INT
block|,
name|YP_BIT
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_BITS"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_BITS
block|,
name|YP_BITLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_BITS"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_BITS
block|,
name|YP_OCT
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_OCTS"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_OCTS
block|,
name|YP_NULL
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_NULL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_NULL
block|,
name|YP_OID
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_OID"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_OID
block|,
name|YP_SEQ
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SEQ"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SEQ
block|,
name|YP_SEQTYPE
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SEQ"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SEQ
block|,
name|YP_SEQLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SEQ"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SEQ
block|,
name|YP_SET
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SET"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SET
block|,
name|YP_SETTYPE
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SET"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SET
block|,
name|YP_SETLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SET"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SET
block|,
name|YP_ENUMLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_ENUM"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_ENUM
block|,
name|YP_REAL
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_REAL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_REAL
block|,
name|YP_UNDF
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*
comment|PULLUP */
end_comment

begin_expr_stmt
name|choice_pullup
argument_list|(
name|yp
argument_list|,
name|partial
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pullup fully, or just enough? */
end_comment

begin_block
block|{
specifier|register
name|YP
modifier|*
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
modifier|*
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|z3
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|yp
operator|->
name|yp_type
init|;
name|y
operator|=
operator|*
name|x
condition|;
name|x
operator|=
operator|&
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_BOUND
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|partial
condition|)
continue|continue;
if|if
condition|(
operator|(
name|z
operator|=
name|lookup_type
argument_list|(
name|y
operator|->
name|yp_module
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULLYP
operator|||
name|z
operator|->
name|yp_code
operator|!=
name|YP_CHOICE
condition|)
continue|continue;
name|choice_pullup
argument_list|(
name|z2
operator|=
name|copy_type
argument_list|(
name|z
argument_list|)
argument_list|,
name|partial
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
name|choice_pullup
argument_list|(
name|z2
operator|=
name|copy_type
argument_list|(
name|y
argument_list|)
argument_list|,
name|partial
argument_list|)
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|z
operator|=
name|z3
operator|=
name|z2
operator|->
name|yp_type
expr_stmt|;
for|for
control|(
name|z1
operator|=
operator|&
name|z
operator|->
name|yp_next
init|;
name|z2
operator|=
operator|*
name|z1
condition|;
name|z1
operator|=
operator|&
name|z2
operator|->
name|yp_next
control|)
name|z3
operator|=
name|z2
expr_stmt|;
operator|*
name|z1
operator|=
name|y
operator|->
name|yp_next
expr_stmt|;
operator|*
name|x
operator|=
name|z
expr_stmt|;
name|y
operator|=
name|z3
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|tag_pullup
argument_list|(
name|yp
argument_list|,
name|level
argument_list|,
name|arg
argument_list|,
name|whatsit
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|whatsit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|narg
decl_stmt|;
name|char
modifier|*
name|id
init|=
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|?
name|yp
operator|->
name|yp_id
else|:
literal|"member"
decl_stmt|;
name|printf
argument_list|(
literal|"%*s{\t/* %s TAG PULLUP */\n%*sregister PE %s;\n\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|whatsit
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
operator|=
name|gensym
argument_list|()
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%*sif ((%s = prim2set (%s)) == NULLPE) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%s %%s%s: %%s\", PEPY_ERR_BAD,\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|whatsit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*spe_error (%s -> pe_errno));\n"
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sif (%s -> pe_cardinal != 1) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%s %%s %s: %%d\", PEPY_ERR_TOO_MANY_TAGGED,\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|whatsit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s -> pe_cardinal);\n"
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s = first_member (%s);\n%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|narg
argument_list|,
operator|(
name|level
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|tag_pushdown
argument_list|(
name|yp
argument_list|,
name|level
argument_list|,
name|arg
argument_list|,
name|whatsit
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|whatsit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|narg
decl_stmt|;
name|printf
argument_list|(
literal|"%*s{\t/* %s TAG PUSHDOWN */\n%*sPE %s_z;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|whatsit
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
operator|=
name|gensym
argument_list|()
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%*sregister PE *%s =&%s_z;\n\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sif ((*%s = pe_alloc (PE_CLASS_%s, PE_FORM_CONS, %d)) == NULLPE) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
argument_list|,
name|pe_classlist
index|[
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
index|]
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%s: %%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|whatsit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s(*%s) -> pe_cons = %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|narg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s = *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|TYPE HANDLING */
end_comment

begin_expr_stmt
name|tag_type
argument_list|(
name|yp
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tuple
modifier|*
name|t
decl_stmt|;
specifier|register
name|YT
name|yt
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|lookup_binding
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
name|myyerror
argument_list|(
literal|"type \"%s\" isn't defined for binding"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
condition|)
name|myyerror
argument_list|(
literal|"type \"%s\" isn't tagged for binding"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_flags
operator||=
name|YP_TAG
expr_stmt|;
name|yp
operator|->
name|yp_tag
operator|=
name|copy_tag
argument_list|(
name|y
operator|->
name|yp_tag
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|yt
operator|=
name|lookup_tag
argument_list|(
name|yp
argument_list|)
condition|)
block|{
name|yp
operator|->
name|yp_flags
operator||=
name|YP_TAG
operator||
name|YP_IMPLICIT
expr_stmt|;
name|yp
operator|->
name|yp_tag
operator|=
name|copy_tag
argument_list|(
name|yt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
condition|)
name|pyyerror
argument_list|(
name|yp
argument_list|,
literal|"don't know how to tag an undefined type"
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|t
operator|=
name|tuples
init|;
name|t
operator|->
name|t_type
operator|!=
name|YP_UNDF
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|t_type
operator|==
name|yp
operator|->
name|yp_code
condition|)
block|{
name|yp
operator|->
name|yp_flags
operator||=
name|YP_TAG
operator||
name|YP_IMPLICIT
expr_stmt|;
name|yp
operator|->
name|yp_tag
operator|=
name|new_tag
argument_list|(
name|t
operator|->
name|t_classnum
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|=
name|new_value
argument_list|(
name|YV_NUMBER
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
operator|=
name|t
operator|->
name|t_idnum
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|pyyerror
argument_list|(
name|yp
argument_list|,
literal|"don't know how to do a set/choice member that isn't tagged or bound"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YP
name|lookup_type
parameter_list|(
name|mod
parameter_list|,
name|id
parameter_list|)
specifier|register
name|char
modifier|*
name|mod
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|mod
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mod
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sy
operator|->
name|sy_type
return|;
block|}
return|return
name|NULLYP
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|YP
name|lookup_binding
parameter_list|(
name|mod
parameter_list|,
name|id
parameter_list|,
name|binding
parameter_list|)
specifier|register
name|char
modifier|*
name|mod
decl_stmt|,
decl|*
name|id
decl_stmt|,
modifier|*
name|binding
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|YP
name|yp
decl_stmt|,
name|z
decl_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
name|lookup_type
argument_list|(
name|mod
argument_list|,
name|id
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
return|return
name|NULLYP
return|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_CHOICE
condition|)
name|myyerror
argument_list|(
literal|"type \"%s\" isn't a CHOICE type"
argument_list|,
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|z
operator|=
name|yp
operator|->
name|yp_type
init|;
name|z
condition|;
name|z
operator|=
name|z
operator|->
name|yp_next
control|)
if|if
condition|(
operator|(
name|z
operator|->
name|yp_flags
operator|&
name|YP_ID
operator|)
operator|&&
name|strcmp
argument_list|(
name|z
operator|->
name|yp_id
argument_list|,
name|binding
argument_list|)
operator|==
literal|0
condition|)
return|return
name|z
return|;
name|myyerror
argument_list|(
literal|"type \"%s\" doesn't bind \"%s\""
argument_list|,
name|id
argument_list|,
name|binding
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|check_type
argument_list|(
name|type
argument_list|,
name|level
argument_list|,
name|class
argument_list|,
name|form
argument_list|,
name|id
argument_list|,
name|arg
argument_list|)
specifier|register
name|char
operator|*
name|type
operator|,
operator|*
name|class
operator|,
operator|*
name|form
operator|,
operator|*
name|id
operator|,
operator|*
name|arg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|explicit
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%*sif (explicit) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
operator|,
name|level
operator|++
expr_stmt|;
name|explicit
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|explicit
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%*sif (%s -> pe_class != %s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
condition|)
name|printf
argument_list|(
literal|"\n%*s|| %s -> pe_form != %s\n%*s"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|form
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" || %s -> pe_id != %s) {\n"
argument_list|,
name|arg
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%s bad class/form/id: %%s/%%d/0x%%x\",\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*spe_classlist[%s -> pe_class], %s -> pe_form, %s -> pe_id);\n"
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit
condition|)
block|{
name|level
operator|--
operator|,
name|printf
argument_list|(
literal|"%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
condition|)
block|{
name|printf
argument_list|(
literal|"%*selse\n%*sif (%s -> pe_form != %s) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%s bad form: %%d\", %s -> pe_form);\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|is_any_type
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YP
name|z
decl_stmt|;
while|while
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_module
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|=
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
condition|)
block|{
name|yp
operator|=
name|z
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_ANY
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_nonimplicit_type
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YP
name|z
decl_stmt|;
while|while
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
operator|)
operator|==
operator|(
name|YP_TAG
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_module
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|=
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
condition|)
block|{
name|yp
operator|=
name|z
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_CHOICE
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_ANY
condition|)
block|{
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
operator|)
operator|==
name|YP_TAG
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|uniqint
argument_list|(
name|yv
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|YV
name|y
decl_stmt|;
for|for
control|(
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|i
operator|=
name|val2int
argument_list|(
name|yv
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_next
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
if|if
condition|(
name|i
operator|==
name|val2int
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"non-unique values in list"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvalue=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" name1=%s"
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" name2=%s"
argument_list|,
name|y
operator|->
name|yv_named
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|uniqtag
argument_list|(
name|y
argument_list|,
name|z
argument_list|)
specifier|register
name|YP
name|y
operator|,
name|z
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|id
decl_stmt|;
specifier|register
name|YT
name|yt
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
for|for
control|(
init|;
name|y
operator|!=
name|z
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
operator|(
name|yt
operator|=
name|lookup_tag
argument_list|(
name|y
argument_list|)
operator|)
operator|==
name|NULLYT
condition|)
continue|continue;
name|id
operator|=
name|PE_ID
argument_list|(
name|yt
operator|->
name|yt_class
argument_list|,
name|i
operator|=
name|val2int
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|yp
operator|=
name|y
operator|->
name|yp_next
init|;
name|yp
operator|!=
name|z
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
operator|(
name|yt
operator|=
name|lookup_tag
argument_list|(
name|yp
argument_list|)
operator|)
operator|==
name|NULLYT
condition|)
continue|continue;
if|if
condition|(
name|id
operator|==
name|PE_ID
argument_list|(
name|yt
operator|->
name|yt_class
argument_list|,
name|val2int
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"non-unique tags in list"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttag=%s/%d"
argument_list|,
name|pe_classlist
index|[
name|yt
operator|->
name|yt_class
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" id1=%s"
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" id2=%s"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|val2int
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_VALIST
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a list of values"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|PH FILES */
end_comment

begin_comment
comment|/* really need much more information in the .ph file... */
end_comment

begin_expr_stmt
specifier|static
name|read_ph_file
argument_list|(
name|module
argument_list|,
name|oid
argument_list|)
specifier|register
name|char
operator|*
name|module
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|OID
name|oid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|class
decl_stmt|,
name|value
decl_stmt|,
name|direction
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|file
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|id
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|encpref
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|decpref
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|printpref
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ppp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
specifier|register
name|YT
name|yt
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s.ph"
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
operator|=
name|buffer
argument_list|,
literal|"%s.ph"
argument_list|,
name|sprintoid
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULLCP
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|open_ph_file
argument_list|(
name|file
argument_list|,
name|p
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Can't find file %s%s%s failed\n"
argument_list|,
name|file
argument_list|,
name|p
condition|?
literal|"/"
else|:
literal|""
argument_list|,
name|p
condition|?
name|p
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|module
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
name|yyprint
argument_list|(
name|module
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"%d/%d/%d: %s"
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|direction
argument_list|,
name|id
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|myyerror
argument_list|(
literal|"bad external definition in %s: %s"
argument_list|,
name|file
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ppp
operator|=
name|dp
operator|=
name|ep
operator|=
name|NULLCP
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'|'
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|"%s %s %s\n"
argument_list|,
name|encpref
argument_list|,
name|decpref
argument_list|,
name|printpref
argument_list|)
operator|==
literal|3
condition|)
block|{
name|ppp
operator|=
name|new_string
argument_list|(
name|printpref
argument_list|)
expr_stmt|;
name|dp
operator|=
name|new_string
argument_list|(
name|decpref
argument_list|)
expr_stmt|;
name|ep
operator|=
name|new_string
argument_list|(
name|encpref
argument_list|)
expr_stmt|;
block|}
block|}
name|yp
operator|=
name|new_type
argument_list|(
name|YP_ANY
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_flags
operator|=
name|YP_IMPORTED
expr_stmt|;
if|if
condition|(
name|class
operator|>=
literal|0
condition|)
block|{
name|yp
operator|->
name|yp_flags
operator||=
name|YP_TAG
expr_stmt|;
name|yp
operator|->
name|yp_tag
operator|=
name|yt
operator|=
name|new_tag
argument_list|(
operator|(
name|PElementClass
operator|)
name|class
argument_list|)
expr_stmt|;
name|yt
operator|->
name|yt_value
operator|=
name|yv
operator|=
name|new_value
argument_list|(
name|YV_NUMBER
argument_list|)
expr_stmt|;
name|yv
operator|->
name|yv_number
operator|=
name|value
expr_stmt|;
block|}
name|yp
operator|->
name|yp_direction
operator|=
name|direction
expr_stmt|;
name|pass1_type
argument_list|(
name|ep
argument_list|,
name|dp
argument_list|,
name|ppp
argument_list|,
name|new_string
argument_list|(
name|module
argument_list|)
argument_list|,
name|new_string
argument_list|(
name|id
argument_list|)
argument_list|,
name|yp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|write_ph_file
argument_list|()
block|{
name|int
name|msave
block|;
name|char
name|file
index|[
name|BUFSIZ
index|]
block|;
name|char
name|fileoid
index|[
name|BUFSIZ
index|]
block|;
name|char
operator|*
name|cp
block|;
specifier|register
name|FILE
operator|*
name|fp
block|;
specifier|register
name|SY
name|sy
block|;
specifier|register
name|YT
name|yt
block|;
specifier|register
name|YP
name|yp
block|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s.ph"
argument_list|,
name|mymodule
argument_list|)
block|;
if|if
condition|(
name|mymoduleid
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|fileoid
argument_list|,
literal|"%s.ph"
argument_list|,
name|sprintoid
argument_list|(
name|mymoduleid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|NULLCP
expr_stmt|;
name|msave
operator|=
name|mflag
operator|,
name|mflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|fp
operator|=
name|open_ph_file
argument_list|(
name|file
argument_list|,
name|cp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|mflag
operator|=
name|msave
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|doexternals
operator|==
literal|0
operator|&&
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_EXPORTED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|is_any_type
argument_list|(
name|yp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-1/0/%d: %s"
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" |%s %s %s\n"
argument_list|,
name|yyencpref
argument_list|,
name|yydecpref
argument_list|,
name|yyprfpref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|yt
operator|=
name|lookup_tag
argument_list|(
name|yp
argument_list|)
operator|)
operator|&&
name|yt
operator|->
name|yt_class
operator|!=
name|PE_CLASS_CONT
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d/%d/%d: %s"
argument_list|,
name|yt
operator|->
name|yt_class
argument_list|,
name|val2int
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" |%s %s %s\n"
argument_list|,
name|yyencpref
argument_list|,
name|yydecpref
argument_list|,
name|yyprfpref
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PEPYPATH
end_ifndef

begin_define
define|#
directive|define
name|PEPYPATH
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
unit|static
name|FILE
modifier|*
name|open_ph_file
parameter_list|(
name|fn
parameter_list|,
name|fnoid
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|,
decl|*
name|fnoid
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|char
name|fnb
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|char
modifier|*
name|pepypath
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|fn
operator|==
literal|'/'
condition|)
return|return
name|fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|mflag
condition|)
block|{
comment|/* MOBY HACK */
if|if
condition|(
name|fnoid
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnoid
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
if|if
condition|(
name|fnoid
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../pepy/%s"
argument_list|,
name|fnoid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../pepy/%s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
if|if
condition|(
name|fnoid
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../../pepy/%s"
argument_list|,
name|fnoid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../../pepy/%s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|pepypath
operator|==
name|NULL
operator|&&
operator|(
name|pepypath
operator|=
name|getenv
argument_list|(
literal|"PEPYPATH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pepypath
operator|=
name|PEPYPATH
expr_stmt|;
name|path
operator|=
name|pepypath
expr_stmt|;
do|do
block|{
name|dst
operator|=
name|fnb
expr_stmt|;
while|while
condition|(
operator|*
name|path
operator|&&
operator|*
name|path
operator|!=
literal|':'
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|fnb
condition|)
operator|*
name|dst
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|fnoid
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dst
argument_list|,
name|fnoid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dst
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|path
operator|++
condition|)
do|;
return|return
name|fp
return|;
block|}
end_block

begin_comment
comment|/*
comment|PRETTY-PRINTING */
end_comment

begin_define
define|#
directive|define
name|S0
value|0
end_define

begin_define
define|#
directive|define
name|S1
value|1
end_define

begin_define
define|#
directive|define
name|S2
value|2
end_define

begin_define
define|#
directive|define
name|S3
value|3
end_define

begin_define
define|#
directive|define
name|S4
value|4
end_define

begin_define
define|#
directive|define
name|S5
value|5
end_define

begin_define
define|#
directive|define
name|S6
value|6
end_define

begin_define
define|#
directive|define
name|S7
value|7
end_define

begin_define
define|#
directive|define
name|S8
value|8
end_define

begin_define
define|#
directive|define
name|S9
value|9
end_define

begin_function
specifier|static
name|int
name|pp
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|wp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|s
operator|=
name|S0
operator|,
name|bp
operator|=
name|buffer
init|;
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|;
control|)
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|S0
case|:
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
name|s
operator|=
name|S1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
name|s
operator|=
name|S4
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
name|s
operator|=
name|S7
expr_stmt|;
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
name|c
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|flush
label|:
empty_stmt|;
if|if
condition|(
name|bp
operator|!=
name|buffer
condition|)
block|{
for|for
control|(
name|wp
operator|=
name|buffer
init|;
name|wp
operator|<
name|bp
condition|;
name|wp
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|wp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
block|}
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|S1
case|:
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|bp
operator|=
name|buffer
expr_stmt|;
name|s
operator|=
name|S2
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|=
name|S0
expr_stmt|;
goto|goto
name|flush
goto|;
case|case
name|S2
case|:
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
name|s
operator|=
name|S3
expr_stmt|;
break|break;
case|case
name|S3
case|:
name|s
operator|=
name|c
operator|==
literal|'}'
condition|?
name|S0
else|:
name|S2
expr_stmt|;
break|break;
case|case
name|S4
case|:
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|bp
operator|=
name|buffer
expr_stmt|;
name|s
operator|=
name|S5
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|++
operator|=
literal|'<'
expr_stmt|;
name|s
operator|=
name|S0
expr_stmt|;
goto|goto
name|flush
goto|;
case|case
name|S5
case|:
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
name|s
operator|=
name|S6
expr_stmt|;
break|break;
case|case
name|S6
case|:
name|s
operator|=
name|c
operator|==
literal|'>'
condition|?
name|S0
else|:
name|S5
expr_stmt|;
break|break;
case|case
name|S7
case|:
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|bp
operator|=
name|buffer
expr_stmt|;
name|s
operator|=
name|S8
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|++
operator|=
literal|'['
expr_stmt|;
name|s
operator|=
name|S0
expr_stmt|;
goto|goto
name|flush
goto|;
case|case
name|S8
case|:
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
name|s
operator|=
name|S9
expr_stmt|;
break|break;
case|case
name|S9
case|:
name|s
operator|=
name|c
operator|==
literal|']'
condition|?
name|S0
else|:
name|S8
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"s=%d\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bp
operator|!=
name|buffer
condition|)
for|for
control|(
name|wp
operator|=
name|buffer
init|;
name|wp
operator|<
name|bp
condition|;
name|wp
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|wp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*
comment|DEBUG */
end_comment

begin_expr_stmt
name|print_type
argument_list|(
name|yp
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s direction=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|,
name|sprintb
argument_list|(
name|yp
operator|->
name|yp_flags
argument_list|,
name|YPBITS
argument_list|)
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sintexp=\"%s\" strexp=\"%s\" prfexp=%c declexp=\"%s\" varexp=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sparameter type=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction0 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act0_lineno
argument_list|,
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action05
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction05 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act05_lineno
argument_list|,
name|yp
operator|->
name|yp_action05
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction1 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act1_lineno
argument_list|,
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction2 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act2_lineno
argument_list|,
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction3 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act3_lineno
argument_list|,
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stag class=0x%x value=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sdefault=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*soffset=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_INTLIST
case|:
case|case
name|YP_BITLIST
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*svalue=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|print_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_module
condition|?
name|yp
operator|->
name|yp_module
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|,
name|sprintb
argument_list|(
name|yv
operator|->
name|yv_flags
argument_list|,
name|YVBITS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_act_lineno
argument_list|,
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snamed=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snumber=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sstring=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_function
specifier|static
name|SY
name|new_symbol
parameter_list|(
name|encpref
parameter_list|,
name|decpref
parameter_list|,
name|prfpref
parameter_list|,
name|mod
parameter_list|,
name|id
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
name|encpref
decl_stmt|,
decl|*
name|decpref
decl_stmt|,
modifier|*
name|prfpref
decl_stmt|,
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|YP
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
operator|(
name|sy
operator|=
operator|(
name|SY
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|sy
argument_list|)
operator|)
operator|==
name|NULLSY
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_encpref
operator|=
name|encpref
expr_stmt|;
name|sy
operator|->
name|sy_decpref
operator|=
name|decpref
expr_stmt|;
name|sy
operator|->
name|sy_prfpref
operator|=
name|prfpref
expr_stmt|;
name|sy
operator|->
name|sy_module
operator|=
name|mod
expr_stmt|;
name|sy
operator|->
name|sy_name
operator|=
name|id
expr_stmt|;
name|sy
operator|->
name|sy_type
operator|=
name|type
expr_stmt|;
return|return
name|sy
return|;
block|}
end_block

begin_function
specifier|static
name|SY
name|add_symbol
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|SY
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULLSY
condition|)
return|return
name|s2
return|;
for|for
control|(
name|sy
operator|=
name|s1
init|;
name|sy
operator|->
name|sy_next
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
continue|continue;
name|sy
operator|->
name|sy_next
operator|=
name|s2
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/*
comment|MODULES */
end_comment

begin_function
specifier|static
name|MD
name|lookup_module
parameter_list|(
name|module
parameter_list|,
name|oid
parameter_list|)
name|char
modifier|*
name|module
decl_stmt|;
name|OID
name|oid
decl_stmt|;
block|{
specifier|register
name|MD
name|md
decl_stmt|;
for|for
control|(
name|md
operator|=
name|mymodules
init|;
name|md
condition|;
name|md
operator|=
name|md
operator|->
name|md_next
control|)
block|{
if|if
condition|(
name|module
operator|&&
name|md
operator|->
name|md_module
operator|&&
name|strcmp
argument_list|(
name|md
operator|->
name|md_module
argument_list|,
name|module
argument_list|)
operator|==
literal|0
condition|)
return|return
name|md
return|;
if|if
condition|(
name|oid
operator|&&
name|md
operator|->
name|md_oid
operator|&&
name|oid_cmp
argument_list|(
name|oid
argument_list|,
name|md
operator|->
name|md_oid
argument_list|)
operator|==
literal|0
condition|)
return|return
name|md
return|;
block|}
name|read_ph_file
argument_list|(
name|module
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
operator|(
name|MD
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|md
argument_list|)
operator|)
operator|==
name|NULLMD
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_module
operator|=
name|new_string
argument_list|(
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
condition|)
name|md
operator|->
name|md_oid
operator|=
name|oid_cpy
argument_list|(
name|oid
argument_list|)
expr_stmt|;
else|else
name|md
operator|->
name|md_oid
operator|=
name|NULLOID
expr_stmt|;
if|if
condition|(
name|mymodules
operator|!=
name|NULLMD
condition|)
name|md
operator|->
name|md_next
operator|=
name|mymodules
expr_stmt|;
return|return
operator|(
name|mymodules
operator|=
name|md
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|TYPES */
end_comment

begin_function
name|YP
name|new_type
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
operator|(
name|YP
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yp
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_code
operator|=
name|code
expr_stmt|;
return|return
name|yp
return|;
block|}
end_function

begin_function
name|YP
name|add_type
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YP
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
for|for
control|(
name|yp
operator|=
name|y
init|;
name|yp
operator|->
name|yp_next
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
continue|continue;
name|yp
operator|->
name|yp_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YP
name|copy_type
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YP
name|y
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return
name|NULLYP
return|;
name|y
operator|=
name|new_type
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_direction
operator|=
name|yp
operator|->
name|yp_direction
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
condition|)
name|y
operator|->
name|yp_module
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_identifier
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_modid
operator|=
name|oid_cpy
argument_list|(
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|y
operator|->
name|yp_type
operator|=
name|copy_type
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_BITLIST
case|:
name|y
operator|->
name|yp_value
operator|=
name|copy_value
argument_list|(
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|y
operator|->
name|yp_intexp
operator|=
name|yp
operator|->
name|yp_intexp
expr_stmt|;
name|y
operator|->
name|yp_strexp
operator|=
name|yp
operator|->
name|yp_strexp
expr_stmt|;
name|y
operator|->
name|yp_prfexp
operator|=
name|yp
operator|->
name|yp_prfexp
expr_stmt|;
name|y
operator|->
name|yp_declexp
operator|=
name|yp
operator|->
name|yp_declexp
expr_stmt|;
name|y
operator|->
name|yp_varexp
operator|=
name|yp
operator|->
name|yp_varexp
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|y
operator|->
name|yp_structname
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|y
operator|->
name|yp_ptrname
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
name|y
operator|->
name|yp_param_type
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
block|{
name|y
operator|->
name|yp_action0
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act0_lineno
operator|=
name|yp
operator|->
name|yp_act0_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action05
condition|)
block|{
name|y
operator|->
name|yp_action05
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action05
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act05_lineno
operator|=
name|yp
operator|->
name|yp_act05_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
block|{
name|y
operator|->
name|yp_action1
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act1_lineno
operator|=
name|yp
operator|->
name|yp_act1_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
block|{
name|y
operator|->
name|yp_action2
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act2_lineno
operator|=
name|yp
operator|->
name|yp_act2_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
block|{
name|y
operator|->
name|yp_action3
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act3_lineno
operator|=
name|yp
operator|->
name|yp_act3_lineno
expr_stmt|;
block|}
name|y
operator|->
name|yp_flags
operator|=
name|yp
operator|->
name|yp_flags
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|y
operator|->
name|yp_default
operator|=
name|copy_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|y
operator|->
name|yp_id
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
name|y
operator|->
name|yp_tag
operator|=
name|copy_tag
argument_list|(
name|yp
operator|->
name|yp_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|y
operator|->
name|yp_bound
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
condition|)
name|y
operator|->
name|yp_parm
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
name|y
operator|->
name|yp_control
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTCONTROL
condition|)
name|y
operator|->
name|yp_optcontrol
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
name|y
operator|->
name|yp_offset
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_next
condition|)
name|y
operator|->
name|yp_next
operator|=
name|copy_type
argument_list|(
name|yp
operator|->
name|yp_next
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|VALUES */
end_comment

begin_function
name|YV
name|new_value
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
operator|(
name|yv
operator|=
operator|(
name|YV
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yv
argument_list|)
operator|)
operator|==
name|NULLYV
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yv
operator|->
name|yv_code
operator|=
name|code
expr_stmt|;
return|return
name|yv
return|;
block|}
end_function

begin_function
name|YV
name|add_value
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YV
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
name|y
operator|==
name|NULLYV
condition|)
return|return
name|z
return|;
if|if
condition|(
name|z
operator|==
name|NULLYV
condition|)
return|return
name|y
return|;
for|for
control|(
name|yv
operator|=
name|y
init|;
name|yv
operator|->
name|yv_next
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
continue|continue;
name|yv
operator|->
name|yv_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YV
name|copy_value
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return
name|NULLYV
return|;
name|y
operator|=
name|new_value
argument_list|(
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_flags
operator|=
name|yv
operator|->
name|yv_flags
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
block|{
name|y
operator|->
name|yv_action
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_act_lineno
operator|=
name|yv
operator|->
name|yv_act_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|y
operator|->
name|yv_id
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|y
operator|->
name|yv_named
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
name|y
operator|->
name|yv_type
operator|=
name|copy_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
name|y
operator|->
name|yv_number
operator|=
name|yv
operator|->
name|yv_number
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|y
operator|->
name|yv_string
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_module
condition|)
name|y
operator|->
name|yv_module
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_module
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_identifier
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
name|y
operator|->
name|yv_idlist
operator|=
name|copy_value
argument_list|(
name|yv
operator|->
name|yv_idlist
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|yv
operator|->
name|yv_next
condition|)
name|y
operator|->
name|yv_next
operator|=
name|copy_value
argument_list|(
name|yv
operator|->
name|yv_next
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|TAGS */
end_comment

begin_function
name|YT
name|new_tag
parameter_list|(
name|class
parameter_list|)
name|PElementClass
name|class
decl_stmt|;
block|{
specifier|register
name|YT
name|yt
decl_stmt|;
if|if
condition|(
operator|(
name|yt
operator|=
operator|(
name|YT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yt
argument_list|)
operator|)
operator|==
name|NULLYT
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yt
operator|->
name|yt_class
operator|=
name|class
expr_stmt|;
return|return
name|yt
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YT
name|copy_tag
parameter_list|(
name|yt
parameter_list|)
specifier|register
name|YT
name|yt
decl_stmt|;
block|{
specifier|register
name|YT
name|y
decl_stmt|;
if|if
condition|(
name|yt
operator|==
name|NULLYT
condition|)
return|return
name|NULLYT
return|;
name|y
operator|=
name|new_tag
argument_list|(
name|yt
operator|->
name|yt_class
argument_list|)
expr_stmt|;
name|y
operator|->
name|yt_value
operator|=
name|copy_value
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YT
name|lookup_tag
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|struct
name|tuple
modifier|*
name|t
decl_stmt|;
specifier|static
name|struct
name|ypt
name|ypts
decl_stmt|;
specifier|register
name|YT
name|yt
init|=
operator|&
name|ypts
decl_stmt|;
specifier|static
name|struct
name|ypv
name|ypvs
decl_stmt|;
specifier|register
name|YV
name|yv
init|=
operator|&
name|ypvs
decl_stmt|;
specifier|register
name|YP
name|z
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
return|return
name|yp
operator|->
name|yp_tag
return|;
while|while
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_module
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|=
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
condition|)
block|{
name|yp
operator|=
name|z
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
return|return
name|yp
operator|->
name|yp_tag
return|;
continue|continue;
block|}
break|break;
block|}
for|for
control|(
name|t
operator|=
name|tuples
init|;
name|t
operator|->
name|t_type
operator|!=
name|YP_UNDF
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|t_type
operator|==
name|yp
operator|->
name|yp_code
condition|)
block|{
name|yt
operator|->
name|yt_class
operator|=
name|t
operator|->
name|t_classnum
expr_stmt|;
name|yt
operator|->
name|yt_value
operator|=
name|yv
expr_stmt|;
name|yv
operator|->
name|yv_code
operator|=
name|YV_NUMBER
expr_stmt|;
name|yv
operator|->
name|yv_number
operator|=
name|t
operator|->
name|t_idnum
expr_stmt|;
return|return
name|yt
return|;
block|}
return|return
name|NULLYT
return|;
block|}
end_function

begin_comment
comment|/*
comment|STRINGS */
end_comment

begin_function
name|char
modifier|*
name|new_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_struct
specifier|static
struct|struct
name|triple
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|PElementClass
name|t_class
decl_stmt|;
name|PElementID
name|t_id
decl_stmt|;
block|}
name|triples
index|[]
init|=
block|{
literal|"IA5String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"ISO646String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"NumericString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_NUMS
block|,
literal|"PrintableString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_PRTS
block|,
literal|"T61String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"TeletexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"VideotexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VTXS
block|,
literal|"GeneralizedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"GeneralisedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"UTCTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"UniversalTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"GraphicString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GFXS
block|,
literal|"VisibleString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VISS
block|,
literal|"GeneralString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENS
block|,
literal|"EXTERNAL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_EXTN
block|,
literal|"ObjectDescriptor"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_ODE
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|char
modifier|*
name|modsym
parameter_list|(
name|module
parameter_list|,
name|id
parameter_list|,
name|direct
parameter_list|)
specifier|register
name|char
modifier|*
name|module
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|direct
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|pref
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|pref
operator|=
name|NULLCP
expr_stmt|;
if|if
condition|(
name|module
operator|==
name|NULLCP
condition|)
for|for
control|(
name|t
operator|=
name|triples
init|;
name|t
operator|->
name|t_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|module
operator|=
literal|"UNIV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|module
operator|&&
name|strcmp
argument_list|(
name|module
argument_list|,
name|mymodule
argument_list|)
condition|)
switch|switch
condition|(
name|direct
condition|)
block|{
case|case
name|YP_DECODER
case|:
name|pref
operator|=
name|yydecdflt
expr_stmt|;
break|break;
case|case
name|YP_ENCODER
case|:
name|pref
operator|=
name|yyencdflt
expr_stmt|;
break|break;
case|case
name|YP_PRINTER
case|:
name|pref
operator|=
name|yyprfdflt
expr_stmt|;
break|break;
block|}
name|modsym_aux
argument_list|(
name|pref
condition|?
name|pref
else|:
name|yyprefix
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|module
condition|?
name|module
else|:
name|mymodule
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|id
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|modsym_aux
argument_list|(
name|name
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|char
modifier|*
name|gensym
parameter_list|()
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"p%d"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
return|return
name|new_string
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_macro
name|init_new_file
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|file_no
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-%.*d.c"
argument_list|,
name|bflag
argument_list|,
name|bwidth
argument_list|,
operator|++
name|file_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|buffer
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to write "
argument_list|)
operator|,
name|perror
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|prologue
argument_list|()
expr_stmt|;
name|prologue3
argument_list|()
expr_stmt|;
if|if
condition|(
name|module_actions
condition|)
name|fputs
argument_list|(
name|module_actions
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|prologue2
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|end_file
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

