begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vt.c - VT initiator */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/vt/RCS/vt.c,v 7.4 91/02/22 09:48:23 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/vt/RCS/vt.c,v 7.4 91/02/22 09:48:23 mrose Interim $  *  *  * $Log:	vt.c,v $  * Revision 7.4  91/02/22  09:48:23  mrose  * Interim 6.8  *   * Revision 7.3  90/12/23  18:43:29  mrose  * update  *   * Revision 7.2  90/01/11  18:38:13  mrose  * real-sync  *   * Revision 7.1  89/11/30  23:51:38  mrose  * pa2str  *   * Revision 7.0  89/11/23  22:31:49  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"vtpm.h"
end_include

begin_include
include|#
directive|include
file|"sector1.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD44
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|strip
parameter_list|(
name|x
parameter_list|)
value|((x)&0177)
end_define

begin_define
define|#
directive|define
name|TBUFSIZ
value|1024
end_define

begin_decl_stmt
name|char
name|ttyobuf
index|[
name|TBUFSIZ
index|]
decl_stmt|,
modifier|*
name|tfrontp
init|=
name|ttyobuf
decl_stmt|,
modifier|*
name|tbackp
init|=
name|ttyobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netobuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|nfrontp
init|=
name|netobuf
decl_stmt|,
modifier|*
name|nbackp
init|=
name|netobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|connected
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|net
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|showoptions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|crmod
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|escape
init|=
literal|']'
operator|&
literal|037
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|escapestr
init|=
literal|"^]"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VT_PROFILE
name|vtp_profile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|erase_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Unix Erase*/
end_comment

begin_decl_stmt
name|char
name|erase_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Unix Kill*/
end_comment

begin_decl_stmt
name|char
name|intr_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Unix Interrupt*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|my_displayobj
init|=
literal|"K"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Initiator's Display Object Name*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|my_echo_obj
init|=
literal|"NI"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Initiator's Negotiation Control Object*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|my_signal_obj
init|=
literal|"KB"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Initiator's Signal Control Object*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|his_echo_obj
init|=
literal|"NA"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Acceptor's Negotiation Control Object*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|his_signal_obj
init|=
literal|"DI"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Acceptor's Signal Control Object*/
end_comment

begin_decl_stmt
name|int
name|my_right
init|=
name|INITIATOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|kb_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*KB Control Object Image*/
end_comment

begin_decl_stmt
name|char
name|di_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*DI Control Image*/
end_comment

begin_decl_stmt
name|char
name|ni_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NI Control Object Image*/
end_comment

begin_decl_stmt
name|char
name|na_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NA Control Object Image*/
end_comment

begin_decl_stmt
name|char
name|nego_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Current state of NI affected options*/
end_comment

begin_decl_stmt
name|char
name|sync_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*SY Control Object*/
end_comment

begin_decl_stmt
name|char
name|ga_image
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|transparent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Transparent Repertoire switch*/
end_comment

begin_decl_stmt
name|int
name|telnet_profile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_break
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*If VT-BREAK Functional Unit agreed to*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|myhostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|peerhost
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|PSAPaddr
name|ts_bound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Kludge for single map.c (sorry)*/
end_comment

begin_decl_stmt
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|toplevel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|peerdied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dispatch
block|{
name|char
modifier|*
name|ds_name
decl_stmt|;
name|IFP
name|ds_fnx
decl_stmt|;
name|int
name|ds_flags
decl_stmt|;
define|#
directive|define
name|DS_NULL
value|0x00
define|#
directive|define
name|DS_OPEN
value|0x01
comment|/* association required */
define|#
directive|define
name|DS_CLOSE
value|0x02
comment|/* association avoided */
name|char
modifier|*
name|ds_help
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|dispatch
modifier|*
name|getds
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|vt_open
argument_list|()
decl_stmt|,
name|vt_close
argument_list|()
decl_stmt|,
name|vt_quit
argument_list|()
decl_stmt|,
name|vt_status
argument_list|()
decl_stmt|,
name|vt_suspend
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vt_ayt
argument_list|()
decl_stmt|,
name|vt_break
argument_list|()
decl_stmt|,
name|vt_escape
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vt_set
argument_list|()
decl_stmt|,
name|vt_help
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dispatch
name|dispatches
index|[]
init|=
block|{
literal|"ayt"
block|,
name|vt_ayt
block|,
name|DS_OPEN
block|,
literal|"send \"are you there?\""
block|,
literal|"break"
block|,
name|vt_break
block|,
name|DS_OPEN
block|,
literal|"send break"
block|,
literal|"close"
block|,
name|vt_close
block|,
name|DS_OPEN
block|,
literal|"release association with terminal service"
block|,
literal|"escape"
block|,
name|vt_escape
block|,
name|DS_NULL
block|,
literal|"set escape character (depreciated)"
block|,
literal|"help"
block|,
name|vt_help
block|,
name|DS_NULL
block|,
literal|"print help information"
block|,
literal|"open"
block|,
name|vt_open
block|,
name|DS_CLOSE
block|,
literal|"associate with terminal service"
block|,
literal|"quit"
block|,
name|vt_quit
block|,
name|DS_NULL
block|,
literal|"release association with terminal service and exit"
block|,
literal|"set"
block|,
name|vt_set
block|,
name|DS_NULL
block|,
literal|"display or change variables"
block|,
literal|"status"
block|,
name|vt_status
block|,
name|DS_OPEN
block|,
literal|"show current status"
block|,
literal|"suspend"
block|,
name|vt_suspend
block|,
name|DS_OPEN
block|,
literal|"suspend vtp"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SFD
name|intr
argument_list|()
decl_stmt|,
name|deadpeer
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|control
argument_list|()
decl_stmt|,
modifier|*
name|strdup
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD44
end_ifdef

begin_decl_stmt
name|struct
name|termios
name|oterm
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|tchars
name|otc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ltchars
name|oltc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgttyb
name|ottyb
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|runcom
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myhome
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|tmode
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|LLog
name|_vt_log
init|=
block|{
literal|"./vt.log"
block|,
name|NULLCP
block|,
name|NULLCP
block|,
name|LLOG_NONE
block|,
name|LLOG_NONE
block|,
operator|-
literal|1
block|,
name|LLOGCLS
operator||
name|LLOGCRT
operator||
name|LLOGZER
block|,
name|NOTOK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LLog
modifier|*
name|vt_log
init|=
operator|&
name|_vt_log
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|fflag
decl_stmt|;
name|char
modifier|*
name|logname
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|NVEC
operator|+
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|myname
operator|=
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
condition|)
name|myname
operator|++
expr_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|||
operator|*
name|myname
operator|==
name|NULL
condition|)
name|myname
operator|=
operator|*
name|argv
expr_stmt|;
name|isodetailor
argument_list|(
name|myname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ll_hdinit
argument_list|(
name|vt_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|fflag
operator|=
literal|0
expr_stmt|;
name|logname
operator|=
literal|0
expr_stmt|;
name|myhostname
operator|=
name|PLocalHostName
argument_list|()
expr_stmt|;
name|peerhost
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|acc
operator|=
operator|&
name|accs
expr_stmt|;
name|acr
operator|=
operator|&
name|acrs
expr_stmt|;
name|aci
operator|=
operator|&
name|acis
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|oterm
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
name|erase_char
operator|=
name|oterm
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|erase_line
operator|=
name|oterm
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
name|intr_char
operator|=
name|oterm
operator|.
name|c_cc
index|[
name|VINTR
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ottyb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|otc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oltc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
name|erase_char
operator|=
name|ottyb
operator|.
name|sg_erase
expr_stmt|;
name|erase_line
operator|=
name|ottyb
operator|.
name|sg_kill
expr_stmt|;
name|intr_char
operator|=
name|otc
operator|.
name|t_intrc
expr_stmt|;
endif|#
directive|endif
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|vtp_profile
argument_list|,
sizeof|sizeof
name|vtp_profile
argument_list|)
expr_stmt|;
name|vtp_profile
operator|.
name|profile_name
operator|=
literal|"telnet"
expr_stmt|;
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
operator|=
name|ncols
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|peerhost
index|[
literal|0
index|]
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|argv
index|[
name|i
index|]
operator|!=
literal|'-'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|peerhost
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-g"
argument_list|)
condition|)
block|{
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|=
literal|0
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"using ASCII GO repertoire"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-D"
argument_list|)
condition|)
block|{
name|vtp_profile
operator|.
name|profile_name
operator|=
literal|"default"
expr_stmt|;
name|telnet_profile
operator|=
literal|0
expr_stmt|;
name|my_displayobj
operator|=
literal|"DISPLAY-OBJECT-2"
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"using default profile"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-B"
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"VT-BREAK not chosen"
argument_list|)
expr_stmt|;
name|do_break
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-f"
argument_list|)
condition|)
name|fflag
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-F"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|logname
operator|=
name|argv
index|[
operator|++
name|i
index|]
operator|)
operator|==
name|NULL
operator|||
operator|*
name|logname
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -F logfile"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|vt_log
operator|->
name|ll_file
operator|=
name|logname
expr_stmt|;
operator|(
name|void
operator|)
name|ll_close
argument_list|(
name|vt_log
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"logging to %s"
argument_list|,
name|logname
argument_list|)
expr_stmt|;
block|}
else|else
name|adios
argument_list|(
literal|"usage: %s [-g] [-D] [-B] [-f] [-F logfile] [hostname]"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
name|runcom
operator|=
literal|1
expr_stmt|;
name|rcinit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/.vtrc"
argument_list|,
name|myhome
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fflag
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|buffer
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vec
argument_list|,
sizeof|sizeof
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
if|if
condition|(
name|vtploop
argument_list|(
name|vec
argument_list|,
name|NOTOK
argument_list|)
operator|==
name|NOTOK
operator|&&
name|peerhost
index|[
literal|0
index|]
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|runcom
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peerhost
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|toplevel
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|do_vt
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|toplevel
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|command
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|DISPATCH */
end_comment

begin_macro
name|command
argument_list|(
argument|top
argument_list|)
end_macro

begin_decl_stmt
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|eof
decl_stmt|,
name|oldmode
decl_stmt|;
name|char
modifier|*
name|vec
index|[
name|NVEC
operator|+
literal|1
index|]
decl_stmt|;
name|oldmode
operator|=
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|eof
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"%s> "
argument_list|,
name|line
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|eof
condition|)
block|{
if|if
condition|(
operator|!
name|connected
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vt_status
argument_list|(
name|NULLVP
argument_list|)
expr_stmt|;
break|break;
block|}
name|eof
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|eof
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vec
argument_list|,
sizeof|sizeof
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2vec
argument_list|(
name|line
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
break|break;
if|if
condition|(
name|vtploop
argument_list|(
name|vec
argument_list|,
name|NOTOK
argument_list|)
operator|!=
name|DONE
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
operator|!
name|connected
condition|)
name|longjmp
argument_list|(
name|toplevel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tmode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|vtploop
parameter_list|(
name|vec
parameter_list|,
name|error
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
name|getds
argument_list|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
condition|?
operator|*
name|vec
else|:
literal|"help"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|connected
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_flags
operator|&
name|DS_OPEN
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"not associated with terminal service"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ds
operator|->
name|ds_flags
operator|&
name|DS_CLOSE
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"already associated with terminal service"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
switch|switch
condition|(
call|(
modifier|*
name|ds
operator|->
name|ds_fnx
call|)
argument_list|(
name|vec
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|error
return|;
case|case
name|OK
case|:
default|default:
return|return
name|OK
return|;
case|case
name|DONE
case|:
return|return
name|DONE
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|getline
parameter_list|(
name|prompt
parameter_list|,
name|buffer
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
specifier|static
name|int
name|sticky
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sticky
condition|)
block|{
name|sticky
operator|=
literal|0
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
name|prompt
argument_list|,
name|connected
condition|?
name|peerhost
else|:
name|myname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|buffer
operator|)
operator|+
name|BUFSIZ
operator|-
literal|1
init|;
operator|(
name|i
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buffer
condition|)
return|return
name|NOTOK
return|;
name|sticky
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|i
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|struct
name|dispatch
modifier|*
name|getds
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|longest
decl_stmt|,
name|nmatches
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|p
operator|=
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
return|return
name|ds
return|;
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|fs
operator|=
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|nmatches
condition|)
block|{
case|case
literal|0
case|:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown operation \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|1
case|:
return|return
name|fs
return|;
default|default:
for|for
control|(
name|ds
operator|=
name|dispatches
operator|,
name|p
operator|=
name|buffer
init|;
name|q
operator|=
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|longest
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|p
operator|!=
name|buffer
condition|?
literal|","
else|:
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"ambiguous operation, it could be one of:%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|OPERATIONS */
end_comment

begin_function
specifier|static
name|int
name|vt_open
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"host: "
argument_list|,
name|line
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vecX
argument_list|(
name|line
argument_list|,
name|vec
argument_list|,
literal|0
argument_list|,
name|NULLIP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|1
condition|)
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|peerhost
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
name|do_vt
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_macro
name|do_vt
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|deadpeer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Trying...\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|con_req
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return;
name|connected
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vt_status
argument_list|(
name|NULLVP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"escape character is '%s'\n"
argument_list|,
name|escapestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|peerdied
argument_list|)
operator|==
literal|0
condition|)
name|vt
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"association terminated by peer"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vt_close
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vrelreq
argument_list|()
expr_stmt|;
if|if
condition|(
name|getch
argument_list|()
operator|>=
operator|-
literal|1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"flushing input queue..."
argument_list|)
expr_stmt|;
while|while
condition|(
name|getch
argument_list|()
operator|>=
operator|-
literal|1
condition|)
continue|continue;
block|}
comment|/* read network events until the release sequence reached        the point where the other side shuts down      */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"association released\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|connected
operator|=
literal|0
expr_stmt|;
comment|/* reset his options */
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vt_quit
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
name|connected
condition|)
operator|(
name|void
operator|)
name|vt_close
argument_list|(
name|NULLVP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vt_status
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"associated with terminal service on \"%s\"\n  at %s\n"
argument_list|,
name|peerhost
argument_list|,
name|pa2str
argument_list|(
operator|&
name|ts_bound
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"  using %s profile\n"
argument_list|,
name|vtp_profile
operator|.
name|profile_name
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vt_suspend
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|save
decl_stmt|;
name|save
operator|=
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* reget parameters in case they were changed */
ifdef|#
directive|ifdef
name|BSD44
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|oterm
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ottyb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|otc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oltc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|tmode
argument_list|(
name|save
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|vt_escape
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"new escape character: "
argument_list|,
name|line
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|line
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|vec
index|[
literal|0
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|control
argument_list|(
name|escape
operator|=
name|c
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|escapestr
argument_list|)
expr_stmt|;
name|escapestr
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"escape character is '%s'\n"
argument_list|,
name|escapestr
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|VARIABLES */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debug_val
index|[]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bool
index|[]
init|=
block|{
literal|"off"
block|,
literal|"on"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|emodes
index|[]
init|=
block|{
literal|"local"
block|,
literal|"remote"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rmodes
index|[]
init|=
block|{
literal|"ascii"
block|,
literal|"transparent"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xsaplevels
index|[]
init|=
block|{
literal|"none"
block|,
literal|"fatal"
block|,
literal|"exceptions"
block|,
literal|"notice"
block|,
literal|"pdus"
block|,
literal|"trace"
block|,
literal|"debug"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|var
block|{
name|char
modifier|*
name|v_name
decl_stmt|;
name|IP
name|v_value
decl_stmt|;
name|char
modifier|*
name|v_dname
decl_stmt|;
name|char
modifier|*
modifier|*
name|v_dvalue
decl_stmt|;
name|char
modifier|*
name|v_mask
decl_stmt|;
name|IFP
name|v_hook
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|var
modifier|*
name|getvar
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|echo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|repertoire
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_debug
argument_list|()
decl_stmt|,
name|set_echo
argument_list|()
decl_stmt|,
name|set_escape
argument_list|()
decl_stmt|,
name|set_repertoire
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|var
name|vars
index|[]
init|=
block|{
literal|"acsaplevel"
block|,
operator|&
name|_acsap_log
operator|.
name|ll_events
block|,
literal|"ACSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"acsapfile"
block|,
name|NULLIP
block|,
literal|"ACSAP trace file"
block|,
operator|&
name|_acsap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"addrlevel"
block|,
operator|&
name|_addr_log
operator|.
name|ll_events
block|,
literal|"address logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"addrfile"
block|,
name|NULLIP
block|,
literal|"address trace file"
block|,
operator|&
name|_addr_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"compatlevel"
block|,
operator|&
name|_compat_log
operator|.
name|ll_events
block|,
literal|"COMPAT logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"compatfile"
block|,
name|NULLIP
block|,
literal|"COMPAT trace file"
block|,
operator|&
name|_compat_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"crmod"
block|,
operator|&
name|crmod
block|,
literal|"map CR on output"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"debug"
block|,
operator|&
name|debug
block|,
literal|"debug VT"
block|,
name|debug_val
block|,
name|NULLCP
block|,
name|set_debug
block|,
literal|"echo"
block|,
operator|&
name|echo
block|,
literal|"local or remote echoing"
block|,
name|emodes
block|,
name|NULLCP
block|,
name|set_echo
block|,
literal|"escape"
block|,
name|NULLIP
block|,
literal|"escape character"
block|,
operator|&
name|escapestr
block|,
name|NULLCP
block|,
name|set_escape
block|,
literal|"options"
block|,
operator|&
name|showoptions
block|,
literal|"show option processing"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"psaplevel"
block|,
operator|&
name|_psap_log
operator|.
name|ll_events
block|,
literal|"PSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"psapfile"
block|,
name|NULLIP
block|,
literal|"PSAP trace file"
block|,
operator|&
name|_psap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"psap2level"
block|,
operator|&
name|_psap2_log
operator|.
name|ll_events
block|,
literal|"PSAP2 logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"psap2file"
block|,
name|NULLIP
block|,
literal|"PSAP2 trace file"
block|,
operator|&
name|_psap2_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"repertoire"
block|,
operator|&
name|repertoire
block|,
literal|"terminal repertoire"
block|,
name|rmodes
block|,
name|NULLCP
block|,
name|set_repertoire
block|,
literal|"ssaplevel"
block|,
operator|&
name|_ssap_log
operator|.
name|ll_events
block|,
literal|"SSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"ssapfile"
block|,
name|NULLIP
block|,
literal|"SSAP trace file"
block|,
operator|&
name|_ssap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"tracelevel"
block|,
operator|&
name|_vt_log
operator|.
name|ll_events
block|,
literal|"VT logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"tracefile"
block|,
name|NULLIP
block|,
literal|"VT trace file"
block|,
operator|&
name|_vt_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"tsaplevel"
block|,
operator|&
name|_tsap_log
operator|.
name|ll_events
block|,
literal|"TSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"tsapfile"
block|,
name|NULLIP
block|,
literal|"TSAP trace file"
block|,
operator|&
name|_tsap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"verbose"
block|,
operator|&
name|verbose
block|,
literal|"verbose interaction"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|varwidth1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|varwidth2
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
modifier|*
name|getval
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|vt_set
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|value
decl_stmt|,
name|vflag
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
specifier|register
name|int
name|w
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|width
decl_stmt|,
name|lines
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|vars
init|;
name|u
operator|->
name|v_name
condition|;
name|u
operator|++
control|)
continue|continue;
name|width
operator|=
name|varwidth1
expr_stmt|;
if|if
condition|(
operator|(
name|columns
operator|=
name|ncols
argument_list|(
name|stdout
argument_list|)
operator|/
operator|(
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
operator|(
operator|(
name|u
operator|-
name|vars
operator|)
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Variables:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|v
operator|=
name|vars
operator|+
name|j
operator|*
name|lines
operator|+
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|+
name|lines
operator|>=
name|u
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|w
operator|=
name|strlen
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
init|;
name|w
operator|<
name|width
condition|;
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
return|return
name|DONE
return|;
block|}
name|echo
operator|=
operator|(
name|nego_state
operator|&
name|ECHO_OBJ
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|repertoire
operator|=
name|transparent
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|v
operator|=
name|vars
init|;
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
operator|(
name|v
operator|=
name|getvar
argument_list|(
operator|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|DONE
return|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_value
operator|&&
operator|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"use %s of:"
argument_list|,
name|v
operator|->
name|v_mask
condition|?
literal|"any"
else|:
literal|"one"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|printf
argument_list|(
literal|"%s \"%s\""
argument_list|,
name|i
operator|++
condition|?
literal|","
else|:
literal|""
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
name|printf
argument_list|(
literal|";\n\tor  \"all\";\n\tor a hexadecimal number from 0 to 0x%x\n"
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|";\n\tor a number from 0 to %d\n"
argument_list|,
name|cp
operator|-
name|v
operator|->
name|v_dvalue
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"use any %s value\n"
argument_list|,
name|v
operator|->
name|v_value
condition|?
literal|"integer"
else|:
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_value
operator|==
name|NULLIP
condition|)
block|{
specifier|register
name|int
name|w
decl_stmt|;
if|if
condition|(
operator|*
name|v
operator|->
name|v_dvalue
condition|)
name|free
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
expr_stmt|;
operator|*
name|v
operator|->
name|v_dvalue
operator|=
name|strdup
argument_list|(
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
operator|+
literal|2
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|=
operator|*
name|vec
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
operator|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
name|i
operator|<<=
literal|1
expr_stmt|;
name|value
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|=
operator|*
name|vec
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|dp
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
name|sscanf
argument_list|(
name|dp
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|value
argument_list|)
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|j
operator|=
name|sscanf
argument_list|(
operator|*
name|vec
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
name|i
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|i
condition|)
goto|goto
name|out_of_range
goto|;
block|}
else|else
block|{
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
continue|continue;
if|if
condition|(
name|value
operator|>=
name|cp
operator|-
name|v
operator|->
name|v_dvalue
condition|)
block|{
name|out_of_range
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"value out of range \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
block|}
block|}
name|vflag
operator|=
name|verbose
expr_stmt|;
operator|*
name|v
operator|->
name|v_value
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|getval
argument_list|(
operator|*
name|vec
argument_list|,
name|v
operator|->
name|v_dvalue
argument_list|)
operator|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"bad value \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
name|cp
operator|-
name|v
operator|->
name|v_dvalue
operator|)
operator|<=
literal|0
condition|)
continue|continue;
name|i
operator||=
literal|1
operator|<<
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|vflag
operator|=
name|verbose
expr_stmt|;
operator|*
name|v
operator|->
name|v_value
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_dvalue
operator|&&
operator|(
name|cp
operator|=
name|getval
argument_list|(
operator|*
name|vec
argument_list|,
name|v
operator|->
name|v_dvalue
argument_list|)
operator|)
condition|)
block|{
name|vflag
operator|=
name|verbose
expr_stmt|;
operator|*
name|v
operator|->
name|v_value
operator|=
name|cp
operator|-
name|v
operator|->
name|v_dvalue
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|v
operator|->
name|v_dvalue
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"bad value \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|printvar
argument_list|(
name|v
argument_list|)
specifier|register
expr|struct
name|var
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|runcom
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s = "
argument_list|,
name|varwidth1
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_value
condition|)
block|{
name|i
operator|=
operator|*
name|v
operator|->
name|v_value
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_dvalue
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|v
operator|->
name|v_dvalue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|sprintb
argument_list|(
name|i
argument_list|,
name|v
operator|->
name|v_mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|<=
name|varwidth2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n%*s"
argument_list|,
name|buffer
argument_list|,
name|varwidth1
operator|+
name|varwidth2
operator|+
literal|3
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"0x%-*x"
argument_list|,
name|varwidth2
operator|-
literal|2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|v
operator|->
name|v_dvalue
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|v
operator|->
name|v_dvalue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*d"
argument_list|,
name|varwidth2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|v
operator|->
name|v_dvalue
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\"%s\""
argument_list|,
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"    - %s\n"
argument_list|,
name|v
operator|->
name|v_dname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|set_debug
parameter_list|(
name|v
parameter_list|)
name|struct
name|var
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
name|ll_dbinit
argument_list|(
name|vt_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
else|else
name|vt_log
operator|->
name|ll_stat
operator|&=
operator|~
name|LLOGTTY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|set_echo
parameter_list|(
name|v
parameter_list|)
name|struct
name|var
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|connected
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"not associated with terminal service"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vt_echo
argument_list|(
name|echo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|set_escape
parameter_list|(
name|v
parameter_list|)
name|struct
name|var
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|escapestr
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|control
argument_list|(
name|escape
operator|=
operator|*
name|escapestr
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|escapestr
argument_list|)
expr_stmt|;
name|escapestr
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|set_repertoire
parameter_list|(
name|v
parameter_list|)
name|struct
name|var
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|connected
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"not associated with terminal service"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vt_repertoire
argument_list|(
name|repertoire
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|getval
parameter_list|(
name|name
parameter_list|,
name|choices
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|choices
decl_stmt|;
block|{
specifier|register
name|int
name|longest
decl_stmt|,
name|nmatches
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|fp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|choices
init|;
name|p
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
return|return
name|cp
return|;
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|nmatches
condition|)
block|{
case|case
literal|0
case|:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown value \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|1
case|:
return|return
name|fp
return|;
default|default:
for|for
control|(
name|cp
operator|=
name|choices
operator|,
name|p
operator|=
name|buffer
init|;
name|q
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|longest
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|p
operator|!=
name|buffer
condition|?
literal|","
else|:
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"ambiguous value, it could be one of:%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|var
modifier|*
name|getvar
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|longest
decl_stmt|,
name|nmatches
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|v
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
name|vars
init|;
name|p
operator|=
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
return|return
name|v
return|;
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|v
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|nmatches
condition|)
block|{
case|case
literal|0
case|:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown variable \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|1
case|:
return|return
name|f
return|;
default|default:
for|for
control|(
name|v
operator|=
name|vars
operator|,
name|p
operator|=
name|buffer
init|;
name|q
operator|=
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|longest
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|p
operator|!=
name|buffer
condition|?
literal|","
else|:
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"ambiguous variable, it could be one of:%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|HELP */
end_comment

begin_decl_stmt
specifier|static
name|int
name|helpwidth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vt_help
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|w
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|width
decl_stmt|,
name|lines
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|,
modifier|*
name|es
decl_stmt|;
for|for
control|(
name|es
operator|=
name|dispatches
init|;
name|es
operator|->
name|ds_name
condition|;
name|es
operator|++
control|)
continue|continue;
name|width
operator|=
name|helpwidth
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|columns
operator|=
name|ncols
argument_list|(
name|stdout
argument_list|)
operator|/
operator|(
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
operator|(
operator|(
name|es
operator|-
name|dispatches
operator|)
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Operations:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|ds
operator|=
name|dispatches
operator|+
name|j
operator|*
name|lines
operator|+
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|+
name|lines
operator|>=
name|es
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|w
operator|=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_name
argument_list|)
init|;
name|w
operator|<
name|width
condition|;
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
for|for
control|(
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s\t- %s\n"
argument_list|,
name|width
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|,
name|ds
operator|->
name|ds_help
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ds
operator|=
name|getds
argument_list|(
operator|*
name|vec
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-*s\t- %s\n"
argument_list|,
name|width
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|,
name|ds
operator|->
name|ds_help
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TIOCGWINSZ
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ncols
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|int
name|i
decl_stmt|;
name|struct
name|winsize
name|win
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
operator|!=
name|NOTOK
operator|&&
operator|(
name|i
operator|=
name|win
operator|.
name|ws_col
operator|)
operator|>
literal|0
condition|)
return|return
name|i
return|;
endif|#
directive|endif
return|return
literal|80
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|rcinit
argument_list|()
block|{
specifier|register
name|int
name|w
block|;
specifier|register
name|char
operator|*
operator|*
name|cp
block|;
specifier|register
expr|struct
name|dispatch
operator|*
name|ds
block|;
specifier|register
expr|struct
name|var
operator|*
name|v
block|;
if|if
condition|(
operator|(
name|myhome
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myhome
operator|=
literal|"."
expr_stmt|;
comment|/* could do passwd search... */
name|escapestr
operator|=
name|strdup
argument_list|(
name|control
argument_list|(
name|escape
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|ds
operator|=
name|dispatches
operator|,
name|helpwidth
operator|=
literal|0
init|;
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_name
argument_list|)
operator|)
operator|>
name|helpwidth
condition|)
name|helpwidth
operator|=
name|w
expr_stmt|;
end_for

begin_for
for|for
control|(
name|v
operator|=
name|vars
operator|,
name|varwidth1
operator|=
literal|0
init|;
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
operator|)
operator|>
name|varwidth1
condition|)
name|varwidth1
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_value
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|w
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
name|w
operator|<<=
literal|1
expr_stmt|;
name|w
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|sprintb
argument_list|(
name|w
argument_list|,
name|v
operator|->
name|v_mask
argument_list|)
argument_list|)
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
endif|#
directive|endif
block|}
else|else
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|v
operator|->
name|v_dvalue
condition|)
block|{
operator|*
name|v
operator|->
name|v_dvalue
operator|=
name|strdup
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
operator|+
literal|2
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
unit|}  char
name|sibuf
index|[
name|BUFSIZ
operator|<<
literal|3
index|]
operator|,
operator|*
name|sbp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|tibuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|tbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Select from tty and network...  */
end_comment

begin_macro
name|vt
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|tin
init|=
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|,
name|tout
init|=
name|fileno
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
name|int
name|nfds
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|nfds
operator|=
operator|(
name|tin
operator|>
name|tout
condition|?
name|tin
else|:
name|tout
operator|)
operator|)
operator|<
name|s
condition|)
name|nfds
operator|=
name|s
expr_stmt|;
name|nfds
operator|++
expr_stmt|;
name|nego_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|telnet_profile
condition|)
block|{
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|vt_rem_echo
argument_list|(
operator|&
name|ni_image
argument_list|)
expr_stmt|;
comment|/*Request Remote Echo*/
name|vt_sup_ga
argument_list|(
operator|&
name|ni_image
argument_list|)
expr_stmt|;
comment|/*Request Suppress Go Ahead*/
name|repertoire
operator|=
literal|1
expr_stmt|;
name|vt_repertoire
argument_list|(
name|repertoire
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fd_set
name|ibits
decl_stmt|,
name|obits
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|obits
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tout
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfrontp
operator|-
name|nbackp
condition|)
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
else|else
name|FD_SET
argument_list|(
name|tin
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfrontp
operator|-
name|tbackp
condition|)
name|FD_SET
argument_list|(
name|tout
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
else|else
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|s
argument_list|,
operator|&
name|ibits
argument_list|)
operator|&&
name|data_pending
argument_list|()
condition|)
block|{
name|FD_CLR
argument_list|(
name|s
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|result
operator|=
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
name|OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"xselect"
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
name|NOTOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"xselect"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|s
argument_list|,
operator|&
name|ibits
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|tin
argument_list|,
operator|&
name|ibits
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|s
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|tout
argument_list|,
operator|&
name|obits
argument_list|)
condition|)
block|{
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Something to read from the network... 		 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|s
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
operator|*
name|tfrontp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tfrontp
operator|>=
operator|&
name|ttyobuf
index|[
name|TBUFSIZ
operator|-
literal|1
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|E_EOF
condition|)
block|{
break|break;
block|}
block|}
comment|/* 		 * Something to read from the tty... 		 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tin
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|tcc
operator|=
name|read
argument_list|(
name|tin
argument_list|,
name|tibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tibuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|tcc
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tcc
operator|<=
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"error: read from terminal returned %d"
argument_list|,
name|tcc
argument_list|)
expr_stmt|;
break|break;
block|}
name|tbp
operator|=
name|tibuf
expr_stmt|;
block|}
block|}
while|while
condition|(
name|tcc
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|(
operator|&
name|netobuf
index|[
name|BUFSIZ
index|]
operator|-
name|nfrontp
operator|)
operator|<
literal|2
condition|)
break|break;
name|ch
operator|=
operator|*
name|tbp
operator|++
operator|&
literal|0377
operator|,
name|tcc
operator|--
expr_stmt|;
if|if
condition|(
name|strip
argument_list|(
name|ch
argument_list|)
operator|==
name|escape
condition|)
block|{
name|command
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|nfrontp
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|s
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|(
name|nfrontp
operator|-
name|nbackp
operator|)
operator|>
literal|0
condition|)
name|netflush
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tout
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|(
name|tfrontp
operator|-
name|tbackp
operator|)
operator|>
literal|0
condition|)
name|ttyflush
argument_list|(
name|tout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Construct a control character sequence  * for a special character.  */
end_comment

begin_function
name|char
modifier|*
name|control
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
return|return
operator|(
literal|"^?"
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|040
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'@'
operator|+
name|c
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|SFD
name|deadpeer
parameter_list|()
block|{
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|peerdied
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SFD
name|intr
parameter_list|()
block|{
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|toplevel
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|ttyflush
argument_list|(
argument|dd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|tfrontp
operator|-
name|tbackp
operator|)
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|write
argument_list|(
name|dd
argument_list|,
name|tbackp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"ttyflush(): Negative returned from write"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tbackp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|tbackp
operator|==
name|tfrontp
condition|)
name|tbackp
operator|=
name|tfrontp
operator|=
name|ttyobuf
expr_stmt|;
block|}
end_block

begin_macro
name|netflush
argument_list|(
argument|dd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nl_flag
decl_stmt|;
comment|/*If current PDU includes newline, follow it 				  with a Deliver Request*/
name|nl_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|nfrontp
operator|-
name|nbackp
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|transparent
condition|)
block|{
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|n
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|vtsend
argument_list|()
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|vdelreq
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|cp
expr_stmt|;
block|}
name|nbackp
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|nbackp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|rflag
operator|=
literal|1
expr_stmt|;
name|vt_newline
argument_list|()
expr_stmt|;
operator|++
name|nl_flag
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|rflag
condition|)
comment|/*If preceeding char was not CR*/
block|{
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|vt_newline
argument_list|()
expr_stmt|;
operator|++
name|nl_flag
expr_stmt|;
block|}
else|else
comment|/*Preceeding char was CR so already sent 				   the Update.  Remove this LF from buffer*/
block|{
operator|++
name|nbackp
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|telnet_profile
condition|)
block|{
name|rflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|erase_char
condition|)
block|{
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|vt_char_erase
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|erase_line
condition|)
block|{
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|vt_line_erase
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|intr_char
condition|)
block|{
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|vt_interrupt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
condition|)
comment|/*If ASCII GO, dump ctrl chars*/
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|<
literal|0x20
operator|)
operator|||
operator|(
operator|*
name|cp
operator|>
literal|0x7e
operator|)
condition|)
block|{
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
block|}
else|else
comment|/*Else Default Profile*/
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|<
literal|0x20
operator|)
operator|||
operator|(
operator|*
name|cp
operator|>
literal|0x7e
operator|)
condition|)
block|{
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
block|}
block|}
comment|/*End for loop*/
if|if
condition|(
name|j
condition|)
if|if
condition|(
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
operator|!=
name|OK
condition|)
comment|/*Load anything left if CR or LF 							wasn't last char in buffer*/
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vt_text failed"
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
name|j
expr_stmt|;
name|vtsend
argument_list|()
expr_stmt|;
comment|/*Send the whole NDQ*/
if|if
condition|(
name|nl_flag
operator|&&
name|telnet_profile
condition|)
name|vdelreq
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOBUFS
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|peerhost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|dd
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|peerdied
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|n
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nbackp
operator|==
name|nfrontp
condition|)
name|nbackp
operator|=
name|nfrontp
operator|=
name|netobuf
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|flushbufs
argument_list|()
end_macro

begin_block
block|{
name|tcc
operator|=
literal|0
expr_stmt|;
name|tbp
operator|=
name|tibuf
expr_stmt|;
name|nfrontp
operator|=
name|nbackp
operator|=
name|netobuf
expr_stmt|;
while|while
condition|(
name|getch
argument_list|()
operator|>
literal|0
condition|)
continue|continue;
name|tfrontp
operator|=
name|tbackp
operator|=
name|ttyobuf
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_function
name|void
name|finalbye
parameter_list|()
block|{
operator|(
name|void
operator|)
name|tmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|adios
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
specifier|static
name|int
name|latched
init|=
literal|0
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_ll_log
argument_list|(
name|vt_log
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|connected
operator|&&
name|latched
operator|++
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|vt_close
argument_list|(
name|NULLVP
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|,
name|flags
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
name|buffer
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|flags
operator|=
name|vt_log
operator|->
name|ll_stat
expr_stmt|;
if|if
condition|(
name|code
operator|&
operator|(
name|LLOG_FATAL
operator||
name|LLOG_EXCEPTIONS
operator||
name|LLOG_NOTICE
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|myname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|vt_log
operator|->
name|ll_stat
operator|&=
operator|~
name|LLOGTTY
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ll_log
argument_list|(
name|vt_log
argument_list|,
name|code
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|vt_log
operator|->
name|ll_stat
operator|=
name|flags
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS3 */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX -- why is this stubbed ? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD44
end_ifdef

begin_macro
name|ptyecho
argument_list|(
argument|on
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|setmode
argument_list|(
argument|on
argument_list|,
argument|off
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

