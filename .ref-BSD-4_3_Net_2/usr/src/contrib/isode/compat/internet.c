begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* internet.c - TCP/IP abstractions */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/compat/RCS/internet.c,v 7.3 91/02/22 09:15:14 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/compat/RCS/internet.c,v 7.3 91/02/22 09:15:14 mrose Interim $  *  *  * $Log:	internet.c,v $  * Revision 7.3  91/02/22  09:15:14  mrose  * Interim 6.8  *   * Revision 7.2  90/11/21  11:29:41  mrose  * sun  *   * Revision 7.1  90/01/11  18:35:06  mrose  * real-sync  *   * Revision 7.0  89/11/23  21:23:03  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|Berkeley UNIX: 4.2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SOCKETS
end_ifdef

begin_comment
comment|/* For real networking, nothing is better than 4BSD! */
end_comment

begin_function
name|int
name|start_tcp_client
parameter_list|(
name|sock
parameter_list|,
name|priv
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|sock
decl_stmt|;
name|int
name|priv
decl_stmt|;
block|{
specifier|register
name|int
name|port
decl_stmt|;
name|int
name|eindex
decl_stmt|,
name|sd
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD43
name|int
name|onoff
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"socket"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
goto|goto
name|got_socket
goto|;
for|for
control|(
name|port
operator|=
name|IPPORT_RESERVED
operator|-
name|priv
init|;
condition|;
name|priv
condition|?
name|port
operator|--
else|:
name|port
operator|++
control|)
block|{
name|sock
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
sizeof|sizeof
expr|*
name|sock
argument_list|)
operator|!=
name|NOTOK
condition|)
break|break;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EADDRINUSE
case|:
if|if
condition|(
operator|!
name|priv
operator|||
operator|(
name|port
operator|>=
name|IPPORT_RESERVED
operator|/
literal|2
operator|)
condition|)
continue|continue;
comment|/* else fall */
case|case
name|EADDRNOTAVAIL
case|:
default|default:
name|eindex
operator|=
name|errno
expr_stmt|;
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"bind"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|eindex
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
name|got_socket
label|:
empty_stmt|;
ifndef|#
directive|ifndef
name|BSD43
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set SO_KEEPALIVE"
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|onoff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
name|onoff
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set SO_KEEPALIVE"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|start_tcp_server
parameter_list|(
name|sock
parameter_list|,
name|backlog
parameter_list|,
name|opt1
parameter_list|,
name|opt2
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|sock
decl_stmt|;
name|int
name|backlog
decl_stmt|,
name|opt1
decl_stmt|,
name|opt2
decl_stmt|;
block|{
specifier|register
name|int
name|port
decl_stmt|;
name|int
name|eindex
decl_stmt|,
name|sd
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD43
name|int
name|onoff
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"socket"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|sock
operator|->
name|sin_port
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bind
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
sizeof|sizeof
expr|*
name|sock
argument_list|)
operator|!=
name|NOTOK
condition|)
goto|goto
name|got_socket
goto|;
name|eindex
operator|=
name|errno
expr_stmt|;
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"bind"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|eindex
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|port
operator|=
name|IPPORT_RESERVED
init|;
condition|;
name|port
operator|++
control|)
block|{
name|sock
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
sizeof|sizeof
expr|*
name|sock
argument_list|)
operator|!=
name|NOTOK
condition|)
break|break;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EADDRINUSE
case|:
continue|continue;
case|case
name|EADDRNOTAVAIL
case|:
default|default:
name|eindex
operator|=
name|errno
expr_stmt|;
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"bind"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|eindex
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
name|got_socket
label|:
empty_stmt|;
ifndef|#
directive|ifndef
name|BSD43
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set SO_KEEPALIVE"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt1
operator|&&
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt1
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set socket option 0x%x"
operator|,
name|opt1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt2
operator|&&
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt2
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set socket option 0x%x"
operator|,
name|opt2
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|onoff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
name|onoff
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set SO_KEEPALIVE"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt1
operator|&&
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
name|onoff
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set socket option 0x%x"
operator|,
name|opt1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt2
operator|&&
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
name|onoff
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"set socket option 0x%x"
operator|,
name|opt2
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|listen
argument_list|(
name|sd
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|join_tcp_client
parameter_list|(
name|fd
parameter_list|,
name|sock
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sock
decl_stmt|;
block|{
name|int
name|eindex
decl_stmt|,
name|len
init|=
sizeof|sizeof
expr|*
name|sock
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|accept
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|eindex
operator|=
name|errno
expr_stmt|;
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"accept"
operator|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|eindex
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|join_tcp_server
parameter_list|(
name|fd
parameter_list|,
name|sock
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sock
decl_stmt|;
block|{
name|int
name|eindex
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
sizeof|sizeof
expr|*
name|sock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|eindex
operator|=
name|errno
expr_stmt|;
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"connect"
operator|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|eindex
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|close_tcp_socket
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|never_do_this_if_from_join_tcp_client
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|AT&T UNIX: 5r3 using TLI */
end_comment

begin_comment
comment|/*
comment|AT&T UNIX: 5 with EXOS 8044 TCP/IP card */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXOS
end_ifdef

begin_comment
comment|/* If we had a getsockname() for the EXOS card, then we could postpone some    of the binding until connect time.  But since we don't, our hand is forced    and we must prematurely bind the sockets to IP addresses. */
end_comment

begin_macro
name|start_tcp_client
argument_list|(
argument|sock
argument_list|,
argument|priv
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|sock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|priv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|port
decl_stmt|;
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
return|return
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|SO_KEEPALIVE
argument_list|)
return|;
if|if
condition|(
name|sock
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
literal|"localhost"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|sock
operator|->
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|sock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|port
operator|=
name|IPPORT_RESERVED
operator|-
name|priv
init|;
condition|;
name|priv
condition|?
name|port
operator|--
else|:
name|port
operator|++
control|)
block|{
name|sock
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
name|SO_KEEPALIVE
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
return|return
name|sd
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EADDRINUSE
case|:
if|if
condition|(
operator|!
name|priv
operator|||
operator|(
name|port
operator|>=
name|IPPORT_RESERVED
operator|/
literal|2
operator|)
condition|)
continue|continue;
comment|/* else fall */
case|case
name|EADDRNOTAVAIL
case|:
default|default:
return|return
name|NOTOK
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|start_tcp_server
parameter_list|(
name|sock
parameter_list|,
name|backlog
parameter_list|,
name|opt1
parameter_list|,
name|opt2
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|sock
decl_stmt|;
name|int
name|backlog
decl_stmt|,
name|opt1
decl_stmt|,
name|opt2
decl_stmt|;
block|{
specifier|register
name|int
name|port
decl_stmt|;
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|backlog
operator|!=
literal|1
condition|)
return|return
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
name|SO_ACCEPTCONN
operator||
name|SO_KEEPALIVE
operator||
name|opt1
operator||
name|opt2
argument_list|)
return|;
if|if
condition|(
name|sock
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
literal|"localhost"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|sock
operator|->
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|sock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|port
operator|=
name|IPPORT_RESERVED
init|;
condition|;
name|port
operator|++
control|)
block|{
name|sock
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sock
argument_list|,
name|SO_ACCEPTCONN
operator||
name|SO_KEEPALIVE
operator||
name|opt1
operator||
name|opt2
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
return|return
name|sd
return|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EADDRINUSE
case|:
continue|continue;
case|case
name|EADDRNOTAVAIL
case|:
default|default:
return|return
name|NOTOK
return|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|GETHOSTENT PLUS */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|empty
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|h_addr
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|addrs
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|hostent
modifier|*
name|gethostbystring
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
ifndef|#
directive|ifndef
name|DG
specifier|static
name|u_long
name|iaddr
decl_stmt|;
else|#
directive|else
specifier|static
name|struct
name|in_addr
name|iaddr
decl_stmt|;
endif|#
directive|endif
specifier|static
name|struct
name|hostent
name|hs
decl_stmt|;
name|iaddr
operator|=
name|inet_addr
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DG
if|if
condition|(
name|iaddr
operator|==
name|NOTOK
condition|)
else|#
directive|else
if|if
condition|(
name|iaddr
operator|.
name|s_addr
operator|==
name|NOTOK
condition|)
endif|#
directive|endif
return|return
name|gethostbyname
argument_list|(
name|s
argument_list|)
return|;
name|h
operator|=
operator|&
name|hs
expr_stmt|;
name|h
operator|->
name|h_name
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|h_aliases
operator|=
operator|&
name|empty
expr_stmt|;
name|h
operator|->
name|h_addrtype
operator|=
name|AF_INET
expr_stmt|;
name|h
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
name|iaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|h_addr
name|h
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addrs
argument_list|,
sizeof|sizeof
name|addrs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|->
name|h_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|iaddr
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/*
comment|AT&T UNIX: 5 with EXOS 8044 TCP/IP card */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXOS
end_ifdef

begin_function_decl
name|long
name|rhost
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|raddr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|struct
name|hostent
modifier|*
name|gethostbyaddr
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|;
block|{
name|long
name|iaddr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|struct
name|hostent
name|hs
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|h
init|=
operator|&
name|hs
decl_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|||
name|type
operator|!=
name|AF_INET
condition|)
return|return
name|NULL
return|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|iaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|raddr
argument_list|(
name|iaddr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_name
operator|=
name|buffer
expr_stmt|;
name|h
operator|->
name|h_aliases
operator|=
operator|&
name|empty
expr_stmt|;
name|h
operator|->
name|h_addrtype
operator|=
name|type
expr_stmt|;
name|h
operator|->
name|h_length
operator|=
name|len
expr_stmt|;
name|h
operator|->
name|h_addr
operator|=
name|addr
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
name|struct
name|hostent
modifier|*
name|gethostbyname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|long
name|iaddr
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|struct
name|hostent
name|hs
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|h
init|=
operator|&
name|hs
decl_stmt|;
if|if
condition|(
operator|(
name|iaddr
operator|=
name|rhost
argument_list|(
operator|&
name|name
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_name
operator|=
name|buffer
expr_stmt|;
name|h
operator|->
name|h_aliases
operator|=
operator|&
name|empty
expr_stmt|;
name|h
operator|->
name|h_addrtype
operator|=
name|AF_INET
expr_stmt|;
name|h
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
name|iaddr
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|iaddr
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* really only need the "tsap" entry in this table... but why not? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|servent
name|services
index|[]
init|=
block|{
literal|"tsap"
block|,
name|NULL
block|,
literal|102
block|,
literal|"tcp"
block|,
literal|"miscellany"
block|,
name|NULL
block|,
literal|17000
block|,
literal|"lpp"
block|,
literal|"echo"
block|,
name|NULL
block|,
literal|7
block|,
literal|"tcp"
block|,
comment|/* Network standard functions */
literal|"echo"
block|,
name|NULL
block|,
literal|7
block|,
literal|"udp"
block|,
literal|"sink"
block|,
name|NULL
block|,
literal|9
block|,
literal|"tcp"
block|,
literal|"sink"
block|,
name|NULL
block|,
literal|9
block|,
literal|"udp"
block|,
literal|"users"
block|,
name|NULL
block|,
literal|11
block|,
literal|"tcp"
block|,
literal|"users"
block|,
name|NULL
block|,
literal|11
block|,
literal|"udp"
block|,
literal|"daytime"
block|,
name|NULL
block|,
literal|13
block|,
literal|"tcp"
block|,
literal|"daytime"
block|,
name|NULL
block|,
literal|13
block|,
literal|"udp"
block|,
literal|"netstat"
block|,
name|NULL
block|,
literal|15
block|,
literal|"tcp"
block|,
literal|"netstat"
block|,
name|NULL
block|,
literal|15
block|,
literal|"udp"
block|,
literal|"qotd"
block|,
name|NULL
block|,
literal|17
block|,
literal|"tcp"
block|,
literal|"qotd"
block|,
name|NULL
block|,
literal|17
block|,
literal|"udp"
block|,
literal|"chargen"
block|,
name|NULL
block|,
literal|19
block|,
literal|"tcp"
block|,
literal|"chargen"
block|,
name|NULL
block|,
literal|19
block|,
literal|"udp"
block|,
literal|"ftp"
block|,
name|NULL
block|,
literal|21
block|,
literal|"tcp"
block|,
literal|"telnet"
block|,
name|NULL
block|,
literal|23
block|,
literal|"tcp"
block|,
literal|"smtp"
block|,
name|NULL
block|,
literal|25
block|,
literal|"tcp"
block|,
literal|"imagen"
block|,
name|NULL
block|,
literal|35
block|,
literal|"udp"
block|,
literal|"time"
block|,
name|NULL
block|,
literal|37
block|,
literal|"tcp"
block|,
literal|"time"
block|,
name|NULL
block|,
literal|37
block|,
literal|"udp"
block|,
literal|"name"
block|,
name|NULL
block|,
literal|42
block|,
literal|"tcp"
block|,
literal|"name"
block|,
name|NULL
block|,
literal|42
block|,
literal|"udp"
block|,
literal|"whois"
block|,
name|NULL
block|,
literal|43
block|,
literal|"tcp"
block|,
literal|"whois"
block|,
name|NULL
block|,
literal|43
block|,
literal|"udp"
block|,
literal|"nameserver"
block|,
name|NULL
block|,
literal|53
block|,
literal|"tcp"
block|,
literal|"nameserver"
block|,
name|NULL
block|,
literal|53
block|,
literal|"udp"
block|,
literal|"mtp"
block|,
name|NULL
block|,
literal|57
block|,
literal|"tcp"
block|,
literal|"hostnames"
block|,
name|NULL
block|,
literal|101
block|,
literal|"tcp"
block|,
literal|"pop"
block|,
name|NULL
block|,
literal|109
block|,
literal|"tcp"
block|,
literal|"pwdgen"
block|,
name|NULL
block|,
literal|129
block|,
literal|"tcp"
block|,
literal|"pwdgen"
block|,
name|NULL
block|,
literal|129
block|,
literal|"udp"
block|,
literal|"x25bridge"
block|,
name|NULL
block|,
literal|146
block|,
literal|"tcp"
block|,
literal|"iso-ip"
block|,
name|NULL
block|,
literal|147
block|,
literal|"udp"
block|,
literal|"tftp"
block|,
name|NULL
block|,
literal|69
block|,
literal|"udp"
block|,
comment|/* Host specific functions */
literal|"rje"
block|,
name|NULL
block|,
literal|77
block|,
literal|"tcp"
block|,
literal|"nmui"
block|,
name|NULL
block|,
literal|77
block|,
literal|"udp"
block|,
literal|"finger"
block|,
name|NULL
block|,
literal|79
block|,
literal|"tcp"
block|,
literal|"finger"
block|,
name|NULL
block|,
literal|79
block|,
literal|"udp"
block|,
literal|"link"
block|,
name|NULL
block|,
literal|87
block|,
literal|"tcp"
block|,
literal|"supdup"
block|,
name|NULL
block|,
literal|95
block|,
literal|"tcp"
block|,
literal|"path"
block|,
name|NULL
block|,
literal|117
block|,
literal|"tcp"
block|,
literal|"exec"
block|,
name|NULL
block|,
literal|512
block|,
literal|"tcp"
block|,
comment|/* UNIX TCP sockets */
literal|"login"
block|,
name|NULL
block|,
literal|513
block|,
literal|"tcp"
block|,
literal|"shell"
block|,
name|NULL
block|,
literal|514
block|,
literal|"tcp"
block|,
literal|"printer"
block|,
name|NULL
block|,
literal|515
block|,
literal|"tcp"
block|,
literal|"rfile"
block|,
name|NULL
block|,
literal|522
block|,
literal|"tcp"
block|,
literal|"ingreslock"
block|,
name|NULL
block|,
literal|1524
block|,
literal|"tcp"
block|,
literal|"biff"
block|,
name|NULL
block|,
literal|512
block|,
literal|"udp"
block|,
comment|/* UNIX UDP sockets */
literal|"who"
block|,
name|NULL
block|,
literal|513
block|,
literal|"udp"
block|,
literal|"syslog"
block|,
name|NULL
block|,
literal|514
block|,
literal|"udp"
block|,
literal|"talk"
block|,
name|NULL
block|,
literal|517
block|,
literal|"udp"
block|,
literal|"routed"
block|,
name|NULL
block|,
literal|520
block|,
literal|"udp"
block|,
literal|"router_1"
block|,
name|NULL
block|,
literal|521
block|,
literal|"udp"
block|,
name|NULL
block|,
operator|&
name|empty
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|servent
modifier|*
name|getservbyname
parameter_list|(
name|name
parameter_list|,
name|proto
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|proto
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|servent
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|services
init|;
name|s
operator|->
name|s_name
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|s_name
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|proto
argument_list|,
name|s
operator|->
name|s_proto
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s_aliases
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|s_aliases
operator|=
operator|&
name|empty
expr_stmt|;
name|s
operator|->
name|s_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|s
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|s2a
parameter_list|(
name|b
parameter_list|)
value|(((int) (b))& 0xff)
end_define

begin_function
name|char
modifier|*
name|inet_ntoa
parameter_list|(
name|in
parameter_list|)
name|struct
name|in_addr
name|in
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|in
decl_stmt|;
specifier|static
name|char
name|addr
index|[
literal|4
operator|*
literal|3
operator|+
literal|3
operator|+
literal|1
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|s2a
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|s2a
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|s2a
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|s2a
argument_list|(
name|s
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_function
name|u_long
name|inet_addr
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|base
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|u_long
name|val
decl_stmt|;
name|u_long
name|parts
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|pp
init|=
name|parts
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|val
operator|=
literal|0
operator|,
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|8
operator|,
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'x'
operator|||
operator|*
name|cp
operator|==
literal|'X'
condition|)
name|base
operator|=
literal|16
operator|,
name|cp
operator|++
expr_stmt|;
for|for
control|(
init|;
name|isxdigit
argument_list|(
call|(
name|u_char
call|)
argument_list|(
name|c
operator|=
operator|*
name|cp
argument_list|)
argument_list|)
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|base
operator|==
literal|16
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
operator|(
name|c
operator|+
literal|10
operator|-
operator|(
name|islower
argument_list|(
operator|(
name|u_char
operator|)
name|c
argument_list|)
condition|?
literal|'a'
else|:
literal|'A'
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|c
argument_list|)
condition|)
name|val
operator|=
operator|(
name|val
operator|*
name|base
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
break|break;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|pp
operator|>=
name|parts
operator|+
literal|4
condition|)
return|return
name|NOTOK
return|;
operator|*
name|pp
operator|++
operator|=
name|val
operator|,
name|cp
operator|++
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
name|NOTOK
return|;
operator|*
name|pp
operator|++
operator|=
name|val
expr_stmt|;
break|break;
block|}
break|break;
block|}
switch|switch
condition|(
name|pp
operator|-
name|parts
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
name|parts
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
operator|(
operator|(
name|parts
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xffffff
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|val
operator|=
operator|(
operator|(
name|parts
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xffff
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|val
operator|=
operator|(
operator|(
name|parts
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|parts
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|NOTOK
return|;
block|}
return|return
name|htonl
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_function
name|u_long
name|inet_network
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|base
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|u_long
name|val
decl_stmt|;
name|u_long
name|parts
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|pp
init|=
name|parts
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|val
operator|=
literal|0
operator|,
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|8
operator|,
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'x'
operator|||
operator|*
name|cp
operator|==
literal|'X'
condition|)
name|base
operator|=
literal|16
operator|,
name|cp
operator|++
expr_stmt|;
for|for
control|(
init|;
name|isxdigit
argument_list|(
call|(
name|u_char
call|)
argument_list|(
name|c
operator|=
operator|*
name|cp
argument_list|)
argument_list|)
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|base
operator|==
literal|16
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
operator|(
name|c
operator|+
literal|10
operator|-
operator|(
name|islower
argument_list|(
operator|(
name|u_char
operator|)
name|c
argument_list|)
condition|?
literal|'a'
else|:
literal|'A'
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|c
argument_list|)
condition|)
name|val
operator|=
operator|(
name|val
operator|*
name|base
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
break|break;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|pp
operator|>=
name|parts
operator|+
literal|4
condition|)
return|return
name|NOTOK
return|;
operator|*
name|pp
operator|++
operator|=
name|val
operator|,
name|cp
operator|++
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
name|NOTOK
return|;
operator|*
name|pp
operator|++
operator|=
name|val
expr_stmt|;
break|break;
block|}
break|break;
block|}
switch|switch
condition|(
name|pp
operator|-
name|parts
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
operator|(
name|parts
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
operator|(
operator|(
name|parts
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|val
operator|=
operator|(
operator|(
name|parts
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
break|break;
case|case
literal|4
case|:
name|val
operator|=
operator|(
operator|(
name|parts
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|parts
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|parts
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|NOTOK
return|;
block|}
return|return
name|htonl
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

