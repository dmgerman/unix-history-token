begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* x25addr.c - X.25 level generic<-> interface address munging */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/compat/RCS/x25addr.c,v 7.6 91/02/22 09:16:14 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/compat/RCS/x25addr.c,v 7.6 91/02/22 09:16:14 mrose Interim $  *  * Contributed by George Michaelson, Julian Onions, and John Pavel  *  *  * $Log:	x25addr.c,v $  * Revision 7.6  91/02/22  09:16:14  mrose  * Interim 6.8  *   * Revision 7.5  91/01/14  13:33:56  mrose  * loader  *   * Revision 7.4  91/01/07  12:40:04  mrose  * update  *   * Revision 7.3  90/07/09  14:32:30  mrose  * sync  *   * Revision 7.2  89/12/11  16:21:42  mrose  * comments  *   * Revision 7.1  89/12/11  01:36:14  mrose  * SUN_X25_HACK  *   * Revision 7.0  89/11/23  21:23:49  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_comment
comment|/*  * for *really* generic address translation  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"tpkt.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * convert from the generic X25 structure to interface specific  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|CONN_DB
modifier|*
name|gen2if
parameter_list|(
name|generic
parameter_list|,
name|specific
parameter_list|,
name|context
parameter_list|)
name|struct
name|NSAPaddr
modifier|*
name|generic
decl_stmt|;
name|CONN_DB
modifier|*
name|specific
decl_stmt|;
name|int
name|context
decl_stmt|;
block|{
name|int
name|dtelen
decl_stmt|;
name|char
name|dte
index|[
name|NSAP_DTELEN
operator|+
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|CAMTEC_CCL
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|generic
operator|==
name|NULLNA
operator|||
name|specific
operator|==
operator|(
name|CONN_DB
operator|*
operator|)
literal|0
operator|||
name|generic
operator|->
name|na_stack
operator|!=
name|NA_X25
condition|)
return|return
operator|(
name|CONN_DB
operator|*
operator|)
literal|0
return|;
if|if
condition|(
name|x25_dnic_prefix
operator|&&
operator|*
name|x25_dnic_prefix
condition|)
block|{
comment|/* need DNIC on local calls? */
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|generic
operator|->
name|na_dte
argument_list|,
name|x25_dnic_prefix
argument_list|,
name|i
operator|=
name|strlen
argument_list|(
name|x25_dnic_prefix
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|x25_strip_dnic
condition|)
name|bcopy
argument_list|(
name|generic
operator|->
name|na_dte
operator|+
name|i
argument_list|,
name|dte
argument_list|,
name|dtelen
operator|=
name|generic
operator|->
name|na_dtelen
operator|-
name|i
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|generic
operator|->
name|na_dte
argument_list|,
name|dte
argument_list|,
name|dtelen
operator|=
name|generic
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x25_intl_zero
condition|)
block|{
name|bcopy
argument_list|(
name|generic
operator|->
name|na_dte
argument_list|,
name|dte
operator|+
literal|1
argument_list|,
name|dtelen
operator|=
name|generic
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
operator|*
name|dte
operator|=
literal|'0'
operator|,
name|dtelen
operator|++
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|generic
operator|->
name|na_dte
argument_list|,
name|dte
argument_list|,
name|dtelen
operator|=
name|generic
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|generic
operator|->
name|na_dte
argument_list|,
name|dte
argument_list|,
name|dtelen
operator|=
name|generic
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
name|dte
index|[
name|dtelen
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_X25_HACK
comment|/*	 	 * If your X.25 provider expects to receive the subaddress alone 	 * on listen requests, and you are using SunLink X.25, you may need 	 * to enable SUN_X25_HACK in your config file. This will allow you 	 * to use x25_local_dte in isotailor to specify a dte mask to be 	 * stripped when listening, and thus use full DTE strings in 	 * isoentities and QUIPU EDB files. You will also have to use the  	 * tsapd -a<dte> option to specify the listen address in 	 * /etc/rc.local and other tsapd startups since by default this equals 	 * x25_local_dte and thus will be masked to<null> unless overridden 	 * with full DTE + subaddress.  	 */
comment|/*  	 * in ADDR_LISTEN context, it may be neccessary to only listen 	 * on the sub-address, because certain PTT-provided networks 	 * remove the local DTE from incoming CR packets.  	 * 	 * SunLink X.25 listen asserts whatever DTE it is given as a simple 	 * string-compare, and will never receive inbound calls that bear 	 * only the sub-address if you assert the full DTE. 	 * 	 * this behaviour is orthogonal to any requirements to remove DNIC 	 * or add a leading 0 on outbound calls, and so needs a separate 	 * test. It uses tailor variable x25_local_dte to assert the local  	 * DTE *without* subaddress which should be tested for and stripped  	 * when detected.  	 */
if|if
condition|(
operator|(
name|context
operator|==
name|ADDR_LISTEN
operator|)
operator|&&
name|x25_local_dte
operator|&&
operator|*
name|x25_local_dte
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|generic
operator|->
name|na_dte
argument_list|,
name|x25_local_dte
argument_list|,
name|i
operator|=
name|strlen
argument_list|(
name|x25_local_dte
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|generic
operator|->
name|na_dte
operator|+
name|i
argument_list|,
name|dte
argument_list|,
name|dtelen
operator|=
name|generic
operator|->
name|na_dtelen
operator|-
name|i
argument_list|)
expr_stmt|;
name|dte
index|[
name|dtelen
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|DLOG
argument_list|(
name|x25_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"gen2if %s -> %s, %d octets; PID %s"
operator|,
name|generic
operator|->
name|na_dte
operator|,
name|dte
operator|,
name|dtelen
operator|,
name|sel2str
argument_list|(
name|generic
operator|->
name|na_pid
argument_list|,
operator|(
name|int
operator|)
name|generic
operator|->
name|na_pidlen
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CAMTEC_CCL
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|specific
argument_list|,
sizeof|sizeof
expr|*
name|specific
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UBC_X25
if|if
condition|(
operator|(
name|specific
operator|->
name|xaddr_len
operator|=
name|dtelen
operator|)
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|dte
argument_list|,
name|specific
operator|->
name|xaddr_addr
argument_list|,
name|dtelen
argument_list|)
expr_stmt|;
name|specific
operator|->
name|xaddr_len
operator|=
name|dtelen
expr_stmt|;
name|specific
operator|->
name|xaddr_facilities
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|generic
operator|->
name|na_pid
argument_list|,
name|specific
operator|->
name|xaddr_proto
argument_list|,
name|generic
operator|->
name|na_pidlen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|generic
operator|->
name|na_cudf
argument_list|,
name|specific
operator|->
name|xaddr_userdata
argument_list|,
name|generic
operator|->
name|na_cudflen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUN_X25
name|specific
operator|->
name|hostlen
operator|=
name|char2bcd
argument_list|(
name|dte
argument_list|,
name|specific
operator|->
name|host
argument_list|)
expr_stmt|;
comment|/* Zero PID */
if|if
condition|(
name|generic
operator|->
name|na_pidlen
condition|)
block|{
comment|/* non-null PID */
if|if
condition|(
name|generic
operator|->
name|na_pidlen
operator|>
name|NPSIZE
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"PID too long (%d> %d)"
operator|,
name|generic
operator|->
name|na_pidlen
operator|,
name|NPSIZE
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|CONN_DB
operator|*
operator|)
literal|0
return|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|specific
operator|->
name|data
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|generic
operator|->
name|na_pid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|specific
operator|->
name|data
argument_list|,
name|generic
operator|->
name|na_pidlen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|generic
operator|->
name|na_cudf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|specific
operator|->
name|data
operator|+
name|NPSIZE
argument_list|,
name|generic
operator|->
name|na_cudflen
argument_list|)
expr_stmt|;
name|specific
operator|->
name|datalen
operator|=
name|generic
operator|->
name|na_pidlen
operator|+
name|generic
operator|->
name|na_cudflen
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Null PID (just copy in CUDF, the first four octets of which 		will be the PID in any case) */
name|bcopy
argument_list|(
name|generic
operator|->
name|na_cudf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|specific
operator|->
name|data
argument_list|,
name|generic
operator|->
name|na_cudflen
argument_list|)
expr_stmt|;
name|specific
operator|->
name|datalen
operator|=
name|generic
operator|->
name|na_cudflen
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CAMTEC_CCL
switch|switch
condition|(
name|context
condition|)
block|{
case|case
name|ADDR_REMOTE
case|:
name|iov
operator|=
operator|&
operator|(
name|specific
operator|->
name|ccl_iovec
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|x25_outgoing_port
operator|==
literal|'#'
condition|)
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iov
operator|->
name|iov_len
operator|=
name|dtelen
operator|+
literal|4
expr_stmt|;
name|bzero
argument_list|(
name|iov
operator|->
name|iov_base
argument_list|,
name|iov
operator|->
name|iov_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|a
operator|=
name|iov
operator|->
name|iov_base
expr_stmt|;
name|b
operator|=
name|dte
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|'['
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtelen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
operator|*
name|a
operator|++
operator|=
literal|':'
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|14
condition|)
operator|*
name|a
operator|++
operator|=
literal|']'
expr_stmt|;
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|iov
operator|->
name|iov_len
operator|=
name|dtelen
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|dte
argument_list|,
operator|(
name|iov
operator|->
name|iov_base
operator|)
operator|+
literal|1
argument_list|,
name|dtelen
argument_list|)
expr_stmt|;
operator|*
operator|(
name|iov
operator|->
name|iov_base
operator|)
operator|=
name|x25_outgoing_port
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_LOCAL
case|:
name|iov
operator|=
operator|&
operator|(
name|specific
operator|->
name|ccl_iovec
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|strncpy
argument_list|(
name|iov
operator|->
name|iov_base
argument_list|,
name|generic
operator|->
name|na_dte
argument_list|,
name|generic
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_base
index|[
name|generic
operator|->
name|na_dtelen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|specific
operator|)
return|;
case|case
name|ADDR_LISTEN
case|:
name|iov
operator|=
operator|&
operator|(
name|specific
operator|->
name|ccl_iovec
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|generic
operator|->
name|na_pidlen
condition|)
block|{
comment|/* listen on a PID */
specifier|register
name|int
name|i
decl_stmt|;
name|iov
operator|->
name|iov_base
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
name|bcopy
argument_list|(
name|generic
operator|->
name|na_pid
argument_list|,
name|iov
operator|->
name|iov_base
operator|+
literal|1
argument_list|,
name|i
operator|=
name|generic
operator|->
name|na_pidlen
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|generic
operator|->
name|na_dtelen
operator|<
literal|6
condition|)
block|{
comment|/* listen on a subaddress */
specifier|register
name|int
name|i
decl_stmt|;
name|iov
operator|->
name|iov_base
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|bcopy
argument_list|(
name|generic
operator|->
name|na_dte
argument_list|,
name|iov
operator|->
name|iov_base
operator|+
literal|1
argument_list|,
name|i
operator|=
name|generic
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* full DTE */
name|bcopy
argument_list|(
name|dte
argument_list|,
name|iov
operator|->
name|iov_base
argument_list|,
name|iov
operator|->
name|iov_len
operator|=
name|dtelen
argument_list|)
expr_stmt|;
return|return
operator|(
name|specific
operator|)
return|;
block|}
comment|/*      * CUDF& PID must be merged. malloc initailly PIDsize space      * and bzero it. this may be UK net specific action which      * ensures we do NOT fall foul of listeners which use pid      * to match as well as "true" cudf& DTE.      */
operator|(
name|iov
operator|=
operator|&
operator|(
name|specific
operator|->
name|ccl_iovec
index|[
literal|2
index|]
operator|)
operator|)
operator|->
name|iov_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|generic
operator|->
name|na_faclen
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|generic
operator|->
name|na_fac
argument_list|,
name|iov
operator|->
name|iov_base
argument_list|,
name|iov
operator|->
name|iov_len
operator|=
name|min
argument_list|(
name|generic
operator|->
name|na_faclen
argument_list|,
name|FACSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|iov
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|iov
operator|->
name|iov_len
operator|=
name|generic
operator|->
name|na_pidlen
operator|)
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|generic
operator|->
name|na_pid
argument_list|,
name|iov
operator|->
name|iov_base
argument_list|,
name|generic
operator|->
name|na_pidlen
argument_list|)
expr_stmt|;
comment|/*      * if there is any other user data add that in now...      * actually cudf is a variable length field so this is      * all very suspect.      */
if|if
condition|(
name|generic
operator|->
name|na_cudflen
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|generic
operator|->
name|na_cudf
argument_list|,
name|iov
operator|->
name|iov_base
operator|+
name|iov
operator|->
name|iov_len
argument_list|,
name|generic
operator|->
name|na_cudflen
argument_list|)
operator|,
name|iov
operator|->
name|iov_len
operator|+=
name|generic
operator|->
name|na_cudflen
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|specific
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * convert from interface specific format to generic X.25 structure  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|struct
name|NSAPaddr
modifier|*
name|if2gen
parameter_list|(
name|generic
parameter_list|,
name|specific
parameter_list|,
name|context
parameter_list|)
name|struct
name|NSAPaddr
modifier|*
name|generic
decl_stmt|;
name|CONN_DB
modifier|*
name|specific
decl_stmt|;
name|int
name|context
decl_stmt|;
block|{
name|int
name|dtelen
decl_stmt|;
name|char
name|dte
index|[
name|NSAP_DTELEN
operator|+
literal|1
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|CAMTEC_CCL
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|generic
operator|==
name|NULLNA
operator|||
name|specific
operator|==
operator|(
name|CONN_DB
operator|*
operator|)
literal|0
condition|)
return|return
name|NULLNA
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|generic
argument_list|,
sizeof|sizeof
expr|*
name|generic
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dte
argument_list|,
sizeof|sizeof
name|dte
argument_list|)
expr_stmt|;
name|dtelen
operator|=
literal|0
expr_stmt|;
name|generic
operator|->
name|na_stack
operator|=
name|NA_X25
expr_stmt|;
name|generic
operator|->
name|na_community
operator|=
name|ts_comm_x25_default
expr_stmt|;
ifdef|#
directive|ifdef
name|UBC_X25
if|if
condition|(
name|specific
operator|->
name|xaddr_len
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|specific
operator|->
name|xaddr_addr
argument_list|,
name|dte
argument_list|,
name|specific
operator|->
name|xaddr_len
argument_list|)
expr_stmt|;
name|dtelen
operator|=
name|specific
operator|->
name|xaddr_len
expr_stmt|;
name|bcopy
argument_list|(
name|specific
operator|->
name|xaddr_proto
argument_list|,
name|generic
operator|->
name|na_pid
argument_list|,
sizeof|sizeof
argument_list|(
name|specific
operator|->
name|xaddr_proto
argument_list|)
argument_list|)
expr_stmt|;
name|generic
operator|->
name|na_pidlen
operator|=
sizeof|sizeof
name|specific
operator|->
name|xaddr_proto
expr_stmt|;
name|bcopy
argument_list|(
name|specific
operator|->
name|xaddr_userdata
argument_list|,
name|generic
operator|->
name|na_cudf
argument_list|,
sizeof|sizeof
argument_list|(
name|specific
operator|->
name|xaddr_userdata
argument_list|)
argument_list|)
expr_stmt|;
name|generic
operator|->
name|na_cudflen
operator|=
sizeof|sizeof
name|specific
operator|->
name|xaddr_userdata
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUN_X25
name|dtelen
operator|=
name|bcd2char
argument_list|(
name|specific
operator|->
name|host
argument_list|,
name|dte
argument_list|,
operator|(
name|int
operator|)
name|specific
operator|->
name|hostlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|specific
operator|->
name|datalen
operator|>
name|NPSIZE
condition|)
block|{
comment|/* have some real user data after the PID */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|specific
operator|->
name|data
argument_list|,
name|generic
operator|->
name|na_pid
argument_list|,
name|generic
operator|->
name|na_pidlen
operator|=
name|NPSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|specific
operator|->
name|data
operator|+
name|generic
operator|->
name|na_pidlen
argument_list|,
name|generic
operator|->
name|na_cudf
argument_list|,
name|generic
operator|->
name|na_cudflen
operator|=
name|specific
operator|->
name|datalen
operator|-
name|generic
operator|->
name|na_pidlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* PID only */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|specific
operator|->
name|data
argument_list|,
name|generic
operator|->
name|na_pid
argument_list|,
name|generic
operator|->
name|na_pidlen
operator|=
name|specific
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|generic
operator|->
name|na_cudflen
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CAMTEC_CCL
switch|switch
condition|(
name|context
condition|)
block|{
case|case
name|ADDR_REMOTE
case|:
name|iov
operator|=
operator|&
operator|(
name|specific
operator|->
name|ccl_iovec
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|iov
operator|->
name|iov_len
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|iov
operator|->
name|iov_base
operator|)
operator|==
literal|'#'
condition|)
block|{
name|char
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|iov
operator|->
name|iov_base
expr_stmt|;
while|while
condition|(
operator|*
name|a
operator|&&
name|iov
operator|->
name|iov_len
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|==
literal|']'
condition|)
block|{
name|iov
operator|->
name|iov_len
operator|--
expr_stmt|;
name|a
operator|++
expr_stmt|;
break|break;
block|}
name|iov
operator|->
name|iov_len
operator|--
expr_stmt|;
name|a
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|a
operator|==
literal|0
operator|||
name|iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
name|dtelen
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|dtelen
operator|=
name|iov
operator|->
name|iov_len
expr_stmt|;
name|bcopy
argument_list|(
name|a
argument_list|,
name|dte
argument_list|,
name|dtelen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dtelen
operator|=
name|iov
operator|->
name|iov_len
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|iov
operator|->
name|iov_base
operator|)
operator|+
literal|1
argument_list|,
name|dte
argument_list|,
name|dtelen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dtelen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ADDR_LOCAL
case|:
name|iov
operator|=
operator|&
operator|(
name|specific
operator|->
name|ccl_iovec
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|iov
operator|->
name|iov_len
condition|)
block|{
name|dtelen
operator|=
name|iov
operator|->
name|iov_len
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|iov
operator|->
name|iov_base
operator|)
operator|+
literal|1
argument_list|,
name|dte
argument_list|,
name|dtelen
argument_list|)
expr_stmt|;
block|}
else|else
name|dtelen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ADDR_LISTEN
case|:
return|return
name|NULLNA
return|;
block|}
if|if
condition|(
operator|(
name|iov
operator|=
operator|&
operator|(
name|specific
operator|->
name|ccl_iovec
index|[
literal|2
index|]
operator|)
operator|)
operator|->
name|iov_len
condition|)
name|bcopy
argument_list|(
name|iov
operator|->
name|iov_base
argument_list|,
name|generic
operator|->
name|na_fac
argument_list|,
name|generic
operator|->
name|na_faclen
operator|=
name|min
argument_list|(
name|iov
operator|->
name|iov_len
argument_list|,
name|FACSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|iov
operator|->
name|iov_len
condition|)
block|{
name|bcopy
argument_list|(
name|iov
operator|->
name|iov_base
argument_list|,
name|generic
operator|->
name|na_pid
argument_list|,
name|generic
operator|->
name|na_pidlen
operator|=
name|min
argument_list|(
name|iov
operator|->
name|iov_len
argument_list|,
name|NPSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iov
operator|->
name|iov_len
operator|>
name|NPSIZE
condition|)
name|bcopy
argument_list|(
name|iov
operator|->
name|iov_base
operator|+
name|NPSIZE
argument_list|,
name|generic
operator|->
name|na_cudf
argument_list|,
name|generic
operator|->
name|na_cudflen
operator|=
name|min
argument_list|(
name|iov
operator|->
name|iov_len
operator|-
name|NPSIZE
argument_list|,
name|CUDFSIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|x25_dnic_prefix
operator|&&
operator|*
name|x25_dnic_prefix
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x25_intl_zero
operator|&&
name|dte
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|dte
index|[
literal|1
index|]
operator|!=
literal|'0'
condition|)
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|x25_dnic_prefix
operator|&&
operator|*
name|x25_dnic_prefix
operator|&&
name|x25_strip_dnic
operator|&&
name|dtelen
operator|<
literal|12
condition|)
comment|/* local call... */
name|bcopy
argument_list|(
name|x25_dnic_prefix
argument_list|,
name|generic
operator|->
name|na_dte
argument_list|,
name|generic
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|x25_dnic_prefix
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dte
operator|+
name|i
argument_list|,
name|generic
operator|->
name|na_dte
operator|+
name|generic
operator|->
name|na_dtelen
argument_list|,
name|dtelen
operator|-
name|i
argument_list|)
expr_stmt|;
name|generic
operator|->
name|na_dtelen
operator|+=
name|dtelen
operator|-
name|i
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|dte
argument_list|,
name|generic
operator|->
name|na_dte
argument_list|,
name|generic
operator|->
name|na_dtelen
operator|=
name|dtelen
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|x25_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"if2gen %s -> %s, %d octets; PID %s"
operator|,
name|dte
operator|,
name|generic
operator|->
name|na_dte
operator|,
name|generic
operator|->
name|na_dtelen
operator|,
name|sel2str
argument_list|(
name|generic
operator|->
name|na_pid
argument_list|,
operator|(
name|int
operator|)
name|generic
operator|->
name|na_pidlen
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|generic
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|elucidate_x25_err
argument_list|(
argument|flags
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|RECV_DIAG
operator|)
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
operator|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|DIAG_TYPE
operator|)
operator|)
condition|?
literal|"cleared 0x%02x"
else|:
literal|"reset 0x%02x"
operator|,
name|pkt
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|)
operator|&
operator|(
literal|1
operator|<<
name|DIAG_TYPE
operator|)
condition|)
comment|/* cleared */
switch|switch
condition|(
name|pkt
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x00
case|:
name|cp
operator|=
literal|"DTE Clearing"
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|cp
operator|=
literal|"Number Busy"
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
name|cp
operator|=
literal|"Out of Order"
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|cp
operator|=
literal|"Remote Procedure Error"
expr_stmt|;
break|break;
case|case
literal|0x19
case|:
name|cp
operator|=
literal|"Reverse Charging not subscribed"
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|cp
operator|=
literal|"Invalid Facility Request"
expr_stmt|;
break|break;
case|case
literal|0x0B
case|:
name|cp
operator|=
literal|"Access Barred"
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|cp
operator|=
literal|"Local Procedure Error"
expr_stmt|;
break|break;
case|case
literal|0x05
case|:
name|cp
operator|=
literal|"Network Congestion"
expr_stmt|;
break|break;
case|case
literal|0x0D
case|:
name|cp
operator|=
literal|"Not Obtainable"
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
name|cp
operator|=
literal|"DTE Incompatible Call"
expr_stmt|;
break|break;
case|case
literal|0x29
case|:
name|cp
operator|=
literal|"Fast Select Acceptance not Subscribed"
expr_stmt|;
break|break;
default|default:
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"clearing cause 0x2%x"
operator|,
name|pkt
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
else|else
comment|/* reset */
switch|switch
condition|(
name|pkt
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x00
case|:
name|cp
operator|=
literal|"DTE Reset"
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|cp
operator|=
literal|"Out of Order (PVC Only)"
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|cp
operator|=
literal|"Remote Procedure Error"
expr_stmt|;
break|break;
case|case
literal|0x05
case|:
name|cp
operator|=
literal|"Local Procedure Error"
expr_stmt|;
break|break;
case|case
literal|0x07
case|:
name|cp
operator|=
literal|"Network Congestion"
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
name|cp
operator|=
literal|"Remote DTE Operational (PVC Only)"
expr_stmt|;
break|break;
case|case
literal|0x0F
case|:
name|cp
operator|=
literal|"Network Operational (PVC Only"
expr_stmt|;
break|break;
default|default:
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"resetting cause 0x%2x"
operator|,
name|pkt
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"%s%s"
operator|,
operator|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|DIAG_TYPE
operator|)
operator|)
condition|?
literal|"clearing cause "
else|:
literal|"resetting cause "
operator|,
name|cp
operator|)
argument_list|)
expr_stmt|;
name|next
label|:
empty_stmt|;
comment|/* The following may only be applicable to PSS in the UK */
comment|/* In any case, if someone is keen, they can stuff it all 	   into a text file and read it out */
switch|switch
condition|(
name|pkt
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0x00
case|:
name|cp
operator|=
literal|"NO ADDITIONAL INFORMATION"
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|cp
operator|=
literal|"INVALID P(S)\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|cp
operator|=
literal|"INVALID P(R)\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE r1\tRESTART"
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE r2\tRESTART"
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE r3\tRESTART"
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE p1\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x15
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE p2\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x16
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE p3\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x17
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE p4\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE p5\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x19
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE p6\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x1A
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE p7\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x1B
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE d1\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x1C
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE d2\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x1D
case|:
name|cp
operator|=
literal|"PACKET TYPE INVALID FOR STATE d3\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|cp
operator|=
literal|"PACKET NOT ALLOWED"
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
name|cp
operator|=
literal|"UNIDENTIFIABLE PACKET"
expr_stmt|;
break|break;
case|case
literal|0x22
case|:
name|cp
operator|=
literal|"CALL ON ONE-WAY LOGICAL CHANNEL\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x23
case|:
name|cp
operator|=
literal|"INVALID PACKET TYPE ON PVC\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x24
case|:
name|cp
operator|=
literal|"PACKET ON UNASSIGNED LCN\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x25
case|:
name|cp
operator|=
literal|"REJECT NOT SUBSCRIBED TO\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x26
case|:
name|cp
operator|=
literal|"PACKET TOO SHORT\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x27
case|:
name|cp
operator|=
literal|"PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x28
case|:
name|cp
operator|=
literal|"INVALID GFI\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x29
case|:
name|cp
operator|=
literal|"RESTART WITH NON-ZERO BITS 5-16"
expr_stmt|;
break|break;
case|case
literal|0x2A
case|:
name|cp
operator|=
literal|"PACKET TYPE NOT COMPATIBLE WITH FACILITY\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x2B
case|:
name|cp
operator|=
literal|"UNAUTHORISED INTERRUPT CONF\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x2C
case|:
name|cp
operator|=
literal|"UNAUTHORISED INTERRUPT\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x31
case|:
name|cp
operator|=
literal|"TIMER EXPIRED;  INCOMING CALL"
expr_stmt|;
break|break;
case|case
literal|0x32
case|:
name|cp
operator|=
literal|"TIMER EXPIRED;\tCLEAR INDICATION"
expr_stmt|;
break|break;
case|case
literal|0x33
case|:
name|cp
operator|=
literal|"TIMER EXPIRED;\tRESET INDICATION"
expr_stmt|;
break|break;
case|case
literal|0x34
case|:
name|cp
operator|=
literal|"TIMER EXPIRED;\tRESTART IND"
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|cp
operator|=
literal|"UNSPECIFIED CALL SET-UP PROBLEM CLEAR"
expr_stmt|;
break|break;
case|case
literal|0x41
case|:
name|cp
operator|=
literal|"FACILITY CODE NOT ALLOWED\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x42
case|:
name|cp
operator|=
literal|"FACILITY PARAMETER NOT ALLOWED\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x43
case|:
name|cp
operator|=
literal|"INVALID CALLED ADDRESS\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x44
case|:
name|cp
operator|=
literal|"INVALID CALLING ADDRESS\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0x90
case|:
name|cp
operator|=
literal|"DTE/DCE CONGESTION\tRESET"
expr_stmt|;
break|break;
case|case
literal|0x91
case|:
name|cp
operator|=
literal|"RECEIVED FAST SELECT CLEAR REQUEST"
expr_stmt|;
break|break;
case|case
literal|0x92
case|:
name|cp
operator|=
literal|"LINE RESTARTING BY INMC COMMAND\tRESTART"
expr_stmt|;
break|break;
case|case
literal|0xA0
case|:
name|cp
operator|=
literal|"NON-ZERO RESET CAUSE FROM DTE\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA1
case|:
name|cp
operator|=
literal|"DATA PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA2
case|:
name|cp
operator|=
literal|"INTERRUPT PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA3
case|:
name|cp
operator|=
literal|"INT PACKET TOO SHORT; NO USER DATA\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA4
case|:
name|cp
operator|=
literal|"INT CONFIRMATION PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA5
case|:
name|cp
operator|=
literal|"RR PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA6
case|:
name|cp
operator|=
literal|"RNR PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA7
case|:
name|cp
operator|=
literal|"RESET PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA8
case|:
name|cp
operator|=
literal|"RESET CONF PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xA9
case|:
name|cp
operator|=
literal|"INVALID `Q' BIT IN DATA PACKET\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xAA
case|:
name|cp
operator|=
literal|"PACKET WINDOW RANGE EXCEEDED\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xAB
case|:
name|cp
operator|=
literal|"UNABLE TO TRANSMIT PACKET\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xAC
case|:
name|cp
operator|=
literal|"diagnostic `Q' BIT SET IN NON-DATA PACKET\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xAD
case|:
name|cp
operator|=
literal|"OUTSTANDING PACKET COUNT LESS THAN ZERO\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xAE
case|:
name|cp
operator|=
literal|"RETRANSMISSION ERROR\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xAF
case|:
name|cp
operator|=
literal|"RESET PACKET TOO SHORT (NO CAUSE)\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xB0
case|:
name|cp
operator|=
literal|"REJECT PACKET TOO LONG\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xB1
case|:
name|cp
operator|=
literal|"INVALID 1D PACKET\tRESET"
expr_stmt|;
break|break;
case|case
literal|0xB2
case|:
name|cp
operator|=
literal|"UNSUCCESSFUL RECONNECTION RESNC\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xB3
case|:
name|cp
operator|=
literal|"NON-RECONNECT CALL IN STATE C1\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xB4
case|:
name|cp
operator|=
literal|"SECOND 1D PACKET FROM DTE\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xB5
case|:
name|cp
operator|=
literal|"BAD DATA TRANSFER STATE IN RECONNECT\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xB6
case|:
name|cp
operator|=
literal|"PACKET FORMAT INVALID\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xB7
case|:
name|cp
operator|=
literal|"FACILITY BYTE COUNT TOO LARGE\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xB8
case|:
name|cp
operator|=
literal|"INVALID PACKET DETECTED\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xB9
case|:
name|cp
operator|=
literal|"FACILITY/UTILITY FIELD BYTE COUNT> 63\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xBA
case|:
name|cp
operator|=
literal|"OUTGOING CALLS BARRED\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xBB
case|:
name|cp
operator|=
literal|"INCOMING CALLS BARRED\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xBC
case|:
name|cp
operator|=
literal|"CLEARING OF PVC\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xBD
case|:
name|cp
operator|=
literal|"CALLED ADDRESS TOO LONG\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xBE
case|:
name|cp
operator|=
literal|"CALLED ADDRESS TOO SHORT\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xBF
case|:
name|cp
operator|=
literal|"CALLING ADDRESS TOO LONG\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC0
case|:
name|cp
operator|=
literal|"CALLING ADDRESS TOO SHORT\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC1
case|:
name|cp
operator|=
literal|"BCD ERROR IN CALL ADDRESS\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC2
case|:
name|cp
operator|=
literal|"BCD ERROR IN CALLING ADDRESS\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC3
case|:
name|cp
operator|=
literal|"USER DATA FIELD TOO LONG\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC4
case|:
name|cp
operator|=
literal|"NO BUFFER AVAILABLE\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC5
case|:
name|cp
operator|=
literal|"LOCAL DTE IS NOT ENHANCED\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC6
case|:
name|cp
operator|=
literal|"FACILITY NEGOTIATION INVALID\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC7
case|:
name|cp
operator|=
literal|"MANDATORY UTILITY NOT INPUT\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC8
case|:
name|cp
operator|=
literal|"BUFFER NO AVAILABLE FOR TNIC\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xC9
case|:
name|cp
operator|=
literal|"OVERFLOW OF TNIC IN BUFFER\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xCA
case|:
name|cp
operator|=
literal|"DTE LINE CONGESTED\tCLEAR"
expr_stmt|;
break|break;
case|case
literal|0xCB
case|:
name|cp
operator|=
literal|"TABLE ERROR IN PACKET PROCEDURES"
expr_stmt|;
break|break;
case|case
literal|0xCC
case|:
name|cp
operator|=
literal|"INSERT TABLE OVERFLOW"
expr_stmt|;
break|break;
case|case
literal|0xCD
case|:
name|cp
operator|=
literal|"DELETE TABLE OVERFLOW"
expr_stmt|;
break|break;
case|case
literal|0xD0
case|:
name|cp
operator|=
literal|"TRUNK LINE RESTART\tRESTART"
expr_stmt|;
break|break;
case|case
literal|0xD1
case|:
name|cp
operator|=
literal|"INVALID EVENT IN STATE p2"
expr_stmt|;
break|break;
case|case
literal|0xD2
case|:
name|cp
operator|=
literal|"INVALID EVENT IN STATE p3"
expr_stmt|;
break|break;
case|case
literal|0xD3
case|:
name|cp
operator|=
literal|"INVALID 1D EVENT IN STATE d1"
expr_stmt|;
break|break;
case|case
literal|0xD4
case|:
name|cp
operator|=
literal|"CALL COLLISION ON TRUNK LINE"
expr_stmt|;
break|break;
case|case
literal|0xD5
case|:
name|cp
operator|=
literal|"NO BUFFER AVAILABLE"
expr_stmt|;
break|break;
case|case
literal|0xD6
case|:
name|cp
operator|=
literal|"CALL COLLISION ON DTE LINE"
expr_stmt|;
break|break;
case|case
literal|0xD7
case|:
name|cp
operator|=
literal|"DTE RESTART"
expr_stmt|;
break|break;
case|case
literal|0xD8
case|:
name|cp
operator|=
literal|"CALL REQUEST TO TRUNK LINE TIMEOUT"
expr_stmt|;
break|break;
case|case
literal|0xD9
case|:
name|cp
operator|=
literal|"RECONNECT SET-UP TIMED OUT"
expr_stmt|;
break|break;
case|case
literal|0xDA
case|:
name|cp
operator|=
literal|"INVALID OUTPUT SIDE STATE"
expr_stmt|;
break|break;
case|case
literal|0xDB
case|:
name|cp
operator|=
literal|"ERROR DETECTED IN BLINK PACKET QUEUE PROCEDURE"
expr_stmt|;
break|break;
case|case
literal|0xDC
case|:
name|cp
operator|=
literal|"RESET INDICATION RETRANSMISSION COUNT EXPIRED"
expr_stmt|;
break|break;
case|case
literal|0xDD
case|:
name|cp
operator|=
literal|"INVALID OUTPUT SIDE STATE"
expr_stmt|;
break|break;
case|case
literal|0xDE
case|:
name|cp
operator|=
literal|"BLIND BUFFER QUEUE OVERFLOW IN STATE d4"
expr_stmt|;
break|break;
case|case
literal|0xDF
case|:
name|cp
operator|=
literal|"BLIND BUFFER QUEUE OVERFLOW IN STATE c1"
expr_stmt|;
break|break;
case|case
literal|0xE0
case|:
name|cp
operator|=
literal|"BLIND BUFFER QUEUE OVERFLOW IN STATE c2"
expr_stmt|;
break|break;
case|case
literal|0xE1
case|:
name|cp
operator|=
literal|"CLEAR PACKET BYTE COUNT TOO LARGE OR TOO SMALL"
expr_stmt|;
break|break;
case|case
literal|0xE2
case|:
name|cp
operator|=
literal|"NON-ZERO\tCLEAR CAUSE"
expr_stmt|;
break|break;
case|case
literal|0xE3
case|:
name|cp
operator|=
literal|"CLEAR CONF PACKET BYTE COUNT TOO SMALL OR TOO LARGE"
expr_stmt|;
break|break;
case|case
literal|0xE4
case|:
name|cp
operator|=
literal|"CALL COLLISION"
expr_stmt|;
break|break;
case|case
literal|0xE5
case|:
name|cp
operator|=
literal|"INVALID TP LOAD REQUEST CALL PKT"
expr_stmt|;
break|break;
case|case
literal|0xE6
case|:
name|cp
operator|=
literal|"MAXIMUM HOPCOUNT EXCEEDED"
expr_stmt|;
break|break;
case|case
literal|0xE7
case|:
name|cp
operator|=
literal|"ROUTING LOOP DETECTED"
expr_stmt|;
break|break;
case|case
literal|0xE8
case|:
name|cp
operator|=
literal|"PVC CALL REQUEST FAILURE"
expr_stmt|;
break|break;
case|case
literal|0xE9
case|:
name|cp
operator|=
literal|"RECONNECT CALL REQUEST FAILED"
expr_stmt|;
break|break;
case|case
literal|0xEA
case|:
name|cp
operator|=
literal|"NO LC AVAILABLE ON OUTPUT SIDE"
expr_stmt|;
break|break;
case|case
literal|0xEB
case|:
name|cp
operator|=
literal|"NO BUFFER AVAILABLE"
expr_stmt|;
break|break;
case|case
literal|0xEC
case|:
name|cp
operator|=
literal|"CALL REDIRECTION CLEAR"
expr_stmt|;
break|break;
case|case
literal|0xED
case|:
name|cp
operator|=
literal|"NO PATH ROUTE CALL"
expr_stmt|;
break|break;
case|case
literal|0xEE
case|:
name|cp
operator|=
literal|"CALL ROUTED TO DTE LINE"
expr_stmt|;
break|break;
case|case
literal|0xEF
case|:
name|cp
operator|=
literal|"CALL CANNOT BE REROUTED"
expr_stmt|;
break|break;
case|case
literal|0xF0
case|:
name|cp
operator|=
literal|"ADDRESS NOT IN ROUTING TABLES"
expr_stmt|;
break|break;
case|case
literal|0xF1
case|:
name|cp
operator|=
literal|"ROUTING TABLE CHANGE DURING CALL ROUTING"
expr_stmt|;
break|break;
case|case
literal|0xF2
case|:
name|cp
operator|=
literal|"NO LC AVAILABLE ON FAKE TRUNK"
expr_stmt|;
break|break;
case|case
literal|0xF3
case|:
name|cp
operator|=
literal|"REMOTE DTE DOWN ON A PVC"
expr_stmt|;
break|break;
case|case
literal|0xF4
case|:
name|cp
operator|=
literal|"INVALID EVENT DETECTED"
expr_stmt|;
break|break;
case|case
literal|0xF5
case|:
name|cp
operator|=
literal|"INVALID PACKET RECEIVED; STATE d4"
expr_stmt|;
break|break;
case|case
literal|0xF6
case|:
name|cp
operator|=
literal|"INVALID PACKET RECEIVED; STATE d5"
expr_stmt|;
break|break;
case|case
literal|0xF7
case|:
name|cp
operator|=
literal|"INVALID PACKET RECEIVED; STATE p8"
expr_stmt|;
break|break;
case|case
literal|0xF8
case|:
name|cp
operator|=
literal|"INTERNAL PROCESSING FAILURE"
expr_stmt|;
break|break;
case|case
literal|0xF9
case|:
name|cp
operator|=
literal|"INVALID RESTART INDICATION"
expr_stmt|;
break|break;
case|case
literal|0xFA
case|:
name|cp
operator|=
literal|"LINE STATUS CHANGE IN STATE r4"
expr_stmt|;
break|break;
case|case
literal|0xFB
case|:
name|cp
operator|=
literal|"INVALID PACKET RECEIVED; STATE r4"
expr_stmt|;
break|break;
case|case
literal|0xFC
case|:
name|cp
operator|=
literal|"INVALID PACKET RECEIVED; STATE r3"
expr_stmt|;
break|break;
case|case
literal|0xFD
case|:
name|cp
operator|=
literal|"LINE STATUS CHANGE IN STATE r2"
expr_stmt|;
break|break;
case|case
literal|0xFE
case|:
name|cp
operator|=
literal|"LINE STATUS CHANGE IN STATE r1"
expr_stmt|;
break|break;
case|case
literal|0xFF
case|:
name|cp
operator|=
literal|"LINE STATUS CHANGE IN STATE r0"
expr_stmt|;
break|break;
default|default:
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"diagnostic: 0x%2x"
operator|,
name|pkt
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"diagnostic %s"
operator|,
name|cp
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Not RECV_DIAG */
if|if
condition|(
name|flags
condition|)
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"diag flags: 0x%02x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|done
label|:
empty_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_X25
end_ifdef

begin_function
specifier|static
name|int
name|char2bcd
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|c
operator|-=
literal|'a'
operator|+
literal|0x0a
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|c
operator|-=
literal|'A'
operator|+
literal|0x0a
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
operator|*
name|d
operator|++
operator||=
name|c
operator|&
literal|0xf
expr_stmt|;
else|else
operator|*
name|d
operator|=
operator|(
name|c
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|bcd2char
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|len
parameter_list|)
specifier|register
name|u_char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|g
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|g
operator|=
name|s
index|[
name|i
operator|>>
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|g
operator|>>=
literal|4
expr_stmt|;
name|g
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|g
operator|<
literal|0x0a
condition|)
operator|*
name|d
operator|++
operator|=
name|g
operator|+
literal|'0'
expr_stmt|;
else|else
operator|*
name|d
operator|++
operator|=
name|g
operator|+
literal|'a'
operator|-
literal|0x0a
expr_stmt|;
block|}
operator|*
name|d
operator|=
name|NULL
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|_x25addr_stub
parameter_list|()
block|{}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

