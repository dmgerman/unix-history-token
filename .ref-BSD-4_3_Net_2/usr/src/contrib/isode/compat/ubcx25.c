begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ubcx25.c - X.25 abstractions for UBC X25 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/compat/RCS/ubcx25.c,v 7.4 91/02/22 09:16:13 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/compat/RCS/ubcx25.c,v 7.4 91/02/22 09:16:13 mrose Interim $  *  * Contributed by Julian Onions, Nottingham University in the UK  *  *  * $Log:	ubcx25.c,v $  * Revision 7.4  91/02/22  09:16:13  mrose  * Interim 6.8  *   * Revision 7.3  91/01/14  13:33:53  mrose  * loader  *   * Revision 7.2  90/07/09  14:32:28  mrose  * sync  *   * Revision 7.1  89/12/07  01:08:02  mrose  * queued writes  *   * Revision 7.0  89/11/23  21:23:47  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"tpkt.h"
end_include

begin_comment
comment|/*
comment|4.[23] UNIX: UBC X25 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|UBC_X25
end_ifdef

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_define
define|#
directive|define
name|X25_MBIT
value|0x40
end_define

begin_define
define|#
directive|define
name|X25_QBIT
value|0x80
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|start_x25_client
parameter_list|(
name|local
parameter_list|)
name|struct
name|NSAPaddr
modifier|*
name|local
decl_stmt|;
block|{
name|int
name|sd
decl_stmt|,
name|pgrp
decl_stmt|;
if|if
condition|(
name|local
operator|!=
name|NULLNA
condition|)
name|local
operator|->
name|na_stack
operator|=
name|NA_X25
operator|,
name|local
operator|->
name|na_community
operator|=
name|ts_comm_x25_default
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|socket
argument_list|(
name|AF_CCITT
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"socket"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
comment|/* Error can be found in errno */
block|}
name|pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sd
argument_list|,
name|SIOCSPGRP
argument_list|,
operator|&
name|pgrp
argument_list|)
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"SIOCSPGRP"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
comment|/* Error can be found in errno */
block|}
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|start_x25_server
parameter_list|(
name|local
parameter_list|,
name|backlog
parameter_list|,
name|opt1
parameter_list|,
name|opt2
parameter_list|)
name|struct
name|NSAPaddr
modifier|*
name|local
decl_stmt|;
name|int
name|backlog
decl_stmt|,
name|opt1
decl_stmt|,
name|opt2
decl_stmt|;
block|{
name|int
name|sd
decl_stmt|,
name|pgrp
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
ifdef|#
directive|ifdef
name|BSD43
name|int
name|onoff
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|CONN_DB
name|zsck
decl_stmt|;
name|CONN_DB
modifier|*
name|sck
init|=
operator|&
name|zsck
decl_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|socket
argument_list|(
name|AF_CCITT
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"socket"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
comment|/* Can't get an X.25 socket */
block|}
name|pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sd
argument_list|,
name|SIOCSPGRP
argument_list|,
operator|&
name|pgrp
argument_list|)
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"SIOCSPGRP"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
comment|/* Error can be found in errno */
block|}
if|if
condition|(
name|local
operator|!=
name|NULLNA
condition|)
block|{
name|local
operator|->
name|na_stack
operator|=
name|NA_X25
operator|,
name|local
operator|->
name|na_community
operator|=
name|ts_comm_x25_default
expr_stmt|;
if|if
condition|(
name|local
operator|->
name|na_dtelen
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|local
operator|->
name|na_dte
argument_list|,
name|x25_local_dte
argument_list|)
expr_stmt|;
name|local
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|x25_local_dte
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|->
name|na_pidlen
operator|==
literal|0
operator|&&
operator|*
name|x25_local_pid
condition|)
name|local
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
name|x25_local_pid
argument_list|,
operator|-
literal|1
argument_list|,
name|local
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|gen2if
argument_list|(
name|local
argument_list|,
name|sck
argument_list|,
name|ADDR_LISTEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sd
argument_list|,
name|sck
argument_list|,
sizeof|sizeof
argument_list|(
name|CONN_DB
argument_list|)
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"bind"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_x25_socket
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* not sure if these are supported... */
ifndef|#
directive|ifndef
name|BSD43
if|if
condition|(
name|opt1
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt1
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt2
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt2
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|onoff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|opt1
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt2
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|opt2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
name|onoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|void
operator|)
name|listen
argument_list|(
name|sd
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
return|return
name|sd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|join_x25_client
parameter_list|(
name|fd
parameter_list|,
name|remote
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|remote
decl_stmt|;
block|{
name|CONN_DB
name|sck
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
name|sck
decl_stmt|;
name|int
name|nfd
decl_stmt|;
if|if
condition|(
operator|(
name|nfd
operator|=
name|accept
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sck
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
name|void
operator|)
name|if2gen
argument_list|(
name|remote
argument_list|,
operator|&
name|sck
argument_list|,
name|ADDR_REMOTE
argument_list|)
expr_stmt|;
return|return
name|nfd
return|;
block|}
end_function

begin_function
name|int
name|join_x25_server
parameter_list|(
name|fd
parameter_list|,
name|remote
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|remote
decl_stmt|;
block|{
name|CONN_DB
name|zsck
decl_stmt|;
name|CONN_DB
modifier|*
name|sck
init|=
operator|&
name|zsck
decl_stmt|;
if|if
condition|(
name|remote
operator|==
name|NULLNA
operator|||
name|remote
operator|->
name|na_stack
operator|!=
name|NA_X25
condition|)
block|{
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"Invalid type na%d"
operator|,
name|remote
operator|->
name|na_stack
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|gen2if
argument_list|(
name|remote
argument_list|,
name|sck
argument_list|,
name|ADDR_REMOTE
argument_list|)
expr_stmt|;
return|return
name|connect
argument_list|(
name|fd
argument_list|,
name|sck
argument_list|,
sizeof|sizeof
argument_list|(
name|CONN_DB
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|read_x25_socket
parameter_list|(
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|u_char
name|mode
decl_stmt|;
specifier|static
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
init|=
block|{
operator|(
name|char
operator|*
operator|)
operator|&
name|mode
block|,
literal|1
block|,
literal|""
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|total
init|=
name|len
decl_stmt|;
do|do
block|{
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|p
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|total
operator|>
name|X25_PACKETSIZE
condition|?
name|X25_PACKETSIZE
else|:
name|total
expr_stmt|;
switch|switch
condition|(
name|cc
operator|=
name|readv
argument_list|(
name|fd
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* 		 * for the -1,0& 1 cases these returns should be ok 		 * if it's the first time through, then they are valid anyway 		 * later stages means the M bit is set so there must 		 * be more data else someone is violating the 		 * protocol badly. 		 */
case|case
name|NOTOK
case|:
case|case
literal|0
case|:
return|return
name|cc
return|;
case|case
literal|1
case|:
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"strange return from read_x25_socket"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
name|cc
operator|--
expr_stmt|;
comment|/* discount the info byte */
name|count
operator|+=
name|cc
expr_stmt|;
name|p
operator|+=
name|cc
expr_stmt|;
name|total
operator|-=
name|cc
expr_stmt|;
block|}
block|}
do|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|mode
operator|&
name|X25_MBIT
operator|)
condition|)
do|;
name|DLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"X25 read, total %d/%d"
operator|,
name|count
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UBC_X25_WRITEV
end_ifdef

begin_comment
comment|/* God this all very bizarre - iovecs work on read but not write!! */
end_comment

begin_comment
comment|/*  * OK, this is due to a bug in UBC implementation. It may or may not  * be fixed in later versions. If writev allows you to write single  * bytes in the first vector then use this version. It's much more  * efficient.  */
end_comment

begin_function
name|int
name|write_x25_socket
parameter_list|(
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|u_char
name|mode
decl_stmt|;
specifier|static
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
init|=
block|{
operator|(
name|char
operator|*
operator|)
operator|&
name|mode
block|,
literal|1
block|,
literal|""
block|,
literal|0
block|}
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
do|do
block|{
name|count
operator|=
name|len
operator|>
name|X25_PACKETSIZE
condition|?
name|X25_PACKETSIZE
else|:
name|len
expr_stmt|;
name|mode
operator|=
name|len
operator|>
name|X25_PACKETSIZE
condition|?
name|X25_MBIT
else|:
literal|0
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|p
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|count
expr_stmt|;
switch|switch
condition|(
name|cc
operator|=
name|writev
argument_list|(
name|fd
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
case|case
literal|0
case|:
return|return
name|cc
return|;
case|case
literal|1
case|:
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"strange return from write_x25_socket"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
name|cc
operator|--
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
name|p
operator|+=
name|cc
expr_stmt|;
name|total
operator|+=
name|cc
expr_stmt|;
block|}
block|}
do|while
condition|(
name|len
operator|>
literal|0
condition|)
do|;
name|DLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"X25 write, total %d/%d"
operator|,
name|total
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|write_x25_socket
parameter_list|(
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|char
name|mybuffer
index|[
name|X25_PACKETSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|int
name|cc
decl_stmt|;
do|do
block|{
name|count
operator|=
name|len
operator|>
name|X25_PACKETSIZE
condition|?
name|X25_PACKETSIZE
else|:
name|len
expr_stmt|;
name|mybuffer
index|[
literal|0
index|]
operator|=
name|len
operator|>
name|X25_PACKETSIZE
condition|?
name|X25_MBIT
else|:
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
operator|&
name|mybuffer
index|[
literal|1
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cc
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|mybuffer
argument_list|,
name|count
operator|+
literal|1
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
case|case
literal|0
case|:
return|return
name|cc
return|;
case|case
literal|1
case|:
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"strange return from write_x25_socket"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
name|cc
operator|--
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
name|p
operator|+=
name|cc
expr_stmt|;
name|total
operator|+=
name|cc
expr_stmt|;
block|}
block|}
do|while
condition|(
name|len
operator|>
literal|0
condition|)
do|;
name|DLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"X25 write, total %d/%d"
operator|,
name|total
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UBC_X25 */
end_comment

begin_function
name|int
name|_ubcx25_stub2
parameter_list|()
block|{}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UBC_X25 */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* X25 */
end_comment

begin_function
name|int
name|_ubcx25_stub
parameter_list|()
block|{}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* X25 */
end_comment

end_unit

