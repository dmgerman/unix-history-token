begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pass2.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/pass2.c,v 7.10 91/02/22 09:49:18 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/pepsy/RCS/pass2.c,v 7.10 91/02/22 09:49:18 mrose Interim $  *  *  * $Log:	pass2.c,v $  * Revision 7.10  91/02/22  09:49:18  mrose  * Interim 6.8  *   * Revision 7.9  91/01/08  12:49:45  mrose  * update  *   * Revision 7.8  90/12/23  17:24:52  mrose  * patches  *   * Revision 7.7  90/12/11  10:33:43  mrose  * sync  *   * Revision 7.6  90/11/20  15:27:14  mrose  * update  *   * Revision 7.5  90/11/11  10:53:58  mrose  * update  *   * Revision 7.4  90/11/04  19:18:57  mrose  * update  *   * Revision 7.3  90/08/08  14:02:27  mrose  * stuff  *   * Revision 7.2  90/07/27  08:49:22  mrose  * update  *   * Revision 7.1  90/07/01  20:00:32  mrose  * update  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"pepsydefs.h"
end_include

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|"mine.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|doexternals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sflag
decl_stmt|,
name|mflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|eval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SY
name|mysymbols
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|modsym
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|my_strcat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|notidtoid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rm_indirect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getidordot
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfield
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sym2type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|YP
name|lookup_type
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mymodule - with - changed to _ */
end_comment

begin_decl_stmt
name|Action
name|start_action
decl_stmt|,
name|final_action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|e_actions
decl_stmt|,
name|d_actions
decl_stmt|,
name|p_actions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of actions of each type */
end_comment

begin_function_decl
name|FILE
modifier|*
name|ffopen
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|peri_pass2
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|inc
decl_stmt|;
comment|/* *_pre_defs.h file */
if|if
condition|(
operator|!
name|sflag
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|tab
operator|=
name|notidtoid
argument_list|(
name|mymodule
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mymodule
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_module
argument_list|(
literal|"UNIV"
argument_list|,
name|NULLOID
argument_list|)
expr_stmt|;
name|inc
operator|=
name|my_strcat
argument_list|(
name|mymodule
argument_list|,
name|HFILE2
argument_list|)
expr_stmt|;
name|gen_typesfile
argument_list|(
name|inc
argument_list|)
expr_stmt|;
name|gen_tablefile
argument_list|(
name|inc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate the table file which contains:  * #include types file  * #include - types files for other (external) modules referenced  * definitions of data structures used: strings and stuff for defaults  * 		declaractions of functions referenced.  *		tpe tables - one per type assignment for each of  *			encoding, decoding and printing  *		tables of pointers to all the above tpe tables - one for  *			type of tpe table  *		pointer table - used to hold pointers as tpe table cannot  *		   hold pointers but only integers which index into this table  *		module definition - the key to all the data structures os this  *			module. contains references to all the tables.  *		lint declaractions for the "pepy" functions  */
end_comment

begin_macro
name|gen_tablefile
argument_list|(
argument|inc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|inc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nentries
decl_stmt|;
name|int
name|encflag
init|=
literal|1
decl_stmt|,
name|decflag
init|=
literal|1
decl_stmt|,
name|prntflag
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|act
decl_stmt|;
name|SY
name|sy
decl_stmt|;
name|YP
name|yp
decl_stmt|;
name|FILE
modifier|*
name|fphh
decl_stmt|,
modifier|*
name|fptab
decl_stmt|;
name|fptab
operator|=
name|ffopen
argument_list|(
name|my_strcat
argument_list|(
name|mymodule
argument_list|,
name|TBLNAME
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only need two files<stdio.h> and our types file which includes      * everything else we need      * Assumption. types file in the same directory as the _tables      */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fptab
argument_list|,
literal|"#include<stdio.h>\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fptab
argument_list|,
literal|"#include \"%s%s\"\n\n"
argument_list|,
name|mymodule
argument_list|,
name|GENTYPES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACT_CODE
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fptab
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|act
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|start_action
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fptab
argument_list|,
literal|"\n# line %d \"%s\"\n"
argument_list|,
name|start_action
operator|->
name|a_line
argument_list|,
name|sysin
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|start_action
operator|->
name|a_data
argument_list|,
name|fptab
argument_list|)
expr_stmt|;
block|}
comment|/*      * loop through and generate all the default values definitions      * and what ever else needs to be processed for all the entries      * e.g. external module references and coding function declarations      */
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
operator|(
name|YP_ENCODER
operator||
name|YP_DECODER
operator||
name|YP_PRINTER
operator|)
operator|||
name|Aflag
condition|)
block|{
name|gen_dflts
argument_list|(
name|fptab
argument_list|,
name|sy
operator|->
name|sy_type
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fptab
argument_list|,
literal|"\n#define OFFSET(t,f)\t((int )&(((t *)0)->f))\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fptab
argument_list|,
literal|"\n#define AOFFSET(t,f)\t((int ) (((t *)0)->f))\n\n"
argument_list|)
expr_stmt|;
name|nentries
operator|=
literal|0
expr_stmt|;
comment|/*      * generate tpe tables      */
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_ENCODER
operator|||
name|Aflag
condition|)
block|{
name|nentries
operator|++
expr_stmt|;
name|gen_enctbl
argument_list|(
name|fptab
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_DECODER
operator|||
name|Aflag
condition|)
name|gen_dectbl
argument_list|(
name|fptab
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_PRINTER
operator|||
name|Aflag
condition|)
name|gen_prnttbl
argument_list|(
name|fptab
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
name|fphh
operator|=
name|ffopen
argument_list|(
name|inc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fphh
argument_list|,
literal|"\nextern modtyp	%s%s%s;\n"
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|out_final_defs
argument_list|(
name|fphh
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fphh
argument_list|)
expr_stmt|;
name|gen_actfunct
argument_list|(
name|fptab
argument_list|)
expr_stmt|;
name|gen_tpe
argument_list|(
name|fptab
argument_list|)
expr_stmt|;
comment|/* generate table of pointers to tpe tables */
name|gen_modtype
argument_list|(
name|fptab
argument_list|,
name|nentries
argument_list|,
name|encflag
argument_list|,
name|decflag
argument_list|,
name|prntflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_action
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fptab
argument_list|,
literal|"\n# line %d \"%s\"\n"
argument_list|,
name|final_action
operator|->
name|a_line
argument_list|,
name|sysin
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|final_action
operator|->
name|a_data
argument_list|,
name|fptab
argument_list|)
expr_stmt|;
block|}
name|gen_lint
argument_list|(
name|fptab
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fptab
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate the *-types.h file  */
end_comment

begin_macro
name|gen_typesfile
argument_list|(
argument|inc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|inc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|encflag
init|=
literal|1
decl_stmt|,
name|decflag
init|=
literal|1
decl_stmt|,
name|prntflag
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|act
decl_stmt|;
name|SY
name|sy
decl_stmt|;
name|YP
name|yp
decl_stmt|;
name|FILE
modifier|*
name|fph
decl_stmt|,
modifier|*
name|fpe
decl_stmt|,
modifier|*
name|fpd
decl_stmt|,
modifier|*
name|fpp
decl_stmt|;
name|FILE
modifier|*
name|fpa
decl_stmt|;
name|fph
operator|=
name|ffopen
argument_list|(
name|my_strcat
argument_list|(
name|mymodule
argument_list|,
name|HFILE1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflag
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#ifndef\tPEPYPATH\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#include<isode/pepsy/%s>\n"
argument_list|,
name|inc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|inc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#endif\n\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_stand
argument_list|(
name|inc
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#include<isode/pepsy/%s>\n"
argument_list|,
name|inc
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|inc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ACT_CODE
name|act
operator|=
name|my_strcat
argument_list|(
name|mymodule
argument_list|,
name|ACTIONDEFS
argument_list|)
expr_stmt|;
name|fpe
operator|=
name|ffopen
argument_list|(
name|my_strcat
argument_list|(
name|mymodule
argument_list|,
name|ENCFILENAME
argument_list|)
argument_list|)
expr_stmt|;
name|file_header
argument_list|(
name|fpe
argument_list|,
name|act
argument_list|)
expr_stmt|;
name|fpd
operator|=
name|ffopen
argument_list|(
name|my_strcat
argument_list|(
name|mymodule
argument_list|,
name|DECFILENAME
argument_list|)
argument_list|)
expr_stmt|;
name|file_header
argument_list|(
name|fpd
argument_list|,
name|act
argument_list|)
expr_stmt|;
name|fpp
operator|=
name|ffopen
argument_list|(
name|my_strcat
argument_list|(
name|mymodule
argument_list|,
name|PRNTFILENAME
argument_list|)
argument_list|)
expr_stmt|;
name|file_header
argument_list|(
name|fpp
argument_list|,
name|act
argument_list|)
expr_stmt|;
name|fpa
operator|=
name|ffopen
argument_list|(
name|act
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* define the macros to support posy functions */
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"\n#ifndef\tlint\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mymodule unsuitable for module name e.g %s and %s(mymodule)\n"
argument_list|,
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_ENCODER
operator|||
name|Aflag
condition|)
block|{
name|buf
operator|=
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|yyencdflt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#define %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"(pe, top, len, buffer, parm) \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"    %s(%s%s, "
argument_list|,
name|ENCFNCNAME
argument_list|,
name|PREFIX
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"&%s%s%s, "
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"pe, top, len, buffer, (char *) parm)\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACT_CODE
if|if
condition|(
name|encflag
condition|)
block|{
name|fprintf
argument_list|(
name|fpe
argument_list|,
literal|"%s%s"
argument_list|,
name|ENC_FNCNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|open_func
argument_list|(
name|fpe
argument_list|)
expr_stmt|;
name|encflag
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bflag
condition|)
name|init_new_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|end_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_DECODER
operator|||
name|Aflag
condition|)
block|{
name|buf
operator|=
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|yydecdflt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|init_new_file
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#define %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"(pe, top, len, buffer, parm) \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"    %s(%s%s, "
argument_list|,
name|DECFNCNAME
argument_list|,
name|PREFIX
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"&%s%s%s, "
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"pe, top, len, buffer, (char **) parm)\n\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|ACT_CODE
if|if
condition|(
name|decflag
condition|)
block|{
name|fprintf
argument_list|(
name|fpd
argument_list|,
literal|"%s%s"
argument_list|,
name|DEC_FNCNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|open_func
argument_list|(
name|fpd
argument_list|)
expr_stmt|;
name|decflag
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bflag
condition|)
name|end_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_PRINTER
operator|||
name|Aflag
condition|)
block|{
name|buf
operator|=
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|yyprfdflt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bflag
condition|)
name|init_new_file
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#define %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"(pe, top, len, buffer, parm) \\\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"    %s(%s%s, "
argument_list|,
name|PRNTFNCNAME
argument_list|,
name|PREFIX
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"&%s%s%s, "
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"pe, top, len, buffer)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"#define %s_P"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"    %s%s, "
argument_list|,
name|PREFIX
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"&%s%s%s\n\n"
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACT_CODE
if|if
condition|(
name|prntflag
condition|)
block|{
name|fprintf
argument_list|(
name|fpp
argument_list|,
literal|"%s%s"
argument_list|,
name|PRNT_FNCNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|open_func
argument_list|(
name|fpp
argument_list|)
expr_stmt|;
name|prntflag
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bflag
condition|)
name|end_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bflag
operator|&&
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fph
argument_list|,
literal|"\n#endif   /* lint */\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACT_CODE
if|if
condition|(
operator|!
name|encflag
condition|)
block|{
name|close_func
argument_list|(
name|fpe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|decflag
condition|)
block|{
name|close_func
argument_list|(
name|fpd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prntflag
condition|)
block|{
name|close_func
argument_list|(
name|fpp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|close
argument_list|(
name|fph
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACT_CODE
name|close
argument_list|(
name|fpe
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fpd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fpp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fpa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|gen_enctbl
argument_list|(
argument|fp
argument_list|,
argument|sy
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SY
name|sy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|YP
name|yp
decl_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"static tpe %s%s[] = {\n"
argument_list|,
name|ETABLE
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_START, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|tenc_typ
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gen_dectbl
argument_list|(
argument|fp
argument_list|,
argument|sy
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SY
name|sy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|YP
name|yp
decl_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"static tpe %s%s[] = {\n"
argument_list|,
name|DTABLE
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_START, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|tdec_typ
argument_list|(
name|fp
argument_list|,
name|sy
operator|->
name|sy_type
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gen_prnttbl
argument_list|(
argument|fp
argument_list|,
argument|sy
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SY
name|sy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|YP
name|yp
decl_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"static ptpe %s%s[] = {\n"
argument_list|,
name|PTABLE
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_START, 0, 0, 0, \"%s\" },\n"
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|tprnt_typ
argument_list|(
name|fp
argument_list|,
name|sy
operator|->
name|sy_type
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0, NULL }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * define the tpe index tables and the pointer table  */
end_comment

begin_macro
name|gen_tpe
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SY
name|sy
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"static tpe *etabl[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_direction
operator|&
name|YP_ENCODER
operator|||
name|Aflag
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s%s,\n"
argument_list|,
name|ETABLE
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"static tpe *dtabl[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_direction
operator|&
name|YP_DECODER
operator|||
name|Aflag
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s%s,\n"
argument_list|,
name|DTABLE
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"static ptpe *ptabl[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_direction
operator|&
name|YP_PRINTER
operator|||
name|Aflag
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s%s,\n"
argument_list|,
name|PTABLE
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t};\n\n"
argument_list|)
expr_stmt|;
comment|/* produce pointer table */
name|dump_ptrtab
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * output the module structure for this module  */
end_comment

begin_macro
name|gen_modtype
argument_list|(
argument|fp
argument_list|,
argument|no
argument_list|,
argument|f1
argument_list|,
argument|f2
argument_list|,
argument|f3
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|f3
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|f1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern PE\t%s%s();\n"
argument_list|,
name|ENC_FNCNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f2
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern PE\t%s%s();\n"
argument_list|,
name|DEC_FNCNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f3
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern PE\t%s%s();\n"
argument_list|,
name|PRNT_FNCNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"modtyp %s%s%s = {\n"
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\"%s\",\n"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
comment|/* name */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%d,\n"
argument_list|,
name|no
argument_list|)
expr_stmt|;
comment|/* number of entries */
comment|/* coding tables */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tetabl,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tdtabl,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tptabl,\n"
argument_list|)
expr_stmt|;
comment|/* action tables */
if|if
condition|(
name|e_actions
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tefn_%s,\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t0,\n"
argument_list|)
expr_stmt|;
comment|/* no action code */
if|if
condition|(
name|d_actions
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tdfn_%s,\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t0,\n"
argument_list|)
expr_stmt|;
comment|/* no action code */
if|if
condition|(
name|p_actions
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tpfn_%s,\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t0,\n"
argument_list|)
expr_stmt|;
comment|/* no action code */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s%s%s,\n"
argument_list|,
name|PREFIX
argument_list|,
name|PTR_TABNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t};\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * open a file called name  */
end_comment

begin_function
name|FILE
modifier|*
name|ffopen
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create the file %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACT_CODE
end_ifdef

begin_comment
comment|/*  * output the file prologue to the file specified by fp  */
end_comment

begin_macro
name|file_header
argument_list|(
argument|fp
argument_list|,
argument|act
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|act
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include %s\n"
argument_list|,
name|PSAP_DOT_H
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|INCFILE1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|act
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include \"%s%s\"\n\n"
argument_list|,
name|mymodule
argument_list|,
name|GENTYPES
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#ifndef PEPYPARM\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#define PEPYPARM char *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern PEPYPARM NullParm;\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * output the function prologue to the file specified by fp  */
end_comment

begin_macro
name|open_func
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(pe, parm, p, mod)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PE\tpe;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PEPYPARM\tparm;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"tpe\t*p;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"modtyp\t*mod;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* action 0 ???? */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tswitch (p->pe_ucode) {\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * output the function epilogue to the file specified by fp  */
end_comment

begin_macro
name|close_func
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\tdefault:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t\tbreak;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\treturn OK;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print the table id_table  */
end_comment

begin_macro
name|print_table
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|id_entry
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABLESIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|t
operator|=
name|id_table
index|[
name|i
index|]
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s(%d) -->   "
argument_list|,
name|t
operator|->
name|r_value
argument_list|,
name|t
operator|->
name|def_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_table
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NULL -- %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|struct
name|univ_typ
name|univ_tab
index|[]
init|=
block|{
block|{
literal|"EXTERNAL"
block|,
literal|"struct	type_UNIV_EXTERNAL	*"
block|,
literal|"EXTERNAL"
block|,
literal|8
block|,
literal|0
block|,
literal|"UNIV"
block|,
name|UNF_EXTMOD
operator||
name|UNF_HASDATA
block|,
name|YP_SEQLIST
block|, }
block|,
block|{
literal|"GeneralString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|27
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"GeneralisedTime"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|24
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"GeneralizedTime"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|24
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"GraphicString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|25
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"IA5String"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|22
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"ISO646String"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|26
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"NumericString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|18
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"PrintableString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|19
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"TeletexString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|20
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"T61String"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|20
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"UTCTime"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|23
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"UniversalTime"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|23
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"VideotexString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|21
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|,
block|{
literal|"VisibleString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|26
block|,
literal|0
block|,
literal|"UNIV"
block|,
literal|0
block|,
name|YP_OCT
block|, }
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|univ_typ
modifier|*
name|simptyp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine wether the type name matches one of the Universal types  * which are to be treated specially. If so return a pointer to the  * data structure which contains the parameters describing how it  * should be processed  */
end_comment

begin_function
name|struct
name|univ_typ
modifier|*
name|univtyp
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|NENTRIES
argument_list|(
name|univ_tab
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|p
operator|=
name|univ_tab
operator|+
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|scmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|univ_name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|low
operator|==
name|high
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|high
operator|=
name|p
operator|-
name|univ_tab
operator|-
literal|1
expr_stmt|;
else|else
name|low
operator|=
name|p
operator|-
name|univ_tab
operator|+
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|OPTIMISED
if|if
condition|(
operator|(
name|p
operator|=
name|simptyp
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two strings returning a number representing the character  * where they differ or 0 if are the same - I wrote this because I  * couldn't trust strcmp to work the same way between numbers and  * letters everywhere. longer strings are greater shorter strings  * numbers are greater then all letters lower case are greater then  * upper case There must be a better way !  */
end_comment

begin_macro
name|scmp
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|&&
operator|*
name|s2
condition|)
name|s1
operator|++
operator|,
name|s2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
operator|&&
operator|*
name|s2
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|s2
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
name|isalpha
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
return|return
operator|(
operator|*
name|s1
operator|-
operator|*
name|s2
operator|)
return|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
name|islower
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
return|return
operator|(
operator|*
name|s1
operator|-
operator|*
name|s2
operator|)
return|;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
return|return
operator|(
operator|*
name|s1
operator|-
operator|*
name|s2
operator|)
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|*
name|s1
operator|-
operator|*
name|s2
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * lookup a symbol and return a pointer to it  */
end_comment

begin_function
name|SY
name|syfind
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|SY
name|sy
decl_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sy
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * determine if the symbol is a simple type that is optimised  */
end_comment

begin_function
name|struct
name|univ_typ
modifier|*
name|simptyp
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
name|YP
name|y
decl_stmt|;
specifier|static
name|struct
name|univ_typ
name|bitstring
init|=
block|{
literal|"Bitstring"
block|,
literal|"struct	PElement	*"
block|,
literal|"BITSTRING"
block|,
literal|3
block|,
literal|0
block|}
decl_stmt|,
name|octetstring
init|=
block|{
literal|"GeneralString"
block|,
literal|"struct	qbuf	*"
block|,
literal|"OCTETSTRING"
block|,
literal|4
block|,
literal|0
block|}
decl_stmt|,
name|oid
init|=
block|{
literal|"Object Identifier"
block|,
literal|"struct	OIDentifier	*"
block|,
literal|"OBJIDENT"
block|,
literal|6
block|,
literal|0
block|}
decl_stmt|,
name|obj
init|=
block|{
literal|"Module"
block|,
literal|"struct	OIDentifier	*"
block|,
literal|"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
block|,
literal|27
block|,
literal|0
block|}
decl_stmt|;
define|#
directive|define
name|MSTRING
value|30
comment|/* number of Xs in the above string */
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
return|return
operator|(
operator|&
name|bitstring
operator|)
return|;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
return|return
operator|(
operator|&
name|bitstring
operator|)
return|;
case|case
name|YP_OCT
case|:
return|return
operator|(
operator|&
name|octetstring
operator|)
return|;
case|case
name|YP_OID
case|:
return|return
operator|(
operator|&
name|oid
operator|)
return|;
case|case
name|YP_IDEFINED
case|:
name|strncpy
argument_list|(
name|p
operator|->
name|univ_tab
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
name|MSTRING
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|obj
operator|)
return|;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * lookup a type name until you get something that is not a name  */
end_comment

begin_function
name|YP
name|lkup
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
name|YP
name|yp1
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return
operator|(
name|yp
operator|)
return|;
while|while
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|yp1
operator|=
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
return|return
operator|(
name|yp
operator|)
return|;
name|yp
operator|=
name|yp1
expr_stmt|;
block|}
return|return
operator|(
name|yp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compute the type of tag it should be given the tag and the type it is  * being applied to  */
end_comment

begin_macro
name|comptag
argument_list|(
argument|tag
argument_list|,
argument|yp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|YP
name|yp1
decl_stmt|;
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|yp1
operator|=
name|lkup
argument_list|(
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp1
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|univ_type
operator|<=
name|YP_UNDF
condition|)
block|{
switch|switch
condition|(
name|chkil
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
condition|)
block|{
case|case
name|ER_NORMAL
case|:
return|return
operator|(
name|tag
operator|)
return|;
case|case
name|ER_EXPLICIT
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|warned
operator|++
operator|<=
literal|3
condition|)
block|{
name|ferrs
argument_list|(
literal|0
argument_list|,
literal|"\ncomptag:warning implicit tag of unknown type %s\n"
argument_list|,
name|yp1
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|ferr
argument_list|(
literal|0
argument_list|,
literal|"\tcomptag:treated as implicit\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tag
operator|)
return|;
block|}
name|code
operator|=
name|p
operator|->
name|univ_type
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|yp1
operator|->
name|yp_code
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|YP_ANY
operator|&&
name|yp1
operator|->
name|yp_flags
operator|&
name|YP_WANTIMPLICIT
condition|)
return|return
operator|(
name|tag
operator|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|YP_CHOICE
operator|||
name|code
operator|==
name|YP_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Generate function definitions for all the macros so that lint  * can type check all thier uses  */
end_comment

begin_macro
name|gen_lint
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|SY
name|sy
decl_stmt|;
name|YP
name|yp
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n#ifdef\tlint\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mymodule unsuitable for module name e.g %s and %s(mymodule)\n"
argument_list|,
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Encoding routine */
name|buf
operator|=
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|yyencdflt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n#undef %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"int	%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(pe, top, len, buffer, parm)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PE     *pe;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"int\ttop,\n\tlen;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"char   *buffer;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s *parm;\n"
argument_list|,
name|sym2type
argument_list|(
name|sy
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"{\n  return (%s(%s%s, "
argument_list|,
name|ENCFNCNAME
argument_list|,
name|PREFIX
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"&%s%s%s, "
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pe, top, len, buffer,\n\t\t(char *) parm));\n}\n"
argument_list|)
expr_stmt|;
comment|/* Decoding routine */
name|buf
operator|=
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|yydecdflt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n#undef %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"int	%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(pe, top, len, buffer, parm)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PE\tpe;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"int\ttop,\n       *len;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"char  **buffer;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s **parm;\n"
argument_list|,
name|sym2type
argument_list|(
name|sy
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"{\n  return (%s(%s%s, "
argument_list|,
name|DECFNCNAME
argument_list|,
name|PREFIX
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"&%s%s%s, "
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pe, top, len, buffer,\n\t\t(char **) parm));\n}\n"
argument_list|)
expr_stmt|;
comment|/* Printing routine */
name|buf
operator|=
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
name|yyprfdflt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n#undef %s\n/* ARGSUSED */\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"int	%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(pe, top, len, buffer, parm)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PE\tpe;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"int\ttop,\n       *len;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"char  **buffer;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s *parm;\n"
argument_list|,
name|sym2type
argument_list|(
name|sy
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"{\n  return (%s(%s%s, "
argument_list|,
name|PRNTFNCNAME
argument_list|,
name|PREFIX
argument_list|,
name|proc_name
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"&%s%s%s, "
argument_list|,
name|PREFIX
argument_list|,
name|tab
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pe, top, len, buffer));\n}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n#endif\t/* lint */\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pointer table support routines  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ptr_tab
index|[
name|MAXPTRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference of the pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ptr_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * add the given pointer to the pointer table and return its index  */
end_comment

begin_macro
name|addptr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ind
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/*      * try to eliminate common pointers by returning a ponter if it matches      * previously      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ptr_cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|ptr_tab
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
name|ptr_cnt
operator|>=
name|MAXPTRS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\npointer table overflow %d\n"
argument_list|,
name|ptr_cnt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\naddptr:out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ptr_tab
index|[
name|ind
operator|=
name|ptr_cnt
operator|++
index|]
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|ind
operator|)
return|;
block|}
end_block

begin_macro
name|dump_ptrtab
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n/* Pointer table %d entries */\n"
argument_list|,
name|ptr_cnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"static caddr_t %s%s%s[] = {\n"
argument_list|,
name|PREFIX
argument_list|,
name|PTR_TABNAME
argument_list|,
name|tab
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ptr_cnt
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    (caddr_t ) %s,\n"
argument_list|,
name|ptr_tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_cnt
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    (caddr_t ) 0,\n"
argument_list|)
expr_stmt|;
comment|/* for fussy C compilers */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * routines to parse and analyse C types to support the pepy-like extensions  * of pepsy  */
end_comment

begin_comment
comment|/*  * remove a level of indirection from the given type. If possible. if not  * return NULLCP, otherwise return the new type in a temporary buffer  */
end_comment

begin_function
name|char
modifier|*
name|rm_indirect
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULLCP
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|)
operator|>=
name|STRSIZE
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULLCP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * extract the field from the C arguement and the following constant  * expression for the bit number.   * if it fails return NULLCP  */
end_comment

begin_function
name|char
modifier|*
name|getfldbit
parameter_list|(
name|p
parameter_list|,
name|pstr
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULLCP
operator|||
name|pstr
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|getidordot
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|STRSIZE
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'$'
condition|)
block|{
comment|/* must be a -> */
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"->"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getidordot
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|STRSIZE
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'$'
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
block|}
operator|*
name|pstr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* have to leave it up to the compiler to verify the 			 * constant expression for the bit number 			 */
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return a pointer after the current batch of white space if any */
end_comment

begin_function
name|char
modifier|*
name|skipspace
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * extract the field from the C arguement and return it in a static buffer  * else return NULLCP  */
end_comment

begin_function
name|char
modifier|*
name|getfield
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|buf1
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
comment|/* to support *parm field */
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|getidordot
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|STRSIZE
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|buf
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"->"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* if we have an& keep it on the field */
if|if
condition|(
operator|*
name|buf
operator|==
literal|'&'
condition|)
name|buf1
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
else|else
name|buf1
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getidordot
argument_list|(
name|p
argument_list|,
name|buf1
argument_list|,
name|STRSIZE
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|buf
operator|)
return|;
return|return
operator|(
name|NULLCP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get an identifier into the given buffer [A-Za-z_] are legal chars  */
end_comment

begin_function
name|char
modifier|*
name|getid
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|fbuf
decl_stmt|;
name|fbuf
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|--
operator|>=
literal|0
condition|)
operator|*
name|buf
operator|++
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fbuf
operator|==
name|buf
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get an identifier into the given buffer - '.' are considered part of an   * identifier - should really be called get field reference  */
end_comment

begin_function
name|char
modifier|*
name|getidordot
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|fbuf
decl_stmt|;
name|fbuf
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
name|len
operator|--
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|--
operator|>=
literal|0
condition|)
operator|*
name|buf
operator|++
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fbuf
operator|==
name|buf
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noindstr
index|[]
init|=
block|{
literal|"*"
block|,
literal|"*parm"
block|,
literal|"&"
block|,
literal|"&parm"
block|,
name|NULLCP
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * determine if the given field means no indirection wanted and so return 1  * else return 0  */
end_comment

begin_macro
name|noindirect
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|ps
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULLCP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|f
operator|=
name|skipspace
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULLCP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|f
operator|==
literal|'&'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|p
operator|=
name|f
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|l
operator|=
name|p
operator|-
name|f
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|noindstr
init|;
operator|*
name|ps
condition|;
name|ps
operator|++
control|)
if|if
condition|(
name|l
operator|==
name|strlen
argument_list|(
operator|*
name|ps
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|f
argument_list|,
operator|*
name|ps
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * process the T - the Type and field specifier  * the given YP to the appropriate values for VALTYPE string  * Namely the yp_parm_type to contain the (Parameter) type string.  * then if there is a $ the yp_parm to the part after the $, the field  */
end_comment

begin_macro
name|setvaltype
argument_list|(
argument|yp
argument_list|,
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULLCP
operator|||
operator|*
operator|(
name|str
operator|=
name|skipspace
argument_list|(
name|str
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_parm
operator|=
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_flags
operator||=
name|YP_PARMVAL
expr_stmt|;
block|}
name|yp
operator|->
name|yp_param_type
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * generate the functions that carry out the action statements  */
end_comment

begin_macro
name|gen_actfunct
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SY
name|sy
decl_stmt|;
name|YP
name|yp
decl_stmt|;
name|Action
name|act
decl_stmt|;
if|if
condition|(
name|e_actions
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n/*VARARGS*/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nstatic\tint\nefn_%s(__p, ppe, _Zp)\ncaddr_t	__p;\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PE	*ppe;\ntpe	*_Zp;\n{\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t\n\t/* %d cases */\n    switch(_Zp->pe_ucode) {\n"
argument_list|,
name|e_actions
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_ENCODER
operator|||
name|Aflag
condition|)
name|gen_actions
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_ENC
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    default:\n        return (pepsylose(NULLMODTYP, _Zp, *ppe, \"enf_%s:Bad table entry: %%d\",\n             _Zp->pe_ucode));\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t}\t/* switch */\n    return (OK);\n}\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d_actions
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n/*VARARGS*/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nstatic\tint\ndfn_%s(__p, pe, _Zp, _val)\ncaddr_t	__p;\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PE	pe;\ntpe	*_Zp;\nint _val;\n{\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t\n\t/* %d cases */\n    switch(_Zp->pe_ucode) {\n"
argument_list|,
name|d_actions
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_DECODER
operator|||
name|Aflag
condition|)
name|gen_actions
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    default:\n        return (pepsylose(NULLMODTYP, _Zp, pe, \"dnf_%s:Bad table entry: %%d\",\n            _Zp->pe_ucode));\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t}\t/* switch */\n    return (OK);\n}\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_actions
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n/*VARARGS*/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nstatic\tint\npfn_%s(pe, _Zp)\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PE	pe;\ntpe	*_Zp;\n{\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t\n\t/* %d cases */\n    switch(_Zp->pe_ucode) {\n"
argument_list|,
name|p_actions
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_PRINTER
operator|||
name|Aflag
condition|)
name|gen_actions
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_PNT
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"    default:\n        return (pepsylose(NULLMODTYP, _Zp, NULLPE, \"pnf_%s:Bad table entry: %%d\",\n            _Zp->pe_ucode));\n"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t}\t/* switch */\n    return (OK);\n}\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|GEN_RETURN
value|1
end_define

begin_define
define|#
directive|define
name|GEN_ASSIGN
value|2
end_define

begin_comment
comment|/*  * generate the actions for this YP unit and all its children  */
end_comment

begin_macro
name|gen_actions
argument_list|(
argument|fp
argument_list|,
argument|oyp
argument_list|,
argument|form
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|oyp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|form
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what type of action is it */
end_comment

begin_block
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
specifier|register
name|YAL
name|yal
decl_stmt|;
specifier|register
name|Action
name|act
decl_stmt|;
for|for
control|(
name|yp
operator|=
name|oyp
init|;
name|yp
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
block|{
comment|/* do its actions first then any of its children */
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_bef_alist
condition|)
name|dumpact
argument_list|(
name|fp
argument_list|,
name|yal
argument_list|,
name|form
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_aft_alist
condition|)
name|dumpact
argument_list|(
name|fp
argument_list|,
name|yal
argument_list|,
name|form
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_control_act
condition|)
block|{
if|if
condition|(
name|form
operator|==
name|G_ENC
condition|)
name|dumpact
argument_list|(
name|fp
argument_list|,
name|yal
argument_list|,
name|form
argument_list|,
name|GEN_RETURN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|form
operator|==
name|G_DEC
condition|)
name|dumpact
argument_list|(
name|fp
argument_list|,
name|yal
argument_list|,
name|form
argument_list|,
name|GEN_ASSIGN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_optional_act
condition|)
block|{
if|if
condition|(
name|form
operator|==
name|G_ENC
condition|)
name|dumpact
argument_list|(
name|fp
argument_list|,
name|yal
argument_list|,
name|form
argument_list|,
name|GEN_RETURN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|form
operator|==
name|G_DEC
condition|)
name|dumpact
argument_list|(
name|fp
argument_list|,
name|yal
argument_list|,
name|form
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|gen_actions
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_type
argument_list|,
name|form
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * dump out a single action  */
end_comment

begin_macro
name|dumpact
argument_list|(
argument|fp
argument_list|,
argument|yal
argument_list|,
argument|form
argument_list|,
argument|ret
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YAL
name|yal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|form
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ret
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|comm
init|=
name|yal
operator|->
name|yal_comment
decl_stmt|;
name|char
modifier|*
name|type
init|=
name|yal
operator|->
name|yal_type
decl_stmt|;
name|Action
name|act
decl_stmt|;
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|type
argument_list|)
operator|>
name|STRSIZE
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"dumpact:type too big \"%s\"\n bye\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|type
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|!=
name|G_DEC
condition|)
name|strncat
argument_list|(
name|buf
argument_list|,
literal|"*"
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
else|else
name|strncat
argument_list|(
name|buf
argument_list|,
literal|"**"
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
name|type
operator|=
name|buf
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|G_ENC
case|:
name|act
operator|=
name|yal
operator|->
name|yal_enc
expr_stmt|;
break|break;
case|case
name|G_DEC
case|:
name|act
operator|=
name|yal
operator|->
name|yal_dec
expr_stmt|;
break|break;
case|case
name|G_PNT
case|:
name|act
operator|=
name|yal
operator|->
name|yal_prn
expr_stmt|;
break|break;
block|}
comment|/* can't tell wether this table has the UCODE till here */
if|if
condition|(
name|act
operator|==
name|NULLAction
operator|||
name|act
operator|->
name|a_line
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|form
operator|!=
name|G_PNT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n#define parm	((%s )__p)\n\tcase %d: /* %s */\n"
argument_list|,
name|type
argument_list|,
name|act
operator|->
name|a_num
argument_list|,
name|comm
condition|?
name|comm
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\tcase %d: /* %s */\n"
argument_list|,
name|act
operator|->
name|a_num
argument_list|,
name|comm
condition|?
name|comm
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t{\n# line %d \"%s\"\n"
argument_list|,
name|act
operator|->
name|a_line
argument_list|,
name|sysin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|GEN_ASSIGN
case|:
if|if
condition|(
name|control_act
argument_list|(
name|act
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t/* ignored - empty expression */\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\t(%s) = _val;\n"
argument_list|,
name|act
operator|->
name|a_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEN_RETURN
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t\treturn (%s);\n"
argument_list|,
name|act
operator|->
name|a_data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs
argument_list|(
name|act
operator|->
name|a_data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t\t}\n\t    break;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|!=
name|G_PNT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n#undef parm\n"
argument_list|)
expr_stmt|;
name|act
operator|->
name|a_line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* mark as done */
block|}
end_block

begin_comment
comment|/*  * produce a temporary copy of the type specified in the ParameterType  * specification  * i.e. a [[ P type ]] specification  */
end_comment

begin_function
name|char
modifier|*
name|partyp2str
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\npartyp2str no param_type field\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\npartyp2str can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * produce a string giving the type of a symbol, in a static buffer  */
end_comment

begin_function
name|char
modifier|*
name|sym2type
parameter_list|(
name|sy
parameter_list|)
name|SY
name|sy
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|STRSIZE
index|]
decl_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_type
operator|&&
name|sy
operator|->
name|sy_type
operator|->
name|yp_param_type
condition|)
return|return
operator|(
name|partyp2str
argument_list|(
name|sy
operator|->
name|sy_type
argument_list|)
operator|)
return|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"struct %s"
argument_list|,
name|modsym
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

end_unit

