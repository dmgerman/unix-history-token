begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ptabs.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/ptabs.c,v 7.8 91/02/22 09:49:58 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/pepsy/RCS/ptabs.c,v 7.8 91/02/22 09:49:58 mrose Interim $  *  *  * $Log:	ptabs.c,v $  * Revision 7.8  91/02/22  09:49:58  mrose  * Interim 6.8  *   * Revision 7.7  91/01/08  12:50:56  mrose  * update  *   * Revision 7.6  90/12/23  17:25:26  mrose  * patches  *   * Revision 7.5  90/12/11  10:41:09  mrose  * sync  *   * Revision 7.4  90/11/11  10:54:20  mrose  * update  *   * Revision 7.3  90/11/04  19:21:09  mrose  * update  *   * Revision 7.2  90/07/27  08:49:29  mrose  * update  *   * Revision 7.1  90/07/09  14:53:16  mrose  * sync  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pepsydefs.h"
end_include

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|"mine.h"
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|c_tag
argument_list|()
decl_stmt|,
modifier|*
name|c_class
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ec_tag
argument_list|()
decl_stmt|,
modifier|*
name|ec_class
argument_list|()
decl_stmt|,
modifier|*
name|pec_class
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strip_last
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|str_yp_code
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|get_val
argument_list|()
decl_stmt|,
modifier|*
name|get_comp
argument_list|()
decl_stmt|,
modifier|*
name|strp2name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_table
modifier|*
name|lookup_list
argument_list|()
decl_stmt|,
modifier|*
name|get_offset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|YP
name|tprnt_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|gen_pentry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|my_strcat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rm_indirect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfield
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|setfield
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* extern int explicit; */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cons_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|s_table
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|s_table
modifier|*
name|save_ptr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WORDSIZE
value|20
end_define

begin_comment
comment|/*  * Marshall's three extra conditions for changing the printing output  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mrose1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if NamedType */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mrose2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !mrose1&& -h&& DefinedType */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mrose3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (mrose1 || !mrose2)&& TAG&& (OPTIONAL|DEFAULT) */
end_comment

begin_comment
comment|/*  * table printe a type. generate tables for the printing of a type  */
end_comment

begin_macro
name|tprnt_typ
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|id
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s_table
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|;
name|YP
name|y
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|ptr_tblidx
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|<
literal|0
operator|||
name|yp
operator|->
name|yp_code
operator|>
name|YP_REAL
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ: unimplemented type %d\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULL
condition|)
block|{
name|ferr
argument_list|(
literal|0
argument_list|,
literal|"tprnt_typ:NULL arguement\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_bef_alist
operator|&&
name|yp
operator|->
name|yp_bef_alist
operator|->
name|yal_prn
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_bef_alist
operator|->
name|yal_prn
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|mrose1
operator|=
literal|1
expr_stmt|;
else|else
name|mrose1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mrose1
operator|&&
name|hflag
operator|&&
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
name|mrose2
operator|=
literal|1
expr_stmt|;
else|else
name|mrose2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mrose1
operator|||
operator|!
name|mrose2
operator|)
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
condition|)
name|mrose3
operator|=
literal|1
expr_stmt|;
else|else
name|mrose3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|t
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SETLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
operator|)
operator|&&
name|yp
operator|->
name|yp_parm
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_parm
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_parm
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|strdup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|yp
operator|->
name|yp_varexp
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|==
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
condition|)
block|{
name|yp
operator|->
name|yp_flags
operator|&=
operator|~
name|YP_OPTCONTROL
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
operator|)
condition|)
block|{
name|prte_enoff
argument_list|(
name|fp
argument_list|,
literal|"ETAG"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_yfn
operator|&&
name|yp
operator|->
name|yp_yfn
operator|->
name|yfn_prt
condition|)
block|{
name|gen_fn
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|yp
operator|->
name|yp_yfn
operator|->
name|yfn_prt
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_aft_alist
operator|&&
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_prn
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_prn
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_UNDF
case|:
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:Undefined type\n"
argument_list|)
expr_stmt|;
case|case
name|YP_BOOL
case|:
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BOOL: must specify a field [[ b .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BOOLEAN"
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
break|break;
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BOOL: can't find a type for boolean\n"
argument_list|)
expr_stmt|;
comment|/* This needs to be fixed up in the action generating area */
case|case
name|YP_INTLIST
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:INT: must specify a field [[ i .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"INTEGER"
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
break|break;
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:INT: couldn't determine type\n"
argument_list|)
expr_stmt|;
case|case
name|YP_REAL
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:REAL: must specify a field [[ r .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"REALTYPE"
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
break|break;
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:INT: couldn't determine type\n"
argument_list|)
expr_stmt|;
case|case
name|YP_BITLIST
case|:
name|ptr_tblidx
operator|=
name|addptr
argument_list|(
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yp
operator|->
name|yp_varexp
condition|?
name|yp
operator|->
name|yp_varexp
else|:
name|id
argument_list|,
literal|"bits"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fall */
case|case
name|YP_BIT
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BIT: must specify a field [[ x .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_PTR"
expr_stmt|;
name|prte_off
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BIT: must specify a field [[ x .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_LEN"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_strexp
operator|==
name|NULLCP
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"BITSTRING"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SBITSTRING, %d, %s, %s, NULL },\n"
argument_list|,
name|ptr_tblidx
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
block|{
switch|switch
condition|(
name|yp
operator|->
name|yp_prfexp
condition|)
block|{
case|case
literal|'q'
case|:
comment|/* [[ q parm->qbufptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"SOCTETSTRING"
expr_stmt|;
else|else
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* [[ s ptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:OCT: must specify a field [[ s .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"T_STRING"
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* [[ o ptr $ length ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:OCT: must specify a field [[ o .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_PTR"
expr_stmt|;
name|prte_off
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:OCT: must specify a field [[ o .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_LEN"
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:Unknown Octet string specifier %c\n"
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|f
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SOCTETSTRING"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"OBJID"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SOBJID"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"ANY"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SANY"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
name|p1
operator|=
literal|"T_NULL"
expr_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
operator|)
operator|&&
name|yp
operator|->
name|yp_prfexp
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"\n[[ ? reference ]] [[ p reference ]] is illegal\n\t only one allowed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_prfexp
condition|)
block|{
comment|/* [[ ? parm->field ]] - complex to process */
name|gen_identry
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|gen_pentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
break|break;
block|}
name|pr_deftyp
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQLIST
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|==
name|NULL
operator|&&
name|type
operator|!=
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:YP_SEQLIST:NULL varexp pointer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSEQ_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSEQ_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
else|else
name|prte_off
argument_list|(
name|fp
argument_list|,
literal|"SEQ_START"
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:SEQLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:YP_SEQLIST:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_OFFSETS
if|if
condition|(
name|optfield
argument_list|(
name|y
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ OPTL, OFFSET(%s, optionals), 0, 0, NULL },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tprnt_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0, NULL },\n"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_SETLIST
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
name|cons_type
operator|++
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|==
name|NULL
operator|&&
name|type
operator|!=
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:YP_SETLIST:NULL varexp pointer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSET_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSET_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
else|else
name|prte_off
argument_list|(
name|fp
argument_list|,
literal|"SET_START"
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|ddflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:SETLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:YP_SETLIST:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_OFFSETS
if|if
condition|(
name|optfield
argument_list|(
name|y
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ OPTL, OFFSET(%s, optionals), 0, 0, NULL },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tprnt_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0, NULL },\n"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
comment|/* What is the difference ?? */
name|p1
operator|=
name|NULL
expr_stmt|;
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSEQOF_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSEQOF_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
else|else
name|prte_off
argument_list|(
name|fp
argument_list|,
literal|"SEQOF_START"
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:SEQTYPE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:YP_SEQTYPE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
name|tprnt_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DO_OFFSETS
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:SEQ OF: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, next), 0, 0, NULL },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0, NULL },\n"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_SETTYPE
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSETOF_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SSETOF_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
else|else
name|prte_off
argument_list|(
name|fp
argument_list|,
literal|"SETOF_START"
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:SETTYPE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:YP_SETTYPE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
name|tprnt_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:SET OF: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, next), 0, 0, NULL },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0, NULL },\n"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
name|tprnt_typ
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
break|break;
block|}
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|ptr
expr_stmt|;
comment|/* Generates an unused tags field - so beware */
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SCHOICE_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"SCHOICE_START"
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
else|else
name|prte_off
argument_list|(
name|fp
argument_list|,
literal|"CHOICE_START"
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
name|char
modifier|*
name|f1
decl_stmt|;
ifdef|#
directive|ifdef
name|DO_OFFSETS
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:CHOICE: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|f1
operator|=
literal|"offset"
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
operator|)
operator|&&
name|yp
operator|->
name|yp_id
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, OFFSET(%s, %s), 0, 0, \"%s\" },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, OFFSET(%s, %s), 0, 0, NULL },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
operator|)
operator|&&
name|yp
operator|->
name|yp_id
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, 0, 0, 0, \"%s\" },\n"
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, 0, 0, 0, NULL },\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntprnt_typ:CHOICE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ:YP_CHOICE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
name|tprnt_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0, NULL },\n"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tprnt_typ: yp_code = %d  not implemented\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
name|prte_off
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
else|else
name|prte_noff
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|yp
argument_list|,
name|ptr_tblidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
name|yp
operator|->
name|yp_flags
operator||=
name|YP_OPTCONTROL
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_aft_alist
operator|&&
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_prn
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_prn
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|fflags
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|7
block|,}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * generate tables for printing a contructed type  */
end_comment

begin_function
name|YP
name|tprnt_loop
parameter_list|(
name|fp
parameter_list|,
name|yp
parameter_list|,
name|id
parameter_list|,
name|type
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|YP
name|yp
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
for|for
control|(
init|;
name|yp
operator|!=
name|NULL
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
block|{
name|tprnt_typ
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|ddflt
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{DFLT_B,      %d,     0,      0 },\n"
argument_list|,
name|yp
operator|->
name|yp_default
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_NULL
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_REAL
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{DFLT_B,      0,      0,      0 },\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"ddflt:unknown type %d\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * print a Non offset table entry  */
end_comment

begin_macro
name|prte_noff
argument_list|(
argument|fp
argument_list|,
argument|type
argument_list|,
argument|yp
argument_list|,
argument|idx
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|idx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
name|char
modifier|*
name|typename
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|tag
operator|=
name|c_tag
argument_list|(
name|yp
argument_list|)
expr_stmt|;
name|flags
operator|=
name|c_class
argument_list|(
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrose3
condition|)
block|{
comment|/* need to append FL_PRTAG flag */
name|strncpy
argument_list|(
name|buf1
argument_list|,
name|flags
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|buf1
argument_list|,
literal|"|FL_PRTAG"
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|flags
operator|=
name|buf1
expr_stmt|;
block|}
if|if
condition|(
name|mrose1
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_id
expr_stmt|;
elseif|else
if|if
condition|(
name|mrose2
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_identifier
expr_stmt|;
else|else
name|typename
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|typename
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %d, %s, %s, \"%s\" },\n"
argument_list|,
name|type
argument_list|,
name|idx
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|,
name|typename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %d, %s, %s, NULL},\n"
argument_list|,
name|type
argument_list|,
name|idx
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print a Non offset table entry for an ETAG - special case  */
end_comment

begin_macro
name|prte_enoff
argument_list|(
argument|fp
argument_list|,
argument|type
argument_list|,
argument|yp
argument_list|,
argument|idx
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|idx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
name|char
modifier|*
name|typename
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|tag
operator|=
name|ec_tag
argument_list|(
name|yp
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ec_class
argument_list|(
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrose3
condition|)
block|{
comment|/* need to append FL_PRTAG flag */
name|strncpy
argument_list|(
name|buf1
argument_list|,
name|flags
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|buf1
argument_list|,
literal|"|FL_PRTAG"
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|flags
operator|=
name|buf1
expr_stmt|;
name|mrose3
operator|=
literal|0
expr_stmt|;
comment|/* don't want the next tag */
block|}
if|if
condition|(
name|mrose1
condition|)
block|{
name|typename
operator|=
name|yp
operator|->
name|yp_id
expr_stmt|;
name|mrose1
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mrose2
condition|)
block|{
name|typename
operator|=
name|yp
operator|->
name|yp_identifier
expr_stmt|;
name|mrose2
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|typename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|typename
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %d, %s, %s, \"%s\" },\n"
argument_list|,
name|type
argument_list|,
name|idx
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|,
name|typename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %d, %s, %s, NULL },\n"
argument_list|,
name|type
argument_list|,
name|idx
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print an offset table entry  */
end_comment

begin_macro
name|prte_off
argument_list|(
argument|fp
argument_list|,
argument|type
argument_list|,
argument|yp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|,
argument|idx
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|idx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
name|char
modifier|*
name|typename
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|tag
operator|=
name|c_tag
argument_list|(
name|yp
argument_list|)
expr_stmt|;
name|flags
operator|=
name|c_class
argument_list|(
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrose3
condition|)
block|{
comment|/* need to append FL_PRTAG flag */
name|strncpy
argument_list|(
name|buf1
argument_list|,
name|flags
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|buf1
argument_list|,
literal|"|FL_PRTAG"
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|flags
operator|=
name|buf1
expr_stmt|;
block|}
if|if
condition|(
name|mrose1
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_id
expr_stmt|;
elseif|else
if|if
condition|(
name|mrose2
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_identifier
expr_stmt|;
else|else
name|typename
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_OFFSETS
if|if
condition|(
name|typename
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, OFFSET(%s, %s), %s, %s, \"%s\" },\n"
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|,
name|typename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, OFFSET(%s, %s), %s, %s, NULL},\n"
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|typename
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %d, %s, %s, \"%s\" },\n"
argument_list|,
name|type
argument_list|,
name|idx
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|,
name|typename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %d, %s, %s, NULL},\n"
argument_list|,
name|type
argument_list|,
name|idx
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * handle the very complex task of defined types.  * Basically generating object calls  */
end_comment

begin_macro
name|pr_deftyp
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Predefined Universal Type */
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|,
modifier|*
name|univtyp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|univ_flags
operator|&
name|UNF_EXTMOD
condition|)
block|{
name|yp
operator|->
name|yp_module
operator|=
name|p
operator|->
name|univ_mod
expr_stmt|;
goto|goto
name|do_obj
goto|;
block|}
name|prte_univt
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|do_obj
label|:
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|prte_noff
argument_list|(
name|fp
argument_list|,
literal|"IMP_OBJ"
argument_list|,
name|yp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|prte_obj
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print an offset table entry for an OBJECT type entry  */
end_comment

begin_macro
name|prte_obj
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|obj
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
name|char
modifier|*
name|typename
decl_stmt|;
name|char
modifier|*
name|off
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|extflag
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|type
operator|=
literal|"OBJECT"
expr_stmt|;
else|else
name|type
operator|=
literal|"SOBJECT"
expr_stmt|;
name|obj
operator|=
name|proc_name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|extflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|type
operator|=
literal|"EXTOBJ"
expr_stmt|;
else|else
name|type
operator|=
literal|"SEXTOBJ"
expr_stmt|;
name|obj
operator|=
name|strp2name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|extflag
operator|=
literal|1
expr_stmt|;
block|}
name|flags
operator|=
name|c_class
argument_list|(
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrose3
condition|)
block|{
comment|/* need to append FL_PRTAG flag */
name|strncpy
argument_list|(
name|buf1
argument_list|,
name|flags
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|buf1
argument_list|,
literal|"|FL_PRTAG"
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|flags
operator|=
name|buf1
expr_stmt|;
block|}
if|if
condition|(
name|mrose1
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_id
expr_stmt|;
elseif|else
if|if
condition|(
name|mrose2
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_identifier
expr_stmt|;
else|else
name|typename
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_OFFSETS
if|if
condition|(
name|f
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"OFFSET(%s, %s)"
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|off
operator|=
name|buf2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|&&
operator|*
name|f
operator|==
literal|'&'
condition|)
block|{
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"OFFSET(%s, %s)"
argument_list|,
name|t
argument_list|,
name|f
operator|+
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|buf2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|off
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|typename
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %s, _Z%s, %s, \"%s\" },\n"
argument_list|,
name|type
argument_list|,
name|off
argument_list|,
name|obj
argument_list|,
name|flags
argument_list|,
name|typename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %s, _Z%s, %s, NULL},\n"
argument_list|,
name|type
argument_list|,
name|off
argument_list|,
name|obj
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|extflag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ EXTMOD, %d, 0, 0, NULL },\n"
argument_list|,
name|gen_modref
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print an table entry for Universal type with the given entry  */
end_comment

begin_macro
name|prte_univt
argument_list|(
argument|fp
argument_list|,
argument|p
argument_list|,
argument|yp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|tag
decl_stmt|;
name|int
name|class
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
name|char
modifier|*
name|typename
decl_stmt|;
name|char
modifier|*
name|off
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf3
argument_list|,
literal|"S%s"
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|)
expr_stmt|;
name|type
operator|=
name|buf3
expr_stmt|;
block|}
else|else
name|type
operator|=
name|p
operator|->
name|univ_tab
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
block|{
name|tag
operator|=
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
expr_stmt|;
name|class
operator|=
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
name|p
operator|->
name|univ_id
expr_stmt|;
name|class
operator|=
name|p
operator|->
name|univ_class
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|buf1
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|class
argument_list|)
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|flags
operator|=
name|buf1
expr_stmt|;
if|if
condition|(
name|mrose3
condition|)
block|{
comment|/* need to append FL_PRTAG flag */
name|strncat
argument_list|(
name|buf1
argument_list|,
literal|"|FL_PRTAG"
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mrose1
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_id
expr_stmt|;
elseif|else
if|if
condition|(
name|mrose2
condition|)
name|typename
operator|=
name|yp
operator|->
name|yp_identifier
expr_stmt|;
else|else
name|typename
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_OFFSETS
if|if
condition|(
name|f
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"OFFSET(%s, %s)"
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|off
operator|=
name|buf2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|&&
operator|*
name|f
operator|==
literal|'&'
condition|)
block|{
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"OFFSET(%s, %s)"
argument_list|,
name|t
argument_list|,
name|f
operator|+
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|buf2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|off
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|typename
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %s, %d, %s, \"%s\" },\n"
argument_list|,
name|type
argument_list|,
name|off
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|,
name|typename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, %s, %d, %s, NULL},\n"
argument_list|,
name|type
argument_list|,
name|off
argument_list|,
name|tag
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate the table entry for a value passing defined type which  * is equivalent to the given primative type  */
end_comment

begin_macro
name|gen_pentry
argument_list|(
argument|fp
argument_list|,
argument|oyp
argument_list|,
argument|yp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|oyp
decl_stmt|,
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
name|s
init|=
name|oyp
operator|->
name|yp_prfexp
decl_stmt|;
comment|/* type of value passing */
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
operator|&&
name|s
operator|!=
literal|'q'
operator|&&
name|s
operator|!=
literal|'a'
condition|)
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"gen_ventry: must specify a field for primative value- not %s\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* can't get id from in here - yet */
block|if (yp->yp_code == YP_BITLIST) { 	idx = addptr (modsym(mymodule, yp->yp_varexp ? yp -> yp_varexp : id,                                     "bits"));     } else
endif|#
directive|endif
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
literal|'q'
case|:
comment|/* [[ q parm->qbufptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OCT
condition|)
name|warning
argument_list|(
literal|"qbuf pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"SOCTETSTRING"
expr_stmt|;
else|else
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* [[ s ptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OCT
condition|)
name|warning
argument_list|(
literal|"string pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"T_STRING"
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* [[ o ptr $ length ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OCT
condition|)
name|warning
argument_list|(
literal|"octet/length pair passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_PTR"
expr_stmt|;
name|prte_off
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"gen_ventry:OCT: must specify a field [[ s .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_LEN"
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* [[ x ptr $ length ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BIT
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BITLIST
condition|)
name|warning
argument_list|(
literal|"bit string/length pair passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_PTR"
expr_stmt|;
name|prte_off
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:BIT: must specify a field [[ x .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_LEN"
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* [[ r REAL ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_REAL
condition|)
name|warning
argument_list|(
literal|"Real passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"REALTYPE"
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* [[ i INTEGER ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_INT
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_INTLIST
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_ENUMLIST
condition|)
name|warning
argument_list|(
literal|"integer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"INTEGER"
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* [[ t Bitvector ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BIT
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BITLIST
condition|)
name|warning
argument_list|(
literal|"Bitvector (PE) passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_varexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"BITSTRING"
expr_stmt|;
else|else
name|p1
operator|=
literal|"SBITSTRING"
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* [[ b BOOLEAN ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BOOL
condition|)
name|warning
argument_list|(
literal|"Boolean passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BOOLEAN"
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* [[ O Object Identifier ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OID
condition|)
name|warning
argument_list|(
literal|"Object Identifier pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OBJID"
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* [[ a ANY ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_ANY
condition|)
name|warning
argument_list|(
literal|"PE pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"SANY"
expr_stmt|;
else|else
name|p1
operator|=
literal|"ANY"
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|"gen_vident:unknown Value passed %d\n"
argument_list|,
operator|(
name|int
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
name|prte_off
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|yp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

