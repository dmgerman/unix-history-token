begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pepsy.c - table driven posy/pepy replacement system */
end_comment

begin_comment
comment|/* OPEN QUESTIONS:  	How to do smarter DEFAULT determination for the other types and NULLs  	Perhaps pull-up primitive IDentifiers  	Abort a CHOICE encoding if the structure is empty   				  HEURISTICS     1. LANGUAGE SIMPLIFICATIONS:   	Pull-up uni-member SEQUENCEs/SETs/CHOICEs      2. LANGUAGE ASSUMPTIONS:  	Unique tags to avoid conflicts for internal structures (-h1 option)      3. STYLE ISSUES:  	SEQUENCE/SET OF Type should have Type be an ID for nicer naming  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/pepsy.c,v 7.12 91/02/22 09:49:38 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/pepsy/RCS/pepsy.c,v 7.12 91/02/22 09:49:38 mrose Interim $  *  *  * $Log:	pepsy.c,v $  * Revision 7.12  91/02/22  09:49:38  mrose  * Interim 6.8  *   * Revision 7.11  91/01/24  14:51:00  mrose  * update  *   * Revision 7.10  91/01/08  12:50:24  mrose  * update  *   * Revision 7.9  90/12/23  17:24:58  mrose  * patches  *   * Revision 7.8  90/12/11  10:33:57  mrose  * sync  *   * Revision 7.7  90/11/20  15:27:21  mrose  * update  *   * Revision 7.6  90/11/11  10:54:05  mrose  * update  *   * Revision 7.5  90/11/04  19:17:13  mrose  * update  *   * Revision 7.4  90/10/23  20:43:04  mrose  * update  *   * Revision 7.3  90/09/07  17:34:20  mrose  * touch-up  *   * Revision 7.2  90/08/08  14:14:28  mrose  * update  *   * Revision 7.1  90/07/09  14:52:50  mrose  * sync  *   * Revision 7.0  90/07/01  19:54:25  mrose  * *** empty log message ***  *   * Revision 7.3  90/02/23  17:50:09  mrose  * update  *   * Revision 7.2  90/02/19  13:09:35  mrose  * update  *   * Revision 7.1  90/01/11  18:37:05  mrose  * real-sync  *   * Revision 7.0  89/11/23  22:11:59  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"pepsydefs.h"
end_include

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_define
define|#
directive|define
name|SVAL
parameter_list|(
name|s
parameter_list|)
value|((s) ? (s) : "")
end_define

begin_define
define|#
directive|define
name|PARVAL
parameter_list|(
name|s
parameter_list|)
value|((s) ? (s) : "parm")
end_define

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't so all modes by default */
end_comment

begin_decl_stmt
name|int
name|Cflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* posy */
end_comment

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pepy compat ... */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bflag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  .. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|iflag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i file => #include users file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|module_actions
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pepydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doexternals
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linepos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|p_debug
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|options
index|[
name|NOPTIONS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|eval
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mymodule
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OID
name|mymoduleid
init|=
name|NULLOID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|modulename
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yysection
init|=
name|YP_DECODER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencpref
init|=
literal|"encode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecpref
init|=
literal|"decode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfpref
init|=
literal|"print"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencdflt
init|=
literal|"encode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecdflt
init|=
literal|"decode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfdflt
init|=
literal|"print"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|classes
index|[]
init|=
block|{
literal|"UNIVERSAL "
block|,
literal|"APPLICATION "
block|,
literal|""
block|,
literal|"PRIVATE "
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tags
index|[]
init|=
block|{
literal|""
block|,
literal|"BOOLEAN"
block|,
literal|"INTEGER"
block|,
literal|"INTEGER"
block|,
literal|"BIT STRING"
block|,
literal|"BIT STRING"
block|,
literal|"OCTET STRING"
block|,
literal|"NULL"
block|,
literal|"SEQUENCE"
block|,
literal|"SEQUENCE OF"
block|,
literal|"SEQUENCE"
block|,
literal|"SET"
block|,
literal|"SET OF"
block|,
literal|"SET"
block|,
literal|"CHOICE"
block|,
literal|"ANY"
block|,
literal|"OBJECT IDENTIFIER"
block|,
literal|""
block|,
literal|"ENUMERATED"
block|,
literal|"REAL"
block|,
literal|""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tuple
name|tuples
index|[]
init|=
block|{
name|YP_BOOL
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_BOOL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_BOOL
block|,
name|YP_INT
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_INT"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_INT
block|,
name|YP_INTLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_INT"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_INT
block|,
name|YP_BIT
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_BITS"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_BITS
block|,
name|YP_BITLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_BITS"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_BITS
block|,
name|YP_OCT
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_OCTS"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_OCTS
block|,
name|YP_NULL
block|,
literal|"PE_CLASS_UNIV"
block|,
name|NULLCP
block|,
literal|"PE_PRIM_NULL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_NULL
block|,
name|YP_OID
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_OID"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_OID
block|,
name|YP_SEQ
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SEQ"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SEQ
block|,
name|YP_SEQTYPE
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SEQ"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SEQ
block|,
name|YP_SEQLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SEQ"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SEQ
block|,
name|YP_SET
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SET"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SET
block|,
name|YP_SETTYPE
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SET"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SET
block|,
name|YP_SETLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_CONS"
block|,
literal|"PE_CONS_SET"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_SET
block|,
name|YP_ENUMLIST
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_ENUM"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_ENUM
block|,
name|YP_REAL
block|,
literal|"PE_CLASS_UNIV"
block|,
literal|"PE_FORM_PRIM"
block|,
literal|"PE_PRIM_REAL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_REAL
block|,
name|YP_UNDF
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|autogen
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sysin
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysout
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysdef
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysact
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fdef
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|modlist
block|{
name|char
modifier|*
name|md_module
decl_stmt|;
name|OID
name|md_oid
decl_stmt|;
name|int
name|md_flags
decl_stmt|;
define|#
directive|define
name|MDF_SEEN
value|1
comment|/* Seen this module */
name|struct
name|modlist
modifier|*
name|md_next
decl_stmt|;
block|}
name|modlist
operator|,
typedef|*
name|MD
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLMD
value|((MD) 0)
end_define

begin_decl_stmt
specifier|static
name|MD
name|mymodules
init|=
name|NULLMD
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|symlist
block|{
name|char
modifier|*
name|sy_encpref
decl_stmt|;
name|char
modifier|*
name|sy_decpref
decl_stmt|;
name|char
modifier|*
name|sy_prfpref
decl_stmt|;
name|char
modifier|*
name|sy_module
decl_stmt|;
name|char
modifier|*
name|sy_name
decl_stmt|;
name|YP
name|sy_type
decl_stmt|;
name|struct
name|symlist
modifier|*
name|sy_next
decl_stmt|;
block|}
name|symlist
operator|,
typedef|*
name|SY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLSY
value|((SY) 0)
end_define

begin_decl_stmt
name|SY
name|mysymbols
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gensym
argument_list|()
decl_stmt|,
modifier|*
name|modsym
argument_list|()
decl_stmt|,
modifier|*
name|array
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|my_strcat
argument_list|()
decl_stmt|,
modifier|*
name|gfree
argument_list|()
decl_stmt|,
modifier|*
name|concat
argument_list|()
decl_stmt|,
modifier|*
name|my_new_str
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|MD
name|lookup_module
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|SY
name|new_symbol
argument_list|()
decl_stmt|,
name|add_symbol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|double
name|val2real
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prime_default
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* to keep lint happy */
end_comment

begin_function_decl
name|FILE
modifier|*
name|open_ph_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|YP
name|lookup_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|YT
name|lookup_tag
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|pepsyversion
operator|+
name|strlen
argument_list|(
literal|"pepsy "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pepsy %s\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sysout
index|[
literal|0
index|]
operator|=
name|sysdef
index|[
literal|0
index|]
operator|=
name|sysact
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|cp
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-A"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Aflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|aflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dflag
operator|++
operator|,
name|fflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"-h"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
block|{
name|hflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|1
operator|||
name|i
operator|>=
name|NOPTIONS
condition|)
goto|goto
name|usage
goto|;
name|hflag
operator|++
operator|,
name|options
index|[
name|i
index|]
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-m"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-i"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|iflag
operator|=
operator|*
name|argv
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sysin
condition|)
block|{
name|usage
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: pepsy [-A] [-a] [-d] [-f] [-h] [-s] module.py\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
name|NULL
condition|)
goto|goto
name|usage
goto|;
name|sysin
operator|=
literal|""
expr_stmt|;
block|}
name|sysin
operator|=
name|cp
expr_stmt|;
block|}
switch|switch
condition|(
name|pepydebug
operator|=
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"PEPSYTEST"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|0
condition|)
block|{
case|case
literal|2
case|:
name|yydebug
operator|++
expr_stmt|;
comment|/* fall */
case|case
literal|1
case|:
name|sflag
operator|++
expr_stmt|;
comment|/*   .. */
case|case
literal|0
case|:
break|break;
block|}
if|if
condition|(
name|sysin
operator|==
name|NULLCP
condition|)
name|sysin
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|sysin
operator|&&
name|freopen
argument_list|(
name|sysin
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to read "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysin
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sysout
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|sysout
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
operator|&&
name|freopen
argument_list|(
name|sysout
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to write "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|')'
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|++
init|;
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|dp
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|autogen
argument_list|,
literal|"pepsy %*.*s"
argument_list|,
name|cp
operator|-
name|dp
argument_list|,
name|cp
operator|-
name|dp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|initoidtbl
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|yyparse
argument_list|()
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_expr_stmt
name|yyerror
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|yyerror_aux
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysdef
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysdef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysact
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysact
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|warning
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buffer2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer2
argument_list|,
literal|"Warning: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|yyerror_aux
argument_list|(
name|buffer2
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|warning
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warning
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|yyerror_aux
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eval
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type %s: "
argument_list|,
name|eval
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %d: "
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eval
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last token read was \"%s\"\n"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|myyerror
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|myyerror
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|myyerror
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
specifier|static
name|pyyerror
argument_list|(
argument|va_alist
argument_list|)
name|va_dcl
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|;
specifier|register
name|YP
name|yp
block|;
name|va_list
name|ap
block|;
name|va_start
argument_list|(
name|ap
argument_list|)
block|;
name|yp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|YP
argument_list|)
block|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
block|;
name|va_end
argument_list|(
name|ap
argument_list|)
block|;
name|yyerror_aux
argument_list|(
name|buffer
argument_list|)
block|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
block|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|sysdef
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysdef
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|*
name|sysact
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysact
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
unit|static
name|pyyerror
argument_list|(
argument|yp
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pyyerror
argument_list|(
name|yp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|yyprint
argument_list|(
argument|s
argument_list|,
argument|f
argument_list|,
argument|top
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|nameoutput
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|outputlinelen
init|=
literal|79
decl_stmt|;
specifier|static
name|int
name|didf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sflag
operator|||
operator|!
name|s
condition|)
return|return;
if|if
condition|(
name|f
operator|&&
name|didf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s includes:"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|linepos
operator|=
operator|(
name|nameoutput
operator|=
name|strlen
argument_list|(
name|mymodule
argument_list|)
operator|+
literal|10
operator|)
operator|+
literal|1
expr_stmt|;
name|didf
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nameoutput
operator|||
name|top
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|nameoutput
operator|=
operator|(
name|linepos
operator|=
name|strlen
argument_list|(
name|mymodule
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
define|#
directive|define
name|section
parameter_list|(
name|flag
parameter_list|,
name|prefix
parameter_list|)
define|\
value|if (yysection& (flag)) { \             fprintf (stderr, " %s", (prefix)); \             linepos += strlen (prefix) + 1; \         } \         else \             fprintf (stderr, " none"), linepos += 5
name|section
argument_list|(
name|YP_ENCODER
argument_list|,
name|yyencpref
argument_list|)
expr_stmt|;
name|section
argument_list|(
name|YP_DECODER
argument_list|,
name|yydecpref
argument_list|)
expr_stmt|;
name|section
argument_list|(
name|YP_PRINTER
argument_list|,
name|yyprfpref
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|linepos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|top
condition|)
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
operator|(
name|f
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|linepos
operator|!=
name|nameoutput
condition|)
if|if
condition|(
name|len
operator|+
name|linepos
operator|+
literal|1
operator|>
name|outputlinelen
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%*s"
argument_list|,
name|linepos
operator|=
name|nameoutput
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
operator|,
name|linepos
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
condition|?
literal|"(%s)"
else|:
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|linepos
operator|+=
name|len
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS1 */
end_comment

begin_macro
name|pass1
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|pass1_type
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|,
name|yp
argument_list|)
specifier|register
name|char
operator|*
name|encpref
operator|,
operator|*
name|decpref
operator|,
operator|*
name|prfpref
operator|,
operator|*
name|mod
operator|,
operator|*
name|id
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|lookup_type
argument_list|(
name|mod
argument_list|,
name|id
argument_list|)
condition|)
comment|/* no duplicate entries, please... */
return|return;
if|if
condition|(
name|pepydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
operator|)
condition|)
name|yyprint
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|mysymbols
operator|=
name|add_symbol
argument_list|(
name|mysymbols
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS2 */
end_comment

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
name|modsym_aux
argument_list|(
name|mymodule
argument_list|,
name|modulename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysdef
argument_list|,
literal|"%s-types.h"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdef
operator|=
name|fopen
argument_list|(
name|sysdef
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|sysdef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"/* automatically generated by %s, do not edit! */\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifndef\t_module_%s_defined_\n"
argument_list|,
name|modulename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t_module_%s_defined_\n\n"
argument_list|,
name|modulename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifndef\tPEPSY_VERSION\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\tPEPSY_VERSION\t\t%d\n"
argument_list|,
name|PEPSY_VERSION_NUMBER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
block|{
define|#
directive|define
name|NFILES
value|5
name|char
modifier|*
name|files
index|[
name|NFILES
index|]
decl_stmt|;
comment|/* { "psap.h", "pepsy.h", "UNIV-types.h", (char *)0 }; */
name|int
name|last
init|=
literal|0
decl_stmt|;
comment|/* last slot available in files */
name|files
index|[
name|last
operator|++
index|]
operator|=
literal|"psap.h"
expr_stmt|;
name|files
index|[
name|last
operator|++
index|]
operator|=
literal|"pepsy.h"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mymodule
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
block|{
name|files
index|[
name|last
operator|++
index|]
operator|=
literal|"pepsy/UNIV-types.h"
expr_stmt|;
block|}
name|files
index|[
name|last
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|doincl
argument_list|(
name|fdef
argument_list|,
name|files
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NFILES
block|}
if|if
condition|(
name|mflag
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifndef\tPEPYPATH\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include<isode/pepsy/%s%s>\n"
argument_list|,
name|mymodule
argument_list|,
name|HFILE1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include \"%s%s\"\n"
argument_list|,
name|mymodule
argument_list|,
name|HFILE1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include \"%s%s\"\n"
argument_list|,
name|mymodule
argument_list|,
name|HFILE1
argument_list|)
expr_stmt|;
comment|/* User's #include file */
if|if
condition|(
name|iflag
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|iflag
argument_list|)
expr_stmt|;
block|}
comment|/*      * pull up some symbols       */
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
name|do_struct0
argument_list|(
name|yp
argument_list|,
name|eval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* dump out the references to the external types */
name|proc_extmod
argument_list|(
name|fdef
argument_list|)
expr_stmt|;
comment|/*      * generate the #define's for simple type definitions      */
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
name|do_struct1
argument_list|(
name|yp
argument_list|,
name|eval
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * generate the C structure definitions      */
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
name|do_struct2
argument_list|(
name|yp
argument_list|,
name|eval
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|peri_pass2
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fdef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fdef
argument_list|)
expr_stmt|;
name|write_ph_file
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sflag
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_struct0
argument_list|(
name|yp
argument_list|,
name|id
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
name|MD
name|md
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|components_pullup
argument_list|(
name|yp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
name|do_struct0
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
case|case
name|YP_SETLIST
case|:
name|choice_pullup
argument_list|(
name|yp
argument_list|,
name|yp
operator|->
name|yp_code
operator|==
name|YP_CHOICE
condition|?
name|CH_FULLY
else|:
name|CH_PARTIAL
argument_list|)
expr_stmt|;
comment|/* and fall */
case|case
name|YP_SEQLIST
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
name|do_struct0
argument_list|(
name|y
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|md
operator|=
name|lookup_module
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_modid
argument_list|)
operator|)
operator|==
name|NULLMD
operator|||
operator|(
name|md
operator|->
name|md_flags
operator|&
name|MDF_SEEN
operator|)
operator|==
literal|0
condition|)
block|{
name|addextmod
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
condition|)
name|md
operator|->
name|md_flags
operator||=
name|MDF_SEEN
expr_stmt|;
block|}
block|}
comment|/* correct for IMPLICIT Tag of a CHOICE or ANY if possible */
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_IMPLICIT
operator||
name|YP_TAG
operator|)
operator|)
operator|==
operator|(
name|YP_IMPLICIT
operator||
name|YP_TAG
operator|)
condition|)
block|{
name|yp
operator|->
name|yp_flags
operator|&=
operator|~
name|YP_IMPLICIT
expr_stmt|;
comment|/* clear it */
name|yp
operator|->
name|yp_flags
operator||=
name|comptag
argument_list|(
name|YP_IMPLICIT
argument_list|,
name|yp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|do_struct1
argument_list|(
name|yp
argument_list|,
name|id
argument_list|,
name|pullup
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|pullup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tPElement\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_BITLIST
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
operator|(
name|j
operator|=
name|val2int
argument_list|(
name|yv
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pyyerror
argument_list|(
name|yp
argument_list|,
literal|"invalid bit number in BIT STRING"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
name|i
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
condition|)
block|{
comment|/* NBBY */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t\"\\020"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|eval
argument_list|,
literal|"bits"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%o%s"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%oBIT%d"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|modsym_aux
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_%s\t%d\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|eval
argument_list|,
literal|"bit"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fflag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tpe_free\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tqbuf\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tqb_free\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tOIDentifier\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\toid_free\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
name|do_struct1
argument_list|(
name|y
argument_list|,
name|id
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall */
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|do_struct2
argument_list|(
name|yp
argument_list|,
name|id
argument_list|,
name|pullup
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|pullup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
name|int
name|flg
init|=
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQTYPE
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_SETTYPE
operator|)
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
name|do_struct2
argument_list|(
name|y
argument_list|,
name|id
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall */
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"struct %s {\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
name|pepsy
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"parm"
argument_list|,
name|id
argument_list|,
literal|"parm"
argument_list|,
name|flg
operator|&&
name|h2flag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s(parm)\\\n\t%s\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|,
name|gfree
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"parm"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_type1
argument_list|(
name|yp
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|id
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|direction
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|var
decl_stmt|,
modifier|*
name|action2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|varbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
specifier|register
name|YT
name|yt
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
name|yt
operator|=
name|yp
operator|->
name|yp_tag
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[%s%d]\n"
argument_list|,
name|classes
index|[
name|yt
operator|->
name|yt_class
index|]
argument_list|,
name|val2int
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|&&
name|yp
operator|->
name|yp_varexp
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|index
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|yyerror
argument_list|(
literal|"Bug in varexp!"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|varbuf
argument_list|,
literal|"%*.*s"
argument_list|,
name|ep
operator|-
name|yp
operator|->
name|yp_varexp
argument_list|,
name|ep
operator|-
name|yp
operator|->
name|yp_varexp
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s%s = %d; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_INT
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s%s = %d; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s%s = %d; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|dfl2int
argument_list|(
name|yp
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_REAL
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s%s = %g; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2real
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_NULL
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
operator|)
operator|==
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"IMPLICIT "
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s< "
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_COMPONENTS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"COMPONENTS OF "
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ENCRYPTED
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ENCRYPTED "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"BOOLEAN"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[b %s -> %s ]]"
else|:
literal|"\n%*s[[b %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_INT
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"INTEGER"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[i %s -> %s ]]"
else|:
literal|"\n%*s[[i %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_ENUMLIST
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ENUMERATED"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"INTEGER"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[i %s -> %s ]]\n%*s{\n"
else|:
literal|"\n%*s[[i %s%s ]]\n%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|level
operator|++
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s(%d)%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|,
name|yv
operator|->
name|yv_next
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"BIT STRING"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[x bit_parm = bitstr2strb (%s%s,&len) $ len]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{\n%*sfree (bit_parm);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
name|balloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_BITLIST
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"BIT STRING"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[x bit_parm = bitstr2strb (%s%s,&len) $ len]]\n%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|level
operator|++
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s(%d)%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|,
name|yv
operator|->
name|yv_next
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_DECODER
case|:
name|balloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_ENCODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{\n%*sfree (bit_parm);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_OCT
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"OCTET STRING"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[q %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[q %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_REAL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"REAL"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[r %s -> %s ]]"
else|:
literal|"\n%*s[[r %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[a %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETTYPE
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|->
name|yp_declexp
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%{ %s = %s; %%}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|SVAL
argument_list|(
name|y
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h2flag
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s<<n_parm = 0; "
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"n_parm< parm -> nelem; n_parm++>>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s<<n_%s = 0;\n%*sn_%s< %s -> nelem;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sn_%s++>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|top
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s<<; parm; parm = parm -> next>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s<<%s = %s%s;\n%*s%s;\n%*s%s = %s -> next>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_DECODER
case|:
if|if
condition|(
name|h2flag
condition|)
block|{
name|y
operator|=
name|yp
operator|->
name|yp_type
expr_stmt|;
name|xalloc
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|2
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|xalloc
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|top
condition|?
literal|"parm"
else|:
name|yp
operator|->
name|yp_declexp
argument_list|,
name|top
condition|?
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|eval
argument_list|,
literal|"type"
argument_list|)
else|:
name|yp
operator|->
name|yp_declexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|do_type1
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|ep
argument_list|,
literal|""
argument_list|,
name|NULLCP
argument_list|,
name|direction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{ "
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2flag
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"n_%s++;"
argument_list|,
name|top
condition|?
literal|"parm"
else|:
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|top
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"parm =&((*parm) -> next);"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s =&((*%s) -> next);"
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|action2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %%}"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETLIST
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
condition|)
name|xalloc
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
name|level
operator|+
literal|2
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s = %s;\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s =&(%s);\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
operator|&&
name|y
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|prime_default
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%}\n%*s{\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|||
operator|!
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|||
name|y
operator|->
name|yp_next
condition|)
block|{
name|var
operator|=
literal|""
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|do_type1
argument_list|(
name|y
argument_list|,
name|top
argument_list|,
name|level
operator|+
operator|(
operator|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|,
name|ep
argument_list|,
name|var
argument_list|,
name|NULLCP
argument_list|,
name|direction
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|y
operator|->
name|yp_next
condition|?
literal|",\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"CHOICE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|||
operator|!
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|||
name|y
operator|->
name|yp_next
condition|)
name|var
operator|=
literal|""
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
name|i
operator|++
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
if|if
condition|(
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s = %s;\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%}\n%*s"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|var
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<1>>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|top
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<parm -> offset>>"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<%s -> offset>>"
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|i
condition|?
literal|"\n%*s{\n"
else|:
literal|" {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|xalloc
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|"(*(%s)) -> offset = "
argument_list|,
name|top
condition|?
literal|"parm"
else|:
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|||
operator|!
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|||
name|y
operator|->
name|yp_next
condition|)
name|top
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|top
condition|)
name|cp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|cp
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s;"
argument_list|,
name|y
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
name|do_type1
argument_list|(
name|y
argument_list|,
name|top
argument_list|,
name|level
operator|+
literal|1
argument_list|,
literal|"choice"
argument_list|,
name|var
argument_list|,
name|cp
condition|?
name|buffer
else|:
name|NULLCP
argument_list|,
name|direction
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|y
operator|->
name|yp_next
condition|?
literal|",\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"OBJECT IDENTIFIER"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[O %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[p %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s[[p&(%s%s)]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown type: %d"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action2
condition|)
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
condition|)
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
condition|)
break|break;
comment|/* else fall */
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{ %s %%}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*sOPTIONAL"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
condition|)
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_NULL
case|:
case|case
name|YP_REAL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<%s -> optionals& %s>>"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
default|default:
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<%s%s>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*sDEFAULT "
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
condition|)
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<%s%s%s>>"
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<%s%s != %d>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|dfl2int
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<< %s%s != %g>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2real
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
default|default:
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<<%s%s>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
operator|&&
name|yp
operator|->
name|yp_varexp
operator|&&
operator|(
name|cp
operator|=
name|index
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"-> "
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"(*%s) -> %s"
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|TYPE HANDLING */
end_comment

begin_function
name|YP
name|lookup_type
parameter_list|(
name|mod
parameter_list|,
name|id
parameter_list|)
specifier|register
name|char
modifier|*
name|mod
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|mod
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mod
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sy
operator|->
name|sy_type
return|;
block|}
return|return
name|NULLYP
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|pepsy
argument_list|(
name|yp
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|id
argument_list|,
name|val
argument_list|,
name|var
argument_list|,
name|arrayflg
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|level
decl_stmt|,
name|arrayflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|val
decl_stmt|,
modifier|*
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|newid
decl_stmt|,
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Preserve the name of the field */
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_ptrname
condition|?
name|yp
operator|->
name|yp_ptrname
else|:
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*schar    %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sinteger     %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_INT
condition|)
break|break;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|modsym_aux
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_%s\t%d\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"int"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sPE      %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BITLIST
condition|)
break|break;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
operator|(
name|j
operator|=
name|val2int
argument_list|(
name|yv
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pyyerror
argument_list|(
name|yp
argument_list|,
literal|"invalid bit number in BIT STRING"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
name|i
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
condition|)
block|{
comment|/* NBBY */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t\"\\020"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"bits"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%o%s"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%oBIT%d"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|modsym_aux
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_%s\t%d\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"bit"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_REAL
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sdouble    %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct qbuf *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_NULL
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*schar    %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sPE      %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETTYPE
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|buf2
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|dp
condition|)
name|cp
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|=
name|buf1
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
name|newid
operator|=
name|yp
operator|->
name|yp_ptrname
condition|?
name|yp
operator|->
name|yp_ptrname
else|:
name|id
expr_stmt|;
if|if
condition|(
name|h2flag
operator|&&
name|top
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sinteger\tnelem;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|id
operator|=
name|yp
operator|->
name|yp_structname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Hflag
condition|)
name|id
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2flag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sinteger\tnelem;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
name|yp
operator|->
name|yp_declexp
operator|=
name|new_string
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
operator|&&
name|hflag
condition|)
block|{
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_identifier
argument_list|,
name|cp
operator|=
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2flag
condition|)
block|{
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"[n_%s]"
argument_list|,
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf3
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_IDEFINED
case|:
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|h2flag
condition|?
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
else|:
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" -> %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|pepsy
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|cp
argument_list|,
name|ep
argument_list|,
name|buf2
argument_list|,
name|h2flag
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_code
operator|!=
name|YP_IDEFINED
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h2flag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n%*sstruct %s *next;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|top
condition|?
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|val
argument_list|,
literal|"type"
argument_list|)
else|:
name|id
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s} *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|newid
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Hflag
condition|)
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETLIST
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|buf2
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|dp
condition|)
name|cp
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|=
name|buf1
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
name|newid
operator|=
name|yp
operator|->
name|yp_ptrname
condition|?
name|yp
operator|->
name|yp_ptrname
else|:
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|id
operator|=
name|yp
operator|->
name|yp_structname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Hflag
condition|)
name|id
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_declexp
operator|=
name|new_string
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|,
name|i
operator|=
literal|0
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_REAL
case|:
case|case
name|YP_NULL
case|:
block|{
name|char
name|obuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sinteger     optionals;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|cp
operator|=
name|buf1
argument_list|)
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%s_%s"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"opt"
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s (0%08o)\n"
argument_list|,
name|obuf
argument_list|,
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASN1_OUTPUT
name|y
operator|->
name|yp_optcontrol
operator|=
name|new_string
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_flags
operator||=
name|YP_OPTCONTROL
expr_stmt|;
endif|#
directive|endif
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|yyerror
argument_list|(
literal|"too many optionals in structure"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|,
name|i
operator|=
literal|1
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|cp
operator|=
name|buf1
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" -> %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|pepsy
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|cp
argument_list|,
name|ep
argument_list|,
name|buf2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
operator|)
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_next
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*schar    dummy;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s} *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|newid
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Hflag
condition|)
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_CHOICE
case|:
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|buf2
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|dp
condition|)
name|cp
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|=
name|buf1
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
name|newid
operator|=
name|yp
operator|->
name|yp_ptrname
condition|?
name|yp
operator|->
name|yp_ptrname
else|:
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|id
operator|=
name|yp
operator|->
name|yp_structname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Hflag
condition|)
name|id
operator|=
name|gensym
argument_list|(
literal|"choice"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_declexp
operator|=
name|new_string
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sint         offset;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
condition|)
name|cp
operator|=
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|val
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|id
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ep
operator|=
name|buf1
argument_list|,
literal|"%s_"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|strlen
argument_list|(
name|ep
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|,
name|i
operator|=
literal|1
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|ep
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ep
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_offset
operator|=
name|new_string
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t%d\n"
argument_list|,
name|y
operator|->
name|yp_offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n%*sunion {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|cp
operator|=
name|buf1
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|gensym
argument_list|(
literal|"choice"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" -> un.%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|pepsy
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|cp
argument_list|,
literal|"choice"
argument_list|,
name|buf2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* prefix yp_varexp (field name) with un. so we will generate offsets that      * allow for the union all the CHOICE fields are imbedded in      */
name|t
operator|=
name|y
operator|->
name|yp_varexp
expr_stmt|;
name|y
operator|->
name|yp_varexp
operator|=
name|my_strcat
argument_list|(
literal|"un."
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
operator|)
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_next
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s}       un;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s} *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|newid
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Hflag
condition|)
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_OID
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sOID     %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|{
comment|/* Predefined Universal Type */
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s%s%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|p
operator|->
name|univ_data
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                     if (fflag)                         ferr(1, "pepsy:YP_IDEFINED:fflag not implemented\n"); 		    */
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"type"
argument_list|)
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown type: %d"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|printag
argument_list|(
name|yp
argument_list|,
name|level
argument_list|,
name|pullup
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pullup
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s/* "
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s."
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pullup
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|" pulled up from %s"
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|xalloc
argument_list|(
name|yp
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|arg
argument_list|,
name|type
argument_list|,
name|brackets
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|level
decl_stmt|,
name|brackets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|didone
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
if|if
condition|(
name|hflag
operator|&&
operator|!
name|arg
operator|&&
operator|!
name|type
condition|)
return|return;
name|didone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&&
name|type
condition|)
block|{
if|if
condition|(
name|brackets
operator|&&
operator|!
name|didone
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
operator|,
name|didone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|h2flag
operator|&&
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQTYPE
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_SETTYPE
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s{\n%*sPE      xx_pe = prim2%s ($$);\n\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQTYPE
condition|?
literal|"seq"
else|:
literal|"set"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sn_%s = xx_pe -> pe_cardinal> 0 "
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"? xx_pe -> pe_cardinal : 0;\n%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sif ((*(%s) = (struct %s *)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*scalloc (1 + (unsigned) n_%s, sizeof **(%s)"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|")) == ((struct %s *) 0)) {\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s(*%s) -> nelem = n_%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sn_%s = 0;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sif ((*(%s) = (struct %s *)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*scalloc (1, sizeof **(%s))) == ((struct %s *) 0)) {\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|top
condition|)
break|break;
case|case
name|YP_CHOICE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|h2flag
operator|&&
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_SETLIST
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQLIST
operator|)
condition|)
block|{
comment|/* include allocation here - no chance later */
if|if
condition|(
name|brackets
operator|&&
operator|!
name|didone
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
operator|,
name|didone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s =&(%s);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
name|xalloc
argument_list|(
name|y
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* and continue ... */
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|brackets
operator|&&
operator|!
name|didone
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
operator|,
name|didone
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s =&(%s);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|brackets
operator|&&
name|didone
condition|)
block|{
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|balloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|action2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sif ((%s%s = prim2bit (pe_cpy ($$))) == NULLPE) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_expr_stmt
specifier|static
name|qalloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|action2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sif ((%s%s = str2qb ($$, $$_len, 1)) == ((struct qbuf *) 0)) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%*s%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%%}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * now we don't pull up things if they have actions associated with them  * this should be okay for those who want exact posy equivalence and  * yet keep those who want the pepy support able to have multiple  * actions in CHOICE { CHOICE {} } and such like  */
end_comment

begin_expr_stmt
specifier|static
name|choice_pullup
argument_list|(
name|yp
argument_list|,
name|partial
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
modifier|*
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
modifier|*
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|z3
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|yp
operator|->
name|yp_type
init|;
name|y
operator|=
operator|*
name|x
condition|;
name|x
operator|=
operator|&
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_BOUND
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
operator|(
name|z
operator|=
name|lookup_type
argument_list|(
name|y
operator|->
name|yp_module
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULLYP
operator|||
name|z
operator|->
name|yp_code
operator|!=
name|YP_CHOICE
condition|)
continue|continue;
if|if
condition|(
name|z
operator|->
name|yp_control_act
operator|||
name|z
operator|->
name|yp_bef_alist
operator|||
name|z
operator|->
name|yp_aft_alist
condition|)
continue|continue;
name|choice_pullup
argument_list|(
name|z2
operator|=
name|copy_type
argument_list|(
name|z
argument_list|)
argument_list|,
name|CH_FULLY
argument_list|)
expr_stmt|;
goto|goto
name|patch
goto|;
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|y
operator|->
name|yp_control_act
operator|||
name|y
operator|->
name|yp_bef_alist
operator|||
name|y
operator|->
name|yp_aft_alist
condition|)
continue|continue;
name|choice_pullup
argument_list|(
name|z2
operator|=
name|copy_type
argument_list|(
name|y
argument_list|)
argument_list|,
name|CH_FULLY
argument_list|)
expr_stmt|;
name|patch
label|:
empty_stmt|;
if|if
condition|(
name|partial
condition|)
block|{
operator|*
name|x
operator|=
name|z2
expr_stmt|;
name|z2
operator|->
name|yp_next
operator|=
name|y
operator|->
name|yp_next
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
continue|continue;
block|}
name|z
operator|=
name|z3
operator|=
name|z2
operator|->
name|yp_type
expr_stmt|;
for|for
control|(
name|z1
operator|=
operator|&
name|z
operator|->
name|yp_next
init|;
name|z2
operator|=
operator|*
name|z1
condition|;
name|z1
operator|=
operator|&
name|z2
operator|->
name|yp_next
control|)
name|z3
operator|=
name|z2
expr_stmt|;
operator|*
name|z1
operator|=
name|y
operator|->
name|yp_next
expr_stmt|;
operator|*
name|x
operator|=
name|z
expr_stmt|;
name|y
operator|=
name|z3
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|components_pullup
argument_list|(
name|yp
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|YP
modifier|*
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|z1
decl_stmt|,
name|z2
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|yp
operator|->
name|yp_type
init|;
name|y
operator|=
operator|*
name|x
condition|;
name|x
operator|=
operator|&
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_COMPONENTS
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|z
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
operator|(
name|z
operator|=
name|lookup_type
argument_list|(
name|y
operator|->
name|yp_module
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
block|{
name|warning
argument_list|(
literal|"COMPONENTS OF target \"%s\" is undefined"
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|z
operator|->
name|yp_code
condition|)
block|{
name|warning
argument_list|(
literal|"COMPONENTS OF target \"%s\" is wrong type, should be %s"
argument_list|,
name|y
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|?
name|y
operator|->
name|yp_identifier
else|:
name|y
operator|->
name|yp_id
condition|?
name|y
operator|->
name|yp_id
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQLIST
condition|?
literal|"SEQUENCE"
else|:
literal|"SET"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|z
operator|->
name|yp_type
operator|==
name|NULLYP
condition|)
continue|continue;
name|components_pullup
argument_list|(
name|z
operator|=
name|copy_type
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|z2
operator|=
name|z
operator|->
name|yp_type
expr_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|z
operator|->
name|yp_type
init|;
name|z1
operator|=
operator|*
name|x
condition|;
name|x
operator|=
operator|&
name|z1
operator|->
name|yp_next
control|)
name|z2
operator|=
name|z1
expr_stmt|;
operator|*
name|x
operator|=
name|y
operator|->
name|yp_next
expr_stmt|;
name|y
operator|=
name|z2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|VALUE HANDLING */
end_comment

begin_function
specifier|static
name|int
name|val2int
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|double
name|val2real
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_REAL
case|:
return|return
name|yv
operator|->
name|yv_real
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|val2prf
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
comment|/* will this REALLY work??? */
name|do_type1
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
name|yv
operator|->
name|yv_number
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NUMBER
case|:
if|if
condition|(
name|yv
operator|->
name|yv_named
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_REAL
case|:
name|dump_real
argument_list|(
name|yv
operator|->
name|yv_real
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_module
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|y
operator|->
name|yv_next
condition|?
literal|", "
else|:
literal|" "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NULL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|dump_real
argument_list|(
argument|r
argument_list|)
name|double
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|BSD44
specifier|extern
name|char
modifier|*
name|ecvt
parameter_list|()
function_decl|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|decpt
decl_stmt|,
name|sign
decl_stmt|;
name|cp
operator|=
name|ecvt
argument_list|(
name|r
argument_list|,
literal|20
argument_list|,
operator|&
name|decpt
argument_list|,
operator|&
name|sign
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* cp gets overwritten by printf */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"{ %s%s, 10, %d }"
argument_list|,
name|sign
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|sbuf
argument_list|,
name|decpt
operator|-
name|strlen
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%.19e"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|dp
operator|=
name|sbuf
operator|)
operator|==
literal|'-'
condition|)
name|sp
operator|=
literal|"-"
operator|,
name|dp
operator|++
expr_stmt|;
else|else
name|sp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|cp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"{ 0, 10, 0 } -- %s --"
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|++
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"{ %s%c%s, 10, %d }"
argument_list|,
name|sp
argument_list|,
operator|*
name|dp
argument_list|,
name|dp
operator|+
literal|2
argument_list|,
name|atoi
argument_list|(
name|cp
argument_list|)
operator|-
name|strlen
argument_list|(
name|dp
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dfl2int
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|,
name|y
decl_stmt|;
name|yv
operator|=
name|yp
operator|->
name|yp_default
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_REAL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a real"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_value
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
if|if
condition|(
name|y
operator|->
name|yv_code
operator|==
name|YV_NUMBER
operator|&&
operator|(
name|y
operator|->
name|yv_flags
operator|&
name|YV_NAMED
operator|)
operator|&&
name|strcmp
argument_list|(
name|yv
operator|->
name|yv_identifier
argument_list|,
name|y
operator|->
name|yv_named
argument_list|)
operator|==
literal|0
condition|)
return|return
name|y
operator|->
name|yv_number
return|;
comment|/* and fall */
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|DEBUG */
end_comment

begin_expr_stmt
name|print_type
argument_list|(
name|yp
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s direction=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|,
name|sprintb
argument_list|(
name|yp
operator|->
name|yp_flags
argument_list|,
name|YPBITS
argument_list|)
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sintexp=\"%s\" strexp=\"%s\" prfexp=0%o declexp=\"%s\" varexp=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sparameter type=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction0 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act0_lineno
argument_list|,
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action05
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction05 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act05_lineno
argument_list|,
name|yp
operator|->
name|yp_action05
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction1 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act1_lineno
argument_list|,
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction2 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act2_lineno
argument_list|,
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction3 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act3_lineno
argument_list|,
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stag class=0x%x value=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sdefault=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*soffset=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_BITLIST
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*svalue=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|print_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_module
condition|?
name|yp
operator|->
name|yp_module
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|,
name|sprintb
argument_list|(
name|yv
operator|->
name|yv_flags
argument_list|,
name|YVBITS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_act_lineno
argument_list|,
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snamed=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snumber=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sstring=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_BOUND
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_function
specifier|static
name|SY
name|new_symbol
parameter_list|(
name|encpref
parameter_list|,
name|decpref
parameter_list|,
name|prfpref
parameter_list|,
name|mod
parameter_list|,
name|id
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
name|encpref
decl_stmt|,
decl|*
name|decpref
decl_stmt|,
modifier|*
name|prfpref
decl_stmt|,
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|YP
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
operator|(
name|sy
operator|=
operator|(
name|SY
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|sy
argument_list|)
operator|)
operator|==
name|NULLSY
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_encpref
operator|=
name|encpref
expr_stmt|;
name|sy
operator|->
name|sy_decpref
operator|=
name|decpref
expr_stmt|;
name|sy
operator|->
name|sy_prfpref
operator|=
name|prfpref
expr_stmt|;
name|sy
operator|->
name|sy_module
operator|=
name|mod
expr_stmt|;
name|sy
operator|->
name|sy_name
operator|=
name|id
expr_stmt|;
name|sy
operator|->
name|sy_type
operator|=
name|type
expr_stmt|;
return|return
name|sy
return|;
block|}
end_block

begin_function
specifier|static
name|SY
name|add_symbol
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|SY
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULLSY
condition|)
return|return
name|s2
return|;
for|for
control|(
name|sy
operator|=
name|s1
init|;
name|sy
operator|->
name|sy_next
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
continue|continue;
name|sy
operator|->
name|sy_next
operator|=
name|s2
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/*
comment|MODULES */
end_comment

begin_function
name|MD
name|lookup_module
parameter_list|(
name|module
parameter_list|,
name|oid
parameter_list|)
name|char
modifier|*
name|module
decl_stmt|;
name|OID
name|oid
decl_stmt|;
block|{
specifier|register
name|MD
name|md
decl_stmt|;
for|for
control|(
name|md
operator|=
name|mymodules
init|;
name|md
condition|;
name|md
operator|=
name|md
operator|->
name|md_next
control|)
block|{
if|if
condition|(
name|module
operator|&&
name|md
operator|->
name|md_module
operator|&&
name|strcmp
argument_list|(
name|md
operator|->
name|md_module
argument_list|,
name|module
argument_list|)
operator|==
literal|0
condition|)
return|return
name|md
return|;
if|if
condition|(
name|oid
operator|&&
name|md
operator|->
name|md_oid
operator|&&
name|oid_cmp
argument_list|(
name|oid
argument_list|,
name|md
operator|->
name|md_oid
argument_list|)
operator|==
literal|0
condition|)
return|return
name|md
return|;
block|}
name|read_ph_file
argument_list|(
name|module
argument_list|,
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
operator|(
name|MD
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|md
argument_list|)
operator|)
operator|==
name|NULLMD
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_module
operator|=
name|new_string
argument_list|(
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
condition|)
name|md
operator|->
name|md_oid
operator|=
name|oid_cpy
argument_list|(
name|oid
argument_list|)
expr_stmt|;
else|else
name|md
operator|->
name|md_oid
operator|=
name|NULLOID
expr_stmt|;
if|if
condition|(
name|mymodules
operator|!=
name|NULLMD
condition|)
name|md
operator|->
name|md_next
operator|=
name|mymodules
expr_stmt|;
return|return
operator|(
name|mymodules
operator|=
name|md
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|TYPES */
end_comment

begin_function
name|YP
name|new_type
parameter_list|(
name|code
parameter_list|,
name|lineno
parameter_list|)
name|int
name|code
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
operator|(
name|YP
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yp
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_code
operator|=
name|code
expr_stmt|;
name|yp
operator|->
name|yp_lineno
operator|=
name|lineno
expr_stmt|;
return|return
name|yp
return|;
block|}
end_function

begin_function
name|YP
name|add_type
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YP
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
for|for
control|(
name|yp
operator|=
name|y
init|;
name|yp
operator|->
name|yp_next
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
continue|continue;
name|yp
operator|->
name|yp_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YP
name|copy_type
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YP
name|y
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return
name|NULLYP
return|;
name|y
operator|=
name|new_type
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|,
name|yp
operator|->
name|yp_lineno
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_direction
operator|=
name|yp
operator|->
name|yp_direction
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
condition|)
name|y
operator|->
name|yp_module
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_identifier
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_modid
operator|=
name|oid_cpy
argument_list|(
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|y
operator|->
name|yp_type
operator|=
name|copy_type
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_BITLIST
case|:
name|y
operator|->
name|yp_value
operator|=
name|copy_value
argument_list|(
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|y
operator|->
name|yp_intexp
operator|=
name|yp
operator|->
name|yp_intexp
expr_stmt|;
name|y
operator|->
name|yp_strexp
operator|=
name|yp
operator|->
name|yp_strexp
expr_stmt|;
name|y
operator|->
name|yp_prfexp
operator|=
name|yp
operator|->
name|yp_prfexp
expr_stmt|;
name|y
operator|->
name|yp_declexp
operator|=
name|yp
operator|->
name|yp_declexp
expr_stmt|;
name|y
operator|->
name|yp_varexp
operator|=
name|yp
operator|->
name|yp_varexp
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|y
operator|->
name|yp_structname
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|y
operator|->
name|yp_ptrname
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
name|y
operator|->
name|yp_param_type
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
block|{
name|y
operator|->
name|yp_action0
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act0_lineno
operator|=
name|yp
operator|->
name|yp_act0_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action05
condition|)
block|{
name|y
operator|->
name|yp_action05
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action05
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act05_lineno
operator|=
name|yp
operator|->
name|yp_act05_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
block|{
name|y
operator|->
name|yp_action1
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act1_lineno
operator|=
name|yp
operator|->
name|yp_act1_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
block|{
name|y
operator|->
name|yp_action2
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act2_lineno
operator|=
name|yp
operator|->
name|yp_act2_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
block|{
name|y
operator|->
name|yp_action3
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act3_lineno
operator|=
name|yp
operator|->
name|yp_act3_lineno
expr_stmt|;
block|}
name|y
operator|->
name|yp_flags
operator|=
name|yp
operator|->
name|yp_flags
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|y
operator|->
name|yp_default
operator|=
name|copy_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|y
operator|->
name|yp_id
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
name|y
operator|->
name|yp_tag
operator|=
name|copy_tag
argument_list|(
name|yp
operator|->
name|yp_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|y
operator|->
name|yp_bound
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
condition|)
name|y
operator|->
name|yp_parm
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
name|y
operator|->
name|yp_control
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTCONTROL
condition|)
name|y
operator|->
name|yp_optcontrol
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
name|y
operator|->
name|yp_offset
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_control_act
condition|)
block|{
name|y
operator|->
name|yp_control_act
operator|=
name|yp
operator|->
name|yp_control_act
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_optional_act
condition|)
block|{
name|y
operator|->
name|yp_optional_act
operator|=
name|yp
operator|->
name|yp_optional_act
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_bef_alist
condition|)
block|{
name|y
operator|->
name|yp_bef_alist
operator|=
name|yp
operator|->
name|yp_bef_alist
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_aft_alist
condition|)
block|{
name|y
operator|->
name|yp_aft_alist
operator|=
name|yp
operator|->
name|yp_aft_alist
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_next
condition|)
name|y
operator|->
name|yp_next
operator|=
name|copy_type
argument_list|(
name|yp
operator|->
name|yp_next
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|VALUES */
end_comment

begin_function
name|YV
name|new_value
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
operator|(
name|yv
operator|=
operator|(
name|YV
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yv
argument_list|)
operator|)
operator|==
name|NULLYV
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yv
operator|->
name|yv_code
operator|=
name|code
expr_stmt|;
return|return
name|yv
return|;
block|}
end_function

begin_function
name|YV
name|add_value
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YV
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
for|for
control|(
name|yv
operator|=
name|y
init|;
name|yv
operator|->
name|yv_next
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
continue|continue;
name|yv
operator|->
name|yv_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YV
name|copy_value
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return
name|NULLYV
return|;
name|y
operator|=
name|new_value
argument_list|(
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_flags
operator|=
name|yv
operator|->
name|yv_flags
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
block|{
name|y
operator|->
name|yv_action
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_act_lineno
operator|=
name|yv
operator|->
name|yv_act_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|y
operator|->
name|yv_id
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|y
operator|->
name|yv_named
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
name|y
operator|->
name|yv_type
operator|=
name|copy_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
name|y
operator|->
name|yv_number
operator|=
name|yv
operator|->
name|yv_number
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|y
operator|->
name|yv_string
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_module
condition|)
name|y
operator|->
name|yv_module
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_module
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_identifier
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
name|y
operator|->
name|yv_idlist
operator|=
name|copy_value
argument_list|(
name|yv
operator|->
name|yv_idlist
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|yv
operator|->
name|yv_next
condition|)
name|y
operator|->
name|yv_next
operator|=
name|copy_value
argument_list|(
name|yv
operator|->
name|yv_next
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|TAGS */
end_comment

begin_function
name|YT
name|new_tag
parameter_list|(
name|class
parameter_list|)
name|PElementClass
name|class
decl_stmt|;
block|{
specifier|register
name|YT
name|yt
decl_stmt|;
if|if
condition|(
operator|(
name|yt
operator|=
operator|(
name|YT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yt
argument_list|)
operator|)
operator|==
name|NULLYT
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yt
operator|->
name|yt_class
operator|=
name|class
expr_stmt|;
return|return
name|yt
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YT
name|copy_tag
parameter_list|(
name|yt
parameter_list|)
specifier|register
name|YT
name|yt
decl_stmt|;
block|{
specifier|register
name|YT
name|y
decl_stmt|;
if|if
condition|(
name|yt
operator|==
name|NULLYT
condition|)
return|return
name|NULLYT
return|;
name|y
operator|=
name|new_tag
argument_list|(
name|yt
operator|->
name|yt_class
argument_list|)
expr_stmt|;
name|y
operator|->
name|yt_value
operator|=
name|copy_value
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|STRINGS */
end_comment

begin_function
name|char
modifier|*
name|new_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULLCP
condition|)
return|return
name|NULLCP
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_struct
specifier|static
struct|struct
name|triple
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|PElementClass
name|t_class
decl_stmt|;
name|PElementID
name|t_id
decl_stmt|;
block|}
name|triples
index|[]
init|=
block|{
literal|"IA5String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"ISO646String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"NumericString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_NUMS
block|,
literal|"PrintableString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_PRTS
block|,
literal|"T61String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"TeletexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"VideotexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VTXS
block|,
literal|"GeneralizedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"GeneralisedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"UTCTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"UniversalTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"GraphicString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GFXS
block|,
literal|"VisibleString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VISS
block|,
literal|"GeneralString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENS
block|,
literal|"EXTERNAL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_EXTN
block|,
literal|"ObjectDescriptor"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_ODE
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|char
modifier|*
name|modsym
parameter_list|(
name|module
parameter_list|,
name|id
parameter_list|,
name|prefix
parameter_list|)
specifier|register
name|char
modifier|*
name|module
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|module
operator|==
name|NULLCP
condition|)
for|for
control|(
name|t
operator|=
name|triples
init|;
name|t
operator|->
name|t_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|module
operator|=
literal|"UNIV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prefix
condition|)
name|modsym_aux
argument_list|(
name|prefix
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|module
condition|?
name|module
else|:
name|mymodule
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|id
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s"
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|modsym_aux
argument_list|(
name|name
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gensym
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|a
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|int
name|cP
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|eP
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|mP
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'c'
case|:
name|i
operator|=
name|cP
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|i
operator|=
name|eP
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|i
operator|=
name|mP
operator|++
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown gensym argument \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|a
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%d[n_%s]"
argument_list|,
name|s
argument_list|,
name|modulename
argument_list|,
name|i
argument_list|,
name|a
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%d"
argument_list|,
name|s
argument_list|,
name|modulename
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|11
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_comment
comment|/* pepy compatible routines - you know how it is ... */
end_comment

begin_macro
name|init_new_file
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_macro
name|end_file
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|array
parameter_list|(
name|s
parameter_list|,
name|flg
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|flg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|flg
condition|)
return|return
name|s
return|;
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'['
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%*.*s[1]"
argument_list|,
name|p
operator|-
name|s
argument_list|,
name|p
operator|-
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prime_default
parameter_list|(
name|yp
parameter_list|,
name|level
parameter_list|)
name|YP
name|yp
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s = %d;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INT
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s = %d;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s = %d;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|dfl2int
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s = %g;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2real
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* PH FILES */
end_comment

begin_comment
comment|/* really need much more information in the .ph file... */
end_comment

begin_expr_stmt
specifier|static
name|read_ph_file
argument_list|(
name|module
argument_list|,
name|oid
argument_list|)
specifier|register
name|char
operator|*
name|module
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|OID
name|oid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|class
decl_stmt|,
name|value
decl_stmt|,
name|direction
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|file
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|id
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|encpref
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|decpref
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|printpref
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ppp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
specifier|register
name|YT
name|yt
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s.ph"
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|oid
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
operator|=
name|buffer
argument_list|,
literal|"%s.ph"
argument_list|,
name|sprintoid
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULLCP
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|open_ph_file
argument_list|(
name|file
argument_list|,
name|p
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Can't find file %s%s%s failed\n"
argument_list|,
name|file
argument_list|,
name|p
condition|?
literal|"/"
else|:
literal|""
argument_list|,
name|p
condition|?
name|p
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|module
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
name|yyprint
argument_list|(
name|module
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"%d/%d/%d: %s"
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|direction
argument_list|,
name|id
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|myyerror
argument_list|(
literal|"bad external definition in %s: %s"
argument_list|,
name|file
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ppp
operator|=
name|dp
operator|=
name|ep
operator|=
name|NULLCP
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'|'
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|"%s %s %s\n"
argument_list|,
name|encpref
argument_list|,
name|decpref
argument_list|,
name|printpref
argument_list|)
operator|==
literal|3
condition|)
block|{
name|ppp
operator|=
name|new_string
argument_list|(
name|printpref
argument_list|)
expr_stmt|;
name|dp
operator|=
name|new_string
argument_list|(
name|decpref
argument_list|)
expr_stmt|;
name|ep
operator|=
name|new_string
argument_list|(
name|encpref
argument_list|)
expr_stmt|;
block|}
block|}
name|yp
operator|=
name|new_type
argument_list|(
name|class
operator|==
operator|-
literal|1
condition|?
name|YP_ANY
else|:
name|YP_IMPTYPE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_flags
operator|=
name|YP_IMPORTED
expr_stmt|;
if|if
condition|(
name|class
operator|>=
literal|0
condition|)
block|{
name|yp
operator|->
name|yp_flags
operator||=
name|YP_TAG
expr_stmt|;
name|yp
operator|->
name|yp_tag
operator|=
name|yt
operator|=
name|new_tag
argument_list|(
operator|(
name|PElementClass
operator|)
name|class
argument_list|)
expr_stmt|;
name|yt
operator|->
name|yt_value
operator|=
name|yv
operator|=
name|new_value
argument_list|(
name|YV_NUMBER
argument_list|)
expr_stmt|;
name|yv
operator|->
name|yv_number
operator|=
name|value
expr_stmt|;
block|}
name|yp
operator|->
name|yp_direction
operator|=
name|direction
expr_stmt|;
name|pass1_type
argument_list|(
name|ep
argument_list|,
name|dp
argument_list|,
name|ppp
argument_list|,
name|new_string
argument_list|(
name|module
argument_list|)
argument_list|,
name|new_string
argument_list|(
name|id
argument_list|)
argument_list|,
name|yp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|write_ph_file
argument_list|()
block|{
name|int
name|msave
block|;
name|char
name|file
index|[
name|BUFSIZ
index|]
block|;
name|char
name|fileoid
index|[
name|BUFSIZ
index|]
block|;
name|char
operator|*
name|cp
block|;
specifier|register
name|FILE
operator|*
name|fp
block|;
specifier|register
name|SY
name|sy
block|;
specifier|register
name|YT
name|yt
block|;
specifier|register
name|YP
name|yp
block|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s.ph"
argument_list|,
name|mymodule
argument_list|)
block|;
if|if
condition|(
name|mymoduleid
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|fileoid
argument_list|,
literal|"%s.ph"
argument_list|,
name|sprintoid
argument_list|(
name|mymoduleid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|NULLCP
expr_stmt|;
name|msave
operator|=
name|mflag
operator|,
name|mflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|fp
operator|=
name|open_ph_file
argument_list|(
name|file
argument_list|,
name|cp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|mflag
operator|=
name|msave
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|doexternals
operator|==
literal|0
operator|&&
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_EXPORTED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|is_any_type
argument_list|(
name|yp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-1/0/%d: %s"
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" |%s %s %s\n"
argument_list|,
name|yyencpref
argument_list|,
name|yydecpref
argument_list|,
name|yyprfpref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|yt
operator|=
name|lookup_tag
argument_list|(
name|yp
argument_list|)
operator|)
operator|&&
name|yt
operator|->
name|yt_class
operator|!=
name|PE_CLASS_CONT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d/%d/%d: %s"
argument_list|,
name|yt
operator|->
name|yt_class
argument_list|,
name|val2int
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" |%s %s %s\n"
argument_list|,
name|yyencpref
argument_list|,
name|yydecpref
argument_list|,
name|yyprfpref
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PEPSYPATH
end_ifndef

begin_define
define|#
directive|define
name|PEPSYPATH
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
unit|static
name|FILE
modifier|*
name|open_ph_file
parameter_list|(
name|fn
parameter_list|,
name|fnoid
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|,
decl|*
name|fnoid
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|char
name|fnb
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|char
modifier|*
name|pepypath
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|fn
operator|==
literal|'/'
condition|)
return|return
name|fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|mflag
condition|)
block|{
comment|/* MOBY HACK */
if|if
condition|(
name|fnoid
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnoid
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
if|if
condition|(
name|fnoid
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../pepy/%s"
argument_list|,
name|fnoid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../pepy/%s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
if|if
condition|(
name|fnoid
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../../pepy/%s"
argument_list|,
name|fnoid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|fp
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fnb
argument_list|,
literal|"../../pepy/%s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|pepypath
operator|==
name|NULL
operator|&&
operator|(
name|pepypath
operator|=
name|getenv
argument_list|(
literal|"PEPSYPATH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pepypath
operator|=
name|PEPSYPATH
expr_stmt|;
name|path
operator|=
name|pepypath
expr_stmt|;
do|do
block|{
name|dst
operator|=
name|fnb
expr_stmt|;
while|while
condition|(
operator|*
name|path
operator|&&
operator|*
name|path
operator|!=
literal|':'
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|fnb
condition|)
operator|*
name|dst
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|fnoid
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dst
argument_list|,
name|fnoid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dst
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fnb
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|path
operator|++
condition|)
do|;
return|return
name|fp
return|;
block|}
end_block

begin_function
name|YT
name|lookup_tag
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|struct
name|tuple
modifier|*
name|t
decl_stmt|;
specifier|static
name|struct
name|ypt
name|ypts
decl_stmt|;
specifier|register
name|YT
name|yt
init|=
operator|&
name|ypts
decl_stmt|;
specifier|static
name|struct
name|ypv
name|ypvs
decl_stmt|;
specifier|register
name|YV
name|yv
init|=
operator|&
name|ypvs
decl_stmt|;
specifier|register
name|YP
name|z
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
return|return
name|yp
operator|->
name|yp_tag
return|;
while|while
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_module
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|=
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
condition|)
block|{
name|yp
operator|=
name|z
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
return|return
name|yp
operator|->
name|yp_tag
return|;
continue|continue;
block|}
break|break;
block|}
for|for
control|(
name|t
operator|=
name|tuples
init|;
name|t
operator|->
name|t_type
operator|!=
name|YP_UNDF
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|t_type
operator|==
name|yp
operator|->
name|yp_code
condition|)
block|{
name|yt
operator|->
name|yt_class
operator|=
name|t
operator|->
name|t_classnum
expr_stmt|;
name|yt
operator|->
name|yt_value
operator|=
name|yv
expr_stmt|;
name|yv
operator|->
name|yv_code
operator|=
name|YV_NUMBER
expr_stmt|;
name|yv
operator|->
name|yv_number
operator|=
name|t
operator|->
name|t_idnum
expr_stmt|;
return|return
name|yt
return|;
block|}
return|return
name|NULLYT
return|;
block|}
end_function

begin_function
name|int
name|is_any_type
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YP
name|z
decl_stmt|;
while|while
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_module
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|=
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
condition|)
block|{
name|yp
operator|=
name|z
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_ANY
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return a string with the leading pathname stripped off  */
end_comment

begin_function
name|char
modifier|*
name|pstrip
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|p1
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
operator|(
name|p1
operator|+
literal|1
operator|)
return|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * produce a #include on the given file descriptor according to what ever  * rules are in fashion today. Unfortunately these keep changing so to  * minimise the effort involved in keeping up we put all the code to change  * in the one place, here. -- amrw  *  * actually, the rules have never changed, andrew just can't figure them out.  *	-- mtr  */
end_comment

begin_macro
name|doincl
argument_list|(
argument|fp
argument_list|,
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where #include is to be written to */
end_comment

begin_decl_stmt
name|char
modifier|*
name|file
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* files to be included */
end_comment

begin_block
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|mflag
condition|)
block|{
comment|/* PEPYPATH version */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#ifndef	PEPYPATH\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|file
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|is_stand
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include<isode/%s>\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|pstrip
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|file
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|pstrip
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|file
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|is_stand
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include<isode/%s>\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|pstrip
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* standard files  - that should be found in the<isode> directory */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stand_f
index|[]
init|=
block|{
literal|"psap.h"
block|,
literal|"pepsy.h"
block|,
literal|"UNIV-types.h"
block|,
literal|"UNIV_defs.h"
block|,
literal|"UNIV_pre_defs.h"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
comment|/* terminating NULL pointer */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * determine if the given (after stripping any path) file is a standard  * include file which should be in the include/isode directory.  * return nonzero (true) if it is.  */
end_comment

begin_macro
name|is_stand
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|f
init|=
name|pstrip
argument_list|(
name|file
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|stand_f
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|f
argument_list|,
name|pstrip
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Number of different external modules that can referenced */
end_comment

begin_define
define|#
directive|define
name|EXTMODSIZE
value|50
end_define

begin_comment
comment|/* table of external modules we reference */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|extmodtab
index|[
name|EXTMODSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nextmod
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next free slot in external module table */
end_comment

begin_comment
comment|/*  * build up a list of external modules we have referenced  */
end_comment

begin_macro
name|addextmod
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of external module */
end_comment

begin_block
block|{
if|if
condition|(
name|nextmod
operator|>=
name|EXTMODSIZE
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"Too many external modules reference, table overflow\n"
argument_list|)
expr_stmt|;
name|extmodtab
index|[
name|nextmod
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * process all the external modules collected to produce the includes  * required  */
end_comment

begin_macro
name|proc_extmod
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|files
index|[
name|EXTMODSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|tail
init|=
literal|"-types.h"
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
literal|"pepsy/"
decl_stmt|;
name|int
name|last
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nextmod
operator|<=
literal|0
condition|)
return|return;
comment|/* no external definitions */
for|for
control|(
name|p
operator|=
name|extmodtab
init|;
name|p
operator|<
name|extmodtab
operator|+
name|nextmod
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|last
operator|>=
name|EXTMODSIZE
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"proc_extmod: too many external modules\n"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|concat
argument_list|(
operator|*
name|p
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflag
operator|||
name|is_stand
argument_list|(
name|buf
argument_list|)
condition|)
comment|/* need to prepend a "pepsy/" */
name|files
index|[
name|last
operator|++
index|]
operator|=
name|my_strcat
argument_list|(
name|prefix
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|files
index|[
name|last
operator|++
index|]
operator|=
name|my_new_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|files
index|[
name|last
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|doincl
argument_list|(
name|fp
argument_list|,
name|files
argument_list|)
expr_stmt|;
comment|/* free up this memory */
operator|--
name|last
expr_stmt|;
comment|/* don't free the NULL pointer - can core dump */
while|while
condition|(
name|last
operator|>
literal|0
condition|)
name|free
argument_list|(
name|files
index|[
operator|--
name|last
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * allocate a yfn structure and intialise it  */
end_comment

begin_function
name|YFN
name|new_yfn
parameter_list|(
name|efn
parameter_list|,
name|dfn
parameter_list|,
name|pfn
parameter_list|,
name|ffn
parameter_list|)
name|char
modifier|*
name|efn
decl_stmt|,
decl|*
name|dfn
decl_stmt|,
modifier|*
name|pfn
decl_stmt|,
modifier|*
name|ffn
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|YFN
name|fn
decl_stmt|;
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fn
operator|=
operator|(
name|YFN
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fn
argument_list|)
operator|)
operator|==
name|NULLYFN
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|efn
condition|)
block|{
if|if
condition|(
name|getid
argument_list|(
name|efn
argument_list|,
name|buf
argument_list|,
name|STRSIZE
argument_list|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"Bad Encoding function\n"
argument_list|)
expr_stmt|;
name|fn
operator|->
name|yfn_enc
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|efn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dfn
condition|)
block|{
if|if
condition|(
name|getid
argument_list|(
name|dfn
argument_list|,
name|buf
argument_list|,
name|STRSIZE
argument_list|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"Bad Decoding function\n"
argument_list|)
expr_stmt|;
name|fn
operator|->
name|yfn_dec
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dfn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfn
condition|)
block|{
if|if
condition|(
name|getid
argument_list|(
name|pfn
argument_list|,
name|buf
argument_list|,
name|STRSIZE
argument_list|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"Bad Printing function\n"
argument_list|)
expr_stmt|;
name|fn
operator|->
name|yfn_prt
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ffn
condition|)
block|{
if|if
condition|(
name|getid
argument_list|(
name|ffn
argument_list|,
name|buf
argument_list|,
name|STRSIZE
argument_list|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"Bad Printing function\n"
argument_list|)
expr_stmt|;
name|fn
operator|->
name|yfn_fre
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ffn
argument_list|)
expr_stmt|;
block|}
return|return
name|fn
return|;
block|}
end_block

begin_comment
comment|/*  * support routine for action_t = allocate space for it and fill it in with  * the given yy_action field  */
end_comment

begin_function
name|Action
name|new_action_t
parameter_list|(
name|text
parameter_list|,
name|lineno
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|Action
name|act
decl_stmt|;
if|if
condition|(
operator|(
name|act
operator|=
operator|(
name|Action
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|action_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLAction
condition|)
name|yyerror
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|act
operator|->
name|a_data
operator|=
name|text
expr_stmt|;
name|act
operator|->
name|a_line
operator|=
name|lineno
expr_stmt|;
name|act
operator|->
name|a_num
operator|=
name|num
expr_stmt|;
return|return
operator|(
name|act
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * support routine for YAL = allocate space for it and make sure it is  * zero'd  */
end_comment

begin_function
name|YAL
name|new_yal
parameter_list|()
block|{
name|YAL
name|yal
decl_stmt|;
if|if
condition|(
operator|(
name|yal
operator|=
operator|(
name|YAL
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|yal
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLYAL
condition|)
name|yyerror
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|yal
operator|)
return|;
block|}
end_function

begin_function
name|YAL
name|yal_join
parameter_list|(
name|yal1
parameter_list|,
name|yal2
parameter_list|)
name|YAL
name|yal1
decl_stmt|,
name|yal2
decl_stmt|;
block|{
if|if
condition|(
name|yal2
operator|==
name|NULLYAL
condition|)
return|return
operator|(
name|yal1
operator|)
return|;
if|if
condition|(
name|yal1
operator|==
name|NULLYAL
condition|)
return|return
operator|(
name|yal2
operator|)
return|;
if|if
condition|(
name|yal1
operator|->
name|yal_enc
operator|==
name|NULLAction
operator|&&
name|yal2
operator|->
name|yal_enc
operator|!=
name|NULLAction
condition|)
name|yal1
operator|->
name|yal_enc
operator|=
name|yal2
operator|->
name|yal_enc
expr_stmt|;
elseif|else
if|if
condition|(
name|yal1
operator|->
name|yal_enc
operator|!=
name|NULLAction
operator|&&
name|yal2
operator|->
name|yal_enc
operator|!=
name|NULLAction
condition|)
name|yyerror
argument_list|(
literal|"two encoding actions in the same place\n merge into one\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yal1
operator|->
name|yal_dec
operator|==
name|NULLAction
operator|&&
name|yal2
operator|->
name|yal_dec
operator|!=
name|NULLAction
condition|)
name|yal1
operator|->
name|yal_dec
operator|=
name|yal2
operator|->
name|yal_dec
expr_stmt|;
elseif|else
if|if
condition|(
name|yal1
operator|->
name|yal_dec
operator|!=
name|NULLAction
operator|&&
name|yal2
operator|->
name|yal_dec
operator|!=
name|NULLAction
condition|)
name|yyerror
argument_list|(
literal|"two decoding actions in the same place\n merge into one\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yal1
operator|->
name|yal_prn
operator|==
name|NULLAction
operator|&&
name|yal2
operator|->
name|yal_prn
operator|!=
name|NULLAction
condition|)
name|yal1
operator|->
name|yal_prn
operator|=
name|yal2
operator|->
name|yal_prn
expr_stmt|;
elseif|else
if|if
condition|(
name|yal1
operator|->
name|yal_prn
operator|!=
name|NULLAction
operator|&&
name|yal2
operator|->
name|yal_prn
operator|!=
name|NULLAction
condition|)
name|yyerror
argument_list|(
literal|"two printing actions in the same place\n merge into one\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|yal2
argument_list|)
expr_stmt|;
return|return
operator|(
name|yal1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * join two yfn structures  */
end_comment

begin_function
name|YFN
name|join_yfn
parameter_list|(
name|fn1
parameter_list|,
name|fn2
parameter_list|)
specifier|register
name|YFN
name|fn1
decl_stmt|,
name|fn2
decl_stmt|;
block|{
if|if
condition|(
name|fn2
operator|==
name|NULLYFN
condition|)
return|return
operator|(
name|fn1
operator|)
return|;
if|if
condition|(
name|fn1
operator|==
name|NULLYFN
condition|)
return|return
operator|(
name|fn2
operator|)
return|;
if|if
condition|(
name|fn1
operator|->
name|yfn_enc
operator|==
name|NULLCP
operator|&&
name|fn2
operator|->
name|yfn_enc
operator|!=
name|NULLCP
condition|)
name|fn1
operator|->
name|yfn_enc
operator|=
name|fn2
operator|->
name|yfn_enc
expr_stmt|;
elseif|else
if|if
condition|(
name|fn1
operator|->
name|yfn_enc
operator|!=
name|NULLCP
operator|&&
name|fn2
operator|->
name|yfn_enc
operator|!=
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"Illegal: two encoding functions for the same type\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn1
operator|->
name|yfn_dec
operator|==
name|NULLCP
operator|&&
name|fn2
operator|->
name|yfn_dec
operator|!=
name|NULLCP
condition|)
name|fn1
operator|->
name|yfn_dec
operator|=
name|fn2
operator|->
name|yfn_dec
expr_stmt|;
elseif|else
if|if
condition|(
name|fn1
operator|->
name|yfn_dec
operator|!=
name|NULLCP
operator|&&
name|fn2
operator|->
name|yfn_dec
operator|!=
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"Illegal: two decoding functions for the same type\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn1
operator|->
name|yfn_prt
operator|==
name|NULLCP
operator|&&
name|fn2
operator|->
name|yfn_prt
operator|!=
name|NULLCP
condition|)
name|fn1
operator|->
name|yfn_prt
operator|=
name|fn2
operator|->
name|yfn_prt
expr_stmt|;
elseif|else
if|if
condition|(
name|fn1
operator|->
name|yfn_prt
operator|!=
name|NULLCP
operator|&&
name|fn2
operator|->
name|yfn_prt
operator|!=
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"Illegal: two printing functions for the same type\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fn2
argument_list|)
expr_stmt|;
return|return
operator|(
name|fn1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

end_unit

