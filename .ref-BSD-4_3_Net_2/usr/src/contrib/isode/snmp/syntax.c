begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* syntax.c - SMI syntax handling */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/syntax.c,v 7.19 91/02/22 09:44:38 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/snmp/RCS/syntax.c,v 7.19 91/02/22 09:44:38 mrose Interim $  *  * Contributed by NYSERNet Inc.  This work was partially supported by the  * U.S. Defense Advanced Research Projects Agency and the Rome Air Development  * Center of the U.S. Air Force Systems Command under contract number  * F30602-88-C-0016.  *  *  * $Log:	syntax.c,v $  * Revision 7.19  91/02/22  09:44:38  mrose  * Interim 6.8  *   * Revision 7.18  91/01/13  11:05:45  mrose  * update  *   * Revision 7.17  91/01/12  21:22:58  mrose  * update  *   * Revision 7.16  91/01/11  15:35:36  mrose  * sets  *   * Revision 7.15  90/12/18  10:14:07  mrose  * update  *   * Revision 7.14  90/11/20  15:32:55  mrose  * update  *   * Revision 7.13  90/11/04  19:16:36  mrose  * update  *   * Revision 7.12  90/10/29  18:39:12  mrose  * updates  *   * Revision 7.11  90/10/23  20:37:17  mrose  * update  *   * Revision 7.10  90/08/18  00:44:42  mrose  * touch-up  *   * Revision 7.9  90/08/08  14:01:39  mrose  * stuff  *   * Revision 7.8  90/07/09  14:49:41  mrose  * sync  *   * Revision 7.7  90/04/18  08:52:03  mrose  * oid_normalize  *   * Revision 7.6  90/04/08  03:23:20  mrose  * touch-up  *   * Revision 7.5  90/03/23  17:27:35  mrose  * update  *   * Revision 7.4  90/03/08  08:05:25  mrose  * touch-up  *   * Revision 7.3  90/02/19  19:23:14  mrose  * again  *   * Revision 7.2  90/02/19  19:17:11  mrose  * again  *   * Revision 7.1  90/01/11  18:34:48  mrose  * real-sync  *   * Revision 7.0  89/11/23  22:23:32  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"SNMP-types.h"
end_include

begin_include
include|#
directive|include
file|"objects.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_include
include|#
directive|include
file|"clns.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_define
define|#
directive|define
name|MAXSYN
value|50
end_define

begin_decl_stmt
specifier|static
name|object_syntax
name|syntaxes
index|[
name|MAXSYN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OS
name|synlast
init|=
name|syntaxes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|INTEGER */
end_comment

begin_function
specifier|static
name|int
name|integer_encode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|integer
modifier|*
name|x
decl_stmt|;
name|PE
modifier|*
name|pe
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|int2prim
argument_list|(
operator|*
name|x
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|integer_decode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|integer
modifier|*
modifier|*
name|x
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
name|integer
name|i
init|=
name|prim2num
argument_list|(
name|pe
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|NOTOK
operator|&&
name|pe
operator|->
name|pe_errno
operator|!=
name|PE_ERR_NONE
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
operator|*
name|x
operator|=
operator|(
name|integer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|x
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
operator|*
operator|*
name|x
operator|=
name|i
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|integer_free
parameter_list|(
name|x
parameter_list|)
name|integer
modifier|*
name|x
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|integer_parse
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|integer
modifier|*
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|l
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
operator|*
name|x
operator|=
operator|(
name|integer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|x
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
operator|*
operator|*
name|x
operator|=
operator|(
name|integer
operator|)
name|l
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|integer_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|integer
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|*
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|services_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|integer
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sprintb
argument_list|(
operator|(
name|int
operator|)
operator|*
name|x
argument_list|,
literal|"\020\01physical\02datalink/subnetwork\03internet\04transport\05session\06presentation\07application"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|privs_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|integer
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sprintb
argument_list|(
operator|(
name|int
operator|)
operator|*
name|x
argument_list|,
literal|"\020\01get\02get-next\03get-response\04set\05trap"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_integer
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"INTEGER"
argument_list|,
name|integer_encode
argument_list|,
name|integer_decode
argument_list|,
name|integer_free
argument_list|,
name|integer_parse
argument_list|,
name|integer_print
argument_list|)
block|;
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"Services"
argument_list|,
name|integer_encode
argument_list|,
name|integer_decode
argument_list|,
name|integer_free
argument_list|,
name|integer_parse
argument_list|,
name|services_print
argument_list|)
block|;
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"Privileges"
argument_list|,
name|integer_encode
argument_list|,
name|integer_decode
argument_list|,
name|integer_free
argument_list|,
name|integer_parse
argument_list|,
name|privs_print
argument_list|)
block|; }
comment|/*
comment|OCTET STRING */
specifier|static
name|int
name|string_encode
argument_list|(
argument|x
argument_list|,
argument|pe
argument_list|)
expr|struct
name|qbuf
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|qb2prim_aux
argument_list|(
name|x
argument_list|,
name|PE_CLASS_UNIV
argument_list|,
name|PE_PRIM_OCTS
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|string_decode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|struct
name|qbuf
modifier|*
modifier|*
name|x
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
name|struct
name|qbuf
modifier|*
name|qb
init|=
name|prim2qb
argument_list|(
name|pe
argument_list|)
decl_stmt|;
if|if
condition|(
name|qb
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
operator|*
name|x
operator|=
name|qb
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|string_parse
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|struct
name|qbuf
modifier|*
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|%
literal|3
operator|!=
literal|2
condition|)
return|return
name|NOTOK
return|;
name|len
operator|/=
literal|3
operator|,
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|qb
operator|=
name|str2qb
argument_list|(
name|NULLCP
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
name|p
operator|=
name|qb
operator|->
name|qb_forw
operator|->
name|qb_data
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|oops
label|:
empty_stmt|;
name|qb_free
argument_list|(
name|qb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|++
operator|!=
literal|':'
condition|)
goto|goto
name|oops
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|qb
operator|=
name|str2qb
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
operator|*
name|x
operator|=
name|qb
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|string_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|struct
name|qbuf
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
name|p
operator|=
literal|"0x"
expr_stmt|;
for|for
control|(
name|qb
operator|=
name|x
operator|->
name|qb_forw
init|;
name|qb
operator|!=
name|x
condition|;
name|qb
operator|=
name|qb
operator|->
name|qb_forw
control|)
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|qb
operator|->
name|qb_data
operator|)
operator|+
name|qb
operator|->
name|qb_len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s%02x"
argument_list|,
name|p
argument_list|,
operator|*
name|cp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
operator|=
literal|":"
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|string_display
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|struct
name|qbuf
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
specifier|register
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
name|qb
operator|=
name|x
operator|->
name|qb_forw
init|;
name|qb
operator|!=
name|x
condition|;
name|qb
operator|=
name|qb
operator|->
name|qb_forw
control|)
name|printf
argument_list|(
literal|"%*.*s"
argument_list|,
name|qb
operator|->
name|qb_len
argument_list|,
name|qb
operator|->
name|qb_len
argument_list|,
name|qb
operator|->
name|qb_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_string
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"OctetString"
argument_list|,
name|string_encode
argument_list|,
name|string_decode
argument_list|,
name|qb_free
argument_list|,
name|string_parse
argument_list|,
name|string_print
argument_list|)
block|;
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"DisplayString"
argument_list|,
name|string_encode
argument_list|,
name|string_decode
argument_list|,
name|qb_free
argument_list|,
name|string_parse
argument_list|,
name|string_display
argument_list|)
block|;
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"PhysAddress"
argument_list|,
name|string_encode
argument_list|,
name|string_decode
argument_list|,
name|qb_free
argument_list|,
name|string_parse
argument_list|,
name|string_print
argument_list|)
block|; }
comment|/*
comment|OBJECT IDENTIFIER */
specifier|static
name|int
name|object_encode
argument_list|(
argument|x
argument_list|,
argument|pe
argument_list|)
name|OID
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|oid2prim
argument_list|(
name|x
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|object_decode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|OID
modifier|*
name|x
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
name|OID
name|oid
init|=
name|prim2oid
argument_list|(
name|pe
argument_list|)
decl_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULLOID
operator|||
operator|(
operator|*
name|x
operator|=
name|oid_cpy
argument_list|(
name|oid
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|object_parse
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|OID
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|OID
name|oid
init|=
name|text2oid
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
operator|*
name|x
operator|=
name|oid
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|object_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|OID
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|ode
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ode
argument_list|,
name|oid2ode
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ode
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ode
argument_list|,
name|cp
operator|=
name|sprintoid
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_object
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"ObjectID"
argument_list|,
name|object_encode
argument_list|,
name|object_decode
argument_list|,
name|oid_free
argument_list|,
name|object_parse
argument_list|,
name|object_print
argument_list|)
block|; }
comment|/*
comment|NULL */
comment|/* ARGSUSED */
specifier|static
name|int
name|null_encode
argument_list|(
argument|x
argument_list|,
argument|pe
argument_list|)
name|char
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|null_decode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|char
modifier|*
modifier|*
name|x
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|x
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|x
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|null_free
parameter_list|(
name|x
parameter_list|)
name|char
modifier|*
name|x
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|null_parse
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|lexequ
argument_list|(
name|s
argument_list|,
literal|"NULL"
argument_list|)
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
operator|*
name|x
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|x
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|null_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|char
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_null
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"NULL"
argument_list|,
name|null_encode
argument_list|,
name|null_decode
argument_list|,
name|null_free
argument_list|,
name|null_parse
argument_list|,
name|null_print
argument_list|)
block|; }
comment|/*
comment|IpAddress */
specifier|static
name|int
name|ipaddr_encode
argument_list|(
argument|x
argument_list|,
argument|pe
argument_list|)
expr|struct
name|sockaddr_in
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|str2prim
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|x
operator|->
name|sin_addr
argument_list|,
literal|4
argument_list|,
name|PE_CLASS_APPL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|ipaddr_decode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
modifier|*
name|x
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
name|struct
name|type_SNMP_IpAddress
modifier|*
name|ip
decl_stmt|;
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|isock
decl_stmt|;
if|if
condition|(
name|decode_SNMP_IpAddress
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|ip
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|qb_pullup
argument_list|(
name|ip
argument_list|)
operator|==
name|NOTOK
operator|||
operator|(
name|isock
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free_SNMP_IpAddress
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|qb
operator|=
name|ip
operator|->
name|qb_forw
operator|)
operator|->
name|qb_len
operator|!=
literal|4
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isock
argument_list|)
expr_stmt|;
name|free_SNMP_IpAddress
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|isock
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|bcopy
argument_list|(
name|qb
operator|->
name|qb_data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|isock
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
name|isock
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|isock
expr_stmt|;
name|free_SNMP_IpAddress
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipaddr_free
parameter_list|(
name|x
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|x
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipaddr_parse
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|hp
init|=
name|gethostbystring
argument_list|(
name|s
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|isock
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
name|isock
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|isock
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|isock
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ipaddr_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|x
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_ipaddr
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"IpAddress"
argument_list|,
name|ipaddr_encode
argument_list|,
name|ipaddr_decode
argument_list|,
name|ipaddr_free
argument_list|,
name|ipaddr_parse
argument_list|,
name|ipaddr_print
argument_list|)
block|; }
comment|/*
comment|NetworkAddress */
comment|/* good enough for now (and probably forever)... */
specifier|static
name|add_netaddr
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"NetworkAddress"
argument_list|,
name|ipaddr_encode
argument_list|,
name|ipaddr_decode
argument_list|,
name|ipaddr_free
argument_list|,
name|ipaddr_parse
argument_list|,
name|ipaddr_print
argument_list|)
block|; }
comment|/*
comment|UNSIGNED LONGs */
name|u_long
name|prim2ulong
argument_list|(
name|pe
argument_list|)
comment|/* also used in SNMP-capable gawk... */
specifier|register
name|PE
name|pe
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|u_long
name|i
decl_stmt|;
specifier|register
name|PElementData
name|dp
decl_stmt|,
name|ep
decl_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_form
operator|!=
name|PE_FORM_PRIM
operator|||
operator|(
name|dp
operator|=
name|pe
operator|->
name|pe_prim
operator|)
operator|==
name|NULLPED
condition|)
return|return
name|pe_seterr
argument_list|(
name|pe
argument_list|,
name|PE_ERR_PRIM
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|pe
operator|->
name|pe_len
operator|>
sizeof|sizeof
argument_list|(
name|i
argument_list|)
operator|+
literal|1
condition|)
return|return
name|pe_seterr
argument_list|(
name|pe
argument_list|,
name|PE_ERR_OVER
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|pe
operator|->
name|pe_len
operator|==
sizeof|sizeof
argument_list|(
name|i
argument_list|)
operator|+
literal|1
operator|&&
operator|(
operator|*
name|dp
operator|&
literal|0x7f
operator|)
condition|)
return|return
name|pe_seterr
argument_list|(
name|pe
argument_list|,
name|PE_ERR_OVER
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|*
name|dp
operator|&
literal|0x80
condition|)
return|return
name|pe_seterr
argument_list|(
name|pe
argument_list|,
name|PE_ERR_SIGNED
argument_list|,
literal|0
argument_list|)
return|;
name|pe
operator|->
name|pe_errno
operator|=
name|PE_ERR_NONE
expr_stmt|;
comment|/* in case result is ZERO-valued */
name|i
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|dp
operator|+
name|pe
operator|->
name|pe_len
init|;
name|dp
operator|<
name|ep
condition|;
control|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|dp
operator|++
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_function
specifier|static
name|PE
name|ulong2prim
parameter_list|(
name|i
parameter_list|,
name|class
parameter_list|,
name|id
parameter_list|)
specifier|register
name|u_long
name|i
decl_stmt|;
name|PElementClass
name|class
decl_stmt|;
name|PElementID
name|id
decl_stmt|;
block|{
name|int
name|extend
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|u_long
name|mask
decl_stmt|;
specifier|register
name|PElementData
name|dp
decl_stmt|;
specifier|register
name|PE
name|pe
decl_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|pe_alloc
argument_list|(
name|class
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|id
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NULLPE
return|;
name|mask
operator|=
literal|0xff
operator|<<
operator|(
operator|(
operator|(
name|n
operator|=
sizeof|sizeof
name|i
operator|)
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|1
operator|&&
operator|(
name|i
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
name|mask
operator|>>=
literal|8
operator|,
name|n
operator|--
expr_stmt|;
name|extend
operator|=
operator|(
name|i
operator|&
operator|(
literal|0x80
operator|<<
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|->
name|pe_prim
operator|=
name|PEDalloc
argument_list|(
name|n
operator|+
name|extend
argument_list|)
operator|)
operator|==
name|NULLPED
condition|)
block|{
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
name|NULLPE
return|;
block|}
for|for
control|(
name|dp
operator|=
name|pe
operator|->
name|pe_prim
operator|+
operator|(
name|pe
operator|->
name|pe_len
operator|=
name|n
operator|+
name|extend
operator|)
init|;
name|n
operator|--
operator|>
literal|0
condition|;
name|i
operator|>>=
literal|8
control|)
operator|*
operator|--
name|dp
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|extend
condition|)
operator|*
operator|--
name|dp
operator|=
literal|0x00
expr_stmt|;
return|return
name|pe
return|;
block|}
end_function

begin_comment
comment|/*
comment|Counter */
end_comment

begin_function
specifier|static
name|int
name|counter_encode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|u_long
modifier|*
name|x
decl_stmt|;
name|PE
modifier|*
name|pe
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|ulong2prim
argument_list|(
operator|*
name|x
argument_list|,
name|PE_CLASS_APPL
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_decode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|u_long
modifier|*
modifier|*
name|x
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
name|u_long
name|i
init|=
name|prim2ulong
argument_list|(
name|pe
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|pe
operator|->
name|pe_errno
operator|!=
name|PE_ERR_NONE
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
operator|*
name|x
operator|=
operator|(
name|u_long
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|x
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
operator|*
operator|*
name|x
operator|=
name|i
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_free
parameter_list|(
name|x
parameter_list|)
name|u_long
modifier|*
name|x
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_parse
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|u_long
modifier|*
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|u_long
name|i
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%U"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
operator|*
name|x
operator|=
operator|(
name|u_long
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|x
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
operator|*
operator|*
name|x
operator|=
name|i
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|counter_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|u_long
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%U"
argument_list|,
operator|*
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_counter
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"Counter"
argument_list|,
name|counter_encode
argument_list|,
name|counter_decode
argument_list|,
name|counter_free
argument_list|,
name|counter_parse
argument_list|,
name|counter_print
argument_list|)
block|; }
comment|/*
comment|Gauge */
specifier|static
name|int
name|gauge_encode
argument_list|(
argument|x
argument_list|,
argument|pe
argument_list|)
name|u_long
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|ulong2prim
argument_list|(
operator|*
name|x
argument_list|,
name|PE_CLASS_APPL
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|add_gauge
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"Gauge"
argument_list|,
name|gauge_encode
argument_list|,
name|counter_decode
argument_list|,
name|counter_free
argument_list|,
name|counter_parse
argument_list|,
name|counter_print
argument_list|)
block|; }
comment|/*
comment|TimeTicks */
specifier|static
name|int
name|timeticks_encode
argument_list|(
argument|x
argument_list|,
argument|pe
argument_list|)
name|u_long
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|ulong2prim
argument_list|(
operator|*
name|x
argument_list|,
name|PE_CLASS_APPL
argument_list|,
literal|3
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|timeticks_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|u_long
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|u_long
name|d
decl_stmt|,
name|h
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|,
name|ds
decl_stmt|;
name|ds
operator|=
operator|*
name|x
expr_stmt|;
name|s
operator|=
name|ds
operator|/
literal|100
operator|,
name|ds
operator|=
name|ds
operator|%
literal|100
expr_stmt|;
name|m
operator|=
name|s
operator|/
literal|60
operator|,
name|s
operator|=
name|s
operator|%
literal|60
expr_stmt|;
name|h
operator|=
name|m
operator|/
literal|60
operator|,
name|m
operator|=
name|m
operator|%
literal|60
expr_stmt|;
name|d
operator|=
name|h
operator|/
literal|24
operator|,
name|h
operator|=
name|h
operator|%
literal|24
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%d days, "
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
operator|||
name|h
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%d hours, "
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
operator|||
name|h
operator|>
literal|0
operator|||
name|m
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%d minutes, "
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|".%02d"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" seconds (%U timeticks)"
argument_list|,
operator|*
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_timeticks
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"TimeTicks"
argument_list|,
name|timeticks_encode
argument_list|,
name|counter_decode
argument_list|,
name|counter_free
argument_list|,
name|counter_parse
argument_list|,
name|timeticks_print
argument_list|)
block|; }
comment|/*
comment|CnlpAddress */
specifier|static
name|int
name|clnpaddr_encode
argument_list|(
argument|x
argument_list|,
argument|pe
argument_list|)
expr|struct
name|sockaddr_iso
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
sizeof|sizeof
name|x
operator|->
name|siso_data
operator|+
literal|1
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|x
operator|->
name|siso_nlen
operator|&
literal|0xff
expr_stmt|;
name|bcopy
argument_list|(
name|x
operator|->
name|siso_data
argument_list|,
name|buffer
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|)
name|x
operator|->
name|siso_nlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pe
operator|=
name|str2prim
argument_list|(
name|buffer
argument_list|,
call|(
name|int
call|)
argument_list|(
name|x
operator|->
name|siso_nlen
operator|+
literal|1
argument_list|)
argument_list|,
name|PE_CLASS_APPL
argument_list|,
literal|5
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|clnpaddr_decode
parameter_list|(
name|x
parameter_list|,
name|pe
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|x
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|struct
name|type_SNMP_ClnpAddress
modifier|*
name|clnp
decl_stmt|;
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|isock
decl_stmt|;
if|if
condition|(
name|decode_SNMP_ClnpAddress
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|clnp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|qb_pullup
argument_list|(
name|clnp
argument_list|)
operator|==
name|NOTOK
operator|||
operator|(
name|isock
operator|=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free_SNMP_ClnpAddress
argument_list|(
name|clnp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|qb
operator|=
name|clnp
operator|->
name|qb_forw
expr_stmt|;
name|isock
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|qb
operator|->
name|qb_data
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|>=
name|qb
operator|->
name|qb_len
condition|)
name|len
operator|=
name|qb
operator|->
name|qb_len
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|qb
operator|->
name|qb_data
operator|+
literal|1
argument_list|,
name|isock
operator|->
name|siso_data
argument_list|,
call|(
name|int
call|)
argument_list|(
name|isock
operator|->
name|siso_nlen
operator|=
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|isock
expr_stmt|;
name|free_SNMP_ClnpAddress
argument_list|(
name|clnp
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|clnpaddr_free
parameter_list|(
name|x
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
name|x
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|clnpaddr_parse
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|isock
decl_stmt|;
if|if
condition|(
operator|(
name|isock
operator|=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
name|isock
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|isock
operator|->
name|siso_nlen
operator|=
name|implode
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|isock
operator|->
name|siso_data
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|isock
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|clnpaddr_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|char
name|buffer
index|[
sizeof|sizeof
name|x
operator|->
name|siso_data
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|buffer
index|[
name|explode
argument_list|(
name|buffer
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|x
operator|->
name|siso_data
argument_list|,
operator|(
name|int
operator|)
name|x
operator|->
name|siso_nlen
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"NS+%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|add_clnpaddr
argument_list|()
block|{
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
literal|"ClnpAddress"
argument_list|,
name|clnpaddr_encode
argument_list|,
name|clnpaddr_decode
argument_list|,
name|clnpaddr_free
argument_list|,
name|clnpaddr_parse
argument_list|,
name|clnpaddr_print
argument_list|)
block|; }
comment|/*
comment|*/
name|int
name|readsyntax
argument_list|()
block|{
name|add_integer
argument_list|()
block|;
name|add_string
argument_list|()
block|;
name|add_object
argument_list|()
block|;
name|add_null
argument_list|()
block|;
name|add_ipaddr
argument_list|()
block|;
name|add_netaddr
argument_list|()
block|;
name|add_counter
argument_list|()
block|;
name|add_gauge
argument_list|()
block|;
name|add_timeticks
argument_list|()
block|;
name|add_clnpaddr
argument_list|()
block|; }
comment|/*
comment|*/
name|int
name|add_syntax
argument_list|(
argument|name
argument_list|,
argument|f_encode
argument_list|,
argument|f_decode
argument_list|,
argument|f_free
argument_list|,
argument|f_parse
argument_list|,
argument|f_print
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|IFP
name|f_encode
decl_stmt|,
name|f_decode
decl_stmt|,
name|f_free
decl_stmt|,
name|f_parse
decl_stmt|,
name|f_print
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|OS
name|os
init|=
name|synlast
operator|++
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|synlast
operator|-
name|syntaxes
operator|)
operator|>=
name|MAXSYN
condition|)
return|return
name|NOTOK
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|os
argument_list|,
sizeof|sizeof
expr|*
name|os
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_name
operator|=
name|name
expr_stmt|;
name|os
operator|->
name|os_encode
operator|=
name|f_encode
expr_stmt|;
name|os
operator|->
name|os_decode
operator|=
name|f_decode
expr_stmt|;
name|os
operator|->
name|os_free
operator|=
name|f_free
expr_stmt|;
name|os
operator|->
name|os_parse
operator|=
name|f_parse
expr_stmt|;
name|os
operator|->
name|os_print
operator|=
name|f_print
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|OS
name|text2syn
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|OS
name|os
decl_stmt|;
for|for
control|(
name|os
operator|=
name|syntaxes
init|;
name|os
operator|<
name|synlast
condition|;
name|os
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|os
operator|->
name|os_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|os
return|;
return|return
name|NULLOS
return|;
block|}
end_function

end_unit

