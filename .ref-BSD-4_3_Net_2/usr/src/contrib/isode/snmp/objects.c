begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* objects.c - SMI object handling */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/objects.c,v 7.14 91/02/22 09:43:44 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/snmp/RCS/objects.c,v 7.14 91/02/22 09:43:44 mrose Interim $  *  * Contributed by NYSERNet Inc.  This work was partially supported by the  * U.S. Defense Advanced Research Projects Agency and the Rome Air Development  * Center of the U.S. Air Force Systems Command under contract number  * F30602-88-C-0016.  *  *  * $Log:	objects.c,v $  * Revision 7.14  91/02/22  09:43:44  mrose  * Interim 6.8  *   * Revision 7.13  90/12/11  21:56:34  mrose  * again  *   * Revision 7.12  90/09/26  18:47:15  mrose  * more-compile  *   * Revision 7.11  90/08/30  15:11:09  mrose  * ho-hum  *   * Revision 7.10  90/07/09  14:48:54  mrose  * sync  *   * Revision 7.9  90/06/21  21:26:23  mrose  * 0.0  *   * Revision 7.8  90/06/20  21:38:21  mrose  * update  *   * Revision 7.7  90/06/12  09:22:06  mrose  * write-only  *   * Revision 7.6  90/05/28  21:49:51  mrose  * not-accessible  *   * Revision 7.5  90/05/13  16:18:14  mrose  * views  *   * Revision 7.4  90/05/12  17:37:04  mrose  * typo  *   * Revision 7.3  90/02/19  15:54:04  mrose  * touch-up  *   * Revision 7.2  90/02/17  10:38:22  mrose  * smux  *   * Revision 7.1  90/01/11  18:34:23  mrose  * real-sync  *   * Revision 7.0  89/11/23  22:23:18  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"objects.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_define
define|#
directive|define
name|TBUCKETS
value|0x80
end_define

begin_decl_stmt
specifier|static
name|int
name|once_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compile_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OT
name|compile_heap1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|compile_heap2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
modifier|*
name|compile_heap3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OID
name|compile_heap4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OT
name|Tbuckets
index|[
name|TBUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OT
name|anchor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OT
name|chain
decl_stmt|;
end_decl_stmt

begin_function_decl
name|OID
name|resolve
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|OBJECTS */
end_comment

begin_function
specifier|static
name|int
name|THASH
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|*
operator|(
name|dp
operator|=
name|cp
operator|=
name|name
operator|)
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
operator|*
operator|(
name|dp
operator|=
name|cp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|dp
condition|)
return|return
operator|(
operator|(
operator|(
name|c
operator|-
operator|*
name|dp
operator|)
operator|&
literal|0x1f
operator|)
operator|+
operator|(
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
operator|&
literal|0x5f
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|c
operator|&
literal|0x7f
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OT_XXX
value|0x04
end_define

begin_function
specifier|static
name|int
name|ot_compar
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|OT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
init|=
name|oid_cmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|ot_name
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|ot_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
operator|!
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|ot_access
operator|&
name|OT_XXX
operator|)
operator|||
operator|!
operator|(
operator|(
operator|*
name|b
operator|)
operator|->
name|ot_access
operator|&
name|OT_XXX
operator|)
operator|)
condition|)
block|{
name|OID
name|oid
init|=
operator|(
operator|*
name|a
operator|)
operator|->
name|ot_name
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
init|=
name|oid
operator|->
name|oid_elements
decl_stmt|;
comment|/* XXX: 0.0 is a special case */
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|==
literal|2
operator|&&
name|ip
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|ip
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|PY_pepy
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
operator|+
name|strlen
argument_list|(
name|PY_pepy
argument_list|)
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"duplicate objects: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
operator|+
name|strlen
argument_list|(
name|PY_pepy
argument_list|)
argument_list|,
literal|"\"%s\" and \"%s\""
argument_list|,
operator|(
operator|*
name|a
operator|)
operator|->
name|ot_text
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|ot_text
argument_list|)
expr_stmt|;
operator|(
operator|*
name|a
operator|)
operator|->
name|ot_access
operator||=
name|OT_XXX
operator|,
operator|(
operator|*
name|b
operator|)
operator|->
name|ot_access
operator||=
name|OT_XXX
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|roots
index|[]
init|=
block|{
literal|"ccitt"
block|,
literal|"iso"
block|,
literal|"joint-iso-ccitt"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|readobjects
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|NVEC
operator|+
name|NSLACK
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"objects.defs"
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cp
operator|=
name|isodefile
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"unable to read %s: %s"
argument_list|,
name|cp
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Tbuckets
argument_list|,
sizeof|sizeof
name|Tbuckets
argument_list|)
expr_stmt|;
name|readsyntax
argument_list|()
expr_stmt|;
name|compile_flag
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"--* compiled"
argument_list|,
sizeof|sizeof
expr|"--* compiled"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|compile_flag
operator|=
literal|1
expr_stmt|;
name|anchor
operator|=
name|chain
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buffer
argument_list|,
literal|"--* compiled %d %d %d"
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|,
operator|&
name|k
argument_list|)
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|compile_heap1
operator|=
operator|(
name|OT
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|,
sizeof|sizeof
expr|*
name|compile_heap1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory allocating %d objects"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
operator|(
name|compile_heap2
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|j
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory allocating %d octets"
argument_list|,
name|j
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
operator|(
name|compile_heap3
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|k
argument_list|,
sizeof|sizeof
expr|*
name|compile_heap3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory allocating %d sub-identitifers"
argument_list|,
name|k
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
operator|(
name|compile_heap4
operator|=
operator|(
name|OID
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|,
sizeof|sizeof
expr|*
name|compile_heap4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory allocating %d identitifers"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
block|}
else|else
name|compile_heap1
operator|=
name|NULLOT
operator|,
name|compile_heap2
operator|=
name|NULL
operator|,
name|compile_heap3
operator|=
name|NULL
operator|,
name|compile_heap4
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|compile_flag
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|roots
operator|+
operator|(
sizeof|sizeof
name|roots
operator|/
sizeof|sizeof
name|roots
index|[
literal|0
index|]
operator|)
operator|-
literal|1
init|;
name|ap
operator|>=
name|roots
condition|;
name|ap
operator|--
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|ap
operator|-
name|roots
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_name
argument_list|(
operator|*
name|ap
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|you_lose
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
block|}
name|once_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compile_flag
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"only one compiled file is allowed"
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|==
literal|'#'
operator|||
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vec
argument_list|,
sizeof|sizeof
name|vec
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|read_name
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|you_lose
goto|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|read_type
argument_list|(
name|vec
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|you_lose
goto|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"malformed line: \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|PY_pepy
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|compile_flag
operator|<
literal|1
condition|)
block|{
name|int
name|again
decl_stmt|,
name|hit
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|j
init|=
literal|0
decl_stmt|;
specifier|register
name|OT
modifier|*
name|op
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|OT
modifier|*
name|base
decl_stmt|,
name|oz
decl_stmt|;
name|hit
operator|=
literal|1
operator|,
name|oz
operator|=
name|NULLOT
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|hit
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"unable to resolve object \"%s\""
argument_list|,
name|oz
operator|->
name|ot_text
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|again
operator|=
name|hit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ot
operator|=
name|Tbuckets
index|[
name|i
index|]
init|;
name|ot
operator|&&
name|ot
operator|->
name|ot_text
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_chain
control|)
if|if
condition|(
name|ot
operator|->
name|ot_name
operator|==
name|NULLOID
condition|)
if|if
condition|(
name|ot
operator|->
name|ot_name
operator|=
name|resolve
argument_list|(
name|ot
operator|->
name|ot_id
argument_list|,
name|ot
argument_list|)
condition|)
name|hit
operator|=
literal|1
expr_stmt|;
else|else
name|oz
operator|=
name|ot
operator|,
name|again
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|again
condition|)
do|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ot
operator|=
name|Tbuckets
index|[
name|i
index|]
init|;
name|ot
operator|&&
name|ot
operator|->
name|ot_text
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_chain
control|)
name|j
operator|++
expr_stmt|;
comment|/* j> 1 ALWAYS */
if|if
condition|(
operator|(
name|base
operator|=
operator|(
name|OT
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|j
operator|*
sizeof|sizeof
expr|*
name|base
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|op
operator|=
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TBUCKETS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ot
operator|=
name|Tbuckets
index|[
name|i
index|]
init|;
name|ot
operator|&&
name|ot
operator|->
name|ot_text
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_chain
control|)
operator|*
name|op
operator|++
operator|=
name|ot
expr_stmt|;
name|ep
operator|=
name|op
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|j
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|,
name|ot_compar
argument_list|)
expr_stmt|;
name|op
operator|=
name|base
expr_stmt|;
name|anchor
operator|=
name|ot
operator|=
operator|*
name|op
operator|++
expr_stmt|;
while|while
condition|(
name|op
operator|<
name|ep
condition|)
block|{
name|ot
operator|->
name|ot_next
operator|=
operator|*
name|op
expr_stmt|;
name|ot
operator|=
operator|*
name|op
operator|++
expr_stmt|;
block|}
operator|(
name|chain
operator|=
name|ot
operator|)
operator|->
name|ot_next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ot
operator|=
name|anchor
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
block|{
name|OID
name|oid
decl_stmt|;
if|if
condition|(
operator|(
name|oid
operator|=
name|str2oid
argument_list|(
name|ot
operator|->
name|ot_id
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"invalid OID (%s) for \"%s\" in compiled file"
argument_list|,
name|ot
operator|->
name|ot_id
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|compile_heap3
condition|)
block|{
name|ot
operator|->
name|ot_name
operator|=
name|compile_heap4
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oid
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|ot
operator|->
name|ot_name
operator|->
name|oid_elements
operator|=
name|compile_heap3
operator|)
argument_list|,
operator|(
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|=
name|oid
operator|->
name|oid_nelem
operator|)
operator|*
sizeof|sizeof
expr|*
name|oid
operator|->
name|oid_elements
argument_list|)
expr_stmt|;
name|compile_heap3
operator|+=
name|oid
operator|->
name|oid_nelem
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ot
operator|->
name|ot_name
operator|=
name|oid_cpy
argument_list|(
name|oid
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
if|if
condition|(
name|add_objects_aux
argument_list|()
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|notdef
ifdef|#
directive|ifdef
name|DEBUG
name|dump_objects_by_tree
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|PY_pepy
index|[
literal|0
index|]
condition|?
name|NOTOK
else|:
name|OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_name
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
if|if
condition|(
name|text2obj
argument_list|(
name|name
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"duplicate object \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|compile_flag
operator|>
literal|0
operator|&&
name|compile_heap1
condition|)
name|ot
operator|=
name|compile_heap1
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ot
operator|=
operator|(
name|OT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ot
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|compile_flag
operator|>
literal|0
operator|&&
name|compile_heap2
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ot
operator|->
name|ot_text
operator|=
name|compile_heap2
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|compile_heap2
operator|+=
name|strlen
argument_list|(
name|compile_heap2
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ot
operator|->
name|ot_id
operator|=
name|compile_heap2
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|compile_heap2
operator|+=
name|strlen
argument_list|(
name|compile_heap2
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ot
operator|->
name|ot_text
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ot
operator|->
name|ot_id
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ot
operator|->
name|ot_chain
operator|=
name|Tbuckets
index|[
name|i
operator|=
name|THASH
argument_list|(
name|name
argument_list|)
index|]
expr_stmt|;
name|Tbuckets
index|[
name|i
index|]
operator|=
name|ot
expr_stmt|;
if|if
condition|(
name|compile_flag
condition|)
block|{
if|if
condition|(
name|chain
condition|)
name|chain
operator|->
name|ot_next
operator|=
name|ot
expr_stmt|;
else|else
name|anchor
operator|=
name|ot
expr_stmt|;
name|chain
operator|=
name|ot
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_type
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
if|if
condition|(
name|text2obj
argument_list|(
operator|*
name|vec
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"duplicate object \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|compile_flag
operator|>
literal|0
operator|&&
name|compile_heap1
condition|)
name|ot
operator|=
name|compile_heap1
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ot
operator|=
operator|(
name|OT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ot
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|compile_flag
operator|>
literal|0
operator|&&
name|compile_heap2
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ot
operator|->
name|ot_text
operator|=
name|compile_heap2
argument_list|,
operator|*
name|vec
operator|++
argument_list|)
expr_stmt|;
name|compile_heap2
operator|+=
name|strlen
argument_list|(
name|compile_heap2
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ot
operator|->
name|ot_id
operator|=
name|compile_heap2
argument_list|,
operator|*
name|vec
operator|++
argument_list|)
expr_stmt|;
name|compile_heap2
operator|+=
name|strlen
argument_list|(
name|compile_heap2
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ot
operator|->
name|ot_text
operator|=
name|strdup
argument_list|(
operator|*
name|vec
operator|++
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ot
operator|->
name|ot_id
operator|=
name|strdup
argument_list|(
operator|*
name|vec
operator|++
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|ot
operator|->
name|ot_syntax
operator|=
name|text2syn
argument_list|(
operator|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"Aggregate"
argument_list|)
operator|&&
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: object \"%s\" has unknown SYNTAX \"%s\"\n"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"read-only"
argument_list|)
operator|==
literal|0
condition|)
name|ot
operator|->
name|ot_access
operator|=
name|OT_RDONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"read-write"
argument_list|)
operator|==
literal|0
condition|)
name|ot
operator|->
name|ot_access
operator|=
name|OT_RDWRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"write-only"
argument_list|)
operator|==
literal|0
condition|)
name|ot
operator|->
name|ot_access
operator|=
name|OT_WRONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"not-accessible"
argument_list|)
operator|&&
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: object \"%s\" has unknown ACCESS \"%s\"\n"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"mandatory"
argument_list|)
operator|==
literal|0
condition|)
name|ot
operator|->
name|ot_status
operator|=
name|OT_MANDATORY
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"optional"
argument_list|)
operator|==
literal|0
condition|)
name|ot
operator|->
name|ot_status
operator|=
name|OT_OPTIONAL
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"deprecated"
argument_list|)
operator|==
literal|0
condition|)
name|ot
operator|->
name|ot_status
operator|=
name|OT_DEPRECATED
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"obsolete"
argument_list|)
operator|&&
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: object \"%s\" has unknown STATUS \"%s\"\n"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
name|ot
operator|->
name|ot_chain
operator|=
name|Tbuckets
index|[
name|i
operator|=
name|THASH
argument_list|(
name|ot
operator|->
name|ot_text
argument_list|)
index|]
expr_stmt|;
name|Tbuckets
index|[
name|i
index|]
operator|=
name|ot
expr_stmt|;
if|if
condition|(
name|compile_flag
operator|>
literal|0
condition|)
block|{
name|chain
operator|->
name|ot_next
operator|=
name|ot
expr_stmt|;
name|chain
operator|=
name|ot
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* does not insert into THASH table... */
end_comment

begin_function
name|int
name|add_objects
parameter_list|(
name|ot
parameter_list|)
specifier|register
name|OT
name|ot
decl_stmt|;
block|{
specifier|register
name|OID
name|oid
init|=
name|ot
operator|->
name|ot_name
decl_stmt|;
specifier|register
name|OT
name|ot2
decl_stmt|,
modifier|*
name|otp
decl_stmt|;
if|if
condition|(
name|oid_cmp
argument_list|(
name|chain
operator|->
name|ot_name
argument_list|,
name|oid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|chain
operator|->
name|ot_next
operator|=
name|ot
expr_stmt|;
operator|(
name|chain
operator|=
name|ot
operator|)
operator|->
name|ot_next
operator|=
name|NULLOT
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|otp
operator|=
operator|&
name|anchor
init|;
name|ot2
operator|=
operator|*
name|otp
condition|;
name|otp
operator|=
operator|&
name|ot2
operator|->
name|ot_next
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|ot2
operator|->
name|ot_name
argument_list|,
name|oid
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|ot
operator|->
name|ot_next
operator|=
name|ot2
expr_stmt|;
operator|*
name|otp
operator|=
name|ot
expr_stmt|;
block|}
for|for
control|(
name|ot
operator|=
name|anchor
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
name|ot
operator|->
name|ot_sibling
operator|=
name|ot
operator|->
name|ot_children
operator|=
name|NULLOT
expr_stmt|;
return|return
name|add_objects_aux
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_objects_aux
parameter_list|()
block|{
specifier|register
name|OT
name|ot
decl_stmt|,
name|ot2
decl_stmt|;
for|for
control|(
name|ot
operator|=
name|anchor
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
block|{
name|OIDentifier
name|oids
decl_stmt|;
if|if
condition|(
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|<=
literal|1
condition|)
continue|continue;
name|ot2
operator|=
name|NULLOT
expr_stmt|;
for|for
control|(
name|oids
operator|.
name|oid_elements
operator|=
name|ot
operator|->
name|ot_name
operator|->
name|oid_elements
operator|,
name|oids
operator|.
name|oid_nelem
operator|=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|-
literal|1
init|;
name|oids
operator|.
name|oid_nelem
operator|>
literal|0
condition|;
name|oids
operator|.
name|oid_nelem
operator|--
control|)
if|if
condition|(
name|ot2
operator|=
name|name2obj
argument_list|(
operator|&
name|oids
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ot2
condition|)
block|{
name|ot
operator|->
name|ot_sibling
operator|=
name|ot2
operator|->
name|ot_children
expr_stmt|;
name|ot2
operator|->
name|ot_children
operator|=
name|ot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no distant parent for %s"
argument_list|,
name|sprintoid
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|OID
name|text2oid
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
name|unsigned
name|int
name|elements
index|[
name|NELEM
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|OID
name|oid
decl_stmt|,
name|new
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
init|;
name|cp
operator|>=
name|name
condition|;
name|cp
operator|--
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|cp
operator|!=
name|name
condition|)
for|for
control|(
name|cp
operator|++
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
comment|/* name */
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
name|name
condition|)
block|{
comment|/* 1.3.6.1.2.1.1.1.0 */
if|if
condition|(
operator|(
name|i
operator|=
name|str2elem
argument_list|(
name|cp
argument_list|,
name|elements
argument_list|)
operator|)
operator|<
literal|2
condition|)
return|return
name|NULL
return|;
block|}
elseif|else
comment|/* name.numbers */
if|if
condition|(
operator|(
name|i
operator|=
name|str2elem
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|elements
argument_list|)
operator|)
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|cp
operator|!=
name|name
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|oid
operator|=
name|resolve
argument_list|(
name|name
argument_list|,
name|NULLOT
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|oid
return|;
name|j
operator|=
name|oid
operator|->
name|oid_nelem
expr_stmt|;
block|}
else|else
name|oid
operator|=
name|NULL
operator|,
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
operator|(
name|OID
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
block|{
name|oid_free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|ip
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|+
name|j
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|oid_free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|)
expr_stmt|;
block|}
name|new
operator|->
name|oid_elements
operator|=
name|ip
operator|,
name|new
operator|->
name|oid_nelem
operator|=
name|i
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|oid
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|jp
operator|=
name|oid
operator|->
name|oid_elements
init|;
name|j
operator|<
name|oid
operator|->
name|oid_nelem
condition|;
name|j
operator|++
operator|,
name|jp
operator|++
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
expr_stmt|;
name|oid_free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|jp
operator|=
name|elements
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
operator|,
name|jp
operator|++
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
expr_stmt|;
name|new
operator|->
name|oid_nelem
operator|=
name|ip
operator|-
name|new
operator|->
name|oid_elements
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|OID
name|resolve
parameter_list|(
name|id
parameter_list|,
name|ot
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|elements
index|[
name|NELEM
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|OT
name|ot2
decl_stmt|;
name|struct
name|OIDentifier
name|oids
decl_stmt|;
specifier|register
name|OID
name|oid
init|=
operator|&
name|oids
decl_stmt|;
name|oid
operator|->
name|oid_elements
operator|=
name|elements
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|id
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|id
argument_list|)
condition|)
block|{
name|ot2
operator|=
name|NULLOT
expr_stmt|;
name|oid
operator|->
name|oid_nelem
operator|=
literal|1
expr_stmt|;
name|oid
operator|->
name|oid_elements
index|[
literal|0
index|]
operator|=
name|atoi
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
name|ot2
operator|=
name|text2obj
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|ot2
operator|==
name|NULLOT
operator|||
name|ot2
operator|->
name|ot_name
operator|==
name|NULLOID
condition|)
return|return
name|NULLOID
return|;
name|oid
operator|->
name|oid_nelem
operator|=
name|ot2
operator|->
name|ot_name
operator|->
name|oid_nelem
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ot2
operator|->
name|ot_name
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|oid
operator|->
name|oid_elements
argument_list|,
name|oid
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
expr|*
name|elements
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|str2elem
argument_list|(
operator|++
name|cp
argument_list|,
name|oid
operator|->
name|oid_elements
operator|+
name|oid
operator|->
name|oid_nelem
argument_list|)
operator|)
operator|<
literal|1
condition|)
return|return
name|NULLOID
return|;
name|oid
operator|->
name|oid_nelem
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|ot
operator|&&
name|ot2
condition|)
block|{
comment|/* XXX: not normalized... */
name|ot
operator|->
name|ot_sibling
operator|=
name|ot2
operator|->
name|ot_children
expr_stmt|;
name|ot2
operator|->
name|ot_children
operator|=
name|ot
expr_stmt|;
block|}
block|}
return|return
name|oid_cpy
argument_list|(
name|oid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* partial matches are made only on leaf nodes... */
end_comment

begin_function
name|OT
name|name2obj
parameter_list|(
name|oid
parameter_list|)
name|OID
name|oid
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|ip
decl_stmt|;
specifier|register
name|OID
name|nm
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
if|if
condition|(
name|oid
operator|==
name|NULLOID
operator|||
name|oid
operator|->
name|oid_nelem
operator|<
literal|1
operator|||
operator|(
name|i
operator|=
operator|(
name|ip
operator|=
name|oid
operator|->
name|oid_elements
operator|)
index|[
literal|0
index|]
operator|)
operator|>=
operator|(
sizeof|sizeof
name|roots
operator|/
sizeof|sizeof
name|roots
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|ot
operator|=
name|text2obj
argument_list|(
name|roots
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULLOT
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ot
condition|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
operator|(
name|nm
operator|=
name|ot
operator|->
name|ot_name
operator|)
operator|->
name|oid_nelem
operator|)
operator|>
name|oid
operator|->
name|oid_nelem
condition|)
return|return
name|NULLOT
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|nm
operator|->
name|oid_elements
operator|+
name|i
operator|)
argument_list|,
operator|(
name|j
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
expr|*
name|ip
argument_list|)
condition|)
name|ot
operator|=
name|ot
operator|->
name|ot_sibling
expr_stmt|;
elseif|else
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|==
name|j
operator|||
name|ot
operator|->
name|ot_children
operator|==
name|NULLOT
operator|||
name|ot
operator|->
name|ot_smux
condition|)
break|break;
else|else
block|{
name|ot
operator|=
name|ot
operator|->
name|ot_children
expr_stmt|;
name|ip
operator|=
name|oid
operator|->
name|oid_elements
operator|+
name|j
operator|,
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
return|return
name|ot
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|OT
name|text2obj
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|OT
name|ot
decl_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
operator|||
name|once_only
operator|==
literal|0
condition|)
return|return
name|NULLOT
return|;
for|for
control|(
name|ot
operator|=
name|Tbuckets
index|[
name|THASH
argument_list|(
name|text
argument_list|)
index|]
init|;
name|ot
operator|&&
name|strcmp
argument_list|(
name|ot
operator|->
name|ot_text
argument_list|,
name|text
argument_list|)
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_chain
control|)
continue|continue;
return|return
name|ot
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|char
modifier|*
name|oid2ode_aux
parameter_list|(
name|oid
parameter_list|,
name|quoted
parameter_list|)
name|OID
name|oid
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|OID
name|oid2
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|oid
operator|->
name|oid_nelem
operator|==
literal|2
comment|/* XXX: 0.0 is a special case */
operator|&&
name|oid
operator|->
name|oid_elements
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|oid
operator|->
name|oid_elements
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|ot
operator|=
name|name2obj
argument_list|(
name|oid
argument_list|)
operator|)
operator|==
name|NULLOT
condition|)
return|return
name|sprintoid
argument_list|(
name|oid
argument_list|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|oid
operator|->
name|oid_elements
operator|+
operator|(
name|oid2
operator|=
name|ot
operator|->
name|ot_name
operator|)
operator|->
name|oid_nelem
operator|,
name|i
operator|=
name|oid
operator|->
name|oid_nelem
operator|-
name|oid2
operator|->
name|oid_nelem
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|ip
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|".%u"
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|OI
name|name2inst
parameter_list|(
name|oid
parameter_list|)
name|OID
name|oid
decl_stmt|;
block|{
specifier|static
name|object_instance
name|ois
decl_stmt|;
specifier|register
name|OI
name|oi
init|=
operator|&
name|ois
decl_stmt|;
if|if
condition|(
operator|(
name|oi
operator|->
name|oi_type
operator|=
name|name2obj
argument_list|(
name|oi
operator|->
name|oi_name
operator|=
name|oid
argument_list|)
operator|)
operator|==
name|NULLOT
condition|)
return|return
name|NULLOI
return|;
return|return
name|oi
return|;
block|}
end_function

begin_function
name|OI
name|next2inst
parameter_list|(
name|oid
parameter_list|)
name|OID
name|oid
decl_stmt|;
block|{
specifier|static
name|object_instance
name|ois
decl_stmt|;
specifier|register
name|OI
name|oi
init|=
operator|&
name|ois
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
for|for
control|(
name|ot
operator|=
name|anchor
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
block|{
if|if
condition|(
name|ot
operator|->
name|ot_smux
condition|)
block|{
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|<
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|||
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oid
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ot
operator|->
name|ot_name
operator|->
name|oid_elements
argument_list|,
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
name|oid
operator|->
name|oid_elements
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|oid_cmp
argument_list|(
name|oid
argument_list|,
name|ot
operator|->
name|ot_name
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
name|oi
operator|->
name|oi_name
operator|=
operator|(
name|oi
operator|->
name|oi_type
operator|=
name|ot
operator|)
operator|->
name|ot_name
expr_stmt|;
return|return
name|oi
return|;
block|}
return|return
name|NULLOI
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|OI
name|text2inst
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|static
name|object_instance
name|ois
decl_stmt|;
specifier|register
name|OI
name|oi
init|=
operator|&
name|ois
decl_stmt|;
specifier|static
name|OID
name|oid
init|=
name|NULLOID
decl_stmt|;
if|if
condition|(
name|oid
condition|)
name|oid_free
argument_list|(
name|oid
argument_list|)
operator|,
name|oid
operator|=
name|NULLOID
expr_stmt|;
if|if
condition|(
operator|(
name|oid
operator|=
name|text2oid
argument_list|(
name|text
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NULLOI
return|;
if|if
condition|(
operator|(
name|oi
operator|->
name|oi_type
operator|=
name|name2obj
argument_list|(
name|oi
operator|->
name|oi_name
operator|=
name|oid
argument_list|)
operator|)
operator|==
name|NULLOT
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got name \"%s\", but not object\n"
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return
name|NULLOI
return|;
block|}
return|return
name|oi
return|;
block|}
end_function

begin_comment
comment|/*
comment|DUMP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|dump_objects_by_text
argument_list|()
end_macro

begin_block
block|{
name|int
name|hit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TBUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|hit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ot
operator|=
name|Tbuckets
index|[
name|i
index|]
init|;
name|ot
operator|&&
name|ot
operator|->
name|ot_text
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_chain
control|)
block|{
if|if
condition|(
operator|!
name|hit
condition|)
name|printf
argument_list|(
literal|"Bucket %d:\n"
argument_list|,
name|i
argument_list|)
operator|,
name|hit
operator|=
literal|1
expr_stmt|;
name|dump_object
argument_list|(
name|ot
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"///////\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dump_objects_by_tree
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
for|for
control|(
name|bp
operator|=
operator|(
name|ap
operator|=
name|roots
operator|)
operator|+
operator|(
sizeof|sizeof
name|roots
operator|/
sizeof|sizeof
name|roots
index|[
literal|0
index|]
operator|)
init|;
name|ap
operator|<
name|bp
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
name|dump_object_by_tree
argument_list|(
name|ot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no object for root \"%s\"\n"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"///////\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dump_object_by_tree
argument_list|(
name|ot
argument_list|,
name|i
argument_list|)
specifier|register
name|OT
name|ot
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ot
operator|==
name|NULL
condition|)
return|return;
name|dump_object
argument_list|(
name|ot
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_object_by_tree
argument_list|(
name|ot
operator|->
name|ot_children
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump_object_by_tree
argument_list|(
name|ot
operator|->
name|ot_sibling
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dump_objects_by_xxx
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|OT
name|ot
decl_stmt|;
for|for
control|(
name|ot
operator|=
name|anchor
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
name|dump_object
argument_list|(
name|ot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"///////\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|dump_object
argument_list|(
name|ot
argument_list|,
name|i
argument_list|)
specifier|register
name|OT
name|ot
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%*.*s%s %s %s %s %d %d 0x%x\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|,
name|ot
operator|->
name|ot_id
argument_list|,
name|sprintoid
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
argument_list|,
name|ot
operator|->
name|ot_syntax
condition|?
name|ot
operator|->
name|ot_syntax
operator|->
name|os_name
else|:
literal|"NULL"
argument_list|,
name|ot
operator|->
name|ot_access
argument_list|,
name|ot
operator|->
name|ot_status
argument_list|,
name|ot
operator|->
name|ot_smux
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|MISCELLANY */
end_comment

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

end_unit

