begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* routes.c - MIB support of the routing tables */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/routes.c,v 7.5 91/02/22 09:43:51 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/snmp/RCS/routes.c,v 7.5 91/02/22 09:43:51 mrose Interim $  *  * Contributed by NYSERNet Inc.  This work was partially supported by the  * U.S. Defense Advanced Research Projects Agency and the Rome Air Development  * Center of the U.S. Air Force Systems Command under contract number  * F30602-88-C-0016.  *  *  * $Log:	routes.c,v $  * Revision 7.5  91/02/22  09:43:51  mrose  * Interim 6.8  *   * Revision 7.4  90/12/18  10:13:45  mrose  * update  *   * Revision 7.3  90/10/17  14:33:22  mrose  * update  *   * Revision 7.2  90/05/22  20:30:31  mrose  * cache  *   * Revision 7.1  89/12/01  08:25:48  mrose  * touch-up  *   * Revision 7.0  89/11/23  22:23:21  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"mib.h"
end_include

begin_include
include|#
directive|include
file|"interfaces.h"
end_include

begin_include
include|#
directive|include
file|"routes.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|routeNumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rtetab
modifier|*
name|rts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rtetab
modifier|*
modifier|*
name|rtp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtetab
modifier|*
name|rts_inet
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD44
end_ifdef

begin_decl_stmt
name|struct
name|rtetab
modifier|*
name|rts_iso
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flush_rt_cache
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|rt_compar
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|struct
name|rtetab
modifier|*
modifier|*
name|a
decl_stmt|,
decl|*
modifier|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|*
name|a
operator|)
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
operator|-
operator|(
operator|*
name|b
operator|)
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
operator|)
condition|)
return|return
operator|(
name|i
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
return|return
name|elem_cmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|rt_instance
argument_list|,
operator|(
operator|*
name|a
operator|)
operator|->
name|rt_insize
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|rt_instance
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|rt_insize
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|get_routes
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|rthashsize
decl_stmt|,
name|tblsize
decl_stmt|;
ifdef|#
directive|ifdef
name|ultrix
name|struct
name|rtentry
modifier|*
modifier|*
name|rtaddr
decl_stmt|,
modifier|*
modifier|*
name|rtnet
decl_stmt|,
modifier|*
modifier|*
name|rthost
decl_stmt|;
else|#
directive|else
name|struct
name|mbuf
modifier|*
modifier|*
name|rtaddr
decl_stmt|,
modifier|*
modifier|*
name|rtnet
decl_stmt|,
modifier|*
modifier|*
name|rthost
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|rtetab
modifier|*
name|rt
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|struct
name|nlist
name|nzs
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|nz
init|=
operator|&
name|nzs
decl_stmt|;
specifier|static
name|int
name|lastq
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|quantum
operator|==
name|lastq
condition|)
return|return
name|OK
return|;
if|if
condition|(
operator|!
name|flush_rt_cache
operator|&&
name|offset
operator|==
name|type_SNMP_PDUs_get__next__request
operator|&&
name|quantum
operator|==
name|lastq
operator|+
literal|1
condition|)
block|{
comment|/* XXX: caching! */
name|lastq
operator|=
name|quantum
expr_stmt|;
return|return
name|OK
return|;
block|}
name|lastq
operator|=
name|quantum
operator|,
name|flush_rt_cache
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|rts
init|;
name|rt
condition|;
name|rt
operator|=
name|rp
control|)
block|{
name|rp
operator|=
name|rt
operator|->
name|rt_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
argument_list|)
expr_stmt|;
block|}
name|rts
operator|=
name|rts_inet
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
name|rts_iso
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|rtp
operator|=
operator|&
name|rts
operator|,
name|routeNumber
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
if|if
condition|(
name|nl
index|[
name|N_RADIX_NODE_HEAD
index|]
operator|.
name|n_value
condition|)
block|{
if|if
condition|(
name|get_radix_nodes
argument_list|()
operator|==
name|NOTOK
condition|)
goto|goto
name|out1
goto|;
goto|goto
name|sort_routes
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|getkmem
argument_list|(
name|nl
operator|+
name|N_RTHASHSIZE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rthashsize
argument_list|,
sizeof|sizeof
name|rthashsize
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|rthashsize
operator|==
literal|0
condition|)
comment|/* XXX: why is this? */
name|rthashsize
operator|=
literal|8
expr_stmt|;
name|tblsize
operator|=
name|rthashsize
operator|*
sizeof|sizeof
expr|*
name|rtaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|ultrix
if|if
condition|(
operator|(
name|rtnet
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|tblsize
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|rthost
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|tblsize
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|rtnet
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|tblsize
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|rthost
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|tblsize
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getkmem
argument_list|(
name|nl
operator|+
name|N_RTNET
argument_list|,
operator|(
name|caddr_t
operator|)
name|rtnet
argument_list|,
name|tblsize
argument_list|)
operator|==
name|NOTOK
operator|||
name|getkmem
argument_list|(
name|nl
operator|+
name|N_RTHOST
argument_list|,
operator|(
name|caddr_t
operator|)
name|rthost
argument_list|,
name|tblsize
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out2
goto|;
name|nz
operator|->
name|n_name
operator|=
literal|"struct route"
expr_stmt|;
for|for
control|(
name|rtaddr
operator|=
name|rtnet
init|;
name|rtaddr
condition|;
name|rtaddr
operator|=
name|rthost
operator|,
name|rthost
operator|=
name|NULL
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rthashsize
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|ultrix
name|struct
name|rtentry
name|ree
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|re
decl_stmt|;
for|for
control|(
name|re
operator|=
name|rtaddr
index|[
name|i
index|]
init|;
name|nz
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|re
condition|;
name|re
operator|=
name|ree
operator|.
name|rt_next
control|)
block|{
if|if
condition|(
name|getkmem
argument_list|(
name|nz
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ree
argument_list|,
sizeof|sizeof
name|ree
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out2
goto|;
if|if
condition|(
name|get_route
argument_list|(
operator|&
name|ree
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out2
goto|;
else|#
directive|else
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
name|ms
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|re
decl_stmt|;
for|for
control|(
name|m
operator|=
name|rtaddr
index|[
name|i
index|]
init|;
name|nz
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|m
condition|;
name|m
operator|=
name|ms
operator|.
name|m_next
control|)
block|{
if|if
condition|(
name|getkmem
argument_list|(
name|nz
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ms
argument_list|,
sizeof|sizeof
name|ms
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out2
goto|;
ifndef|#
directive|ifndef
name|BSD44
name|re
operator|=
name|mtod
argument_list|(
operator|&
name|ms
argument_list|,
expr|struct
name|rtentry
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|re
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|ms
operator|.
name|m_dat
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|get_route
argument_list|(
name|re
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out2
goto|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rtaddr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BSD44
name|sort_routes
label|:
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|routeNumber
operator|>
literal|1
condition|)
block|{
specifier|register
name|struct
name|rtetab
modifier|*
modifier|*
name|base
decl_stmt|,
modifier|*
modifier|*
name|rte
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
operator|(
expr|struct
name|rtetab
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|routeNumber
operator|*
sizeof|sizeof
expr|*
name|base
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|rte
operator|=
name|base
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|rts
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
operator|*
name|rte
operator|++
operator|=
name|rt
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|routeNumber
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|,
name|rt_compar
argument_list|)
expr_stmt|;
name|rtp
operator|=
name|base
expr_stmt|;
name|rt
operator|=
name|rts
operator|=
operator|*
name|rtp
operator|++
expr_stmt|;
name|rts_inet
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
name|rts_iso
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|rtp
operator|<
name|rte
condition|)
block|{
switch|switch
condition|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|rts_inet
operator|==
name|NULL
condition|)
name|rts_inet
operator|=
name|rt
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BSD44
case|case
name|AF_ISO
case|:
if|if
condition|(
name|rts_iso
operator|==
name|NULL
condition|)
name|rts_iso
operator|=
name|rt
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|rt
operator|->
name|rt_next
operator|=
operator|*
name|rtp
expr_stmt|;
name|rt
operator|=
operator|*
name|rtp
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|rts_inet
operator|==
name|NULL
condition|)
name|rts_inet
operator|=
name|rt
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BSD44
case|case
name|AF_ISO
case|:
if|if
condition|(
name|rts_iso
operator|==
name|NULL
condition|)
name|rts_iso
operator|=
name|rt
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|rt
operator|->
name|rt_next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
block|}
name|first_time
operator|=
literal|0
expr_stmt|;
return|return
name|OK
return|;
name|out2
label|:
empty_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rtnet
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rthost
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
name|out1
label|:
empty_stmt|;
endif|#
directive|endif
for|for
control|(
name|rt
operator|=
name|rts
init|;
name|rt
condition|;
name|rt
operator|=
name|rp
control|)
block|{
name|rp
operator|=
name|rt
operator|->
name|rt_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
argument_list|)
expr_stmt|;
block|}
name|rts
operator|=
name|rts_inet
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
name|rts_iso
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
name|NOTOK
return|;
block|}
comment|/*
comment|*/
specifier|static
name|int
name|get_route
parameter_list|(
name|re
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|re
decl_stmt|;
block|{
specifier|register
name|struct
name|rtetab
modifier|*
name|rt
decl_stmt|,
modifier|*
name|rz
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD44
name|union
name|sockaddr_un
name|rtsock
decl_stmt|;
name|struct
name|nlist
name|nzs
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|nz
init|=
operator|&
name|nzs
decl_stmt|;
endif|#
directive|endif
name|OIDentifier
name|oids
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD44
name|nz
operator|->
name|n_name
operator|=
literal|"union sockaddr_un"
operator|,
name|nz
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rt_key
argument_list|(
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|getkmem
argument_list|(
name|nz
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rtsock
argument_list|,
sizeof|sizeof
name|rtsock
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rt
operator|=
operator|(
expr|struct
name|rtetab
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|rt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_rt
operator|=
operator|*
name|re
expr_stmt|;
comment|/* struct copy */
ifndef|#
directive|ifndef
name|BSD44
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|=
name|re
operator|->
name|rt_dst
expr_stmt|;
comment|/* struct copy */
name|rt
operator|->
name|rt_gateway
operator|.
name|sa
operator|=
name|re
operator|->
name|rt_gateway
expr_stmt|;
comment|/*   .. */
else|#
directive|else
name|rt
operator|->
name|rt_dst
operator|=
name|rtsock
expr_stmt|;
comment|/* struct copy */
name|nz
operator|->
name|n_name
operator|=
literal|"union sockaddr_un"
operator|,
name|nz
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|re
operator|->
name|rt_gateway
expr_stmt|;
if|if
condition|(
name|getkmem
argument_list|(
name|nz
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rt
operator|->
name|rt_gateway
argument_list|,
sizeof|sizeof
name|rt
operator|->
name|rt_gateway
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
endif|#
directive|endif
switch|switch
condition|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|rt
operator|->
name|rt_insize
operator|=
name|ipaddr2oid
argument_list|(
name|rt
operator|->
name|rt_instance
argument_list|,
operator|&
name|rt
operator|->
name|rt_dst
operator|.
name|un_in
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rts_inet
operator|==
name|NULL
condition|)
comment|/* in case routeNumber == 1 */
name|rts_inet
operator|=
name|rt
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BSD44
case|case
name|AF_ISO
case|:
name|rt
operator|->
name|rt_insize
operator|=
name|clnpaddr2oid
argument_list|(
name|rt
operator|->
name|rt_instance
argument_list|,
operator|&
name|rt
operator|->
name|rt_dst
operator|.
name|un_iso
operator|.
name|siso_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rts_iso
operator|==
name|NULL
condition|)
comment|/* in case routeNumber == 1 */
name|rts_iso
operator|=
name|rt
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
operator|->
name|rt_instance
argument_list|,
sizeof|sizeof
name|rt
operator|->
name|rt_instance
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_insize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
for|for
control|(
name|rz
operator|=
name|rts
init|;
name|rz
condition|;
name|rz
operator|=
name|rz
operator|->
name|rt_next
control|)
if|if
condition|(
name|rz
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
operator|&&
name|elem_cmp
argument_list|(
name|rz
operator|->
name|rt_instance
argument_list|,
name|rz
operator|->
name|rt_insize
argument_list|,
name|rt
operator|->
name|rt_instance
argument_list|,
name|rt
operator|->
name|rt_insize
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|rz
condition|)
block|{
if|if
condition|(
name|first_time
condition|)
block|{
name|oids
operator|.
name|oid_elements
operator|=
name|rt
operator|->
name|rt_instance
expr_stmt|;
name|oids
operator|.
name|oid_nelem
operator|=
name|rt
operator|->
name|rt_insize
expr_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"duplicate routes for destination %d/%s"
argument_list|,
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|sprintoid
argument_list|(
operator|&
name|oids
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rt
operator|->
name|rt_instance
index|[
name|rt
operator|->
name|rt_insize
operator|++
index|]
operator|=
operator|++
name|rz
operator|->
name|rt_magic
expr_stmt|;
block|}
operator|*
name|rtp
operator|=
name|rt
operator|,
name|rtp
operator|=
operator|&
name|rt
operator|->
name|rt_next
operator|,
name|routeNumber
operator|++
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|first_time
condition|)
block|{
name|oids
operator|.
name|oid_elements
operator|=
name|rt
operator|->
name|rt_instance
expr_stmt|;
name|oids
operator|.
name|oid_nelem
operator|=
name|rt
operator|->
name|rt_insize
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"add route: %d/%s on interface 0x%x with flags %d"
argument_list|,
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|sprintoid
argument_list|(
operator|&
name|oids
argument_list|)
argument_list|,
name|re
operator|->
name|rt_ifp
argument_list|,
name|re
operator|->
name|rt_flags
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|BSD44
specifier|static
name|int
name|get_radix_nodes
parameter_list|()
block|{
name|struct
name|radix_node_head
modifier|*
name|rnh
decl_stmt|,
name|head
decl_stmt|;
name|struct
name|nlist
name|nzs
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|nz
init|=
operator|&
name|nzs
decl_stmt|;
if|if
condition|(
name|getkmem
argument_list|(
name|nl
operator|+
name|N_RADIX_NODE_HEAD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rnh
argument_list|,
sizeof|sizeof
name|rnh
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
while|while
condition|(
name|rnh
condition|)
block|{
name|nz
operator|->
name|n_name
operator|=
literal|"struct radix_node_head"
operator|,
name|nz
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rnh
expr_stmt|;
if|if
condition|(
name|getkmem
argument_list|(
name|nz
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|head
argument_list|,
sizeof|sizeof
name|head
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|rnh
operator|=
name|head
operator|.
name|rnh_next
expr_stmt|;
if|if
condition|(
name|head
operator|.
name|rnh_af
operator|==
name|AF_UNSPEC
condition|)
continue|continue;
if|if
condition|(
name|get_radix_node
argument_list|(
name|head
operator|.
name|rnh_treetop
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
comment|/*
comment|*/
specifier|static
name|int
name|get_radix_node
parameter_list|(
name|rn
parameter_list|)
name|struct
name|radix_node
modifier|*
name|rn
decl_stmt|;
block|{
name|struct
name|radix_node
name|rnode
decl_stmt|;
name|struct
name|rtentry
name|rtentry
decl_stmt|;
name|struct
name|nlist
name|nzs
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|nz
init|=
operator|&
name|nzs
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nz
operator|->
name|n_name
operator|=
literal|"struct radix_node"
operator|,
name|nz
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rn
expr_stmt|;
if|if
condition|(
name|getkmem
argument_list|(
name|nz
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rnode
argument_list|,
sizeof|sizeof
name|rnode
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|rnode
operator|.
name|rn_b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rnode
operator|.
name|rn_flags
operator|&
name|RNF_ROOT
operator|)
condition|)
block|{
name|nz
operator|->
name|n_name
operator|=
literal|"struct rtentry"
operator|,
name|nz
operator|->
name|n_value
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rn
expr_stmt|;
if|if
condition|(
name|getkmem
argument_list|(
name|nz
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rtentry
argument_list|,
sizeof|sizeof
name|rtentry
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|get_route
argument_list|(
operator|&
name|rtentry
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|rn
operator|=
name|rnode
operator|.
name|rn_dupedkey
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|get_radix_node
argument_list|(
name|rnode
operator|.
name|rn_l
argument_list|)
operator|==
name|NOTOK
operator|||
name|get_radix_node
argument_list|(
name|rnode
operator|.
name|rn_r
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
block|}
endif|#
directive|endif
comment|/*
comment|*/
name|struct
name|rtetab
modifier|*
name|get_rtent
parameter_list|(
name|ip
parameter_list|,
name|len
parameter_list|,
name|head
parameter_list|,
name|isnext
parameter_list|)
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|rtetab
modifier|*
name|head
decl_stmt|;
name|int
name|isnext
decl_stmt|;
block|{
name|int
name|family
decl_stmt|;
specifier|register
name|struct
name|rtetab
modifier|*
name|rt
decl_stmt|;
if|if
condition|(
name|head
condition|)
name|family
operator|=
name|head
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|head
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_next
control|)
if|if
condition|(
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|family
condition|)
break|break;
else|else
switch|switch
condition|(
name|elem_cmp
argument_list|(
name|rt
operator|->
name|rt_instance
argument_list|,
name|rt
operator|->
name|rt_insize
argument_list|,
name|ip
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|isnext
condition|)
return|return
name|rt
return|;
if|if
condition|(
operator|(
name|rt
operator|=
name|rt
operator|->
name|rt_next
operator|)
operator|==
name|NULL
operator|||
name|rt
operator|->
name|rt_dst
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|family
condition|)
goto|goto
name|out
goto|;
comment|/* else fall... */
case|case
literal|1
case|:
return|return
operator|(
name|isnext
condition|?
name|rt
else|:
name|NULL
operator|)
return|;
block|}
name|out
label|:
empty_stmt|;
name|flush_rt_cache
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

