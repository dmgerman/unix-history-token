begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* snmpb.c - snmpi bulk load */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/snmpb.c,v 7.15 91/02/22 09:44:08 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/snmp/RCS/snmpb.c,v 7.15 91/02/22 09:44:08 mrose Interim $  *  * Contributed by NYSERNet Inc.  This work was partially supported by the  * U.S. Defense Advanced Research Projects Agency and the Rome Air Development  * Center of the U.S. Air Force Systems Command under contract number  * F30602-88-C-0016.  *  *  * $Log:	snmpb.c,v $  * Revision 7.15  91/02/22  09:44:08  mrose  * Interim 6.8  *   * Revision 7.14  90/09/17  11:18:42  mrose  * update  *   * Revision 7.13  90/09/10  13:52:21  mrose  * kzm  *   * Revision 7.11  90/09/03  12:57:30  mrose  * update  *   * Revision 7.10  90/08/28  10:29:24  mrose  * kzm  *   * Revision 7.9  90/08/23  12:34:29  mrose  * update  *   * Revision 7.8  90/08/20  21:25:56  mrose  * touch-up  *   * Revision 7.7  90/08/20  14:00:14  mrose  * kzm  *   * Revision 7.6  90/08/19  16:26:25  mrose  * again  *   * Revision 7.5  90/08/18  15:24:08  mrose  * one more time  *   * Revision 7.4  90/08/18  01:28:40  mrose  * again  *   * Revision 7.3  90/08/18  00:44:39  mrose  * touch-up  *   * Revision 7.2  90/08/16  16:50:37  mrose  * again  *   * Revision 7.1  90/08/14  14:28:43  mrose  * pktin  *   * Revision 7.0  90/08/08  14:00:19  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"SNMP-types.h"
end_include

begin_include
include|#
directive|include
file|"objects.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_define
define|#
directive|define
name|MAXTIME
value|(60 * 1000L)
end_define

begin_comment
comment|/* in milli-seconds */
end_comment

begin_define
define|#
directive|define
name|MINTIME
value|1
end_define

begin_comment
comment|/*   .. */
end_comment

begin_define
define|#
directive|define
name|SETTLETIME
value|30
end_define

begin_comment
comment|/* # of iterations to gauge RTT */
end_comment

begin_define
define|#
directive|define
name|MAXTRIES
value|3
end_define

begin_comment
comment|/* for retries */
end_comment

begin_define
define|#
directive|define
name|MAXSPACE
value|0x10000
end_define

begin_comment
comment|/* in between threads */
end_comment

begin_define
define|#
directive|define
name|MAXTHREADS
value|10
end_define

begin_comment
comment|/* maximum #-simultaneous */
end_comment

begin_define
define|#
directive|define
name|MAXBOUNDS
value|10
end_define

begin_define
define|#
directive|define
name|MINBOUNDS
value|3
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* TIMING INFORMATION */
end_comment

begin_decl_stmt
specifier|static
name|long
name|timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|timenow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|timemin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|timemax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timelap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timelap2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|RTTperthread
init|=
name|MAXTIME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BINDING INFORMATION (results) */
end_comment

begin_struct
struct|struct
name|binding
block|{
name|OID
name|b_name
decl_stmt|;
union|union
block|{
name|PE
name|un_value
decl_stmt|;
name|struct
name|binding
modifier|*
name|un_cols
decl_stmt|;
block|}
name|b_un
union|;
define|#
directive|define
name|b_value
value|b_un.un_value
define|#
directive|define
name|b_cols
value|b_un.un_cols
name|struct
name|binding
modifier|*
name|b_next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* INVOCATION INFORMATION */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|invocation
block|{
name|struct
name|type_SNMP_Message
modifier|*
name|i_msg
decl_stmt|;
name|int
name|i_info
decl_stmt|;
comment|/* info>  0: response 				   info == 0: request 				   info<  0: not yet ready */
name|int
name|i_rid
decl_stmt|;
comment|/* request-id of interest */
name|int
name|i_mid
decl_stmt|;
comment|/* exclusive ceiling on i_rid */
name|PE
name|i_pe
decl_stmt|;
comment|/* message to retry */
name|int
name|i_retries
decl_stmt|;
comment|/* number of times request retried */
name|u_long
name|i_lastime
decl_stmt|;
comment|/* time last request sent */
name|int
name|i_curinvokes
decl_stmt|;
comment|/* current # threads when last request sent */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|totreqs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|totretr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|totrsps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|totdups
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* THREAD INFORMATION */
end_comment

begin_struct
struct|struct
name|thread
block|{
name|struct
name|thread
modifier|*
name|t_forw
decl_stmt|;
comment|/* doubly-linked list */
name|struct
name|thread
modifier|*
name|t_back
decl_stmt|;
comment|/*   .. */
name|OID
name|t_lo
decl_stmt|;
comment|/* inclusive lower-bound */
name|OID
name|t_arg
decl_stmt|;
comment|/* current pointer */
name|OID
name|t_hi
decl_stmt|;
comment|/* exclusive upper-bound */
name|struct
name|binding
modifier|*
name|t_binding
decl_stmt|;
comment|/* for bulk2_aux() */
name|struct
name|invocation
name|t_invoke
decl_stmt|;
comment|/* invocation in progress */
define|#
directive|define
name|t_msg
value|t_invoke.i_msg
define|#
directive|define
name|t_info
value|t_invoke.i_info
define|#
directive|define
name|t_rid
value|t_invoke.i_rid
define|#
directive|define
name|t_mid
value|t_invoke.i_mid
define|#
directive|define
name|t_pe
value|t_invoke.i_pe
define|#
directive|define
name|t_retries
value|t_invoke.i_retries
define|#
directive|define
name|t_lastime
value|t_invoke.i_lastime
define|#
directive|define
name|t_curinvokes
value|t_invoke.i_curinvokes
comment|/* statistics */
name|int
name|t_gns
decl_stmt|;
comment|/* how many gn's done */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|once_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|thread
name|tque
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active thread list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|thread
modifier|*
name|THead
init|=
operator|&
name|tque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curthreads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxthreads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tothreads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nilthreads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dedthreads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|threadlimit
init|=
name|MAXTHREADS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* REQUEST INFORMATION */
end_comment

begin_struct
struct|struct
name|request
block|{
name|struct
name|request
modifier|*
name|r_forw
decl_stmt|;
comment|/* doubly-linked list */
name|struct
name|request
modifier|*
name|r_back
decl_stmt|;
comment|/*   .. */
name|int
name|r_nbound
decl_stmt|;
comment|/* number of bounds active */
struct|struct
name|bound
block|{
name|OID
name|r_lo
decl_stmt|;
comment|/* inclusive lower bound */
name|OID
name|r_arg
decl_stmt|;
comment|/* current pointer */
name|OID
name|r_hi
decl_stmt|;
comment|/* exclusive upper bound */
name|int
name|b_gns
decl_stmt|;
comment|/* stats: how many gn's done */
name|struct
name|bound
modifier|*
name|r_next
decl_stmt|;
block|}
modifier|*
name|r_bounds
struct|;
name|struct
name|invocation
name|r_invoke
decl_stmt|;
comment|/* invocation in progress... */
define|#
directive|define
name|r_msg
value|r_invoke.i_msg
define|#
directive|define
name|r_info
value|r_invoke.i_info
define|#
directive|define
name|r_rid
value|r_invoke.i_rid
define|#
directive|define
name|r_mid
value|r_invoke.i_mid
define|#
directive|define
name|r_pe
value|r_invoke.i_pe
define|#
directive|define
name|r_retries
value|r_invoke.i_retries
define|#
directive|define
name|r_lastime
value|r_invoke.i_lastime
define|#
directive|define
name|r_curinvokes
value|r_invoke.i_curinvokes
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|request
name|rque
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active request list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|request
modifier|*
name|RHead
init|=
operator|&
name|rque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|currequests
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxrequests
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|totbounds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxbounds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nilbounds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dedrequests
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|boundlimit
init|=
name|MAXBOUNDS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MISCELLANEOUS INFORMATION */
end_comment

begin_decl_stmt
name|OID
name|oid_median
argument_list|()
decl_stmt|,
name|oid_copy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|watch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|adios
argument_list|()
decl_stmt|,
name|advise
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|snmp_error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|BULK1 */
end_comment

begin_comment
comment|/* algorithm assumes that first variable in VarBind has ubiquitous agent    support...  */
end_comment

begin_macro
name|bulk1
argument_list|(
argument|ps
argument_list|,
argument|sd
argument_list|,
argument|vb
argument_list|,
argument|community
argument_list|)
end_macro

begin_decl_stmt
name|PS
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|community
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|backoff
decl_stmt|,
name|rows
decl_stmt|;
specifier|register
name|struct
name|thread
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|binding
modifier|*
modifier|*
name|bp
decl_stmt|;
name|struct
name|binding
modifier|*
name|bl
decl_stmt|;
name|struct
name|timeval
name|tvs
decl_stmt|,
name|now
decl_stmt|;
specifier|register
name|OID
name|a
decl_stmt|,
name|b
decl_stmt|;
name|OID
name|arg
decl_stmt|;
name|timeout
operator|=
literal|2
operator|*
literal|1000L
expr_stmt|;
name|timemin
operator|=
name|timemax
operator|=
name|timeout
expr_stmt|;
name|curthreads
operator|=
name|maxthreads
operator|=
name|tothreads
operator|=
name|nilthreads
operator|=
name|dedthreads
operator|=
literal|0
expr_stmt|;
name|threadlimit
operator|=
name|MAXTHREADS
expr_stmt|;
name|RTTperthread
operator|=
name|MAXTIME
expr_stmt|;
name|totreqs
operator|=
name|totretr
operator|=
name|totrsps
operator|=
name|totdups
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tvs
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|timenow
operator|=
name|tvs
operator|.
name|tv_sec
operator|*
literal|1000L
operator|+
name|tvs
operator|.
name|tv_usec
operator|/
literal|1000L
expr_stmt|;
name|a
operator|=
name|oid_copy
argument_list|(
name|arg
operator|=
name|vb
operator|->
name|VarBind
operator|->
name|name
argument_list|)
expr_stmt|;
name|a
operator|->
name|oid_elements
index|[
name|a
operator|->
name|oid_nelem
operator|++
index|]
operator|=
literal|127
expr_stmt|;
if|if
condition|(
name|new_thread
argument_list|(
name|ps
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
name|arg
argument_list|,
name|a
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|b
operator|=
name|oid_copy
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|b
operator|->
name|oid_elements
index|[
name|b
operator|->
name|oid_nelem
operator|++
index|]
operator|=
literal|192
expr_stmt|;
if|if
condition|(
name|new_thread
argument_list|(
name|ps
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|a
operator|->
name|oid_elements
index|[
operator|(
operator|--
name|a
operator|->
name|oid_nelem
operator|)
operator|-
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|new_thread
argument_list|(
name|ps
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|oid_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|bl
operator|,
name|bl
operator|=
name|NULL
operator|,
name|rows
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|timelap
operator|=
literal|0
init|;
name|THead
operator|->
name|t_forw
operator|!=
name|THead
condition|;
name|timelap
operator|++
control|)
block|{
specifier|register
name|struct
name|binding
modifier|*
name|bv
decl_stmt|;
name|struct
name|thread
modifier|*
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|backoff
operator|=
name|wait_for_action
argument_list|(
name|sd
argument_list|,
name|ps
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
break|break;
for|for
control|(
name|t
operator|=
name|THead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|THead
condition|;
name|t
operator|=
name|u
control|)
block|{
specifier|register
name|struct
name|binding
modifier|*
modifier|*
name|bz
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
decl_stmt|,
modifier|*
name|vb2
decl_stmt|;
name|struct
name|OIDentifier
name|oids
decl_stmt|;
name|u
operator|=
name|t
operator|->
name|t_forw
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|t_info
condition|)
continue|continue;
if|if
condition|(
name|oid_cmp
argument_list|(
name|t
operator|->
name|t_arg
argument_list|,
name|b
operator|=
name|t
operator|->
name|t_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|->
name|variable__bindings
operator|->
name|VarBind
operator|->
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|oid2ode
argument_list|(
name|t
operator|->
name|t_arg
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"agent botched get-next (%s -> %s), thread dead"
argument_list|,
name|buffer
argument_list|,
name|oid2ode
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|free_thread
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dedthreads
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|b
argument_list|,
name|t
operator|->
name|t_hi
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|free_thread
argument_list|(
name|t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|oid_free
argument_list|(
name|t
operator|->
name|t_arg
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_arg
operator|=
name|oid_copy
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|a
operator|=
name|vb
operator|->
name|VarBind
operator|->
name|name
operator|,
name|b
operator|=
name|t
operator|->
name|t_arg
expr_stmt|;
name|oids
operator|.
name|oid_nelem
operator|=
name|b
operator|->
name|oid_nelem
operator|-
name|a
operator|->
name|oid_nelem
expr_stmt|;
name|oids
operator|.
name|oid_elements
operator|=
name|b
operator|->
name|oid_elements
operator|+
name|a
operator|->
name|oid_nelem
expr_stmt|;
if|if
condition|(
operator|(
name|bv
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|bv
operator|,
name|bp
operator|=
operator|&
name|bv
operator|->
name|b_next
expr_stmt|;
name|bv
operator|->
name|b_name
operator|=
name|oid_copy
argument_list|(
operator|&
name|oids
argument_list|)
expr_stmt|;
name|bz
operator|=
operator|&
name|bv
operator|->
name|b_cols
expr_stmt|;
name|rows
operator|++
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|t
operator|->
name|t_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|->
name|variable__bindings
operator|,
name|vb2
operator|=
name|vb
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
operator|,
name|vb2
operator|=
name|vb2
operator|->
name|next
control|)
block|{
name|int
name|fixup
init|=
literal|0
decl_stmt|;
name|a
operator|=
name|vb2
operator|->
name|VarBind
operator|->
name|name
operator|,
name|b
operator|=
name|vp
operator|->
name|VarBind
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|oid_nelem
operator|>
name|b
operator|->
name|oid_nelem
operator|||
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|oid_elements
argument_list|,
name|a
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
name|a
operator|->
name|oid_elements
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|oid_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|vp
operator|->
name|VarBind
operator|->
name|name
operator|=
name|b
operator|=
name|oid_copy
argument_list|(
name|t
operator|->
name|t_arg
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|oid_elements
argument_list|,
name|a
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
expr|*
name|a
operator|->
name|oid_elements
argument_list|)
expr_stmt|;
comment|/* not really needed... 		    pe_free (vp -> VarBind -> value); 		    if ((vp -> VarBind -> value = pe_alloc (PE_CLASS_UNIV, 							     PE_FORM_PRIM, 							     PE_PRIM_NULL)) 			    == NULL) 			adios (NULLCP, "out of memory");  */
name|fixup
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bv
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|bz
operator|=
name|bv
operator|,
name|bz
operator|=
operator|&
name|bv
operator|->
name|b_next
expr_stmt|;
name|bv
operator|->
name|b_name
operator|=
name|oid_copy
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fixup
condition|)
block|{
name|bv
operator|->
name|b_value
operator|=
name|vp
operator|->
name|VarBind
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|VarBind
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|curthreads
operator|<
name|threadlimit
operator|&&
operator|!
name|backoff
operator|&&
operator|(
name|a
operator|=
name|oid_median
argument_list|(
name|t
operator|->
name|t_arg
argument_list|,
name|t
operator|->
name|t_hi
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|new_thread
argument_list|(
name|ps
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
name|a
argument_list|,
name|t
operator|->
name|t_hi
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|remque
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* fairness in splits... */
name|insque
argument_list|(
name|t
argument_list|,
name|THead
operator|->
name|t_back
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|t
operator|->
name|t_hi
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_hi
operator|=
name|a
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|next_thread
argument_list|(
name|t
argument_list|,
name|ps
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
block|}
block|}
if|if
condition|(
name|backoff
operator|==
name|NOTOK
condition|)
block|{
name|losing
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"aborting bulk retrieval..."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|THead
operator|->
name|t_forw
operator|)
operator|!=
name|THead
condition|)
name|free_thread
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|now
operator|.
name|tv_sec
operator|-=
name|tvs
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|.
name|tv_usec
operator|-=
name|tvs
operator|.
name|tv_usec
operator|)
operator|<
literal|0
condition|)
name|now
operator|.
name|tv_sec
operator|--
operator|,
name|now
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%d row%s retrieved in %d.%06d seconds during %d iterations"
argument_list|,
name|rows
argument_list|,
name|rows
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|now
operator|.
name|tv_sec
argument_list|,
name|now
operator|.
name|tv_usec
argument_list|,
name|timelap
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"threads:  at most %d active, total of %d created, and %d did nothing"
argument_list|,
name|maxthreads
argument_list|,
name|tothreads
argument_list|,
name|nilthreads
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"messages: %d request%s sent,  along with %d retr%s"
argument_list|,
name|totreqs
argument_list|,
name|totreqs
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|totretr
argument_list|,
name|totretr
operator|!=
literal|1
condition|?
literal|"ies"
else|:
literal|"y"
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"          %d response%s rcvd, along with %d duplicate%s"
argument_list|,
name|totrsps
argument_list|,
name|totrsps
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|totdups
argument_list|,
name|totdups
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"timeouts: min=%d.%03d fin=%d.%03d max=%d.%03d seconds"
argument_list|,
name|timemin
operator|/
literal|1000
argument_list|,
name|timemin
operator|%
literal|1000
argument_list|,
name|timeout
operator|/
literal|1000
argument_list|,
name|timeout
operator|%
literal|1000
argument_list|,
name|timemax
operator|/
literal|1000
argument_list|,
name|timemax
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|print_bulk
argument_list|(
name|bl
argument_list|,
name|vb
argument_list|,
name|dedthreads
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|wait_for_action
parameter_list|(
name|sd
parameter_list|,
name|ps
parameter_list|)
name|int
name|sd
decl_stmt|;
name|PS
name|ps
decl_stmt|;
block|{
name|int
name|backoff
decl_stmt|,
name|n
decl_stmt|,
name|nfds
decl_stmt|,
name|request_id
decl_stmt|;
name|long
name|maxrtt
decl_stmt|;
name|u_long
name|lastime
decl_stmt|;
name|fd_set
name|rfds
decl_stmt|;
name|struct
name|timeval
name|tvs
decl_stmt|;
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDU
modifier|*
name|parm
decl_stmt|;
specifier|register
name|struct
name|invocation
modifier|*
name|i
decl_stmt|;
specifier|register
name|struct
name|request
modifier|*
name|r
decl_stmt|,
modifier|*
name|u
decl_stmt|;
specifier|register
name|struct
name|thread
modifier|*
name|t
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|nfds
operator|=
name|sd
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|sd
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
name|lastime
operator|=
name|timenow
expr_stmt|;
for|for
control|(
name|t
operator|=
name|THead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|THead
condition|;
name|t
operator|=
name|t
operator|->
name|t_forw
control|)
block|{
if|if
condition|(
name|t
operator|->
name|t_info
condition|)
comment|/* should always fail... */
continue|continue;
for|for
control|(
name|s
operator|=
name|t
operator|->
name|t_forw
init|;
name|s
operator|!=
name|THead
condition|;
name|s
operator|=
name|s
operator|->
name|t_forw
control|)
if|if
condition|(
operator|!
name|s
operator|->
name|t_info
operator|&&
name|s
operator|->
name|t_lastime
operator|<
name|t
operator|->
name|t_lastime
condition|)
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|lastime
operator|>
name|t
operator|->
name|t_lastime
condition|)
name|lastime
operator|=
name|t
operator|->
name|t_lastime
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
init|;
name|r
operator|!=
name|RHead
condition|;
name|r
operator|=
name|r
operator|->
name|r_forw
control|)
block|{
if|if
condition|(
name|r
operator|->
name|r_info
condition|)
comment|/* should always fail... */
continue|continue;
for|for
control|(
name|u
operator|=
name|r
operator|->
name|r_forw
init|;
name|u
operator|!=
name|RHead
condition|;
name|u
operator|=
name|u
operator|->
name|r_forw
control|)
if|if
condition|(
operator|!
name|u
operator|->
name|r_info
operator|&&
name|u
operator|->
name|r_lastime
operator|<
name|r
operator|->
name|r_lastime
condition|)
name|r
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|lastime
operator|>
name|r
operator|->
name|r_lastime
condition|)
name|lastime
operator|=
name|r
operator|->
name|r_lastime
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|maxrtt
operator|=
name|timeout
operator|-
operator|(
name|timenow
operator|-
name|lastime
operator|)
operator|)
operator|<
literal|0
condition|)
name|maxrtt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|maxrtt
operator|<
name|timeout
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"timeout reduced from %u to %u (delta %d)\n"
argument_list|,
name|timeout
argument_list|,
operator|(
name|u_long
operator|)
name|maxrtt
argument_list|,
call|(
name|int
call|)
argument_list|(
name|timeout
operator|-
name|maxrtt
argument_list|)
argument_list|)
expr_stmt|;
name|tvs
operator|.
name|tv_sec
operator|=
name|maxrtt
operator|/
literal|1000L
operator|,
name|tvs
operator|.
name|tv_usec
operator|=
operator|(
name|maxrtt
operator|%
literal|1000
operator|)
operator|*
literal|1000L
expr_stmt|;
name|maxrtt
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|n
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
operator|&
name|tvs
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
literal|"failed"
argument_list|,
literal|"select"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
default|default:
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tvs
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|timenow
operator|=
name|tvs
operator|.
name|tv_sec
operator|*
literal|1000L
operator|+
name|tvs
operator|.
name|tv_usec
operator|/
literal|1000L
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|OK
condition|)
break|break;
name|again
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ps2pe: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|decode_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"decode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|oops
label|:
empty_stmt|;
if|if
condition|(
name|msg
condition|)
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|watch
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"read PDU\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|totrsps
operator|++
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|data
operator|->
name|offset
operator|!=
name|type_SNMP_PDUs_get__response
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unexpected message type %d"
argument_list|,
name|msg
operator|->
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
name|request_id
operator|=
operator|(
name|parm
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|)
operator|->
name|request__id
expr_stmt|;
for|for
control|(
name|t
operator|=
name|THead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|THead
condition|;
name|t
operator|=
name|s
control|)
block|{
name|s
operator|=
name|t
operator|->
name|t_forw
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_rid
operator|!=
name|request_id
condition|)
continue|continue;
if|if
condition|(
name|t
operator|->
name|t_info
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"duplicated response for request-id %d"
argument_list|,
name|request_id
argument_list|)
expr_stmt|;
goto|goto
name|duplicate_id
goto|;
block|}
name|t
operator|->
name|t_info
operator|=
literal|1
expr_stmt|;
name|free_SNMP_Message
argument_list|(
name|t
operator|->
name|t_msg
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_msg
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_pe
condition|)
name|pe_free
argument_list|(
name|t
operator|->
name|t_pe
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_pe
operator|=
name|pe
expr_stmt|;
if|if
condition|(
name|parm
operator|->
name|error__status
operator|!=
name|int_SNMP_error__status_noError
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|error__status
operator|!=
name|int_SNMP_error__status_noSuchName
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s for get-next of %s, thread dead"
argument_list|,
name|snmp_error
argument_list|(
name|parm
operator|->
name|error__status
argument_list|)
argument_list|,
name|oid2ode
argument_list|(
name|t
operator|->
name|t_arg
argument_list|)
argument_list|)
expr_stmt|;
name|free_thread
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dedthreads
operator|++
expr_stmt|;
block|}
name|i
operator|=
operator|&
name|t
operator|->
name|t_invoke
expr_stmt|;
goto|goto
name|finish_invoke
goto|;
block|}
for|for
control|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
init|;
name|r
operator|!=
name|RHead
condition|;
name|r
operator|=
name|u
control|)
block|{
name|u
operator|=
name|r
operator|->
name|r_forw
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|r_rid
operator|!=
name|request_id
condition|)
continue|continue;
if|if
condition|(
name|r
operator|->
name|r_info
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"duplicated response for request-id %d"
argument_list|,
name|request_id
argument_list|)
expr_stmt|;
goto|goto
name|duplicate_id
goto|;
block|}
switch|switch
condition|(
name|parm
operator|->
name|error__status
condition|)
block|{
case|case
name|int_SNMP_error__status_noError
case|:
name|r
operator|->
name|r_info
operator|=
literal|1
expr_stmt|;
name|free_SNMP_Message
argument_list|(
name|r
operator|->
name|r_msg
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_msg
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|r_pe
condition|)
name|pe_free
argument_list|(
name|r
operator|->
name|r_pe
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_pe
operator|=
name|pe
expr_stmt|;
break|break;
case|case
name|int_SNMP_error__status_tooBig
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"got %s on request of size %d"
argument_list|,
name|snmp_error
argument_list|(
name|parm
operator|->
name|error__status
argument_list|)
argument_list|,
name|r
operator|->
name|r_nbound
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|r
operator|->
name|r_nbound
operator|&&
name|r
operator|->
name|r_nbound
operator|<=
name|boundlimit
condition|)
name|boundlimit
operator|=
name|r
operator|->
name|r_nbound
operator|-
literal|1
expr_stmt|;
name|toss_it
label|:
empty_stmt|;
name|r
operator|->
name|r_info
operator|=
operator|-
literal|1
expr_stmt|;
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
goto|goto
name|next_request
goto|;
case|case
name|int_SNMP_error__status_noSuchName
case|:
if|if
condition|(
name|parm
operator|->
name|error__index
operator|==
literal|0
condition|)
block|{
name|invalid_index
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"got %s with invalid index (%d)"
argument_list|,
name|snmp_error
argument_list|(
name|parm
operator|->
name|error__status
argument_list|)
argument_list|,
name|parm
operator|->
name|error__index
argument_list|)
expr_stmt|;
goto|goto
name|drop_request
goto|;
block|}
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|bound
modifier|*
name|b
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|v
decl_stmt|,
modifier|*
modifier|*
name|vp
decl_stmt|;
name|bp
operator|=
operator|&
name|r
operator|->
name|r_bounds
expr_stmt|;
name|vp
operator|=
operator|&
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
expr_stmt|;
for|for
control|(
name|j
operator|=
name|parm
operator|->
name|error__index
init|;
operator|--
name|j
operator|>
literal|0
condition|;
name|bp
operator|=
operator|&
operator|(
operator|(
operator|*
name|bp
operator|)
operator|->
name|r_next
operator|)
operator|,
name|vp
operator|=
operator|&
operator|(
operator|(
operator|*
name|vp
operator|)
operator|->
name|next
operator|)
control|)
if|if
condition|(
operator|*
name|bp
operator|==
name|NULL
condition|)
goto|goto
name|invalid_index
goto|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"got %s on %s"
argument_list|,
name|snmp_error
argument_list|(
name|parm
operator|->
name|error__status
argument_list|)
argument_list|,
name|oid2ode
argument_list|(
operator|(
operator|*
name|bp
operator|)
operator|->
name|r_arg
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
operator|*
name|bp
operator|,
name|bp
operator|=
operator|&
name|b
operator|->
name|r_next
expr_stmt|;
name|free_bound
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_nbound
operator|--
expr_stmt|;
name|v
operator|=
operator|*
name|vp
operator|,
name|vp
operator|=
operator|&
name|v
operator|->
name|next
expr_stmt|;
name|v
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|free_SNMP_VarBindList
argument_list|(
name|v
argument_list|)
expr_stmt|;
goto|goto
name|toss_it
goto|;
block|}
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s for get-next of %s, et. al."
argument_list|,
name|snmp_error
argument_list|(
name|parm
operator|->
name|error__status
argument_list|)
argument_list|,
name|oid2ode
argument_list|(
name|r
operator|->
name|r_bounds
operator|->
name|r_arg
argument_list|)
argument_list|)
expr_stmt|;
name|drop_request
label|:
empty_stmt|;
name|free_request
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|dedrequests
operator|++
expr_stmt|;
goto|goto
name|next_request
goto|;
block|}
name|i
operator|=
operator|&
name|r
operator|->
name|r_invoke
expr_stmt|;
name|finish_invoke
label|:
empty_stmt|;
if|if
condition|(
name|i
operator|->
name|i_retries
operator|==
literal|0
condition|)
block|{
name|long
name|val
init|=
name|timenow
operator|-
name|i
operator|->
name|i_lastime
decl_stmt|;
if|if
condition|(
name|maxrtt
operator|<
name|val
condition|)
name|maxrtt
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|timelap
operator|<
name|SETTLETIME
condition|)
block|{
name|int
name|rtt
init|=
name|maxrtt
operator|/
name|i
operator|->
name|i_curinvokes
decl_stmt|;
if|if
condition|(
name|RTTperthread
operator|>
name|rtt
condition|)
block|{
name|RTTperthread
operator|=
name|rtt
expr_stmt|;
if|if
condition|(
operator|(
name|threadlimit
operator|=
name|i
operator|->
name|i_curinvokes
operator|+
literal|1
operator|)
operator|>
name|MAXTHREADS
condition|)
name|threadlimit
operator|=
name|MAXTHREADS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"time now %u, xmit-time %u, RTT %u\n"
argument_list|,
name|timenow
argument_list|,
name|i
operator|->
name|i_lastime
argument_list|,
name|timenow
operator|-
name|i
operator|->
name|i_lastime
argument_list|)
expr_stmt|;
name|backoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|->
name|i_retries
operator|=
literal|0
expr_stmt|;
goto|goto
name|next_request
goto|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"request-id mismatch, not expecting %d\n"
argument_list|,
name|request_id
argument_list|)
expr_stmt|;
name|duplicate_id
label|:
empty_stmt|;
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|totrsps
operator|--
operator|,
name|totdups
operator|++
expr_stmt|;
name|next_request
label|:
empty_stmt|;
name|FD_SET
argument_list|(
name|sd
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_dgram_socket
argument_list|(
name|nfds
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|OK
argument_list|)
operator|>
name|OK
condition|)
goto|goto
name|again
goto|;
break|break;
block|}
if|if
condition|(
name|curthreads
operator|>
name|maxthreads
condition|)
name|maxthreads
operator|=
name|curthreads
expr_stmt|;
if|if
condition|(
name|currequests
operator|>
name|maxrequests
condition|)
name|maxrequests
operator|=
name|currequests
expr_stmt|;
if|if
condition|(
name|backoff
condition|)
block|{
if|if
condition|(
operator|(
name|timeout
operator|<<=
literal|1
operator|)
operator|>
name|MAXTIME
condition|)
name|timeout
operator|=
name|MAXTIME
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"adjusted timeout to %g seconds(0)\n"
argument_list|,
name|timeout
operator|/
literal|1000.0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxrtt
operator|>
literal|0
operator|&&
name|maxrtt
operator|!=
name|timeout
condition|)
block|{
name|long
name|timedelta
init|=
name|maxrtt
operator|+
operator|(
name|maxrtt
operator|>>
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|timedelta
operator|>
name|timeout
condition|)
block|{
if|if
condition|(
operator|(
name|timeout
operator|=
name|timedelta
operator|)
operator|>
name|MAXTIME
condition|)
name|timeout
operator|=
name|MAXTIME
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
goto|goto
name|outta_time
goto|;
block|}
else|else
block|{
name|timeout
operator|-=
operator|(
name|timeout
operator|-
name|timedelta
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
name|MINTIME
condition|)
name|timeout
operator|=
name|MINTIME
expr_stmt|;
name|outta_time
label|:
empty_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"adjusted timeout to %g seconds(1)\n"
argument_list|,
name|timeout
operator|/
literal|1000.0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeout
operator|<
name|timemin
condition|)
name|timemin
operator|=
name|timeout
expr_stmt|;
elseif|else
if|if
condition|(
name|timeout
operator|>
name|timemax
condition|)
name|timemax
operator|=
name|timeout
expr_stmt|;
name|i
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
init|;
name|r
operator|!=
name|RHead
condition|;
name|r
operator|=
name|r
operator|->
name|r_forw
control|)
block|{
if|if
condition|(
name|r
operator|->
name|r_info
condition|)
continue|continue;
for|for
control|(
name|u
operator|=
name|r
operator|->
name|r_forw
init|;
name|u
operator|!=
name|RHead
condition|;
name|u
operator|=
name|u
operator|->
name|r_forw
control|)
if|if
condition|(
operator|!
name|u
operator|->
name|r_info
operator|&&
name|u
operator|->
name|r_lastime
operator|<
name|r
operator|->
name|r_lastime
condition|)
name|r
operator|=
name|u
expr_stmt|;
name|i
operator|=
operator|&
name|r
operator|->
name|r_invoke
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|THead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|THead
condition|;
name|t
operator|=
name|t
operator|->
name|t_forw
control|)
block|{
if|if
condition|(
name|t
operator|->
name|t_info
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|t
operator|->
name|t_forw
init|;
name|s
operator|!=
name|THead
condition|;
name|s
operator|=
name|s
operator|->
name|t_forw
control|)
if|if
condition|(
operator|!
name|s
operator|->
name|t_info
operator|&&
name|s
operator|->
name|t_lastime
operator|<
name|t
operator|->
name|t_lastime
condition|)
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
operator|||
name|t
operator|->
name|t_lastime
operator|<
name|i
operator|->
name|i_lastime
condition|)
name|i
operator|=
operator|&
name|t
operator|->
name|t_invoke
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&&
name|i
operator|->
name|i_lastime
operator|+
name|timeout
operator|<
name|timenow
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|->
name|i_retries
operator|>
name|MAXTRIES
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"too many retries (%d)"
argument_list|,
name|MAXTRIES
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|i
operator|->
name|i_pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|watch
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"retry ID %d\n"
argument_list|,
name|i
operator|->
name|i_rid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|i
operator|->
name|i_pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"retry ID %d, time now %u, waiting %u, timeout %u\n"
argument_list|,
name|i
operator|->
name|i_rid
argument_list|,
name|timenow
argument_list|,
name|timenow
operator|-
name|i
operator|->
name|i_lastime
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|totretr
operator|++
expr_stmt|;
name|i
operator|->
name|i_lastime
operator|=
name|timenow
expr_stmt|;
name|i
operator|->
name|i_curinvokes
operator|=
name|currequests
condition|?
name|currequests
else|:
literal|1
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|backoff
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_bulk
argument_list|(
argument|bl
argument_list|,
argument|vb
argument_list|,
argument|partial
argument_list|)
expr|struct
name|binding
operator|*
name|bl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|binding
modifier|*
name|bv
decl_stmt|,
modifier|*
name|bz
decl_stmt|;
if|if
condition|(
name|partial
condition|)
name|printf
argument_list|(
literal|"partial results only...\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
literal|"row"
argument_list|)
expr_stmt|;
for|for
control|(
name|bv
operator|=
name|bl
init|;
name|bv
condition|;
name|bv
operator|=
name|bv
operator|->
name|b_next
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|sprintoid
argument_list|(
name|bv
operator|->
name|b_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|j
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
name|i
operator|=
name|j
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|i
argument_list|,
literal|"row"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|vb
condition|;
name|vb
operator|=
name|vb
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|oid2ode
argument_list|(
name|vb
operator|->
name|VarBind
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bv
operator|=
name|bl
init|;
name|bv
condition|;
name|bv
operator|=
name|bz
control|)
block|{
specifier|register
name|struct
name|binding
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bq
decl_stmt|;
name|bz
operator|=
name|bv
operator|->
name|b_next
expr_stmt|;
name|printf
argument_list|(
literal|"\n%-*s"
argument_list|,
name|i
argument_list|,
name|sprintoid
argument_list|(
name|bv
operator|->
name|b_name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|bv
operator|->
name|b_cols
init|;
name|bp
condition|;
name|bp
operator|=
name|bq
control|)
block|{
name|bq
operator|=
name|bp
operator|->
name|b_next
expr_stmt|;
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_value
condition|)
block|{
name|caddr_t
name|value
decl_stmt|;
specifier|register
name|OI
name|oi
decl_stmt|;
specifier|register
name|OS
name|os
decl_stmt|;
if|if
condition|(
operator|(
name|oi
operator|=
name|name2inst
argument_list|(
name|bp
operator|->
name|b_name
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|os
operator|=
name|oi
operator|->
name|oi_type
operator|->
name|ot_syntax
operator|)
operator|==
name|NULL
operator|||
call|(
modifier|*
name|os
operator|->
name|os_decode
call|)
argument_list|(
operator|&
name|value
argument_list|,
name|bp
operator|->
name|b_value
argument_list|)
operator|==
name|NOTOK
condition|)
name|vunknown
argument_list|(
name|bp
operator|->
name|b_value
argument_list|)
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|os
operator|->
name|os_print
call|)
argument_list|(
name|value
argument_list|,
name|os
argument_list|)
expr_stmt|;
call|(
modifier|*
name|os
operator|->
name|os_free
call|)
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|pe_free
argument_list|(
name|bp
operator|->
name|b_value
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|bp
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
name|oid_free
argument_list|(
name|bv
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bv
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|type_SNMP_Message
modifier|*
name|new_message
parameter_list|(
name|arg
parameter_list|,
name|vb
parameter_list|,
name|community
parameter_list|,
name|next
parameter_list|)
name|OID
name|arg
decl_stmt|;
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
name|char
modifier|*
name|community
decl_stmt|;
name|int
name|next
decl_stmt|;
block|{
specifier|register
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDUs
modifier|*
name|pdu
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDU
modifier|*
name|parm
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
operator|(
expr|struct
name|type_SNMP_Message
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|version
operator|=
name|int_SNMP_version_version__1
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|community
operator|=
name|str2qb
argument_list|(
name|community
argument_list|,
name|strlen
argument_list|(
name|community
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pdu
operator|=
operator|(
expr|struct
name|type_SNMP_PDUs
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|pdu
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
operator|=
name|pdu
expr_stmt|;
name|pdu
operator|->
name|offset
operator|=
name|next
condition|?
name|type_SNMP_PDUs_get__next__request
else|:
name|type_SNMP_PDUs_get__request
expr_stmt|;
comment|/* for now, always a PDU... */
if|if
condition|(
operator|(
name|parm
operator|=
operator|(
expr|struct
name|type_SNMP_PDU
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|parm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|=
name|parm
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|&
name|parm
operator|->
name|variable__bindings
init|;
name|vb
condition|;
name|vb
operator|=
name|vb
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|bind
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|bind
operator|=
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bind
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|bind
operator|,
name|vp
operator|=
operator|&
name|bind
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|type_SNMP_VarBind
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bind
operator|->
name|VarBind
operator|=
name|v
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|oid_copy
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vb
operator|->
name|VarBind
operator|->
name|name
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
operator|->
name|name
operator|->
name|oid_elements
argument_list|,
name|vb
operator|->
name|VarBind
operator|->
name|name
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
expr|*
name|v
operator|->
name|name
operator|->
name|oid_elements
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
return|return
name|msg
return|;
block|}
end_function

begin_comment
comment|/*
comment|THREADS */
end_comment

begin_function
specifier|static
name|int
name|new_thread
parameter_list|(
name|ps
parameter_list|,
name|vb
parameter_list|,
name|community
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|)
name|PS
name|ps
decl_stmt|;
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
name|char
modifier|*
name|community
decl_stmt|;
name|OID
name|start
decl_stmt|,
name|stop
decl_stmt|;
block|{
specifier|register
name|struct
name|thread
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"new_thread: out of memory"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_rid
operator|=
name|last_id
expr_stmt|;
name|t
operator|->
name|t_mid
operator|=
operator|(
name|last_id
operator|+=
name|MAXSPACE
operator|)
expr_stmt|;
name|t
operator|->
name|t_lo
operator|=
name|oid_copy
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_arg
operator|=
name|oid_copy
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_hi
operator|=
name|oid_copy
argument_list|(
name|stop
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_msg
operator|=
name|new_message
argument_list|(
name|t
operator|->
name|t_arg
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|THead
operator|->
name|t_forw
operator|=
name|THead
operator|->
name|t_back
operator|=
name|THead
expr_stmt|;
name|RHead
operator|->
name|r_forw
operator|=
name|RHead
operator|->
name|r_back
operator|=
name|RHead
expr_stmt|;
name|once_only
operator|++
expr_stmt|;
block|}
name|insque
argument_list|(
name|t
argument_list|,
name|THead
operator|->
name|t_back
argument_list|)
expr_stmt|;
name|curthreads
operator|++
expr_stmt|;
name|tothreads
operator|++
expr_stmt|;
return|return
name|next_thread
argument_list|(
name|t
argument_list|,
name|ps
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|new_string
parameter_list|(
name|ps
parameter_list|,
name|vb
parameter_list|,
name|community
parameter_list|,
name|bp
parameter_list|)
name|PS
name|ps
decl_stmt|;
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
name|char
modifier|*
name|community
decl_stmt|;
name|struct
name|binding
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|struct
name|thread
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"new_thread: out of memory"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_rid
operator|=
name|last_id
expr_stmt|;
name|t
operator|->
name|t_mid
operator|=
operator|(
name|last_id
operator|+=
name|MAXSPACE
operator|)
expr_stmt|;
name|t
operator|->
name|t_binding
operator|=
name|bp
expr_stmt|;
name|t
operator|->
name|t_msg
operator|=
name|new_message
argument_list|(
name|bp
operator|->
name|b_cols
operator|->
name|b_name
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|t
argument_list|,
name|THead
operator|->
name|t_back
argument_list|)
expr_stmt|;
name|curthreads
operator|++
expr_stmt|;
name|tothreads
operator|++
expr_stmt|;
return|return
name|next_thread
argument_list|(
name|t
argument_list|,
name|ps
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|free_thread
argument_list|(
name|t
argument_list|)
specifier|register
expr|struct
name|thread
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|debug
operator|&&
name|t
operator|->
name|t_lo
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"thread from %s to "
argument_list|,
name|oid2ode
argument_list|(
name|t
operator|->
name|t_lo
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s did %d get-nexts\n"
argument_list|,
name|oid2ode
argument_list|(
name|t
operator|->
name|t_hi
argument_list|)
argument_list|,
name|t
operator|->
name|t_gns
argument_list|)
expr_stmt|;
block|}
name|curthreads
operator|--
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_gns
operator|<=
literal|1
condition|)
name|nilthreads
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_pe
condition|)
name|pe_free
argument_list|(
name|t
operator|->
name|t_pe
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|t
operator|->
name|t_lo
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|t
operator|->
name|t_arg
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|t
operator|->
name|t_hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_msg
condition|)
name|free_SNMP_Message
argument_list|(
name|t
operator|->
name|t_msg
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|next_thread
parameter_list|(
name|t
parameter_list|,
name|ps
parameter_list|,
name|next
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|t
decl_stmt|;
name|PS
name|ps
decl_stmt|;
name|int
name|next
decl_stmt|;
block|{
if|if
condition|(
operator|++
name|t
operator|->
name|t_rid
operator|>=
name|t
operator|->
name|t_mid
condition|)
name|t
operator|->
name|t_rid
operator|=
name|t
operator|->
name|t_mid
operator|-
name|MAXSPACE
expr_stmt|;
name|t
operator|->
name|t_info
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_msg
operator|->
name|data
operator|->
name|offset
operator|=
name|next
condition|?
name|type_SNMP_PDUs_get__next__request
else|:
name|type_SNMP_PDUs_get__request
expr_stmt|;
name|t
operator|->
name|t_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|->
name|request__id
operator|=
name|t
operator|->
name|t_rid
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_pe
condition|)
name|pe_free
argument_list|(
name|t
operator|->
name|t_pe
argument_list|)
operator|,
name|t
operator|->
name|t_pe
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|t
operator|->
name|t_pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|t
operator|->
name|t_msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|t
operator|->
name|t_pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|watch
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"write PDU\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|t
operator|->
name|t_pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|totreqs
operator|++
expr_stmt|;
name|t
operator|->
name|t_lastime
operator|=
name|timenow
expr_stmt|;
name|t
operator|->
name|t_curinvokes
operator|=
name|curthreads
condition|?
name|curthreads
else|:
literal|1
expr_stmt|;
name|t
operator|->
name|t_gns
operator|++
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|BULK2 */
end_comment

begin_macro
name|bulk2
argument_list|(
argument|ps
argument_list|,
argument|sd
argument_list|,
argument|vb
argument_list|,
argument|community
argument_list|)
end_macro

begin_decl_stmt
name|PS
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|community
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|backoff
decl_stmt|,
name|evalreq
decl_stmt|,
name|rows
decl_stmt|;
specifier|register
name|struct
name|request
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|binding
modifier|*
modifier|*
name|bp
decl_stmt|;
name|struct
name|binding
modifier|*
name|bl
decl_stmt|;
name|struct
name|timeval
name|tvs
decl_stmt|,
name|now
decl_stmt|;
specifier|register
name|OID
name|a
decl_stmt|,
name|b
decl_stmt|;
name|OID
name|arg
decl_stmt|;
name|timeout
operator|=
literal|2
operator|*
literal|1000L
expr_stmt|;
name|timemin
operator|=
name|timemax
operator|=
name|timeout
expr_stmt|;
name|currequests
operator|=
name|maxrequests
operator|=
name|totbounds
operator|=
name|maxbounds
operator|=
name|dedrequests
operator|=
literal|0
expr_stmt|;
name|nilbounds
operator|=
literal|0
expr_stmt|;
name|threadlimit
operator|=
name|MAXTHREADS
expr_stmt|;
name|boundlimit
operator|=
name|MAXBOUNDS
expr_stmt|;
name|RTTperthread
operator|=
name|MAXTIME
expr_stmt|;
name|totreqs
operator|=
name|totretr
operator|=
name|totrsps
operator|=
name|totdups
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tvs
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|timenow
operator|=
name|tvs
operator|.
name|tv_sec
operator|*
literal|1000L
operator|+
name|tvs
operator|.
name|tv_usec
operator|/
literal|1000L
expr_stmt|;
name|a
operator|=
name|oid_copy
argument_list|(
name|arg
operator|=
name|vb
operator|->
name|VarBind
operator|->
name|name
argument_list|)
expr_stmt|;
name|a
operator|->
name|oid_elements
index|[
name|a
operator|->
name|oid_nelem
operator|++
index|]
operator|=
literal|127
expr_stmt|;
name|new_bound
argument_list|(
name|community
argument_list|,
name|arg
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|oid_copy
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|b
operator|->
name|oid_elements
index|[
name|b
operator|->
name|oid_nelem
operator|++
index|]
operator|=
literal|192
expr_stmt|;
name|new_bound
argument_list|(
name|community
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|a
operator|->
name|oid_elements
index|[
operator|(
operator|--
name|a
operator|->
name|oid_nelem
operator|)
operator|-
literal|1
index|]
operator|++
expr_stmt|;
name|new_bound
argument_list|(
name|community
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_requests
argument_list|(
name|ps
argument_list|,
name|community
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|bp
operator|=
operator|&
name|bl
operator|,
name|bl
operator|=
name|NULL
operator|,
name|rows
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|timelap
operator|=
literal|0
init|;
name|RHead
operator|->
name|r_forw
operator|!=
name|RHead
condition|;
name|timelap
operator|++
control|)
block|{
name|struct
name|request
modifier|*
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|backoff
operator|=
name|wait_for_action
argument_list|(
name|sd
argument_list|,
name|ps
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
for|for
control|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
init|;
name|r
operator|!=
name|RHead
condition|;
name|r
operator|=
name|u
control|)
block|{
specifier|register
name|struct
name|bound
modifier|*
name|br
decl_stmt|,
modifier|*
name|bz
decl_stmt|,
modifier|*
modifier|*
name|bb
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vr
decl_stmt|,
modifier|*
modifier|*
name|vv
decl_stmt|;
name|u
operator|=
name|r
operator|->
name|r_forw
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|r_info
operator|<
literal|1
condition|)
continue|continue;
name|bb
operator|=
operator|&
name|r
operator|->
name|r_bounds
expr_stmt|;
name|vv
operator|=
operator|&
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
expr_stmt|;
name|evalreq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|br
operator|=
operator|*
name|bb
condition|)
block|{
specifier|register
name|struct
name|binding
modifier|*
name|bv
decl_stmt|,
modifier|*
name|bv2
decl_stmt|;
name|struct
name|OIDentifier
name|oids
decl_stmt|;
if|if
condition|(
operator|(
name|vr
operator|=
operator|*
name|vv
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing variable in response, continuing"
argument_list|)
expr_stmt|;
name|dedrequests
operator|++
expr_stmt|;
do|do
block|{
name|bz
operator|=
name|br
operator|->
name|r_next
expr_stmt|;
name|free_bound
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_nbound
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|br
operator|=
name|bz
condition|)
do|;
operator|*
name|bb
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|br
operator|->
name|r_arg
argument_list|,
name|b
operator|=
name|vr
operator|->
name|VarBind
operator|->
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|oid2ode
argument_list|(
name|br
operator|->
name|r_arg
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"agent botched get-next (%s -> %s), continuing"
argument_list|,
name|oid2ode
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|dedrequests
operator|++
expr_stmt|;
goto|goto
name|drop_bound
goto|;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|b
argument_list|,
name|br
operator|->
name|r_hi
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|br
operator|->
name|b_gns
operator|<=
literal|1
condition|)
name|evalreq
operator|--
expr_stmt|;
name|drop_bound
label|:
empty_stmt|;
operator|*
name|bb
operator|=
name|br
operator|->
name|r_next
expr_stmt|;
name|free_bound
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_nbound
operator|--
expr_stmt|;
operator|*
name|vv
operator|=
name|vr
operator|->
name|next
expr_stmt|;
name|vr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|free_SNMP_VarBindList
argument_list|(
name|vr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|evalreq
operator|++
expr_stmt|;
name|oid_free
argument_list|(
name|br
operator|->
name|r_arg
argument_list|)
expr_stmt|;
name|br
operator|->
name|r_arg
operator|=
name|oid_copy
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|oids
operator|.
name|oid_nelem
operator|=
name|b
operator|->
name|oid_nelem
operator|-
name|arg
operator|->
name|oid_nelem
expr_stmt|;
name|oids
operator|.
name|oid_elements
operator|=
name|b
operator|->
name|oid_elements
operator|+
name|arg
operator|->
name|oid_nelem
expr_stmt|;
if|if
condition|(
operator|(
name|bv
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|bv
operator|,
name|bp
operator|=
operator|&
name|bv
operator|->
name|b_next
expr_stmt|;
name|bv
operator|->
name|b_name
operator|=
name|oid_copy
argument_list|(
operator|&
name|oids
argument_list|)
expr_stmt|;
name|rows
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|bv2
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bv2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bv
operator|->
name|b_cols
operator|=
name|bv2
expr_stmt|;
name|bv2
operator|->
name|b_name
operator|=
name|oid_copy
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bv2
operator|->
name|b_value
operator|=
name|vr
operator|->
name|VarBind
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|vr
operator|->
name|VarBind
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bb
operator|=
operator|&
name|br
operator|->
name|r_next
operator|,
name|vv
operator|=
operator|&
name|vr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|vr
operator|=
operator|*
name|vv
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"too many variables in response"
argument_list|)
expr_stmt|;
name|free_SNMP_VarBindList
argument_list|(
name|vr
argument_list|)
expr_stmt|;
operator|*
name|vv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|timelap
operator|>=
name|SETTLETIME
operator|&&
name|evalreq
operator|<
literal|0
operator|&&
name|boundlimit
operator|!=
name|MINBOUNDS
condition|)
name|boundlimit
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|push_requests
argument_list|(
name|ps
argument_list|,
name|community
argument_list|,
name|currequests
operator|<
name|threadlimit
operator|&&
operator|!
name|backoff
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
block|}
if|if
condition|(
name|bulk2_aux
argument_list|(
name|ps
argument_list|,
name|sd
argument_list|,
name|bl
argument_list|,
name|vb
argument_list|,
name|community
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|losing
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"aborting bulk retrieval..."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
operator|)
operator|!=
name|RHead
condition|)
name|free_request
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|now
operator|.
name|tv_sec
operator|-=
name|tvs
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|.
name|tv_usec
operator|-=
name|tvs
operator|.
name|tv_usec
operator|)
operator|<
literal|0
condition|)
name|now
operator|.
name|tv_sec
operator|--
operator|,
name|now
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%d row%s retrieved in %d.%06d seconds during %d/%d iterations"
argument_list|,
name|rows
argument_list|,
name|rows
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|now
operator|.
name|tv_sec
argument_list|,
name|now
operator|.
name|tv_usec
argument_list|,
name|timelap
argument_list|,
name|timelap2
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"requests: at most %d active"
argument_list|,
name|maxrequests
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"bounds:   %d created, at most %d active, %d integral, %d did nothing"
argument_list|,
name|totbounds
argument_list|,
name|maxbounds
argument_list|,
name|boundlimit
argument_list|,
name|nilbounds
argument_list|)
expr_stmt|;
if|if
condition|(
name|timelap2
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"threads:  at most %d active, total of %d created"
argument_list|,
name|maxthreads
argument_list|,
name|tothreads
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"messages: %d request%s sent,  along with %d retr%s"
argument_list|,
name|totreqs
argument_list|,
name|totreqs
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|totretr
argument_list|,
name|totretr
operator|!=
literal|1
condition|?
literal|"ies"
else|:
literal|"y"
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"          %d response%s rcvd, along with %d duplicate%s"
argument_list|,
name|totrsps
argument_list|,
name|totrsps
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|totdups
argument_list|,
name|totdups
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"timeouts: min=%d.%03d fin=%d.%03d max=%d.%03d seconds"
argument_list|,
name|timemin
operator|/
literal|1000
argument_list|,
name|timemin
operator|%
literal|1000
argument_list|,
name|timeout
operator|/
literal|1000
argument_list|,
name|timeout
operator|%
literal|1000
argument_list|,
name|timemax
operator|/
literal|1000
argument_list|,
name|timemax
operator|%
literal|1000
argument_list|)
expr_stmt|;
name|print_bulk
argument_list|(
name|bl
argument_list|,
name|vb
argument_list|,
name|dedrequests
operator|||
name|dedthreads
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|bulk2_aux
parameter_list|(
name|ps
parameter_list|,
name|sd
parameter_list|,
name|bl
parameter_list|,
name|vb
parameter_list|,
name|community
parameter_list|)
name|PS
name|ps
decl_stmt|;
name|int
name|sd
decl_stmt|;
name|struct
name|binding
modifier|*
name|bl
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
name|char
modifier|*
name|community
decl_stmt|;
block|{
name|int
name|backoff
decl_stmt|;
specifier|register
name|struct
name|thread
modifier|*
name|t
decl_stmt|;
name|curthreads
operator|=
name|maxthreads
operator|=
name|tothreads
operator|=
name|nilthreads
operator|=
name|dedthreads
operator|=
literal|0
expr_stmt|;
name|timelap2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bl
operator|==
name|NULL
operator|||
operator|(
name|vb
operator|=
name|vb
operator|->
name|next
operator|)
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
while|while
condition|(
name|bl
condition|)
if|if
condition|(
name|curthreads
operator|<
name|threadlimit
condition|)
block|{
if|if
condition|(
name|new_string
argument_list|(
name|ps
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
name|bl
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|bl
operator|=
name|bl
operator|->
name|b_next
expr_stmt|;
block|}
else|else
break|break;
for|for
control|(
init|;
name|THead
operator|->
name|t_forw
operator|!=
name|THead
condition|;
name|timelap2
operator|++
control|)
block|{
name|struct
name|thread
modifier|*
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|backoff
operator|=
name|wait_for_action
argument_list|(
name|sd
argument_list|,
name|ps
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
break|break;
for|for
control|(
name|t
operator|=
name|THead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|THead
condition|;
name|t
operator|=
name|u
control|)
block|{
specifier|register
name|struct
name|binding
modifier|*
name|bv
decl_stmt|,
modifier|*
modifier|*
name|bz
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
decl_stmt|;
name|u
operator|=
name|t
operator|->
name|t_forw
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|t_info
condition|)
continue|continue;
name|bv
operator|=
name|t
operator|->
name|t_binding
expr_stmt|;
name|bz
operator|=
operator|&
name|bv
operator|->
name|b_cols
operator|->
name|b_next
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|t
operator|->
name|t_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|->
name|variable__bindings
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bv
operator|=
operator|(
expr|struct
name|binding
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|bz
operator|=
name|bv
operator|,
name|bz
operator|=
operator|&
name|bv
operator|->
name|b_next
expr_stmt|;
name|bv
operator|->
name|b_name
operator|=
name|oid_copy
argument_list|(
name|vp
operator|->
name|VarBind
operator|->
name|name
argument_list|)
expr_stmt|;
name|bv
operator|->
name|b_value
operator|=
name|vp
operator|->
name|VarBind
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|VarBind
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curthreads
operator|<
name|threadlimit
operator|&&
operator|!
name|backoff
operator|&&
name|bl
condition|)
block|{
if|if
condition|(
name|new_string
argument_list|(
name|ps
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
name|bl
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|bl
operator|=
name|bl
operator|->
name|b_next
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
block|}
name|free_thread
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
if|if
condition|(
name|new_string
argument_list|(
name|ps
argument_list|,
name|vb
argument_list|,
name|community
argument_list|,
name|bl
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|bl
operator|=
name|bl
operator|->
name|b_next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|backoff
operator|==
name|NOTOK
condition|)
block|{
name|losing
label|:
empty_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|THead
operator|->
name|t_forw
operator|)
operator|!=
name|THead
condition|)
name|free_thread
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|backoff
return|;
block|}
end_function

begin_comment
comment|/*
comment|REQUESTS */
end_comment

begin_function
specifier|static
name|struct
name|request
modifier|*
name|new_request
parameter_list|(
name|community
parameter_list|)
name|char
modifier|*
name|community
decl_stmt|;
block|{
specifier|register
name|struct
name|request
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|request
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"new_request: out of memory"
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_rid
operator|=
name|last_id
expr_stmt|;
name|r
operator|->
name|r_mid
operator|=
operator|(
name|last_id
operator|+=
name|MAXSPACE
operator|)
expr_stmt|;
name|r
operator|->
name|r_info
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|r_msg
operator|=
name|new_message
argument_list|(
name|NULLOID
argument_list|,
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
name|NULL
argument_list|,
name|community
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|r
argument_list|,
name|RHead
operator|->
name|r_back
argument_list|)
expr_stmt|;
name|currequests
operator|++
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|free_request
argument_list|(
name|r
argument_list|)
specifier|register
expr|struct
name|request
operator|*
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|bound
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bq
decl_stmt|;
name|currequests
operator|--
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|r_pe
condition|)
name|pe_free
argument_list|(
name|r
operator|->
name|r_pe
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|r
operator|->
name|r_bounds
init|;
name|bp
condition|;
name|bp
operator|=
name|bq
control|)
block|{
name|bq
operator|=
name|bp
operator|->
name|r_next
expr_stmt|;
name|free_bound
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|r_msg
condition|)
name|free_SNMP_Message
argument_list|(
name|r
operator|->
name|r_msg
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|new_bound
parameter_list|(
name|community
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|)
name|char
modifier|*
name|community
decl_stmt|;
name|OID
name|start
decl_stmt|,
name|stop
decl_stmt|;
block|{
specifier|register
name|struct
name|request
modifier|*
name|r
decl_stmt|;
specifier|register
name|struct
name|bound
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|THead
operator|->
name|t_forw
operator|=
name|THead
operator|->
name|t_back
operator|=
name|THead
expr_stmt|;
name|RHead
operator|->
name|r_forw
operator|=
name|RHead
operator|->
name|r_back
operator|=
name|RHead
expr_stmt|;
name|once_only
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
operator|)
operator|==
name|RHead
condition|)
name|r
operator|=
name|new_request
argument_list|(
name|community
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
operator|(
expr|struct
name|bound
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|b
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"new_bound: out of memory"
argument_list|)
expr_stmt|;
name|b
operator|->
name|r_next
operator|=
name|r
operator|->
name|r_bounds
operator|,
name|r
operator|->
name|r_bounds
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|b_gns
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|r_lo
operator|=
name|oid_copy
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|b
operator|->
name|r_arg
operator|=
name|oid_copy
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|b
operator|->
name|r_hi
operator|=
name|oid_copy
argument_list|(
name|stop
argument_list|)
expr_stmt|;
name|totbounds
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|vb
operator|=
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|vb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"new_bound: out of memory"
argument_list|)
expr_stmt|;
name|vb
operator|->
name|next
operator|=
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
operator|,
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
operator|=
name|vb
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|type_SNMP_VarBind
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"new_bound: out of memory"
argument_list|)
expr_stmt|;
name|vb
operator|->
name|VarBind
operator|=
name|v
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|oid_copy
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"new_bound: out of memory"
argument_list|)
expr_stmt|;
name|r
operator|->
name|r_nbound
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|free_bound
argument_list|(
name|b
argument_list|)
specifier|register
expr|struct
name|bound
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|debug
operator|&&
name|b
operator|->
name|r_lo
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d get-nexts on bound: %s to"
argument_list|,
name|b
operator|->
name|b_gns
argument_list|,
name|oid2ode
argument_list|(
name|b
operator|->
name|r_lo
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|oid2ode
argument_list|(
name|b
operator|->
name|r_hi
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oid_free
argument_list|(
name|b
operator|->
name|r_lo
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|b
operator|->
name|r_arg
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|b
operator|->
name|r_hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|b_gns
operator|<=
literal|1
condition|)
name|nilbounds
operator|++
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|push_requests
argument_list|(
argument|ps
argument_list|,
argument|community
argument_list|,
argument|onemore
argument_list|)
name|PS
name|ps
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|community
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onemore
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nbound
decl_stmt|,
name|nrequest
decl_stmt|,
name|tbound
decl_stmt|;
name|int
name|new
decl_stmt|,
name|wen
decl_stmt|;
specifier|register
name|struct
name|request
modifier|*
name|r
decl_stmt|;
name|struct
name|request
modifier|*
name|u
decl_stmt|;
specifier|register
name|struct
name|bound
modifier|*
name|bn
decl_stmt|,
modifier|*
name|bz
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|;
name|struct
name|bound
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vz
decl_stmt|,
modifier|*
modifier|*
name|vp
decl_stmt|;
name|struct
name|type_SNMP_VarBindList
modifier|*
name|v
decl_stmt|;
name|bp
operator|=
operator|&
name|b
operator|,
name|b
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
operator|&
name|v
operator|,
name|v
operator|=
name|NULL
expr_stmt|;
name|nrequest
operator|=
name|nbound
operator|=
name|tbound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
init|;
name|r
operator|!=
name|RHead
condition|;
name|r
operator|=
name|r
operator|->
name|r_forw
control|)
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|r_info
condition|)
block|{
name|tbound
operator|+=
name|r
operator|->
name|r_nbound
expr_stmt|;
continue|continue;
block|}
name|nrequest
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|=
name|r
operator|->
name|r_bounds
condition|)
block|{
for|for
control|(
name|bz
operator|=
operator|*
name|bp
init|;
name|bz
condition|;
name|bz
operator|=
name|bz
operator|->
name|r_next
control|)
if|if
condition|(
name|bz
operator|->
name|r_next
operator|==
name|NULL
condition|)
name|bp
operator|=
operator|&
name|bz
operator|->
name|r_next
expr_stmt|;
name|r
operator|->
name|r_bounds
operator|=
name|NULL
expr_stmt|;
name|nbound
operator|+=
name|r
operator|->
name|r_nbound
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|vp
operator|=
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
condition|)
block|{
for|for
control|(
name|vz
operator|=
operator|*
name|vp
init|;
name|vz
condition|;
name|vz
operator|=
name|vz
operator|->
name|next
control|)
if|if
condition|(
name|vz
operator|->
name|next
operator|==
name|NULL
condition|)
name|vp
operator|=
operator|&
name|vz
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
operator|=
name|NULL
expr_stmt|;
block|}
name|r
operator|->
name|r_nbound
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tbound
operator|+=
name|nbound
operator|)
operator|>
name|maxbounds
condition|)
name|maxbounds
operator|=
name|tbound
expr_stmt|;
if|if
condition|(
name|nrequest
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
operator|(
name|new
operator|=
operator|(
name|nbound
operator|+
operator|(
name|boundlimit
operator|-
literal|1
operator|)
operator|)
operator|/
name|boundlimit
operator|-
name|nrequest
operator|)
operator|<=
literal|0
operator|&&
name|onemore
condition|)
name|new
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|new
operator|--
operator|>
literal|0
condition|;
name|nrequest
operator|++
control|)
operator|(
name|void
operator|)
name|new_request
argument_list|(
name|community
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|nrequest
operator|*
name|boundlimit
operator|)
operator|>
operator|(
name|wen
operator|=
name|nbound
operator|<<
literal|1
operator|)
condition|)
name|new
operator|=
name|wen
expr_stmt|;
for|for
control|(
name|new
operator|-=
name|nbound
operator|,
name|bn
operator|=
name|b
init|;
operator|(
name|new
operator|>
literal|0
operator|)
operator|&&
name|bn
condition|;
name|new
operator|--
operator|,
name|bn
operator|=
name|bn
operator|->
name|r_next
control|)
block|{
name|OID
name|mid
decl_stmt|;
if|if
condition|(
operator|(
name|mid
operator|=
name|oid_median
argument_list|(
name|bn
operator|->
name|r_arg
argument_list|,
name|bn
operator|->
name|r_hi
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bz
operator|=
operator|(
expr|struct
name|bound
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"push_requests: out of memory"
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|bz
operator|,
name|bp
operator|=
operator|&
name|bz
operator|->
name|r_next
expr_stmt|;
name|bz
operator|->
name|r_lo
operator|=
name|oid_copy
argument_list|(
name|mid
argument_list|)
expr_stmt|;
name|bz
operator|->
name|r_arg
operator|=
name|oid_copy
argument_list|(
name|mid
argument_list|)
expr_stmt|;
name|bz
operator|->
name|r_hi
operator|=
name|bn
operator|->
name|r_hi
expr_stmt|;
name|tbound
operator|++
operator|,
name|totbounds
operator|++
expr_stmt|;
name|bn
operator|->
name|r_hi
operator|=
name|mid
expr_stmt|;
if|if
condition|(
operator|(
name|vz
operator|=
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|vz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"push_requests: out of memory"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|vz
operator|,
name|vp
operator|=
operator|&
name|vz
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|vz
operator|->
name|VarBind
operator|=
operator|(
expr|struct
name|type_SNMP_VarBind
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"push_requests: out of memory"
argument_list|)
expr_stmt|;
name|vz
operator|->
name|VarBind
operator|->
name|name
operator|=
name|oid_copy
argument_list|(
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vz
operator|->
name|VarBind
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"push_requests: out of memory"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbound
operator|>
name|maxbounds
condition|)
name|maxbounds
operator|=
name|tbound
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
goto|goto
name|send_them
goto|;
for|for
control|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
init|;
name|r
operator|!=
name|RHead
condition|;
name|r
operator|=
name|r
operator|->
name|r_forw
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|bound
modifier|*
modifier|*
name|inb
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
modifier|*
name|inv
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|r_info
condition|)
continue|continue;
name|inb
operator|=
operator|&
name|r
operator|->
name|r_bounds
expr_stmt|;
name|inv
operator|=
operator|&
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
expr_stmt|;
for|for
control|(
name|i
operator|=
name|boundlimit
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|bz
operator|=
name|b
operator|->
name|r_next
operator|,
name|vz
operator|=
name|v
operator|->
name|next
expr_stmt|;
operator|*
name|inb
operator|=
name|b
operator|,
name|inb
operator|=
operator|&
name|b
operator|->
name|r_next
operator|,
name|b
operator|->
name|r_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|inv
operator|=
name|v
operator|,
name|inv
operator|=
operator|&
name|v
operator|->
name|next
operator|,
name|v
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|b_gns
operator|++
expr_stmt|;
name|r
operator|->
name|r_nbound
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|bz
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|send_them
goto|;
name|v
operator|=
name|vz
expr_stmt|;
block|}
block|}
comment|/* should never get here, since we should run out bounds before        running out of requests; if we do ... ?? */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"push_requests: possibly loss of bounds\n"
argument_list|)
expr_stmt|;
name|send_them
label|:
empty_stmt|;
for|for
control|(
name|r
operator|=
name|RHead
operator|->
name|r_forw
init|;
name|r
operator|!=
name|RHead
condition|;
name|r
operator|=
name|u
control|)
block|{
name|u
operator|=
name|r
operator|->
name|r_forw
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|r_info
condition|)
continue|continue;
if|if
condition|(
name|r
operator|->
name|r_nbound
operator|<=
literal|0
condition|)
block|{
name|free_request
argument_list|(
name|r
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|++
name|r
operator|->
name|r_rid
operator|>=
name|r
operator|->
name|r_mid
condition|)
name|r
operator|->
name|r_rid
operator|=
name|r
operator|->
name|r_mid
operator|-
name|MAXSPACE
expr_stmt|;
name|r
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|offset
operator|=
name|type_SNMP_PDUs_get__next__request
expr_stmt|;
name|r
operator|->
name|r_msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|->
name|request__id
operator|=
name|r
operator|->
name|r_rid
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|r_pe
condition|)
name|pe_free
argument_list|(
name|r
operator|->
name|r_pe
argument_list|)
operator|,
name|r
operator|->
name|r_pe
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|r
operator|->
name|r_pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|r
operator|->
name|r_msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|r
operator|->
name|r_pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|watch
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"write PDU\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|r
operator|->
name|r_pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|totreqs
operator|++
expr_stmt|;
name|r
operator|->
name|r_lastime
operator|=
name|timenow
expr_stmt|;
name|r
operator|->
name|r_curinvokes
operator|=
name|currequests
condition|?
name|currequests
else|:
literal|1
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|OIDS */
end_comment

begin_function
specifier|static
name|OID
name|oid_median
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|OID
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ap
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|OID
name|c
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|oid_cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|sprintoid
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"oid_median(%s<= %s)"
argument_list|,
name|buffer
argument_list|,
name|sprintoid
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|ap
operator|=
name|a
operator|->
name|oid_elements
operator|,
name|bp
operator|=
name|b
operator|->
name|oid_elements
init|;
name|i
operator|<=
name|b
operator|->
name|oid_nelem
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|a
operator|->
name|oid_nelem
condition|)
block|{
for|for
control|(
init|;
operator|*
name|bp
operator|==
name|NULL
condition|;
name|bp
operator|++
control|)
if|if
condition|(
operator|++
name|i
operator|>
name|b
operator|->
name|oid_nelem
condition|)
goto|goto
name|losing
goto|;
name|c
operator|=
name|oid_copy
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|c
operator|->
name|oid_elements
index|[
operator|(
name|c
operator|->
name|oid_nelem
operator|=
name|i
operator|)
operator|-
literal|1
index|]
operator|=
operator|*
name|bp
operator|>>
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|ap
operator|==
operator|*
name|bp
condition|)
continue|continue;
name|c
operator|=
name|oid_copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|oid_elements
index|[
operator|(
name|c
operator|->
name|oid_nelem
operator|=
name|i
operator|)
operator|-
literal|1
index|]
operator|=
operator|*
name|ap
operator|+
operator|(
operator|(
operator|*
name|bp
operator|-
operator|*
name|ap
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|==
operator|*
name|ap
condition|)
block|{
name|bp
operator|=
operator|&
name|c
operator|->
name|oid_elements
index|[
name|c
operator|->
name|oid_nelem
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|oid_nelem
operator|<=
name|i
condition|)
operator|*
name|bp
operator|=
literal|127
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|*
operator|++
name|ap
operator|==
literal|255
condition|)
block|{
name|bp
operator|++
operator|,
name|c
operator|->
name|oid_nelem
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|a
operator|->
name|oid_nelem
condition|)
block|{
operator|*
name|bp
operator|=
literal|127
expr_stmt|;
goto|goto
name|testc
goto|;
block|}
block|}
operator|*
name|bp
operator|=
operator|*
name|ap
operator|>=
literal|16383
condition|?
operator|*
name|ap
operator|+
literal|16383
else|:
operator|*
name|ap
operator|>=
literal|4095
condition|?
operator|*
name|ap
operator|+
literal|4095
else|:
operator|*
name|ap
operator|>=
literal|1023
condition|?
operator|*
name|ap
operator|+
literal|1023
else|:
operator|*
name|ap
operator|>
literal|255
condition|?
operator|*
name|ap
operator|+
literal|255
else|:
operator|(
operator|*
name|ap
operator|>>
literal|1
operator|)
operator|+
literal|128
expr_stmt|;
block|}
block|}
name|testc
label|:
empty_stmt|;
if|if
condition|(
name|c
operator|->
name|oid_nelem
operator|<
literal|2
condition|)
name|c
operator|->
name|oid_elements
index|[
name|c
operator|->
name|oid_nelem
operator|++
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|losing
label|:
empty_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|sprintoid
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"oid_median(%s, %s) fails"
argument_list|,
name|buffer
argument_list|,
name|sprintoid
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|a
argument_list|,
name|c
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|sprintoid
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf2
argument_list|,
name|sprintoid
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"oid_median(%s, %s) -> %s loses(1)"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|sprintoid
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|c
argument_list|,
name|b
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|sprintoid
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf2
argument_list|,
name|sprintoid
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"oid_median(%s, %s) -> %s loses(2)"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|sprintoid
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|OID
name|oid_copy
parameter_list|(
name|a
parameter_list|)
name|OID
name|a
decl_stmt|;
block|{
name|OID
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|oid_cpy
argument_list|(
name|a
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"oid_copy: out of memory"
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*
comment|DUMMY */
end_comment

begin_macro
name|bulk_dummy
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

