begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* view-g.c - VIEW group */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/view-g.c,v 7.2 91/02/22 09:44:59 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/snmp/RCS/view-g.c,v 7.2 91/02/22 09:44:59 mrose Interim $  *  *  * $Log:	view-g.c,v $  * Revision 7.2  91/02/22  09:44:59  mrose  * Interim 6.8  *   * Revision 7.1  90/12/18  10:14:28  mrose  * update  *   * Revision 7.0  90/12/17  22:07:58  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"mib.h"
end_include

begin_include
include|#
directive|include
file|"view-g.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_comment
comment|/*
comment|VIEW GROUP */
end_comment

begin_define
define|#
directive|define
name|viewPrimName
value|0
end_define

begin_define
define|#
directive|define
name|viewPrimTDomain
value|1
end_define

begin_define
define|#
directive|define
name|viewPrimTAddr
value|2
end_define

begin_define
define|#
directive|define
name|viewPrimUser
value|3
end_define

begin_define
define|#
directive|define
name|viewPrimCommunity
value|4
end_define

begin_define
define|#
directive|define
name|viewPrimType
value|5
end_define

begin_define
define|#
directive|define
name|P_VALID
value|1
end_define

begin_comment
comment|/* viewPrimType */
end_comment

begin_decl_stmt
specifier|static
name|int
name|viewmask
init|=
literal|0x1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OID
name|localAgent
init|=
name|NULLOID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OID
name|rfc1157Domain
init|=
name|NULLOID
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|view
modifier|*
name|get_prent
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|o_viewPrim
parameter_list|(
name|oi
parameter_list|,
name|v
parameter_list|,
name|offset
parameter_list|)
name|OI
name|oi
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|ifvar
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|vu
decl_stmt|;
specifier|register
name|OID
name|oid
init|=
name|oi
operator|->
name|oi_name
decl_stmt|;
specifier|register
name|OT
name|ot
init|=
name|oi
operator|->
name|oi_type
decl_stmt|;
name|ifvar
operator|=
operator|(
name|int
operator|)
name|ot
operator|->
name|ot_info
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|<=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
if|if
condition|(
operator|(
name|vu
operator|=
name|get_prent
argument_list|(
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
name|oid
operator|->
name|oid_nelem
operator|-
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
break|break;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|==
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
condition|)
block|{
name|OID
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|vu
operator|=
name|VHead
operator|->
name|v_forw
operator|)
operator|==
name|VHead
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|oid_extend
argument_list|(
name|oid
argument_list|,
name|vu
operator|->
name|v_insize
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
name|ip
operator|=
name|new
operator|->
name|oid_elements
operator|+
name|new
operator|->
name|oid_nelem
operator|-
name|vu
operator|->
name|v_insize
expr_stmt|;
name|jp
operator|=
name|vu
operator|->
name|v_instance
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vu
operator|->
name|v_insize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|name
condition|)
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|vu
operator|=
name|get_prent
argument_list|(
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
name|j
operator|=
name|oid
operator|->
name|oid_nelem
operator|-
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|j
operator|-
name|vu
operator|->
name|v_insize
operator|)
operator|<
literal|0
condition|)
block|{
name|OID
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|oid_extend
argument_list|(
name|oid
argument_list|,
operator|-
name|i
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|v
operator|->
name|name
condition|)
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|new
expr_stmt|;
name|oid
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|oid
operator|->
name|oid_nelem
operator|-=
name|i
expr_stmt|;
name|ip
operator|=
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
expr_stmt|;
name|jp
operator|=
name|vu
operator|->
name|v_instance
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vu
operator|->
name|v_insize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
switch|switch
condition|(
name|ifvar
condition|)
block|{
case|case
name|viewPrimName
case|:
return|return
name|o_specific
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
operator|(
name|caddr_t
operator|)
name|vu
operator|->
name|v_name
argument_list|)
return|;
case|case
name|viewPrimTDomain
case|:
return|return
name|o_specific
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|vu
operator|->
name|v_community
condition|?
name|rfc1157Domain
else|:
name|localAgent
argument_list|)
argument_list|)
return|;
case|case
name|viewPrimTAddr
case|:
ifdef|#
directive|ifdef
name|TCP
if|if
condition|(
name|vu
operator|->
name|v_community
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|vu
operator|->
name|v_sa
decl_stmt|;
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
literal|4
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|viewPrimUser
case|:
case|case
name|viewPrimCommunity
case|:
if|if
condition|(
name|vu
operator|->
name|v_community
condition|)
return|return
name|o_qbstring
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|vu
operator|->
name|v_community
argument_list|)
return|;
else|else
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|viewPrimType
case|:
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|P_VALID
argument_list|)
return|;
default|default:
return|return
name|int_SNMP_error__status_noSuchName
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|view
modifier|*
name|get_prent
parameter_list|(
name|ip
parameter_list|,
name|len
parameter_list|,
name|isnext
parameter_list|)
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|isnext
decl_stmt|;
block|{
specifier|register
name|struct
name|view
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|v
operator|!=
name|VHead
condition|;
name|v
operator|=
name|v
operator|->
name|v_forw
control|)
switch|switch
condition|(
name|elem_cmp
argument_list|(
name|v
operator|->
name|v_instance
argument_list|,
name|v
operator|->
name|v_insize
argument_list|,
name|ip
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|isnext
condition|)
return|return
name|v
return|;
if|if
condition|(
operator|(
name|v
operator|=
name|v
operator|->
name|v_forw
operator|)
operator|==
name|VHead
condition|)
return|return
name|NULL
return|;
comment|/* else fall... */
case|case
literal|1
case|:
return|return
operator|(
name|isnext
condition|?
name|v
else|:
name|NULL
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|viewAclView
value|0
end_define

begin_define
define|#
directive|define
name|viewAclCommunity
value|1
end_define

begin_define
define|#
directive|define
name|viewAclUser
value|2
end_define

begin_define
define|#
directive|define
name|viewAclPrivileges
value|3
end_define

begin_define
define|#
directive|define
name|viewAclType
value|4
end_define

begin_define
define|#
directive|define
name|A_VALID
value|1
end_define

begin_comment
comment|/* viewAclType */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|community
modifier|*
name|CLex
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|community
modifier|*
name|get_acent
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|o_viewAcl
parameter_list|(
name|oi
parameter_list|,
name|v
parameter_list|,
name|offset
parameter_list|)
name|OI
name|oi
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|ifvar
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
specifier|register
name|struct
name|community
modifier|*
name|c
decl_stmt|;
specifier|register
name|OID
name|oid
init|=
name|oi
operator|->
name|oi_name
decl_stmt|;
specifier|register
name|OT
name|ot
init|=
name|oi
operator|->
name|oi_type
decl_stmt|;
name|ifvar
operator|=
operator|(
name|int
operator|)
name|ot
operator|->
name|ot_info
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|<=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|get_acent
argument_list|(
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
name|oid
operator|->
name|oid_nelem
operator|-
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
break|break;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|==
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
condition|)
block|{
name|OID
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|CLex
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|oid_extend
argument_list|(
name|oid
argument_list|,
name|c
operator|->
name|c_insize
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
name|ip
operator|=
name|new
operator|->
name|oid_elements
operator|+
name|new
operator|->
name|oid_nelem
operator|-
name|c
operator|->
name|c_insize
expr_stmt|;
name|jp
operator|=
name|c
operator|->
name|c_instance
expr_stmt|;
for|for
control|(
name|i
operator|=
name|c
operator|->
name|c_insize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|name
condition|)
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|get_acent
argument_list|(
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
name|j
operator|=
name|oid
operator|->
name|oid_nelem
operator|-
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|j
operator|-
name|c
operator|->
name|c_insize
operator|)
operator|<
literal|0
condition|)
block|{
name|OID
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|oid_extend
argument_list|(
name|oid
argument_list|,
operator|-
name|i
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|v
operator|->
name|name
condition|)
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|new
expr_stmt|;
name|oid
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|oid
operator|->
name|oid_nelem
operator|-=
name|i
expr_stmt|;
name|ip
operator|=
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
expr_stmt|;
name|jp
operator|=
name|c
operator|->
name|c_instance
expr_stmt|;
for|for
control|(
name|i
operator|=
name|c
operator|->
name|c_insize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
switch|switch
condition|(
name|ifvar
condition|)
block|{
case|case
name|viewAclView
case|:
return|return
name|o_specific
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
operator|(
name|caddr_t
operator|)
name|c
operator|->
name|c_view
operator|->
name|v_name
argument_list|)
return|;
case|case
name|viewAclCommunity
case|:
case|case
name|viewAclUser
case|:
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|c
operator|->
name|c_name
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|c_name
argument_list|)
argument_list|)
return|;
case|case
name|viewAclPrivileges
case|:
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
operator|(
operator|(
name|c
operator|->
name|c_permission
operator|&
name|OT_RDONLY
operator|)
condition|?
literal|3
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|c
operator|->
name|c_permission
operator|&
name|OT_WRONLY
operator|)
condition|?
literal|8
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|c
operator|->
name|c_permission
operator|&
name|OT_YYY
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
argument_list|)
return|;
case|case
name|viewAclType
case|:
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|A_VALID
argument_list|)
return|;
default|default:
return|return
name|int_SNMP_error__status_noSuchName
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|community
modifier|*
name|get_acent
parameter_list|(
name|ip
parameter_list|,
name|len
parameter_list|,
name|isnext
parameter_list|)
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|isnext
decl_stmt|;
block|{
specifier|register
name|struct
name|community
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|CLex
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|c_next
control|)
switch|switch
condition|(
name|elem_cmp
argument_list|(
name|c
operator|->
name|c_instance
argument_list|,
name|c
operator|->
name|c_insize
argument_list|,
name|ip
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|isnext
condition|?
name|c
operator|->
name|c_next
else|:
name|c
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|isnext
condition|?
name|c
else|:
name|NULL
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|viewTrapView
value|0
end_define

begin_define
define|#
directive|define
name|viewTrapGenerics
value|1
end_define

begin_define
define|#
directive|define
name|viewTrapSpecifics
value|2
end_define

begin_define
define|#
directive|define
name|viewTrapType
value|3
end_define

begin_define
define|#
directive|define
name|T_VALID
value|1
end_define

begin_comment
comment|/* viewTrapType */
end_comment

begin_decl_stmt
specifier|static
name|OID
name|trapview
init|=
name|NULLOID
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|trap
modifier|*
name|get_trent
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|o_viewTrap
parameter_list|(
name|oi
parameter_list|,
name|v
parameter_list|,
name|offset
parameter_list|)
name|OI
name|oi
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|ifvar
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
specifier|register
name|struct
name|trap
modifier|*
name|t
decl_stmt|;
specifier|register
name|OID
name|oid
init|=
name|oi
operator|->
name|oi_name
decl_stmt|;
specifier|register
name|OT
name|ot
init|=
name|oi
operator|->
name|oi_type
decl_stmt|;
name|ifvar
operator|=
operator|(
name|int
operator|)
name|ot
operator|->
name|ot_info
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|<=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
if|if
condition|(
operator|(
name|t
operator|=
name|get_trent
argument_list|(
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
name|oid
operator|->
name|oid_nelem
operator|-
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
break|break;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|==
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
condition|)
block|{
name|OID
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|UHead
operator|->
name|t_forw
operator|)
operator|==
name|UHead
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|oid_extend
argument_list|(
name|oid
argument_list|,
name|t
operator|->
name|t_insize
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
name|ip
operator|=
name|new
operator|->
name|oid_elements
operator|+
name|new
operator|->
name|oid_nelem
operator|-
name|t
operator|->
name|t_insize
expr_stmt|;
name|jp
operator|=
name|t
operator|->
name|t_instance
expr_stmt|;
for|for
control|(
name|i
operator|=
name|t
operator|->
name|t_insize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|name
condition|)
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|get_trent
argument_list|(
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
name|j
operator|=
name|oid
operator|->
name|oid_nelem
operator|-
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|j
operator|-
name|t
operator|->
name|t_insize
operator|)
operator|<
literal|0
condition|)
block|{
name|OID
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|oid_extend
argument_list|(
name|oid
argument_list|,
operator|-
name|i
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|v
operator|->
name|name
condition|)
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|new
expr_stmt|;
name|oid
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|oid
operator|->
name|oid_nelem
operator|-=
name|i
expr_stmt|;
name|ip
operator|=
name|oid
operator|->
name|oid_elements
operator|+
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
expr_stmt|;
name|jp
operator|=
name|t
operator|->
name|t_instance
expr_stmt|;
for|for
control|(
name|i
operator|=
name|t
operator|->
name|t_insize
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
switch|switch
condition|(
name|ifvar
condition|)
block|{
case|case
name|viewTrapView
case|:
return|return
name|o_specific
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
operator|(
name|caddr_t
operator|)
name|t
operator|->
name|t_view
operator|->
name|v_name
argument_list|)
return|;
case|case
name|viewTrapGenerics
case|:
block|{
name|char
name|c
init|=
name|t
operator|->
name|t_generics
operator|&
literal|0xff
decl_stmt|;
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
return|;
block|}
case|case
name|viewTrapSpecifics
case|:
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|viewTrapType
case|:
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|T_VALID
argument_list|)
return|;
default|default:
return|return
name|int_SNMP_error__status_noSuchName
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|trap
modifier|*
name|get_trent
parameter_list|(
name|ip
parameter_list|,
name|len
parameter_list|,
name|isnext
parameter_list|)
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|isnext
decl_stmt|;
block|{
specifier|register
name|struct
name|trap
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|UHead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|UHead
condition|;
name|t
operator|=
name|t
operator|->
name|t_forw
control|)
switch|switch
condition|(
name|elem_cmp
argument_list|(
name|t
operator|->
name|t_instance
argument_list|,
name|t
operator|->
name|t_insize
argument_list|,
name|ip
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|isnext
condition|)
return|return
name|t
return|;
if|if
condition|(
operator|(
name|t
operator|=
name|t
operator|->
name|t_forw
operator|)
operator|==
name|UHead
condition|)
return|return
name|NULL
return|;
comment|/* else fall... */
case|case
literal|1
case|:
return|return
operator|(
name|isnext
condition|?
name|t
else|:
name|NULL
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|view_compar
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|view
modifier|*
modifier|*
name|a
decl_stmt|,
decl|*
modifier|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
name|elem_cmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|v_instance
argument_list|,
operator|(
operator|*
name|a
operator|)
operator|->
name|v_insize
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|v_instance
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|v_insize
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|comm_compar
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|community
modifier|*
modifier|*
name|a
decl_stmt|,
decl|*
modifier|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
name|elem_cmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|c_instance
argument_list|,
operator|(
operator|*
name|a
operator|)
operator|->
name|c_insize
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|c_instance
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|c_insize
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|trap_compar
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|trap
modifier|*
modifier|*
name|a
decl_stmt|,
decl|*
modifier|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
name|elem_cmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|t_instance
argument_list|,
operator|(
operator|*
name|a
operator|)
operator|->
name|t_insize
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|t_instance
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|t_insize
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
specifier|static
struct|struct
name|wired
block|{
name|char
modifier|*
name|w_args1
decl_stmt|;
name|char
modifier|*
name|w_args2
decl_stmt|;
block|}
name|wired
index|[]
init|=
block|{
literal|"defViewWholeRW"
block|,
name|NULL
block|,
literal|"defViewWholeRO"
block|,
name|NULL
block|,
literal|"defViewStandardRW"
block|,
literal|"mgmt"
block|,
literal|"defViewStandardRO"
block|,
literal|"mgmt"
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|init_view
argument_list|()
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
specifier|register
name|struct
name|wired
modifier|*
name|w
decl_stmt|;
name|CHead
operator|->
name|c_forw
operator|=
name|CHead
operator|->
name|c_back
operator|=
name|CHead
expr_stmt|;
name|UHead
operator|->
name|t_forw
operator|=
name|UHead
operator|->
name|t_back
operator|=
name|UHead
expr_stmt|;
name|VHead
operator|->
name|v_forw
operator|=
name|VHead
operator|->
name|v_back
operator|=
name|VHead
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
literal|"view"
expr_stmt|;
for|for
control|(
name|w
operator|=
name|wired
init|;
name|w
operator|->
name|w_args1
condition|;
name|w
operator|++
control|)
block|{
name|vec
index|[
literal|1
index|]
operator|=
name|w
operator|->
name|w_args1
expr_stmt|;
if|if
condition|(
name|vec
index|[
literal|2
index|]
operator|=
name|w
operator|->
name|w_args2
condition|)
name|vec
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|f_view
argument_list|(
name|vec
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"you lose"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"defViewTrapDest.0"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|trapview
operator|=
name|text2oid
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown OID \"defViewTrapDest.0\" for traps"
argument_list|)
expr_stmt|;
name|trapview
operator|->
name|oid_nelem
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|localAgent
operator|=
name|text2oid
argument_list|(
literal|"localAgent"
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown OID \"localAgent\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rfc1157Domain
operator|=
name|text2oid
argument_list|(
literal|"rfc1157Domain"
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown OID \"rfc1157Domain\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewPrimName"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewPrim
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewPrimName
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewPrimTDomain"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewPrim
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewPrimTDomain
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewPrimTAddr"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewPrim
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewPrimTAddr
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewPrimUser"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewPrim
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewPrimUser
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewPrimCommunity"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewPrim
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewPrimCommunity
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewPrimType"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewPrim
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewPrimType
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewAclView"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewAcl
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewAclView
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewAclCommunity"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewAcl
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewAclCommunity
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewAclUser"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewAcl
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewAclUser
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewAclPrivileges"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewAcl
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewAclPrivileges
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewAclType"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewAcl
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewAclType
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewTrapView"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewTrap
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewTrapView
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewTrapGenerics"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewTrap
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewTrapGenerics
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewTrapSpecifics"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewTrap
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewTrapSpecifics
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"viewTrapType"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_viewTrap
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|viewTrapType
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|fin_view
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|struct
name|community
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|trap
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|CHead
operator|->
name|c_forw
operator|==
name|CHead
condition|)
block|{
name|vec
index|[
literal|0
index|]
operator|=
literal|"community"
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
literal|"public"
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|f_community
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|CHead
operator|->
name|c_forw
init|;
name|c
operator|!=
name|CHead
condition|;
name|c
operator|=
name|c
operator|->
name|c_forw
control|)
block|{
for|for
control|(
name|v
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|v
operator|!=
name|VHead
condition|;
name|v
operator|=
name|v
operator|->
name|v_forw
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|v
operator|->
name|v_name
argument_list|,
name|c
operator|->
name|c_vu
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|->
name|c_view
operator|=
name|v
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|v
operator|==
name|VHead
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"no such view as %s for community \"%s\""
argument_list|,
name|sprintoid
argument_list|(
name|c
operator|->
name|c_vu
argument_list|)
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|v
operator|!=
name|VHead
condition|;
name|v
operator|=
name|v
operator|->
name|v_forw
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|view
modifier|*
modifier|*
name|base
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
operator|(
expr|struct
name|view
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|*
sizeof|sizeof
expr|*
name|base
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|base
expr_stmt|;
for|for
control|(
name|v
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|v
operator|!=
name|VHead
condition|;
name|v
operator|=
name|v
operator|->
name|v_forw
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
name|OID
name|oid
init|=
name|v
operator|->
name|v_name
decl_stmt|;
name|v
operator|->
name|v_insize
operator|=
literal|1
operator|+
operator|(
name|j
operator|=
name|oid
operator|->
name|oid_nelem
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|v_instance
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|v
operator|->
name|v_insize
argument_list|,
sizeof|sizeof
expr|*
name|v
operator|->
name|v_instance
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_instance
index|[
literal|0
index|]
operator|=
name|oid
operator|->
name|oid_nelem
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|v
operator|->
name|v_instance
operator|+
literal|1
operator|,
name|jp
operator|=
name|oid
operator|->
name|oid_elements
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
name|remque
argument_list|(
operator|*
name|ep
operator|++
operator|=
name|v
argument_list|)
expr_stmt|;
block|}
name|VHead
operator|->
name|v_forw
operator|=
name|VHead
operator|->
name|v_back
operator|=
name|VHead
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|i
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|,
name|view_compar
argument_list|)
expr_stmt|;
name|bp
operator|=
name|base
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
name|insque
argument_list|(
operator|*
name|bp
operator|++
argument_list|,
name|VHead
operator|->
name|v_back
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|CHead
operator|->
name|c_forw
init|;
name|c
operator|!=
name|CHead
condition|;
name|c
operator|=
name|c
operator|->
name|c_forw
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
specifier|register
name|struct
name|community
modifier|*
modifier|*
name|base
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
operator|(
expr|struct
name|community
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|*
sizeof|sizeof
expr|*
name|base
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|base
expr_stmt|;
for|for
control|(
name|c
operator|=
name|CHead
operator|->
name|c_forw
init|;
name|c
operator|!=
name|CHead
condition|;
name|c
operator|=
name|c
operator|->
name|c_forw
control|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|;
switch|switch
condition|(
name|c
operator|->
name|c_addr
operator|.
name|na_stack
condition|)
block|{
case|case
name|NA_TCP
case|:
name|j
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|NA_X25
case|:
name|j
operator|=
name|c
operator|->
name|c_addr
operator|.
name|na_dtelen
expr_stmt|;
break|break;
case|case
name|NA_NSAP
case|:
name|j
operator|=
name|c
operator|->
name|c_addr
operator|.
name|na_addrlen
expr_stmt|;
break|break;
default|default:
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|c
operator|->
name|c_insize
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|c
operator|->
name|c_name
argument_list|)
operator|+
literal|1
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|c_instance
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|c
operator|->
name|c_insize
argument_list|,
sizeof|sizeof
expr|*
name|c
operator|->
name|c_instance
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ip
operator|=
name|c
operator|->
name|c_instance
expr_stmt|;
operator|*
name|ip
operator|++
operator|=
name|strlen
argument_list|(
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|c
operator|->
name|c_name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|cp
operator|&
literal|0xff
expr_stmt|;
operator|*
name|ip
operator|++
operator|=
name|j
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|c_addr
operator|.
name|na_stack
condition|)
block|{
case|case
name|NA_TCP
case|:
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|c
operator|->
name|c_addr
operator|.
name|na_domain
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|ip
argument_list|,
name|ip
operator|+
literal|1
argument_list|,
name|ip
operator|+
literal|2
argument_list|,
name|ip
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|NA_X25
case|:
name|dp
operator|=
operator|(
name|cp
operator|=
name|c
operator|->
name|c_addr
operator|.
name|na_dte
operator|)
operator|+
name|c
operator|->
name|c_addr
operator|.
name|na_dtelen
expr_stmt|;
goto|goto
name|stuff_it
goto|;
case|case
name|NA_NSAP
case|:
name|dp
operator|=
operator|(
name|cp
operator|=
name|c
operator|->
name|c_addr
operator|.
name|na_address
operator|)
operator|+
name|c
operator|->
name|c_addr
operator|.
name|na_addrlen
expr_stmt|;
name|stuff_it
label|:
empty_stmt|;
while|while
condition|(
name|cp
operator|<
name|dp
condition|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|cp
operator|++
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|i
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|,
name|comm_compar
argument_list|)
expr_stmt|;
name|bp
operator|=
name|base
expr_stmt|;
name|c
operator|=
name|CLex
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
name|c
operator|->
name|c_next
operator|=
operator|*
name|bp
expr_stmt|;
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
name|c
operator|->
name|c_next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
block|}
else|else
name|CLex
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|UHead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|UHead
condition|;
name|t
operator|=
name|t
operator|->
name|t_forw
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|trap
modifier|*
modifier|*
name|base
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
operator|(
expr|struct
name|trap
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|*
sizeof|sizeof
expr|*
name|base
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|base
expr_stmt|;
for|for
control|(
name|t
operator|=
name|UHead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|UHead
condition|;
name|t
operator|=
name|t
operator|->
name|t_forw
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
name|OID
name|oid
init|=
name|t
operator|->
name|t_view
operator|->
name|v_name
decl_stmt|;
name|t
operator|->
name|t_insize
operator|=
literal|1
operator|+
operator|(
name|j
operator|=
name|oid
operator|->
name|oid_nelem
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|t_instance
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|t
operator|->
name|t_insize
argument_list|,
sizeof|sizeof
expr|*
name|t
operator|->
name|t_instance
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_instance
index|[
literal|0
index|]
operator|=
name|oid
operator|->
name|oid_nelem
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|t
operator|->
name|t_instance
operator|+
literal|1
operator|,
name|jp
operator|=
name|oid
operator|->
name|oid_elements
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
name|remque
argument_list|(
operator|*
name|ep
operator|++
operator|=
name|t
argument_list|)
expr_stmt|;
block|}
name|UHead
operator|->
name|t_forw
operator|=
name|UHead
operator|->
name|t_back
operator|=
name|UHead
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|i
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|,
name|trap_compar
argument_list|)
expr_stmt|;
name|bp
operator|=
name|base
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
name|insque
argument_list|(
operator|*
name|bp
operator|++
argument_list|,
name|UHead
operator|->
name|t_back
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_community
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|struct
name|community
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
name|vec
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|(
expr|struct
name|community
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|c
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|c
operator|->
name|c_name
operator|=
name|strdup
argument_list|(
operator|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
name|na
operator|=
operator|&
name|c
operator|->
name|c_addr
expr_stmt|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
name|str2sa
argument_list|(
operator|*
name|vec
argument_list|,
name|na
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown address \"%s\" for community \"%s\""
argument_list|,
operator|*
name|vec
argument_list|,
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
else|else
block|{
name|na
operator|->
name|na_stack
operator|=
name|NA_TCP
expr_stmt|;
name|na
operator|->
name|na_community
operator|=
name|ts_comm_tcp_default
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|na
operator|->
name|na_domain
argument_list|,
literal|"0.0.0.0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"readOnly"
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|->
name|c_permission
operator|=
name|OT_RDONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"readWrite"
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|->
name|c_permission
operator|=
name|OT_RDWRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"writeOnly"
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|->
name|c_permission
operator|=
name|OT_WRONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"none"
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"invalid access mode \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
name|vec
operator|++
expr_stmt|;
block|}
else|else
name|c
operator|->
name|c_permission
operator|=
name|OT_RDONLY
expr_stmt|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|c_vu
operator|=
name|text2oid
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown OID \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
operator|*
operator|++
name|vec
condition|)
goto|goto
name|you_lose
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|->
name|c_vu
operator|=
name|text2oid
argument_list|(
literal|"defViewWholeRO"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown OID \"defViewWholeRO\""
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
name|insque
argument_list|(
name|c
argument_list|,
name|CHead
operator|->
name|c_back
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|free
argument_list|(
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_proxy
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|community
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|v
decl_stmt|,
modifier|*
name|u
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|view
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_subtree
operator|.
name|s_forw
operator|=
name|v
operator|->
name|v_subtree
operator|.
name|s_back
operator|=
operator|&
name|v
operator|->
name|v_subtree
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|(
expr|struct
name|community
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|c
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_permission
operator|=
name|OT_YYY
expr_stmt|;
name|vec
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|v_name
operator|=
name|text2oid
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown OID \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
name|c
operator|->
name|c_vu
operator|=
name|v
operator|->
name|v_name
expr_stmt|;
if|if
condition|(
name|trapview
operator|&&
name|inSubtree
argument_list|(
name|trapview
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"view \"%s\" is for traps"
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
for|for
control|(
name|u
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|u
operator|!=
name|VHead
condition|;
name|u
operator|=
name|u
operator|->
name|v_forw
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|u
operator|->
name|v_name
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"duplicate view \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
name|vec
operator|++
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"rfc1157"
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unsupported proxy domain \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
name|vec
operator|++
expr_stmt|;
name|na
operator|=
operator|&
name|c
operator|->
name|c_addr
expr_stmt|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
name|str2sa
argument_list|(
operator|*
name|vec
argument_list|,
name|na
argument_list|,
operator|&
name|v
operator|->
name|v_sa
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown address \"%s\" for proxy %s"
argument_list|,
operator|*
name|vec
argument_list|,
name|oid2ode
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
else|else
goto|goto
name|you_lose
goto|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|v_community
operator|=
name|str2qb
argument_list|(
operator|*
name|vec
argument_list|,
name|strlen
argument_list|(
operator|*
name|vec
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|c_name
operator|=
name|strdup
argument_list|(
operator|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
condition|)
goto|goto
name|you_lose
goto|;
block|}
else|else
goto|goto
name|you_lose
goto|;
name|insque
argument_list|(
name|v
argument_list|,
name|VHead
operator|->
name|v_back
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|c
argument_list|,
name|CHead
operator|->
name|c_back
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
if|if
condition|(
name|c
operator|->
name|c_name
condition|)
name|free
argument_list|(
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_name
condition|)
name|oid_free
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_community
condition|)
name|qb_free
argument_list|(
name|v
operator|->
name|v_community
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_trap
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|struct
name|trap
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|v
decl_stmt|;
name|struct
name|NSAPaddr
name|nas
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
operator|&
name|nas
decl_stmt|;
specifier|static
name|int
name|trapno
init|=
literal|1
decl_stmt|;
name|vec
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
expr|struct
name|trap
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|t
operator|->
name|t_name
operator|=
name|strdup
argument_list|(
operator|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|v
operator|=
name|t
operator|->
name|t_view
operator|=
operator|&
name|t
operator|->
name|t_vu
expr_stmt|;
name|v
operator|->
name|v_subtree
operator|.
name|s_forw
operator|=
name|v
operator|->
name|v_subtree
operator|.
name|s_back
operator|=
operator|&
name|v
operator|->
name|v_subtree
expr_stmt|;
name|t
operator|->
name|t_generics
operator|=
literal|0xfe
expr_stmt|;
name|vec
operator|++
expr_stmt|;
name|trapview
operator|->
name|oid_elements
index|[
name|trapview
operator|->
name|oid_nelem
operator|++
index|]
operator|=
name|trapno
expr_stmt|;
name|v
operator|->
name|v_name
operator|=
name|oid_cpy
argument_list|(
name|trapview
argument_list|)
expr_stmt|;
name|trapview
operator|->
name|oid_nelem
operator|--
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_name
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|v_community
operator|=
name|str2qb
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|strlen
argument_list|(
name|t
operator|->
name|t_name
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|na
argument_list|,
sizeof|sizeof
expr|*
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
name|str2sa
argument_list|(
operator|*
name|vec
argument_list|,
name|na
argument_list|,
operator|&
name|v
operator|->
name|v_sa
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown address \"%s\" for trap sink \"%s\""
argument_list|,
operator|*
name|vec
argument_list|,
name|t
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
else|else
goto|goto
name|you_lose
goto|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|OID
name|name
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|u
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|text2oid
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown OID \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
name|oid_free
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_name
operator|=
name|name
expr_stmt|;
for|for
control|(
name|u
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|u
operator|!=
name|VHead
condition|;
name|u
operator|=
name|u
operator|->
name|v_forw
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|u
operator|->
name|v_name
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"duplicate view \"%s\" for trap sink \"%s\""
argument_list|,
operator|*
name|vec
argument_list|,
name|t
operator|->
name|t_name
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
name|vec
operator|++
expr_stmt|;
block|}
else|else
name|trapno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
operator|*
name|vec
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|t
operator|->
name|t_generics
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|you_lose
goto|;
if|if
condition|(
operator|*
operator|++
name|vec
condition|)
goto|goto
name|you_lose
goto|;
block|}
name|insque
argument_list|(
name|t
argument_list|,
name|UHead
operator|->
name|t_back
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|v
argument_list|,
name|VHead
operator|->
name|v_back
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|oid_free
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|qb_free
argument_list|(
name|v
operator|->
name|v_community
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_view
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|subtree
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|v
decl_stmt|,
modifier|*
name|u
decl_stmt|;
if|if
condition|(
name|viewmask
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"too many views starting with \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|view
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|s
operator|=
operator|&
name|v
operator|->
name|v_subtree
expr_stmt|;
name|v
operator|->
name|v_subtree
operator|.
name|s_forw
operator|=
name|v
operator|->
name|v_subtree
operator|.
name|s_back
operator|=
name|s
expr_stmt|;
name|vec
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|v_name
operator|=
name|text2oid
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown OID \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|trapview
operator|&&
name|inSubtree
argument_list|(
name|trapview
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"view \"%s\" is for traps"
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
for|for
control|(
name|u
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|u
operator|!=
name|VHead
condition|;
name|u
operator|=
name|u
operator|->
name|v_forw
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|u
operator|->
name|v_name
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"duplicate view \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
for|for
control|(
name|vec
operator|++
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
specifier|register
name|struct
name|subtree
modifier|*
name|z
decl_stmt|;
name|OID
name|name
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|text2oid
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown OID \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
for|for
control|(
name|x
operator|=
name|s
operator|->
name|s_forw
init|;
name|x
operator|!=
name|s
condition|;
name|x
operator|=
name|y
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|y
operator|=
name|x
operator|->
name|s_forw
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
operator|->
name|s_subtree
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
operator|->
name|oid_elements
argument_list|,
operator|(
operator|(
name|i
operator|=
name|x
operator|->
name|s_subtree
operator|->
name|oid_nelem
operator|)
operator|<=
operator|(
name|j
operator|=
name|name
operator|->
name|oid_nelem
operator|)
condition|?
name|i
else|:
name|j
operator|)
operator|*
sizeof|sizeof
name|name
operator|->
name|oid_elements
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s %s %s"
argument_list|,
operator|*
name|vec
argument_list|,
name|i
operator|<=
name|j
condition|?
literal|"already under"
else|:
literal|"superceding"
argument_list|,
name|oid2ode
argument_list|(
name|x
operator|->
name|s_subtree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|j
condition|)
goto|goto
name|another
goto|;
name|remque
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|x
operator|->
name|s_subtree
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|z
operator|=
operator|(
expr|struct
name|subtree
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|z
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|z
operator|->
name|s_subtree
operator|=
name|name
expr_stmt|;
name|insque
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|s_back
argument_list|)
expr_stmt|;
name|another
label|:
empty_stmt|;
block|}
name|v
operator|->
name|v_mask
operator|=
name|viewmask
expr_stmt|;
name|viewmask
operator|<<=
literal|1
expr_stmt|;
name|insque
argument_list|(
name|v
argument_list|,
name|VHead
operator|->
name|v_back
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
for|for
control|(
name|x
operator|=
name|s
operator|->
name|s_forw
init|;
name|x
operator|!=
name|s
condition|;
name|x
operator|=
name|y
control|)
block|{
name|y
operator|=
name|x
operator|->
name|s_forw
expr_stmt|;
name|remque
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|x
operator|->
name|s_subtree
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|v_name
condition|)
name|oid_free
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tcpservice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|udport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|traport
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|str2sa
parameter_list|(
name|s
parameter_list|,
name|na
parameter_list|,
name|sock
parameter_list|,
name|proxy
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sock
decl_stmt|;
name|int
name|proxy
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TCP
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
endif|#
directive|endif
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP
if|if
condition|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|na
operator|->
name|na_stack
operator|=
name|NA_TCP
expr_stmt|;
name|na
operator|->
name|na_community
operator|=
name|ts_comm_tcp_default
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
operator|&
name|sin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|na
operator|->
name|na_domain
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
sizeof|sizeof
name|na
operator|->
name|na_domain
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|ta
operator|=
name|str2taddr
argument_list|(
name|s
argument_list|)
operator|)
operator|&&
name|ta
operator|->
name|ta_naddr
operator|>
literal|0
condition|)
block|{
operator|*
name|na
operator|=
name|ta
operator|->
name|ta_addrs
index|[
literal|0
index|]
expr_stmt|;
comment|/* struct copy */
block|}
else|else
return|return
name|NOTOK
return|;
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
switch|switch
condition|(
name|na
operator|->
name|na_stack
condition|)
block|{
ifdef|#
directive|ifdef
name|TCP
case|case
name|NA_TCP
case|:
if|if
condition|(
operator|!
name|tcpservice
condition|)
goto|goto
name|you_lose
goto|;
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|na
operator|->
name|na_port
condition|?
name|na
operator|->
name|na_port
else|:
name|proxy
condition|?
name|udport
else|:
name|traport
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|na
operator|->
name|na_domain
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
name|sin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
operator|&
name|sin
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sock
operator|)
operator|=
name|sin
expr_stmt|;
comment|/* struct copy */
block|}
break|break;
endif|#
directive|endif
default|default:
name|you_lose
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"address type unsupported"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
end_function

end_unit

