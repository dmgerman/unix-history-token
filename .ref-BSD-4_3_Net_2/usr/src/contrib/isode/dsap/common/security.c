begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* security.c - Check security parameters */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/dsap/common/RCS/security.c,v 7.3 91/02/22 09:20:12 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/dsap/common/RCS/security.c,v 7.3 91/02/22 09:20:12 mrose Interim $  *  *  * $Log:	security.c,v $  * Revision 7.3  91/02/22  09:20:12  mrose  * Interim 6.8  *   * Revision 7.1  89/12/19  16:20:47  mrose  * sync  *   * Revision 6.0  89/09/08  10:20:02  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"logger.h"
end_include

begin_include
include|#
directive|include
file|"quipu/ds_error.h"
end_include

begin_include
include|#
directive|include
file|"quipu/commonarg.h"
end_include

begin_include
include|#
directive|include
file|"pepsy.h"
end_include

begin_include
include|#
directive|include
file|"quipu/AF_pre_defs.h"
end_include

begin_include
include|#
directive|include
file|"quipu/algorithm.h"
end_include

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STATS
end_ifndef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_stat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|adios
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|fatal(-1, b)
end_define

begin_function_decl
name|char
modifier|*
name|new_version
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
modifier|*
name|compute_signature
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|signature
modifier|*
name|sign_operation_aux
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|signature
modifier|*
name|sign_operation
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|GenericHash
modifier|*
name|pe2hash
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*   * Cache holding keys of trusted certification authorities  */
end_comment

begin_decl_stmt
name|struct
name|ca_record
modifier|*
name|ca_key_cache
init|=
operator|(
expr|struct
name|ca_record
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Cache holding keys of users (untrusted)  */
end_comment

begin_decl_stmt
name|struct
name|ca_record
modifier|*
name|user_key_cache
init|=
operator|(
expr|struct
name|ca_record
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Own certificate. (For convenient access).  */
end_comment

begin_decl_stmt
name|struct
name|certificate
modifier|*
name|my_certificate
init|=
operator|(
expr|struct
name|certificate
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Secret key.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|GenericSecretKey
modifier|*
name|my_secret_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|GenericParameters
modifier|*
name|my_key_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Options to hash function.   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|GenericParameters
modifier|*
name|my_hash_parms
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|ca_record
modifier|*
name|find_user_keyinfo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ca_record
modifier|*
name|find_ca_keyinfo
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Callbacks that actually do the work  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|null_encrypt
argument_list|()
decl_stmt|,
name|null_decrypt
argument_list|()
decl_stmt|,
name|null_read_secret_key
argument_list|()
decl_stmt|,
name|null_write_secret_key
argument_list|()
decl_stmt|,
name|null_read_public_key
argument_list|()
decl_stmt|,
name|null_write_public_key
argument_list|()
decl_stmt|,
name|null_pack_encrypted
argument_list|()
decl_stmt|,
name|null_unpack_encrypted
argument_list|()
decl_stmt|,
name|null_pack_public_key
argument_list|()
decl_stmt|,
name|null_unpack_public_key
argument_list|()
decl_stmt|,
name|null_pack_secret_key
argument_list|()
decl_stmt|,
name|null_unpack_secret_key
argument_list|()
decl_stmt|,
name|null_get_blocksize
argument_list|()
decl_stmt|,
name|null_free_encrypted
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|PublicKeyAlgorithm
name|null_pk_algorithm
init|=
block|{
literal|"quipuEncryptionAlgorithm.2"
block|,
name|null_encrypt
block|,
name|null_decrypt
block|,
name|null_read_secret_key
block|,
name|null_write_secret_key
block|,
name|null_read_public_key
block|,
name|null_write_public_key
block|,
name|null_pack_encrypted
block|,
name|null_unpack_encrypted
block|,
name|null_pack_public_key
block|,
name|null_unpack_public_key
block|,
name|null_pack_secret_key
block|,
name|null_unpack_secret_key
block|,
name|null_get_blocksize
block|,
name|null_free_encrypted
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|PublicKeyAlgorithm
modifier|*
name|pk_alg
init|=
operator|&
name|null_pk_algorithm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|null_hash_block
argument_list|()
decl_stmt|,
name|null_hash_short_block
argument_list|()
decl_stmt|,
name|null_init_hash
argument_list|()
decl_stmt|,
name|null_terminate_hash
argument_list|()
decl_stmt|,
name|null_pack_hash
argument_list|()
decl_stmt|,
name|null_unpack_hash
argument_list|()
decl_stmt|,
name|null_get_blocksize
argument_list|()
decl_stmt|,
name|null_compare_hash
argument_list|()
decl_stmt|,
name|null_free_hash
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|HashAlgorithm
name|null_hash_algorithm
init|=
block|{
literal|"quipuHashAlgorithm.2"
block|,
name|null_hash_block
block|,
name|null_hash_short_block
block|,
name|null_init_hash
block|,
name|null_terminate_hash
block|,
name|null_pack_hash
block|,
name|null_unpack_hash
block|,
name|null_get_blocksize
block|,
name|null_compare_hash
block|,
name|null_free_hash
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|HashAlgorithm
modifier|*
name|hash_alg
init|=
operator|&
name|null_hash_algorithm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|SignatureAlgorithm
name|md2_rsa_algorithm
init|=
block|{
literal|"quipuSignatureAlgorithm.2"
block|,
operator|&
name|null_pk_algorithm
block|,
operator|&
name|null_hash_algorithm
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|SignatureAlgorithm
modifier|*
name|sig_alg
init|=
operator|&
name|md2_rsa_algorithm
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_algorithms
parameter_list|(
name|alg
parameter_list|)
name|struct
name|SignatureAlgorithm
modifier|*
name|alg
decl_stmt|;
block|{
name|pk_alg
operator|=
name|alg
operator|->
name|sig_public
expr_stmt|;
name|hash_alg
operator|=
name|alg
operator|->
name|sig_hash
expr_stmt|;
name|sig_alg
operator|=
name|alg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check security parameters - return 0 or the number of the security error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|check_security_parms
parameter_list|(
name|data
parameter_list|,
name|type
parameter_list|,
name|module
parameter_list|,
name|sp
parameter_list|,
name|sig
parameter_list|,
name|nameptr
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
name|int
name|type
decl_stmt|;
name|modtyp
modifier|*
name|module
decl_stmt|;
name|struct
name|security_parms
modifier|*
name|sp
decl_stmt|;
name|struct
name|signature
modifier|*
name|sig
decl_stmt|;
name|DN
modifier|*
name|nameptr
decl_stmt|;
block|{
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
name|long
name|time_now
decl_stmt|;
name|long
name|time_then
decl_stmt|;
name|long
name|delta
decl_stmt|;
comment|/* If parameters are present, they must be valid */
if|if
condition|(
name|sp
operator|!=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|sp_time
operator|!=
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|time_now
argument_list|)
expr_stmt|;
name|time_then
operator|=
name|gtime
argument_list|(
name|ut2tm
argument_list|(
name|str2utct
argument_list|(
name|sp
operator|->
name|sp_time
argument_list|,
name|strlen
argument_list|(
name|sp
operator|->
name|sp_time
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|time_now
operator|-
name|time_then
expr_stmt|;
block|}
else|else
name|delta
operator|=
literal|0L
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Delay=%D s, protection%s requested, certificate%s present"
operator|,
name|delta
operator|,
operator|(
name|sp
operator|->
name|sp_target
operator|==
literal|'\0'
operator|)
condition|?
literal|" not"
else|:
literal|""
operator|,
operator|(
name|sp
operator|->
name|sp_path
operator|==
operator|(
expr|struct
name|certificate_list
operator|*
operator|)
literal|0
operator|)
condition|?
literal|" not"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
comment|/* NB : must use "" rather than NULLCP for the above to work. */
endif|#
directive|endif
block|}
comment|/* If no signature is provided, nothing else to do */
if|if
condition|(
name|sig
operator|==
operator|(
expr|struct
name|signature
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Operation is signed"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Policy : signed messages must have security parameters present. */
if|if
condition|(
name|sp
operator|==
operator|(
expr|struct
name|security_parms
operator|*
operator|)
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"No security parameters present"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_INVALIDCREDENTIALS
operator|)
return|;
block|}
comment|/* Policy: signed messages must have a time-stamp. */
if|if
condition|(
name|sp
operator|->
name|sp_time
operator|==
name|NULLCP
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"No time-stamp present"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_INVALIDCREDENTIALS
operator|)
return|;
block|}
comment|/* Policy: a certification path must be provided. */
if|if
condition|(
name|sp
operator|->
name|sp_path
operator|==
operator|(
expr|struct
name|certificate_list
operator|*
operator|)
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"No certification path"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_INVALIDCREDENTIALS
operator|)
return|;
block|}
return|return
name|check_cert_path
argument_list|(
name|data
argument_list|,
name|type
argument_list|,
name|module
argument_list|,
name|sp
operator|->
name|sp_path
argument_list|,
name|sig
argument_list|,
name|nameptr
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|check_cert_path
parameter_list|(
name|data
parameter_list|,
name|type
parameter_list|,
name|module
parameter_list|,
name|path
parameter_list|,
name|sig
parameter_list|,
name|nameptr
parameter_list|)
name|caddr_t
name|data
decl_stmt|;
name|int
name|type
decl_stmt|;
name|modtyp
modifier|*
name|module
decl_stmt|;
name|struct
name|certificate_list
modifier|*
name|path
decl_stmt|;
name|struct
name|signature
modifier|*
name|sig
decl_stmt|;
name|DN
modifier|*
name|nameptr
decl_stmt|;
block|{
name|struct
name|ca_record
modifier|*
name|keyinfo
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|GenericPublicKey
modifier|*
name|ca_public
decl_stmt|,
modifier|*
name|user_public
decl_stmt|;
name|struct
name|GenericParameters
modifier|*
name|ca_parms
decl_stmt|,
modifier|*
name|user_parms
decl_stmt|;
name|char
modifier|*
name|now
decl_stmt|;
if|if
condition|(
name|path
operator|==
operator|(
expr|struct
name|certificate_list
operator|*
operator|)
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"No certification path provided"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_AUTHENTICATION
operator|)
return|;
block|}
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Certificate subject:"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|path
operator|->
name|cert
operator|->
name|subject
argument_list|)
expr_stmt|;
name|keyinfo
operator|=
name|find_user_keyinfo
argument_list|(
name|path
operator|->
name|cert
operator|->
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyinfo
operator|!=
operator|(
expr|struct
name|ca_record
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|keyinfo
operator|->
name|key
operator|.
name|alg
operator|.
name|algorithm
argument_list|,
name|name2oid
argument_list|(
name|pk_alg
operator|->
name|name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Cryptographic algorithm not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DSE_SV_UNAVAILABLE
operator|)
return|;
block|}
else|else
name|result
operator|=
call|(
modifier|*
name|pk_alg
operator|->
name|unpack_public
call|)
argument_list|(
name|keyinfo
operator|->
name|key
operator|.
name|value
argument_list|,
operator|&
name|user_public
argument_list|,
operator|&
name|user_parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Certificate issuer:"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|path
operator|->
name|cert
operator|->
name|issuer
argument_list|)
expr_stmt|;
name|keyinfo
operator|=
name|find_ca_keyinfo
argument_list|(
name|path
operator|->
name|cert
operator|->
name|issuer
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyinfo
operator|==
operator|(
expr|struct
name|ca_record
operator|*
operator|)
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid certification path"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_AUTHENTICATION
operator|)
return|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Checking certificate"
operator|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|new_version
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|now
argument_list|,
name|keyinfo
operator|->
name|valid
operator|.
name|not_before
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"CA key not yet valid"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_AUTHENTICATION
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|now
argument_list|,
name|keyinfo
operator|->
name|valid
operator|.
name|not_after
argument_list|)
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"CA key has expired"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_AUTHENTICATION
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|now
argument_list|,
name|path
operator|->
name|cert
operator|->
name|valid
operator|.
name|not_before
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Certificate not yet valid"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_AUTHENTICATION
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|now
argument_list|,
name|path
operator|->
name|cert
operator|->
name|valid
operator|.
name|not_after
argument_list|)
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Certificate has expired"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_AUTHENTICATION
operator|)
return|;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|keyinfo
operator|->
name|key
operator|.
name|alg
operator|.
name|algorithm
argument_list|,
name|name2oid
argument_list|(
name|pk_alg
operator|->
name|name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Algorithm not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DSE_SV_UNAVAILABLE
operator|)
return|;
block|}
else|else
name|result
operator|=
call|(
name|pk_alg
operator|->
name|unpack_public
call|)
argument_list|(
name|keyinfo
operator|->
name|key
operator|.
name|value
argument_list|,
operator|&
name|ca_public
argument_list|,
operator|&
name|ca_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|OK
condition|)
name|result
operator|=
name|check_signature
argument_list|(
operator|(
name|caddr_t
operator|)
name|path
operator|->
name|cert
argument_list|,
name|_ZCertificateToSignAF
argument_list|,
operator|&
name|_ZAF_mod
argument_list|,
operator|&
operator|(
name|path
operator|->
name|cert
operator|->
name|sig
operator|)
argument_list|,
name|ca_public
argument_list|,
name|ca_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid certificate"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DSE_SC_INVALIDSIGNATURE
operator|)
return|;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|path
operator|->
name|cert
operator|->
name|key
operator|.
name|alg
operator|.
name|algorithm
argument_list|,
name|name2oid
argument_list|(
name|pk_alg
operator|->
name|name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Algorithm not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DSE_SV_UNAVAILABLE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|OK
condition|)
name|result
operator|=
call|(
name|pk_alg
operator|->
name|unpack_public
call|)
argument_list|(
name|path
operator|->
name|cert
operator|->
name|key
operator|.
name|value
argument_list|,
operator|&
name|user_public
argument_list|,
operator|&
name|user_parms
argument_list|)
expr_stmt|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Checking user's signature"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|OK
condition|)
name|result
operator|=
name|check_signature
argument_list|(
name|data
argument_list|,
name|type
argument_list|,
name|module
argument_list|,
name|sig
argument_list|,
name|user_public
argument_list|,
name|user_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid user signature"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DSE_SC_INVALIDSIGNATURE
operator|)
return|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Signature was OK"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Operation signed by"
argument_list|,
operator|(
name|IFP
operator|)
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|path
operator|->
name|cert
operator|->
name|subject
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|nameptr
operator|=
name|path
operator|->
name|cert
operator|->
name|subject
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Having decided that a CA is trusted (eg. by looking a tailor file),  * add its key to the cache.  */
end_comment

begin_function
name|int
name|add_ca_key
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|key_info
name|key
decl_stmt|;
name|struct
name|validity
name|valid
decl_stmt|;
name|DN
name|name
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|OID
name|alg
decl_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|name
operator|=
name|str2dn
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULLDN
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"Invalid CA name: %s"
operator|,
name|str
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|str
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULLCP
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|alg
operator|=
name|name2oid
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|alg
operator|==
name|NULLOID
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"Invalid algorithm: %s"
operator|,
name|str
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|key
operator|.
name|alg
operator|.
name|algorithm
operator|=
name|alg
expr_stmt|;
name|str
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULLCP
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"Algorithm parameters missing"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|str2alg
argument_list|(
name|str
argument_list|,
operator|&
operator|(
name|key
operator|.
name|alg
operator|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULLCP
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|str2encrypted
argument_list|(
name|str
argument_list|,
operator|&
operator|(
name|key
operator|.
name|value
operator|)
argument_list|,
operator|&
operator|(
name|key
operator|.
name|n_bits
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|str
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULLCP
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"End of key velidity not specified"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|valid
operator|.
name|not_before
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|ptr
expr_stmt|;
name|valid
operator|.
name|not_after
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valid
operator|.
name|not_before
operator|=
literal|"000000000000Z"
expr_stmt|;
name|valid
operator|.
name|not_after
operator|=
literal|"891231235959Z"
expr_stmt|;
block|}
return|return
operator|(
name|add_ca_key_aux
argument_list|(
name|name
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|valid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|add_ca_key_aux
parameter_list|(
name|name
parameter_list|,
name|key
parameter_list|,
name|valid
parameter_list|)
name|DN
name|name
decl_stmt|;
name|struct
name|key_info
modifier|*
name|key
decl_stmt|;
name|struct
name|validity
modifier|*
name|valid
decl_stmt|;
block|{
name|struct
name|ca_record
modifier|*
name|new
decl_stmt|;
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Adding CA:"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|name
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|ca_record
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
operator|(
expr|struct
name|ca_record
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|key
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_info
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|valid
operator|.
name|not_before
operator|=
name|valid
operator|->
name|not_before
expr_stmt|;
name|new
operator|->
name|valid
operator|.
name|not_after
operator|=
name|valid
operator|->
name|not_after
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|ca_key_cache
expr_stmt|;
name|ca_key_cache
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|struct
name|ca_record
modifier|*
name|find_keyinfo_aux
parameter_list|(
name|cache
parameter_list|,
name|name
parameter_list|)
name|struct
name|ca_record
modifier|*
name|cache
decl_stmt|;
name|DN
name|name
decl_stmt|;
block|{
name|struct
name|ca_record
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|cache
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
if|if
condition|(
name|dn_cmp
argument_list|(
name|name
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
comment|/* ie. NULL */
block|}
end_function

begin_function
name|struct
name|ca_record
modifier|*
name|find_user_keyinfo
parameter_list|(
name|name
parameter_list|)
name|DN
name|name
decl_stmt|;
block|{
return|return
operator|(
name|find_keyinfo_aux
argument_list|(
name|user_key_cache
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ca_record
modifier|*
name|find_ca_keyinfo
parameter_list|(
name|name
parameter_list|)
name|DN
name|name
decl_stmt|;
block|{
return|return
operator|(
name|find_keyinfo_aux
argument_list|(
name|ca_key_cache
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read secret key from a file.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|set_secret_key
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
call|(
name|pk_alg
operator|->
name|read_secret
call|)
argument_list|(
name|str
argument_list|,
operator|&
name|my_secret_key
argument_list|,
operator|&
name|my_key_parms
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute signature. To do this, have to know canonical BER encoding of the  * data structure. Hence, this routine takes a PEPY-produced encoder as one  * parameter, and uses it to produce a PE.  */
end_comment

begin_function
name|struct
name|signature
modifier|*
name|sign_operation
parameter_list|(
name|data
parameter_list|,
name|type
parameter_list|,
name|module
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|type
decl_stmt|;
name|modtyp
modifier|*
name|module
decl_stmt|;
block|{
return|return
name|sign_operation_aux
argument_list|(
name|data
argument_list|,
name|type
argument_list|,
name|module
argument_list|,
name|my_secret_key
argument_list|,
name|my_key_parms
argument_list|,
name|my_hash_parms
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|struct
name|signature
modifier|*
name|sign_operation_aux
parameter_list|(
name|data
parameter_list|,
name|type
parameter_list|,
name|module
parameter_list|,
name|key
parameter_list|,
name|parms
parameter_list|,
name|mdparms
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|type
decl_stmt|;
name|modtyp
modifier|*
name|module
decl_stmt|;
name|struct
name|GenericSecretKey
modifier|*
name|key
decl_stmt|;
name|struct
name|GenericParameters
modifier|*
name|parms
decl_stmt|;
name|struct
name|GenericParameters
modifier|*
name|mdparms
decl_stmt|;
block|{
name|struct
name|signature
modifier|*
name|result
decl_stmt|;
name|unsigned
modifier|*
name|csig
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|enc_f
argument_list|(
name|type
argument_list|,
name|module
argument_list|,
operator|&
name|pe
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|csig
operator|=
name|compute_signature
argument_list|(
name|pe
argument_list|,
name|key
argument_list|,
name|parms
argument_list|,
name|mdparms
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
expr|struct
name|signature
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|pack_encrypted
call|)
argument_list|(
name|csig
argument_list|,
operator|&
operator|(
name|result
operator|->
name|encrypted
operator|)
argument_list|,
operator|&
operator|(
name|result
operator|->
name|n_bits
operator|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|result
operator|->
name|alg
operator|.
name|algorithm
operator|=
name|name2oid
argument_list|(
name|sig_alg
operator|->
name|sig_name
argument_list|)
expr_stmt|;
name|result
operator|->
name|alg
operator|.
name|algorithm
operator|=
name|oid_cpy
argument_list|(
name|result
operator|->
name|alg
operator|.
name|algorithm
argument_list|)
expr_stmt|;
name|result
operator|->
name|alg
operator|.
name|p_type
operator|=
name|ALG_PARM_UNKNOWN
expr_stmt|;
name|result
operator|->
name|alg
operator|.
name|asn
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|free_encrypted
call|)
argument_list|(
name|csig
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|check_signature
parameter_list|(
name|data
parameter_list|,
name|type
parameter_list|,
name|module
parameter_list|,
name|sig
parameter_list|,
name|pubkey
parameter_list|,
name|parms
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|type
decl_stmt|;
name|modtyp
modifier|*
name|module
decl_stmt|;
name|struct
name|signature
modifier|*
name|sig
decl_stmt|;
name|struct
name|GenericPublicKey
modifier|*
name|pubkey
decl_stmt|;
name|struct
name|GenericParameters
modifier|*
name|parms
decl_stmt|;
block|{
name|PE
name|pe
decl_stmt|;
name|unsigned
modifier|*
name|mac
decl_stmt|;
name|unsigned
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|GenericHash
modifier|*
name|hash
decl_stmt|,
modifier|*
name|hash2
decl_stmt|;
if|if
condition|(
name|oid_cmp
argument_list|(
name|sig
operator|->
name|alg
operator|.
name|algorithm
argument_list|,
name|name2oid
argument_list|(
name|sig_alg
operator|->
name|sig_name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"check_signature: Cryptographic algorithm not supported"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|enc_f
argument_list|(
name|type
argument_list|,
name|module
argument_list|,
operator|&
name|pe
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|unpack_encrypted
call|)
argument_list|(
name|sig
operator|->
name|encrypted
argument_list|,
operator|&
name|mac
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|hash
operator|=
name|pe2hash
argument_list|(
name|pe
argument_list|,
name|pubkey
argument_list|,
name|parms
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|encrypt
call|)
argument_list|(
name|mac
argument_list|,
operator|&
name|r
argument_list|,
name|pubkey
argument_list|,
name|parms
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|pack_encrypted
call|)
argument_list|(
name|r
argument_list|,
operator|&
name|cp2
argument_list|,
operator|&
name|len
argument_list|,
name|parms
argument_list|)
expr_stmt|;
call|(
name|hash_alg
operator|->
name|hash_unpack
call|)
argument_list|(
name|cp2
operator|+
call|(
name|pk_alg
operator|->
name|get_blocksize
call|)
argument_list|(
name|parms
argument_list|)
operator|/
literal|8
operator|-
call|(
name|hash_alg
operator|->
name|hash_blocksize
call|)
argument_list|(
name|parms
argument_list|)
operator|/
literal|8
argument_list|,
operator|&
name|hash2
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
name|hash_alg
operator|->
name|hash_compare
call|)
argument_list|(
name|hash
argument_list|,
name|hash2
argument_list|)
expr_stmt|;
comment|/* pe_free(pe); */
comment|/* really ought to free this */
call|(
name|hash_alg
operator|->
name|hash_free
call|)
argument_list|(
name|hash
argument_list|)
expr_stmt|;
call|(
name|hash_alg
operator|->
name|hash_free
call|)
argument_list|(
name|hash2
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|free_encrypted
call|)
argument_list|(
name|r
argument_list|,
name|parms
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|free_encrypted
call|)
argument_list|(
name|mac
argument_list|,
name|parms
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
modifier|*
name|compute_signature
parameter_list|(
name|pe
parameter_list|,
name|key
parameter_list|,
name|parms
parameter_list|,
name|mdparms
parameter_list|)
name|PE
name|pe
decl_stmt|;
name|struct
name|GenericSecretKey
modifier|*
name|key
decl_stmt|;
name|struct
name|GenericParameters
modifier|*
name|parms
decl_stmt|;
name|struct
name|GenericParameters
modifier|*
name|mdparms
decl_stmt|;
block|{
name|unsigned
modifier|*
name|r
decl_stmt|;
name|unsigned
modifier|*
name|b
decl_stmt|;
name|struct
name|GenericHash
modifier|*
name|hash
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n_bits
decl_stmt|;
name|char
name|buff
index|[
literal|4096
index|]
decl_stmt|;
name|hash
operator|=
name|pe2hash
argument_list|(
name|pe
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|mdparms
argument_list|)
expr_stmt|;
call|(
name|hash_alg
operator|->
name|hash_pack
call|)
argument_list|(
name|hash
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|n_bits
argument_list|,
name|mdparms
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buff
argument_list|,
call|(
name|pk_alg
operator|->
name|get_blocksize
call|)
argument_list|(
name|parms
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|buff
operator|+
call|(
name|pk_alg
operator|->
name|get_blocksize
call|)
argument_list|(
name|parms
argument_list|)
operator|/
literal|8
operator|-
call|(
name|hash_alg
operator|->
name|hash_blocksize
call|)
argument_list|(
name|mdparms
argument_list|)
operator|/
literal|8
argument_list|,
call|(
name|hash_alg
operator|->
name|hash_blocksize
call|)
argument_list|(
name|mdparms
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|unpack_encrypted
call|)
argument_list|(
name|buff
argument_list|,
operator|&
name|b
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
call|(
name|pk_alg
operator|->
name|decrypt
call|)
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|,
name|key
argument_list|,
name|parms
argument_list|)
expr_stmt|;
comment|/*  (pk_alg->free_encrypted)(b, parms); */
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|GenericHash
modifier|*
name|pe2hash
parameter_list|(
name|pe
parameter_list|,
name|key
parameter_list|,
name|parm
parameter_list|)
name|PE
name|pe
decl_stmt|;
name|struct
name|GenericPublicKey
modifier|*
name|key
decl_stmt|;
name|struct
name|GenericParameters
modifier|*
name|parm
decl_stmt|;
block|{
name|PS
name|stream
decl_stmt|;
name|int
name|blocksize
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|n_blocks
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|struct
name|GenericHash
modifier|*
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|strategy
decl_stmt|;
name|strategy
operator|=
name|ps_len_strategy
expr_stmt|;
name|ps_len_strategy
operator|=
name|PS_LEN_LONG
expr_stmt|;
name|stream
operator|=
name|ps_alloc
argument_list|(
name|str_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_setup
argument_list|(
name|stream
argument_list|,
name|NULLCP
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"str_setup failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|stream
argument_list|,
name|pe
argument_list|)
operator|!=
name|OK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps failed"
argument_list|)
expr_stmt|;
name|blocksize
operator|=
call|(
name|hash_alg
operator|->
name|hash_blocksize
call|)
argument_list|(
name|parm
argument_list|)
operator|/
literal|8
expr_stmt|;
name|length
operator|=
name|stream
operator|->
name|ps_byteno
expr_stmt|;
name|txt
operator|=
name|stream
operator|->
name|ps_base
expr_stmt|;
name|n_blocks
operator|=
name|length
operator|/
name|blocksize
expr_stmt|;
name|extra
operator|=
name|length
operator|%
name|blocksize
expr_stmt|;
name|buff
operator|=
name|calloc
argument_list|(
name|blocksize
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the `initialisation vector' to all zeros */
call|(
name|hash_alg
operator|->
name|hash_start
call|)
argument_list|(
operator|&
name|hash
argument_list|,
name|key
argument_list|,
name|parm
argument_list|)
expr_stmt|;
comment|/* For each complete block ... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_blocks
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blocksize
condition|;
name|j
operator|++
control|)
name|buff
index|[
name|j
index|]
operator|=
name|txt
index|[
name|i
operator|*
name|blocksize
operator|+
name|j
index|]
expr_stmt|;
call|(
name|hash_alg
operator|->
name|hash_block
call|)
argument_list|(
name|hash
argument_list|,
name|buff
argument_list|,
name|key
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
comment|/* Pad the last block */
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|extra
condition|;
name|j
operator|++
control|)
name|buff
index|[
name|j
index|]
operator|=
name|txt
index|[
name|n_blocks
operator|*
name|blocksize
operator|+
name|j
index|]
expr_stmt|;
call|(
name|hash_alg
operator|->
name|hash_short
call|)
argument_list|(
name|hash
argument_list|,
name|buff
argument_list|,
name|extra
argument_list|,
name|key
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
else|else
call|(
name|hash_alg
operator|->
name|hash_short
call|)
argument_list|(
name|hash
argument_list|,
name|buff
argument_list|,
name|extra
argument_list|,
name|key
argument_list|,
name|parm
argument_list|)
expr_stmt|;
call|(
name|hash_alg
operator|->
name|hash_end
call|)
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|ps_free
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|ps_len_strategy
operator|=
name|strategy
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
block|}
end_function

end_unit

