begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tsapd.c - OSI transport listener */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/support/RCS/tsapd.c,v 7.12 91/02/22 09:46:59 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/support/RCS/tsapd.c,v 7.12 91/02/22 09:46:59 mrose Interim $  *  *  * $Log:	tsapd.c,v $  * Revision 7.12  91/02/22  09:46:59  mrose  * Interim 6.8  *   * Revision 7.11  90/12/19  09:16:14  mrose  * touch-up  *   * Revision 7.10  90/12/17  22:13:27  mrose  * -call  *   * Revision 7.9  90/12/11  10:52:29  mrose  * lock-and-load  *   * Revision 7.8  90/11/05  14:10:32  mrose  * oops  *   * Revision 7.7  90/10/30  14:25:32  mrose  * update  *   * Revision 7.6  90/10/29  18:37:25  mrose  * updates  *   * Revision 7.5  90/10/16  11:21:04  mrose  * update  *   * Revision 7.4  90/10/15  22:54:26  mrose  * typo  *   * Revision 7.3  90/10/15  18:18:47  mrose  * iaed  *   * Revision 7.2  90/07/09  14:51:00  mrose  * sync  *   * Revision 7.1  90/02/19  13:09:53  mrose  * update  *   * Revision 7.0  89/11/23  22:27:46  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|X_OK
end_ifndef

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IAE
end_ifdef

begin_include
include|#
directive|include
file|<quipu/util.h>
end_include

begin_include
include|#
directive|include
file|<quipu/bind.h>
end_include

begin_include
include|#
directive|include
file|<quipu/list.h>
end_include

begin_include
include|#
directive|include
file|<quipu/ds_search.h>
end_include

begin_define
define|#
directive|define
name|NOGOSIP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NOGOSIP
end_ifndef

begin_include
include|#
directive|include
file|"rosap.h"
end_include

begin_include
include|#
directive|include
file|"rtsap.h"
end_include

begin_include
include|#
directive|include
file|"psap2.h"
end_include

begin_include
include|#
directive|include
file|"ssap.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tpkt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TP4
end_ifdef

begin_include
include|#
directive|include
file|"tp4.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IAE
end_ifndef

begin_include
include|#
directive|include
file|"isoservent.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nbits
init|=
name|FD_SETSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LLog
name|_pgm_log
init|=
block|{
ifndef|#
directive|ifndef
name|IAE
literal|"tsapd.log"
block|,
else|#
directive|else
literal|"iaed.log"
block|,
endif|#
directive|endif
name|NULLCP
block|,
name|NULLCP
block|,
name|LLOG_FATAL
operator||
name|LLOG_EXCEPTIONS
operator||
name|LLOG_NOTICE
block|,
name|LLOG_FATAL
block|,
operator|-
literal|1
block|,
name|LLOGCLS
operator||
name|LLOGCRT
operator||
name|LLOGZER
block|,
name|NOTOK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LLog
modifier|*
name|pgm_log
init|=
operator|&
name|_pgm_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pgmname
init|=
literal|"tsapd"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|myhost
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcpservice
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|x25service
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bridgeservice
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tp4service
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|services
index|[]
init|=
block|{
operator|&
name|tp4service
block|,
operator|&
name|tcpservice
block|,
operator|&
name|x25service
block|,
operator|&
name|bridgeservice
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NTADDRS
value|FD_SETSIZE
end_define

begin_decl_stmt
specifier|static
name|int
name|listening
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|TSAPaddr
modifier|*
name|tz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|TSAPaddr
name|tas
index|[
name|NTADDRS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IAE
end_ifdef

begin_define
define|#
directive|define
name|IAETIME
value|(24 * 60 * 60L)
end_define

begin_decl_stmt
specifier|static
name|int
name|isbound
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|main_dsa
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|referral_dsa
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|nextime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DN
name|userdn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|passwd
index|[
name|DBA_MAX_PASSWD_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|AttributeType
name|t_ev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|AttributeType
name|t_pa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ds_search_arg
name|search_arg
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|IAEntry
block|{
name|struct
name|TSAPaddr
name|is_addr
decl_stmt|;
name|char
modifier|*
name|is_vector
decl_stmt|;
name|char
modifier|*
modifier|*
name|is_vec
decl_stmt|;
name|char
modifier|*
modifier|*
name|is_tail
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NENTRIES
value|100
end_define

begin_decl_stmt
specifier|static
name|struct
name|IAEntry
modifier|*
name|iz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|IAEntry
name|iae
index|[
name|NENTRIES
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|str2dnY
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|dsa_ad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dsa_dead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|local_dit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|PSAPaddr
name|dsa_bound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|as_print
argument_list|()
decl_stmt|,
name|dn_print
argument_list|()
decl_stmt|,
name|de_print
argument_list|()
decl_stmt|,
name|fi_print
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|adios
argument_list|()
decl_stmt|,
name|advise
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ts_advise
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NOGOSIP
end_ifdef

begin_define
define|#
directive|define
name|ssapd
value|NULLIFP
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|ssapd
argument_list|()
decl_stmt|,
name|psapd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IAE
end_ifdef

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|failed
decl_stmt|,
name|vecp
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|arginit
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|envinit
argument_list|()
expr_stmt|;
name|failed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|tas
init|;
name|ta
operator|<
name|tz
condition|;
name|ta
operator|++
control|)
block|{
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
if|if
condition|(
name|ta
operator|->
name|ta_naddr
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|na
operator|=
name|ta
operator|->
name|ta_addrs
operator|)
operator|->
name|na_stack
operator|<
literal|0
operator|||
name|na
operator|->
name|na_stack
operator|>=
sizeof|sizeof
name|services
operator|/
sizeof|sizeof
name|services
index|[
literal|0
index|]
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown network type 0x%x"
argument_list|,
name|na
operator|->
name|na_stack
argument_list|)
expr_stmt|;
block|}
else|else
name|na
operator|=
name|NULLNA
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|services
index|[
name|na
condition|?
name|na
operator|->
name|na_stack
else|:
name|NA_NSAP
index|]
condition|)
continue|continue;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"listening on %s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TNetListen
argument_list|(
name|ta
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetListen failed"
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
block|}
else|else
name|listening
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|listening
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
name|failed
condition|?
literal|"no successful listens"
else|:
literal|"no network services selected"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|IAE
name|int
name|secs
decl_stmt|;
name|long
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|now
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|secs
operator|=
call|(
name|int
call|)
argument_list|(
name|nextime
operator|-
name|now
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|search_directory
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|secs
operator|=
name|IAETIME
expr_stmt|;
block|}
else|#
directive|else
define|#
directive|define
name|secs
value|NOTOK
endif|#
directive|endif
if|if
condition|(
name|TNetAccept
argument_list|(
operator|&
name|vecp
argument_list|,
name|vec
argument_list|,
literal|0
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|secs
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetAccept failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vecp
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|debug
condition|)
break|break;
switch|switch
condition|(
name|TNetFork
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|td
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
ifdef|#
directive|ifdef
name|IAE
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTOK
case|:
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetFork failed"
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
break|break;
block|}
name|tsapd
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|buffer1
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|buffer2
index|[
literal|32768
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tsapd
parameter_list|(
name|vecp
parameter_list|,
name|vec
parameter_list|)
name|int
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|IAE
specifier|register
name|struct
name|isoservent
modifier|*
name|is
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|IAEntry
modifier|*
name|is
decl_stmt|;
endif|#
directive|endif
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|struct
name|TSAPstart
name|tss
decl_stmt|;
specifier|register
name|struct
name|TSAPstart
modifier|*
name|ts
init|=
operator|&
name|tss
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|IFP
name|hook
decl_stmt|;
comment|/* begin UGLY */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer1
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer2
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* end UGLY */
if|if
condition|(
name|TInit
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|ts
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"T-CONNECT.INDICATION"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* used to print this in ssapd()... */
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"T-CONNECT.INDICATION:<%d, %s, %s, %d, %d>"
argument_list|,
name|ts
operator|->
name|ts_sd
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|ts
operator|->
name|ts_calling
argument_list|)
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|ts
operator|->
name|ts_called
argument_list|)
argument_list|,
name|ts
operator|->
name|ts_expedited
argument_list|,
name|ts
operator|->
name|ts_tsdusize
argument_list|)
expr_stmt|;
name|hook
operator|=
name|ssapd
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_called
operator|.
name|ta_selectlen
condition|)
block|{
ifndef|#
directive|ifndef
name|IAE
if|if
condition|(
operator|(
name|is
operator|=
name|getisoserventbyselector
argument_list|(
literal|"tsap"
argument_list|,
name|ts
operator|->
name|ts_called
operator|.
name|ta_selector
argument_list|,
name|ts
operator|->
name|ts_called
operator|.
name|ta_selectlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
for|for
control|(
name|is
operator|=
name|iae
init|;
name|is
operator|<
name|iz
condition|;
name|is
operator|++
control|)
if|if
condition|(
name|is
operator|->
name|is_addr
operator|.
name|ta_selectlen
operator|==
name|ts
operator|->
name|ts_called
operator|.
name|ta_selectlen
operator|&&
name|bcmp
argument_list|(
name|is
operator|->
name|is_addr
operator|.
name|ta_selector
argument_list|,
name|ts
operator|->
name|ts_called
operator|.
name|ta_selector
argument_list|,
name|is
operator|->
name|is_addr
operator|.
name|ta_selectlen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|is
operator|>=
name|iz
condition|)
block|{
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"OSI service tsap/%s not found"
argument_list|,
name|sel2str
argument_list|(
name|ts
operator|->
name|ts_called
operator|.
name|ta_selector
argument_list|,
name|ts
operator|->
name|ts_called
operator|.
name|ta_selectlen
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
ifndef|#
directive|ifndef
name|IAE
if|if
condition|(
name|hook
operator|==
name|NULLIFP
operator|||
operator|(
name|is
operator|=
name|getisoserventbyname
argument_list|(
literal|"session"
argument_list|,
literal|"tsap"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"default session service not found"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifndef|#
directive|ifndef
name|IAE
operator|*
name|is
operator|->
name|is_tail
operator|++
operator|=
name|buffer1
expr_stmt|;
operator|*
name|is
operator|->
name|is_tail
operator|++
operator|=
name|buffer2
expr_stmt|;
operator|*
name|is
operator|->
name|is_tail
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|is
operator|->
name|is_tail
index|[
literal|0
index|]
operator|=
name|buffer1
expr_stmt|;
name|is
operator|->
name|is_tail
index|[
literal|1
index|]
operator|=
name|buffer2
expr_stmt|;
name|is
operator|->
name|is_tail
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tb
operator|=
name|findtblk
argument_list|(
name|ts
operator|->
name|ts_sd
argument_list|)
condition|)
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
switch|switch
condition|(
name|hook
condition|?
call|(
modifier|*
name|hook
call|)
argument_list|(
name|is
argument_list|,
name|td
argument_list|)
else|:
name|OK
condition|)
block|{
case|case
name|NOTOK
case|:
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"service not started at tsap"
argument_list|)
expr_stmt|;
case|case
name|DONE
case|:
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|OK
case|:
default|default:
operator|(
name|void
operator|)
name|setperms
argument_list|(
name|is
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execv
argument_list|(
operator|*
name|is
operator|->
name|is_vec
argument_list|,
name|is
operator|->
name|is_vec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"unable to exec %s: %s"
argument_list|,
operator|*
name|is
operator|->
name|is_vec
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|SLOG
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_FATAL
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"%s"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|>=
name|TD_SIZE
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|TDiscRequest
argument_list|(
name|ts
operator|->
name|ts_sd
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
specifier|static
name|int
name|setperms
parameter_list|(
name|is
parameter_list|)
ifndef|#
directive|ifndef
name|IAE
specifier|register
name|struct
name|isoservent
modifier|*
name|is
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|IAEntry
modifier|*
name|is
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
operator|*
name|is
operator|->
name|is_vec
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|st
operator|.
name|st_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|st
operator|.
name|st_uid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*
comment|*/
specifier|static
name|void
name|ts_advise
parameter_list|(
name|td
parameter_list|,
name|code
parameter_list|,
name|event
parameter_list|)
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_cc
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%s] %*.*s"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_data
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%s]"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|code
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: %s"
argument_list|,
name|event
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
ifndef|#
directive|ifndef
name|NOGOSIP
specifier|static
name|int
name|ssapd
parameter_list|(
name|is
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|isoservent
modifier|*
name|is
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|sd
decl_stmt|;
name|struct
name|TSAPstart
name|tss
decl_stmt|;
specifier|register
name|struct
name|TSAPstart
modifier|*
name|ts
init|=
operator|&
name|tss
decl_stmt|;
name|struct
name|SSAPindication
name|sis
decl_stmt|;
specifier|register
name|struct
name|SSAPabort
modifier|*
name|sa
init|=
operator|&
name|sis
operator|.
name|si_abort
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_entity
argument_list|,
literal|"session"
argument_list|)
operator|||
name|strcmp
argument_list|(
name|is
operator|->
name|is_provider
argument_list|,
literal|"tsap"
argument_list|)
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|TInit
argument_list|(
name|is
operator|->
name|is_tail
operator|-
name|is
operator|->
name|is_vec
argument_list|,
name|is
operator|->
name|is_vec
argument_list|,
name|ts
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|sd
operator|=
name|ts
operator|->
name|ts_sd
expr_stmt|;
if|if
condition|(
name|TConnResponse
argument_list|(
name|sd
argument_list|,
operator|&
name|ts
operator|->
name|ts_called
argument_list|,
name|ts
operator|->
name|ts_expedited
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|NULLQOS
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|SExec
argument_list|(
name|ts
argument_list|,
operator|&
name|sis
argument_list|,
name|psapd
argument_list|,
name|setperms
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"service not started at ssap: %s"
argument_list|,
name|SErrString
argument_list|(
name|sa
operator|->
name|sa_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_cc
operator|>
literal|0
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"   %*.*s"
argument_list|,
name|sa
operator|->
name|sa_cc
argument_list|,
name|sa
operator|->
name|sa_cc
argument_list|,
name|sa
operator|->
name|sa_data
argument_list|)
expr_stmt|;
name|SAFREE
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
return|return
name|DONE
return|;
block|}
comment|/*
comment|*/
define|#
directive|define
name|RMASK
define|\
value|"\020\01HALFDUPLEX\02DUPLEX\03EXPEDITED\04MINORSYNC\05MAJORSYNC\06RESYNC\ \07ACTIVITY\010NEGOTIATED\011CAPABILITY\012EXCEPTIONS\013TYPEDATA"
specifier|static
name|int
name|psapd
parameter_list|(
name|is
parameter_list|,
name|si
parameter_list|)
specifier|register
name|struct
name|isoservent
modifier|*
name|is
decl_stmt|;
specifier|register
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
name|struct
name|SSAPstart
name|sss
decl_stmt|;
specifier|register
name|struct
name|SSAPstart
modifier|*
name|ss
init|=
operator|&
name|sss
decl_stmt|;
name|struct
name|PSAPindication
name|pis
decl_stmt|;
specifier|register
name|struct
name|PSAPabort
modifier|*
name|pa
init|=
operator|&
name|pis
operator|.
name|pi_abort
decl_stmt|;
name|struct
name|RtSAPindication
name|rtis
decl_stmt|;
specifier|register
name|struct
name|RtSAPabort
modifier|*
name|rta
init|=
operator|&
name|rtis
operator|.
name|rti_abort
decl_stmt|;
name|struct
name|RoSAPindication
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPpreject
modifier|*
name|rop
init|=
operator|&
name|rois
operator|.
name|roi_preject
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_provider
argument_list|,
literal|"ssap"
argument_list|)
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_entity
argument_list|,
literal|"presentation"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|is
operator|->
name|is_entity
argument_list|,
literal|"rts"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|is
operator|->
name|is_entity
argument_list|,
literal|"ros"
argument_list|)
condition|)
return|return
name|OK
return|;
comment|/* begin UGLY */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer1
argument_list|,
operator|*
operator|(
name|is
operator|->
name|is_tail
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer2
argument_list|,
operator|*
operator|(
name|is
operator|->
name|is_tail
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* end UGLY */
if|if
condition|(
name|SInit
argument_list|(
name|is
operator|->
name|is_tail
operator|-
name|is
operator|->
name|is_vec
argument_list|,
name|is
operator|->
name|is_vec
argument_list|,
name|ss
argument_list|,
name|si
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"S-CONNECT.INDICATION:<%d, %s, %s, %s, %s, %ld, %d>"
argument_list|,
name|ss
operator|->
name|ss_sd
argument_list|,
name|sprintref
argument_list|(
operator|&
name|ss
operator|->
name|ss_connect
argument_list|)
argument_list|,
name|saddr2str
argument_list|(
operator|&
name|ss
operator|->
name|ss_calling
argument_list|)
argument_list|,
name|saddr2str
argument_list|(
operator|&
name|ss
operator|->
name|ss_called
argument_list|)
argument_list|,
name|sprintb
argument_list|(
name|ss
operator|->
name|ss_requirements
argument_list|,
name|RMASK
argument_list|)
argument_list|,
name|ss
operator|->
name|ss_isn
argument_list|,
name|ss
operator|->
name|ss_ssdusize
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_entity
argument_list|,
literal|"presentation"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PExec
argument_list|(
name|ss
argument_list|,
operator|&
name|pis
argument_list|,
name|buffer1
argument_list|,
name|buffer2
argument_list|,
name|NULLIFP
argument_list|,
name|setperms
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"service not started at psap: %s"
argument_list|,
name|PErrString
argument_list|(
name|pa
operator|->
name|pa_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|pa_cc
operator|>
literal|0
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"   %*.*s"
argument_list|,
name|pa
operator|->
name|pa_cc
argument_list|,
name|pa
operator|->
name|pa_cc
argument_list|,
name|pa
operator|->
name|pa_data
argument_list|)
expr_stmt|;
block|}
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_entity
argument_list|,
literal|"rts"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|RtExec
argument_list|(
name|ss
argument_list|,
operator|&
name|rtis
argument_list|,
name|buffer1
argument_list|,
name|buffer2
argument_list|,
name|NULLIFP
argument_list|,
name|setperms
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"service not started at rtsap: %s"
argument_list|,
name|RtErrString
argument_list|(
name|rta
operator|->
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rta
operator|->
name|rta_cc
operator|>
literal|0
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"   %*.*s"
argument_list|,
name|rta
operator|->
name|rta_cc
argument_list|,
name|rta
operator|->
name|rta_cc
argument_list|,
name|rta
operator|->
name|rta_data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|RoExec
argument_list|(
name|ss
argument_list|,
operator|&
name|rois
argument_list|,
name|buffer1
argument_list|,
name|buffer2
argument_list|,
name|NULLIFP
argument_list|,
name|setperms
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"service not started at rosap: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rop
operator|->
name|rop_cc
operator|>
literal|0
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"   %*.*s"
argument_list|,
name|rop
operator|->
name|rop_cc
argument_list|,
name|rop
operator|->
name|rop_cc
argument_list|,
name|rop
operator|->
name|rop_data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|DONE
return|;
block|}
endif|#
directive|endif
comment|/*
comment|*/
ifndef|#
directive|ifndef
name|IAE
specifier|static
name|arginit
argument_list|(
argument|vec
argument_list|)
name|char
operator|*
operator|*
name|vec
expr_stmt|;
block|{
name|int
name|rflag
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP
name|int
name|port
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|tcp_na
decl_stmt|;
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|X25
name|struct
name|NSAPaddr
modifier|*
name|x25_na
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE_X25
name|struct
name|NSAPaddr
modifier|*
name|bridge_na
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TP4
specifier|register
name|struct
name|isoservent
modifier|*
name|is
decl_stmt|;
endif|#
directive|endif
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|pgmname
operator|=
name|rindex
argument_list|(
operator|*
name|vec
argument_list|,
literal|'/'
argument_list|)
condition|)
name|pgmname
operator|++
expr_stmt|;
if|if
condition|(
name|pgmname
operator|==
name|NULL
operator|||
operator|*
name|pgmname
operator|==
name|NULL
condition|)
name|pgmname
operator|=
operator|*
name|vec
expr_stmt|;
name|isodetailor
argument_list|(
name|pgmname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myhost
argument_list|,
name|TLocalHostName
argument_list|()
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tas
argument_list|,
sizeof|sizeof
name|tas
argument_list|)
expr_stmt|;
name|tz
operator|=
name|tas
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_TCP
operator|)
condition|)
name|tcpservice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"tsap"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"iso-tsap"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"tcp/tsap: unknown service"
argument_list|)
expr_stmt|;
name|tcp_na
operator|=
name|tz
operator|->
name|ta_addrs
expr_stmt|;
name|tcp_na
operator|->
name|na_stack
operator|=
name|NA_TCP
expr_stmt|;
name|tcp_na
operator|->
name|na_community
operator|=
name|ts_comm_tcp_default
expr_stmt|;
name|tcp_na
operator|->
name|na_domain
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|tcp_na
operator|->
name|na_port
operator|=
name|sp
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|102
argument_list|)
expr_stmt|;
name|tz
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|tz
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|X25
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_X25
operator|)
condition|)
name|x25service
operator|=
literal|0
expr_stmt|;
name|x25_na
operator|=
name|tz
operator|->
name|ta_addrs
expr_stmt|;
name|x25_na
operator|->
name|na_stack
operator|=
name|NA_X25
expr_stmt|;
name|x25_na
operator|->
name|na_community
operator|=
name|ts_comm_x25_default
expr_stmt|;
if|if
condition|(
name|x25_local_dte
operator|&&
operator|*
name|x25_local_dte
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|x25_na
operator|->
name|na_dte
argument_list|,
name|x25_local_dte
argument_list|)
expr_stmt|;
name|x25_na
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|x25_na
operator|->
name|na_dte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x25_local_pid
operator|&&
operator|*
name|x25_local_pid
condition|)
name|x25_na
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
name|x25_local_pid
argument_list|,
operator|-
literal|1
argument_list|,
name|x25_na
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
name|tz
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|tz
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE_X25
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_BRG
operator|)
condition|)
name|bridgeservice
operator|=
literal|0
expr_stmt|;
name|bridge_na
operator|=
name|tz
operator|->
name|ta_addrs
expr_stmt|;
name|bridge_na
operator|->
name|na_stack
operator|=
name|NA_BRG
expr_stmt|;
name|bridge_na
operator|->
name|na_community
operator|=
name|ts_comm_x25_default
expr_stmt|;
if|if
condition|(
name|x25_bridge_listen
operator|&&
operator|*
name|x25_bridge_listen
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bridge_na
operator|->
name|na_dte
argument_list|,
name|x25_bridge_listen
argument_list|)
expr_stmt|;
name|bridge_na
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|bridge_na
operator|->
name|na_dte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x25_bridge_pid
operator|&&
operator|*
name|x25_bridge_pid
condition|)
name|bridge_na
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
name|x25_bridge_pid
argument_list|,
operator|-
literal|1
argument_list|,
name|bridge_na
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
name|tz
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|tz
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TP4
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_TP4
operator|)
condition|)
name|tp4service
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|setisoservent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|is
operator|=
name|getisoservent
argument_list|()
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_provider
argument_list|,
literal|"tsap"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
operator|*
name|is
operator|->
name|is_vec
argument_list|,
literal|"tsapd-bootstrap"
argument_list|)
operator|==
literal|0
operator|||
name|access
argument_list|(
operator|*
name|is
operator|->
name|is_vec
argument_list|,
name|X_OK
argument_list|)
operator|!=
name|NOTOK
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_entity
argument_list|,
literal|"isore"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tz
operator|>=
name|tas
operator|+
name|NTADDRS
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"too many services, starting with %s"
argument_list|,
name|is
operator|->
name|is_entity
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|is
operator|->
name|is_selector
argument_list|,
name|tz
operator|->
name|ta_selector
argument_list|,
name|tz
operator|->
name|ta_selectlen
operator|=
name|is
operator|->
name|is_selectlen
argument_list|)
expr_stmt|;
name|tz
operator|->
name|ta_naddr
operator|=
literal|0
expr_stmt|;
name|tz
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|endisoservent
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|vec
operator|++
init|;
name|ap
operator|=
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|ap
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|ts_stacks
operator|=
name|TS_TCP
expr_stmt|;
name|tcpservice
operator|=
literal|1
expr_stmt|;
name|x25service
operator|=
name|bridgeservice
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|ts_stacks
operator|=
name|TS_X25
expr_stmt|;
name|x25service
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|bridgeservice
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|ts_stacks
operator|=
name|TS_TP4
expr_stmt|;
name|tp4service
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|x25service
operator|=
name|bridgeservice
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
name|ts_stacks
operator|=
name|TS_BRG
expr_stmt|;
name|bridgeservice
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|x25service
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflag
operator|=
literal|1
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|TCP
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
operator|||
operator|(
name|port
operator|=
name|atoi
argument_list|(
name|ap
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -p portno"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
name|tcp_na
operator|->
name|na_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|X25
comment|/* This permits listening on a specific subaddress. */
case|case
literal|'a'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -a x121address"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|x25_na
operator|->
name|na_dte
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|x25_na
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
comment|/* This permits listening on a specific protocol id. 		   In fact, SunLink X.25 lets you listen on a protocol 		   id mask, but let's keep it simple. */
case|case
literal|'i'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -i pid"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
name|x25_na
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
name|ap
argument_list|,
operator|-
literal|1
argument_list|,
name|x25_na
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE_X25
case|case
literal|'A'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -A x121address"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bridge_na
operator|->
name|na_dte
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|bridge_na
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'I'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -I pid"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
name|bridge_na
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
name|ap
argument_list|,
operator|-
literal|1
argument_list|,
name|bridge_na
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s: unknown switch"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [switches]"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rflag
operator|&&
name|getuid
argument_list|()
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|ap
operator|=
name|isodefile
argument_list|(
literal|"isoservices"
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|st
operator|.
name|st_uid
operator|!=
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s not owned by root"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
else|#
directive|else
specifier|static
name|arginit
argument_list|(
argument|vec
argument_list|)
name|char
operator|*
operator|*
name|vec
expr_stmt|;
block|{
name|int
name|argp
decl_stmt|,
name|options
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
name|char
name|base
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
modifier|*
name|argptr
decl_stmt|,
modifier|*
name|args
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|pgmname
operator|=
name|rindex
argument_list|(
operator|*
name|vec
argument_list|,
literal|'/'
argument_list|)
condition|)
name|pgmname
operator|++
expr_stmt|;
if|if
condition|(
name|pgmname
operator|==
name|NULL
operator|||
operator|*
name|pgmname
operator|==
name|NULL
condition|)
name|pgmname
operator|=
operator|*
name|vec
expr_stmt|;
name|isodetailor
argument_list|(
name|pgmname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
name|quipu_syntaxes
argument_list|()
expr_stmt|;
name|argp
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|argp
operator|++
index|]
operator|=
name|pgmname
expr_stmt|;
for|for
control|(
name|argptr
operator|=
name|vec
operator|,
name|argptr
operator|++
init|;
name|ap
operator|=
operator|*
name|argptr
condition|;
name|argptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|ap
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'u'
case|:
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|argptr
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
break|break;
continue|continue;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|argptr
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
break|break;
name|args
index|[
name|argp
operator|++
index|]
operator|=
literal|"-c"
expr_stmt|;
name|args
index|[
name|argp
operator|++
index|]
operator|=
name|ap
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
break|break;
block|}
name|args
index|[
name|argp
index|]
operator|=
name|NULLCP
expr_stmt|;
name|dsap_init
argument_list|(
operator|&
name|argp
argument_list|,
operator|(
name|argptr
operator|=
name|args
operator|,
operator|&
name|argptr
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myhost
argument_list|,
name|TLocalHostName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|base
argument_list|,
name|local_dit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_TCP
operator|)
condition|)
name|tcpservice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_X25
operator|)
condition|)
name|x25service
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_BRG
operator|)
condition|)
name|bridgeservice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_TP4
operator|)
condition|)
name|tp4service
operator|=
literal|0
expr_stmt|;
name|options
operator|=
name|SVC_OPT_PREFERCHAIN
expr_stmt|;
name|userdn
operator|=
name|NULLDN
operator|,
name|passwd
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vec
operator|++
init|;
name|ap
operator|=
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|ap
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
name|ll_dbinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|ts_stacks
operator|=
name|TS_TCP
expr_stmt|;
name|tcpservice
operator|=
literal|1
expr_stmt|;
name|x25service
operator|=
name|bridgeservice
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|ts_stacks
operator|=
name|TS_X25
expr_stmt|;
name|x25service
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|bridgeservice
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|ts_stacks
operator|=
name|TS_TP4
expr_stmt|;
name|tp4service
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|x25service
operator|=
name|bridgeservice
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
name|ts_stacks
operator|=
name|TS_BRG
expr_stmt|;
name|bridgeservice
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|x25service
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
comment|/* ignored... */
continue|continue;
case|case
literal|'D'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -D DIT"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'@'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|base
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|base
argument_list|,
literal|"%s@%s"
argument_list|,
name|local_dit
argument_list|,
name|ap
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'m'
case|:
name|options
operator||=
name|SVC_OPT_DONTUSECOPY
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -c DSA-name-or-address"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -u username"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|userdn
operator|=
name|str2dn
argument_list|(
operator|*
name|ap
operator|!=
literal|'@'
condition|?
name|ap
else|:
name|ap
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid DN for username: %s"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
name|strlen
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -p password"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|passwd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
name|strlen
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s: unknown switch"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [switches]"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
block|}
block|{
name|Attr_Sequence
name|as
decl_stmt|;
name|AttributeType
name|t_oc
decl_stmt|;
name|DN
name|local_dn
decl_stmt|;
specifier|register
name|Filter
name|fi
decl_stmt|;
specifier|register
name|struct
name|ds_search_arg
modifier|*
name|sa
init|=
operator|&
name|search_arg
decl_stmt|;
if|if
condition|(
operator|(
name|t_ev
operator|=
name|str2AttrT
argument_list|(
literal|"execVector"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown attribute type \"%s\""
argument_list|,
literal|"execVector"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t_oc
operator|=
name|str2AttrT
argument_list|(
literal|"objectClass"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown attribute type \"%s\""
argument_list|,
literal|"objectClass"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t_pa
operator|=
name|str2AttrT
argument_list|(
literal|"presentationAddress"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown attribute type \"%s\""
argument_list|,
literal|"presentationAddress"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2dnY
argument_list|(
operator|*
name|base
operator|!=
literal|'@'
condition|?
name|base
else|:
name|base
operator|+
literal|1
argument_list|,
operator|&
name|local_dn
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"DIT subtree invalid: \"%s\""
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|fi
operator|=
name|filter_alloc
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fi
argument_list|,
sizeof|sizeof
expr|*
name|fi
argument_list|)
expr_stmt|;
name|fi
operator|->
name|flt_type
operator|=
name|FILTER_ITEM
expr_stmt|;
name|fi
operator|->
name|FUITEM
operator|.
name|fi_type
operator|=
name|FILTERITEM_EQUALITY
expr_stmt|;
name|fi
operator|->
name|FUITEM
operator|.
name|UNAVA
operator|.
name|ava_type
operator|=
name|AttrT_cpy
argument_list|(
name|t_oc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fi
operator|->
name|FUITEM
operator|.
name|UNAVA
operator|.
name|ava_value
operator|=
name|str2AttrV
argument_list|(
literal|"iSODEApplicationEntity"
argument_list|,
name|fi
operator|->
name|FUITEM
operator|.
name|UNAVA
operator|.
name|ava_type
operator|->
name|oa_syntax
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown attribute value \"%s\" for \"%s\""
argument_list|,
literal|"iSODEApplicationEntity"
argument_list|,
literal|"objectClass"
argument_list|)
expr_stmt|;
name|as
operator|=
name|as_merge
argument_list|(
name|as_comp_new
argument_list|(
name|AttrT_cpy
argument_list|(
name|t_ev
argument_list|)
argument_list|,
name|NULLAV
argument_list|,
name|NULLACL_INFO
argument_list|)
argument_list|,
name|as_comp_new
argument_list|(
name|AttrT_cpy
argument_list|(
name|t_pa
argument_list|)
argument_list|,
name|NULLAV
argument_list|,
name|NULLACL_INFO
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sa
argument_list|,
sizeof|sizeof
expr|*
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sra_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_options
operator|=
name|options
expr_stmt|;
name|sa
operator|->
name|sra_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_timelimit
operator|=
name|SVC_NOTIMELIMIT
expr_stmt|;
name|sa
operator|->
name|sra_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_sizelimit
operator|=
name|SVC_NOSIZELIMIT
expr_stmt|;
name|sa
operator|->
name|sra_baseobject
operator|=
name|local_dn
expr_stmt|;
name|sa
operator|->
name|sra_subset
operator|=
name|SRA_WHOLESUBTREE
expr_stmt|;
name|sa
operator|->
name|sra_filter
operator|=
name|fi
expr_stmt|;
name|sa
operator|->
name|sra_searchaliases
operator|=
name|TRUE
expr_stmt|;
name|sa
operator|->
name|sra_eis
operator|.
name|eis_allattributes
operator|=
name|FALSE
expr_stmt|;
name|sa
operator|->
name|sra_eis
operator|.
name|eis_select
operator|=
name|as
expr_stmt|;
name|sa
operator|->
name|sra_eis
operator|.
name|eis_infotypes
operator|=
name|EIS_ATTRIBUTESANDVALUES
expr_stmt|;
name|search_directory
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*
comment|*/
specifier|static
name|search_directory
argument_list|(
argument|firstime
argument_list|)
name|int
name|firstime
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ds_search_arg
modifier|*
name|sa
init|=
operator|&
name|search_arg
decl_stmt|;
name|struct
name|ds_search_result
name|search_result
decl_stmt|;
specifier|register
name|struct
name|ds_search_result
modifier|*
name|sr
init|=
operator|&
name|search_result
decl_stmt|;
name|struct
name|DSError
name|error
decl_stmt|;
specifier|register
name|struct
name|DSError
modifier|*
name|se
init|=
operator|&
name|error
decl_stmt|;
specifier|register
name|EntryInfo
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|struct
name|IAEntry
modifier|*
name|ia
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|,
modifier|*
name|tb
decl_stmt|,
modifier|*
name|ty
decl_stmt|;
name|struct
name|TSAPaddr
name|tys
index|[
name|NTADDRS
index|]
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"searching directory for iSODEApplicationEntity objects"
argument_list|)
expr_stmt|;
while|while
condition|(
name|rebind_to_directory
argument_list|()
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
operator|!
name|firstime
condition|)
return|return;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"sleeping for 5 minutes..."
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|5
operator|*
literal|60
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
literal|"performing subtree search of"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sra_baseobject
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
literal|"  for"
argument_list|,
name|fi_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sra_filter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds_search
argument_list|(
name|sa
argument_list|,
name|se
argument_list|,
name|sr
argument_list|)
operator|==
name|DS_OK
condition|)
break|break;
if|if
condition|(
name|do_error
argument_list|(
name|se
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
operator|!
name|firstime
condition|)
return|return;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"search failed"
argument_list|)
expr_stmt|;
block|}
name|sa
operator|->
name|sra_baseobject
operator|=
name|se
operator|->
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
expr_stmt|;
block|}
if|if
condition|(
name|sr
operator|->
name|srr_correlated
operator|!=
name|TRUE
condition|)
name|correlate_search_results
argument_list|(
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstime
condition|)
for|for
control|(
name|ia
operator|=
name|iae
init|;
name|ia
operator|<
name|iz
condition|;
name|ia
operator|++
control|)
block|{
name|free
argument_list|(
name|ia
operator|->
name|is_vector
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ia
operator|->
name|is_vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ia
operator|->
name|is_vec
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iae
argument_list|,
sizeof|sizeof
name|iae
argument_list|)
expr_stmt|;
name|iz
operator|=
name|iae
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tys
argument_list|,
sizeof|sizeof
name|tys
argument_list|)
expr_stmt|;
name|ty
operator|=
name|tys
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|sr
operator|->
name|CSR_entries
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|ent_next
control|)
block|{
name|Attr_Sequence
name|eptr
decl_stmt|;
name|AV_Sequence
name|avs
decl_stmt|;
if|if
condition|(
name|iz
operator|>=
name|iae
operator|+
name|NENTRIES
condition|)
block|{
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"too many services, starting with"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
operator|->
name|ent_dn
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
literal|"processing"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
operator|->
name|ent_dn
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
literal|"  attributes"
argument_list|,
name|as_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
operator|->
name|ent_attr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|eptr
operator|=
name|ptr
operator|->
name|ent_attr
init|;
name|eptr
condition|;
name|eptr
operator|=
name|eptr
operator|->
name|attr_link
control|)
block|{
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|eptr
operator|->
name|attr_type
argument_list|,
name|t_pa
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|avs
operator|=
name|eptr
operator|->
name|attr_value
condition|)
block|{
specifier|register
name|struct
name|PSAPaddr
modifier|*
name|pa
init|=
operator|(
expr|struct
name|PSAPaddr
operator|*
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
decl_stmt|;
if|if
condition|(
operator|(
name|ta
operator|=
operator|&
name|pa
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
operator|->
name|ta_selectlen
operator|==
literal|0
operator|||
name|pa
operator|->
name|pa_selectlen
operator|>
literal|0
operator|||
name|pa
operator|->
name|pa_addr
operator|.
name|sa_selectlen
operator|>
literal|0
condition|)
continue|continue;
name|iz
operator|->
name|is_addr
operator|=
operator|*
name|ta
expr_stmt|;
comment|/* struct copy */
block|}
continue|continue;
block|}
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|eptr
operator|->
name|attr_type
argument_list|,
name|t_ev
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|avs
operator|=
name|eptr
operator|->
name|attr_value
condition|)
block|{
name|int
name|vecp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|evec
index|[
name|NVEC
operator|+
name|NSLACK
operator|+
literal|1
index|]
decl_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
expr_stmt|;
if|if
condition|(
operator|(
name|iz
operator|->
name|is_vector
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory allocating iaeVector"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|iz
operator|->
name|is_vector
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vecp
operator|=
name|str2vec
argument_list|(
name|iz
operator|->
name|is_vector
argument_list|,
name|evec
argument_list|)
operator|)
operator|<
literal|1
condition|)
goto|goto
name|losing_iae
goto|;
if|if
condition|(
operator|(
name|iz
operator|->
name|is_vec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|vecp
operator|+
literal|3
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|iz
operator|->
name|is_vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory allocating execVector"
argument_list|)
expr_stmt|;
name|iz
operator|->
name|is_tail
operator|=
name|iz
operator|->
name|is_vec
operator|,
name|vp
operator|=
name|evec
expr_stmt|;
while|while
condition|(
operator|*
name|iz
operator|->
name|is_tail
operator|++
operator|=
operator|*
name|vp
operator|++
condition|)
continue|continue;
name|iz
operator|->
name|is_tail
operator|--
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|cp
operator|=
name|isodefile
argument_list|(
name|iz
operator|->
name|is_vec
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|,
name|X_OK
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|cp
argument_list|,
literal|"unable to find program"
argument_list|)
expr_stmt|;
name|iz
operator|->
name|is_vec
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|losing_iae
goto|;
block|}
if|if
condition|(
operator|(
name|iz
operator|->
name|is_vec
index|[
literal|0
index|]
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory allocating pgmVector"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|iz
operator|->
name|is_vec
index|[
literal|0
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|ta
operator|=
operator|&
name|iz
operator|->
name|is_addr
operator|)
operator|->
name|ta_selectlen
operator|==
literal|0
operator|||
name|iz
operator|->
name|is_vector
operator|==
name|NULL
condition|)
block|{
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"invalid entry"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
operator|->
name|ent_dn
argument_list|)
expr_stmt|;
name|losing_iae
label|:
empty_stmt|;
if|if
condition|(
name|iz
operator|->
name|is_vector
condition|)
name|free
argument_list|(
name|iz
operator|->
name|is_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|iz
operator|->
name|is_vec
condition|)
block|{
if|if
condition|(
name|iz
operator|->
name|is_vec
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|iz
operator|->
name|is_vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iz
operator|->
name|is_vec
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iz
argument_list|,
sizeof|sizeof
expr|*
name|iz
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ta
operator|->
name|ta_naddr
operator|==
literal|0
condition|)
operator|*
name|ty
operator|++
operator|=
operator|*
name|ta
expr_stmt|;
comment|/* struct copy */
else|else
block|{
specifier|register
name|int
name|n
init|=
name|ta
operator|->
name|ta_naddr
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
name|ta
operator|->
name|ta_addrs
decl_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|na
operator|++
operator|,
name|n
operator|--
control|)
block|{
for|for
control|(
name|tb
operator|=
name|tys
init|;
name|tb
operator|<
name|ty
condition|;
name|tb
operator|++
control|)
if|if
condition|(
name|tb
operator|->
name|ta_naddr
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|na
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tb
operator|->
name|ta_addrs
argument_list|,
sizeof|sizeof
expr|*
name|na
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tb
operator|>=
name|ty
condition|)
block|{
if|if
condition|(
name|na
operator|->
name|na_type
operator|==
name|NA_NSAP
condition|)
name|bcopy
argument_list|(
name|ta
operator|->
name|ta_selector
argument_list|,
name|ty
operator|->
name|ta_selector
argument_list|,
name|ty
operator|->
name|ta_selectlen
operator|=
name|ta
operator|->
name|ta_selectlen
argument_list|)
expr_stmt|;
else|else
name|ty
operator|->
name|ta_selectlen
operator|=
literal|0
expr_stmt|;
name|ty
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|ty
operator|->
name|ta_addrs
index|[
literal|0
index|]
operator|=
operator|*
name|na
expr_stmt|;
comment|/* struct copy */
name|ty
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|ia
operator|=
name|iae
init|;
name|ia
operator|<
name|iz
condition|;
name|ia
operator|++
control|)
block|{
name|tb
operator|=
operator|&
name|ia
operator|->
name|is_addr
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|ta_selectlen
operator|==
name|tb
operator|->
name|ta_selectlen
operator|&&
name|bcmp
argument_list|(
name|ta
operator|->
name|ta_selector
argument_list|,
name|tb
operator|->
name|ta_selector
argument_list|,
name|ta
operator|->
name|ta_selectlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|taddr2str
argument_list|(
name|tb
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"two services with the same transport selector: %s and %s"
argument_list|,
name|buffer
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"starting with"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|ptr
operator|->
name|ent_dn
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"you lose big"
argument_list|)
expr_stmt|;
block|}
block|}
name|iz
operator|++
operator|,
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sr
operator|->
name|CSR_cr
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"partial results only (not all DSAs could be reached)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sr
operator|->
name|CSR_limitproblem
operator|!=
name|LSR_NOLIMITPROBLEM
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s limit exceeded"
argument_list|,
name|sr
operator|->
name|CSR_limitproblem
operator|==
name|LSR_TIMELIMITEXCEEDED
condition|?
literal|"time"
else|:
name|sr
operator|->
name|CSR_limitproblem
operator|==
name|LSR_SIZELIMITEXCEEDED
condition|?
literal|"size"
else|:
literal|"administrative"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"search failed to find anything"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"%d match%s found"
argument_list|,
name|i
argument_list|,
name|i
operator|!=
literal|1
condition|?
literal|"es"
else|:
literal|""
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|sr
operator|->
name|CSR_object
argument_list|)
expr_stmt|;
name|entryinfo_free
argument_list|(
name|sr
operator|->
name|CSR_entries
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crefs_free
argument_list|(
name|sr
operator|->
name|CSR_cr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unbind_from_directory
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|firstime
condition|)
block|{
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
for|for
control|(
name|ta
operator|=
name|tas
init|;
name|ta
operator|<
name|tz
condition|;
name|ta
operator|++
control|)
block|{
for|for
control|(
name|tb
operator|=
name|tys
init|;
name|tb
operator|<
name|ty
condition|;
name|tb
operator|++
control|)
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ta
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tb
argument_list|,
sizeof|sizeof
expr|*
name|ta
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tb
operator|>=
name|ty
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"closing %s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TNetClose
argument_list|(
name|ta
argument_list|,
operator|&
name|tds
argument_list|)
operator|==
name|NOTOK
condition|)
name|ts_advise
argument_list|(
operator|&
name|tds
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetClose failed"
argument_list|)
expr_stmt|;
name|listening
operator|--
expr_stmt|;
block|}
block|}
for|for
control|(
name|ta
operator|=
name|tys
init|;
name|ta
operator|<
name|ty
condition|;
name|ta
operator|++
control|)
block|{
for|for
control|(
name|tb
operator|=
name|tas
init|;
name|tb
operator|<
name|tz
condition|;
name|tb
operator|++
control|)
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ta
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tb
argument_list|,
sizeof|sizeof
expr|*
name|ta
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tb
operator|>=
name|tz
condition|)
block|{
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
if|if
condition|(
name|ta
operator|->
name|ta_naddr
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|na
operator|=
name|ta
operator|->
name|ta_addrs
operator|)
operator|->
name|na_stack
operator|<
literal|0
operator|||
name|na
operator|->
name|na_stack
operator|>=
sizeof|sizeof
name|services
operator|/
sizeof|sizeof
name|services
index|[
literal|0
index|]
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown network type 0x%x"
argument_list|,
name|na
operator|->
name|na_stack
argument_list|)
expr_stmt|;
block|}
else|else
name|na
operator|=
name|NULLNA
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|services
index|[
name|na
condition|?
name|na
operator|->
name|na_stack
else|:
name|NA_NSAP
index|]
condition|)
continue|continue;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"listening on %s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TNetListen
argument_list|(
name|ta
argument_list|,
operator|&
name|tds
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
operator|&
name|tds
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetListen failed"
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
block|}
else|else
name|listening
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|listening
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
name|failed
condition|?
literal|"no successful listens"
else|:
literal|"no network services selected"
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tas
argument_list|,
sizeof|sizeof
name|tas
argument_list|)
expr_stmt|;
name|tz
operator|=
name|tas
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|tys
init|;
name|ta
operator|<
name|ty
condition|;
operator|*
name|tz
operator|++
operator|=
operator|*
name|ta
operator|++
control|)
comment|/* struct copy */
continue|continue;
if|if
condition|(
name|debug
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"application entitites..."
argument_list|)
expr_stmt|;
for|for
control|(
name|ia
operator|=
name|iae
init|;
name|ia
operator|<
name|iz
condition|;
name|ia
operator|++
control|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"  addr=%s vector=%s"
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|ia
operator|->
name|is_addr
argument_list|)
argument_list|,
name|ia
operator|->
name|is_vector
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"transport addresses..."
argument_list|)
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|tas
init|;
name|ta
operator|<
name|tz
condition|;
name|ta
operator|++
control|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"  addr=%s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|nextime
argument_list|)
expr_stmt|;
name|nextime
operator|+=
name|IAETIME
expr_stmt|;
block|}
comment|/*
comment|*/
specifier|static
name|bind_to_directory
argument_list|()
block|{     struct
name|ds_bind_arg
name|bind_arg
block|,
name|bind_result
block|;
specifier|register
expr|struct
name|ds_bind_arg
operator|*
name|ba
operator|=
operator|&
name|bind_arg
block|,
operator|*
name|br
operator|=
operator|&
name|bind_result
block|;     struct
name|ds_bind_error
name|bind_error
block|;
specifier|register
expr|struct
name|ds_bind_error
operator|*
name|be
operator|=
operator|&
name|bind_error
block|;
specifier|static
name|int
name|very_first_time
operator|=
literal|1
block|;
operator|(
name|void
operator|)
name|unbind_from_directory
argument_list|()
block|;
name|make_bind_args
argument_list|(
name|ba
argument_list|,
name|br
argument_list|,
name|be
argument_list|)
block|;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"connecting to DSA..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|secure_ds_bind
argument_list|(
name|ba
argument_list|,
name|be
argument_list|,
name|br
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
if|if
condition|(
name|very_first_time
condition|)
name|very_first_time
operator|=
literal|0
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to connect: %s"
argument_list|,
name|be
operator|->
name|dbe_type
operator|==
name|DBE_TYPE_SECURITY
condition|?
literal|"security error"
else|:
literal|"DSA unavailable"
argument_list|)
expr_stmt|;
name|isbound
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|very_first_time
operator|=
literal|0
expr_stmt|;
name|dn_free
argument_list|(
name|br
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
name|main_dsa
operator|=
name|dsap_ad
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"connected to %s"
argument_list|,
name|pa2str
argument_list|(
operator|&
name|dsa_bound
argument_list|)
argument_list|)
expr_stmt|;
name|isbound
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|rebind_to_directory
parameter_list|()
block|{
if|if
condition|(
name|referral_dsa
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"dap_unbind from referral dsa"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dap_unbind
argument_list|(
name|referral_dsa
argument_list|)
expr_stmt|;
name|referral_dsa
operator|=
name|NOTOK
expr_stmt|;
name|dsap_ad
operator|=
name|main_dsa
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isbound
condition|)
operator|(
name|void
operator|)
name|bind_to_directory
argument_list|()
expr_stmt|;
return|return
operator|(
name|isbound
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|make_bind_args
parameter_list|(
name|ba
parameter_list|,
name|br
parameter_list|,
name|be
parameter_list|)
specifier|register
name|struct
name|ds_bind_arg
modifier|*
name|ba
decl_stmt|,
decl|*
name|br
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|struct
name|ds_bind_error
modifier|*
name|be
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ba
argument_list|,
sizeof|sizeof
expr|*
name|ba
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|br
argument_list|,
sizeof|sizeof
expr|*
name|br
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be
argument_list|,
sizeof|sizeof
expr|*
name|be
argument_list|)
expr_stmt|;
name|ba
operator|->
name|dba_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
if|if
condition|(
name|ba
operator|->
name|dba_dn
operator|=
name|userdn
condition|)
name|ba
operator|->
name|dba_auth_type
operator|=
name|DBA_AUTH_SIMPLE
expr_stmt|;
if|if
condition|(
name|ba
operator|->
name|dba_passwd_len
operator|=
name|strlen
argument_list|(
name|passwd
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ba
operator|->
name|dba_passwd
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|unbind_from_directory
parameter_list|()
block|{
name|int
name|wasbound
decl_stmt|;
if|if
condition|(
name|wasbound
operator|=
name|isbound
condition|)
block|{
if|if
condition|(
name|referral_dsa
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"dap_unbind from referral dsa"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dap_unbind
argument_list|(
name|referral_dsa
argument_list|)
expr_stmt|;
name|referral_dsa
operator|=
name|NOTOK
expr_stmt|;
name|dsap_ad
operator|=
name|main_dsa
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ds_unbind
argument_list|()
expr_stmt|;
name|isbound
operator|=
literal|0
expr_stmt|;
block|}
name|dsa_dead
operator|=
literal|0
expr_stmt|;
return|return
name|wasbound
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|do_error
parameter_list|(
name|de
parameter_list|)
specifier|register
name|struct
name|DSError
modifier|*
name|de
decl_stmt|;
block|{
if|if
condition|(
name|de
operator|->
name|dse_type
operator|==
name|DSE_REFERRAL
operator|&&
name|de
operator|->
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
condition|)
block|{
specifier|register
name|struct
name|access_point
modifier|*
name|ap
decl_stmt|;
name|struct
name|ds_bind_arg
name|bind_arg
decl_stmt|,
name|bind_result
decl_stmt|;
specifier|register
name|struct
name|ds_bind_arg
modifier|*
name|ba
init|=
operator|&
name|bind_arg
decl_stmt|,
modifier|*
name|br
init|=
operator|&
name|bind_result
decl_stmt|;
name|struct
name|ds_bind_error
name|bind_error
decl_stmt|;
specifier|register
name|struct
name|ds_bind_error
modifier|*
name|be
init|=
operator|&
name|bind_error
decl_stmt|;
name|ap
operator|=
name|de
operator|->
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_accesspoints
expr_stmt|;
if|if
condition|(
name|referral_dsa
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"dap_unbind from referral dsa"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dap_unbind
argument_list|(
name|referral_dsa
argument_list|)
expr_stmt|;
name|referral_dsa
operator|=
name|NOTOK
expr_stmt|;
name|dsap_ad
operator|=
name|main_dsa
expr_stmt|;
block|}
name|make_bind_args
argument_list|(
name|ba
argument_list|,
name|br
argument_list|,
name|be
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"referring to"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|ap
operator|->
name|ap_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dap_bind
argument_list|(
operator|&
name|referral_dsa
argument_list|,
name|ba
argument_list|,
name|be
argument_list|,
name|br
argument_list|,
name|ap
operator|->
name|ap_address
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to connect: %s"
argument_list|,
name|be
operator|->
name|dbe_type
operator|==
name|DBE_TYPE_SECURITY
condition|?
literal|"security error"
else|:
literal|"DSA unavailable"
argument_list|)
expr_stmt|;
name|dsap_ad
operator|=
name|main_dsa
expr_stmt|;
name|ds_error_free
argument_list|(
name|de
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|dsap_ad
operator|=
name|referral_dsa
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"referral in progress"
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
name|de
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|pslog
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"DAP error:"
argument_list|,
name|de_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsa_dead
condition|)
block|{
name|dsa_dead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|referral_dsa
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"dap_unbind from referral dsa"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dap_unbind
argument_list|(
name|referral_dsa
argument_list|)
expr_stmt|;
name|referral_dsa
operator|=
name|NOTOK
expr_stmt|;
name|dsap_ad
operator|=
name|main_dsa
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|unbind_from_directory
argument_list|()
expr_stmt|;
block|}
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|str2dnY
parameter_list|(
name|str
parameter_list|,
name|dn
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|DN
modifier|*
name|dn
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
block|{
operator|*
name|dn
operator|=
name|NULLDN
expr_stmt|;
return|return
name|OK
return|;
block|}
return|return
operator|(
operator|(
operator|*
name|dn
operator|=
name|str2dn
argument_list|(
name|str
argument_list|)
operator|)
operator|!=
name|NULLDN
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|SFD
name|hupser
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|sig
argument_list|,
name|hupser
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|search_directory
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|envinit
argument_list|()
block|{
name|int
name|i
block|,
name|sd
block|;
name|nbits
operator|=
name|getdtablesize
argument_list|()
block|;
if|if
condition|(
name|debug
operator|==
literal|0
operator|&&
operator|!
operator|(
name|debug
operator|=
name|isatty
argument_list|(
literal|2
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OK
case|:
break|break;
default|default:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
unit|}  	(
name|void
end_expr_stmt

begin_expr_stmt
unit|)
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sd
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|)
operator|,
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SETSID
end_ifdef

begin_if
if|if
condition|(
name|setsid
argument_list|()
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"setsid"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCNOTTY
end_ifdef

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|sd
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}     else
name|ll_dbinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_comment
comment|/* damn YP... */
end_comment

begin_for
for|for
control|(
name|sd
operator|=
literal|3
init|;
name|sd
operator|<
name|nbits
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|pgm_log
operator|->
name|ll_fd
operator|!=
name|sd
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"starting"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IAE
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hupser
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/*
comment|ERRORS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
unit|void
name|adios
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_FATAL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

