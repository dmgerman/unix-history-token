begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tsaplisten.c - "network" listening */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/tsap/RCS/tsaplisten.c,v 7.20 91/03/09 11:58:23 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/tsap/RCS/tsaplisten.c,v 7.20 91/03/09 11:58:23 mrose Exp $  *  * RFC1085 (LPP) support contributed by the Wollongong Group, Inc.  *  *  * $Log:	tsaplisten.c,v $  * Revision 7.20  91/03/09  11:58:23  mrose  * update  *   * Revision 7.19  91/02/22  09:47:29  mrose  * Interim 6.8  *   * Revision 7.18  91/01/24  14:50:52  mrose  * update  *   * Revision 7.17  91/01/07  12:41:30  mrose  * update  *   * Revision 7.16  90/12/17  22:18:03  mrose  * tsel  *   * Revision 7.15  90/10/16  16:24:20  mrose  * foo  *   * Revision 7.14  90/10/16  11:21:27  mrose  * iaed  *   * Revision 7.13  90/07/27  08:48:16  mrose  * update  *   * Revision 7.12  90/07/09  14:51:28  mrose  * sync  *   * Revision 7.11  90/05/08  08:55:45  mrose  * touch-up  *   * Revision 7.10  90/03/23  17:31:37  mrose  * 8  *   * Revision 7.9  90/02/19  13:07:29  mrose  * update  *   * Revision 7.8  89/12/19  22:02:35  mrose  * touch-up  *   * Revision 7.7  89/12/19  16:21:35  mrose  * sync  *   * Revision 7.6  89/12/13  07:05:50  mrose  * touch-up  *   * Revision 7.5  89/12/11  09:35:37  mrose  * again  *   * Revision 7.4  89/12/11  09:20:30  mrose  * update  *   * Revision 7.3  89/12/07  22:15:45  mrose  * touch-up  *   * Revision 7.2  89/12/07  01:07:43  mrose  * queued writes  *   * Revision 7.1  89/11/25  16:31:39  mrose  * sync  *   * Revision 7.0  89/11/23  22:30:46  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"tpkt.h"
end_include

begin_include
include|#
directive|include
file|"mpkt.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LPP
end_ifdef

begin_undef
undef|#
directive|undef
name|X25
end_undef

begin_undef
undef|#
directive|undef
name|BRIDGE_X25
end_undef

begin_undef
undef|#
directive|undef
name|TP4
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LPP
end_ifdef

begin_include
include|#
directive|include
file|"dgram.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TP4
end_ifdef

begin_include
include|#
directive|include
file|"tp4.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LPP
end_ifdef

begin_undef
undef|#
directive|undef
name|MGMT
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|DATA */
end_comment

begin_union
union|union
name|naddr
block|{
ifdef|#
directive|ifdef
name|TCP
name|struct
name|sockaddr_in
name|lb_un_isock
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|X25
argument_list|)
operator|||
name|defined
argument_list|(
name|BRIDGE_X25
argument_list|)
name|struct
name|NSAPaddr
name|lb_un_xsock
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TP4
name|struct
name|TSAPaddr
name|lb_un_tsock
decl_stmt|;
endif|#
directive|endif
name|int
name|lb_dummy
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|listenblk
block|{
name|struct
name|listenblk
modifier|*
name|lb_forw
decl_stmt|;
comment|/* doubly-linked list */
name|struct
name|listenblk
modifier|*
name|lb_back
decl_stmt|;
comment|/*   .. */
name|int
name|lb_fd
decl_stmt|;
comment|/* network handle */
define|#
directive|define
name|LISTEN_EXCEPTED
value|(-2)
comment|/* magic value */
name|int
name|lb_type
decl_stmt|;
comment|/* either listener, or exception handler */
define|#
directive|define
name|LB_UNDEF
value|0
define|#
directive|define
name|LB_LISTEN
value|1
define|#
directive|define
name|LB_ACCEPT
value|2
define|#
directive|define
name|LB_ACCEPTNOW
value|3
define|#
directive|define
name|LB_EXCEPTION
value|4
ifndef|#
directive|ifndef
name|LPP
define|#
directive|define
name|LB_QUEUED
value|5
endif|#
directive|endif
name|IFP
name|lb_magic
decl_stmt|;
name|struct
name|TSAPaddr
name|lb_addr
decl_stmt|;
comment|/* transport address */
name|struct
name|tsapblk
modifier|*
name|lb_tb
decl_stmt|;
name|union
name|naddr
name|lb_un1
decl_stmt|;
define|#
directive|define
name|lb_loc_isock
value|lb_un1.lb_un_isock
define|#
directive|define
name|lb_loc_xsock
value|lb_un1.lb_un_xsock
define|#
directive|define
name|lb_loc_nsock
value|lb_un1.lb_un_nsock
define|#
directive|define
name|lb_loc_tsock
value|lb_un1.lb_un_tsock
name|union
name|naddr
name|lb_un3
decl_stmt|;
define|#
directive|define
name|lb_rem_isock
value|lb_un3.lb_un_isock
define|#
directive|define
name|lb_rem_xsock
value|lb_un3.lb_un_xsock
define|#
directive|define
name|lb_rem_nsock
value|lb_un3.lb_un_nsock
define|#
directive|define
name|lb_rem_tsock
value|lb_un3.lb_un_tsock
union|union
block|{
struct|struct
block|{
name|IFP
name|accept1
decl_stmt|;
comment|/* accept 1 function */
name|IFP
name|accept2
decl_stmt|;
comment|/* accept 2 function */
block|}
name|lb_un_accept
struct|;
name|IFP
name|lb_un_except
decl_stmt|;
comment|/* exception function */
block|}
name|lb_un2
union|;
define|#
directive|define
name|lb_accept1
value|lb_un2.lb_un_accept.accept1
define|#
directive|define
name|lb_accept2
value|lb_un2.lb_un_accept.accept2
define|#
directive|define
name|lb_except
value|lb_un2.lb_un_except
name|IFP
name|lb_close
decl_stmt|;
comment|/* close function */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULLLBP
value|((struct listenblk *) 0)
end_define

begin_decl_stmt
specifier|static
name|int
name|once_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|listenblk
name|listenque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|listenblk
modifier|*
name|LHead
init|=
operator|&
name|listenque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|listenblk
modifier|*
name|findlblk
argument_list|()
decl_stmt|,
modifier|*
name|newlblk
argument_list|()
decl_stmt|,
modifier|*
name|findlblkbyfd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Event block abstraction. An event block is generated by interfaces  * that might need to do things occasionally. Currently this is only  * the bridge but other things should be slot inable.  * The idea is you but a listenblk of the exception type on a fd.  * If the fd `goes off' the listenblk is destroyed and an eventblk  * created which will be called every 60 seconds for blocking listens,  * and before each listen otherwise.  */
end_comment

begin_struct
struct|struct
name|eventblk
block|{
name|struct
name|eventblk
modifier|*
name|ev_forw
decl_stmt|;
comment|/* doubly-linked list */
name|struct
name|eventblk
modifier|*
name|ev_back
decl_stmt|;
comment|/*   .. */
name|struct
name|TSAPaddr
name|ev_taddr
decl_stmt|;
comment|/* associated address */
name|IFP
name|ev_eventfnx
decl_stmt|;
comment|/* the function to call */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULLEVP
value|((struct eventblk *) 0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|eventblk
name|eventqueue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eventblk
modifier|*
name|EHead
init|=
operator|&
name|eventqueue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ev_onceonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ev_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|eventblk
modifier|*
name|neweblk
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|add_fd
parameter_list|(
name|fd
parameter_list|)
define|\
value|{ \     if ((fd)>= acl_nfds) \ 	acl_nfds = (fd) + 1; \     if (acl_count++ == 0) \ 	FD_ZERO (&acl_mask); \     FD_SET (fd,&acl_mask); \ }
end_define

begin_define
define|#
directive|define
name|del_fd
parameter_list|(
name|fd
parameter_list|)
define|\
value|{ \     if ((fd) + 1 == acl_nfds) \ 	acl_nfds--; \     if (--acl_count == 0) \ 	acl_nfds = 0; \     FD_CLR (fd,&acl_mask); \ }
end_define

begin_decl_stmt
specifier|static
name|int
name|acl_nfds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acl_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fd_set
name|acl_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qw_nfds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qw_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fd_set
name|qw_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startlb
argument_list|()
decl_stmt|,
name|uniqlb
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_decl_stmt
name|int
name|tcplisten
argument_list|()
decl_stmt|,
name|tcpaccept1
argument_list|()
decl_stmt|,
name|tcpaccept2
argument_list|()
decl_stmt|,
name|tcpunique
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_decl_stmt
name|int
name|x25listen
argument_list|()
decl_stmt|,
name|x25accept1
argument_list|()
decl_stmt|,
name|x25accept2
argument_list|()
decl_stmt|,
name|x25unique
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE_X25
end_ifdef

begin_decl_stmt
name|int
name|bridgelisten
argument_list|()
decl_stmt|,
name|bridgeaccept1
argument_list|()
decl_stmt|,
name|bridgeaccept2
argument_list|()
decl_stmt|,
name|bridgeunique
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|close_bridge_socket
argument_list|()
decl_stmt|,
name|bridge_except
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TP4
end_ifdef

begin_decl_stmt
name|int
name|tp4listen
argument_list|()
decl_stmt|,
name|tp4accept1
argument_list|()
decl_stmt|,
name|tp4accept2
argument_list|()
decl_stmt|,
name|tp4unique
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
name|nsapent
block|{
name|int
name|ns_type
decl_stmt|;
name|int
name|ns_stack
decl_stmt|;
name|IFP
name|ns_listen
decl_stmt|;
name|IFP
name|ns_accept1
decl_stmt|;
name|IFP
name|ns_accept2
decl_stmt|;
name|IFP
name|ns_unique
decl_stmt|;
name|IFP
name|ns_close
decl_stmt|;
block|}
name|nsaps
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|TCP
name|NA_TCP
block|,
name|TS_TCP
block|,
name|tcplisten
block|,
name|tcpaccept1
block|,
name|tcpaccept2
block|,
name|tcpunique
block|,
name|close_tcp_socket
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|X25
name|NA_X25
block|,
name|TS_X25
block|,
name|x25listen
block|,
name|x25accept1
block|,
name|x25accept2
block|,
name|x25unique
block|,
name|close_x25_socket
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE_X25
name|NA_BRG
block|,
name|TS_BRG
block|,
name|bridgelisten
block|,
name|bridgeaccept1
block|,
name|bridgeaccept2
block|,
name|bridgeunique
block|,
name|close_bridge_socket
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TP4
name|NA_NSAP
block|,
name|TS_TP4
block|,
name|tp4listen
block|,
name|tp4accept1
block|,
name|tp4accept2
block|,
name|tp4unique
block|,
name|close_tp4_socket
block|,
endif|#
directive|endif
name|NULL
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|LPP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|_lpp_fd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|_lpp_lastport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MOBY HACK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|chldhit
decl_stmt|;
end_decl_stmt

begin_function_decl
name|SFD
name|chldser
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|TNetListen
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|TNetWork
argument_list|(
name|ta
argument_list|,
name|td
argument_list|,
name|startlb
argument_list|,
name|NULLIFP
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|TNetListenAux
parameter_list|(
name|ta
parameter_list|,
name|magic
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|IFP
name|magic
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|TNetWork
argument_list|(
name|ta
argument_list|,
name|td
argument_list|,
name|startlb
argument_list|,
name|magic
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|TNetUnique
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|TNetWork
argument_list|(
name|ta
argument_list|,
name|td
argument_list|,
name|uniqlb
argument_list|,
name|NULLIFP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|TNetWork
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|,
name|fnx
parameter_list|,
name|magic
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
name|IFP
name|fnx
decl_stmt|;
name|IFP
name|magic
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|lstn
init|=
name|NOTOK
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
specifier|register
name|struct
name|nsapent
modifier|*
name|ns
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
ifdef|#
directive|ifdef
name|MGMT
name|struct
name|TSAPaddr
name|tas
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|ca
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|ta
operator|->
name|ta_naddr
operator|)
operator|>
name|NTADDR
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"illegal number of network addresses"
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fnx
operator|==
name|startlb
condition|)
block|{
for|for
control|(
name|ns
operator|=
name|nsaps
init|;
name|ns
operator|->
name|ns_listen
condition|;
name|ns
operator|++
control|)
if|if
condition|(
name|ns
operator|->
name|ns_type
operator|==
name|NA_NSAP
operator|&&
operator|(
name|ns
operator|->
name|ns_stack
operator|&
name|ts_stacks
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ns
operator|->
name|ns_listen
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"unsupported network address (%d)"
argument_list|,
name|NA_NSAP
argument_list|)
return|;
name|fd
operator|=
call|(
modifier|*
name|fnx
call|)
argument_list|(
name|ta
argument_list|,
name|NULLNA
argument_list|,
name|ns
argument_list|,
name|magic
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MGMT
if|if
condition|(
name|fd
operator|==
name|OK
condition|)
operator|(
name|void
operator|)
name|TManGen
argument_list|(
name|STARTLISTEN
argument_list|,
name|NULLBP
argument_list|,
name|ta
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fd
return|;
block|}
name|na
operator|=
name|ta
operator|->
name|ta_addrs
expr_stmt|;
for|for
control|(
name|ns
operator|=
name|nsaps
init|;
name|ns
operator|->
name|ns_listen
condition|;
name|ns
operator|++
control|)
if|if
condition|(
name|ns
operator|->
name|ns_stack
operator|&
name|ts_stacks
condition|)
block|{
name|na
operator|->
name|na_stack
operator|=
name|ns
operator|->
name|ns_type
expr_stmt|;
name|na
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|ta
operator|->
name|ta_naddr
operator|=
name|na
operator|-
name|ta
operator|->
name|ta_addrs
operator|)
operator|==
literal|0
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"no transport stacks active!?!"
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|MGMT
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tas
argument_list|,
sizeof|sizeof
name|tas
argument_list|)
expr_stmt|;
if|if
condition|(
name|tas
operator|.
name|ta_selectlen
operator|=
name|ta
operator|->
name|ta_selectlen
condition|)
name|bcopy
argument_list|(
name|ta
operator|->
name|ta_selector
argument_list|,
name|tas
operator|.
name|ta_selector
argument_list|,
name|ta
operator|->
name|ta_selectlen
argument_list|)
expr_stmt|;
name|ca
operator|=
name|tas
operator|.
name|ta_addrs
expr_stmt|;
endif|#
directive|endif
comment|/*      * stricter checking in force, the proposed listen address must      * now be in the communities and not in the tsb communities.      * This allows us to give a list of addresses and let this code      * sort out the useful from the useless.      */
for|for
control|(
name|na
operator|=
name|ta
operator|->
name|ta_addrs
init|;
name|n
operator|--
operator|>
literal|0
condition|;
name|na
operator|++
control|)
block|{
name|int
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|ns
operator|=
name|nsaps
init|;
name|ns
operator|->
name|ns_listen
condition|;
name|ns
operator|++
control|)
if|if
condition|(
name|ns
operator|->
name|ns_type
operator|==
name|na
operator|->
name|na_stack
operator|&&
operator|(
name|ns
operator|->
name|ns_stack
operator|&
name|ts_stacks
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ns
operator|->
name|ns_listen
condition|)
comment|/* not one of our supported stacks */
continue|continue;
for|for
control|(
name|ip
operator|=
name|ts_communities
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|na
operator|->
name|na_subnet
operator|==
operator|*
name|ip
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|ip
condition|)
comment|/* stack ok, community wrong */
continue|continue;
for|for
control|(
name|ip
operator|=
name|tsb_communities
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|na
operator|->
name|na_subnet
operator|==
operator|*
name|ip
condition|)
break|break;
if|if
condition|(
operator|*
name|ip
condition|)
comment|/* only reachable via tsbridge - ignore */
continue|continue;
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|fnx
call|)
argument_list|(
name|ta
argument_list|,
name|na
argument_list|,
name|ns
argument_list|,
name|magic
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|lstn
operator|=
name|OK
expr_stmt|;
ifdef|#
directive|ifdef
name|MGMT
operator|*
name|ca
operator|++
operator|=
operator|*
name|na
expr_stmt|;
comment|/* struct copy */
endif|#
directive|endif
block|}
if|if
condition|(
name|lstn
operator|==
name|OK
condition|)
block|{
ifdef|#
directive|ifdef
name|MGMT
name|tas
operator|.
name|ta_naddr
operator|=
name|ca
operator|-
name|tas
operator|.
name|ta_addrs
expr_stmt|;
operator|(
name|void
operator|)
name|TManGen
argument_list|(
name|STARTLISTEN
argument_list|,
name|NULLBP
argument_list|,
operator|&
name|tas
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"no supported network addresses"
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|TNetClose
argument_list|(
name|ta
argument_list|,
operator|&
name|tds
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|startlb
parameter_list|(
name|ta
parameter_list|,
name|na
parameter_list|,
name|ns
parameter_list|,
name|magic
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
specifier|register
name|struct
name|nsapent
modifier|*
name|ns
decl_stmt|;
name|IFP
name|magic
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|TSAPaddr
name|tas
decl_stmt|;
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tas
argument_list|,
sizeof|sizeof
name|tas
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ta
operator|->
name|ta_selector
argument_list|,
name|tas
operator|.
name|ta_selector
argument_list|,
name|tas
operator|.
name|ta_selectlen
operator|=
name|ta
operator|->
name|ta_selectlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
condition|)
block|{
name|tas
operator|.
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|tas
operator|.
name|ta_addrs
index|[
literal|0
index|]
operator|=
operator|*
name|na
expr_stmt|;
comment|/* struct copy */
block|}
name|ta
operator|=
operator|&
name|tas
expr_stmt|;
if|if
condition|(
name|lb
operator|=
name|findlblk
argument_list|(
name|ta
argument_list|,
name|LB_LISTEN
argument_list|)
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_OPERATION
argument_list|,
name|NULLCP
argument_list|,
literal|"already listening on %s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|lb
operator|=
name|newlblk
argument_list|(
name|LB_LISTEN
argument_list|,
name|ta
argument_list|)
operator|)
operator|==
name|NULLLBP
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
name|lb
operator|->
name|lb_accept1
operator|=
name|ns
operator|->
name|ns_accept1
expr_stmt|;
name|lb
operator|->
name|lb_accept2
operator|=
name|ns
operator|->
name|ns_accept2
expr_stmt|;
name|lb
operator|->
name|lb_close
operator|=
name|ns
operator|->
name|ns_close
expr_stmt|;
name|lb
operator|->
name|lb_magic
operator|=
name|magic
expr_stmt|;
if|if
condition|(
operator|(
name|lb
operator|->
name|lb_fd
operator|=
call|(
modifier|*
name|ns
operator|->
name|ns_listen
call|)
argument_list|(
name|lb
argument_list|,
name|ta
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
elseif|else
if|if
condition|(
name|lb
operator|->
name|lb_fd
operator|==
name|LISTEN_EXCEPTED
condition|)
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
else|else
name|add_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|uniqlb
parameter_list|(
name|ta
parameter_list|,
name|na
parameter_list|,
name|ns
parameter_list|,
name|magic
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
specifier|register
name|struct
name|nsapent
modifier|*
name|ns
decl_stmt|;
name|IFP
name|magic
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|TSAPaddr
name|tas
decl_stmt|;
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tas
argument_list|,
sizeof|sizeof
name|tas
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ta
operator|->
name|ta_selector
argument_list|,
name|tas
operator|.
name|ta_selector
argument_list|,
name|tas
operator|.
name|ta_selectlen
operator|=
name|ta
operator|->
name|ta_selectlen
argument_list|)
expr_stmt|;
name|tas
operator|.
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|tas
operator|.
name|ta_addrs
index|[
literal|0
index|]
operator|=
operator|*
name|na
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|ns
operator|->
name|ns_unique
call|)
argument_list|(
operator|&
name|tas
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|bcopy
argument_list|(
name|tas
operator|.
name|ta_selector
argument_list|,
name|ta
operator|->
name|ta_selector
argument_list|,
name|ta
operator|->
name|ta_selectlen
operator|=
name|tas
operator|.
name|ta_selectlen
argument_list|)
expr_stmt|;
operator|*
name|na
operator|=
name|tas
operator|.
name|ta_addrs
index|[
literal|0
index|]
expr_stmt|;
comment|/* struct copy */
name|ta
operator|=
operator|&
name|tas
expr_stmt|;
if|if
condition|(
operator|(
name|lb
operator|=
name|newlblk
argument_list|(
name|LB_LISTEN
argument_list|,
name|ta
argument_list|)
operator|)
operator|==
name|NULLLBP
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
name|lb
operator|->
name|lb_fd
operator|=
name|fd
expr_stmt|;
name|lb
operator|->
name|lb_magic
operator|=
name|magic
expr_stmt|;
name|lb
operator|->
name|lb_accept1
operator|=
name|ns
operator|->
name|ns_accept1
expr_stmt|;
name|lb
operator|->
name|lb_accept2
operator|=
name|ns
operator|->
name|ns_accept2
expr_stmt|;
name|lb
operator|->
name|lb_close
operator|=
name|ns
operator|->
name|ns_close
expr_stmt|;
name|add_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|TNetAcceptAux
parameter_list|(
name|vecp
parameter_list|,
name|vec
parameter_list|,
name|newfd
parameter_list|,
name|ta
parameter_list|,
name|nfds
parameter_list|,
name|rfds
parameter_list|,
name|wfds
parameter_list|,
name|efds
parameter_list|,
name|secs
parameter_list|,
name|td
parameter_list|)
name|int
modifier|*
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|int
modifier|*
name|newfd
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|int
name|nfds
decl_stmt|;
name|fd_set
modifier|*
name|rfds
decl_stmt|,
decl|*
name|wfds
decl_stmt|,
modifier|*
name|efds
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|secs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|accepted
decl_stmt|,
name|fd
decl_stmt|,
name|fd2
decl_stmt|,
name|n
decl_stmt|,
name|xsecs
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|,
name|ofds
decl_stmt|,
name|xfds
decl_stmt|;
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|,
modifier|*
name|lb2
decl_stmt|;
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|chldser
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|acl_count
operator|==
literal|0
condition|)
name|FD_ZERO
argument_list|(
operator|&
name|acl_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|qw_count
operator|==
literal|0
condition|)
name|FD_ZERO
argument_list|(
operator|&
name|qw_mask
argument_list|)
expr_stmt|;
name|inited
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|vecp
operator|=
literal|0
expr_stmt|;
operator|*
name|vec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ta
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ta
argument_list|,
sizeof|sizeof
expr|*
name|ta
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
condition|)
operator|*
name|newfd
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|acl_count
operator|==
literal|0
operator|&&
name|ev_count
operator|==
literal|0
operator|&&
name|qw_count
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD42
name|retry
label|:
empty_stmt|;
name|chldhit
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|xselect
argument_list|(
name|nfds
argument_list|,
name|rfds
argument_list|,
name|wfds
argument_list|,
name|efds
argument_list|,
name|secs
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD42
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|&&
name|chldhit
condition|)
goto|goto
name|retry
goto|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"xselect"
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
if|if
condition|(
name|acl_nfds
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|acl_nfds
operator|+
literal|1
expr_stmt|;
name|ifds
operator|=
name|acl_mask
expr_stmt|;
if|if
condition|(
name|rfds
condition|)
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
name|rfds
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
name|qw_nfds
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|qw_nfds
operator|+
literal|1
expr_stmt|;
name|ofds
operator|=
name|qw_mask
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
name|wfds
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ofds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|xfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
condition|)
name|xfds
operator|=
operator|*
name|efds
expr_stmt|;
comment|/* struct copy */
for|for
control|(
init|;
condition|;
control|)
block|{
name|xsecs
operator|=
name|secs
expr_stmt|;
if|if
condition|(
name|ev_count
condition|)
block|{
if|if
condition|(
name|secs
operator|==
name|NOTOK
condition|)
name|xsecs
operator|=
literal|60
expr_stmt|;
comment|/* infinite timeout, arrange for periodic */
else|else
name|check_events
argument_list|()
expr_stmt|;
comment|/* single attempt */
block|}
ifdef|#
directive|ifdef
name|BSD42
name|chldhit
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|n
operator|=
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|ifds
argument_list|,
operator|&
name|ofds
argument_list|,
name|efds
argument_list|,
name|xsecs
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
if|if
condition|(
name|secs
operator|==
name|NOTOK
operator|&&
name|ev_count
condition|)
block|{
comment|/* just a timeout */
name|check_events
argument_list|()
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|empty
label|:
empty_stmt|;
if|if
condition|(
name|rfds
condition|)
name|FD_ZERO
argument_list|(
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
name|FD_ZERO
argument_list|(
name|wfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
condition|)
name|FD_ZERO
argument_list|(
name|efds
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
case|case
name|NOTOK
case|:
ifdef|#
directive|ifdef
name|BSD42
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|&&
name|chldhit
condition|)
goto|goto
name|next
goto|;
endif|#
directive|endif
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"xselect"
argument_list|)
return|;
default|default:
name|accepted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lb
operator|=
name|LHead
operator|->
name|lb_forw
init|;
name|lb
operator|!=
name|LHead
condition|;
control|)
block|{
name|lb
operator|=
operator|(
name|lb2
operator|=
name|lb
operator|)
operator|->
name|lb_forw
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|lb2
operator|->
name|lb_fd
operator|)
operator|==
name|NOTOK
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|LPP
if|if
condition|(
name|lb2
operator|->
name|lb_type
operator|==
name|LB_QUEUED
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ofds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|TDoQueues
argument_list|(
name|lb2
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|rfds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
name|rfds
argument_list|)
condition|)
block|{
comment|/* on error, force caller to look at it */
name|FD_ZERO
argument_list|(
name|rfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
name|FD_ZERO
argument_list|(
name|wfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
condition|)
name|FD_ZERO
argument_list|(
name|efds
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|SLOG
argument_list|(
name|tsap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"unable to propagate failure of queued write"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ofds
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
block|{
name|n
operator|--
expr_stmt|;
comment|/* we are using one up */
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lb2
operator|->
name|lb_type
condition|)
block|{
case|case
name|LB_LISTEN
case|:
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
call|(
modifier|*
name|lb2
operator|->
name|lb_accept1
call|)
argument_list|(
name|lb2
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
continue|continue;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|lb2
operator|=
name|findlblkbyfd
argument_list|(
name|fd2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|lb2
operator|->
name|lb_type
operator|!=
name|LB_ACCEPTNOW
condition|)
break|break;
name|fd
operator|=
name|fd2
expr_stmt|;
comment|/* else fall */
case|case
name|LB_ACCEPT
case|:
block|{
comment|/* take care - lb2 is free'd by accept2 */
name|IFP
name|closefnx
init|=
name|lb2
operator|->
name|lb_close
decl_stmt|,
name|magicfnx
init|=
name|lb2
operator|->
name|lb_magic
decl_stmt|;
if|if
condition|(
name|accepted
condition|)
comment|/* only 1 accept at a time */
break|break;
comment|/* we'll get it next time */
if|if
condition|(
name|ta
condition|)
operator|*
name|ta
operator|=
name|lb2
operator|->
name|lb_addr
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
call|(
modifier|*
name|lb2
operator|->
name|lb_accept2
call|)
argument_list|(
name|lb2
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|newfd
condition|)
operator|*
name|newfd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|magicfnx
operator|&&
call|(
modifier|*
name|magicfnx
call|)
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|closefnx
argument_list|)
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|accepted
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|LB_EXCEPTION
case|:
if|if
condition|(
name|exception
argument_list|(
name|lb2
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
break|break;
default|default:
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_UNKNOWN
argument_list|,
name|NULLCP
argument_list|,
literal|"invalid block type"
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|accepted
condition|)
block|{
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
operator|||
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ofds
argument_list|)
operator|||
operator|(
name|efds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
name|efds
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|fd
operator|>=
name|nfds
condition|)
block|{
if|if
condition|(
name|secs
operator|!=
name|NOTOK
condition|)
goto|goto
name|empty
goto|;
goto|goto
name|next
goto|;
block|}
block|}
if|if
condition|(
name|rfds
condition|)
operator|*
name|rfds
operator|=
name|ifds
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|wfds
condition|)
operator|*
name|wfds
operator|=
name|ofds
expr_stmt|;
comment|/* struct copy */
return|return
name|n
return|;
block|}
name|next
label|:
empty_stmt|;
if|if
condition|(
name|acl_nfds
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|acl_nfds
operator|+
literal|1
expr_stmt|;
name|ifds
operator|=
name|acl_mask
expr_stmt|;
if|if
condition|(
name|rfds
condition|)
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
name|rfds
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
name|qw_nfds
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|qw_nfds
operator|+
literal|1
expr_stmt|;
name|ofds
operator|=
name|qw_mask
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
name|wfds
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ofds
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
condition|)
operator|*
name|efds
operator|=
name|xfds
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|exception
parameter_list|(
name|lb
parameter_list|,
name|td
parameter_list|)
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|struct
name|listenblk
modifier|*
name|lb2
decl_stmt|;
specifier|register
name|struct
name|eventblk
modifier|*
name|eb
decl_stmt|;
if|if
condition|(
operator|(
name|lb2
operator|=
name|findlblk
argument_list|(
operator|&
name|lb
operator|->
name|lb_addr
argument_list|,
name|LB_LISTEN
argument_list|)
operator|)
operator|!=
name|NULLLBP
condition|)
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eb
operator|=
name|neweblk
argument_list|(
operator|&
name|lb
operator|->
name|lb_addr
argument_list|)
operator|)
operator|==
name|NULLEVP
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
return|;
name|eb
operator|->
name|ev_eventfnx
operator|=
name|lb
operator|->
name|lb_except
expr_stmt|;
name|SLOG
argument_list|(
name|tsap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"exception on %s"
operator|,
name|taddr2str
argument_list|(
operator|&
name|lb
operator|->
name|lb_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|check_events
argument_list|()
block|{
specifier|register
expr|struct
name|eventblk
operator|*
name|eb
block|,
operator|*
name|ep
block|;     struct
name|TSAPdisconnect
name|tds
block|;
for|for
control|(
name|eb
operator|=
name|EHead
operator|->
name|ev_forw
init|;
name|eb
operator|!=
name|EHead
condition|;
name|eb
operator|=
name|ep
control|)
block|{
name|ep
operator|=
name|eb
operator|->
name|ev_forw
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|eb
operator|->
name|ev_eventfnx
argument_list|)
argument_list|(
name|eb
argument_list|,
operator|&
name|tds
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_expr_stmt
unit|int
name|TNetClose
argument_list|(
name|ta
argument_list|,
name|td
argument_list|)
specifier|register
expr|struct
name|TSAPaddr
operator|*
name|ta
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|ta
operator|==
name|NULLTA
condition|)
block|{
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
return|return
name|OK
return|;
for|for
control|(
name|lb
operator|=
name|LHead
operator|->
name|lb_forw
init|;
name|lb
operator|!=
name|LHead
condition|;
name|lb
operator|=
name|lp
control|)
block|{
name|lp
operator|=
name|lb
operator|->
name|lb_forw
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ta
operator|->
name|ta_naddr
operator|>
literal|1
condition|)
block|{
name|int
name|gotone
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|ta
operator|->
name|ta_naddr
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
name|ta
operator|->
name|ta_addrs
decl_stmt|;
name|struct
name|TSAPaddr
name|tas
decl_stmt|;
name|tas
operator|=
operator|*
name|ta
expr_stmt|;
comment|/* struct copy */
name|tas
operator|.
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|gotone
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|na
operator|=
name|ta
operator|->
name|ta_addrs
operator|,
name|n
operator|=
name|ta
operator|->
name|ta_naddr
init|;
name|n
operator|>
literal|0
condition|;
name|na
operator|++
operator|,
name|n
operator|--
control|)
block|{
name|tas
operator|.
name|ta_addrs
index|[
literal|0
index|]
operator|=
operator|*
name|na
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|lb
operator|=
name|findlblk
argument_list|(
operator|&
name|tas
argument_list|,
name|LB_LISTEN
argument_list|)
condition|)
block|{
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|gotone
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gotone
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"no such transport addressess"
argument_list|)
return|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|(
name|lb
operator|=
name|findlblk
argument_list|(
name|ta
argument_list|,
name|LB_LISTEN
argument_list|)
operator|)
operator|==
name|NULLLBP
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"no such transport addressess"
argument_list|)
return|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SFD
name|chldser
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|sc
parameter_list|)
name|int
name|sig
decl_stmt|;
name|long
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|{
name|union
name|wait
name|status
decl_stmt|;
while|while
condition|(
name|wait3
argument_list|(
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
operator|>
literal|0
condition|)
name|chldhit
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LPP
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|TNetFork
parameter_list|(
name|vecp
parameter_list|,
name|vec
parameter_list|,
name|td
parameter_list|)
name|int
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|int
name|sd
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|OK
case|:
break|break;
case|case
name|NOTOK
case|:
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"connection"
argument_list|,
literal|"unable to fork, so rejecting"
argument_list|)
expr_stmt|;
default|default:
ifndef|#
directive|ifndef
name|LPP
block|{
name|struct
name|TSAPstart
name|tss
decl_stmt|;
specifier|register
name|struct
name|TSAPstart
modifier|*
name|ts
init|=
operator|&
name|tss
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
if|if
condition|(
name|TInit
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|ts
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|SLOG
argument_list|(
name|tsap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"TNetFork: TInit returns [%s]"
operator|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
if|if
condition|(
operator|(
name|tb
operator|=
name|findtblk
argument_list|(
name|ts
operator|->
name|ts_sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SLOG
argument_list|(
name|tsap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"TNetFork: findtblk fails"
operator|)
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
call|(
name|void
call|)
argument_list|(
operator|*
name|tb
operator|->
name|tb_closefnx
argument_list|)
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|_lpp_fd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|_lpp_fd
argument_list|)
expr_stmt|;
name|_lpp_fd
operator|=
name|NOTOK
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|pid
return|;
block|}
operator|(
name|void
operator|)
name|TNetClose
argument_list|(
name|NULLTA
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETSID
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCNOTTY
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|sd
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|SYS5
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|isodexport
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|TCP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_function
specifier|static
name|int
name|tcplisten
parameter_list|(
name|lb
parameter_list|,
name|ta
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|lb
operator|->
name|lb_loc_isock
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
if|if
condition|(
name|ta
operator|->
name|ta_naddr
operator|<
literal|1
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_ADDRESS
argument_list|,
name|NULLCP
argument_list|,
literal|"TCP address not specified"
argument_list|)
return|;
name|na
operator|=
name|ta
operator|->
name|ta_addrs
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_domain
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|na
operator|->
name|na_domain
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_ADDRESS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: unknown host"
argument_list|,
name|na
operator|->
name|na_domain
argument_list|)
return|;
block|}
else|else
name|hp
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isock
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
expr_stmt|;
name|isock
operator|->
name|sin_family
operator|=
name|hp
condition|?
name|hp
operator|->
name|h_addrtype
else|:
name|AF_INET
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_port
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"tsap"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"iso-tsap"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
name|isock
operator|->
name|sin_port
operator|=
name|sp
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|102
argument_list|)
expr_stmt|;
block|}
else|else
name|isock
operator|->
name|sin_port
operator|=
name|na
operator|->
name|na_port
expr_stmt|;
if|if
condition|(
name|hp
condition|)
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|isock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|na
operator|->
name|na_tset
condition|)
block|{
ifdef|#
directive|ifdef
name|LPP
case|case
name|NA_TSET_UDP
case|:
if|if
condition|(
operator|(
name|fd
operator|=
name|start_udp_server
argument_list|(
name|isock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"start_udp_server"
argument_list|)
return|;
break|break;
endif|#
directive|endif
case|case
name|NA_TSET_TCP
case|:
default|default:
if|if
condition|(
operator|(
name|fd
operator|=
name|start_tcp_server
argument_list|(
name|isock
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"start_tcp_server"
argument_list|)
return|;
break|break;
block|}
name|lb
operator|->
name|lb_addr
operator|.
name|ta_addrs
operator|->
name|na_tset
operator|=
name|na
operator|->
name|na_tset
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LPP
end_ifdef

begin_function_decl
name|char
modifier|*
name|udpsave
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|tcpaccept1
parameter_list|(
name|lb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|tset
init|=
name|lb
operator|->
name|lb_addr
operator|.
name|ta_addrs
operator|->
name|na_tset
decl_stmt|;
name|struct
name|listenblk
modifier|*
name|lb2
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|LPP
specifier|register
name|struct
name|tsapkt
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|lb2
operator|=
name|newlblk
argument_list|(
name|LB_ACCEPT
argument_list|,
name|NULLTA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|tset
condition|)
block|{
ifdef|#
directive|ifdef
name|LPP
case|case
name|NA_TSET_UDP
case|:
if|if
condition|(
operator|(
name|fd
operator|=
name|join_udp_client
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|lb2
operator|->
name|lb_rem_isock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_NETWORK
argument_list|,
literal|"failed"
argument_list|,
literal|"join_udp_client"
argument_list|)
return|;
block|}
break|break;
endif|#
directive|endif
case|case
name|NA_TSET_TCP
case|:
default|default:
if|if
condition|(
operator|(
name|fd
operator|=
name|join_tcp_client
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|lb2
operator|->
name|lb_rem_isock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_NETWORK
argument_list|,
literal|"failed"
argument_list|,
literal|"join_tcp_client"
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|LPP
name|_lpp_fd
operator|=
name|fd
expr_stmt|;
name|_lpp_lastport
operator|=
name|lb
operator|->
name|lb_loc_isock
operator|.
name|sin_port
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXOS
name|del_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lb
operator|->
name|lb_fd
operator|=
name|start_tcp_server
argument_list|(
operator|&
name|lb
operator|->
name|lb_loc_isock
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
name|add_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
name|lb2
operator|->
name|lb_fd
operator|=
name|fd
expr_stmt|;
name|lb2
operator|->
name|lb_addr
operator|=
name|lb
operator|->
name|lb_addr
expr_stmt|;
name|lb2
operator|->
name|lb_loc_isock
operator|=
name|lb
operator|->
name|lb_loc_isock
expr_stmt|;
name|lb2
operator|->
name|lb_accept2
operator|=
name|lb
operator|->
name|lb_accept2
expr_stmt|;
name|lb2
operator|->
name|lb_close
operator|=
name|lb
operator|->
name|lb_close
expr_stmt|;
name|lb2
operator|->
name|lb_magic
operator|=
name|lb
operator|->
name|lb_magic
expr_stmt|;
ifndef|#
directive|ifndef
name|LPP
if|if
condition|(
operator|(
name|tb
operator|=
name|newtblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tb
operator|->
name|tb_fd
operator|=
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|TTService
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|add_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|lb2
operator|->
name|lb_type
operator|=
name|LB_ACCEPTNOW
expr_stmt|;
endif|#
directive|endif
name|lb2
operator|->
name|lb_tb
operator|=
name|tb
expr_stmt|;
return|return
name|fd
return|;
name|out
label|:
empty_stmt|;
ifndef|#
directive|ifndef
name|LPP
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lb2
condition|)
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tcpaccept2
parameter_list|(
name|lb
parameter_list|,
name|vecp
parameter_list|,
name|vec
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|int
modifier|*
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|LPP
name|int
name|tset
init|=
name|lb
operator|->
name|lb_addr
operator|.
name|ta_addrs
operator|->
name|na_tset
decl_stmt|;
endif|#
directive|endif
name|char
name|buffer1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buffer2
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SOCKETS
name|struct
name|sockaddr_in
name|in_socket
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
name|int
name|len
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LPP
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
init|=
name|lb
operator|->
name|lb_tb
decl_stmt|;
specifier|register
name|struct
name|tsapkt
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|lb
operator|->
name|lb_fd
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer1
argument_list|,
literal|"%s+%d"
argument_list|,
name|inet_ntoa
argument_list|(
name|lb
operator|->
name|lb_rem_isock
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|lb
operator|->
name|lb_rem_isock
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOCKETS
name|len
operator|=
sizeof|sizeof
expr|*
name|isock
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|isock
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer2
argument_list|,
literal|"%s+%d"
argument_list|,
name|inet_ntoa
argument_list|(
name|isock
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|isock
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer2
argument_list|,
literal|"%s"
argument_list|,
name|TLocalHostName
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LPP
if|if
condition|(
operator|(
name|t
operator|=
name|fd2tpkt
argument_list|(
name|fd
argument_list|,
name|tb
operator|->
name|tb_initfnx
argument_list|,
name|tb
operator|->
name|tb_readfnx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|t
operator|->
name|t_errno
operator|!=
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|t
condition|?
name|t
operator|->
name|t_errno
else|:
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|TPDU_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TPDU_CR
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"transport protocol mangled: expecting 0x%x, got 0x%x"
argument_list|,
name|TPDU_CR
argument_list|,
name|TPDU_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
operator|>
literal|0
operator|&&
operator|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
operator|!=
name|t
operator|->
name|t_calledlen
operator|||
name|bcmp
argument_list|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selector
argument_list|,
name|t
operator|->
name|t_called
argument_list|,
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_SESSION
argument_list|,
name|NULLCP
argument_list|,
literal|"not expecting connection for tsap/%s"
argument_list|,
name|sel2str
argument_list|(
name|t
operator|->
name|t_called
argument_list|,
name|t
operator|->
name|t_calledlen
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
literal|"tsaplisten"
expr_stmt|;
comment|/* any value will do */
if|if
condition|(
operator|(
name|vec
index|[
literal|1
index|]
operator|=
name|tcpsave
argument_list|(
name|fd
argument_list|,
name|buffer1
argument_list|,
name|buffer2
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|vec
index|[
literal|2
index|]
operator|=
name|tpkt2str
argument_list|(
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vec
index|[
operator|*
name|vecp
operator|=
literal|3
index|]
operator|=
name|NULLCP
expr_stmt|;
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|del_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|vec
index|[
literal|0
index|]
operator|=
literal|"psaplisten"
expr_stmt|;
switch|switch
condition|(
name|tset
condition|)
block|{
case|case
name|NA_TSET_UDP
case|:
if|if
condition|(
operator|(
name|vec
index|[
literal|1
index|]
operator|=
name|udpsave
argument_list|(
name|fd
argument_list|,
name|buffer1
argument_list|,
name|buffer2
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|NA_TSET_TCP
case|:
default|default:
if|if
condition|(
operator|(
name|vec
index|[
literal|1
index|]
operator|=
name|tcpsave
argument_list|(
name|fd
argument_list|,
name|buffer1
argument_list|,
name|buffer2
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
name|vec
index|[
operator|*
name|vecp
operator|=
literal|2
index|]
operator|=
name|NULLCP
expr_stmt|;
endif|#
directive|endif
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|out
label|:
empty_stmt|;
ifndef|#
directive|ifndef
name|LPP
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lb
condition|)
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tcpunique
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|sockaddr_in
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
name|ta
operator|->
name|ta_addrs
decl_stmt|;
name|cp
operator|=
name|na
operator|->
name|na_domain
index|[
literal|0
index|]
condition|?
name|na
operator|->
name|na_domain
else|:
name|TLocalHostName
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_ADDRESS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: unknown host"
argument_list|,
name|cp
argument_list|)
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isock
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
expr_stmt|;
name|isock
operator|->
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|isock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|na
operator|->
name|na_tset
condition|)
block|{
ifdef|#
directive|ifdef
name|LPP
case|case
name|NA_TSET_UDP
case|:
if|if
condition|(
operator|(
name|fd
operator|=
name|start_udp_server
argument_list|(
name|isock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"start_udp_server"
argument_list|)
return|;
break|break;
endif|#
directive|endif
case|case
name|NA_TSET_TCP
case|:
default|default:
if|if
condition|(
operator|(
name|fd
operator|=
name|start_tcp_server
argument_list|(
name|isock
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"start_tcp_server"
argument_list|)
return|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|na
operator|->
name|na_domain
argument_list|,
name|inet_ntoa
argument_list|(
name|isock
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_port
operator|=
name|isock
operator|->
name|sin_port
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|X.25 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|x25listen
parameter_list|(
name|lb
parameter_list|,
name|ta
parameter_list|,
name|td
parameter_list|)
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|ta
operator|->
name|ta_naddr
operator|<
literal|1
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_ADDRESS
argument_list|,
name|NULLCP
argument_list|,
literal|"X.121 DTE not specified"
argument_list|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|start_x25_server
argument_list|(
name|ta
operator|->
name|ta_addrs
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
name|SO_KEEPALIVE
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"start_x25_server"
argument_list|)
return|;
name|lb
operator|->
name|lb_loc_xsock
operator|=
operator|*
name|ta
operator|->
name|ta_addrs
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|x25accept1
parameter_list|(
name|lb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|struct
name|listenblk
modifier|*
name|lb2
decl_stmt|;
if|if
condition|(
operator|(
name|lb2
operator|=
name|newlblk
argument_list|(
name|LB_ACCEPT
argument_list|,
name|NULLTA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lb2
operator|->
name|lb_accept2
operator|=
name|lb
operator|->
name|lb_accept2
expr_stmt|;
name|lb2
operator|->
name|lb_addr
operator|=
name|lb
operator|->
name|lb_addr
expr_stmt|;
name|lb2
operator|->
name|lb_close
operator|=
name|lb
operator|->
name|lb_close
expr_stmt|;
name|lb2
operator|->
name|lb_loc_xsock
operator|=
name|lb
operator|->
name|lb_loc_xsock
expr_stmt|;
name|lb2
operator|->
name|lb_magic
operator|=
name|lb
operator|->
name|lb_magic
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_x25_client
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|lb2
operator|->
name|lb_rem_xsock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_NETWORK
argument_list|,
literal|"failed"
argument_list|,
literal|"join_x25_client"
argument_list|)
return|;
block|}
name|lb2
operator|->
name|lb_fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|=
name|newtblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tb
operator|->
name|tb_fd
operator|=
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|XTService
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|lb2
operator|->
name|lb_tb
operator|=
name|tb
expr_stmt|;
name|add_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lb2
condition|)
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|x25accept2
parameter_list|(
name|lb
parameter_list|,
name|vecp
parameter_list|,
name|vec
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|int
modifier|*
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
init|=
name|lb
operator|->
name|lb_tb
decl_stmt|;
specifier|register
name|struct
name|tsapkt
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|fd2tpkt
argument_list|(
name|fd
operator|=
name|tb
operator|->
name|tb_fd
argument_list|,
name|tb
operator|->
name|tb_initfnx
argument_list|,
name|tb
operator|->
name|tb_readfnx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|t
operator|->
name|t_errno
operator|!=
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|t
condition|?
name|t
operator|->
name|t_errno
else|:
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|TPDU_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TPDU_CR
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"transport protocol mangled: expecting 0x%x, got 0x%x"
argument_list|,
name|TPDU_CR
argument_list|,
name|TPDU_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
operator|>
literal|0
operator|&&
operator|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
operator|!=
name|t
operator|->
name|t_calledlen
operator|||
name|bcmp
argument_list|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selector
argument_list|,
name|t
operator|->
name|t_called
argument_list|,
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_SESSION
argument_list|,
name|NULLCP
argument_list|,
literal|"not expecting connection for tsap/%s"
argument_list|,
name|sel2str
argument_list|(
name|t
operator|->
name|t_called
argument_list|,
name|t
operator|->
name|t_calledlen
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
literal|"tsaplisten"
expr_stmt|;
comment|/* any value will do */
if|if
condition|(
operator|(
name|vec
index|[
literal|1
index|]
operator|=
name|x25save
argument_list|(
name|fd
argument_list|,
name|lb
operator|->
name|lb_rem_xsock
operator|.
name|na_dte
argument_list|,
name|lb
operator|->
name|lb_rem_xsock
operator|.
name|na_dtelen
argument_list|,
name|lb
operator|->
name|lb_loc_xsock
operator|.
name|na_dte
argument_list|,
name|lb
operator|->
name|lb_loc_xsock
operator|.
name|na_dtelen
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|vec
index|[
literal|2
index|]
operator|=
name|tpkt2str
argument_list|(
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vec
index|[
operator|*
name|vecp
operator|=
literal|3
index|]
operator|=
name|NULLCP
expr_stmt|;
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
name|del_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|x25unique
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|)
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
name|ta
operator|->
name|ta_addrs
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|na
argument_list|,
sizeof|sizeof
expr|*
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_stack
operator|=
name|NA_X25
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|start_x25_server
argument_list|(
name|na
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
name|SO_KEEPALIVE
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"start_x25_server"
argument_list|)
return|;
return|return
name|fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE_X25
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|bridgelisten
parameter_list|(
name|lb
parameter_list|,
name|ta
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|eventblk
modifier|*
name|eb
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|bridgelisten_aux
argument_list|(
name|lb
argument_list|,
name|ta
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
return|return
name|fd
return|;
if|if
condition|(
operator|(
name|eb
operator|=
name|neweblk
argument_list|(
name|ta
argument_list|)
operator|)
operator|==
name|NULLEVP
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
return|;
name|eb
operator|->
name|ev_eventfnx
operator|=
name|bridge_except
expr_stmt|;
return|return
name|LISTEN_EXCEPTED
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_except
parameter_list|(
name|eb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|eventblk
modifier|*
name|eb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
init|=
operator|&
name|eb
operator|->
name|ev_taddr
decl_stmt|;
if|if
condition|(
operator|(
name|lb
operator|=
name|newlblk
argument_list|(
name|LB_LISTEN
argument_list|,
name|ta
argument_list|)
operator|)
operator|==
name|NULLLBP
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
return|;
if|if
condition|(
operator|(
name|lb
operator|->
name|lb_fd
operator|=
name|bridgelisten_aux
argument_list|(
name|lb
argument_list|,
name|ta
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|SLOG
argument_list|(
name|tsap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"reconnection on %s"
operator|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|freeeblk
argument_list|(
name|eb
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_close
operator|=
name|close_bridge_socket
expr_stmt|;
name|lb
operator|->
name|lb_accept1
operator|=
name|bridgeaccept1
expr_stmt|;
name|lb
operator|->
name|lb_accept2
operator|=
name|bridgeaccept2
expr_stmt|;
name|add_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridgelisten_aux
parameter_list|(
name|lb
parameter_list|,
name|ta
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|listenblk
modifier|*
name|lb2
decl_stmt|;
if|if
condition|(
name|ta
operator|->
name|ta_naddr
operator|<
literal|1
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_ADDRESS
argument_list|,
name|NULLCP
argument_list|,
literal|"X.121 DTE not specified"
argument_list|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|start_bridge_server
argument_list|(
name|ta
operator|->
name|ta_addrs
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
name|SO_KEEPALIVE
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"start_bridge_server"
argument_list|)
return|;
name|lb
operator|->
name|lb_loc_xsock
operator|=
operator|*
name|ta
operator|->
name|ta_addrs
expr_stmt|;
if|if
condition|(
operator|(
name|lb2
operator|=
name|newlblk
argument_list|(
name|LB_EXCEPTION
argument_list|,
name|ta
argument_list|)
operator|)
operator|==
name|NULLLBP
condition|)
block|{
name|close_bridge_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|lb2
operator|->
name|lb_fd
operator|=
name|get_bridge_assfd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|lb2
operator|->
name|lb_except
operator|=
name|bridge_except
expr_stmt|;
name|lb2
operator|->
name|lb_close
operator|=
name|close_bridge_socket
expr_stmt|;
name|add_fd
argument_list|(
name|lb2
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|bridgeaccept1
parameter_list|(
name|lb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
specifier|register
name|struct
name|tsapkt
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
name|struct
name|listenblk
modifier|*
name|lb2
decl_stmt|;
if|if
condition|(
operator|(
name|lb2
operator|=
name|newlblk
argument_list|(
name|LB_ACCEPT
argument_list|,
name|NULLTA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lb2
operator|->
name|lb_accept2
operator|=
name|lb
operator|->
name|lb_accept2
expr_stmt|;
name|lb2
operator|->
name|lb_addr
operator|=
name|lb
operator|->
name|lb_addr
expr_stmt|;
name|lb2
operator|->
name|lb_close
operator|=
name|lb
operator|->
name|lb_close
expr_stmt|;
name|lb2
operator|->
name|lb_loc_xsock
operator|=
name|lb
operator|->
name|lb_loc_xsock
expr_stmt|;
name|lb2
operator|->
name|lb_magic
operator|=
name|lb
operator|->
name|lb_magic
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_bridge_client
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|lb2
operator|->
name|lb_rem_xsock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_NETWORK
argument_list|,
literal|"failed"
argument_list|,
literal|"join_bridge_client"
argument_list|)
return|;
block|}
name|lb2
operator|->
name|lb_fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|=
name|newtblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lb2
operator|->
name|lb_tb
operator|=
name|tb
expr_stmt|;
name|tb
operator|->
name|tb_fd
operator|=
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|BTService
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|add_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lb2
condition|)
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|bridgeaccept2
parameter_list|(
name|lb
parameter_list|,
name|vecp
parameter_list|,
name|vec
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|int
modifier|*
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
init|=
name|lb
operator|->
name|lb_fd
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
init|=
name|lb
operator|->
name|lb_tb
decl_stmt|;
specifier|register
name|struct
name|tsapkt
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|fd2tpkt
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|tb
operator|->
name|tb_initfnx
argument_list|,
name|tb
operator|->
name|tb_readfnx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|t
operator|->
name|t_errno
operator|!=
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|t
condition|?
name|t
operator|->
name|t_errno
else|:
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|TPDU_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TPDU_CR
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"transport protocol mangled: expecting 0x%x, got 0x%x"
argument_list|,
name|TPDU_CR
argument_list|,
name|TPDU_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
operator|>
literal|0
operator|&&
operator|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
operator|!=
name|t
operator|->
name|t_calledlen
operator|||
name|bcmp
argument_list|(
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selector
argument_list|,
name|t
operator|->
name|t_called
argument_list|,
name|lb
operator|->
name|lb_addr
operator|.
name|ta_selectlen
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_SESSION
argument_list|,
name|NULLCP
argument_list|,
literal|"not expecting connection for tsap/%s"
argument_list|,
name|sel2str
argument_list|(
name|t
operator|->
name|t_called
argument_list|,
name|t
operator|->
name|t_calledlen
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
literal|"tsaplisten"
expr_stmt|;
comment|/* any value will do */
if|if
condition|(
operator|(
name|vec
index|[
literal|1
index|]
operator|=
name|bridgesave
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|lb
operator|->
name|lb_rem_xsock
operator|.
name|na_dte
argument_list|,
name|lb
operator|->
name|lb_rem_xsock
operator|.
name|na_dtelen
argument_list|,
name|lb
operator|->
name|lb_loc_xsock
operator|.
name|na_dte
argument_list|,
name|lb
operator|->
name|lb_loc_xsock
operator|.
name|na_dtelen
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|vec
index|[
literal|2
index|]
operator|=
name|tpkt2str
argument_list|(
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vec
index|[
operator|*
name|vecp
operator|=
literal|3
index|]
operator|=
name|NULLCP
expr_stmt|;
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|del_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|bridgeunique
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|)
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_ADDRESS
argument_list|,
name|NULLCP
argument_list|,
literal|"unique listens not supported at the X.25 bridge"
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|TP4 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TP4
end_ifdef

begin_comment
comment|/*
comment|TP4 from 4.4BSD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_TP4
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|tp4listen
parameter_list|(
name|lb
parameter_list|,
name|ta
parameter_list|,
name|td
parameter_list|)
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|start_tp4_server
argument_list|(
name|ta
argument_list|,
name|SOMAXCONN
argument_list|,
name|SO_KEEPALIVE
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tp4accept1
parameter_list|(
name|lb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|struct
name|listenblk
modifier|*
name|lb2
decl_stmt|;
if|if
condition|(
operator|(
name|lb2
operator|=
name|newlblk
argument_list|(
name|LB_ACCEPTNOW
argument_list|,
name|NULLTA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lb2
operator|->
name|lb_accept2
operator|=
name|lb
operator|->
name|lb_accept2
expr_stmt|;
name|lb2
operator|->
name|lb_addr
operator|=
name|lb
operator|->
name|lb_addr
expr_stmt|;
name|lb2
operator|->
name|lb_close
operator|=
name|lb
operator|->
name|lb_close
expr_stmt|;
name|lb2
operator|->
name|lb_loc_tsock
operator|=
name|lb
operator|->
name|lb_loc_tsock
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_tp4_client
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|lb2
operator|->
name|lb_rem_tsock
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|lb2
operator|->
name|lb_fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|=
name|newtblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tb
operator|->
name|tb_fd
operator|=
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|tp4init
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|lb2
operator|->
name|lb_tb
operator|=
name|tb
expr_stmt|;
name|copyTSAPaddrY
argument_list|(
operator|&
name|tb
operator|->
name|tb_responding
argument_list|,
operator|&
name|lb2
operator|->
name|lb_rem_tsock
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lb2
condition|)
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tp4accept2
parameter_list|(
name|lb
parameter_list|,
name|vecp
parameter_list|,
name|vec
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|int
modifier|*
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|,
name|cmsgtype
decl_stmt|,
name|fd
init|=
name|lb
operator|->
name|lb_fd
decl_stmt|,
name|len
decl_stmt|;
name|char
name|udata
index|[
name|TS_SIZE
index|]
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
init|=
name|lb
operator|->
name|lb_tb
decl_stmt|;
name|union
name|sockaddr_osi
name|sock
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|ifaddr
init|=
operator|&
name|sock
operator|.
name|osi_sockaddr
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|len
operator|=
sizeof|sizeof
name|sock
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ifaddr
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|ifaddr
operator|->
name|siso_len
operator|=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|tp42genX
argument_list|(
operator|&
name|tb
operator|->
name|tb_initiating
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
block|}
else|else
name|SLOG
argument_list|(
name|tsap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
operator|(
literal|"getsockname on incoming connection"
operator|)
argument_list|)
expr_stmt|;
name|cc
operator|=
sizeof|sizeof
name|udata
expr_stmt|;
if|if
condition|(
name|tp4getCmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|cc
argument_list|,
operator|&
name|cmsgtype
argument_list|,
name|udata
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"TPOPT_CONN_DATA"
argument_list|,
literal|"unable to get"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cmsgtype
operator|!=
name|TPOPT_CONN_DATA
condition|)
name|cc
operator|=
literal|0
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
literal|"tsaplisten"
expr_stmt|;
comment|/* any value will do */
if|if
condition|(
operator|(
name|vec
index|[
literal|1
index|]
operator|=
name|tp4save
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc
operator|>
literal|0
condition|)
name|len
operator|+=
name|explode
argument_list|(
name|buffer
operator|+
name|len
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|udata
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|buffer
index|[
name|len
index|]
operator|=
name|NULL
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
name|buffer
expr_stmt|;
name|vec
index|[
operator|*
name|vecp
operator|=
literal|3
index|]
operator|=
name|NULLCP
expr_stmt|;
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|tp4unique
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|)
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
name|ta
operator|->
name|ta_addrs
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|na
argument_list|,
sizeof|sizeof
expr|*
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_stack
operator|=
name|NA_NSAP
expr_stmt|;
return|return
name|start_tp4_server
argument_list|(
name|na
argument_list|,
name|SOMAXCONN
argument_list|,
name|SO_KEEPALIVE
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|TP4 from SunLink OSI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_TP4
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|tp4listen
parameter_list|(
name|lb
parameter_list|,
name|ta
parameter_list|,
name|td
parameter_list|)
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|start_tp4_server
argument_list|(
name|ta
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tp4accept1
parameter_list|(
name|lb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|struct
name|listenblk
modifier|*
name|lb2
decl_stmt|;
if|if
condition|(
operator|(
name|lb2
operator|=
name|newlblk
argument_list|(
name|LB_ACCEPT
argument_list|,
name|NULLTA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lb2
operator|->
name|lb_loc_isock
operator|=
name|lb
operator|->
name|lb_loc_isock
expr_stmt|;
name|lb2
operator|->
name|lb_addr
operator|=
name|lb
operator|->
name|lb_addr
expr_stmt|;
name|lb2
operator|->
name|lb_accept2
operator|=
name|lb
operator|->
name|lb_accept2
expr_stmt|;
name|lb2
operator|->
name|lb_close
operator|=
name|lb
operator|->
name|lb_close
expr_stmt|;
name|lb2
operator|->
name|lb_magic
operator|=
name|lb
operator|->
name|lb_magic
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_tp4_client
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|lb
operator|->
name|lb_rem_tsock
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|lb2
operator|->
name|lb_fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|=
name|newtblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tb
operator|->
name|tb_fd
operator|=
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|tp4init
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|add_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|lb2
operator|->
name|lb_tb
operator|=
name|tb
expr_stmt|;
return|return
name|fd
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lb2
condition|)
name|freelblk
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tp4accept2
parameter_list|(
name|lb
parameter_list|,
name|vecp
parameter_list|,
name|vec
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|int
modifier|*
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|,
name|fd
init|=
name|lb
operator|->
name|lb_fd
decl_stmt|,
name|header_len
decl_stmt|,
name|len
decl_stmt|;
name|char
name|data
index|[
name|TC_SIZE
index|]
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
init|=
name|lb
operator|->
name|lb_tb
decl_stmt|;
specifier|register
name|struct
name|tp4pkt
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|newtp4pkt
argument_list|(
operator|(
name|TP_EVENT
operator|)
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|header_len
operator|=
sizeof|sizeof
argument_list|(
name|TP_MSG_CONNECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|tp
argument_list|,
operator|&
name|header_len
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"recvfrom"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|tp4_event
operator|!=
name|TP_CONNECT_IND
condition|)
block|{
operator|(
name|void
operator|)
name|tpktlose
argument_list|(
name|tb
argument_list|,
name|td
argument_list|,
name|DR_REMOTE
argument_list|,
name|NULLCP
argument_list|,
literal|"transport protocol mangled: expecting 0x%x got 0x%x"
argument_list|,
name|TP_CONNECT_IND
argument_list|,
name|tp
operator|->
name|tp4_event
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|tp42genX
argument_list|(
operator|&
name|tb
operator|->
name|tb_responding
argument_list|,
operator|&
name|tp
operator|->
name|tp4_called
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tp42genX
argument_list|(
operator|&
name|tb
operator|->
name|tb_initiating
argument_list|,
operator|&
name|tp
operator|->
name|tp4_calling
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
literal|"tsaplisten"
expr_stmt|;
comment|/* any value will do */
if|if
condition|(
operator|(
name|vec
index|[
literal|1
index|]
operator|=
name|tp4save
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|len
operator|=
name|explode
argument_list|(
name|buffer
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|TP_MSG_CONNECT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|>
literal|0
condition|)
name|len
operator|+=
name|explode
argument_list|(
name|buffer
operator|+
name|len
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|buffer
index|[
name|len
index|]
operator|=
name|NULL
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
name|buffer
expr_stmt|;
name|vec
index|[
operator|*
name|vecp
operator|=
literal|3
index|]
operator|=
name|NULLCP
expr_stmt|;
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|freetp4pkt
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|del_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freetblk
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
condition|)
name|freetp4pkt
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|tp4unique
parameter_list|(
name|ta
parameter_list|,
name|td
parameter_list|)
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_ADDRESS
argument_list|,
name|NULLCP
argument_list|,
literal|"unique listens not yet supported with SunLink OSI"
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|INTERNAL */
end_comment

begin_function
specifier|static
name|struct
name|listenblk
modifier|*
name|newlblk
parameter_list|(
name|type
parameter_list|,
name|ta
parameter_list|)
name|int
name|type
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
block|{
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|lb
operator|=
operator|(
expr|struct
name|listenblk
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|lb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|==
name|NULLLBP
condition|)
return|return
name|lb
return|;
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|ta
condition|)
name|lb
operator|->
name|lb_addr
operator|=
operator|*
name|ta
expr_stmt|;
comment|/* struct copy */
name|lb
operator|->
name|lb_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|LHead
operator|->
name|lb_forw
operator|=
name|LHead
operator|->
name|lb_back
operator|=
name|LHead
expr_stmt|;
name|once_only
operator|++
expr_stmt|;
block|}
name|insque
argument_list|(
name|lb
argument_list|,
name|LHead
operator|->
name|lb_back
argument_list|)
expr_stmt|;
return|return
name|lb
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|freelblk
argument_list|(
name|lb
argument_list|)
specifier|register
expr|struct
name|listenblk
operator|*
name|lb
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|lb
operator|==
name|NULLLBP
condition|)
return|return;
ifdef|#
directive|ifdef
name|MGMT
if|if
condition|(
name|lb
operator|->
name|lb_type
operator|==
name|LB_LISTEN
condition|)
operator|(
name|void
operator|)
name|TManGen
argument_list|(
name|ENDLISTEN
argument_list|,
name|NULLBP
argument_list|,
operator|&
name|lb
operator|->
name|lb_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|LPP
if|if
condition|(
name|lb
operator|->
name|lb_type
operator|!=
name|LB_QUEUED
condition|)
endif|#
directive|endif
if|if
condition|(
name|lb
operator|->
name|lb_fd
operator|!=
name|NOTOK
condition|)
block|{
name|del_fd
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|lb
operator|->
name|lb_close
argument_list|)
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|)
expr_stmt|;
block|}
name|remque
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|listenblk
modifier|*
name|findlblk
parameter_list|(
name|ta
parameter_list|,
name|type
parameter_list|)
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
return|return
name|NULLLBP
return|;
for|for
control|(
name|lb
operator|=
name|LHead
operator|->
name|lb_forw
init|;
name|lb
operator|!=
name|LHead
condition|;
name|lb
operator|=
name|lb
operator|->
name|lb_forw
control|)
if|if
condition|(
name|lb
operator|->
name|lb_type
operator|==
name|type
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lb
operator|->
name|lb_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ta
argument_list|,
sizeof|sizeof
expr|*
name|ta
argument_list|)
operator|==
literal|0
condition|)
return|return
name|lb
return|;
return|return
name|NULLLBP
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|listenblk
modifier|*
name|findlblkbyfd
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
return|return
name|NULLLBP
return|;
for|for
control|(
name|lb
operator|=
name|LHead
operator|->
name|lb_forw
init|;
name|lb
operator|!=
name|LHead
condition|;
name|lb
operator|=
name|lb
operator|->
name|lb_forw
control|)
ifndef|#
directive|ifndef
name|LPP
if|if
condition|(
name|lb
operator|->
name|lb_type
operator|!=
name|LB_QUEUED
condition|)
endif|#
directive|endif
if|if
condition|(
name|lb
operator|->
name|lb_fd
operator|==
name|fd
condition|)
return|return
name|lb
return|;
return|return
name|NULLLBP
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|eventblk
modifier|*
name|neweblk
parameter_list|(
name|ta
parameter_list|)
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
block|{
specifier|register
name|struct
name|eventblk
modifier|*
name|eb
decl_stmt|;
name|eb
operator|=
operator|(
expr|struct
name|eventblk
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|eb
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|==
name|NULLEVP
condition|)
return|return
name|eb
return|;
name|eb
operator|->
name|ev_taddr
operator|=
operator|*
name|ta
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|ev_onceonly
operator|==
literal|0
condition|)
block|{
name|EHead
operator|->
name|ev_forw
operator|=
name|EHead
operator|->
name|ev_back
operator|=
name|EHead
expr_stmt|;
name|ev_onceonly
operator|++
expr_stmt|;
block|}
name|insque
argument_list|(
name|eb
argument_list|,
name|EHead
operator|->
name|ev_back
argument_list|)
expr_stmt|;
name|ev_count
operator|++
expr_stmt|;
return|return
name|eb
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE_X25
end_ifdef

begin_expr_stmt
specifier|static
name|freeeblk
argument_list|(
name|eb
argument_list|)
specifier|register
expr|struct
name|eventblk
operator|*
name|eb
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|eb
operator|==
name|NULLEVP
condition|)
return|return;
name|remque
argument_list|(
name|eb
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eb
argument_list|)
expr_stmt|;
name|ev_count
operator|--
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LPP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|int
name|tsaplose
parameter_list|(
name|td
parameter_list|,
name|reason
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
name|int
name|reason
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|reason
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|queued writes */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LPP
end_ifndef

begin_function
specifier|static
name|int
name|TNetQueue
parameter_list|(
name|tb
parameter_list|,
name|insert
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|int
name|insert
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|LHead
operator|->
name|lb_forw
operator|=
name|LHead
operator|->
name|lb_back
operator|=
name|LHead
expr_stmt|;
name|once_only
operator|++
expr_stmt|;
block|}
for|for
control|(
name|lb
operator|=
name|LHead
operator|->
name|lb_forw
init|;
name|lb
operator|!=
name|LHead
condition|;
name|lb
operator|=
name|lb
operator|->
name|lb_forw
control|)
if|if
condition|(
name|lb
operator|->
name|lb_type
operator|==
name|LB_QUEUED
operator|&&
name|lb
operator|->
name|lb_tb
operator|==
name|tb
condition|)
break|break;
if|if
condition|(
operator|!
name|insert
condition|)
block|{
if|if
condition|(
name|lb
operator|!=
name|LHead
condition|)
name|TFreeQueues
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|lb
operator|!=
name|LHead
condition|)
comment|/* should "never happen" */
return|return
name|OK
return|;
if|if
condition|(
operator|(
name|lb
operator|=
name|newlblk
argument_list|(
name|LB_QUEUED
argument_list|,
name|NULLTA
argument_list|)
operator|)
operator|==
name|NULLLBP
condition|)
block|{
name|SLOG
argument_list|(
name|tsap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"unable to allocate listenblk for queued writes"
operator|)
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
return|;
block|}
name|lb
operator|->
name|lb_fd
operator|=
operator|(
name|lb
operator|->
name|lb_tb
operator|=
name|tb
operator|)
operator|->
name|tb_fd
expr_stmt|;
if|if
condition|(
name|lb
operator|->
name|lb_fd
operator|>=
name|qw_nfds
condition|)
name|qw_nfds
operator|=
name|lb
operator|->
name|lb_fd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|qw_count
operator|++
operator|==
literal|0
condition|)
name|FD_ZERO
argument_list|(
operator|&
name|qw_mask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|qw_mask
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|TDoQueues
parameter_list|(
name|lb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
init|=
name|lb
operator|->
name|lb_tb
decl_stmt|;
switch|switch
condition|(
call|(
modifier|*
name|tb
operator|->
name|tb_drainPfnx
call|)
argument_list|(
name|tb
argument_list|,
name|td
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|DONE
case|:
default|default:
name|TFreeQueues
argument_list|(
name|lb
argument_list|)
expr_stmt|;
comment|/* and fall... */
case|case
name|OK
case|:
return|return
name|OK
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|TFreeQueues
parameter_list|(
name|lb
parameter_list|)
specifier|register
name|struct
name|listenblk
modifier|*
name|lb
decl_stmt|;
block|{
if|if
condition|(
name|lb
operator|->
name|lb_fd
operator|+
literal|1
operator|==
name|qw_nfds
condition|)
name|qw_nfds
operator|--
expr_stmt|;
if|if
condition|(
operator|--
name|qw_count
operator|==
literal|0
condition|)
name|qw_nfds
operator|=
literal|0
expr_stmt|;
name|FD_CLR
argument_list|(
name|lb
operator|->
name|lb_fd
argument_list|,
operator|&
name|qw_mask
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freelblk
argument_list|(
name|lb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|TSetQueuesOK
parameter_list|(
name|sd
parameter_list|,
name|onoff
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
name|int
name|onoff
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|SBV
name|smask
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|missingP
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|tsapPsig
argument_list|(
name|tb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
if|if
condition|(
name|tb
operator|->
name|tb_drainPfnx
operator|==
name|NULLIFP
condition|)
name|result
operator|=
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_OPERATION
argument_list|,
name|NULLCP
argument_list|,
literal|"queued writes not supported by TS-stack"
argument_list|)
expr_stmt|;
else|else
block|{
name|tb
operator|->
name|tb_flags
operator||=
name|TB_QWRITES
expr_stmt|;
name|tb
operator|->
name|tb_queuePfnx
operator|=
name|TNetQueue
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tb
operator|->
name|tb_qwrites
operator|.
name|qb_forw
operator|!=
operator|&
name|tb
operator|->
name|tb_qwrites
condition|)
name|result
operator|=
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_WAITING
argument_list|,
name|NULLCP
argument_list|,
literal|"queued writes still waiting to drain"
argument_list|)
expr_stmt|;
else|else
block|{
name|tb
operator|->
name|tb_flags
operator|&=
operator|~
name|TB_QWRITES
expr_stmt|;
name|tb
operator|->
name|tb_queuePfnx
operator|=
name|NULLIFP
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

