begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftamprovider.c - implement the FTAM protocol */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam/RCS/ftamprovider.c,v 7.6 91/02/22 09:23:05 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam/RCS/ftamprovider.c,v 7.6 91/02/22 09:23:05 mrose Interim $  *  *  * $Log:	ftamprovider.c,v $  * Revision 7.6  91/02/22  09:23:05  mrose  * Interim 6.8  *   * Revision 7.5  91/01/07  12:40:14  mrose  * update  *   * Revision 7.4  90/11/21  11:30:12  mrose  * sun  *   * Revision 7.3  90/11/05  13:32:53  mrose  * update  *   * Revision 7.2  90/08/08  14:12:18  mrose  * update  *   * Revision 7.1  89/12/14  10:04:00  mrose  * bdt  *   * Revision 7.0  89/11/23  21:53:45  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"fpkt.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
name|struct
name|pair
name|fclass_pairs
index|[]
init|=
block|{
name|FCLASS_UNCONS
block|,
name|bit_FTAM_Service__Class_unconstrained__class
block|,
name|FCLASS_MANAGE
block|,
name|bit_FTAM_Service__Class_management__class
block|,
name|FCLASS_TRANSFER
block|,
name|bit_FTAM_Service__Class_transfer__class
block|,
name|FCLASS_TM
block|,
name|bit_FTAM_Service__Class_transfer__and__management__class
block|,
name|FCLASS_ACCESS
block|,
name|bit_FTAM_Service__Class_access__class
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pair
name|funit_pairs
index|[]
init|=
block|{
name|FUNIT_READ
block|,
name|bit_FTAM_Functional__Units_read
block|,
name|FUNIT_WRITE
block|,
name|bit_FTAM_Functional__Units_write
block|,
name|FUNIT_ACCESS
block|,
name|bit_FTAM_Functional__Units_file__access
block|,
name|FUNIT_LIMITED
block|,
name|bit_FTAM_Functional__Units_limited__file__management
block|,
name|FUNIT_ENHANCED
block|,
name|bit_FTAM_Functional__Units_enhanced__file__management
block|,
name|FUNIT_GROUPING
block|,
name|bit_FTAM_Functional__Units_grouping
block|,
name|FUNIT_FADULOCK
block|,
name|bit_FTAM_Functional__Units_fadu__locking
block|,
name|FUNIT_RECOVERY
block|,
name|bit_FTAM_Functional__Units_recovery
block|,
name|FUNIT_RESTART
block|,
name|bit_FTAM_Functional__Units_restart__data__transfer
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pair
name|fattr_pairs
index|[]
init|=
block|{
name|FATTR_STORAGE
block|,
name|bit_FTAM_Attribute__Groups_storage
block|,
name|FATTR_SECURITY
block|,
name|bit_FTAM_Attribute__Groups_security
block|,
name|FATTR_PRIVATE
block|,
name|bit_FTAM_Attribute__Groups_private
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pair
name|fname_pairs
index|[]
init|=
block|{
name|FA_FILENAME
block|,
name|bit_FTAM_Attribute__Names_read__filename
block|,
name|FA_ACTIONS
block|,
name|bit_FTAM_Attribute__Names_read__permitted__actions
block|,
name|FA_CONTENTS
block|,
name|bit_FTAM_Attribute__Names_read__content__types
block|,
name|FA_ACCOUNT
block|,
name|bit_FTAM_Attribute__Names_read__storage__account
block|,
name|FA_DATE_CREATE
block|,
name|bit_FTAM_Attribute__Names_read__date__and__time__of__creation
block|,
name|FA_DATE_MODIFY
block|,
name|bit_FTAM_Attribute__Names_read__date__and__time__of__last__modification
block|,
name|FA_DATE_READ
block|,
name|bit_FTAM_Attribute__Names_read__date__and__time__of__last__read__access
block|,
name|FA_DATE_ATTR
block|,
name|bit_FTAM_Attribute__Names_read__date__and__time__of__last__attribute__modification
block|,
name|FA_ID_CREATE
block|,
name|bit_FTAM_Attribute__Names_read__identity__of__creator
block|,
name|FA_ID_MODIFY
block|,
name|bit_FTAM_Attribute__Names_read__identity__of__last__modifier
block|,
name|FA_ID_READ
block|,
name|bit_FTAM_Attribute__Names_read__identity__of__last__reader
block|,
name|FA_ID_ATTR
block|,
name|bit_FTAM_Attribute__Names_read__identity__of__last__attribute__modifier
block|,
name|FA_AVAILABILITY
block|,
name|bit_FTAM_Attribute__Names_read__file__availability
block|,
name|FA_FILESIZE
block|,
name|bit_FTAM_Attribute__Names_read__filesize
block|,
name|FA_FUTURESIZE
block|,
name|bit_FTAM_Attribute__Names_read__future__filesize
block|,
name|FA_CONTROL
block|,
name|bit_FTAM_Attribute__Names_read__access__control
block|,
name|FA_LEGAL
block|,
name|bit_FTAM_Attribute__Names_read__legal__qualifications
block|,
name|FA_PRIVATE
block|,
name|bit_FTAM_Attribute__Names_read__private__use
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pair
name|fmode_pairs
index|[]
init|=
block|{
name|FA_PERM_READ
block|,
name|bit_FTAM_processing__mode_f__read
block|,
name|FA_PERM_INSERT
block|,
name|bit_FTAM_processing__mode_f__insert
block|,
name|FA_PERM_REPLACE
block|,
name|bit_FTAM_processing__mode_f__replace
block|,
name|FA_PERM_EXTEND
block|,
name|bit_FTAM_processing__mode_f__extend
block|,
name|FA_PERM_ERASE
block|,
name|bit_FTAM_processing__mode_f__erase
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pair
name|frequested_pairs
index|[]
init|=
block|{
name|FA_PERM_READ
block|,
name|bit_FTAM_Access__Request_read
block|,
name|FA_PERM_INSERT
block|,
name|bit_FTAM_Access__Request_insert
block|,
name|FA_PERM_REPLACE
block|,
name|bit_FTAM_Access__Request_replace
block|,
name|FA_PERM_EXTEND
block|,
name|bit_FTAM_Access__Request_extend
block|,
name|FA_PERM_ERASE
block|,
name|bit_FTAM_Access__Request_erase
block|,
name|FA_PERM_READATTR
block|,
name|bit_FTAM_Access__Request_read__attribute
block|,
name|FA_PERM_CHNGATTR
block|,
name|bit_FTAM_Access__Request_change__attribute
block|,
name|FA_PERM_DELETE
block|,
name|bit_FTAM_Access__Request_delete
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pair
name|fpermitted_pairs
index|[]
init|=
block|{
name|FA_PERM_READ
block|,
name|bit_FTAM_Permitted__Actions__Attribute_read
block|,
name|FA_PERM_INSERT
block|,
name|bit_FTAM_Permitted__Actions__Attribute_insert
block|,
name|FA_PERM_REPLACE
block|,
name|bit_FTAM_Permitted__Actions__Attribute_replace
block|,
name|FA_PERM_EXTEND
block|,
name|bit_FTAM_Permitted__Actions__Attribute_extend
block|,
name|FA_PERM_ERASE
block|,
name|bit_FTAM_Permitted__Actions__Attribute_erase
block|,
name|FA_PERM_READATTR
block|,
name|bit_FTAM_Permitted__Actions__Attribute_read__attribute
block|,
name|FA_PERM_CHNGATTR
block|,
name|bit_FTAM_Permitted__Actions__Attribute_change__attribute
block|,
name|FA_PERM_DELETE
block|,
name|bit_FTAM_Permitted__Actions__Attribute_delete__file
block|,
name|FA_PERM_TRAV
block|,
name|bit_FTAM_Permitted__Actions__Attribute_traversal
block|,
name|FA_PERM_RVTRAV
block|,
name|bit_FTAM_Permitted__Actions__Attribute_reverse__traversal
block|,
name|FA_PERM_RANDOM
block|,
name|bit_FTAM_Permitted__Actions__Attribute_random__order
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|once_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ftamblk
name|ftamque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ftamblk
modifier|*
name|FSHead
init|=
operator|&
name|ftamque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|psDATAser
argument_list|()
decl_stmt|,
name|psTOKENser
argument_list|()
decl_stmt|,
name|psSYNCser
argument_list|()
decl_stmt|,
name|psACTIVITYser
argument_list|()
decl_stmt|,
name|psREPORTser
argument_list|()
decl_stmt|,
name|psFINISHser
argument_list|()
decl_stmt|,
name|psABORTser
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|F-WAIT.REQUEST (pseudo) */
end_comment

begin_function
name|int
name|FWaitRequest
parameter_list|(
name|sd
parameter_list|,
name|secs
parameter_list|,
name|fti
parameter_list|)
name|int
name|sd
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|missingP
argument_list|(
name|fti
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|ftamPsig
argument_list|(
name|fsb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|result
operator|=
name|FWaitRequestAux
argument_list|(
name|fsb
argument_list|,
name|secs
argument_list|,
name|fti
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|FWaitRequestAux
parameter_list|(
name|fsb
parameter_list|,
name|secs
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|struct
name|PSAPdata
name|pxs
decl_stmt|;
specifier|register
name|struct
name|PSAPdata
modifier|*
name|px
init|=
operator|&
name|pxs
decl_stmt|;
name|struct
name|PSAPindication
name|pis
decl_stmt|;
specifier|register
name|struct
name|PSAPindication
modifier|*
name|pi
init|=
operator|&
name|pis
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fsb
operator|->
name|fsb_data
operator|.
name|px_ninfo
operator|>
literal|0
condition|)
block|{
operator|*
name|px
operator|=
name|fsb
operator|->
name|fsb_data
expr_stmt|;
comment|/* struct copy */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fsb
operator|->
name|fsb_data
argument_list|,
sizeof|sizeof
name|fsb
operator|->
name|fsb_data
argument_list|)
expr_stmt|;
goto|goto
name|do_data
goto|;
block|}
switch|switch
condition|(
name|result
operator|=
name|PReadRequest
argument_list|(
name|fsb
operator|->
name|fsb_fd
argument_list|,
name|px
argument_list|,
name|secs
argument_list|,
name|pi
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|doPSabort
argument_list|(
name|fsb
argument_list|,
operator|&
name|pi
operator|->
name|pi_abort
argument_list|,
name|fti
argument_list|)
return|;
case|case
name|OK
case|:
name|do_data
label|:
empty_stmt|;
name|result
operator|=
name|doPSdata
argument_list|(
name|fsb
argument_list|,
name|px
argument_list|,
name|fti
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONE
case|:
switch|switch
condition|(
name|pi
operator|->
name|pi_type
condition|)
block|{
case|case
name|PI_TOKEN
case|:
name|result
operator|=
name|doPStokens
argument_list|(
name|fsb
argument_list|,
operator|&
name|pi
operator|->
name|pi_token
argument_list|,
name|fti
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_SYNC
case|:
name|result
operator|=
name|doPSsync
argument_list|(
name|fsb
argument_list|,
operator|&
name|pi
operator|->
name|pi_sync
argument_list|,
name|fti
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_ACTIVITY
case|:
name|result
operator|=
name|doPSactivity
argument_list|(
name|fsb
argument_list|,
operator|&
name|pi
operator|->
name|pi_activity
argument_list|,
name|fti
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_REPORT
case|:
name|result
operator|=
name|doPSreport
argument_list|(
name|fsb
argument_list|,
operator|&
name|pi
operator|->
name|pi_report
argument_list|,
name|fti
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_FINISH
case|:
name|result
operator|=
name|doPSfinish
argument_list|(
name|fsb
argument_list|,
operator|&
name|pi
operator|->
name|pi_finish
argument_list|,
name|fti
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_LOWFAIL
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown indication (0x%x) from presentation"
argument_list|,
name|pi
operator|->
name|pi_type
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|result
operator|=
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_LOWFAIL
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected return from PReadRequest=%d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
break|break;
case|case
name|DONE
case|:
return|return
name|OK
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doPSdata
parameter_list|(
name|fsb
parameter_list|,
name|px
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|PSAPdata
modifier|*
name|px
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
name|int
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|PE
name|pe
decl_stmt|,
modifier|*
name|pep
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|fti
operator|->
name|fti_group
decl_stmt|;
name|struct
name|type_FTAM_PDU
modifier|*
name|pdu
decl_stmt|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_FINISH
expr_stmt|;
comment|/* temporary for group */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|pdu
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pep
operator|=
name|px
operator|->
name|px_info
operator|,
name|i
operator|=
name|px
operator|->
name|px_ninfo
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|pep
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|pe
operator|=
operator|*
name|pep
operator|)
operator|==
name|NULLPE
condition|)
continue|continue;
if|if
condition|(
name|pe
operator|->
name|pe_context
operator|!=
name|fsb
operator|->
name|fsb_id
condition|)
goto|goto
name|got_fadu
goto|;
switch|switch
condition|(
name|PE_ID
argument_list|(
name|pe
operator|->
name|pe_class
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
condition|)
block|{
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_APPL
argument_list|,
name|FADU_NODESCR
argument_list|)
case|:
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_APPL
argument_list|,
name|FADU_ENTERTREE
argument_list|)
case|:
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_APPL
argument_list|,
name|FADU_EXITREE
argument_list|)
case|:
name|pe
operator|->
name|pe_context
operator|=
name|PE_DFLT_CTX
expr_stmt|;
name|got_fadu
label|:
empty_stmt|;
if|if
condition|(
name|next
operator|<
literal|0
condition|)
goto|goto
name|copy_psdu
goto|;
name|next
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|next
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|PSAPdata
modifier|*
name|fx
init|=
operator|&
name|fsb
operator|->
name|fsb_data
decl_stmt|;
name|copy_psdu
label|:
empty_stmt|;
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_id
operator|,
literal|"queueing possible BDT entries in PSDU"
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|px
operator|->
name|px_ninfo
operator|-=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
do|do
block|{
name|fx
operator|->
name|px_info
index|[
name|fx
operator|->
name|px_ninfo
operator|++
index|]
operator|=
operator|*
name|pep
expr_stmt|;
operator|*
name|pep
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
do|;
break|break;
block|}
name|next
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|next
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|fsb
operator|->
name|fsb_state
condition|)
block|{
case|case
name|FSB_DATAREAD
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|)
block|{
name|unexpected_fadu
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected FADU; state=0x%x"
argument_list|,
name|fsb
operator|->
name|fsb_state
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|FSB_DATAWRITE
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
goto|goto
name|unexpected_fadu
goto|;
break|break;
case|case
name|FSB_DATACANCEL
case|:
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"discarding FADU during CANCEL procedure"
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
default|default:
goto|goto
name|unexpected_fadu
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_DATA
expr_stmt|;
block|{
specifier|register
name|struct
name|PSAPdata
modifier|*
name|fx
init|=
operator|&
name|fti
operator|->
name|fti_data
decl_stmt|;
operator|*
name|fx
operator|=
operator|*
name|px
expr_stmt|;
comment|/* struct copy */
block|}
return|return
name|DONE
return|;
block|}
name|next
operator|=
name|FTG_BEGIN
expr_stmt|;
for|for
control|(
name|pep
operator|=
name|px
operator|->
name|px_info
operator|,
name|i
operator|=
name|px
operator|->
name|px_ninfo
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|pep
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|pe
operator|=
operator|*
name|pep
operator|)
operator|==
name|NULLPE
condition|)
continue|continue;
if|if
condition|(
name|decode_FTAM_PDU
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|pdu
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRMSG
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to parse PDU: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"P-DATA.INDICATION"
operator|,
literal|"FPDU"
operator|,
name|pe
operator|,
literal|1
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pdu
operator|->
name|offset
condition|)
block|{
case|case
name|type_FTAM_PDU_f__begin__group__request
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_threshold
operator|=
name|pdu
operator|->
name|un
operator|.
name|f__begin__group__request
operator|->
name|parm
expr_stmt|;
goto|goto
name|do_begin
goto|;
case|case
name|type_FTAM_PDU_f__begin__group__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|do_begin
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|&
name|FTG_BEGIN
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_GROUPING
operator|)
condition|)
block|{
name|no_grouping
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRFUNIT
argument_list|,
name|NULLCP
argument_list|,
literal|"grouping not permitted"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
expr_stmt|;
name|next
operator|=
name|FTG_SELECT
operator||
name|FTG_CREATE
operator||
name|FTG_CLOSE
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__select__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_SELECT
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__SELECT__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__select__request
decl_stmt|;
if|if
condition|(
name|fpm2attr
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|attributes
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_attrs
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|ftse
operator|->
name|ftse_attrs
operator|.
name|fa_present
operator|&=
name|FA_SEL_ATTRS
expr_stmt|;
if|if
condition|(
name|fpm2bits
argument_list|(
name|fsb
argument_list|,
name|frequested_pairs
argument_list|,
name|req
operator|->
name|requested__access
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_access
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
operator|&&
name|req
operator|->
name|access__passwords
operator|&&
name|fpm2pass
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|access__passwords
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_pwds
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
operator|&&
name|req
operator|->
name|concurrency__control
operator|&&
name|fpm2conctl
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|concurrency__control
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|account
operator|&&
operator|(
name|ftse
operator|->
name|ftse_account
operator|=
name|qb2str
argument_list|(
name|req
operator|->
name|account
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|next
operator|=
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_OPEN
operator||
name|FTG_DESELECT
operator||
name|FTG_DELETE
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__select__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_SELECT
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__SELECT__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__select__response
decl_stmt|;
name|ftse
operator|->
name|ftse_state
operator|=
name|rsp
operator|->
name|state__result
condition|?
name|rsp
operator|->
name|state__result
operator|->
name|parm
else|:
name|int_FTAM_State__Result_success
expr_stmt|;
name|ftse
operator|->
name|ftse_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|fpm2attr
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|attributes
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_attrs
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|ftse
operator|->
name|ftse_attrs
operator|.
name|fa_present
operator|&=
name|FA_SEL_ATTRS
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftse
operator|->
name|ftse_diags
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_OPEN
operator||
name|FTG_DESELECT
operator||
name|FTG_DELETE
operator||
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__create__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_CREATE
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_LIMITED
operator|)
condition|)
block|{
name|no_limited
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"limited file management not permitted"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CREATE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftg
operator|->
name|ftg_create
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__CREATE__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__create__request
decl_stmt|;
name|ftce
operator|->
name|ftce_override
operator|=
name|req
operator|->
name|override
expr_stmt|;
if|if
condition|(
name|fpm2attr
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|initial__attributes
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_attrs
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_present
operator|&
operator|(
name|FA_FILENAME
operator||
name|FA_ACTIONS
operator||
name|FA_CONTENTS
operator|)
operator|)
operator|!=
operator|(
name|FA_FILENAME
operator||
name|FA_ACTIONS
operator||
name|FA_CONTENTS
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
literal|"missing mandatory parameters in F-CREATE-request"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_present
operator|&=
name|FA_CRE_ATTRS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_STORAGE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
condition|)
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_SECURITY
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|create__password
condition|)
block|{
comment|/* both choices are qbufs... */
specifier|register
name|struct
name|qbuf
modifier|*
name|qb
init|=
name|req
operator|->
name|create__password
operator|->
name|un
operator|.
name|graphic
decl_stmt|;
if|if
condition|(
operator|(
name|ftce
operator|->
name|ftce_create
operator|=
name|qb2str
argument_list|(
name|qb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|ftce
operator|->
name|ftce_crelen
operator|=
name|qb
operator|->
name|qb_len
expr_stmt|;
block|}
if|if
condition|(
name|fpm2bits
argument_list|(
name|fsb
argument_list|,
name|frequested_pairs
argument_list|,
name|req
operator|->
name|requested__access
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_access
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
operator|&&
name|req
operator|->
name|access__passwords
operator|&&
name|fpm2pass
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|access__passwords
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_pwds
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|FCINIT
argument_list|(
operator|&
name|ftce
operator|->
name|ftce_conctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
operator|&&
name|req
operator|->
name|concurrency__control
operator|&&
name|fpm2conctl
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|concurrency__control
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_conctl
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|account
operator|&&
operator|(
name|ftce
operator|->
name|ftce_account
operator|=
name|qb2str
argument_list|(
name|req
operator|->
name|account
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
name|next
operator|=
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_OPEN
operator||
name|FTG_DESELECT
operator||
name|FTG_DELETE
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__create__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_CREATE
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_LIMITED
operator|)
condition|)
goto|goto
name|no_limited
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CREATE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftg
operator|->
name|ftg_create
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__CREATE__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__create__response
decl_stmt|;
name|ftce
operator|->
name|ftce_state
operator|=
name|rsp
operator|->
name|state__result
condition|?
name|rsp
operator|->
name|state__result
operator|->
name|parm
else|:
name|int_FTAM_State__Result_success
expr_stmt|;
name|ftce
operator|->
name|ftce_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|fpm2attr
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|initial__attributes
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_attrs
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_present
operator|&=
name|FA_CRE_ATTRS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_STORAGE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
condition|)
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_SECURITY
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftce
operator|->
name|ftce_diags
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_OPEN
operator||
name|FTG_DESELECT
operator||
name|FTG_DELETE
operator||
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__read__attrib__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_RDATTR
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_LIMITED
operator|)
condition|)
goto|goto
name|no_limited
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_RDATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMreadattr
modifier|*
name|ftra
init|=
operator|&
name|ftg
operator|->
name|ftg_readattr
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__READ__ATTRIB__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__read__attrib__request
decl_stmt|;
if|if
condition|(
name|fpm2bits
argument_list|(
name|fsb
argument_list|,
name|fname_pairs
argument_list|,
name|req
argument_list|,
operator|&
name|ftra
operator|->
name|ftra_attrnames
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
name|ftra
operator|->
name|ftra_attrnames
operator|&=
operator|~
name|FA_STORAGE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
condition|)
name|ftra
operator|->
name|ftra_attrnames
operator|&=
operator|~
name|FA_SECURITY
expr_stmt|;
block|}
name|next
operator|=
name|FTG_CHATTR
operator||
name|FTG_DESELECT
operator||
name|FTG_DELETE
operator||
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|(
name|FTG_SELECT
operator||
name|FTG_CREATE
operator|)
condition|?
name|FTG_OPEN
else|:
name|FTG_NULL
operator|)
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__read__attrib__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_RDATTR
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_LIMITED
operator|)
condition|)
goto|goto
name|no_limited
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_RDATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMreadattr
modifier|*
name|ftra
init|=
operator|&
name|ftg
operator|->
name|ftg_readattr
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__READ__ATTRIB__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__read__attrib__response
decl_stmt|;
name|ftra
operator|->
name|ftra_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|attributes
operator|&&
name|fpm2attr
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|attributes
argument_list|,
operator|&
name|ftra
operator|->
name|ftra_attrs
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
name|ftra
operator|->
name|ftra_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_STORAGE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
condition|)
name|ftra
operator|->
name|ftra_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_SECURITY
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftra
operator|->
name|ftra_diags
argument_list|,
operator|&
name|ftra
operator|->
name|ftra_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_CHATTR
operator||
name|FTG_DESELECT
operator||
name|FTG_DELETE
operator||
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|(
name|FTG_SELECT
operator||
name|FTG_CREATE
operator|)
condition|?
name|FTG_OPEN
else|:
name|FTG_NULL
operator|)
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__change__attrib__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_CHATTR
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_ENHANCED
operator|)
condition|)
block|{
name|no_enhanced
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"enhanced file management not permitted"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CHATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__CHANGE__ATTRIB__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__change__attrib__request
decl_stmt|;
if|if
condition|(
name|fpm2attr
argument_list|(
name|fsb
argument_list|,
name|req
argument_list|,
operator|&
name|ftca
operator|->
name|ftca_attrs
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_present
operator|&
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_novalue
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"attributes can not be changed to no value available"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_STORAGE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
condition|)
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_SECURITY
expr_stmt|;
block|}
name|next
operator|=
name|FTG_DESELECT
operator||
name|FTG_DELETE
operator||
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|(
name|FTG_SELECT
operator||
name|FTG_CREATE
operator|)
condition|?
name|FTG_OPEN
else|:
name|FTG_NULL
operator|)
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__change__attrib__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_CHATTR
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_ENHANCED
operator|)
condition|)
goto|goto
name|no_enhanced
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CHATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__CHANGE__ATTRIB__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__change__attrib__response
decl_stmt|;
name|ftca
operator|->
name|ftca_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|attributes
operator|&&
name|fpm2attr
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|attributes
argument_list|,
operator|&
name|ftca
operator|->
name|ftca_attrs
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_STORAGE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
condition|)
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_SECURITY
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftca
operator|->
name|ftca_diags
argument_list|,
operator|&
name|ftca
operator|->
name|ftca_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_STORAGE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_SECURITY
operator|)
condition|)
name|ftca
operator|->
name|ftca_attrs
operator|.
name|fa_present
operator|&=
operator|~
name|FA_SECURITY
expr_stmt|;
block|}
name|next
operator|=
name|FTG_DESELECT
operator||
name|FTG_DELETE
operator||
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|(
name|FTG_SELECT
operator||
name|FTG_CREATE
operator|)
condition|?
name|FTG_OPEN
else|:
name|FTG_NULL
operator|)
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__open__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_OPEN
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_OPEN
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftg
operator|->
name|ftg_open
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__OPEN__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__open__request
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|processing__mode
condition|)
block|{
if|if
condition|(
name|fpm2bits
argument_list|(
name|fsb
argument_list|,
name|fmode_pairs
argument_list|,
name|req
operator|->
name|processing__mode
argument_list|,
operator|&
name|ftop
operator|->
name|ftop_mode
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
else|else
name|ftop
operator|->
name|ftop_mode
operator|=
name|FA_PERM_READ
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|contents__type
operator|->
name|offset
operator|==
name|choice_FTAM_0_proposed
condition|)
block|{
specifier|register
name|struct
name|type_FTAM_Contents__Type__Attribute
modifier|*
name|proposed
init|=
name|req
operator|->
name|contents__type
operator|->
name|un
operator|.
name|proposed
decl_stmt|;
name|ftop
operator|->
name|ftop_contents
operator|=
name|proposed
operator|->
name|document__type__name
expr_stmt|;
name|proposed
operator|->
name|document__type__name
operator|=
name|NULLOID
expr_stmt|;
if|if
condition|(
name|proposed
operator|->
name|parameter
operator|&&
operator|(
name|ftop
operator|->
name|ftop_parameter
operator|=
name|pe_cpy
argument_list|(
name|proposed
operator|->
name|parameter
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
goto|goto
name|no_mem
goto|;
block|}
name|FCINIT
argument_list|(
operator|&
name|ftop
operator|->
name|ftop_conctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
operator|&&
name|req
operator|->
name|concurrency__control
operator|&&
name|fpm2conctl
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|concurrency__control
argument_list|,
operator|&
name|ftop
operator|->
name|ftop_conctl
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftop
operator|->
name|ftop_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_FADULOCK
condition|)
name|ftop
operator|->
name|ftop_locking
operator|=
name|req
operator|->
name|enable__fadu__locking
expr_stmt|;
block|}
name|next
operator|=
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__open__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_OPEN
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_OPEN
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftg
operator|->
name|ftg_open
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__OPEN__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__open__response
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_Contents__Type__Attribute
modifier|*
name|proposed
init|=
name|rsp
operator|->
name|contents__type
decl_stmt|;
name|ftop
operator|->
name|ftop_state
operator|=
name|rsp
operator|->
name|state__result
condition|?
name|rsp
operator|->
name|state__result
operator|->
name|parm
else|:
name|int_FTAM_State__Result_success
expr_stmt|;
name|ftop
operator|->
name|ftop_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
name|ftop
operator|->
name|ftop_contents
operator|=
name|proposed
operator|->
name|document__type__name
expr_stmt|;
name|proposed
operator|->
name|document__type__name
operator|=
name|NULLOID
expr_stmt|;
if|if
condition|(
name|proposed
operator|->
name|parameter
operator|&&
operator|(
name|ftop
operator|->
name|ftop_parameter
operator|=
name|pe_cpy
argument_list|(
name|proposed
operator|->
name|parameter
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
goto|goto
name|no_mem
goto|;
name|FCINIT
argument_list|(
operator|&
name|ftop
operator|->
name|ftop_conctl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_attrs
operator|&
name|FATTR_STORAGE
operator|)
operator|&&
name|rsp
operator|->
name|concurrency__control
operator|&&
name|fpm2conctl
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|concurrency__control
argument_list|,
operator|&
name|ftop
operator|->
name|ftop_conctl
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftop
operator|->
name|ftop_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftop
operator|->
name|ftop_diags
argument_list|,
operator|&
name|ftop
operator|->
name|ftop_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__close__request
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
goto|goto
name|unexpected_fpdu
goto|;
goto|goto
name|do_close
goto|;
case|case
name|type_FTAM_PDU_f__close__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|do_close
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|&
name|FTG_CLOSE
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CLOSE
expr_stmt|;
block|{
comment|/* F-CLOSE-response is identical... */
specifier|register
name|struct
name|FTAMclose
modifier|*
name|ftcl
init|=
operator|&
name|ftg
operator|->
name|ftg_close
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__CLOSE__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__close__request
decl_stmt|;
name|ftcl
operator|->
name|ftcl_action
operator|=
name|req
operator|->
name|action__result
condition|?
name|req
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftcl
operator|->
name|ftcl_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|diagnostic
argument_list|,
name|ftcl
operator|->
name|ftcl_diags
argument_list|,
operator|&
name|ftcl
operator|->
name|ftcl_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_DESELECT
operator||
name|FTG_DELETE
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__deselect__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_DESELECT
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__DESELECT__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__deselect__request
decl_stmt|;
if|if
condition|(
name|req
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
argument_list|,
operator|&
name|ftde
operator|->
name|ftde_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__deselect__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_DESELECT
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__DESELECT__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__deselect__response
decl_stmt|;
name|ftde
operator|->
name|ftde_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftde
operator|->
name|ftde_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|charging
operator|&&
name|fpm2chrg
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|charging
argument_list|,
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftde
operator|->
name|ftde_diags
argument_list|,
operator|&
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__delete__request
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_LIMITED
operator|)
condition|)
goto|goto
name|no_limited
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DELETE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMdelete
modifier|*
name|ftxe
init|=
operator|&
name|ftg
operator|->
name|ftg_delete
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__DELETE__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__delete__request
decl_stmt|;
if|if
condition|(
name|req
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
argument_list|,
operator|&
name|ftxe
operator|->
name|ftxe_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__delete__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
operator|!
operator|(
name|next
operator|&
name|FTG_DELETE
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_LIMITED
operator|)
condition|)
goto|goto
name|no_limited
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DELETE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMdelete
modifier|*
name|ftxe
init|=
operator|&
name|ftg
operator|->
name|ftg_delete
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__DELETE__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__delete__response
decl_stmt|;
name|ftxe
operator|->
name|ftxe_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftxe
operator|->
name|ftxe_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|charging
operator|&&
name|fpm2chrg
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|charging
argument_list|,
operator|&
name|ftxe
operator|->
name|ftxe_charges
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftxe
operator|->
name|ftxe_diags
argument_list|,
operator|&
name|ftxe
operator|->
name|ftxe_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|FTG_END
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__end__group__request
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
goto|goto
name|unexpected_fpdu
goto|;
goto|goto
name|do_end
goto|;
case|case
name|type_FTAM_PDU_f__end__group__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|do_end
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|&
name|FTG_END
operator|)
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_GROUPING
operator|)
condition|)
goto|goto
name|no_grouping
goto|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_END
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__locate__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_DATAIDLE
operator|||
name|next
operator|!=
name|FTG_BEGIN
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_ACCESS
operator|)
condition|)
block|{
name|no_access
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"file access not permitted"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_ACCESS
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMaccess
modifier|*
name|ftac
init|=
operator|&
name|fti
operator|->
name|fti_access
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__LOCATE__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__locate__request
decl_stmt|;
name|ftac
operator|->
name|ftac_operation
operator|=
name|FA_OPS_LOCATE
expr_stmt|;
if|if
condition|(
name|fpm2faduid
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|file__access__data__unit__identity
argument_list|,
operator|&
name|ftac
operator|->
name|ftac_identity
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|fadu__lock
condition|)
name|ftac
operator|->
name|ftac_locking
operator|=
name|req
operator|->
name|fadu__lock
operator|->
name|parm
expr_stmt|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__locate__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_LOCATE
operator|||
name|next
operator|!=
name|FTG_BEGIN
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_ACCESS
operator|)
condition|)
goto|goto
name|no_access
goto|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_ACCESS
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMaccess
modifier|*
name|ftac
init|=
operator|&
name|fti
operator|->
name|fti_access
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__LOCATE__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__locate__response
decl_stmt|;
name|ftac
operator|->
name|ftac_operation
operator|=
name|FA_OPS_LOCATE
expr_stmt|;
name|ftac
operator|->
name|ftac_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|file__access__data__unit__identity
operator|&&
name|fpm2faduid
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|file__access__data__unit__identity
argument_list|,
operator|&
name|ftac
operator|->
name|ftac_identity
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftac
operator|->
name|ftac_diags
argument_list|,
operator|&
name|ftac
operator|->
name|ftac_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__erase__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_DATAIDLE
operator|||
name|next
operator|!=
name|FTG_BEGIN
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_ACCESS
operator|)
condition|)
goto|goto
name|no_access
goto|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_ACCESS
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMaccess
modifier|*
name|ftac
init|=
operator|&
name|fti
operator|->
name|fti_access
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__ERASE__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__erase__request
decl_stmt|;
name|ftac
operator|->
name|ftac_operation
operator|=
name|FA_OPS_ERASE
expr_stmt|;
if|if
condition|(
name|fpm2faduid
argument_list|(
name|fsb
argument_list|,
name|req
argument_list|,
operator|&
name|ftac
operator|->
name|ftac_identity
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__erase__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_ERASE
operator|||
name|next
operator|!=
name|FTG_BEGIN
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_ACCESS
operator|)
condition|)
goto|goto
name|no_access
goto|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_ACCESS
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMaccess
modifier|*
name|ftac
init|=
operator|&
name|fti
operator|->
name|fti_access
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__ERASE__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__erase__response
decl_stmt|;
name|ftac
operator|->
name|ftac_operation
operator|=
name|FA_OPS_ERASE
expr_stmt|;
name|ftac
operator|->
name|ftac_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftac
operator|->
name|ftac_diags
argument_list|,
operator|&
name|ftac
operator|->
name|ftac_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__read__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|next
operator|!=
name|FTG_BEGIN
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_DATAIDLE
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_READ
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"reading not permitted"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_READWRITE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMreadwrite
modifier|*
name|ftrw
init|=
operator|&
name|fti
operator|->
name|fti_readwrite
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__READ__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__read__request
decl_stmt|;
name|ftrw
operator|->
name|ftrw_operation
operator|=
name|FA_OPS_READ
expr_stmt|;
if|if
condition|(
name|fpm2faduid
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|file__access__data__unit__identity
argument_list|,
operator|&
name|ftrw
operator|->
name|ftrw_identity
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ftrw
operator|->
name|ftrw_context
operator|=
name|req
operator|->
name|access__context
operator|->
name|access__context
operator|)
operator|==
name|FA_ACC_FL
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|access__context
operator|->
name|optionals
operator|&
name|opt_FTAM_Access__Context_level__number
condition|)
name|ftrw
operator|->
name|ftrw_level
operator|=
name|req
operator|->
name|access__context
operator|->
name|level__number
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRMSG
argument_list|,
name|NULLCP
argument_list|,
literal|"level-number missing for access-context FL"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
name|ftrw
operator|->
name|ftrw_level
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_FADULOCK
operator|)
operator|&&
name|req
operator|->
name|fadu__lock
condition|)
name|ftrw
operator|->
name|ftrw_locking
operator|=
name|req
operator|->
name|fadu__lock
operator|->
name|parm
expr_stmt|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__write__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|next
operator|!=
name|FTG_BEGIN
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_DATAIDLE
condition|)
goto|goto
name|unexpected_fpdu
goto|;
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_WRITE
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"writing not permitted"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_READWRITE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMreadwrite
modifier|*
name|ftrw
init|=
operator|&
name|fti
operator|->
name|fti_readwrite
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__WRITE__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__write__request
decl_stmt|;
name|ftrw
operator|->
name|ftrw_operation
operator|=
name|req
operator|->
name|file__access__data__unit__operation
expr_stmt|;
if|if
condition|(
name|fpm2faduid
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|file__access__data__unit__identity
argument_list|,
operator|&
name|ftrw
operator|->
name|ftrw_identity
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_units
operator|&
name|FUNIT_FADULOCK
operator|)
operator|&&
name|req
operator|->
name|fadu__lock
condition|)
name|ftrw
operator|->
name|ftrw_locking
operator|=
name|req
operator|->
name|fadu__lock
operator|->
name|parm
expr_stmt|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__data__end__request
case|:
switch|switch
condition|(
name|fsb
operator|->
name|fsb_state
condition|)
block|{
case|case
name|FSB_DATAREAD
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|)
goto|goto
name|unexpected_data_end
goto|;
break|break;
case|case
name|FSB_DATAWRITE
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
goto|goto
name|unexpected_data_end
goto|;
break|break;
case|case
name|FSB_DATACANCEL
case|:
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"discarding F-DATA-END during CANCEL procedure"
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|free_FTAM_PDU
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
default|default:
name|unexpected_data_end
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected data end; state=0x%x"
argument_list|,
name|fsb
operator|->
name|fsb_state
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|next
operator|!=
name|FTG_BEGIN
condition|)
goto|goto
name|unexpected_data_end
goto|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_DATAEND
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMdataend
modifier|*
name|ftda
init|=
operator|&
name|fti
operator|->
name|fti_dataend
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__DATA__END__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__data__end__request
decl_stmt|;
name|ftda
operator|->
name|ftda_action
operator|=
name|req
operator|->
name|action__result
condition|?
name|req
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|diagnostic
argument_list|,
name|ftda
operator|->
name|ftda_diags
argument_list|,
operator|&
name|ftda
operator|->
name|ftda_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__cancel__request
case|:
switch|switch
condition|(
name|fsb
operator|->
name|fsb_state
condition|)
block|{
case|case
name|FSB_DATAREAD
case|:
case|case
name|FSB_DATAWRITE
case|:
case|case
name|FSB_DATAFIN1
case|:
case|case
name|FSB_DATAFIN2
case|:
break|break;
case|case
name|FSB_DATACANCEL
case|:
name|fsb
operator|->
name|fsb_flags
operator||=
name|FSB_COLLIDE
expr_stmt|;
break|break;
default|default:
goto|goto
name|unexpected_fpdu
goto|;
block|}
goto|goto
name|do_cancel
goto|;
case|case
name|type_FTAM_PDU_f__cancel__response
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_DATACANCEL
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|do_cancel
label|:
empty_stmt|;
if|if
condition|(
name|next
operator|!=
name|FTG_BEGIN
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_CANCEL
expr_stmt|;
block|{
comment|/* F-CANCEL-response is identical... */
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__CANCEL__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__cancel__request
decl_stmt|;
name|ftcn
operator|->
name|ftcn_action
operator|=
name|req
operator|->
name|action__result
condition|?
name|req
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftcn
operator|->
name|ftcn_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|diagnostic
argument_list|,
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
operator|&
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__transfer__end__request
case|:
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|next
operator|!=
name|FTG_BEGIN
condition|)
goto|goto
name|unexpected_fpdu
goto|;
switch|switch
condition|(
name|fsb
operator|->
name|fsb_state
condition|)
block|{
case|case
name|FSB_DATAFIN1
case|:
break|break;
case|case
name|FSB_DATACANCEL
case|:
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"discarding F-TRANSFER-END during CANCEL procedure"
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|free_FTAM_PDU
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
default|default:
goto|goto
name|unexpected_fpdu
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_TRANSEND
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMtransend
modifier|*
name|ftre
init|=
operator|&
name|fti
operator|->
name|fti_transend
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__TRANSFER__END__request
modifier|*
name|req
init|=
name|pdu
operator|->
name|un
operator|.
name|f__transfer__end__request
decl_stmt|;
if|if
condition|(
name|req
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
argument_list|,
operator|&
name|ftre
operator|->
name|ftre_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__transfer__end__response
case|:
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|next
operator|!=
name|FTG_BEGIN
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_DATAFIN2
condition|)
goto|goto
name|unexpected_fpdu
goto|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_TRANSEND
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMtransend
modifier|*
name|ftre
init|=
operator|&
name|fti
operator|->
name|fti_transend
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__TRANSFER__END__response
modifier|*
name|rsp
init|=
name|pdu
operator|->
name|un
operator|.
name|f__transfer__end__response
decl_stmt|;
name|ftre
operator|->
name|ftre_action
operator|=
name|rsp
operator|->
name|action__result
condition|?
name|rsp
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|shared__ASE__information
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|shared__ASE__information
argument_list|,
operator|&
name|ftre
operator|->
name|ftre_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rsp
operator|->
name|diagnostic
operator|&&
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|rsp
operator|->
name|diagnostic
argument_list|,
name|ftre
operator|->
name|ftre_diags
argument_list|,
operator|&
name|ftre
operator|->
name|ftre_ndiag
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
name|next
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|unexpected_fpdu
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"FPDU mismatch; expecting one of 0x%x, found tag %s/%d/0x%x; state=0x%x"
argument_list|,
name|next
argument_list|,
name|pe_classlist
index|[
name|pe
operator|->
name|pe_class
index|]
argument_list|,
name|pe
operator|->
name|pe_form
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|,
name|fsb
operator|->
name|fsb_state
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|free_FTAM_PDU
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
name|pdu
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"missing FPDU(s) in group; expecting one of 0x%x next"
argument_list|,
name|next
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|fti
operator|->
name|fti_type
condition|)
block|{
case|case
name|FTI_ACCESS
case|:
name|fsb
operator|->
name|fsb_state
operator|=
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|?
name|FSB_DATAIDLE
else|:
name|fti
operator|->
name|fti_access
operator|.
name|ftac_operation
operator|==
name|FA_OPS_LOCATE
condition|?
name|FSB_LOCATE
else|:
name|FSB_ERASE
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FTI_READWRITE
case|:
name|fsb
operator|->
name|fsb_state
operator|=
name|fti
operator|->
name|fti_readwrite
operator|.
name|ftrw_operation
operator|==
name|FA_OPS_READ
condition|?
name|FSB_DATAREAD
else|:
name|FSB_DATAWRITE
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FTI_DATAEND
case|:
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_DATAFIN1
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FTI_TRANSEND
case|:
name|fsb
operator|->
name|fsb_state
operator|=
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|?
name|FSB_DATAIDLE
else|:
name|FSB_DATAFIN2
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|FTI_CANCEL
case|:
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_COLLIDE
condition|)
block|{
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"resolving CANCEL collision"
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|FCancelResponseAux
argument_list|(
name|fsb
argument_list|,
name|fsb
operator|->
name|fsb_cancelaction
argument_list|,
name|fsb
operator|->
name|fsb_cancelshared
argument_list|,
name|fsb
operator|->
name|fsb_canceldiags
argument_list|,
name|fsb
operator|->
name|fsb_cancelndiag
argument_list|,
operator|&
name|ftis
argument_list|)
expr_stmt|;
name|fsb
operator|->
name|fsb_flags
operator|&=
operator|~
name|FSB_COLLIDE
expr_stmt|;
name|fsb
operator|->
name|fsb_cancelaction
operator|=
name|FACTION_PERM
expr_stmt|;
if|if
condition|(
name|fsb
operator|->
name|fsb_cancelshared
condition|)
block|{
name|pe_free
argument_list|(
name|fsb
operator|->
name|fsb_cancelshared
argument_list|)
expr_stmt|;
name|fsb
operator|->
name|fsb_cancelshared
operator|=
name|NULLPE
expr_stmt|;
block|}
name|fsb
operator|->
name|fsb_canceldiags
operator|=
name|NULL
expr_stmt|;
name|fsb
operator|->
name|fsb_cancelndiag
operator|=
literal|0
expr_stmt|;
name|FTCNFREE
argument_list|(
operator|&
name|fti
operator|->
name|fti_cancel
argument_list|)
expr_stmt|;
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_CANCEL
condition|)
block|{
name|fsb
operator|->
name|fsb_flags
operator|&=
operator|~
name|FSB_CANCEL
expr_stmt|;
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_DATAIDLE
expr_stmt|;
block|}
else|else
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_DATACANCEL
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
comment|/* a grouped request */
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|&&
name|ftg
operator|->
name|ftg_threshold
operator|!=
name|px
operator|->
name|px_ninfo
operator|-
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"threshold mismatch; expecting %d, found %d"
argument_list|,
name|px
operator|->
name|px_ninfo
operator|-
literal|2
argument_list|,
name|ftg
operator|->
name|ftg_threshold
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|(
name|FTG_SELECT
operator||
name|FTG_CREATE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|?
operator|(
name|fsb
operator|->
name|fsb_state
operator|==
name|FSB_MANAGEMENT
operator|)
else|:
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|(
name|FTG_DESELECT
operator||
name|FTG_DELETE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|)
switch|switch
condition|(
name|fsb
operator|->
name|fsb_class
condition|)
block|{
case|case
name|FCLASS_MANAGE
case|:
case|case
name|FCLASS_TM
case|:
case|case
name|FCLASS_ACCESS
case|:
break|break;
default|default:
goto|goto
name|unexpected_group
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_MANAGEMENT
expr_stmt|;
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
block|{
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|~
name|fsb
operator|->
name|fsb_group
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"management reply mismatch; expecting 0x%x, found 0x%x"
argument_list|,
name|fsb
operator|->
name|fsb_group
argument_list|,
name|ftg
operator|->
name|ftg_flags
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_INITIALIZED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_INITIALIZED
condition|)
goto|goto
name|unexpected_group
goto|;
if|if
condition|(
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
operator|)
condition|?
name|ftg
operator|->
name|ftg_select
operator|.
name|ftse_account
else|:
name|ftg
operator|->
name|ftg_create
operator|.
name|ftce_account
condition|)
name|fsb
operator|->
name|fsb_flags
operator||=
name|FSB_DECHARGE
expr_stmt|;
else|else
name|fsb
operator|->
name|fsb_flags
operator|&=
operator|~
name|FSB_DECHARGE
expr_stmt|;
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_MANAGEMENT
expr_stmt|;
name|fsb
operator|->
name|fsb_group
operator|=
name|ftg
operator|->
name|ftg_flags
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|?
operator|(
name|fsb
operator|->
name|fsb_state
operator|==
name|FSB_BULKBEGIN
operator|)
else|:
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_OPEN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
condition|)
switch|switch
condition|(
name|fsb
operator|->
name|fsb_class
condition|)
block|{
case|case
name|FCLASS_TRANSFER
case|:
case|case
name|FCLASS_TM
case|:
case|case
name|FCLASS_ACCESS
case|:
break|break;
default|default:
goto|goto
name|unexpected_group
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_BULKBEGIN
expr_stmt|;
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
block|{
name|int
name|state
decl_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|~
name|fsb
operator|->
name|fsb_group
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"bulk transfer reply mismatch; expecting 0x%x found 0x%x"
argument_list|,
name|fsb
operator|->
name|fsb_group
argument_list|,
name|ftg
operator|->
name|ftg_flags
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
name|state
operator|=
name|ftg
operator|->
name|ftg_select
operator|.
name|ftse_state
expr_stmt|;
else|else
name|state
operator|=
name|ftg
operator|->
name|ftg_create
operator|.
name|ftce_state
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|FSTATE_SUCCESS
operator|||
name|ftg
operator|->
name|ftg_open
operator|.
name|ftop_state
operator|!=
name|FSTATE_SUCCESS
condition|)
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_INITIALIZED
expr_stmt|;
else|else
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_DATAIDLE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_INITIALIZED
condition|)
goto|goto
name|unexpected_group
goto|;
if|if
condition|(
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
operator|)
condition|?
name|ftg
operator|->
name|ftg_select
operator|.
name|ftse_account
else|:
name|ftg
operator|->
name|ftg_create
operator|.
name|ftce_account
condition|)
name|fsb
operator|->
name|fsb_flags
operator||=
name|FSB_DECHARGE
expr_stmt|;
else|else
name|fsb
operator|->
name|fsb_flags
operator|&=
operator|~
name|FSB_DECHARGE
expr_stmt|;
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_BULKBEGIN
expr_stmt|;
name|fsb
operator|->
name|fsb_group
operator|=
name|ftg
operator|->
name|ftg_flags
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
goto|goto
name|unexpected_group
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CLOSE
condition|)
block|{
switch|switch
condition|(
name|fsb
operator|->
name|fsb_class
condition|)
block|{
case|case
name|FCLASS_TRANSFER
case|:
case|case
name|FCLASS_TM
case|:
case|case
name|FCLASS_ACCESS
case|:
break|break;
default|default:
goto|goto
name|unexpected_group
goto|;
block|}
name|fti
operator|->
name|fti_type
operator|=
name|FTI_BULKEND
expr_stmt|;
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
block|{
if|if
condition|(
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_BULKEND
condition|)
goto|goto
name|unexpected_group
goto|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
operator|~
name|fsb
operator|->
name|fsb_group
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"bulk transfer reply mismatch; expecting 0x%x found 0x%x"
argument_list|,
name|fsb
operator|->
name|fsb_group
argument_list|,
name|ftg
operator|->
name|ftg_flags
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_INITIALIZED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_DATAIDLE
condition|)
goto|goto
name|unexpected_group
goto|;
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_BULKEND
expr_stmt|;
name|fsb
operator|->
name|fsb_group
operator|=
name|ftg
operator|->
name|ftg_flags
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|unexpected_group
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected group type 0x%x; state=0x%x"
argument_list|,
name|ftg
operator|->
name|ftg_flags
argument_list|,
name|fsb
operator|->
name|fsb_state
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
name|done
label|:
empty_stmt|;
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|pdu
condition|)
name|free_FTAM_PDU
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fti
operator|->
name|fti_type
condition|)
block|{
case|case
name|FTI_ACCESS
case|:
name|FTACFREE
argument_list|(
operator|&
name|fti
operator|->
name|fti_access
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_READWRITE
case|:
name|FTRWFREE
argument_list|(
operator|&
name|fti
operator|->
name|fti_readwrite
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_TRANSEND
case|:
name|FTREFREE
argument_list|(
operator|&
name|fti
operator|->
name|fti_transend
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_CANCEL
case|:
name|FTCNFREE
argument_list|(
operator|&
name|fti
operator|->
name|fti_cancel
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_FINISH
case|:
case|case
name|FTI_MANAGEMENT
case|:
case|case
name|FTI_BULKBEGIN
case|:
case|case
name|FTI_BULKEND
case|:
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doPStokens
parameter_list|(
name|fsb
parameter_list|,
name|pt
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|PSAPtoken
modifier|*
name|pt
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected token indication (0x%x)"
argument_list|,
name|pt
operator|->
name|pt_type
argument_list|)
expr_stmt|;
name|PTFREE
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doPSsync
parameter_list|(
name|fsb
parameter_list|,
name|pn
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|PSAPsync
modifier|*
name|pn
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|PSAPdata
name|pxs
decl_stmt|;
specifier|register
name|struct
name|PSAPdata
modifier|*
name|px
init|=
operator|&
name|pxs
decl_stmt|;
switch|switch
condition|(
name|pn
operator|->
name|pn_type
condition|)
block|{
case|case
name|SN_RESETCNF
case|:
break|break;
case|case
name|SN_RESETIND
case|:
if|if
condition|(
name|pn
operator|->
name|pn_options
operator|==
name|SYNC_ABANDON
condition|)
break|break;
comment|/* else fall */
default|default:
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected sync indication (0x%x)"
argument_list|,
name|pn
operator|->
name|pn_type
argument_list|)
expr_stmt|;
name|PNFREE
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|fsb
operator|->
name|fsb_settings
operator|=
name|pn
operator|->
name|pn_settings
expr_stmt|;
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \     if (fsb -> fsb_srequirements& requires) \ 	switch (fsb -> fsb_settings& (ST_MASK<< shift)) { \ 	    default: \ 		fsb -> fsb_settings&= ~(ST_MASK<< shift); \ 		fsb -> fsb_settings |= ST_INIT_VALUE<< shift; \  \ 	    case ST_INIT_VALUE<< shift: \ 		fsb -> fsb_owned |= bit; \ 		fsb -> fsb_avail |= bit; \ 		break; \  \ 	    case ST_RESP_VALUE<< shift: \ 		fsb -> fsb_avail |= bit; \ 		break; \ 	} \ }
name|dotokens
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dotoken
if|if
condition|(
name|pn
operator|->
name|pn_type
operator|==
name|SN_RESETCNF
operator|&&
name|pn
operator|->
name|pn_ninfo
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftcn
argument_list|,
sizeof|sizeof
expr|*
name|ftcn
argument_list|)
expr_stmt|;
name|ftcn
operator|->
name|ftcn_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
comment|/* what else can be done? */
name|fsb
operator|->
name|fsb_flags
operator|&=
operator|~
name|FSB_CANCEL
expr_stmt|;
name|fsb
operator|->
name|fsb_state
operator|=
name|FSB_DATAIDLE
expr_stmt|;
name|PNFREE
argument_list|(
name|pn
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|px
argument_list|,
sizeof|sizeof
expr|*
name|px
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pn
operator|->
name|pn_ninfo
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|px
operator|->
name|px_info
index|[
name|i
index|]
operator|=
name|pn
operator|->
name|pn_info
index|[
name|i
index|]
expr_stmt|;
name|pn
operator|->
name|pn_info
index|[
name|i
index|]
operator|=
name|NULLPE
expr_stmt|;
block|}
name|px
operator|->
name|px_ninfo
operator|=
name|pn
operator|->
name|pn_ninfo
expr_stmt|;
name|PNFREE
argument_list|(
name|pn
argument_list|)
expr_stmt|;
return|return
name|doPSdata
argument_list|(
name|fsb
argument_list|,
name|px
argument_list|,
name|fti
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doPSactivity
parameter_list|(
name|fsb
parameter_list|,
name|pv
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|PSAPactivity
modifier|*
name|pv
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected activity indication (0x%x)"
argument_list|,
name|pv
operator|->
name|pv_type
argument_list|)
expr_stmt|;
name|PVFREE
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doPSreport
parameter_list|(
name|fsb
parameter_list|,
name|pp
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|PSAPreport
modifier|*
name|pp
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected exception report indication (0x%x)"
argument_list|,
name|pp
operator|->
name|pp_peer
argument_list|)
expr_stmt|;
name|PPFREE
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doPSfinish
parameter_list|(
name|fsb
parameter_list|,
name|pf
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|PSAPfinish
modifier|*
name|pf
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
name|PE
name|pe
decl_stmt|;
name|struct
name|AcSAPindication
name|acis
decl_stmt|;
specifier|register
name|struct
name|AcSAPabort
modifier|*
name|aca
init|=
operator|&
name|acis
operator|.
name|aci_abort
decl_stmt|;
specifier|register
name|struct
name|AcSAPfinish
modifier|*
name|acf
init|=
operator|&
name|acis
operator|.
name|aci_finish
decl_stmt|;
name|struct
name|type_FTAM_PDU
modifier|*
name|pdu
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__TERMINATE__request
modifier|*
name|req
decl_stmt|;
name|pdu
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
operator|)
operator|||
name|fsb
operator|->
name|fsb_state
operator|!=
name|FSB_INITIALIZED
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_ACS_MGMT
argument_list|,
name|NULLCP
argument_list|,
literal|"association management botched"
argument_list|)
expr_stmt|;
name|PFFREE
argument_list|(
name|pf
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|AcFINISHser
argument_list|(
name|fsb
operator|->
name|fsb_fd
argument_list|,
name|pf
argument_list|,
operator|&
name|acis
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|acs2ftamlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
literal|"AcFINISHser"
argument_list|,
name|aca
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|acf
operator|->
name|acf_ninfo
operator|<
literal|1
operator|||
operator|(
name|pe
operator|=
name|acf
operator|->
name|acf_info
index|[
literal|0
index|]
operator|)
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
name|decode_FTAM_PDU
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|pdu
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRMSG
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to parse PDU: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
name|pdu
operator|->
name|offset
operator|!=
name|type_FTAM_PDU_f__terminate__request
condition|)
block|{
operator|(
name|void
operator|)
name|fpktlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
name|NULLCP
argument_list|,
literal|"expecting F-TERMINATE-request, got %d"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
name|req
operator|=
name|pdu
operator|->
name|un
operator|.
name|f__terminate__request
expr_stmt|;
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"A-RELEASE.INDICATION"
operator|,
literal|"F-TERMINATE-request"
operator|,
name|pe
operator|,
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ACFFREE
argument_list|(
name|acf
argument_list|)
expr_stmt|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_FINISH
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMfinish
modifier|*
name|ftf
init|=
operator|&
name|fti
operator|->
name|fti_finish
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftf
argument_list|,
sizeof|sizeof
expr|*
name|ftf
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|&&
name|fpm2shared
argument_list|(
name|fsb
argument_list|,
name|req
argument_list|,
operator|&
name|ftf
operator|->
name|ftf_sharedASE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out2
goto|;
block|}
name|fsb
operator|->
name|fsb_flags
operator||=
name|FSB_FINN
expr_stmt|;
name|free_FTAM_PDU
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
name|out2
label|:
empty_stmt|;
name|ACFFREE
argument_list|(
name|acf
argument_list|)
expr_stmt|;
name|out1
label|:
empty_stmt|;
if|if
condition|(
name|pdu
condition|)
name|free_FTAM_PDU
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doPSabort
parameter_list|(
name|fsb
parameter_list|,
name|pa
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|PSAPabort
modifier|*
name|pa
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
name|struct
name|AcSAPindication
name|acis
decl_stmt|;
specifier|register
name|struct
name|AcSAPabort
modifier|*
name|aca
init|=
operator|&
name|acis
operator|.
name|aci_abort
decl_stmt|;
if|if
condition|(
operator|!
name|pa
operator|->
name|pa_peer
operator|&&
name|pa
operator|->
name|pa_reason
operator|==
name|PC_TIMER
condition|)
return|return
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_PRO_TIMEOUT
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
if|if
condition|(
name|AcABORTser
argument_list|(
name|fsb
operator|->
name|fsb_fd
argument_list|,
name|pa
argument_list|,
operator|&
name|acis
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|acs2ftamlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
literal|"AcABORTser"
argument_list|,
name|aca
argument_list|)
expr_stmt|;
name|fsb
operator|->
name|fsb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|acs2ftamabort
argument_list|(
name|fsb
argument_list|,
name|aca
argument_list|,
name|fti
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|psDATAser
parameter_list|(
name|sd
parameter_list|,
name|px
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|PSAPdata
modifier|*
name|px
decl_stmt|;
block|{
name|IFP
name|handler
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|=
name|findfsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|handler
operator|=
name|fsb
operator|->
name|fsb_indication
expr_stmt|;
if|if
condition|(
name|doPSdata
argument_list|(
name|fsb
argument_list|,
name|px
argument_list|,
name|fti
argument_list|)
operator|!=
name|OK
condition|)
call|(
modifier|*
name|handler
call|)
argument_list|(
name|sd
argument_list|,
name|fti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|psTOKENser
parameter_list|(
name|sd
parameter_list|,
name|pt
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|PSAPtoken
modifier|*
name|pt
decl_stmt|;
block|{
name|IFP
name|handler
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|=
name|findfsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|handler
operator|=
name|fsb
operator|->
name|fsb_indication
expr_stmt|;
if|if
condition|(
name|doPStokens
argument_list|(
name|fsb
argument_list|,
name|pt
argument_list|,
name|fti
argument_list|)
operator|!=
name|OK
condition|)
call|(
modifier|*
name|handler
call|)
argument_list|(
name|sd
argument_list|,
name|fti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|psSYNCser
parameter_list|(
name|sd
parameter_list|,
name|pn
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|PSAPsync
modifier|*
name|pn
decl_stmt|;
block|{
name|IFP
name|handler
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|=
name|findfsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|handler
operator|=
name|fsb
operator|->
name|fsb_indication
expr_stmt|;
if|if
condition|(
name|doPSsync
argument_list|(
name|fsb
argument_list|,
name|pn
argument_list|,
name|fti
argument_list|)
operator|!=
name|OK
condition|)
call|(
modifier|*
name|handler
call|)
argument_list|(
name|sd
argument_list|,
name|fti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|psACTIVITYser
parameter_list|(
name|sd
parameter_list|,
name|pv
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|PSAPactivity
modifier|*
name|pv
decl_stmt|;
block|{
name|IFP
name|handler
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|=
name|findfsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|handler
operator|=
name|fsb
operator|->
name|fsb_indication
expr_stmt|;
if|if
condition|(
name|doPSactivity
argument_list|(
name|fsb
argument_list|,
name|pv
argument_list|,
name|fti
argument_list|)
operator|!=
name|OK
condition|)
call|(
modifier|*
name|handler
call|)
argument_list|(
name|sd
argument_list|,
name|fti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|psREPORTser
parameter_list|(
name|sd
parameter_list|,
name|pp
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|PSAPreport
modifier|*
name|pp
decl_stmt|;
block|{
name|IFP
name|handler
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|=
name|findfsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|handler
operator|=
name|fsb
operator|->
name|fsb_indication
expr_stmt|;
if|if
condition|(
name|doPSreport
argument_list|(
name|fsb
argument_list|,
name|pp
argument_list|,
name|fti
argument_list|)
operator|!=
name|OK
condition|)
call|(
modifier|*
name|handler
call|)
argument_list|(
name|sd
argument_list|,
name|fti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|psFINISHser
parameter_list|(
name|sd
parameter_list|,
name|pf
parameter_list|)
name|int
name|sd
decl_stmt|;
name|struct
name|PSAPfinish
modifier|*
name|pf
decl_stmt|;
block|{
name|IFP
name|handler
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|=
name|findfsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|handler
operator|=
name|fsb
operator|->
name|fsb_indication
expr_stmt|;
if|if
condition|(
name|doPSfinish
argument_list|(
name|fsb
argument_list|,
name|pf
argument_list|,
name|fti
argument_list|)
operator|!=
name|OK
condition|)
call|(
modifier|*
name|handler
call|)
argument_list|(
name|sd
argument_list|,
name|fti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|psABORTser
parameter_list|(
name|sd
parameter_list|,
name|pa
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|PSAPabort
modifier|*
name|pa
decl_stmt|;
block|{
name|IFP
name|handler
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|fsb
operator|=
name|findfsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|handler
operator|=
name|fsb
operator|->
name|fsb_indication
expr_stmt|;
if|if
condition|(
name|doPSabort
argument_list|(
name|fsb
argument_list|,
name|pa
argument_list|,
name|fti
argument_list|)
operator|!=
name|OK
condition|)
call|(
modifier|*
name|handler
call|)
argument_list|(
name|sd
argument_list|,
name|fti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|define vector for INDICATION events */
end_comment

begin_define
define|#
directive|define
name|e
parameter_list|(
name|i
parameter_list|)
value|(indication ? (i) : NULLIFP)
end_define

begin_function
name|int
name|FSetIndications
parameter_list|(
name|sd
parameter_list|,
name|indication
parameter_list|,
name|fti
parameter_list|)
name|int
name|sd
decl_stmt|;
name|IFP
name|indication
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|PSAPindication
name|pis
decl_stmt|;
specifier|register
name|struct
name|PSAPabort
modifier|*
name|pa
init|=
operator|&
name|pis
operator|.
name|pi_abort
decl_stmt|;
name|missingP
argument_list|(
name|fti
argument_list|)
expr_stmt|;
name|_iosignals_set
operator|=
literal|1
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|ftamPsig
argument_list|(
name|fsb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsb
operator|->
name|fsb_indication
operator|=
name|indication
condition|)
name|fsb
operator|->
name|fsb_flags
operator||=
name|FSB_ASYN
expr_stmt|;
else|else
name|fsb
operator|->
name|fsb_flags
operator|&=
operator|~
name|FSB_ASYN
expr_stmt|;
if|if
condition|(
name|PSetIndications
argument_list|(
name|fsb
operator|->
name|fsb_fd
argument_list|,
name|e
argument_list|(
name|psDATAser
argument_list|)
argument_list|,
name|e
argument_list|(
name|psTOKENser
argument_list|)
argument_list|,
name|e
argument_list|(
name|psSYNCser
argument_list|)
argument_list|,
name|e
argument_list|(
name|psACTIVITYser
argument_list|)
argument_list|,
name|e
argument_list|(
name|psREPORTser
argument_list|)
argument_list|,
name|e
argument_list|(
name|psFINISHser
argument_list|)
argument_list|,
name|e
argument_list|(
name|psABORTser
argument_list|)
argument_list|,
operator|&
name|pis
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|fsb
operator|->
name|fsb_flags
operator|&=
operator|~
name|FSB_ASYN
expr_stmt|;
switch|switch
condition|(
name|pa
operator|->
name|pa_reason
condition|)
block|{
case|case
name|PC_WAITING
case|:
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN_WAITING
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
default|default:
operator|(
name|void
operator|)
name|ps2ftamlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
literal|"PSetIndications"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|e
end_undef

begin_comment
comment|/*
comment|AcSAP interface */
end_comment

begin_function
name|int
name|acs2ftamlose
parameter_list|(
name|fsb
parameter_list|,
name|fti
parameter_list|,
name|event
parameter_list|,
name|aca
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|AcSAPabort
modifier|*
name|aca
decl_stmt|;
block|{
name|int
name|observer
decl_stmt|,
name|reason
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|fsb
operator|&&
name|fsb
operator|->
name|fsb_trace
operator|&&
name|event
condition|)
block|{
name|cp
operator|=
name|buffer
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s: %s"
argument_list|,
name|event
argument_list|,
name|AcErrString
argument_list|(
name|aca
operator|->
name|aca_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aca
operator|->
name|aca_cc
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" [%*.*s]"
argument_list|,
name|aca
operator|->
name|aca_cc
argument_list|,
name|aca
operator|->
name|aca_cc
argument_list|,
name|aca
operator|->
name|aca_data
argument_list|)
expr_stmt|;
block|}
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
name|buffer
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|aca
operator|->
name|aca_reason
condition|)
block|{
case|case
name|ACS_ADDRESS
case|:
name|reason
operator|=
name|FS_PRO_LOWADDR
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|" (%s)"
argument_list|,
name|AcErrString
argument_list|(
name|ACS_ADDRESS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACS_REFUSED
case|:
name|reason
operator|=
name|FS_PRO_LOWFAIL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|" (%s)"
argument_list|,
name|AcErrString
argument_list|(
name|ACS_REFUSED
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|" (%s at association control)"
argument_list|,
name|AcErrString
argument_list|(
name|aca
operator|->
name|aca_reason
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|ACS_CONGEST
case|:
case|case
name|ACS_PARAMETER
case|:
case|case
name|ACS_OPERATION
case|:
case|case
name|ACS_PRESENTATION
case|:
name|reason
operator|=
name|FS_PRO_LOWFAIL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fsb
condition|)
block|{
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
name|observer
operator|=
name|EREF_IFPM
expr_stmt|;
else|else
name|observer
operator|=
name|EREF_RFPM
expr_stmt|;
block|}
else|else
name|observer
operator|=
name|EREF_NONE
expr_stmt|;
if|if
condition|(
name|aca
operator|->
name|aca_cc
operator|>
literal|0
condition|)
return|return
name|ftamoops
argument_list|(
name|fti
argument_list|,
name|reason
argument_list|,
name|ACS_FATAL
argument_list|(
name|aca
operator|->
name|aca_reason
argument_list|)
argument_list|,
name|observer
argument_list|,
name|EREF_NONE
argument_list|,
name|NULLCP
argument_list|,
literal|"%*.*s%s"
argument_list|,
name|aca
operator|->
name|aca_cc
argument_list|,
name|aca
operator|->
name|aca_cc
argument_list|,
name|aca
operator|->
name|aca_data
argument_list|,
name|cp
argument_list|)
return|;
else|else
return|return
name|ftamoops
argument_list|(
name|fti
argument_list|,
name|reason
argument_list|,
name|ACS_FATAL
argument_list|(
name|aca
operator|->
name|aca_reason
argument_list|)
argument_list|,
name|observer
argument_list|,
name|EREF_NONE
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|cp
condition|?
name|cp
operator|+
literal|1
else|:
name|cp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|acs2ftamabort
parameter_list|(
name|fsb
parameter_list|,
name|aca
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|AcSAPabort
modifier|*
name|aca
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
name|int
name|peer
decl_stmt|;
name|PE
name|pe
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
name|struct
name|type_FTAM_PDU
modifier|*
name|pdu
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_F__U__ABORT__request
modifier|*
name|req
decl_stmt|;
name|pdu
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|aca
operator|->
name|aca_source
operator|!=
name|ACA_USER
condition|)
block|{
operator|(
name|void
operator|)
name|acs2ftamlose
argument_list|(
name|fsb
argument_list|,
name|fti
argument_list|,
name|NULLCP
argument_list|,
name|aca
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|aca
operator|->
name|aca_ninfo
operator|<
literal|1
operator|||
operator|(
name|pe
operator|=
name|aca
operator|->
name|aca_info
index|[
literal|0
index|]
operator|)
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_PRO_ERR
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|decode_FTAM_PDU
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|pdu
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_PRO_ERRMSG
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to parse PDU: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|pdu
operator|->
name|offset
condition|)
block|{
case|case
name|type_FTAM_PDU_f__u__abort__request
case|:
name|peer
operator|=
literal|1
expr_stmt|;
name|req
operator|=
name|pdu
operator|->
name|un
operator|.
name|f__u__abort__request
expr_stmt|;
break|break;
case|case
name|type_FTAM_PDU_f__p__abort__request
case|:
name|peer
operator|=
literal|0
expr_stmt|;
comment|/* F-P-ABORT-request is identical... */
name|req
operator|=
name|pdu
operator|->
name|un
operator|.
name|f__u__abort__request
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_PRO_ERRPROC
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
literal|"expecting F-{U,P}-ABORT-request, got %d"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"A-ABORT.INDICATION"
operator|,
name|pdu
operator|->
name|offset
operator|!=
name|type_FTAM_PDU_f__u__abort__request
condition|?
literal|"F-P-ABORT-request"
else|:
literal|"F-U-ABORT-request"
operator|,
name|pe
operator|,
literal|1
operator|)
argument_list|)
expr_stmt|;
name|fti
operator|->
name|fti_type
operator|=
name|FTI_ABORT
expr_stmt|;
name|fta
operator|->
name|fta_peer
operator|=
name|peer
expr_stmt|;
name|fta
operator|->
name|fta_action
operator|=
name|req
operator|->
name|action__result
condition|?
name|req
operator|->
name|action__result
operator|->
name|parm
else|:
name|int_FTAM_Action__Result_success
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|diagnostic
condition|)
operator|(
name|void
operator|)
name|fpm2diag
argument_list|(
name|fsb
argument_list|,
name|req
operator|->
name|diagnostic
argument_list|,
name|fta
operator|->
name|fta_diags
argument_list|,
operator|&
name|fta
operator|->
name|fta_ndiag
argument_list|,
name|fti
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
name|ACAFREE
argument_list|(
name|aca
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdu
condition|)
name|free_FTAM_PDU
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
name|fsb
operator|->
name|fsb_fd
operator|=
name|NOTOK
expr_stmt|;
name|freefsblk
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|PSAP interface */
end_comment

begin_function
name|int
name|ps2ftamlose
parameter_list|(
name|fsb
parameter_list|,
name|fti
parameter_list|,
name|event
parameter_list|,
name|pa
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|PSAPabort
modifier|*
name|pa
decl_stmt|;
block|{
name|int
name|observer
decl_stmt|,
name|reason
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|fsb
operator|&&
name|fsb
operator|->
name|fsb_trace
operator|&&
name|event
condition|)
block|{
name|cp
operator|=
name|buffer
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s: %s"
argument_list|,
name|event
argument_list|,
name|PErrString
argument_list|(
name|pa
operator|->
name|pa_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|pa_cc
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" [%*.*s]"
argument_list|,
name|pa
operator|->
name|pa_cc
argument_list|,
name|pa
operator|->
name|pa_cc
argument_list|,
name|pa
operator|->
name|pa_data
argument_list|)
expr_stmt|;
block|}
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
name|buffer
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|pa
operator|->
name|pa_reason
condition|)
block|{
case|case
name|PC_PARAMETER
case|:
case|case
name|PC_OPERATION
case|:
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|" (%s at presentation)"
argument_list|,
name|PErrString
argument_list|(
name|pa
operator|->
name|pa_reason
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|PC_CONGEST
case|:
case|case
name|PC_SESSION
case|:
name|reason
operator|=
name|FS_PRO_LOWFAIL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fsb
condition|)
block|{
if|if
condition|(
name|fsb
operator|->
name|fsb_flags
operator|&
name|FSB_INIT
condition|)
name|observer
operator|=
name|EREF_IFPM
expr_stmt|;
else|else
name|observer
operator|=
name|EREF_RFPM
expr_stmt|;
block|}
else|else
name|observer
operator|=
name|EREF_NONE
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|pa_cc
operator|>
literal|0
condition|)
return|return
name|ftamoops
argument_list|(
name|fti
argument_list|,
name|reason
argument_list|,
name|PC_FATAL
argument_list|(
name|pa
operator|->
name|pa_reason
argument_list|)
argument_list|,
name|observer
argument_list|,
name|EREF_NONE
argument_list|,
name|NULLCP
argument_list|,
literal|"%*.*s%s"
argument_list|,
name|pa
operator|->
name|pa_cc
argument_list|,
name|pa
operator|->
name|pa_cc
argument_list|,
name|pa
operator|->
name|pa_data
argument_list|,
name|cp
argument_list|)
return|;
else|else
return|return
name|ftamoops
argument_list|(
name|fti
argument_list|,
name|reason
argument_list|,
name|PC_FATAL
argument_list|(
name|pa
operator|->
name|pa_reason
argument_list|)
argument_list|,
name|observer
argument_list|,
name|EREF_NONE
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|cp
condition|?
name|cp
operator|+
literal|1
else|:
name|cp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|INTERNAL */
end_comment

begin_function
name|struct
name|ftamblk
modifier|*
name|newfsblk
parameter_list|()
block|{
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
name|fsb
operator|=
operator|(
expr|struct
name|ftamblk
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fsb
operator|->
name|fsb_fd
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|FSHead
operator|->
name|fsb_forw
operator|=
name|FSHead
operator|->
name|fsb_back
operator|=
name|FSHead
expr_stmt|;
name|once_only
operator|++
expr_stmt|;
block|}
name|insque
argument_list|(
name|fsb
argument_list|,
name|FSHead
operator|->
name|fsb_back
argument_list|)
expr_stmt|;
return|return
name|fsb
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|freefsblk
argument_list|(
name|fsb
argument_list|)
specifier|register
expr|struct
name|ftamblk
operator|*
name|fsb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|PSAPcontext
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|FTAMcontent
modifier|*
name|fcont
decl_stmt|;
if|if
condition|(
name|fsb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|fsb
operator|->
name|fsb_fd
operator|!=
name|NOTOK
condition|)
block|{
name|struct
name|AcSAPindication
name|acis
decl_stmt|;
name|fsbtrace
argument_list|(
name|fsb
argument_list|,
operator|(
name|fsb
operator|->
name|fsb_fd
operator|,
literal|"A-ABORT.REQUEST(discard)"
operator|,
name|NULLCP
operator|,
name|NULLPE
operator|,
literal|0
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AcUAbortRequest
argument_list|(
name|fsb
operator|->
name|fsb_fd
argument_list|,
name|NULLPEP
argument_list|,
literal|0
argument_list|,
operator|&
name|acis
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsb
operator|->
name|fsb_context
condition|)
name|oid_free
argument_list|(
name|fsb
operator|->
name|fsb_context
argument_list|)
operator|,
name|fsb
operator|->
name|fsb_context
operator|=
name|NULLOID
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|fsb
operator|->
name|fsb_contexts
operator|.
name|pc_ctx
operator|,
name|i
operator|=
name|fsb
operator|->
name|fsb_contexts
operator|.
name|pc_nctx
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|pp
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|pc_asn
condition|)
name|oid_free
argument_list|(
name|pp
operator|->
name|pc_asn
argument_list|)
expr_stmt|;
block|}
name|fsb
operator|->
name|fsb_contexts
operator|.
name|pc_nctx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcont
operator|=
name|fsb
operator|->
name|fsb_contents
operator|.
name|fc_contents
operator|,
name|i
operator|=
name|fsb
operator|->
name|fsb_contents
operator|.
name|fc_ncontent
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|fcont
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fcont
operator|->
name|fc_dtn
condition|)
name|oid_free
argument_list|(
name|fcont
operator|->
name|fc_dtn
argument_list|)
expr_stmt|;
block|}
name|fsb
operator|->
name|fsb_contents
operator|.
name|fc_ncontent
operator|=
literal|0
expr_stmt|;
name|PXFREE
argument_list|(
operator|&
name|fsb
operator|->
name|fsb_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsb
operator|->
name|fsb_cancelshared
condition|)
name|pe_free
argument_list|(
name|fsb
operator|->
name|fsb_cancelshared
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|fsb
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fsb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|struct
name|ftamblk
modifier|*
name|findfsblk
parameter_list|(
name|sd
parameter_list|)
specifier|register
name|int
name|sd
decl_stmt|;
block|{
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|fsb
operator|=
name|FSHead
operator|->
name|fsb_forw
init|;
name|fsb
operator|!=
name|FSHead
condition|;
name|fsb
operator|=
name|fsb
operator|->
name|fsb_forw
control|)
if|if
condition|(
name|fsb
operator|->
name|fsb_fd
operator|==
name|sd
condition|)
return|return
name|fsb
return|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

