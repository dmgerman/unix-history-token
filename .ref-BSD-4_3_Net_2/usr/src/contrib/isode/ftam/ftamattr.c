begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftamattr.c - FPM: encode/decode attributes */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam/RCS/ftamattr.c,v 7.3 91/02/22 09:22:37 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam/RCS/ftamattr.c,v 7.3 91/02/22 09:22:37 mrose Interim $  *  *  * $Log:	ftamattr.c,v $  * Revision 7.3  91/02/22  09:22:37  mrose  * Interim 6.8  *   * Revision 7.2  90/10/23  20:41:27  mrose  * update  *   * Revision 7.1  90/03/23  10:53:58  mrose  * update  *   * Revision 7.0  89/11/23  21:53:23  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"fpkt.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|struct
name|type_FTAM_Read__Attributes
modifier|*
name|attr2fpm
parameter_list|(
name|fsb
parameter_list|,
name|fa
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_Read__Attributes
modifier|*
name|fpm
decl_stmt|;
if|if
condition|(
operator|(
name|fpm
operator|=
operator|(
expr|struct
name|type_FTAM_Read__Attributes
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fpm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|fpm
condition|)
name|free_FTAM_Read__Attributes
argument_list|(
name|fpm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_FILENAME
condition|)
block|{
specifier|register
name|struct
name|type_FTAM_Filename__Attribute
modifier|*
name|fn
decl_stmt|,
modifier|*
modifier|*
name|fc
decl_stmt|;
if|if
condition|(
name|fa
operator|->
name|fa_novalue
operator|&
name|FA_FILENAME
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"filename not present"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fa
operator|->
name|fa_nfile
operator|>
name|NFFILE
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"too many filenames"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fc
operator|=
operator|&
name|fpm
operator|->
name|filename
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|fa
operator|->
name|fa_files
operator|,
name|i
operator|=
name|fa
operator|->
name|fa_nfile
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|ap
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"empty filename at slot %d"
argument_list|,
name|fa
operator|->
name|fa_nfile
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fn
operator|=
operator|(
expr|struct
name|type_FTAM_Filename__Attribute
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fpm
operator|->
name|filename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
operator|*
name|fc
operator|=
name|fn
expr_stmt|;
if|if
condition|(
operator|(
name|fn
operator|->
name|GraphicString
operator|=
name|str2qb
argument_list|(
operator|*
name|ap
argument_list|,
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|fc
operator|=
operator|&
operator|(
operator|(
operator|*
name|fc
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_ACTIONS
condition|)
block|{
if|if
condition|(
name|fa
operator|->
name|fa_novalue
operator|&
name|FA_ACTIONS
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"permitted-actions not present"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fpm
operator|->
name|permitted__actions
operator|=
name|bits2fpm
argument_list|(
name|fsb
argument_list|,
name|fpermitted_pairs
argument_list|,
name|fa
operator|->
name|fa_permitted
argument_list|,
name|fti
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_CONTENTS
condition|)
block|{
if|if
condition|(
name|fa
operator|->
name|fa_novalue
operator|&
name|FA_CONTENTS
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"contents-type not present"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fa
operator|->
name|fa_contents
operator|==
name|NULLOID
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"missing contents-type"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fpm
operator|->
name|contents__type
operator|=
operator|(
expr|struct
name|type_FTAM_Contents__Type__Attribute
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fpm
operator|->
name|contents__type
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|fpm
operator|->
name|contents__type
operator|->
name|document__type__name
operator|=
name|oid_cpy
argument_list|(
name|fa
operator|->
name|fa_contents
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|fpm
operator|->
name|contents__type
operator|->
name|parameter
operator|=
name|fa
operator|->
name|fa_parameter
condition|)
name|fpm
operator|->
name|contents__type
operator|->
name|parameter
operator|->
name|pe_refcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_ACCOUNT
condition|)
block|{
if|if
condition|(
name|fa
operator|->
name|fa_account
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"missing account"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fpm
operator|->
name|storage__account
operator|=
operator|(
expr|struct
name|type_FTAM_Account__Attribute
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fpm
operator|->
name|storage__account
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|fa
operator|->
name|fa_novalue
operator|&
name|FA_ACCOUNT
condition|)
name|fpm
operator|->
name|storage__account
operator|->
name|offset
operator|=
name|type_FTAM_Account__Attribute_no__value__available
expr_stmt|;
else|else
block|{
name|fpm
operator|->
name|storage__account
operator|->
name|offset
operator|=
name|type_FTAM_Account__Attribute_actual__values
expr_stmt|;
if|if
condition|(
operator|(
name|fpm
operator|->
name|storage__account
operator|->
name|un
operator|.
name|actual__values
operator|=
name|str2qb
argument_list|(
name|fa
operator|->
name|fa_account
argument_list|,
name|strlen
argument_list|(
name|fa
operator|->
name|fa_account
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
block|}
define|#
directive|define
name|dodate
parameter_list|(
name|flag
parameter_list|,
name|field
parameter_list|,
name|tag
parameter_list|)
define|\
value|if (fa -> fa_present& flag) { \ 	if ((fpm -> tag = (struct type_FTAM_Date__and__Time__Attribute *) \ 			        calloc (1, sizeof *fpm -> tag)) == NULL) \ 	    goto no_mem; \ 	if (fa -> fa_novalue& flag) \ 	    fpm -> tag -> offset = \ 		    type_FTAM_Date__and__Time__Attribute_no__value__available;\ 	else { \ 	    fpm -> tag -> offset = \ 		    type_FTAM_Date__and__Time__Attribute_actual__values; \ 	    if ((cp = gent2str (field)) == NULL \ 		    || (fpm -> tag -> un.actual__values = \ 				str2qb (cp, strlen (cp), 1)) == NULL) \ 		goto no_mem; \ 	} \     }
name|dodate
argument_list|(
name|FA_DATE_CREATE
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_create
argument_list|,
name|date__and__time__of__creation
argument_list|)
expr_stmt|;
name|dodate
argument_list|(
name|FA_DATE_MODIFY
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_modify
argument_list|,
name|date__and__time__of__last__modification
argument_list|)
expr_stmt|;
name|dodate
argument_list|(
name|FA_DATE_READ
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_read
argument_list|,
name|date__and__time__of__last__read__access
argument_list|)
expr_stmt|;
name|dodate
argument_list|(
name|FA_DATE_ATTR
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_attribute
argument_list|,
name|date__and__time__of__last__attribute__modification
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dodate
define|#
directive|define
name|douser
parameter_list|(
name|flag
parameter_list|,
name|field
parameter_list|,
name|tag
parameter_list|,
name|name
parameter_list|)
define|\
value|if (fa -> fa_present& flag) { \ 	if ((fpm -> tag = (struct type_FTAM_User__Identity__Attribute *) \ 				calloc (1, sizeof *fpm -> tag)) == NULL) \ 	    goto no_mem; \ 	if (fa -> fa_novalue& flag) \ 	    fpm -> tag -> offset = \ 		    type_FTAM_User__Identity__Attribute_no__value__available; \ 	else { \ 	    if (field == NULL) { \ 		(void) ftamlose (fti, FS_GEN (fsb), 0, NULLCP, "missing %s", \ 				 name); \ 		goto out; \ 	    } \ 	    fpm -> tag -> offset = \ 		    type_FTAM_User__Identity__Attribute_actual__values; \ 	    if ((fpm -> tag -> un.actual__values = str2qb (field, \ 							  strlen (field), 1)) \ 		    == NULL) \ 		goto no_mem; \ 	} \     }
name|douser
argument_list|(
name|FA_ID_CREATE
argument_list|,
name|fa
operator|->
name|fa_id_create
argument_list|,
name|identity__of__creator
argument_list|,
literal|"identity-of-creator"
argument_list|)
expr_stmt|;
name|douser
argument_list|(
name|FA_ID_MODIFY
argument_list|,
name|fa
operator|->
name|fa_id_modify
argument_list|,
name|identity__of__last__modifier
argument_list|,
literal|"identity-of-last-modifier"
argument_list|)
expr_stmt|;
name|douser
argument_list|(
name|FA_ID_READ
argument_list|,
name|fa
operator|->
name|fa_id_read
argument_list|,
name|identity__of__last__reader
argument_list|,
literal|"identity-of-last-reader"
argument_list|)
expr_stmt|;
name|douser
argument_list|(
name|FA_ID_ATTR
argument_list|,
name|fa
operator|->
name|fa_id_attribute
argument_list|,
name|identity__of__last__attribute__modifier
argument_list|,
literal|"identity-of-last-attribute-modifier"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|douser
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_AVAILABILITY
condition|)
block|{
if|if
condition|(
operator|(
name|fpm
operator|->
name|file__availability
operator|=
operator|(
expr|struct
name|type_FTAM_File__Availability__Attribute
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fpm
operator|->
name|file__availability
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|fa
operator|->
name|fa_novalue
operator|&
name|FA_AVAILABILITY
condition|)
name|fpm
operator|->
name|file__availability
operator|->
name|offset
operator|=
name|type_FTAM_File__Availability__Attribute_no__value__available
expr_stmt|;
else|else
block|{
name|fpm
operator|->
name|file__availability
operator|->
name|offset
operator|=
name|type_FTAM_File__Availability__Attribute_actual__values
expr_stmt|;
switch|switch
condition|(
name|fa
operator|->
name|fa_availability
condition|)
block|{
case|case
name|FA_AVAIL_IMMED
case|:
case|case
name|FA_AVAIL_DEFER
case|:
name|fpm
operator|->
name|file__availability
operator|->
name|un
operator|.
name|actual__values
operator|=
name|fa
operator|->
name|fa_availability
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"bad value for file-availability"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
define|#
directive|define
name|dosize
parameter_list|(
name|flag
parameter_list|,
name|field
parameter_list|,
name|tag
parameter_list|)
define|\
value|if (fa -> fa_present& flag) { \ 	if ((fpm -> tag = (struct type_FTAM_Filesize__Attribute *) \ 			    calloc (1, sizeof *fpm -> tag)) == NULL) \ 	    goto no_mem; \ 	if (fa -> fa_novalue& flag) \ 	    fpm -> tag -> offset = \ 		type_FTAM_Filesize__Attribute_no__value__available; \ 	else { \ 	    fpm -> tag -> offset = \ 		type_FTAM_Filesize__Attribute_actual__values; \ 	    fpm -> tag -> un.actual__values = field; \ 	} \     }
name|dosize
argument_list|(
name|FA_FILESIZE
argument_list|,
name|fa
operator|->
name|fa_filesize
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
name|dosize
argument_list|(
name|FA_FUTURESIZE
argument_list|,
name|fa
operator|->
name|fa_futuresize
argument_list|,
name|future__filesize
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dosize
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_CONTROL
condition|)
block|{
if|if
condition|(
operator|(
name|fpm
operator|->
name|access__control
operator|=
operator|(
expr|struct
name|type_FTAM_Access__Control__Attribute
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fpm
operator|->
name|access__control
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|fa
operator|->
name|fa_novalue
operator|&
name|FA_CONTROL
condition|)
name|fpm
operator|->
name|access__control
operator|->
name|offset
operator|=
name|type_FTAM_Access__Control__Attribute_no__value__available
expr_stmt|;
else|else
block|{
name|fpm
operator|->
name|access__control
operator|->
name|offset
operator|=
name|type_FTAM_Access__Control__Attribute_actual__values
expr_stmt|;
if|if
condition|(
operator|(
name|fpm
operator|->
name|access__control
operator|->
name|un
operator|.
name|actual__values
operator|=
name|acl2fpm
argument_list|(
name|fsb
argument_list|,
name|fa
operator|->
name|fa_control
argument_list|,
name|fti
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_LEGAL
condition|)
block|{
if|if
condition|(
operator|(
name|fpm
operator|->
name|legal__qualification
operator|=
operator|(
expr|struct
name|type_FTAM_Legal__Qualification__Attribute
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fpm
operator|->
name|legal__qualification
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|fa
operator|->
name|fa_novalue
operator|&
name|FA_LEGAL
condition|)
name|fpm
operator|->
name|legal__qualification
operator|->
name|offset
operator|=
name|type_FTAM_Legal__Qualification__Attribute_no__value__available
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fa
operator|->
name|fa_legal
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"missing legal-qualification"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fpm
operator|->
name|legal__qualification
operator|->
name|offset
operator|=
name|type_FTAM_Legal__Qualification__Attribute_actual__values
expr_stmt|;
if|if
condition|(
operator|(
name|fpm
operator|->
name|legal__qualification
operator|->
name|un
operator|.
name|actual__values
operator|=
name|str2qb
argument_list|(
name|fa
operator|->
name|fa_legal
argument_list|,
name|strlen
argument_list|(
name|fa
operator|->
name|fa_legal
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
block|}
comment|/*      * Added private use attribute functionality for Retix NBS9 interworking.      * No value should always be set because we don't support private use.      * pmk.      */
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_PRIVATE
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|"private-use attribute not supported"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
return|return
name|fpm
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|fpm2attr
parameter_list|(
name|fsb
parameter_list|,
name|fpm
parameter_list|,
name|fa
parameter_list|,
name|fti
parameter_list|)
specifier|register
name|struct
name|ftamblk
modifier|*
name|fsb
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_Read__Attributes
modifier|*
name|fpm
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|UTC
name|u
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fa
argument_list|,
sizeof|sizeof
expr|*
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpm
operator|->
name|filename
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|struct
name|type_FTAM_Filename__Attribute
modifier|*
name|fn
decl_stmt|;
name|fa
operator|->
name|fa_present
operator||=
name|FA_FILENAME
expr_stmt|;
name|ap
operator|=
name|fa
operator|->
name|fa_files
operator|,
name|n
operator|=
name|NFFILE
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|fpm
operator|->
name|filename
init|;
name|fn
condition|;
name|fn
operator|=
name|fn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|--
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
literal|"too many names in filename"
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
name|FAFREE
argument_list|(
name|fa
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|ap
operator|++
operator|=
name|qb2str
argument_list|(
name|fn
operator|->
name|GraphicString
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|ftamlose
argument_list|(
name|fti
argument_list|,
name|FS_GEN
argument_list|(
name|fsb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fa
operator|->
name|fa_nfile
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fpm
operator|->
name|permitted__actions
condition|)
block|{
name|fa
operator|->
name|fa_present
operator||=
name|FA_ACTIONS
expr_stmt|;
if|if
condition|(
name|fpm2bits
argument_list|(
name|fsb
argument_list|,
name|fpermitted_pairs
argument_list|,
name|fpm
operator|->
name|permitted__actions
argument_list|,
operator|&
name|fa
operator|->
name|fa_permitted
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fpm
operator|->
name|contents__type
condition|)
block|{
name|fa
operator|->
name|fa_present
operator||=
name|FA_CONTENTS
expr_stmt|;
name|fa
operator|->
name|fa_contents
operator|=
name|fpm
operator|->
name|contents__type
operator|->
name|document__type__name
expr_stmt|;
name|fpm
operator|->
name|contents__type
operator|->
name|document__type__name
operator|=
name|NULLOID
expr_stmt|;
if|if
condition|(
name|fpm
operator|->
name|contents__type
operator|->
name|parameter
operator|&&
operator|(
name|fa
operator|->
name|fa_parameter
operator|=
name|pe_cpy
argument_list|(
name|fpm
operator|->
name|contents__type
operator|->
name|parameter
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
goto|goto
name|no_mem
goto|;
block|}
if|if
condition|(
name|fpm
operator|->
name|storage__account
condition|)
block|{
name|fa
operator|->
name|fa_present
operator||=
name|FA_ACCOUNT
expr_stmt|;
if|if
condition|(
name|fpm
operator|->
name|storage__account
operator|->
name|offset
operator|==
name|type_FTAM_Account__Attribute_no__value__available
condition|)
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_ACCOUNT
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|fa
operator|->
name|fa_account
operator|=
name|qb2str
argument_list|(
name|fpm
operator|->
name|storage__account
operator|->
name|un
operator|.
name|actual__values
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
operator|*
name|fa
operator|->
name|fa_account
operator|==
name|NULL
condition|)
block|{
comment|/* CDC: some other vendor... */
name|fa
operator|->
name|fa_present
operator|&=
operator|~
name|FA_ACCOUNT
expr_stmt|;
name|free
argument_list|(
name|fa
operator|->
name|fa_account
argument_list|)
expr_stmt|;
name|fa
operator|->
name|fa_account
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
define|#
directive|define
name|dodate
parameter_list|(
name|flag
parameter_list|,
name|field
parameter_list|,
name|tag
parameter_list|)
define|\
value|if (fpm -> tag) { \ 	fa -> fa_present |= flag; \  \ 	if (fpm -> tag -> offset \ 	        == type_FTAM_Date__and__Time__Attribute_no__value__available) \ 	    fa -> fa_novalue |= flag; \ 	else { \ 	    if ((cp = qb2str (fpm -> tag -> un.actual__values)) == NULL) \ 		goto no_mem; \ 	    u = str2gent (cp, strlen (cp)); \ 	    free (cp); \ 	    if (u == NULLUTC) \ 		goto no_mem; \ 	    field = *u; \ 	} \     }
name|dodate
argument_list|(
name|FA_DATE_CREATE
argument_list|,
name|fa
operator|->
name|fa_date_create
argument_list|,
name|date__and__time__of__creation
argument_list|)
expr_stmt|;
name|dodate
argument_list|(
name|FA_DATE_MODIFY
argument_list|,
name|fa
operator|->
name|fa_date_modify
argument_list|,
name|date__and__time__of__last__modification
argument_list|)
expr_stmt|;
name|dodate
argument_list|(
name|FA_DATE_READ
argument_list|,
name|fa
operator|->
name|fa_date_read
argument_list|,
name|date__and__time__of__last__read__access
argument_list|)
expr_stmt|;
name|dodate
argument_list|(
name|FA_DATE_ATTR
argument_list|,
name|fa
operator|->
name|fa_date_attribute
argument_list|,
name|date__and__time__of__last__attribute__modification
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dodate
define|#
directive|define
name|douser
parameter_list|(
name|flag
parameter_list|,
name|field
parameter_list|,
name|tag
parameter_list|,
name|name
parameter_list|)
define|\
value|if (fpm -> tag) { \ 	fa -> fa_present |= flag; \  \ 	if (fpm -> tag -> offset \ 		== type_FTAM_User__Identity__Attribute_no__value__available) \ 	    fa -> fa_novalue |= flag; \ 	else \ 	    if ((field = qb2str (fpm -> tag -> un.actual__values)) == NULL) \ 		goto no_mem; \     }
name|douser
argument_list|(
name|FA_ID_CREATE
argument_list|,
name|fa
operator|->
name|fa_id_create
argument_list|,
name|identity__of__creator
argument_list|,
literal|"identity-of-creator"
argument_list|)
expr_stmt|;
name|douser
argument_list|(
name|FA_ID_MODIFY
argument_list|,
name|fa
operator|->
name|fa_id_modify
argument_list|,
name|identity__of__last__modifier
argument_list|,
literal|"identity-of-last-modifier"
argument_list|)
expr_stmt|;
name|douser
argument_list|(
name|FA_ID_READ
argument_list|,
name|fa
operator|->
name|fa_id_read
argument_list|,
name|identity__of__last__reader
argument_list|,
literal|"identity-of-last-reader"
argument_list|)
expr_stmt|;
name|douser
argument_list|(
name|FA_ID_ATTR
argument_list|,
name|fa
operator|->
name|fa_id_attribute
argument_list|,
name|identity__of__last__attribute__modifier
argument_list|,
literal|"identity-of-last-attribute-modifier"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|douser
if|if
condition|(
name|fpm
operator|->
name|file__availability
condition|)
block|{
name|fa
operator|->
name|fa_present
operator||=
name|FA_AVAILABILITY
expr_stmt|;
if|if
condition|(
name|fpm
operator|->
name|file__availability
operator|->
name|offset
operator|==
name|type_FTAM_File__Availability__Attribute_no__value__available
condition|)
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_AVAILABILITY
expr_stmt|;
else|else
name|fa
operator|->
name|fa_availability
operator|=
name|fpm
operator|->
name|file__availability
operator|->
name|un
operator|.
name|actual__values
expr_stmt|;
block|}
define|#
directive|define
name|dosize
parameter_list|(
name|flag
parameter_list|,
name|field
parameter_list|,
name|tag
parameter_list|)
define|\
value|if (fpm -> tag) { \ 	fa -> fa_present |= flag; \  \ 	if (fpm -> tag -> offset \ 		== type_FTAM_Filesize__Attribute_no__value__available) \ 	    fa -> fa_novalue |= flag; \ 	else \ 	    field = fpm -> tag -> un.actual__values; \     }
name|dosize
argument_list|(
name|FA_FILESIZE
argument_list|,
name|fa
operator|->
name|fa_filesize
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
name|dosize
argument_list|(
name|FA_FUTURESIZE
argument_list|,
name|fa
operator|->
name|fa_futuresize
argument_list|,
name|future__filesize
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dosize
if|if
condition|(
name|fpm
operator|->
name|access__control
condition|)
block|{
name|fa
operator|->
name|fa_present
operator||=
name|FA_CONTROL
expr_stmt|;
if|if
condition|(
name|fpm
operator|->
name|access__control
operator|->
name|offset
operator|==
name|type_FTAM_Access__Control__Attribute_no__value__available
condition|)
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_CONTROL
expr_stmt|;
elseif|else
if|if
condition|(
name|fpm2acl
argument_list|(
name|fsb
argument_list|,
name|fpm
operator|->
name|access__control
operator|->
name|un
operator|.
name|actual__values
argument_list|,
operator|&
name|fa
operator|->
name|fa_control
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fpm
operator|->
name|legal__qualification
condition|)
block|{
name|fa
operator|->
name|fa_present
operator||=
name|FA_LEGAL
expr_stmt|;
if|if
condition|(
name|fpm
operator|->
name|legal__qualification
operator|->
name|offset
operator|==
name|type_FTAM_Legal__Qualification__Attribute_no__value__available
condition|)
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_LEGAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fa
operator|->
name|fa_legal
operator|=
name|qb2str
argument_list|(
name|fpm
operator|->
name|legal__qualification
operator|->
name|un
operator|.
name|actual__values
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
comment|/* Added private use functionality pmk */
if|if
condition|(
name|fpm
operator|->
name|private__use
condition|)
block|{
name|fa
operator|->
name|fa_present
operator||=
name|FA_PRIVATE
expr_stmt|;
comment|/* Set no value, regardless of what is there we don't support it */
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_PRIVATE
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|void
name|FAFREE
parameter_list|(
name|fa
parameter_list|)
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
decl_stmt|;
block|{
specifier|register
name|int
name|FAI
decl_stmt|;
for|for
control|(
name|FAI
operator|=
operator|(
name|fa
operator|)
operator|->
name|fa_nfile
operator|-
literal|1
init|;
name|FAI
operator|>=
literal|0
condition|;
name|FAI
operator|--
control|)
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_files
index|[
name|FAI
index|]
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_files
index|[
name|FAI
index|]
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_files
index|[
name|FAI
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|fa
operator|)
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_contents
condition|)
name|oid_free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_contents
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_contents
operator|=
name|NULLOID
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_parameter
condition|)
name|pe_free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_parameter
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_parameter
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_account
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_account
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_account
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_create
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_create
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_id_create
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_modify
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_modify
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_id_modify
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_read
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_read
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_id_read
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_attribute
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_id_attribute
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_id_attribute
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fa
operator|->
name|fa_control
condition|)
block|{
name|FEFREE
argument_list|(
name|fa
operator|->
name|fa_control
argument_list|)
expr_stmt|;
name|fa
operator|->
name|fa_control
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_legal
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_legal
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_legal
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fa
operator|)
operator|->
name|fa_private
condition|)
name|free
argument_list|(
operator|(
name|fa
operator|)
operator|->
name|fa_private
argument_list|)
operator|,
operator|(
name|fa
operator|)
operator|->
name|fa_private
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

