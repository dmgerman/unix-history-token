begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mosy.c - Managed Object Syntax-compiler (yacc-based) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/mosy/RCS/mosy.c,v 7.6 91/03/09 11:54:19 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/others/mosy/RCS/mosy.c,v 7.6 91/03/09 11:54:19 mrose Exp $  *  *  * $Log:	mosy.c,v $  * Revision 7.6  91/03/09  11:54:19  mrose  * update  *   * Revision 7.5  91/02/22  09:28:42  mrose  * Interim 6.8  *   * Revision 7.4  90/11/20  15:33:41  mrose  * update  *   * Revision 7.3  90/09/07  17:33:59  mrose  * new-macros  *   * Revision 7.2  90/08/29  12:24:19  mrose  * touch-up  *   * Revision 7.1  90/07/01  21:04:36  mrose  * pepsy  *   * Revision 7.0  89/11/23  22:00:38  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"mosy-defs.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
name|int
name|Cflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mosy */
end_comment

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pepy compat... */
end_comment

begin_decl_stmt
name|int
name|doexternals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linepos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mosydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eval
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mymodule
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OID
name|mymoduleid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yysection
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencpref
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecpref
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfpref
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencdflt
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecdflt
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfdflt
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|yymode
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|classes
index|[]
init|=
block|{
literal|"UNIVERSAL "
block|,
literal|"APPLICATION "
block|,
literal|""
block|,
literal|"PRIVATE "
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|autogen
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sysin
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysout
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|yot
block|{
name|char
modifier|*
name|yo_name
decl_stmt|;
name|YP
name|yo_syntax
decl_stmt|;
name|YV
name|yo_value
decl_stmt|;
name|char
modifier|*
name|yo_access
decl_stmt|;
name|char
modifier|*
name|yo_status
decl_stmt|;
name|char
modifier|*
name|yo_descr
decl_stmt|;
name|char
modifier|*
name|yo_refer
decl_stmt|;
name|YV
name|yo_index
decl_stmt|;
name|YV
name|yo_defval
decl_stmt|;
block|}
name|yot
operator|,
typedef|*
name|OT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLOT
value|((OT) 0)
end_define

begin_typedef
typedef|typedef
struct|struct
name|yoi
block|{
name|char
modifier|*
name|yi_name
decl_stmt|;
name|YV
name|yi_value
decl_stmt|;
block|}
name|yoi
operator|,
typedef|*
name|OI
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLOI
value|((OI) 0)
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|symlist
block|{
name|char
modifier|*
name|sy_encpref
decl_stmt|;
name|char
modifier|*
name|sy_decpref
decl_stmt|;
name|char
modifier|*
name|sy_prfpref
decl_stmt|;
name|char
modifier|*
name|sy_module
decl_stmt|;
name|char
modifier|*
name|sy_name
decl_stmt|;
union|union
block|{
name|OT
name|sy_un_yo
decl_stmt|;
name|OI
name|sy_un_yi
decl_stmt|;
name|YP
name|sy_un_yp
decl_stmt|;
block|}
name|sy_un
union|;
define|#
directive|define
name|sy_yo
value|sy_un.sy_un_yo
define|#
directive|define
name|sy_yi
value|sy_un.sy_un_yi
define|#
directive|define
name|sy_yp
value|sy_un.sy_un_yp
name|struct
name|symlist
modifier|*
name|sy_next
decl_stmt|;
block|}
name|symlist
operator|,
typedef|*
name|SY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLSY
value|((SY) 0)
end_define

begin_decl_stmt
specifier|static
name|SY
name|myobjects
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SY
name|myidentifiers
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SY
name|mytypes
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|modsym
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|SY
name|new_symbol
argument_list|()
decl_stmt|,
name|add_symbol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|id2str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|YP
name|lookup_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|val2str
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|mosyversion
argument_list|)
expr_stmt|;
name|sysout
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|cp
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-m"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sysout
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many output files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|)
condition|)
goto|goto
name|usage
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sysout
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sysin
condition|)
block|{
name|usage
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: mosy [-d] [-o module.defs] [-s] module.my\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
name|NULL
condition|)
goto|goto
name|usage
goto|;
name|sysin
operator|=
literal|""
expr_stmt|;
block|}
name|sysin
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|sysout
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
condition|)
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
operator|*
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|cp
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|cp
operator|=
name|sp
argument_list|)
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|sp
operator|>
name|cp
operator|&&
name|strcmp
argument_list|(
name|sp
argument_list|,
literal|".my"
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysout
argument_list|,
literal|"%.*s.defs"
argument_list|,
name|sp
operator|-
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysout
argument_list|,
literal|"%s.defs"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mosydebug
operator|=
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MOSYTEST"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|0
condition|)
block|{
case|case
literal|2
case|:
name|yydebug
operator|++
expr_stmt|;
comment|/* fall */
case|case
literal|1
case|:
name|sflag
operator|++
expr_stmt|;
comment|/*   .. */
case|case
literal|0
case|:
break|break;
block|}
if|if
condition|(
name|sysin
operator|==
name|NULLCP
condition|)
name|sysin
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|sysin
operator|&&
name|freopen
argument_list|(
name|sysin
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to read "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysin
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sysout
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|sysout
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
operator|&&
name|freopen
argument_list|(
name|sysout
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to write "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|mosyversion
argument_list|,
literal|')'
argument_list|)
condition|)
for|for
control|(
name|cp
operator|++
init|;
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|mosyversion
operator|+
name|strlen
argument_list|(
name|mosyversion
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|autogen
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|mosyversion
argument_list|,
name|cp
operator|-
name|mosyversion
argument_list|,
name|mosyversion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- automatically generated by %s, do not edit!\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
name|initoidtbl
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|yyparse
argument_list|()
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_expr_stmt
name|yyerror
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|yyerror_aux
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|warning
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buffer2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer2
argument_list|,
literal|"Warning: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|yyerror_aux
argument_list|(
name|buffer2
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|warning
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warning
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|yyerror_aux
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s: "
argument_list|,
name|yymode
argument_list|,
name|eval
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %d: "
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last token read was \"%s\"\n"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|myyerror
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|myyerror
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|myyerror
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|yyprint
argument_list|(
argument|s
argument_list|,
argument|f
argument_list|,
argument|top
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|,
name|top
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_expr_stmt
specifier|static
name|yyprint_aux
argument_list|(
argument|s
argument_list|,
argument|mode
argument_list|)
name|char
operator|*
name|s
operator|,
operator|*
name|mode
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|nameoutput
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|outputlinelen
init|=
literal|79
decl_stmt|;
if|if
condition|(
name|sflag
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|yymode
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|nameoutput
operator|=
operator|(
name|linepos
operator|=
name|strlen
argument_list|(
name|mymodule
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %ss"
argument_list|,
name|yymode
operator|=
name|mode
argument_list|)
expr_stmt|;
name|linepos
operator|+=
name|strlen
argument_list|(
name|yymode
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|linepos
operator|+=
literal|2
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|linepos
operator|!=
name|nameoutput
condition|)
if|if
condition|(
name|len
operator|+
name|linepos
operator|+
literal|1
operator|>
name|outputlinelen
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%*s"
argument_list|,
name|linepos
operator|=
name|nameoutput
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
operator|,
name|linepos
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|linepos
operator|+=
name|len
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS1 */
end_comment

begin_macro
name|pass1
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"-- object definitions compiled from %s"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
if|if
condition|(
name|mymoduleid
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|oidprint
argument_list|(
name|mymoduleid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|pass1_oid
argument_list|(
argument|mod
argument_list|,
argument|id
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YV
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|OI
name|yi
decl_stmt|;
if|if
condition|(
operator|(
name|yi
operator|=
operator|(
name|OI
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yi
argument_list|)
operator|)
operator|==
name|NULLOI
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yi
operator|->
name|yi_name
operator|=
name|id
expr_stmt|;
name|yi
operator|->
name|yi_value
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|mosydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_yi
argument_list|(
name|yi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|yyprint_aux
argument_list|(
name|id
argument_list|,
literal|"identifier"
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|mod
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_yi
operator|=
name|yi
expr_stmt|;
name|myidentifiers
operator|=
name|add_symbol
argument_list|(
name|myidentifiers
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|pass1_obj
argument_list|(
argument|mod
argument_list|,
argument|id
argument_list|,
argument|syntax
argument_list|,
argument|value
argument_list|,
argument|aname
argument_list|,
argument|sname
argument_list|,
argument|descr
argument_list|,
argument|refer
argument_list|,
argument|idx
argument_list|,
argument|defval
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|,
modifier|*
name|aname
decl_stmt|,
modifier|*
name|sname
decl_stmt|,
modifier|*
name|descr
decl_stmt|,
modifier|*
name|refer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|syntax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YV
name|value
decl_stmt|,
name|idx
decl_stmt|,
name|defval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|OT
name|yo
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|id
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|warning
argument_list|(
literal|"object %s contains a `-' in its descriptor"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|syntax
argument_list|,
literal|"Counter"
argument_list|)
operator|==
literal|0
operator|&&
name|id
index|[
name|strlen
argument_list|(
name|id
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'s'
condition|)
name|warning
argument_list|(
literal|"descriptor of counter object %s doesn't end in `s'"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|aname
argument_list|,
literal|"read-only"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|aname
argument_list|,
literal|"read-write"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|aname
argument_list|,
literal|"read-write"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|aname
argument_list|,
literal|"not-accessible"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"value of ACCESS clause isn't a valid keyword"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"mandatory"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"optional"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"obsolete"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"deprecated"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"value of STATUS clause isn't a valid keyword"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yo
operator|=
operator|(
name|OT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yo
argument_list|)
operator|)
operator|==
name|NULLOT
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yo
operator|->
name|yo_name
operator|=
name|id
expr_stmt|;
name|yo
operator|->
name|yo_syntax
operator|=
name|syntax
expr_stmt|;
name|yo
operator|->
name|yo_value
operator|=
name|value
expr_stmt|;
name|yo
operator|->
name|yo_access
operator|=
name|aname
expr_stmt|;
name|yo
operator|->
name|yo_status
operator|=
name|sname
expr_stmt|;
name|yo
operator|->
name|yo_descr
operator|=
name|descr
expr_stmt|;
name|yo
operator|->
name|yo_refer
operator|=
name|refer
expr_stmt|;
name|yo
operator|->
name|yo_index
operator|=
name|idx
expr_stmt|;
name|yo
operator|->
name|yo_defval
operator|=
name|defval
expr_stmt|;
if|if
condition|(
name|mosydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_yo
argument_list|(
name|yo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|yyprint_aux
argument_list|(
name|id
argument_list|,
literal|"object"
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|mod
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_yo
operator|=
name|yo
expr_stmt|;
name|myobjects
operator|=
name|add_symbol
argument_list|(
name|myobjects
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|pass1_trap
argument_list|(
argument|mod
argument_list|,
argument|id
argument_list|,
argument|enterprise
argument_list|,
argument|number
argument_list|,
argument|var
argument_list|,
argument|descr
argument_list|,
argument|refer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YV
name|enterprise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YV
name|var
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|descr
decl_stmt|,
modifier|*
name|refer
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|pass1_type
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|,
name|yp
argument_list|)
specifier|register
name|char
operator|*
name|encpref
operator|,
operator|*
name|decpref
operator|,
operator|*
name|prfpref
operator|,
operator|*
name|mod
operator|,
operator|*
name|id
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|dflag
operator|&&
name|lookup_type
argument_list|(
name|mod
argument_list|,
name|id
argument_list|)
condition|)
comment|/* no duplicate entries, please... */
return|return;
if|if
condition|(
name|mosydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
operator|)
condition|)
name|yyprint_aux
argument_list|(
name|id
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_yp
operator|=
name|yp
expr_stmt|;
name|mytypes
operator|=
name|add_symbol
argument_list|(
name|mytypes
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS2 */
end_comment

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|!
name|sflag
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|yymode
operator|=
literal|"identifier"
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|myidentifiers
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
name|do_id
argument_list|(
name|sy
operator|->
name|sy_yi
argument_list|,
name|eval
operator|=
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|myidentifiers
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|yymode
operator|=
literal|"object"
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|myobjects
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
name|do_obj1
argument_list|(
name|sy
operator|->
name|sy_yo
argument_list|,
name|eval
operator|=
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|myobjects
condition|)
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_id
argument_list|(
name|yi
argument_list|,
name|id
argument_list|)
specifier|register
name|OI
name|yi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%-20s %s\n"
argument_list|,
name|yi
operator|->
name|yi_name
argument_list|,
name|id2str
argument_list|(
name|yi
operator|->
name|yi_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_obj1
argument_list|(
name|yo
argument_list|,
name|id
argument_list|)
specifier|register
name|OT
name|yo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|yp
decl_stmt|,
name|yz
decl_stmt|;
name|printf
argument_list|(
literal|"%-20s %-16s "
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|id2str
argument_list|(
name|yo
operator|->
name|yo_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
name|yo
operator|->
name|yo_syntax
operator|)
operator|==
name|NULLYP
condition|)
name|yyerror
argument_list|(
literal|"no syntax associated with object type"
argument_list|)
expr_stmt|;
name|again
label|:
empty_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
name|id
operator|=
literal|"INTEGER"
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
name|id
operator|=
literal|"OctetString"
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
name|id
operator|=
literal|"ObjectID"
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
name|id
operator|=
literal|"NULL"
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
if|if
condition|(
operator|(
name|yz
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|->
name|yp_code
operator|!=
name|YP_IDEFINED
operator|||
operator|(
name|yz
operator|=
name|lookup_type
argument_list|(
name|yz
operator|->
name|yp_module
argument_list|,
name|yz
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|yz
operator|->
name|yp_code
operator|!=
name|YP_SEQLIST
condition|)
name|warning
argument_list|(
literal|"value of SYNTAX clause isn't SEQUENCE OF Type,\n\twhere Type ::= SEQUENCE { ... }"
argument_list|)
expr_stmt|;
comment|/* and fall... */
case|case
name|YP_SEQLIST
case|:
name|id
operator|=
literal|"Aggregate"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|yo
operator|->
name|yo_access
argument_list|,
literal|"not-accessible"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"value of ACCESS clause isn't not-accessible"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|id
operator|=
literal|"Invalid"
expr_stmt|;
name|warning
argument_list|(
literal|"invalid value of SYNTAX clause"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|=
name|lookup_type
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|id
operator|=
name|yp
operator|->
name|yp_identifier
argument_list|)
condition|)
goto|goto
name|again
goto|;
break|break;
block|}
name|printf
argument_list|(
literal|"%-15s %-15s %s\n"
argument_list|,
name|id
argument_list|,
name|yo
operator|->
name|yo_access
argument_list|,
name|yo
operator|->
name|yo_status
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|IDENTIFIER HANDLING */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|id2str
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_code
operator|!=
name|YV_OIDLIST
condition|)
name|yyerror
argument_list|(
literal|"need an object identifer"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yv
operator|->
name|yv_idlist
operator|,
name|dp
operator|=
literal|""
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
operator|,
name|dp
operator|=
literal|"."
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s%s"
argument_list|,
name|dp
argument_list|,
name|val2str
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*
comment|TYPE HANDLING */
end_comment

begin_function
specifier|static
name|YP
name|lookup_type
parameter_list|(
name|mod
parameter_list|,
name|id
parameter_list|)
specifier|register
name|char
modifier|*
name|mod
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
for|for
control|(
name|sy
operator|=
name|mytypes
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|mod
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mod
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sy
operator|->
name|sy_yp
return|;
block|}
return|return
name|NULLYP
return|;
block|}
end_block

begin_comment
comment|/*
comment|VALUE HANDLING */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|val2str
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
name|yyerror
argument_list|(
literal|"need a sub-identifier, not a boolean"
argument_list|)
expr_stmt|;
case|case
name|YV_NUMBER
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need a sub-identifier, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
return|return
name|yv
operator|->
name|yv_identifier
return|;
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_VALIST
case|:
name|yyerror
argument_list|(
literal|"need a sub-identifier, not a list of values"
argument_list|)
expr_stmt|;
case|case
name|YV_OIDLIST
case|:
name|yyerror
argument_list|(
literal|"need a sub-identifier, not an object identifier"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need a sub-identifier, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|val2int
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_VALIST
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a list of values"
argument_list|)
expr_stmt|;
case|case
name|YV_OIDLIST
case|:
name|yyerror
argument_list|(
literal|"need an integer, not an object identifier"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|val2prf
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
comment|/* will this REALLY work??? */
name|do_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
name|level
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
name|printf
argument_list|(
name|yv
operator|->
name|yv_number
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NUMBER
case|:
if|if
condition|(
name|yv
operator|->
name|yv_named
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_module
condition|)
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|y
operator|->
name|yv_next
condition|?
literal|", "
else|:
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_OIDLIST
case|:
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NULL
case|:
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_comment
comment|/*
comment|ACTION HANDLING */
end_comment

begin_expr_stmt
specifier|static
name|act2prf
argument_list|(
argument|cp
argument_list|,
argument|level
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|)
name|char
operator|*
name|cp
operator|,
operator|*
name|e1
operator|,
operator|*
name|e2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l4
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|e1
condition|)
name|printf
argument_list|(
name|e1
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ep
operator|=
name|index
argument_list|(
name|dp
operator|=
name|cp
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|expand
argument_list|(
name|dp
argument_list|,
name|ep
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%*.*s\n"
argument_list|,
name|ep
operator|-
name|dp
argument_list|,
name|ep
operator|-
name|dp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|ep
operator|=
name|index
argument_list|(
name|dp
operator|=
name|ep
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|l4
operator|=
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
for|for
control|(
init|;
operator|*
name|dp
condition|;
name|dp
operator|=
name|fp
control|)
block|{
if|if
condition|(
name|ep
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|fp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
else|else
name|fp
operator|=
name|ep
operator|=
name|dp
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|j
operator|=
name|expand
argument_list|(
name|dp
argument_list|,
name|ep
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|fp
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|j
operator|<
name|i
condition|)
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|j
condition|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|l4
operator|+
name|j
operator|-
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*.*s\n"
argument_list|,
name|ep
operator|-
name|gp
argument_list|,
name|ep
operator|-
name|gp
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|e2
condition|)
name|printf
argument_list|(
name|e2
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|expand
argument_list|(
name|dp
argument_list|,
name|ep
argument_list|,
name|gp
argument_list|)
specifier|register
name|char
operator|*
name|dp
operator|,
operator|*
name|ep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|gp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|*
name|gp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dp
operator|<
name|ep
condition|;
name|dp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|dp
condition|)
block|{
case|case
literal|' '
case|:
name|i
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
name|i
operator|+=
literal|8
operator|-
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
continue|continue;
default|default:
operator|*
name|gp
operator|=
name|dp
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/*
comment|DEBUG */
end_comment

begin_expr_stmt
specifier|static
name|print_yo
argument_list|(
name|yo
argument_list|,
name|level
argument_list|)
specifier|register
name|OT
name|yo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|yo
operator|==
name|NULLOT
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sname=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|yo
operator|->
name|yo_syntax
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*ssyntax\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yo
operator|->
name|yo_syntax
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yo
operator|->
name|yo_value
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*svalue\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yo
operator|->
name|yo_value
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_yi
argument_list|(
name|yi
argument_list|,
name|level
argument_list|)
specifier|register
name|OI
name|yi
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|yi
operator|==
name|NULLOI
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sname=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yi
operator|->
name|yi_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|yi
operator|->
name|yi_value
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*svalue\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yi
operator|->
name|yi_value
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_type
argument_list|(
name|yp
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|,
name|sprintb
argument_list|(
name|yp
operator|->
name|yp_flags
argument_list|,
name|YPBITS
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sintexp=\"%s\" strexp=\"%s\" prfexp=%c declexp=\"%s\" varexp=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sstructname=\"%s\" ptrname=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction0 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act0_lineno
argument_list|,
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction1 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act1_lineno
argument_list|,
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction2 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act2_lineno
argument_list|,
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction3 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act3_lineno
argument_list|,
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stag class=0x%x value=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sdefault=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*soffset=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_INTLIST
case|:
case|case
name|YP_BITLIST
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*svalue=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|print_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_module
condition|?
name|yp
operator|->
name|yp_module
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|,
name|sprintb
argument_list|(
name|yv
operator|->
name|yv_flags
argument_list|,
name|YVBITS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_act_lineno
argument_list|,
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snamed=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snumber=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sstring=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
case|case
name|YV_OIDLIST
case|:
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_function
specifier|static
name|SY
name|new_symbol
parameter_list|(
name|encpref
parameter_list|,
name|decpref
parameter_list|,
name|prfpref
parameter_list|,
name|mod
parameter_list|,
name|id
parameter_list|)
specifier|register
name|char
modifier|*
name|encpref
decl_stmt|,
decl|*
name|decpref
decl_stmt|,
modifier|*
name|prfpref
decl_stmt|,
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
operator|(
name|sy
operator|=
operator|(
name|SY
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|sy
argument_list|)
operator|)
operator|==
name|NULLSY
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_encpref
operator|=
name|encpref
expr_stmt|;
name|sy
operator|->
name|sy_decpref
operator|=
name|decpref
expr_stmt|;
name|sy
operator|->
name|sy_prfpref
operator|=
name|prfpref
expr_stmt|;
name|sy
operator|->
name|sy_module
operator|=
name|mod
expr_stmt|;
name|sy
operator|->
name|sy_name
operator|=
name|id
expr_stmt|;
return|return
name|sy
return|;
block|}
end_block

begin_function
specifier|static
name|SY
name|add_symbol
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|SY
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULLSY
condition|)
return|return
name|s2
return|;
for|for
control|(
name|sy
operator|=
name|s1
init|;
name|sy
operator|->
name|sy_next
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
continue|continue;
name|sy
operator|->
name|sy_next
operator|=
name|s2
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/*
comment|TYPES */
end_comment

begin_function
name|YP
name|new_type
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
operator|(
name|YP
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yp
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_code
operator|=
name|code
expr_stmt|;
return|return
name|yp
return|;
block|}
end_function

begin_function
name|YP
name|add_type
parameter_list|(
name|y1
parameter_list|,
name|y2
parameter_list|)
specifier|register
name|YP
name|y1
decl_stmt|,
name|y2
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
for|for
control|(
name|yp
operator|=
name|y1
init|;
name|yp
operator|->
name|yp_next
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
continue|continue;
name|yp
operator|->
name|yp_next
operator|=
name|y2
expr_stmt|;
return|return
name|y1
return|;
block|}
end_function

begin_comment
comment|/*
comment|VALUES */
end_comment

begin_function
name|YV
name|new_value
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
operator|(
name|yv
operator|=
operator|(
name|YV
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yv
argument_list|)
operator|)
operator|==
name|NULLYV
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yv
operator|->
name|yv_code
operator|=
name|code
expr_stmt|;
return|return
name|yv
return|;
block|}
end_function

begin_function
name|YV
name|add_value
parameter_list|(
name|y1
parameter_list|,
name|y2
parameter_list|)
specifier|register
name|YV
name|y1
decl_stmt|,
name|y2
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
for|for
control|(
name|yv
operator|=
name|y1
init|;
name|yv
operator|->
name|yv_next
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
continue|continue;
name|yv
operator|->
name|yv_next
operator|=
name|y2
expr_stmt|;
return|return
name|y1
return|;
block|}
end_function

begin_comment
comment|/*
comment|TAGS */
end_comment

begin_function
name|YT
name|new_tag
parameter_list|(
name|class
parameter_list|)
name|PElementClass
name|class
decl_stmt|;
block|{
specifier|register
name|YT
name|yt
decl_stmt|;
if|if
condition|(
operator|(
name|yt
operator|=
operator|(
name|YT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yt
argument_list|)
operator|)
operator|==
name|NULLYT
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yt
operator|->
name|yt_class
operator|=
name|class
expr_stmt|;
return|return
name|yt
return|;
block|}
end_function

begin_comment
comment|/*
comment|STRINGS */
end_comment

begin_function
name|char
modifier|*
name|new_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_struct
specifier|static
struct|struct
name|triple
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|PElementClass
name|t_class
decl_stmt|;
name|PElementID
name|t_id
decl_stmt|;
block|}
name|triples
index|[]
init|=
block|{
literal|"IA5String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"ISO646String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"NumericString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_NUMS
block|,
literal|"PrintableString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_PRTS
block|,
literal|"T61String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"TeletexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"VideotexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VTXS
block|,
literal|"GeneralizedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"GeneralisedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"UTCTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"UniversalTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"GraphicString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GFXS
block|,
literal|"VisibleString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VISS
block|,
literal|"GeneralString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENS
block|,
literal|"EXTERNAL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_EXTN
block|,
literal|"ObjectDescriptor"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_ODE
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|modsym
parameter_list|(
name|module
parameter_list|,
name|id
parameter_list|,
name|prefix
parameter_list|)
specifier|register
name|char
modifier|*
name|module
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|module
operator|==
name|NULLCP
condition|)
for|for
control|(
name|t
operator|=
name|triples
init|;
name|t
operator|->
name|t_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|module
operator|=
literal|"UNIV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prefix
condition|)
name|modsym_aux
argument_list|(
name|prefix
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|module
condition|?
name|module
else|:
name|mymodule
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|id
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s"
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|modsym_aux
argument_list|(
name|name
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

end_unit

