begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* alias_chk.c - checks aliases from position provided downwards. */
end_comment

begin_comment
comment|/* A management tool - probably best to run this as a manager. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/quipu/uips/manage/RCS/alias_chk.c,v 7.1 91/02/22 09:32:02 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/others/quipu/uips/manage/RCS/alias_chk.c,v 7.1 90/07/27 08:4  *  *  * $Log:	alias_chk.c,v $  * Revision 7.1  91/02/22  09:32:02  mrose  * Interim 6.8  *   * Revision 7.0  91/01/24  14:43:41  mrose  * *** empty log message ***  *   * Revision 7.1  90/07/27  08:47:16  mrose  * update  *  * Revision 7.0  90/06/26  14:52:31  mrose  * *** empty log message ***  *  */
end_comment

begin_comment
comment|/*  *				NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/compare.h"
end_include

begin_include
include|#
directive|include
file|"quipu/ds_search.h"
end_include

begin_include
include|#
directive|include
file|"quipu/read.h"
end_include

begin_define
define|#
directive|define
name|ORG_PERSON
value|"thornPerson& quipuObject"
end_define

begin_comment
comment|/* this should probably go elsewhere !!! */
end_comment

begin_decl_stmt
specifier|extern
name|DN
name|dn
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPT
value|(!frompipe || rps -> ps_byteno == 0 ? opt : rps)
end_define

begin_define
define|#
directive|define
name|RPS
value|(!frompipe || opt -> ps_byteno == 0 ? rps : opt)
end_define

begin_decl_stmt
specifier|extern
name|char
name|frompipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PS
name|opt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PS
name|rps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Entry
name|current_entry
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|DN
name|sequence_dn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|DN
name|str2dn_aux
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Filter
name|get_filter
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
modifier|*
name|NULLARGV
init|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|call_alias_chk
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ds_search_arg
name|search_arg
decl_stmt|;
name|struct
name|DSError
name|search_error
decl_stmt|;
name|struct
name|ds_search_result
name|search_result
decl_stmt|;
name|DN
name|save_dn
decl_stmt|,
name|tmp_dn
init|=
name|NULLDN
decl_stmt|;
name|char
name|alias
init|=
name|FALSE
decl_stmt|;
name|char
name|verify_alias
parameter_list|()
function_decl|;
name|EntryInfo
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Error, too many arguments..\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
comment|/* Convert arg 2 to a DN for future use. */
comment|/* Turn a sequence number back into a DN */
if|if
condition|(
operator|*
name|argv
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|<=
literal|'9'
condition|)
block|{
comment|/* First convert the number into a dn */
name|tmp_dn
operator|=
name|dn_cpy
argument_list|(
name|sequence_dn
argument_list|(
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"..@ gives me a headache. Ambiguous. Aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'@'
condition|)
block|{
name|tmp_dn
operator|=
name|dn_cpy
argument_list|(
name|str2dn
argument_list|(
name|argv
index|[
literal|1
index|]
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|save_dn
operator|=
name|dn_cpy
argument_list|(
name|str2dn_aux
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|alias
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_dn
operator|!=
name|NULLDN
condition|)
block|{
if|if
condition|(
name|alias
condition|)
block|{
name|tmp_dn
operator|=
name|dn_cpy
argument_list|(
name|save_dn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dn
operator|==
name|NULLDN
condition|)
block|{
name|tmp_dn
operator|=
name|dn_cpy
argument_list|(
name|save_dn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp_dn
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn_append
argument_list|(
name|tmp_dn
argument_list|,
name|dn_cpy
argument_list|(
name|save_dn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dn_free
argument_list|(
name|save_dn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* We now have the start location in tmp_dn */
if|if
condition|(
name|tmp_dn
operator|!=
name|NULLDN
condition|)
block|{
name|save_dn
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
comment|/* save start location for later restore */
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn
operator|=
name|dn_cpy
argument_list|(
name|tmp_dn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|tmp_dn
argument_list|)
expr_stmt|;
block|}
comment|/* dn should be set to a: either current location, or 			       b: 2nd arg if specified. */
comment|/* Is dn a leaf or a non_leaf? */
block|{
name|struct
name|ds_compare_arg
name|compare_arg
decl_stmt|;
name|struct
name|DSError
name|compare_error
decl_stmt|;
name|struct
name|ds_compare_result
name|compare_result
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|=
name|service_control
argument_list|(
name|OPT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|compare_arg
operator|.
name|cma_common
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
name|compare_arg
operator|.
name|cma_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_options
operator||=
name|SVC_OPT_DONTDEREFERENCEALIAS
expr_stmt|;
name|compare_arg
operator|.
name|cma_object
operator|=
name|dn
expr_stmt|;
if|if
condition|(
name|get_ava
argument_list|(
operator|&
name|compare_arg
operator|.
name|cma_purported
argument_list|,
literal|"objectClass"
argument_list|,
literal|"quipuNonLeafObject"
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Oops, 'objectClass=quipuNonLeafObject' is a bad attribute!\n"
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"This is very bad...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|compare_arg
operator|.
name|cma_common
operator|.
name|ca_security
operator|!=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|signature
modifier|*
name|sign_operation
parameter_list|()
function_decl|;
name|int
name|encode_DAS_CompareArgumentData
parameter_list|()
function_decl|;
name|compare_arg
operator|.
name|cma_common
operator|.
name|ca_sig
operator|=
name|sign_operation
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|compare_arg
argument_list|,
name|encode_DAS_CompareArgumentData
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rebind
argument_list|()
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
while|while
condition|(
name|ds_compare
argument_list|(
operator|&
name|compare_arg
argument_list|,
operator|&
name|compare_error
argument_list|,
operator|&
name|compare_result
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
if|if
condition|(
name|dish_error
argument_list|(
name|OPT
argument_list|,
operator|&
name|compare_error
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|compare_arg
operator|.
name|cma_object
operator|=
name|compare_error
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
expr_stmt|;
block|}
comment|/* If the object is a leaf then check it out and exit... */
if|if
condition|(
name|compare_result
operator|.
name|cmr_matched
operator|==
name|FALSE
condition|)
block|{
name|struct
name|DSError
name|read_error
decl_stmt|;
name|struct
name|ds_read_result
name|read_result
decl_stmt|;
name|struct
name|ds_read_arg
name|read_arg
decl_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_allattributes
operator|=
name|TRUE
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_select
operator|=
name|NULLATTR
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_infotypes
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|service_control
argument_list|(
name|OPT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|read_arg
operator|.
name|rda_common
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_options
operator||=
name|SVC_OPT_DONTDEREFERENCEALIAS
expr_stmt|;
name|read_arg
operator|.
name|rda_object
operator|=
name|dn
expr_stmt|;
comment|/* Strong authentication */
if|if
condition|(
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_security
operator|!=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|signature
modifier|*
name|sign_operation
parameter_list|()
function_decl|;
name|int
name|encode_DAS_ReadArgumentData
parameter_list|()
function_decl|;
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_sig
operator|=
name|sign_operation
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_arg
argument_list|,
name|encode_DAS_ReadArgumentData
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ds_read
argument_list|(
operator|&
name|read_arg
argument_list|,
operator|&
name|read_error
argument_list|,
operator|&
name|read_result
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
if|if
condition|(
name|dish_error
argument_list|(
name|OPT
argument_list|,
operator|&
name|read_error
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|read_arg
operator|.
name|rda_object
operator|=
name|read_error
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
expr_stmt|;
block|}
if|if
condition|(
name|verify_alias
argument_list|(
operator|&
name|read_result
operator|.
name|rdr_entry
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Bad Alias.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
block|}
comment|/* Else search the subtree below this current  	 * position for ALL aliases, and check each one. */
comment|/* Sort out the search filter for this. */
name|search_arg
operator|.
name|sra_baseobject
operator|=
name|dn
expr_stmt|;
name|search_arg
operator|.
name|sra_subset
operator|=
name|SRA_WHOLESUBTREE
expr_stmt|;
name|search_arg
operator|.
name|sra_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_sizelimit
operator|=
name|SVC_NOSIZELIMIT
expr_stmt|;
name|search_arg
operator|.
name|sra_searchaliases
operator|=
name|FALSE
expr_stmt|;
name|search_arg
operator|.
name|sra_filter
operator|=
name|NULLFILTER
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|=
name|service_control
argument_list|(
name|OPT
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|search_arg
operator|.
name|sra_common
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
operator|(
name|search_arg
operator|.
name|sra_filter
operator|=
name|get_filter
argument_list|(
literal|"objectClass=alias"
argument_list|)
operator|)
operator|==
name|NULLFILTER
condition|)
block|{
name|ps_printf
argument_list|(
name|OPT
argument_list|,
literal|"Very bad... Filter wrong. Aborting...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Searching... please wait...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rebind
argument_list|()
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
comment|/* Strong authentication */
if|if
condition|(
name|search_arg
operator|.
name|sra_common
operator|.
name|ca_security
operator|!=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|signature
modifier|*
name|sign_operation
parameter_list|()
function_decl|;
name|int
name|encode_DAS_SearchArgumentData
parameter_list|()
function_decl|;
name|search_arg
operator|.
name|sra_common
operator|.
name|ca_sig
operator|=
name|sign_operation
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|search_arg
argument_list|,
name|encode_DAS_SearchArgumentData
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ds_search
argument_list|(
operator|&
name|search_arg
argument_list|,
operator|&
name|search_error
argument_list|,
operator|&
name|search_result
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
if|if
condition|(
name|dish_error
argument_list|(
name|OPT
argument_list|,
operator|&
name|search_error
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
name|search_arg
operator|.
name|sra_baseobject
operator|=
name|search_error
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
expr_stmt|;
block|}
name|correlate_search_results
argument_list|(
operator|&
name|search_result
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_result
operator|.
name|CSR_entries
operator|==
name|NULLENTRYINFO
condition|)
block|{
name|ps_printf
argument_list|(
name|OPT
argument_list|,
literal|"No aliases found...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
for|for
control|(
name|ptr
operator|=
name|search_result
operator|.
name|CSR_entries
init|;
name|ptr
operator|!=
name|NULLENTRYINFO
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|ent_next
control|)
block|{
comment|/* decode it immediately so we only have to do it once. */
name|cache_entry
argument_list|(
name|ptr
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify_alias
argument_list|(
name|ptr
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Bad Alias.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|handle_problems
argument_list|(
name|RPS
argument_list|,
name|search_result
operator|.
name|CSR_cr
argument_list|,
name|search_result
operator|.
name|CSR_limitproblem
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|filter_free
argument_list|(
name|search_arg
operator|.
name|sra_filter
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn
operator|=
name|dn_cpy
argument_list|(
name|save_dn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|save_dn
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_function
name|char
name|verify_alias
parameter_list|(
name|alias_entry
parameter_list|)
name|EntryInfo
modifier|*
name|alias_entry
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|nvec
index|[
literal|2
index|]
init|=
block|{
literal|"search"
block|}
decl_stmt|;
name|struct
name|DSError
name|read_error
decl_stmt|;
name|struct
name|ds_read_result
name|read_result
decl_stmt|;
name|struct
name|ds_read_arg
name|read_arg
decl_stmt|;
name|struct
name|attrcomp
modifier|*
name|tmp_ent_attr
decl_stmt|;
name|AttributeType
name|at_ojc
decl_stmt|;
name|AttributeType
name|at_aoj
decl_stmt|;
name|AttributeType
name|at_acl
decl_stmt|;
name|AttributeType
name|at_sa
decl_stmt|;
name|AttributeType
name|at_lmt
decl_stmt|;
name|AttributeType
name|at_lmb
decl_stmt|;
name|AttributeType
name|at_trs
decl_stmt|;
name|AttributeType
name|at_c
decl_stmt|;
name|AttributeType
name|at_o
decl_stmt|;
name|AttributeType
name|at_ou
decl_stmt|;
name|AttributeType
name|at_cn
decl_stmt|;
name|AV_Sequence
name|object_class_of_object
decl_stmt|;
name|AV_Sequence
name|tree_strAVS
init|=
name|NULLAV
decl_stmt|;
name|DN
name|dn_above_alias
decl_stmt|,
name|trail
decl_stmt|,
name|dnptr
decl_stmt|;
name|char
name|Name
init|=
name|FALSE
decl_stmt|,
name|Acl
init|=
name|FALSE
decl_stmt|,
name|ObjClass
init|=
name|FALSE
decl_stmt|,
name|AlObjNam
init|=
name|FALSE
decl_stmt|;
name|char
name|BackReference
init|=
name|FALSE
decl_stmt|;
name|char
name|GoodAlias
init|=
name|OK
decl_stmt|;
name|at_ojc
operator|=
name|AttrT_new
argument_list|(
literal|"objectClass"
argument_list|)
expr_stmt|;
comment|/* objectClass */
name|at_aoj
operator|=
name|AttrT_new
argument_list|(
literal|"aliasedObjectName"
argument_list|)
expr_stmt|;
name|at_acl
operator|=
name|AttrT_new
argument_list|(
literal|"acl"
argument_list|)
expr_stmt|;
name|at_sa
operator|=
name|AttrT_new
argument_list|(
literal|"seeAlso"
argument_list|)
expr_stmt|;
name|at_lmt
operator|=
name|AttrT_new
argument_list|(
literal|"lastModifiedTime"
argument_list|)
expr_stmt|;
name|at_lmb
operator|=
name|AttrT_new
argument_list|(
literal|"lastModifiedBy"
argument_list|)
expr_stmt|;
name|at_trs
operator|=
name|AttrT_new
argument_list|(
literal|"treeStructure"
argument_list|)
expr_stmt|;
name|at_c
operator|=
name|AttrT_new
argument_list|(
literal|"countryName"
argument_list|)
expr_stmt|;
name|at_o
operator|=
name|AttrT_new
argument_list|(
literal|"organizationName"
argument_list|)
expr_stmt|;
name|at_ou
operator|=
name|AttrT_new
argument_list|(
literal|"organizationalUnitName"
argument_list|)
expr_stmt|;
name|at_cn
operator|=
name|AttrT_new
argument_list|(
literal|"commonName"
argument_list|)
expr_stmt|;
name|nvec
index|[
literal|1
index|]
operator|=
literal|"-compact"
expr_stmt|;
name|read_arg
operator|.
name|rda_object
operator|=
name|NULLDN
expr_stmt|;
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"\nFound alias:"
argument_list|)
expr_stmt|;
name|dn_print
argument_list|(
name|OPT
argument_list|,
name|alias_entry
operator|->
name|ent_dn
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* We now have ourselves an entrystruct which is an alias, and we  	 * have to check various features!! 	 * 1: only the allowed objects. 	 * 2: the seeAlso attribute is correct (ie points to a real entry). 	 * 3: The objectClass of the real entry fits under where the alias 	 *    lives. 	 */
comment|/* Does the alias have the allowed objects and only the allowed? */
for|for
control|(
name|tmp_ent_attr
operator|=
name|alias_entry
operator|->
name|ent_attr
init|;
name|tmp_ent_attr
operator|!=
name|NULL
condition|;
name|tmp_ent_attr
operator|=
name|tmp_ent_attr
operator|->
name|attr_link
control|)
block|{
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_ojc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ObjClass
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_aoj
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_arg
operator|.
name|rda_object
operator|=
name|dn_cpy
argument_list|(
operator|(
name|DN
operator|)
name|tmp_ent_attr
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|)
expr_stmt|;
name|AlObjNam
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_acl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Acl
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_lmt
argument_list|)
operator|==
literal|0
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_lmb
argument_list|)
operator|==
literal|0
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_c
argument_list|)
operator|==
literal|0
operator|||
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_o
argument_list|)
operator|==
literal|0
operator|||
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_ou
argument_list|)
operator|==
literal|0
operator|||
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_cn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Name
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Illegal attribute type: "
argument_list|)
expr_stmt|;
name|AttrT_print
argument_list|(
name|OPT
argument_list|,
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|GoodAlias
operator|=
name|NOTOK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|read_arg
operator|.
name|rda_object
operator|==
name|NULLDN
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Malformed alias. No alias object name present!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|ObjClass
operator|==
name|FALSE
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Object Class missing.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AlObjNam
operator|==
name|FALSE
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Alias Object name missing.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Acl
operator|==
name|FALSE
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"ACL missing.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Name
operator|==
name|FALSE
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Name of alias is missing.\n"
argument_list|)
expr_stmt|;
block|}
name|GoodAlias
operator|=
operator|(
operator|(
name|ObjClass
operator|&&
name|AlObjNam
operator|&&
name|Acl
operator|&&
name|Name
operator|)
condition|?
name|OK
else|:
name|NOTOK
operator|)
expr_stmt|;
comment|/* Read the entry that the alias points to.... */
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_allattributes
operator|=
name|TRUE
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_select
operator|=
name|NULLATTR
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_infotypes
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|service_control
argument_list|(
name|OPT
argument_list|,
literal|0
argument_list|,
name|NULLARGV
argument_list|,
operator|&
name|read_arg
operator|.
name|rda_common
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_options
operator||=
name|SVC_OPT_DONTDEREFERENCEALIAS
expr_stmt|;
comment|/* Strong authentication */
if|if
condition|(
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_security
operator|!=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|signature
modifier|*
name|sign_operation
parameter_list|()
function_decl|;
name|int
name|encode_DAS_ReadArgumentData
parameter_list|()
function_decl|;
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_sig
operator|=
name|sign_operation
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_arg
argument_list|,
name|encode_DAS_ReadArgumentData
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ds_read
argument_list|(
operator|&
name|read_arg
argument_list|,
operator|&
name|read_error
argument_list|,
operator|&
name|read_result
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
if|if
condition|(
name|dish_error
argument_list|(
name|OPT
argument_list|,
operator|&
name|read_error
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Can't read "
argument_list|)
expr_stmt|;
name|dn_print
argument_list|(
name|OPT
argument_list|,
name|read_arg
operator|.
name|rda_object
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|GoodAlias
operator|)
return|;
block|}
name|read_arg
operator|.
name|rda_object
operator|=
name|read_error
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
expr_stmt|;
block|}
comment|/* and see if it points back to this alias.  	 * It should do, but doesn't have to. While we are at it, 	 * collect the objectClass of this entry. 	 */
for|for
control|(
name|tmp_ent_attr
operator|=
name|read_result
operator|.
name|rdr_entry
operator|.
name|ent_attr
init|;
name|tmp_ent_attr
operator|!=
name|NULL
condition|;
name|tmp_ent_attr
operator|=
name|tmp_ent_attr
operator|->
name|attr_link
control|)
block|{
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_sa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|AV_Sequence
name|tmp_avs
init|=
name|tmp_ent_attr
operator|->
name|attr_value
decl_stmt|;
for|for
control|(
init|;
name|tmp_avs
operator|!=
name|NULL
condition|;
name|tmp_avs
operator|=
name|tmp_avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
name|dn_cmp
argument_list|(
operator|(
name|DN
operator|)
name|tmp_avs
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|,
name|alias_entry
operator|->
name|ent_dn
argument_list|)
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Alias object correctly points back to alias itself.\n"
argument_list|)
expr_stmt|;
name|BackReference
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_ojc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|object_class_of_object
operator|=
name|avs_cpy
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BackReference
operator|==
name|FALSE
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Alias object should point back to alias.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object_class_of_object
operator|==
name|NULLAV
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Can't find object class of aliased object\n. Assuming OK\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|GoodAlias
operator|)
return|;
block|}
comment|/* Move above the alias in order to find the treeStructure. */
name|dn_above_alias
operator|=
name|dn_cpy
argument_list|(
name|alias_entry
operator|->
name|ent_dn
argument_list|)
expr_stmt|;
for|for
control|(
name|dnptr
operator|=
name|dn_above_alias
init|;
name|dnptr
operator|->
name|dn_parent
operator|!=
name|NULLDN
condition|;
name|dnptr
operator|=
name|dnptr
operator|->
name|dn_parent
control|)
name|trail
operator|=
name|dnptr
expr_stmt|;
name|dn_comp_free
argument_list|(
name|dnptr
argument_list|)
expr_stmt|;
name|trail
operator|->
name|dn_parent
operator|=
name|NULLDN
expr_stmt|;
comment|/* Now read it... */
name|read_arg
operator|.
name|rda_object
operator|=
name|dn_cpy
argument_list|(
name|dn_above_alias
argument_list|)
expr_stmt|;
comment|/* Strong authentication */
if|if
condition|(
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_security
operator|!=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|signature
modifier|*
name|sign_operation
parameter_list|()
function_decl|;
name|int
name|encode_DAS_ReadArgumentData
parameter_list|()
function_decl|;
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_sig
operator|=
name|sign_operation
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|read_arg
argument_list|,
name|encode_DAS_ReadArgumentData
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ds_read
argument_list|(
operator|&
name|read_arg
argument_list|,
operator|&
name|read_error
argument_list|,
operator|&
name|read_result
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
if|if
condition|(
name|dish_error
argument_list|(
name|OPT
argument_list|,
operator|&
name|read_error
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|read_arg
operator|.
name|rda_object
operator|=
name|read_error
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
expr_stmt|;
block|}
for|for
control|(
name|tmp_ent_attr
operator|=
name|read_result
operator|.
name|rdr_entry
operator|.
name|ent_attr
init|;
name|tmp_ent_attr
operator|!=
name|NULL
condition|;
name|tmp_ent_attr
operator|=
name|tmp_ent_attr
operator|->
name|attr_link
control|)
block|{
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_type
argument_list|,
name|at_trs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree_strAVS
operator|=
name|avs_cpy
argument_list|(
name|tmp_ent_attr
operator|->
name|attr_value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tree_strAVS
operator|==
name|NULLAV
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Tree structure missing - assuming validity.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test_schema
argument_list|(
name|tree_strAVS
argument_list|,
name|object_class_of_object
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ps_print
argument_list|(
name|OPT
argument_list|,
literal|"Tree structure bad...\n"
argument_list|)
expr_stmt|;
name|GoodAlias
operator|=
name|NOTOK
expr_stmt|;
block|}
return|return
operator|(
name|GoodAlias
operator|)
return|;
block|}
end_function

begin_macro
name|shadow_entry
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

end_unit

