begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: access.c,v 1.26 88/09/06 15:51:03 jim Exp $ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/*  * i'm sorry, i'm sorry  *  * By Analogy with per host auth, we keep all the TSAPaddr but  * do access control on NSAPaddr part only...  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"site.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hpux */
end_comment

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCPCONN
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPCONN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_include
include|#
directive|include
file|<netdnet/dnetdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_include
include|#
directive|include
file|<isode/psap.h>
end_include

begin_include
include|#
directive|include
file|<isode/tsap.h>
end_include

begin_include
include|#
directive|include
file|<isode/isoservent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"dixstruct.h"
end_include

begin_include
include|#
directive|include
file|"osdep.h"
end_include

begin_define
define|#
directive|define
name|acmp
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|,
name|len
parameter_list|)
value|bcmp((char *)(a1), (char *)(a2), len)
end_define

begin_define
define|#
directive|define
name|acopy
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|,
name|len
parameter_list|)
value|bcopy((char *)(a1), (char *)(a2), len)
end_define

begin_define
define|#
directive|define
name|DONT_CHECK
value|-1
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|_host
block|{
name|short
name|family
decl_stmt|;
name|short
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPaddr
name|addr
decl_stmt|;
comment|/* and so it is!! */
else|#
directive|else
comment|/* ISOCONN */
name|unsigned
name|char
name|addr
index|[
literal|4
index|]
decl_stmt|;
comment|/* will need to be bigger eventually */
endif|#
directive|endif
comment|/* ISOCONN */
name|struct
name|_host
modifier|*
name|next
decl_stmt|;
block|}
name|HOST
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|HOST
modifier|*
name|selfhosts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST
modifier|*
name|validhosts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|AccessEnabled
init|=
name|DEFAULT_ACCESS_CONTROL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|af
decl_stmt|,
name|xf
decl_stmt|;
block|}
name|FamilyMap
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|FamilyMap
name|familyMap
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * This has to be visible to the protocol via X.h...  */
block|{
name|AF_OSI
block|,
name|FamilyIso
block|}
block|,
endif|#
directive|endif
comment|/* ISOCONN */
ifdef|#
directive|ifdef
name|AF_DECnet
block|{
name|AF_DECnet
block|,
name|FamilyDECnet
block|}
block|,
endif|#
directive|endif
comment|/* AF_DECnet */
ifdef|#
directive|ifdef
name|AF_CHAOS
block|{
name|AF_CHAOS
block|,
name|FamilyChaos
block|}
block|,
endif|#
directive|endif
comment|/* AF_CHAOS */
ifdef|#
directive|ifdef
name|AF_INET
block|{
name|AF_INET
block|,
name|FamilyInternet
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FAMILIES
value|((sizeof familyMap)/(sizeof familyMap[0]))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_comment
comment|/* Define this host for access control.  Find all the hosts the OS knows about   * for this fd and add them to the selfhosts list.  * HPUX version - hpux does not have SIOCGIFCONF ioctl;  */
end_comment

begin_macro
name|DefineSelf
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|family
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
name|struct
name|utsname
name|name
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|in
decl_stmt|;
block|}
name|saddr
union|;
name|struct
name|sockaddr_in
modifier|*
name|inetaddr
decl_stmt|;
comment|/* Why not use gethostname()?  Well, at least on my system, I've had to      * make an ugly kernel patch to get a name longer than 8 characters, and      * uname() lets me access to the whole string (it smashes release, you      * see), whereas gethostname() kindly truncates it for me.      */
name|uname
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
operator|.
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|saddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|inetaddr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
operator|(
name|saddr
operator|.
name|sa
operator|)
operator|)
expr_stmt|;
name|acopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
operator|(
name|inetaddr
operator|->
name|sin_addr
operator|)
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|family
operator|=
name|ConvertAddr
argument_list|(
operator|&
operator|(
name|saddr
operator|.
name|sa
operator|)
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|family
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|host
operator|=
name|selfhosts
init|;
name|host
operator|&&
operator|(
name|family
operator|!=
name|host
operator|->
name|family
operator|||
name|acmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
operator|)
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
comment|/* add this host to the host list.	*/
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|family
operator|=
name|family
expr_stmt|;
name|host
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|acopy
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|host
operator|->
name|next
operator|=
name|selfhosts
expr_stmt|;
name|selfhosts
operator|=
name|host
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Define this host for access control.  Find all the hosts the OS knows about   * for this fd and add them to the selfhosts list.  */
end_comment

begin_macro
name|DefineSelf
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|pointer
name|addr
decl_stmt|;
name|int
name|family
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|AEI
name|aei
decl_stmt|;
name|struct
name|PSAPaddr
modifier|*
name|pa
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
ifdef|#
directive|ifdef
name|TCPCONN
name|||
name|UNIXCONN
name|||
name|DNETCONN
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|int
operator|)
name|SIOCGIFCONF
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
name|Error
argument_list|(
literal|"Getting interface configuration"
argument_list|)
expr_stmt|;
for|for
control|(
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
operator|,
name|n
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|ifr
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DNETCONN
comment|/* 	 * this is ugly but SIOCGIFCONF returns decnet addresses in 	 * a different form from other decnet calls 	 */
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|==
name|AF_DECnet
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_naddr
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|pointer
operator|)
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_data
expr_stmt|;
name|family
operator|=
name|AF_DECnet
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* DNETCONN */
if|if
condition|(
operator|(
name|family
operator|=
name|ConvertAddr
argument_list|(
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|<=
literal|0
condition|)
continue|continue;
for|for
control|(
name|host
operator|=
name|selfhosts
init|;
name|host
operator|&&
operator|(
name|family
operator|!=
name|host
operator|->
name|family
operator|||
name|acmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
operator|)
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|host
condition|)
continue|continue;
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|family
operator|=
name|family
expr_stmt|;
name|host
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|acopy
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|host
operator|->
name|next
operator|=
name|selfhosts
expr_stmt|;
name|selfhosts
operator|=
name|host
expr_stmt|;
block|}
endif|#
directive|endif
endif|TCPCONN
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*   * This is dubious - we should be able to take an fd (transport  * descriptor) and get the list of possible transport interfaces...  *  * Well strictly, for this TSAP, a list of NSAPs that are valid  */
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|family
operator|=
name|AF_OSI
expr_stmt|;
name|aei
operator|=
name|str2aei
argument_list|(
name|TLocalHostName
argument_list|()
argument_list|,
name|DEFAULTTSERVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aei
operator|==
name|NULLAEI
condition|)
block|{
name|Error
argument_list|(
literal|"Unknown Display\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pa
operator|=
name|aei2addr
argument_list|(
name|aei
argument_list|)
operator|)
operator|==
name|NULLPA
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"address translation failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|acopy
argument_list|(
operator|&
operator|(
name|pa
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|TSAPaddr
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|len
operator|=
name|NASIZE
expr_stmt|;
name|host
operator|->
name|next
operator|=
name|selfhosts
expr_stmt|;
name|selfhosts
operator|=
name|host
expr_stmt|;
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|hp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Self: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|host
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|(
operator|*
name|hp
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISODEBUG */
endif|#
directive|endif
comment|/* ISOCONN */
block|}
end_block

begin_endif
endif|#
directive|endif
endif|hpux
end_endif

begin_comment
comment|/* Reset access control list to initial hosts */
end_comment

begin_macro
name|ResetHosts
argument_list|(
argument|display
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|,
modifier|*
name|self
decl_stmt|;
name|char
name|hostname
index|[
literal|120
index|]
decl_stmt|;
name|char
name|fname
index|[
literal|32
index|]
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
ifdef|#
directive|ifdef
name|TCPCONN
name|struct
name|sockaddr_in
name|in
decl_stmt|;
endif|#
directive|endif
comment|/* TCPCONN */
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|sockaddr_dn
name|dn
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPaddr
name|ta
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
name|saddr
union|;
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|nodeent
modifier|*
name|np
decl_stmt|;
name|struct
name|dn_naddr
name|dnaddr
decl_stmt|,
modifier|*
name|dnaddrp
decl_stmt|,
modifier|*
name|dnet_addr
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|int
name|family
decl_stmt|;
name|int
name|len
decl_stmt|;
name|pointer
name|addr
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|AccessEnabled
operator|=
name|DEFAULT_ACCESS_CONTROL
expr_stmt|;
while|while
condition|(
name|host
operator|=
name|validhosts
condition|)
block|{
name|validhosts
operator|=
name|host
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|self
operator|=
name|selfhosts
init|;
name|self
condition|;
name|self
operator|=
name|self
operator|->
name|next
control|)
block|{
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|host
operator|=
operator|*
name|self
expr_stmt|;
name|host
operator|->
name|next
operator|=
name|validhosts
expr_stmt|;
name|validhosts
operator|=
name|host
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|fname
argument_list|,
literal|"/etc/X"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|".hosts"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|,
name|fd
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|=
name|index
argument_list|(
name|hostname
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|hostname
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* node name (DECnet names end in "::") */
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dnaddrp
operator|=
name|dnet_addr
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
comment|/* allow nodes to be specified by address */
name|NewHost
argument_list|(
operator|(
name|short
operator|)
name|AF_DECnet
argument_list|,
operator|(
name|pointer
operator|)
name|dnaddrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
comment|/* node was specified by name */
name|saddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|np
operator|->
name|n_addrtype
expr_stmt|;
if|if
condition|(
operator|(
name|family
operator|=
name|ConvertAddr
argument_list|(
operator|&
name|saddr
operator|.
name|sa
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|==
name|AF_DECnet
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|pointer
operator|)
operator|&
name|dnaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|dnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|dnaddr
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|acopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
name|dnaddr
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
name|NewHost
argument_list|(
name|family
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|dnaddr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* DNETCONN */
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * ISO displays are host:T-Namedisplay number  * only AEI are allowed (i.e. no raw addrs)   * XXX Fix to allow T/X and other T-Names...  */
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|hostname
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
operator|||
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|'T'
operator|)
operator|)
condition|)
block|{
name|AEI
name|aei
decl_stmt|;
name|struct
name|PSAPaddr
modifier|*
name|pa
decl_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|aei
operator|=
name|str2aei
argument_list|(
name|hostname
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|aei
operator|=
name|str2aei
argument_list|(
name|hostname
argument_list|,
name|DEFAULTTSERVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aei
operator|==
name|NULLAEI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s Unknown Display\n"
argument_list|,
name|hostname
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|pa
operator|=
name|aei2addr
argument_list|(
name|aei
argument_list|)
operator|)
operator|==
name|NULLPA
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"address translation failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|family
operator|=
name|AF_OSI
expr_stmt|;
name|NewHost
argument_list|(
name|family
argument_list|,
name|pa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|ISOCONN
ifdef|#
directive|ifdef
name|TCPCONN
comment|/* host name */
if|if
condition|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
name|saddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
if|if
condition|(
operator|(
name|family
operator|=
name|ConvertAddr
argument_list|(
operator|&
name|saddr
operator|.
name|sa
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|>
literal|0
condition|)
ifdef|#
directive|ifdef
name|NEW_HEADER_WITH_OLD_LIBRARY
name|NewHost
argument_list|(
name|family
argument_list|,
operator|(
name|pointer
operator|)
name|hp
operator|->
name|h_addr_list
argument_list|)
expr_stmt|;
else|#
directive|else
name|NewHost
argument_list|(
name|family
argument_list|,
operator|(
name|pointer
operator|)
name|hp
operator|->
name|h_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* TCPCONN */
ifdef|#
directive|ifdef
name|DNETCONN
block|}
endif|#
directive|endif
comment|/* DNETCONN */
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|Bool
name|AuthorizedClient
parameter_list|(
name|client
parameter_list|)
name|ClientPtr
name|client
decl_stmt|;
block|{
name|int
name|alen
decl_stmt|,
name|family
decl_stmt|;
ifndef|#
directive|ifndef
name|ISOCONN
name|struct
name|sockaddr
name|from
decl_stmt|;
endif|#
directive|endif
name|pointer
name|addr
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPaddr
name|from
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * XXXXXXXXXXXXXXXXX  * Just til I fix the X.25 calling addr stuff  */
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* ISOCONN */
name|alen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
if|if
condition|(
operator|!
name|SGetPeerName
argument_list|(
operator|(
operator|(
name|OsCommPtr
operator|)
name|client
operator|->
name|osPrivate
operator|)
operator|->
name|fd
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|)
condition|)
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
operator|!
name|getpeername
argument_list|(
operator|(
operator|(
name|OsCommPtr
operator|)
name|client
operator|->
name|osPrivate
operator|)
operator|->
name|fd
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ISOCONN */
block|{
if|if
condition|(
operator|(
name|family
operator|=
name|ConvertAddr
argument_list|(
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|family
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|host
operator|=
name|selfhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|alen
argument_list|)
condition|)
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|alen
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ISOCONN */
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Add a host to the access control list.  This is the external interface  * called from the dispatcher */
end_comment

begin_function
name|int
name|AddHost
parameter_list|(
name|client
parameter_list|,
name|family
parameter_list|,
name|length
parameter_list|,
name|pAddr
parameter_list|)
name|ClientPtr
name|client
decl_stmt|;
name|int
name|family
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
comment|/* of bytes in pAddr */
name|pointer
name|pAddr
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
name|int
name|unixFamily
decl_stmt|;
if|if
condition|(
operator|!
name|AuthorizedClient
argument_list|(
name|client
argument_list|)
condition|)
return|return
operator|(
name|BadAccess
operator|)
return|;
name|unixFamily
operator|=
name|UnixFamily
argument_list|(
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|CheckFamily
argument_list|(
name|DONT_CHECK
argument_list|,
name|unixFamily
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|client
operator|->
name|errorValue
operator|=
name|family
expr_stmt|;
return|return
operator|(
operator|-
name|len
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
name|length
condition|)
block|{
name|client
operator|->
name|errorValue
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|BadValue
operator|)
return|;
block|}
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
if|if
condition|(
name|unixFamily
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|pAddr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
name|Success
operator|)
return|;
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
name|unixFamily
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|pAddr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
name|Success
operator|)
return|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|family
operator|=
name|unixFamily
expr_stmt|;
name|host
operator|->
name|len
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|acopy
argument_list|(
name|pAddr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|acopy
argument_list|(
name|pAddr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|host
operator|->
name|next
operator|=
name|validhosts
expr_stmt|;
name|validhosts
operator|=
name|host
expr_stmt|;
return|return
operator|(
name|Success
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a host to the access control list. This is the internal interface   * called when starting or resetting the server */
end_comment

begin_macro
name|NewHost
argument_list|(
argument|family
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|short
name|family
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pointer
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|CheckFamily
argument_list|(
name|DONT_CHECK
argument_list|,
name|family
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|len
argument_list|)
condition|)
return|return;
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|family
operator|=
name|family
expr_stmt|;
name|host
operator|->
name|len
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|acopy
argument_list|(
name|addr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|acopy
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|host
operator|->
name|next
operator|=
name|validhosts
expr_stmt|;
name|validhosts
operator|=
name|host
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remove a host from the access control list */
end_comment

begin_function
name|int
name|RemoveHost
parameter_list|(
name|client
parameter_list|,
name|family
parameter_list|,
name|length
parameter_list|,
name|pAddr
parameter_list|)
name|ClientPtr
name|client
decl_stmt|;
name|int
name|family
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
comment|/* of bytes in pAddr */
name|pointer
name|pAddr
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|unixFamily
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
operator|!
name|AuthorizedClient
argument_list|(
name|client
argument_list|)
condition|)
return|return
operator|(
name|BadAccess
operator|)
return|;
name|unixFamily
operator|=
name|UnixFamily
argument_list|(
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|CheckFamily
argument_list|(
name|DONT_CHECK
argument_list|,
name|unixFamily
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|client
operator|->
name|errorValue
operator|=
name|family
expr_stmt|;
return|return
operator|(
operator|-
name|len
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
name|length
condition|)
block|{
name|client
operator|->
name|errorValue
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|BadValue
operator|)
return|;
block|}
for|for
control|(
name|prev
operator|=
operator|&
name|validhosts
init|;
operator|(
name|host
operator|=
operator|*
name|prev
operator|)
operator|&&
operator|(
name|unixFamily
operator|!=
name|host
operator|->
name|family
operator|||
ifdef|#
directive|ifdef
name|ISOCONN
name|acmp
argument_list|(
name|pAddr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|len
argument_list|)
operator|)
condition|;
else|#
directive|else
comment|/* ISOCONN */
name|acmp
argument_list|(
name|pAddr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
control|)
empty_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|prev
operator|=
operator|&
name|host
operator|->
name|next
block|)
function|;
end_function

begin_if
if|if
condition|(
name|host
condition|)
block|{
operator|*
name|prev
operator|=
name|host
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
operator|(
name|Success
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* Get all hosts in the access control list */
end_comment

begin_macro
unit|int
name|GetHosts
argument_list|(
argument|data
argument_list|,
argument|pnHosts
argument_list|,
argument|pEnabled
argument_list|)
end_macro

begin_decl_stmt
name|pointer
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pnHosts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOL
modifier|*
name|pEnabled
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|pointer
name|ptr
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
name|int
name|nHosts
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|lengths
init|=
operator|(
name|int
operator|*
operator|)
name|NULL
decl_stmt|;
operator|*
name|pEnabled
operator|=
name|AccessEnabled
condition|?
name|EnableAccess
else|:
name|DisableAccess
expr_stmt|;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|CheckFamily
argument_list|(
name|DONT_CHECK
argument_list|,
name|host
operator|->
name|family
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lengths
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|lengths
argument_list|,
operator|(
name|nHosts
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|lengths
index|[
name|nHosts
operator|++
index|]
operator|=
name|len
expr_stmt|;
name|n
operator|+=
operator|(
operator|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
operator|*
name|data
operator|=
name|ptr
operator|=
operator|(
name|pointer
operator|)
name|xalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|nHosts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|hp
init|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|host
operator|->
name|addr
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"List(%d): "
argument_list|,
name|host
operator|->
name|family
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|(
operator|*
name|hp
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|ISODEBUG
endif|#
directive|endif
comment|/* ISOCONN */
name|len
operator|=
name|lengths
index|[
name|nHosts
operator|++
index|]
expr_stmt|;
operator|(
operator|(
name|xHostEntry
operator|*
operator|)
name|ptr
operator|)
operator|->
name|family
operator|=
name|XFamily
argument_list|(
name|host
operator|->
name|family
argument_list|)
expr_stmt|;
operator|(
operator|(
name|xHostEntry
operator|*
operator|)
name|ptr
operator|)
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|xHostEntry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|acopy
argument_list|(
operator|&
name|host
operator|->
name|addr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|acopy
argument_list|(
name|host
operator|->
name|addr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|ptr
operator|+=
operator|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
block|}
operator|*
name|pnHosts
operator|=
name|nHosts
expr_stmt|;
name|xfree
argument_list|(
name|lengths
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Check for valid address family, and for local host if client modification.  * Return address length.  */
end_comment

begin_macro
name|CheckFamily
argument_list|(
argument|connection
argument_list|,
argument|family
argument_list|)
end_macro

begin_decl_stmt
name|int
name|connection
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|family
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPaddr
name|from
decl_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|struct
name|sockaddr
name|from
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|int
name|alen
decl_stmt|;
name|pointer
name|addr
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
ifdef|#
directive|ifdef
name|TCPCONN
case|case
name|AF_INET
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DNETCONN
case|case
name|AF_DECnet
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_naddr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISOCONN
case|case
name|AF_OSI
case|:
name|len
operator|=
name|NASIZE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ISOCONN */
default|default:
return|return
operator|(
operator|-
name|BadValue
operator|)
return|;
block|}
if|if
condition|(
name|connection
operator|==
name|DONT_CHECK
condition|)
return|return
operator|(
name|len
operator|)
return|;
ifdef|#
directive|ifdef
name|ISOCONN
name|alen
operator|=
name|NASIZE
expr_stmt|;
if|if
condition|(
operator|!
name|SGetPeerName
argument_list|(
name|connection
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|)
condition|)
else|#
directive|else
comment|/* ISOCONN */
name|alen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getpeername
argument_list|(
name|connection
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ISOCONN */
block|{
if|if
condition|(
operator|(
name|family
operator|=
name|ConvertAddr
argument_list|(
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|family
operator|==
literal|0
condition|)
return|return
operator|(
name|len
operator|)
return|;
for|for
control|(
name|host
operator|=
name|selfhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
ifdef|#
directive|ifdef
name|ISOCONN
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|alen
argument_list|)
condition|)
else|#
directive|else
comment|/* ISOCONN */
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|alen
argument_list|)
block|)
endif|#
directive|endif
comment|/* ISOCONN */
return|return
operator|(
name|len
operator|)
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Bad Access */
end_comment

begin_return
return|return
operator|(
operator|-
literal|1
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* Check if a host is not in the access control list.   * Returns 1 if host is invalid, 0 if we've found it. */
end_comment

begin_expr_stmt
unit|InvalidHost
operator|(
name|saddr
operator|,
name|len
operator|)
ifdef|#
directive|ifdef
name|ISOCONN
specifier|register
expr|struct
name|TSAPaddr
operator|*
name|saddr
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|family
decl_stmt|;
name|pointer
name|addr
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|len
operator|=
name|NASIZE
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
operator|(
name|family
operator|=
name|ConvertAddr
argument_list|(
name|saddr
argument_list|,
name|len
condition|?
operator|&
name|len
else|:
literal|0
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|ISOCONN
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|hp
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|addr
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Other(%d): "
argument_list|,
name|family
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|(
operator|*
name|hp
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISODEBUG */
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|family
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * XXXXXXXXXXXXXXXXX  * Just til I fix the X.25 calling addr stuff  */
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|AccessEnabled
condition|)
comment|/* just let them in */
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|hp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"List(%d): "
argument_list|,
name|host
operator|->
name|family
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|host
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|(
operator|*
name|hp
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISODEBUG */
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
operator|&
operator|(
name|host
operator|->
name|addr
operator|)
argument_list|,
name|len
argument_list|)
condition|)
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|acmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ISOCONN */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ConvertAddr
argument_list|(
name|saddr
argument_list|,
name|len
argument_list|,
name|addr
argument_list|)
ifdef|#
directive|ifdef
name|ISOCONN
specifier|register
expr|struct
name|TSAPaddr
operator|*
name|saddr
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|int
modifier|*
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pointer
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * NULL ish type acttion, but maybe later we'd change this to  * use AEIs as the thing for access ctl, and need to get from  * transport descriptor to T-SAPs to AEI...  */
operator|*
name|len
operator|=
name|NASIZE
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
name|pointer
operator|)
name|saddr
expr_stmt|;
return|return
operator|(
name|AF_OSI
operator|)
return|;
else|#
directive|else
comment|/* ISOCONN */
switch|switch
condition|(
name|saddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
ifndef|#
directive|ifndef
name|hpux
case|case
name|AF_UNIX
case|:
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|TCPCONN
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
name|pointer
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|saddr
operator|)
operator|->
name|sin_addr
operator|)
expr_stmt|;
return|return
operator|(
name|AF_INET
operator|)
return|;
else|#
directive|else
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DNETCONN
case|case
name|AF_DECnet
case|:
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_naddr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
name|pointer
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_dn
operator|*
operator|)
name|saddr
operator|)
operator|->
name|sdn_add
operator|)
expr_stmt|;
return|return
operator|(
name|AF_DECnet
operator|)
return|;
else|#
directive|else
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
end_block

begin_function
name|int
name|ChangeAccessControl
parameter_list|(
name|client
parameter_list|,
name|fEnabled
parameter_list|)
name|ClientPtr
name|client
decl_stmt|;
name|int
name|fEnabled
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|AuthorizedClient
argument_list|(
name|client
argument_list|)
condition|)
return|return
name|BadAccess
return|;
name|AccessEnabled
operator|=
name|fEnabled
expr_stmt|;
return|return
name|Success
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|XFamily
parameter_list|(
name|af
parameter_list|)
name|int
name|af
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FAMILIES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|familyMap
index|[
name|i
index|]
operator|.
name|af
operator|==
name|af
condition|)
return|return
name|familyMap
index|[
name|i
index|]
operator|.
name|xf
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|UnixFamily
parameter_list|(
name|xf
parameter_list|)
name|int
name|xf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FAMILIES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|familyMap
index|[
name|i
index|]
operator|.
name|xf
operator|==
name|xf
condition|)
return|return
name|familyMap
index|[
name|i
index|]
operator|.
name|af
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

