begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright 1985, 1986, 1987 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission. M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_xhost_c
init|=
literal|"$XConsortium: xhost.c,v 11.28 88/10/11 12:48:06 jim Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_expr_stmt
name|bogus
name|definition
name|of
name|inet_makeaddr
argument_list|()
name|in
name|BSD
literal|4.2
name|and
name|Ultrix
else|#
directive|else
specifier|extern
name|unsigned
name|long
name|inet_makeaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_include
include|#
directive|include
file|<netdnet/dnetdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xproto.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xmu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_include
include|#
directive|include
file|<isode/psap.h>
end_include

begin_include
include|#
directive|include
file|<isode/tsap.h>
end_include

begin_include
include|#
directive|include
file|<isode/isoservent.h>
end_include

begin_include
include|#
directive|include
file|"../server/osdep.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_function_decl
specifier|static
name|int
name|local_xerror
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NAMESERVER_TIMEOUT
value|5
end_define

begin_comment
comment|/* time to wait for nameserver */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|af
decl_stmt|,
name|xf
decl_stmt|;
block|}
name|FamilyMap
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|FamilyMap
name|familyMap
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|AF_DECnet
block|{
name|AF_DECnet
block|,
name|FamilyDECnet
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AF_CHAOS
block|{
name|AF_CHAOS
block|,
name|FamilyChaos
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AF_OSI
block|{
name|AF_OSI
block|,
name|FamilyIso
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AF_INET
block|{
name|AF_INET
block|,
name|FamilyInternet
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FAMILIES
value|((sizeof familyMap)/(sizeof familyMap[0]))
end_define

begin_decl_stmt
name|int
name|nameserver_timedout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ProgramName
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|XFamily
parameter_list|(
name|af
parameter_list|)
name|int
name|af
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FAMILIES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|familyMap
index|[
name|i
index|]
operator|.
name|af
operator|==
name|af
condition|)
return|return
name|familyMap
index|[
name|i
index|]
operator|.
name|xf
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|Display
modifier|*
name|dpy
decl_stmt|;
name|char
name|host
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|display
decl_stmt|,
name|i
decl_stmt|,
name|w
decl_stmt|,
name|nhosts
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|get_hostname
argument_list|()
decl_stmt|;
name|XHostAddress
modifier|*
name|list
decl_stmt|;
name|Bool
name|enabled
init|=
name|False
decl_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
name|char
modifier|*
name|dnet_htoa
parameter_list|()
function_decl|;
name|struct
name|nodeent
modifier|*
name|np
decl_stmt|;
name|struct
name|dn_naddr
modifier|*
name|nlist
decl_stmt|,
name|dnaddr
decl_stmt|,
modifier|*
name|dnaddrp
decl_stmt|,
modifier|*
name|dnet_addr
argument_list|()
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
endif|#
directive|endif
name|ProgramName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * XXX Shouldd parse -display display here  */
if|if
condition|(
operator|(
name|dpy
operator|=
name|XOpenDisplay
argument_list|(
literal|"perky:X0"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dpy
operator|=
name|XOpenDisplay
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  unable to open display \"%s\"\n"
argument_list|,
name|ProgramName
argument_list|,
name|XDisplayName
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|XSetErrorHandler
argument_list|(
name|local_xerror
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DNETCONN
name|setnodeent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* keep the database accessed */
endif|#
directive|endif
name|sethostent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* don't close the data base each time */
name|list
operator|=
name|XListHosts
argument_list|(
name|dpy
argument_list|,
operator|&
name|nhosts
argument_list|,
operator|&
name|enabled
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"access control %s\n"
argument_list|,
operator|(
name|enabled
condition|?
literal|"enabled (only the following hosts are allowed)"
else|:
literal|"disabled (any host is allowed)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhosts
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhosts
condition|;
name|i
operator|++
control|)
block|{
name|hostname
operator|=
name|get_hostname
argument_list|(
operator|&
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameserver_timedout
condition|)
name|printf
argument_list|(
literal|"(nameserver did not respond in %d seconds)\n"
argument_list|,
name|NAMESERVER_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|endhostent
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|&&
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|argc
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"all hosts being restricted (access control enabled)\n"
argument_list|)
expr_stmt|;
name|XEnableAccessControl
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|?
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
else|:
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|change_host
argument_list|(
name|dpy
argument_list|,
name|arg
argument_list|,
name|False
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  bad hostname \"%s\"\n"
argument_list|,
name|ProgramName
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|arg
operator|==
literal|'+'
operator|&&
operator|!
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|&&
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|argc
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"all hosts being allowed (access control disabled)\n"
argument_list|)
expr_stmt|;
name|XDisableAccessControl
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|arg
operator|==
literal|'+'
condition|)
block|{
name|arg
operator|=
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|?
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
else|:
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|change_host
argument_list|(
name|dpy
argument_list|,
name|arg
argument_list|,
name|True
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  bad hostname \"%s\"\n"
argument_list|,
name|ProgramName
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|XCloseDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
comment|/* does an XSync first */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  * change_host - edit the list of hosts that may connect to the server;  * it parses DECnet names (expo::), Internet addresses (18.30.0.212), or  * Internet names (expo.lcs.mit.edu); if 4.3bsd macro h_addr is defined  * (from<netdb.h>), it will add or remove all addresses with the given  * address.  */
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * ISO T-Service is selected by server:T-Name:Display  * where T-Name must start non numeric (i.e. default is by ommission  *  */
endif|#
directive|endif
comment|/* ISOCONN */
name|int
name|change_host
parameter_list|(
name|dpy
parameter_list|,
name|name
parameter_list|,
name|add
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Bool
name|add
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|XHostAddress
name|ha
decl_stmt|;
specifier|static
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* so we can point at it */
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|dn_naddr
modifier|*
name|dnaddrp
decl_stmt|;
name|struct
name|nodeent
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|struct
name|dn_naddr
name|dnaddr
decl_stmt|;
endif|#
directive|endif
comment|/* DNETCONN */
specifier|static
name|char
modifier|*
name|add_msg
init|=
literal|"being added to access control list"
decl_stmt|;
specifier|static
name|char
modifier|*
name|remove_msg
init|=
literal|"being removed from access control list"
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|char
modifier|*
name|cp
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|ha
operator|.
name|family
operator|=
name|FamilyDECnet
expr_stmt|;
if|if
condition|(
name|dnaddrp
operator|=
name|dnet_addr
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|dnaddr
operator|=
operator|*
name|dnaddrp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  unble to get node name for \"%s::\"\n"
argument_list|,
name|ProgramName
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dnaddr
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|bcopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
name|dnaddr
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
block|}
name|ha
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_naddr
argument_list|)
expr_stmt|;
name|ha
operator|.
name|address
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dnaddr
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|XAddHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:: %s\n"
argument_list|,
name|name
argument_list|,
name|add_msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XRemoveHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:: %s\n"
argument_list|,
name|name
argument_list|,
name|remove_msg
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* DNETCONN */
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * TServiceNameDisplayNumber...  */
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
operator|||
operator|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|'T'
operator|)
operator|)
condition|)
block|{
name|AEI
name|aei
decl_stmt|;
name|struct
name|PSAPaddr
modifier|*
name|pa
decl_stmt|;
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|ha
operator|.
name|family
operator|=
name|FamilyIso
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|aei
operator|=
name|str2aei
argument_list|(
name|name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|aei
operator|=
name|str2aei
argument_list|(
name|name
argument_list|,
name|DEFAULTTSERVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aei
operator|==
name|NULLAEI
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  unble to get AEI for \"%s::\"\n"
argument_list|,
name|ProgramName
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|pa
operator|=
name|aei2addr
argument_list|(
name|aei
argument_list|)
operator|)
operator|==
name|NULLPA
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"address translation failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ha
operator|.
name|length
operator|=
name|NASIZE
expr_stmt|;
name|ha
operator|.
name|address
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|pa
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
comment|/*  * XXXX  */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|hp
init|=
name|ha
operator|.
name|address
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|TSAPaddr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|*
name|hp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|hp
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add
condition|)
block|{
name|XAddHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:: %s\n"
argument_list|,
name|name
argument_list|,
name|add_msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XRemoveHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:: %s\n"
argument_list|,
name|name
argument_list|,
name|remove_msg
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* ISOCONN */
comment|/*    * First see if inet_addr() can grok the name; if so, then use it.    */
if|if
condition|(
operator|(
name|addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ha
operator|.
name|family
operator|=
name|FamilyInternet
expr_stmt|;
name|ha
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ha
operator|.
name|address
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|XAddHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|name
argument_list|,
name|add_msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XRemoveHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|name
argument_list|,
name|remove_msg
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/*    * Is it in the namespace?    */
elseif|else
if|if
condition|(
operator|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|NULL
operator|)
operator|||
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
name|ha
operator|.
name|family
operator|=
name|XFamily
argument_list|(
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
name|ha
operator|.
name|length
operator|=
name|hp
operator|->
name|h_length
expr_stmt|;
ifdef|#
directive|ifdef
name|h_addr
comment|/* new 4.3bsd version of gethostent */
block|{
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
comment|/* iterate over the hosts */
for|for
control|(
name|list
operator|=
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|list
condition|;
name|list
operator|++
control|)
block|{
name|ha
operator|.
name|address
operator|=
operator|*
name|list
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|XAddHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XRemoveHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
name|ha
operator|.
name|address
operator|=
name|hp
operator|->
name|h_addr
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|XAddHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XRemoveHost
argument_list|(
name|dpy
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|name
argument_list|,
name|add
condition|?
name|add_msg
else|:
name|remove_msg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* NOTREACHED */
block|}
comment|/*  * get_hostname - Given an internet address, return a name (CHARON.MIT.EDU)  * or a string representing the address (18.58.0.13) if the name cannot  * be found.  */
name|jmp_buf
name|env
decl_stmt|;
name|char
modifier|*
name|get_hostname
parameter_list|(
name|ha
parameter_list|)
name|XHostAddress
modifier|*
name|ha
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|int
name|nameserver_lost
parameter_list|()
function_decl|;
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|nodeent
modifier|*
name|np
decl_stmt|;
specifier|static
name|char
name|nodeaddr
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* DNETCONN */
if|if
condition|(
name|ha
operator|->
name|family
operator|==
name|FamilyInternet
condition|)
block|{
comment|/* gethostbyaddr can take a LONG time if the host does not exist.        Assume that if it does not respond in NAMESERVER_TIMEOUT seconds        that something is wrong and do not make the user wait.        gethostbyaddr will continue after a signal, so we have to        jump out of it.         */
name|nameserver_timedout
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|nameserver_lost
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
name|ha
operator|->
name|address
argument_list|,
name|ha
operator|->
name|length
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|->
name|h_name
operator|)
return|;
else|else
return|return
operator|(
name|inet_ntoa
argument_list|(
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|ha
operator|->
name|address
operator|)
operator|)
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
name|ha
operator|->
name|family
operator|==
name|FamilyDECnet
condition|)
block|{
if|if
condition|(
name|np
operator|=
name|getnodebyaddr
argument_list|(
name|ha
operator|->
name|address
argument_list|,
name|ha
operator|->
name|length
argument_list|,
name|AF_DECnet
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|nodeaddr
argument_list|,
literal|"%s::"
argument_list|,
name|np
operator|->
name|n_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|nodeaddr
argument_list|,
literal|"%s::"
argument_list|,
name|dnet_htoa
argument_list|(
name|ha
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nodeaddr
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * We really truly need an nsap to AEI here...  */
if|if
condition|(
name|ha
operator|->
name|family
operator|==
name|FamilyIso
condition|)
block|{
return|return
operator|(
name|ha
operator|->
name|address
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ISOCONN */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nameserver_lost
argument_list|()
block|{
name|nameserver_timedout
operator|=
literal|1
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * local_xerror - local non-fatal error handling routine. If the error was  * that an X_GetHosts request for an unknown address format was received, just  * return, otherwise print the normal error message and continue.  */
specifier|static
name|int
name|local_xerror
parameter_list|(
name|dpy
parameter_list|,
name|rep
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|XErrorEvent
modifier|*
name|rep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|rep
operator|->
name|error_code
operator|==
name|BadAccess
operator|)
operator|&&
operator|(
name|rep
operator|->
name|request_code
operator|==
name|X_ChangeHosts
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  must be on local machine to add or remove hosts.\n"
argument_list|,
name|ProgramName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rep
operator|->
name|error_code
operator|==
name|BadAccess
operator|)
operator|&&
operator|(
name|rep
operator|->
name|request_code
operator|==
name|X_SetAccessControl
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  must be on local machine to enable or disable access control.\n"
argument_list|,
name|ProgramName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rep
operator|->
name|error_code
operator|==
name|BadValue
operator|)
operator|&&
operator|(
name|rep
operator|->
name|request_code
operator|==
name|X_ListHosts
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
name|XmuPrintDefaultErrorMessage
argument_list|(
name|dpy
argument_list|,
name|rep
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

