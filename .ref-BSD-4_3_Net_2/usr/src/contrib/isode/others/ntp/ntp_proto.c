begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/ntp/RCS/ntp_proto.c,v 7.1 91/02/22 09:33:51 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This module actually implements the the bulk of the NTP protocol processing.  * It contains a minimum of machine and operating system dependencies (or at  * least that's the idea).  Setup of UDP sockets, timers, etc is done in the  * ntpd.c module, while arithmetic conversion routines are in ntpsubs.c  *  * Some of this is now factored out as it was too protocol specific.  */
end_comment

begin_comment
comment|/*  * Based on the ntp 3.4 code - but modified for use with OSI.  * $Log:	ntp_proto.c,v $  * Revision 7.1  91/02/22  09:33:51  mrose  * Interim 6.8  *   * Revision 7.0  90/12/10  17:21:31  mrose  * *** empty log message ***  *   * Revision 1.2  90/08/14  10:13:56  jpo  * new protocol version  *   * Revision 1.1  89/06/15  20:36:57  jpo  * Initial revision  *   *   */
end_comment

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_decl_stmt
name|int
name|peer_switches
decl_stmt|,
name|peer_sw_inhibited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ntp_peer
name|dummy_peer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|WayTooBig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|clock_watchdog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|pgm_log
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|dump_pkt
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|servport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|trusting
decl_stmt|,
name|logstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysdata
name|sys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|list
name|peer_list
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|ntp_peer
modifier|*
name|check_peer
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|ntoa
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|drift_comp
decl_stmt|,
name|compliance
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logical clock variables */
end_comment

begin_decl_stmt
specifier|extern
name|double
name|s_fixed_to_double
argument_list|()
decl_stmt|,
name|ul_fixed_to_double
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|make_new_peer
argument_list|()
decl_stmt|,
name|double_to_s_fixed
argument_list|()
decl_stmt|,
name|tstamp
argument_list|()
decl_stmt|,
name|receive
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|demobilize
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|actions
index|[
literal|5
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*      Sym Act   Sym Pas    Client     Server     Broadcast  |Host /       */
comment|/*      --------   --------  --------   ---------  ---------  |    / Peer   */
comment|/*                                                            ------------  */
block|{
name|ACT_PKT
block|,
name|ACT_PKT
block|,
name|ACT_RECV
block|,
name|ACT_XMIT
block|,
name|ACT_XMIT
block|}
block|,
comment|/* Sym Act   */
block|{
name|ACT_PKT
block|,
name|ACT_ERROR
block|,
name|ACT_RECV
block|,
name|ACT_ERROR
block|,
name|ACT_ERROR
block|}
block|,
comment|/* Sym Pas   */
block|{
name|ACT_XMIT
block|,
name|ACT_XMIT
block|,
name|ACT_ERROR
block|,
name|ACT_XMIT
block|,
name|ACT_XMIT
block|}
block|,
comment|/* Client    */
block|{
name|ACT_PKT
block|,
name|ACT_ERROR
block|,
name|ACT_RECV
block|,
name|ACT_ERROR
block|,
name|ACT_ERROR
block|}
block|,
comment|/* Server    */
block|{
name|ACT_PKT
block|,
name|ACT_ERROR
block|,
name|ACT_RECV
block|,
name|ACT_ERROR
block|,
name|ACT_ERROR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Broadcast */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_function_decl
name|void
name|refclock_input
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|process_packet
argument_list|()
decl_stmt|,
name|clock_update
argument_list|()
decl_stmt|,
name|clear
argument_list|()
decl_stmt|,
name|clock_filter
argument_list|()
decl_stmt|,
name|receive
argument_list|()
decl_stmt|,
name|select_clock
argument_list|()
decl_stmt|,
name|poll_update
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3.4. Event Processing */
end_comment

begin_comment
comment|/* 3.4.1. Transmit Procedure */
end_comment

begin_function
name|void
name|transmit
parameter_list|(
name|peer
parameter_list|)
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
name|struct
name|timeval
name|txtv
decl_stmt|;
specifier|static
name|struct
name|ntpdata
name|ntpframe
decl_stmt|;
name|struct
name|ntpdata
modifier|*
name|pkt
init|=
operator|&
name|ntpframe
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_OSI
condition|)
block|{
name|transmit_osi
argument_list|(
name|peer
argument_list|)
expr_stmt|;
return|return;
block|}
name|pkt
operator|->
name|status
operator|=
name|sys
operator|.
name|leap
operator||
name|peer
operator|->
name|hmode
expr_stmt|;
name|VERS2PKT
argument_list|(
name|pkt
operator|->
name|status
argument_list|,
name|peer
operator|->
name|vers
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|stratum
operator|=
name|sys
operator|.
name|stratum
expr_stmt|;
name|pkt
operator|->
name|ppoll
operator|=
name|peer
operator|->
name|hpoll
expr_stmt|;
name|pkt
operator|->
name|precision
operator|=
operator|(
name|char
operator|)
name|sys
operator|.
name|precision
expr_stmt|;
name|pkt
operator|->
name|distance
operator|=
name|sys
operator|.
name|distance
expr_stmt|;
name|pkt
operator|->
name|dispersion
operator|=
name|sys
operator|.
name|dispersion
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_INET
condition|)
name|pkt
operator|->
name|refid
operator|=
name|sys
operator|.
name|refid
operator|.
name|rid_inet
expr_stmt|;
name|pkt
operator|->
name|reftime
operator|=
name|sys
operator|.
name|reftime
expr_stmt|;
name|pkt
operator|->
name|org
operator|=
name|peer
operator|->
name|org
expr_stmt|;
name|pkt
operator|->
name|rec
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|txtv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_AUTHENABLE
operator|&&
name|peer
operator|->
name|vers
operator|==
literal|2
operator|&&
name|authhavekey
argument_list|(
name|peer
operator|->
name|keyid
argument_list|)
condition|)
block|{
name|pkt
operator|->
name|keyid
operator|=
name|htonl
argument_list|(
name|peer
operator|->
name|keyid
argument_list|)
expr_stmt|;
name|auth1crypt
argument_list|(
name|peer
operator|->
name|keyid
argument_list|,
name|pkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|tstamp
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|txtv
argument_list|)
expr_stmt|;
name|auth2crypt
argument_list|(
name|peer
operator|->
name|keyid
argument_list|,
name|pkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* Not Yet in this version */
name|pkt
operator|->
name|keyid
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
name|tstamp
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|,
operator|&
name|txtv
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|xmt
operator|=
name|pkt
operator|->
name|xmt
expr_stmt|;
if|if
condition|(
operator|(
name|peer
operator|->
name|flags
operator|&
operator|(
name|PEER_FL_BCAST
operator||
name|PEER_FL_REFCLOCK
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* select correct socket to send reply on */
name|struct
name|intf
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
operator|&
name|addrs
index|[
name|peer
operator|->
name|sock
operator|<
literal|0
condition|?
literal|0
else|:
name|peer
operator|->
name|sock
index|]
expr_stmt|;
switch|switch
condition|(
name|peer
operator|->
name|src
operator|.
name|type
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|send_inet
argument_list|(
name|ap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pkt
argument_list|)
argument_list|,
operator|&
name|peer
operator|->
name|src
argument_list|)
operator|<
literal|0
condition|)
return|return;
break|break;
block|}
ifdef|#
directive|ifdef
name|REFCLOCK
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_REFCLOCK
condition|)
block|{
comment|/* Special version of code below, adjusted for refclocks */
name|peer
operator|->
name|pkt_sent
operator|++
expr_stmt|;
name|i
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
comment|/* save a copy */
name|peer
operator|->
name|reach
operator|=
operator|(
name|peer
operator|->
name|reach
operator|<<
literal|1
operator|)
operator|&
name|NTP_WINDOW_SHIFT_MASK
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"Lost reachability with %.4s"
argument_list|,
name|peer
operator|->
name|refid
operator|.
name|rid_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
name|clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|valid
operator|<
literal|2
condition|)
name|peer
operator|->
name|valid
operator|++
expr_stmt|;
else|else
block|{
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
comment|/* call with invalid values */
name|select_clock
argument_list|()
expr_stmt|;
comment|/* and try to reselect clock */
block|}
name|peer
operator|->
name|timer
operator|=
literal|1
operator|<<
name|NTP_MINPOLL
expr_stmt|;
comment|/* poll refclocks frequently */
name|refclock_input
argument_list|(
name|peer
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
endif|REFCLOCK
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BROADCAST_NTP
if|if
condition|(
name|addrs
index|[
name|peer
operator|->
name|sock
index|]
operator|.
name|addr
operator|.
name|type
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|send_inet
argument_list|(
operator|&
name|addrs
index|[
name|peer
operator|->
name|sock
index|]
argument_list|,
name|pkt
argument_list|,
name|peer
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
else|else
return|return;
else|#
directive|else
return|return;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"\nSent "
argument_list|)
expr_stmt|;
name|dump_pkt
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|,
name|pkt
argument_list|,
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|peer
operator|->
name|pkt_sent
operator|++
expr_stmt|;
name|i
operator|=
name|peer
operator|->
name|reach
expr_stmt|;
comment|/* save a copy */
name|peer
operator|->
name|reach
operator|=
operator|(
name|peer
operator|->
name|reach
operator|<<
literal|1
operator|)
operator|&
name|NTP_WINDOW_SHIFT_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|peer
operator|->
name|reach
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_CONFIG
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|peer
operator|!=
operator|&
name|dummy_peer
operator|)
operator|&&
name|demobilize
argument_list|(
operator|&
name|peer_list
argument_list|,
name|peer
argument_list|)
condition|)
return|return;
if|if
condition|(
name|i
operator|&&
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"Lost reachability with %s"
argument_list|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
name|clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_INET
condition|)
name|peer
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* since he fell off the end of the 					   earth, don't depend on local address 					   any longer */
block|}
if|if
condition|(
name|peer
operator|->
name|valid
operator|<
literal|2
condition|)
name|peer
operator|->
name|valid
operator|++
expr_stmt|;
else|else
block|{
name|clock_filter
argument_list|(
name|peer
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
comment|/* call with invalid values */
name|select_clock
argument_list|()
expr_stmt|;
comment|/* and try to reselect clock */
if|if
condition|(
name|sys
operator|.
name|peer
operator|!=
name|NULL
condition|)
name|poll_update
argument_list|(
name|sys
operator|.
name|peer
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|timer
operator|=
literal|1
operator|<<
operator|(
name|MAX
argument_list|(
name|MIN
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|MIN
argument_list|(
name|peer
operator|->
name|hpoll
argument_list|,
name|NTP_MAXPOLL
argument_list|)
argument_list|)
argument_list|,
name|NTP_MINPOLL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|backoff
operator|==
literal|0
condition|)
name|peer
operator|->
name|backoff
operator|=
name|BACKOFF_COUNT
expr_stmt|;
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|backoff
operator|==
literal|1
condition|)
name|poll_update
argument_list|(
name|peer
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|hpoll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|peer
operator|->
name|backoff
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|estdisp
operator|>
name|PEER_THRESHOLD
condition|)
name|poll_update
argument_list|(
name|peer
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|hpoll
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|poll_update
argument_list|(
name|peer
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|hpoll
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_function
name|void
name|refclock_input
parameter_list|(
name|peer
parameter_list|,
name|pkt
parameter_list|)
name|struct
name|ntpdata
modifier|*
name|pkt
decl_stmt|;
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
name|struct
name|timeval
modifier|*
name|otvp
decl_stmt|;
if|if
condition|(
name|read_clock
argument_list|(
name|peer
operator|->
name|sock
argument_list|,
operator|&
name|tvp
argument_list|,
operator|&
name|otvp
argument_list|)
condition|)
return|return;
name|tstamp
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|xmt
operator|=
name|pkt
operator|->
name|rec
expr_stmt|;
name|pkt
operator|->
name|reftime
operator|=
name|pkt
operator|->
name|rec
expr_stmt|;
name|tstamp
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|,
name|otvp
argument_list|)
expr_stmt|;
name|peer
operator|->
name|xmt
operator|=
name|pkt
operator|->
name|org
expr_stmt|;
name|pkt
operator|->
name|refid
operator|=
name|peer
operator|->
name|refid
operator|.
name|rid_inet
expr_stmt|;
comment|/* XXX */
name|pkt
operator|->
name|status
operator|&=
operator|~
name|ALARM
expr_stmt|;
name|pkt
operator|->
name|stratum
operator|=
name|peer
operator|->
name|stratum
expr_stmt|;
name|pkt
operator|->
name|ppoll
operator|=
literal|0xff
expr_stmt|;
name|pkt
operator|->
name|precision
operator|=
name|peer
operator|->
name|precision
expr_stmt|;
name|double_to_s_fixed
argument_list|(
operator|&
name|pkt
operator|->
name|distance
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|double_to_s_fixed
argument_list|(
operator|&
name|pkt
operator|->
name|dispersion
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"\nFaking packet "
argument_list|)
expr_stmt|;
name|dump_pkt
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|,
name|pkt
argument_list|,
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|receive
argument_list|(
operator|(
expr|struct
name|Naddr
operator|*
operator|)
name|peer
argument_list|,
name|pkt
argument_list|,
name|otvp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|REFCLOCK
end_endif

begin_escape
end_escape

begin_comment
comment|/* 3.4.2. Receive Procedure */
end_comment

begin_function
name|void
name|receive
parameter_list|(
name|dst
parameter_list|,
name|pkt
parameter_list|,
name|tvp
parameter_list|,
name|sock
parameter_list|)
name|struct
name|Naddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|ntpdata
modifier|*
name|pkt
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
name|int
name|sock
decl_stmt|;
block|{
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
name|int
name|peer_mode
decl_stmt|;
comment|/* if we're only going to support NTP Version 2 then this stuff 	   isn't necessary, right? */
if|if
condition|(
operator|(
name|peer_mode
operator|=
name|pkt
operator|->
name|status
operator|&
name|MODEMASK
operator|)
operator|==
literal|0
operator|&&
name|dst
condition|)
block|{
comment|/* packet from an older NTP implementation.  Synthesize the 		   correct mode.  The mapping goes like this:  		   pkt source port      pkt dst port	Mode 		   ---------------	------------	---- 		   NTP Port		NTP Port	symmetric active 		   NTP Port		not NTP Port	server 		   not NTP Port		NTP Port	client 		   not NTP Port		not NTP Port<not possible>  		   Now, since we only are processing packets with the 		   destination being NTP Port, it reduces to the two cases:  		   pkt source port      pkt dst port	Mode 		   ---------------	------------	---- 		   NTP Port		NTP Port	symmetric active 		   not NTP Port		NTP Port	client		 */
if|if
condition|(
name|dst
operator|->
name|inet_ad
operator|.
name|sin_port
operator|==
name|servport
condition|)
name|peer_mode
operator|=
name|MODE_SYM_ACT
expr_stmt|;
else|else
name|peer_mode
operator|=
name|MODE_CLIENT
expr_stmt|;
block|}
if|if
condition|(
name|peer_mode
operator|==
name|MODE_CLIENT
condition|)
block|{
comment|/* 		 * Special case: Use the dummy peer item that we keep around 		 * just for this type of thing 		 */
name|peer
operator|=
operator|&
name|dummy_peer
expr_stmt|;
name|make_new_peer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|src
operator|=
operator|*
name|dst
expr_stmt|;
name|peer
operator|->
name|sock
operator|=
name|sock
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_SYM_PAS
expr_stmt|;
name|peer
operator|->
name|reach
operator|=
literal|0
expr_stmt|;
name|clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
block|}
elseif|else
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* we're begin called by refclock_input(), get peer ptr */
name|peer
operator|=
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|dst
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|peer
operator|=
name|check_peer
argument_list|(
name|dst
argument_list|,
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
name|peer
operator|=
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ntp_peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"malloc"
argument_list|,
literal|"peer"
argument_list|)
expr_stmt|;
return|return;
block|}
name|make_new_peer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|src
operator|=
operator|*
name|dst
expr_stmt|;
name|peer
operator|->
name|sock
operator|=
name|sock
expr_stmt|;
comment|/* remember which socket we heard  					   this from */
name|peer
operator|->
name|hmode
operator|=
name|MODE_SYM_PAS
expr_stmt|;
name|peer
operator|->
name|reach
operator|=
literal|0
expr_stmt|;
name|clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* 		 *  If we decide to consider any random NTP peer that might 		 *  come as a peer we might sync to, then set the PEER_FL_SYNC 		 *  flag in the peer structure. 		 * 		 *  Alternatively, we could change the hmode to MODE_SERVER,  		 *  but then the peer state wouldn't be persistant. 		 */
if|if
condition|(
name|trusting
condition|)
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_SYNC
expr_stmt|;
name|enqueue
argument_list|(
operator|&
name|peer_list
argument_list|,
name|peer
argument_list|)
expr_stmt|;
block|}
comment|/*  	 *  "pre-configured" peers are initially assigned a socket index of 	 *  -1, which means we don't know which interface we'll use to talk 	 *  to them.  Once the first reply comes back, we'll update the 	 *  peer structure 	 */
if|if
condition|(
name|peer
operator|->
name|sock
operator|==
operator|-
literal|1
condition|)
name|peer
operator|->
name|sock
operator|=
name|sock
expr_stmt|;
ifdef|#
directive|ifdef
name|BROADCAST_NTP
comment|/* 	 *  Input frame matched a funny broadcast peer;  these peers only 	 *  exist to periodically generate broadcasts.  If an input packet 	 *  matched, it means that it looked like it *came* from the broadcast 	 *  address.  This is clearly bogus. 	 */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_BCAST
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"receive: input frame for broadcast peer?"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* BROADCAST_NTP */
if|#
directive|if
literal|0
block|if ((peer->flags& PEER_FL_AUTHENABLE)&& 	    pkt->mac) {
comment|/* verify computed crypto-checksum */
block|}
endif|#
directive|endif
if|if
condition|(
name|peer_mode
operator|<
name|MODE_SYM_ACT
operator|||
name|peer_mode
operator|>
name|MODE_BROADCAST
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Bogus peer_mode %d from %s"
operator|,
name|peer_mode
operator|,
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|dst
operator|==
name|peer
condition|?
literal|"refclock"
else|:
name|paddr
argument_list|(
name|dst
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|peer
operator|->
name|hmode
operator|<
name|MODE_SYM_ACT
operator|||
name|peer
operator|->
name|hmode
operator|>
name|MODE_BROADCAST
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Bogus hmode %d for peer %s"
argument_list|,
name|peer
operator|->
name|hmode
argument_list|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|peer
operator|->
name|backoff
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|actions
index|[
name|peer_mode
operator|-
literal|1
index|]
index|[
name|peer
operator|->
name|hmode
operator|-
literal|1
index|]
condition|)
block|{
case|case
name|ACT_RECV
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_CONFIG
operator|)
operator|==
literal|0
operator|)
operator|&&
name|STRMCMP
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|,
operator|>
argument_list|,
name|sys
operator|.
name|stratum
argument_list|)
operator|)
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|PEER_FL_SNOOZE
expr_stmt|;
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|process_packet
argument_list|(
name|dst
argument_list|,
name|pkt
argument_list|,
name|tvp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Note fall-through */
case|case
name|ACT_ERROR
case|:
if|if
condition|(
operator|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_CONFIG
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|peer
operator|!=
operator|&
name|dummy_peer
operator|)
operator|&&
name|demobilize
argument_list|(
operator|&
name|peer_list
argument_list|,
name|peer
argument_list|)
condition|)
break|break;
break|break;
case|case
name|ACT_PKT
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_CONFIG
operator|)
operator|==
literal|0
operator|)
operator|&&
name|STRMCMP
argument_list|(
name|pkt
operator|->
name|stratum
argument_list|,
operator|>
argument_list|,
name|sys
operator|.
name|stratum
argument_list|)
operator|)
condition|)
block|{
name|peer
operator|->
name|flags
operator|&=
operator|~
name|PEER_FL_SNOOZE
expr_stmt|;
name|peer
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
name|process_packet
argument_list|(
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|dst
operator|==
name|peer
condition|?
name|NULL
else|:
name|dst
argument_list|,
name|pkt
argument_list|,
name|tvp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Note fall-through */
case|case
name|ACT_XMIT
case|:
name|process_packet
argument_list|(
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|dst
operator|==
name|peer
condition|?
name|NULL
else|:
name|dst
argument_list|,
name|pkt
argument_list|,
name|tvp
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|ppoll
argument_list|)
expr_stmt|;
name|transmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 3.4.3 Packet procedure */
end_comment

begin_function
name|void
name|process_packet
parameter_list|(
name|dst
parameter_list|,
name|pkt
parameter_list|,
name|tvp
parameter_list|,
name|peer
parameter_list|)
name|struct
name|Naddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|ntpdata
modifier|*
name|pkt
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
name|double
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|,
name|offset
decl_stmt|,
name|delay
decl_stmt|;
name|short
name|duplicate
decl_stmt|,
name|bogus
decl_stmt|;
name|duplicate
operator|=
operator|(
name|pkt
operator|->
name|xmt
operator|.
name|int_part
operator|==
name|peer
operator|->
name|org
operator|.
name|int_part
operator|)
operator|&&
operator|(
name|pkt
operator|->
name|xmt
operator|.
name|fraction
operator|==
name|peer
operator|->
name|org
operator|.
name|fraction
operator|)
expr_stmt|;
name|bogus
operator|=
operator|(
operator|(
name|pkt
operator|->
name|org
operator|.
name|int_part
operator|!=
name|peer
operator|->
name|xmt
operator|.
name|int_part
operator|)
operator|||
operator|(
name|pkt
operator|->
name|org
operator|.
name|fraction
operator|!=
name|peer
operator|->
name|xmt
operator|.
name|fraction
operator|)
operator|)
operator|||
operator|(
name|peer
operator|->
name|xmt
operator|.
name|int_part
operator|==
literal|0
operator|)
expr_stmt|;
name|peer
operator|->
name|pkt_rcvd
operator|++
expr_stmt|;
name|peer
operator|->
name|leap
operator|=
name|pkt
operator|->
name|status
operator|&
name|LEAPMASK
expr_stmt|;
name|peer
operator|->
name|vers
operator|=
name|PKT2VERS
argument_list|(
name|pkt
operator|->
name|status
argument_list|)
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|pkt
operator|->
name|stratum
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|pkt
operator|->
name|ppoll
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|pkt
operator|->
name|precision
expr_stmt|;
name|peer
operator|->
name|distance
operator|=
name|pkt
operator|->
name|distance
expr_stmt|;
name|peer
operator|->
name|dispersion
operator|=
name|pkt
operator|->
name|dispersion
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_INET
condition|)
block|{
name|peer
operator|->
name|refid
operator|.
name|rid_type
operator|=
name|peer
operator|->
name|stratum
operator|==
literal|1
condition|?
name|RID_STRING
else|:
name|RID_INET
expr_stmt|;
name|peer
operator|->
name|refid
operator|.
name|rid_inet
operator|=
name|pkt
operator|->
name|refid
expr_stmt|;
block|}
name|peer
operator|->
name|reftime
operator|=
name|pkt
operator|->
name|reftime
expr_stmt|;
name|peer
operator|->
name|org
operator|=
name|pkt
operator|->
name|xmt
expr_stmt|;
name|tstamp
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
name|poll_update
argument_list|(
name|peer
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|hpoll
argument_list|)
expr_stmt|;
comment|/*  	 * may want to do something special here for Broadcast Mode peers to 	 * allow these through  	 */
if|if
condition|(
name|bogus
operator|||
name|duplicate
operator|||
operator|(
name|pkt
operator|->
name|org
operator|.
name|int_part
operator|==
literal|0
operator|&&
name|pkt
operator|->
name|org
operator|.
name|fraction
operator|==
literal|0
operator|)
operator|||
operator|(
name|pkt
operator|->
name|rec
operator|.
name|int_part
operator|==
literal|0
operator|&&
name|pkt
operator|->
name|rec
operator|.
name|fraction
operator|==
literal|0
operator|)
condition|)
block|{
name|peer
operator|->
name|pkt_dropped
operator|++
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"process_packet: dropped duplicate or bogus"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Now compute local adjusts  	 */
name|t1
operator|=
name|ul_fixed_to_double
argument_list|(
operator|&
name|pkt
operator|->
name|org
argument_list|)
expr_stmt|;
name|t2
operator|=
name|ul_fixed_to_double
argument_list|(
operator|&
name|pkt
operator|->
name|rec
argument_list|)
expr_stmt|;
name|t3
operator|=
name|ul_fixed_to_double
argument_list|(
operator|&
name|pkt
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|t4
operator|=
name|ul_fixed_to_double
argument_list|(
operator|&
name|peer
operator|->
name|rec
argument_list|)
expr_stmt|;
comment|/*  	 * although the delay computation looks different than the one in the 	 * specification, it is correct.  Think about it. 	 */
name|delay
operator|=
operator|(
name|t2
operator|-
name|t1
operator|)
operator|-
operator|(
name|t3
operator|-
name|t4
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|t2
operator|-
name|t1
operator|)
operator|+
operator|(
name|t3
operator|-
name|t4
operator|)
operator|)
operator|/
literal|2.0
expr_stmt|;
name|delay
operator|+=
literal|1.0
operator|/
call|(
name|unsigned
name|long
call|)
argument_list|(
literal|1L
operator|<<
operator|-
name|sys
operator|.
name|precision
argument_list|)
ifndef|#
directive|ifndef
name|REFCLOCK
operator|+
name|NTP_MAXSKW
expr_stmt|;
else|#
directive|else
operator|+
operator|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_REFCLOCK
operator|)
condition|?
name|NTP_REFMAXSKW
else|:
name|NTP_MAXSKW
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|precision
operator|<
literal|0
operator|&&
operator|-
name|peer
operator|->
name|precision
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|NBBY
condition|)
name|delay
operator|+=
literal|1.0
operator|/
call|(
name|unsigned
name|long
call|)
argument_list|(
literal|1L
operator|<<
operator|-
name|peer
operator|->
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|0.0
condition|)
block|{
name|peer
operator|->
name|pkt_dropped
operator|++
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|REFCLOCK
name|delay
operator|=
name|MAX
argument_list|(
name|delay
argument_list|,
name|NTP_MINDIST
argument_list|)
expr_stmt|;
else|#
directive|else
name|delay
operator|=
name|MAX
argument_list|(
name|delay
argument_list|,
operator|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_REFCLOCK
operator|)
condition|?
name|NTP_REFMINDIST
else|:
name|NTP_MINDIST
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|peer
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|clock_filter
argument_list|(
name|peer
argument_list|,
name|delay
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* invoke clock filter procedure */
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"host: %s : %f : %f : %f : %f : %f : %o"
operator|,
name|dst
condition|?
name|paddr
argument_list|(
name|dst
argument_list|)
else|:
literal|"refclock"
operator|,
name|delay
operator|,
name|offset
operator|,
name|peer
operator|->
name|estdelay
operator|,
name|peer
operator|->
name|estoffset
operator|,
name|peer
operator|->
name|estdisp
operator|,
name|peer
operator|->
name|reach
operator|)
argument_list|)
expr_stmt|;
name|clock_update
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* call clock update procedure */
block|}
end_function

begin_comment
comment|/* 3.4.4 Primary clock procedure */
end_comment

begin_comment
comment|/*  *  We don't have a primary clock.  *  *  TODO:  *  *  ``When a  primary clock is connected to the host, it is convient to  *    incorporate its information into the database as if the clock was  *    represented as an ordinary peer.  The clock can be polled once a  *    minute or so and the returned timecheck used to produce a new update  *    for the logical clock.''  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* 3.4.5 Clock update procedure */
end_comment

begin_function
name|void
name|clock_update
parameter_list|(
name|peer
parameter_list|)
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
name|double
name|temp
decl_stmt|;
specifier|extern
name|int
name|adj_logical
parameter_list|()
function_decl|;
name|select_clock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sys
operator|.
name|peer
operator|!=
name|NULL
condition|)
name|poll_update
argument_list|(
name|sys
operator|.
name|peer
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
comment|/* 	 * Did we just sync to this peer? 	 */
if|if
condition|(
operator|(
name|peer
operator|==
name|sys
operator|.
name|peer
operator|)
operator|&&
operator|(
name|sys
operator|.
name|hold
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 *  Update the local system variables 		 */
name|sys
operator|.
name|leap
operator|=
name|peer
operator|->
name|leap
expr_stmt|;
ifndef|#
directive|ifndef
name|REFCLOCK
name|sys
operator|.
name|stratum
operator|=
name|peer
operator|->
name|stratum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_INET
condition|)
block|{
name|sys
operator|.
name|refid
operator|.
name|rid_type
operator|=
name|RID_INET
expr_stmt|;
name|sys
operator|.
name|refid
operator|.
name|rid_inet
operator|=
name|peer
operator|->
name|src
operator|.
name|inet_ad
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_OSI
condition|)
block|{
name|sys
operator|.
name|refid
operator|.
name|rid_type
operator|=
name|RID_PSAP
expr_stmt|;
name|sys
operator|.
name|refid
operator|.
name|rid_psap
operator|=
name|peer
operator|->
name|src
operator|.
name|psap_ad
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_REFCLOCK
condition|)
block|{
comment|/* once we re-map the stratums so that stratum 0 is 			   better than stratum 1, some of this foolishness 			   can go away */
name|sys
operator|.
name|stratum
operator|=
name|peer
operator|->
name|stratum
expr_stmt|;
name|sys
operator|.
name|refid
operator|=
name|peer
operator|->
name|refid
expr_stmt|;
block|}
else|else
block|{
name|sys
operator|.
name|stratum
operator|=
name|peer
operator|->
name|stratum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_INET
condition|)
block|{
name|sys
operator|.
name|refid
operator|.
name|rid_type
operator|=
name|RID_INET
expr_stmt|;
name|sys
operator|.
name|refid
operator|.
name|rid_inet
operator|=
name|peer
operator|->
name|src
operator|.
name|inet_ad
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peer
operator|->
name|src
operator|.
name|type
operator|==
name|AF_OSI
condition|)
block|{
name|sys
operator|.
name|refid
operator|.
name|rid_type
operator|=
name|RID_PSAP
expr_stmt|;
name|sys
operator|.
name|refid
operator|.
name|rid_psap
operator|=
name|peer
operator|->
name|src
operator|.
name|psap_ad
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|temp
operator|=
name|s_fixed_to_double
argument_list|(
operator|&
name|peer
operator|->
name|distance
argument_list|)
operator|+
name|peer
operator|->
name|estdelay
expr_stmt|;
name|double_to_s_fixed
argument_list|(
operator|&
name|sys
operator|.
name|distance
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|s_fixed_to_double
argument_list|(
operator|&
name|peer
operator|->
name|dispersion
argument_list|)
operator|+
name|peer
operator|->
name|estdisp
expr_stmt|;
name|double_to_s_fixed
argument_list|(
operator|&
name|sys
operator|.
name|dispersion
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|sys
operator|.
name|reftime
operator|=
name|peer
operator|->
name|rec
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"clock_update: synced to peer, adj clock"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Sanity check: is computed offset insane? 		 */
if|if
condition|(
name|peer
operator|->
name|estoffset
operator|>
name|WayTooBig
operator|||
name|peer
operator|->
name|estoffset
operator|<
operator|-
name|WayTooBig
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Clock is too far off %f sec. [%s]"
argument_list|,
name|peer
operator|->
name|estoffset
argument_list|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|clock_watchdog
operator|=
literal|0
expr_stmt|;
comment|/* reset watchdog timer */
if|if
condition|(
name|adj_logical
argument_list|(
name|peer
operator|->
name|estoffset
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|ntp_peer
modifier|*
name|p
init|=
name|peer_list
operator|.
name|head
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"adjust: STEP %s st %d off %f drft %f cmpl %f"
argument_list|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
argument_list|,
name|peer
operator|->
name|stratum
argument_list|,
name|peer
operator|->
name|estoffset
argument_list|,
name|drift_comp
argument_list|,
name|compliance
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Clockset from %s stratum %d offset %f"
operator|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
operator|,
name|peer
operator|->
name|stratum
operator|,
name|peer
operator|->
name|estoffset
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|clear
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|sys
operator|.
name|hold
operator|=
name|PEER_SHIFT
operator|*
operator|(
literal|1
operator|<<
name|NTP_MINPOLL
operator|)
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"clock_updates: STEP ADJ"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|logstats
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"adjust: SLEW %s st %d off %f drft %f cmpl %f"
argument_list|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
argument_list|,
name|peer
operator|->
name|stratum
argument_list|,
name|peer
operator|->
name|estoffset
argument_list|,
name|drift_comp
argument_list|,
name|compliance
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* 3.4.6 Initialization procedure */
end_comment

begin_function
name|void
name|initialize
parameter_list|()
block|{
name|sys
operator|.
name|leap
operator|=
name|ALARM
expr_stmt|;
comment|/* indicate unsynchronized */
name|sys
operator|.
name|stratum
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|precision
operator|=
literal|0
expr_stmt|;
comment|/* may be specified in the config file; 				   if not, gets set in init_kern_vars() */
if|#
directive|if
literal|0
comment|/* under construction */
block|sys.keyid = 0; 	sys.keys = ??;
endif|#
directive|endif
name|sys
operator|.
name|distance
operator|.
name|int_part
operator|=
name|sys
operator|.
name|distance
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|dispersion
operator|.
name|int_part
operator|=
name|sys
operator|.
name|dispersion
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|refid
operator|.
name|rid_type
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|refid
operator|.
name|rid_inet
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|reftime
operator|.
name|int_part
operator|=
name|sys
operator|.
name|reftime
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|hold
operator|=
literal|0
expr_stmt|;
name|sys
operator|.
name|peer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 3.4.7 Clear Procedure */
end_comment

begin_function
name|void
name|clear
parameter_list|(
name|peer
parameter_list|)
specifier|register
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"clear: emptied filter for %s"
operator|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|!=
literal|0
condition|)
name|peer
operator|->
name|hpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|peer
operator|->
name|estdisp
operator|=
name|PEER_MAXDISP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_WINDOW
condition|;
name|i
operator|++
control|)
name|peer
operator|->
name|filter
operator|.
name|offset
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
name|peer
operator|->
name|filter
operator|.
name|samples
operator|=
literal|0
expr_stmt|;
comment|/* Implementation specific */
name|peer
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|org
operator|.
name|int_part
operator|=
name|peer
operator|->
name|org
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|rec
operator|.
name|int_part
operator|=
name|peer
operator|->
name|rec
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|xmt
operator|.
name|int_part
operator|=
name|peer
operator|->
name|xmt
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|reach
operator|!=
literal|0
condition|)
name|poll_update
argument_list|(
name|peer
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
name|select_clock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sys
operator|.
name|peer
operator|!=
name|NULL
condition|)
name|poll_update
argument_list|(
name|sys
operator|.
name|peer
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 3.4.8 Poll Update Procedure */
end_comment

begin_function
name|void
name|poll_update
parameter_list|(
name|peer
parameter_list|,
name|new_hpoll
parameter_list|)
specifier|register
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
name|int
name|new_hpoll
decl_stmt|;
block|{
name|int
name|interval
decl_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|MAX
argument_list|(
name|NTP_MINPOLL
argument_list|,
name|MIN
argument_list|(
name|NTP_MAXPOLL
argument_list|,
name|new_hpoll
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|XTAL
comment|/* if crystal controlled clock */
if|if
condition|(
name|peer
operator|==
name|sys
operator|.
name|peer
condition|)
endif|#
directive|endif
name|peer
operator|->
name|hpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|interval
operator|=
literal|1
operator|<<
operator|(
name|MAX
argument_list|(
name|MIN
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|MIN
argument_list|(
name|peer
operator|->
name|hpoll
argument_list|,
name|NTP_MAXPOLL
argument_list|)
argument_list|)
argument_list|,
name|NTP_MINPOLL
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_REFCLOCK
condition|)
name|interval
operator|=
literal|1
operator|<<
name|NTP_MINPOLL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|interval
operator|==
name|peer
operator|->
name|timer
condition|)
return|return;
comment|/* only randomize when poll interval changes */
if|if
condition|(
name|interval
operator|<
name|peer
operator|->
name|timer
condition|)
block|{
name|interval
operator|=
operator|(
name|double
operator|)
name|interval
operator|*
call|(
name|double
call|)
argument_list|(
name|random
argument_list|()
operator|%
literal|100
operator|/
literal|100.0
argument_list|)
expr_stmt|;
name|peer
operator|->
name|timer
operator|=
name|interval
expr_stmt|;
block|}
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"poll_update: timer %d, poll=%d"
operator|,
name|peer
operator|->
name|timer
operator|,
name|interval
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 3.4.9 Authentication Procedures */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|encrypt() {} decrypt() {}
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* 4.1 Clock Filter Procedure */
end_comment

begin_comment
comment|/*  *  The previous incarnation of this code made the assumption that  *  the value of PEER_FILTER was a power of two and used shifting.  *  This version has been generalized, so that experimenting with  *  different PEER_FILTER values should be much easier.  */
end_comment

begin_function
name|void
name|clock_filter
parameter_list|(
name|peer
parameter_list|,
name|new_delay
parameter_list|,
name|new_offset
parameter_list|)
specifier|register
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
name|double
name|new_delay
decl_stmt|,
name|new_offset
decl_stmt|;
block|{
name|double
name|offset
index|[
name|PEER_SHIFT
index|]
decl_stmt|,
name|delay
index|[
name|PEER_SHIFT
index|]
decl_stmt|;
specifier|register
name|double
name|temp
decl_stmt|,
name|d
decl_stmt|,
name|w
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|samples
decl_stmt|;
if|if
condition|(
name|peer
operator|->
name|filter
operator|.
name|samples
operator|<
name|PEER_SHIFT
condition|)
name|peer
operator|->
name|filter
operator|.
name|samples
operator|++
expr_stmt|;
comment|/* 	 *  Too bad C doesn't have a barrel shifter... 	 */
for|for
control|(
name|i
operator|=
name|PEER_SHIFT
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|peer
operator|->
name|filter
operator|.
name|offset
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter
operator|.
name|offset
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|peer
operator|->
name|filter
operator|.
name|delay
index|[
name|i
index|]
operator|=
name|peer
operator|->
name|filter
operator|.
name|delay
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|peer
operator|->
name|filter
operator|.
name|offset
index|[
literal|0
index|]
operator|=
name|new_offset
expr_stmt|;
name|peer
operator|->
name|filter
operator|.
name|delay
index|[
literal|0
index|]
operator|=
name|new_delay
expr_stmt|;
name|samples
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Now sort the valid (non-zero delay) samples into a temporary 	 *  list by delay. 	 * 	 *  First, build the temp list... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|peer
operator|->
name|filter
operator|.
name|samples
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|filter
operator|.
name|delay
index|[
name|i
index|]
operator|!=
literal|0.0
condition|)
block|{
name|offset
index|[
name|samples
index|]
operator|=
name|peer
operator|->
name|filter
operator|.
name|offset
index|[
name|i
index|]
expr_stmt|;
name|delay
index|[
name|samples
operator|++
index|]
operator|=
name|peer
operator|->
name|filter
operator|.
name|delay
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* ..and now sort it. */
if|if
condition|(
name|samples
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|samples
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|samples
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|delay
index|[
name|i
index|]
operator|>
name|delay
index|[
name|j
index|]
condition|)
block|{
name|temp
operator|=
name|delay
index|[
name|i
index|]
expr_stmt|;
name|delay
index|[
name|i
index|]
operator|=
name|delay
index|[
name|j
index|]
expr_stmt|;
name|delay
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|offset
index|[
name|i
index|]
expr_stmt|;
name|offset
index|[
name|i
index|]
operator|=
name|offset
index|[
name|j
index|]
expr_stmt|;
name|offset
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
comment|/* samples are now sorted by delay */
name|peer
operator|->
name|estdelay
operator|=
name|delay
index|[
literal|0
index|]
expr_stmt|;
name|peer
operator|->
name|estoffset
operator|=
name|offset
index|[
literal|0
index|]
expr_stmt|;
block|}
name|temp
operator|=
literal|0.0
expr_stmt|;
name|w
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PEER_SHIFT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|samples
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|offset
index|[
name|i
index|]
operator|-
name|offset
index|[
literal|0
index|]
operator|)
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|PEER_MAXDISP
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
block|}
name|temp
operator|+=
name|d
operator|*
name|w
expr_stmt|;
comment|/* compute  PEER_FILTER**i  as we go along */
name|w
operator|*=
name|PEER_FILTER
expr_stmt|;
block|}
name|peer
operator|->
name|estdisp
operator|=
name|temp
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"clock_filter: estdelay %f, estoffset %f, estdisp %f"
operator|,
name|peer
operator|->
name|estdelay
operator|,
name|peer
operator|->
name|estoffset
operator|,
name|peer
operator|->
name|estdisp
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 4.2 Clock Select Procedure */
end_comment

begin_function
name|void
name|select_clock
parameter_list|()
block|{
name|struct
name|ntp_peer
modifier|*
name|ptmp
decl_stmt|,
modifier|*
name|peer
init|=
name|peer_list
operator|.
name|head
decl_stmt|;
struct|struct
name|sel_lst
block|{
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
name|double
name|distance
decl_stmt|;
name|double
name|precision
decl_stmt|;
block|}
name|sel_lst
index|[
name|X_NTP_CANDIDATES
index|]
struct|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|stratums
decl_stmt|,
name|candidates
decl_stmt|;
name|int
name|sanity_check
parameter_list|()
function_decl|;
name|double
name|dtmp
decl_stmt|;
name|candidates
operator|=
literal|0
expr_stmt|;
name|stratums
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|peer
operator|!=
name|NULL
operator|&&
name|candidates
operator|<
name|X_NTP_CANDIDATES
condition|)
block|{
comment|/* 		 * Check if this is a candidate for "sys.peer"  		 */
name|peer
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PEER_FL_SANE
operator||
name|PEER_FL_CANDIDATE
operator|)
expr_stmt|;
if|if
condition|(
name|sanity_check
argument_list|(
name|peer
argument_list|)
condition|)
block|{
name|sel_lst
index|[
name|candidates
index|]
operator|.
name|peer
operator|=
name|peer
expr_stmt|;
name|sel_lst
index|[
name|candidates
index|]
operator|.
name|distance
operator|=
name|peer
operator|->
name|estdisp
operator|+
name|s_fixed_to_double
argument_list|(
operator|&
name|peer
operator|->
name|dispersion
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_SANE
expr_stmt|;
name|candidates
operator|++
expr_stmt|;
block|}
name|peer
operator|=
name|peer
operator|->
name|next
expr_stmt|;
block|}
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select_clock: step1 %d candidates"
operator|,
name|candidates
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  If no candidates passed the sanity check, then give up. 	 */
if|if
condition|(
operator|!
name|candidates
condition|)
block|{
if|if
condition|(
name|sys
operator|.
name|peer
operator|!=
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"Lost NTP peer %s"
argument_list|,
name|paddr
argument_list|(
operator|&
name|sys
operator|.
name|peer
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select_clock: no candidates"
operator|)
argument_list|)
expr_stmt|;
name|sys
operator|.
name|peer
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * leave sys.stratum and sys.refid intact after losing  		 * reachability to all clocks.  After 24 hours, we'll 		 * set the alarm condition if we didn't get any clock 		 * updates. 		 */
return|return;
block|}
comment|/*  	 *  Sort the list.  We assume that sanity_check() above trashed any 	 *  peers which were stratum 0, so we can safely compare stratums 	 *  below.  Sort the list by stratum.  Where stratums are equal, the 	 *  peer with the lowest (peer.estdisp + peer.dispersion) is preferred. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidates
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|candidates
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|stratum
operator|>
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|->
name|stratum
operator|)
operator|||
operator|(
operator|(
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|stratum
operator|==
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|->
name|stratum
operator|)
operator|&&
operator|(
name|sel_lst
index|[
name|i
index|]
operator|.
name|distance
operator|>
name|sel_lst
index|[
name|j
index|]
operator|.
name|distance
operator|)
operator|)
condition|)
block|{
name|ptmp
operator|=
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
expr_stmt|;
name|dtmp
operator|=
name|sel_lst
index|[
name|i
index|]
operator|.
name|distance
expr_stmt|;
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|=
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
expr_stmt|;
name|sel_lst
index|[
name|i
index|]
operator|.
name|distance
operator|=
name|sel_lst
index|[
name|j
index|]
operator|.
name|distance
expr_stmt|;
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|=
name|ptmp
expr_stmt|;
name|sel_lst
index|[
name|j
index|]
operator|.
name|distance
operator|=
name|dtmp
expr_stmt|;
block|}
block|}
block|}
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select_clock: step2 %d candidates"
operator|,
name|candidates
operator|)
argument_list|)
expr_stmt|;
comment|/* truncate the list at NTP_MAXLIST peers */
if|if
condition|(
name|candidates
operator|>
name|NTP_MAXLIST
condition|)
name|candidates
operator|=
name|NTP_MAXLIST
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select_clock: step3 %d candidates"
operator|,
name|candidates
operator|)
argument_list|)
expr_stmt|;
comment|/* truncate list where number of different strata exceeds NTP_MAXSTRA */
for|for
control|(
name|stratums
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|candidates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sel_lst
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|peer
operator|->
name|stratum
operator|!=
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|stratum
condition|)
block|{
if|if
condition|(
operator|++
name|stratums
operator|>
name|NTP_MAXSTRA
condition|)
block|{
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"select_clock: truncated to %d peers"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|candidates
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select_clock: step4 %d candidates"
operator|,
name|candidates
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Kick out falsetickers 	 */
comment|/* now, re-sort the list by peer.stratum and peer.estdelay */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidates
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|candidates
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|stratum
operator|>
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|->
name|stratum
operator|)
operator|||
operator|(
operator|(
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|stratum
operator|==
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|->
name|stratum
operator|)
operator|&&
operator|(
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|estdelay
operator|>
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|->
name|estdelay
operator|)
operator|)
condition|)
block|{
name|ptmp
operator|=
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
expr_stmt|;
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|=
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
expr_stmt|;
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|=
name|ptmp
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|candidates
operator|>
literal|1
condition|)
block|{
name|double
name|maxdispersion
init|=
literal|0.0
decl_stmt|,
name|dispersion
decl_stmt|,
name|weight
decl_stmt|;
name|double
name|min_precision_thres
init|=
literal|10e20
decl_stmt|,
name|precision_thres
decl_stmt|;
name|short
name|worst
init|=
literal|0
decl_stmt|;
comment|/* shut up GNU CC about unused var */
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select_clock: step5 %d candidates"
operator|,
name|candidates
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidates
condition|;
name|i
operator|++
control|)
block|{
comment|/* compute dispersion of candidate `i' relative to the 			   rest of the candidates */
name|dispersion
operator|=
literal|0.0
expr_stmt|;
name|weight
operator|=
literal|1.0
expr_stmt|;
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_CANDIDATE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|candidates
condition|;
name|j
operator|++
control|)
block|{
name|dtmp
operator|=
name|sel_lst
index|[
name|j
index|]
operator|.
name|peer
operator|->
name|estoffset
operator|-
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|estoffset
expr_stmt|;
if|if
condition|(
name|dtmp
operator|<
literal|0
condition|)
name|dtmp
operator|=
operator|-
name|dtmp
expr_stmt|;
name|dispersion
operator|+=
name|dtmp
operator|*
name|weight
expr_stmt|;
name|weight
operator|*=
name|NTP_SELECT
expr_stmt|;
block|}
comment|/* since we just happen to have this double floating 			   around.. */
name|sel_lst
index|[
name|i
index|]
operator|.
name|distance
operator|=
name|dispersion
expr_stmt|;
name|precision_thres
operator|=
name|NTP_MAXSKW
operator|+
literal|1.0
operator|/
operator|(
literal|1
operator|<<
operator|-
name|sys
operator|.
name|precision
operator|)
expr_stmt|;
if|if
condition|(
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|precision
operator|<
literal|0
operator|&&
operator|-
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|precision
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|NBBY
condition|)
name|precision_thres
operator|+=
literal|1.0
operator|/
operator|(
literal|1
operator|<<
operator|-
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|precision
operator|)
expr_stmt|;
name|sel_lst
index|[
name|i
index|]
operator|.
name|precision
operator|=
name|precision_thres
expr_stmt|;
if|if
condition|(
name|dispersion
operator|>=
name|maxdispersion
condition|)
block|{
name|maxdispersion
operator|=
name|dispersion
expr_stmt|;
name|worst
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|precision_thres
operator|<
name|min_precision_thres
condition|)
block|{
name|min_precision_thres
operator|=
name|precision_thres
expr_stmt|;
block|}
name|TRACE
argument_list|(
literal|4
argument_list|,
operator|(
literal|" peer %s => disp %f prec_th %f"
operator|,
name|paddr
argument_list|(
operator|&
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
operator|->
name|src
argument_list|)
operator|,
name|dispersion
operator|,
name|precision_thres
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *  Now check to see if the max dispersion is greater than 		 *  the min dispersion limit.  If so, crank again, otherwise 		 *  bail out. 		 */
if|if
condition|(
operator|!
operator|(
name|maxdispersion
operator|>
name|min_precision_thres
operator|)
condition|)
block|{
name|TRACE
argument_list|(
literal|4
argument_list|,
operator|(
literal|" %d left valid"
operator|,
name|candidates
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|TRACE
argument_list|(
literal|4
argument_list|,
operator|(
literal|" peer %s => TOSS"
operator|,
name|paddr
argument_list|(
operator|&
name|sel_lst
index|[
name|worst
index|]
operator|.
name|peer
operator|->
name|src
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 *  now, we need to trash the peer with the worst dispersion 		 *  and interate until there is only one candidate peer left. 		 */
if|if
condition|(
name|worst
operator|!=
name|candidates
operator|-
literal|1
condition|)
block|{
name|sel_lst
index|[
name|worst
index|]
operator|.
name|peer
operator|->
name|flags
operator|&=
operator|~
name|PEER_FL_CANDIDATE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|worst
operator|,
name|j
operator|=
name|worst
operator|+
literal|1
init|;
name|j
operator|<
name|candidates
condition|;
control|)
name|sel_lst
index|[
name|i
operator|++
index|]
operator|.
name|peer
operator|=
name|sel_lst
index|[
name|j
operator|++
index|]
operator|.
name|peer
expr_stmt|;
block|}
name|candidates
operator|--
expr_stmt|;
comment|/* one more time.. */
block|}
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"select_clock: step6 %d candidates"
operator|,
name|candidates
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Check to see if current peer is on the list of candidate peers.  If 	 *  don't change sys.peer.  Note that if the first selected clock is 	 *  at a lower stratum, don't even bother; we're going to want to 	 *  switch to it. 	 */
if|if
condition|(
name|sys
operator|.
name|peer
operator|!=
name|NULL
operator|&&
operator|(
name|sys
operator|.
name|peer
operator|->
name|stratum
operator|<=
name|sel_lst
index|[
literal|0
index|]
operator|.
name|peer
operator|->
name|stratum
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|candidates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sys
operator|.
name|peer
operator|==
name|sel_lst
index|[
name|i
index|]
operator|.
name|peer
condition|)
block|{
comment|/* 				 * The clock we're currently synchronized to 				 * is among the candidate peers.  Don't switch. 				 */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* 					 *  Count instances where the best  					 *  candidate is different from the 					 *  current clock, thus inhibiting 					 *  clockhopping. 					 */
name|peer_sw_inhibited
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
comment|/* 	 *  The currently selected peer (if any) isn't on the candidate list. 	 *  Grab the first one and let it be. 	 */
if|if
condition|(
name|sys
operator|.
name|peer
operator|!=
name|sel_lst
index|[
literal|0
index|]
operator|.
name|peer
condition|)
block|{
if|if
condition|(
name|sys
operator|.
name|peer
operator|!=
name|NULL
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"clock: select peer %s stratum %d was %s stratum %d"
argument_list|,
name|paddr
argument_list|(
operator|&
name|sel_lst
index|[
literal|0
index|]
operator|.
name|peer
operator|->
name|src
argument_list|)
argument_list|,
name|sel_lst
index|[
literal|0
index|]
operator|.
name|peer
operator|->
name|stratum
argument_list|,
name|paddr
argument_list|(
operator|&
name|sys
operator|.
name|peer
operator|->
name|src
argument_list|)
argument_list|,
name|sys
operator|.
name|peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"clock: select peer %s stratum %d was UNSYNCED"
argument_list|,
name|paddr
argument_list|(
operator|&
name|sel_lst
index|[
literal|0
index|]
operator|.
name|peer
operator|->
name|src
argument_list|)
argument_list|,
name|sel_lst
index|[
literal|0
index|]
operator|.
name|peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|sys
operator|.
name|peer
operator|=
name|sel_lst
index|[
literal|0
index|]
operator|.
name|peer
expr_stmt|;
name|peer_switches
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sanity_check
parameter_list|(
name|peer
parameter_list|)
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
name|TRACE
argument_list|(
literal|7
argument_list|,
operator|(
literal|"Checking peer %s stratum %d"
operator|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
operator|,
name|peer
operator|->
name|stratum
operator|)
argument_list|)
expr_stmt|;
comment|/* Snity check -1 - not really in consideration */
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_SNOOZE
condition|)
return|return
literal|0
return|;
comment|/* Sanity check 0. ?? */
if|if
condition|(
operator|!
operator|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_SYNC
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Sanity check 1. */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|<=
literal|0
operator|||
name|peer
operator|->
name|stratum
operator|>=
name|NTP_INFIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Sanity check 2. 	   if peer.stratum is greater than one (synchronized via NTP), 	   peer.refid must not match peer.dstadr */
if|if
condition|(
name|peer
operator|->
name|stratum
operator|>
literal|1
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nintf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|addrs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INTF_VALID
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|addrs
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|type
operator|==
name|AF_INET
operator|&&
name|peer
operator|->
name|refid
operator|.
name|rid_type
operator|==
name|RID_INET
operator|&&
name|addrs
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|inet_ad
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|peer
operator|->
name|refid
operator|.
name|rid_inet
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|addrs
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|type
operator|==
name|AF_OSI
operator|&&
name|peer
operator|->
name|refid
operator|.
name|rid_type
operator|==
name|RID_PSAP
operator|&&
name|psapaddr_cmp
argument_list|(
operator|&
name|peer
operator|->
name|refid
operator|.
name|rid_psap
argument_list|,
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|psap_ad
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* Sanity check 3. 	   Both peer.estdelay and 	   peer.estdisp to be less than NTP_MAXWGT, which insures that the 	   filter register at least half full, yet avoids using data from 	   very noisy associations or broken implementations.  	*/
if|if
condition|(
name|peer
operator|->
name|estdisp
operator|>
operator|(
name|float
operator|)
name|NTP_MAXWGT
operator|||
name|peer
operator|->
name|estdelay
operator|>
operator|(
name|float
operator|)
name|NTP_MAXWGT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  Sanity check 4. 	    The peer clock must be synchronized... and the interval since 	    the peer clock was last updated satisfy 	     	    peer.org - peer.reftime< NTP.MAXAGE 	    */
if|if
condition|(
name|peer
operator|->
name|leap
operator|==
name|ALARM
operator|||
operator|(
name|ul_fixed_to_double
argument_list|(
operator|&
name|peer
operator|->
name|org
argument_list|)
operator|-
name|ul_fixed_to_double
argument_list|(
operator|&
name|peer
operator|->
name|reftime
argument_list|)
operator|)
operator|>=
name|NTP_MAXAGE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|TRACE
argument_list|(
literal|7
argument_list|,
operator|(
literal|"That one is certainly qualified %s"
operator|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

