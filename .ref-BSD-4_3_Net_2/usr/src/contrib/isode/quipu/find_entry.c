begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* find_entry.c - */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/find_entry.c,v 7.4 91/03/09 11:56:56 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/find_entry.c,v 7.4 91/03/09 11:56:56 mrose Exp $  *  *  * $Log:	find_entry.c,v $  * Revision 7.4  91/03/09  11:56:56  mrose  * update  *   * Revision 7.3  91/02/22  09:39:22  mrose  * Interim 6.8  *   * Revision 7.2  90/10/17  11:54:19  mrose  * sync  *   * Revision 7.1  90/07/09  14:46:12  mrose  * sync  *   * Revision 7.0  89/11/23  22:17:40  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/commonarg.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/ds_error.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TURBO_AVL
end_ifdef

begin_include
include|#
directive|include
file|"quipu/turbo.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|Entry
name|database_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|cache_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|di_block
modifier|*
name|di_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|find_entry
parameter_list|(
name|object
parameter_list|,
name|ca
parameter_list|,
name|acl_who
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|ent_p
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|,
name|optype
parameter_list|)
name|DN
name|object
decl_stmt|;
name|common_args
modifier|*
name|ca
decl_stmt|;
name|DN
name|acl_who
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
modifier|*
name|ent_p
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
name|int
name|optype
decl_stmt|;
block|{
name|int
name|deref
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|time_t
name|cache_timeout
decl_stmt|;
name|DN
name|dn_found
decl_stmt|;
name|int
name|res
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"find_entry"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NOERROR
expr_stmt|;
if|if
condition|(
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_DONTDEREFERENCEALIAS
operator|)
operator|==
literal|0
condition|)
name|deref
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_DONTUSECOPY
operator|)
operator|!=
literal|0
condition|)
name|master
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|really_find_entry
argument_list|(
name|object
argument_list|,
name|deref
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|ent_p
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_entry - rfe: OK"
operator|)
argument_list|)
expr_stmt|;
comment|/* Have set up ent_p continue processing */
break|break;
case|case
name|DS_CONTINUE
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_entry - rfe: CONT"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|(
operator|*
name|di_p
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Have set up di_blocks of DSAs to be questioned */
return|return
operator|(
name|DS_CONTINUE
operator|)
return|;
case|case
name|DS_X500_ERROR
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_entry - rfe: X500_ERROR"
operator|)
argument_list|)
expr_stmt|;
comment|/* Have set up an error */
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
default|default:
comment|/* Scream */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"really_find_entry failed in find_entry 1"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_ERROR_LOCAL
operator|)
return|;
block|}
name|dn_found
operator|=
name|get_copy_dn
argument_list|(
operator|*
name|ent_p
argument_list|)
expr_stmt|;
comment|/* if the returned entry is a CONSTRUCTOR, return a referral */
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_data
operator|==
name|E_TYPE_CONSTRUCTOR
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_entry - constructor"
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|FALSE
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
comment|/* if the returned entry is a COPY, - check service controls */
if|if
condition|(
operator|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_data
operator|!=
name|E_DATA_MASTER
operator|)
operator|&&
operator|(
name|master
operator|)
condition|)
block|{
comment|/* DSAs are special for read/modify */
if|if
condition|(
operator|(
name|optype
operator|==
name|OP_READ
operator|)
operator|||
operator|(
name|optype
operator|==
name|OP_MODIFYRDN
operator|)
operator|||
operator|(
name|optype
operator|==
name|OP_MODIFYENTRY
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|quipu_ctx_supported
argument_list|(
operator|*
name|ent_p
argument_list|)
operator|==
literal|2
operator|)
operator|&&
operator|(
name|quipu_version_7
argument_list|(
operator|*
name|ent_p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dn_cmp
argument_list|(
name|dn_found
argument_list|,
name|mydsadn
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|mk_ref
label|:
empty_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_type
operator|=
name|DI_TASK
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_dn
operator|=
name|dn_found
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_reftype
operator|=
name|RT_UNDEFINED
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_rdn_resolved
operator|=
name|CR_RDNRESOLVED_NOTDEFINED
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_aliasedRDNs
operator|=
name|CR_NOALIASEDRDNS
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
operator|=
operator|*
name|ent_p
expr_stmt|;
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_refcount
operator|++
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_state
operator|=
name|DI_COMPLETE
expr_stmt|;
return|return
name|DS_CONTINUE
return|;
block|}
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_entry - slave master needed"
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|TRUE
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|optype
operator|==
name|OP_MODIFYRDN
operator|)
operator|||
operator|(
name|optype
operator|==
name|OP_MODIFYENTRY
operator|)
operator|)
operator|&&
operator|(
name|quipu_ctx_supported
argument_list|(
operator|*
name|ent_p
argument_list|)
operator|==
literal|2
operator|)
operator|&&
name|quipu_version_7
argument_list|(
operator|*
name|ent_p
argument_list|)
operator|&&
operator|(
name|dn_cmp
argument_list|(
name|dn_found
argument_list|,
name|mydsadn
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|mk_ref
goto|;
ifdef|#
directive|ifdef
name|WRONG_BEHAVIOUR
comment|/* if this is right, we need to make sure that dsa_info */
comment|/* pick ups the correct external reference */
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_external
operator|&&
operator|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_reftype
operator|!=
name|RT_NONSPECIFICSUBORDINATE
operator|)
condition|)
block|{
name|res
operator|=
name|constructor_dsa_info
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|TRUE
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_data
operator|==
name|E_TYPE_CACHE_FROM_MASTER
operator|)
operator|&&
operator|(
name|timenow
operator|-
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_age
operator|>
name|cache_timeout
operator|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_entry - cache timed out"
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|TRUE
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
expr_stmt|;
name|delete_cache
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
name|out
label|:
empty_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_parent
operator|==
name|NULLENTRY
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_entry: (*ent_p)->e_parent is NULLENTRY"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
comment|/* no acl for root entry */
block|}
if|if
condition|(
name|check_acl
argument_list|(
name|acl_who
argument_list|,
name|ACL_DETECT
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_parent
operator|->
name|e_acl
operator|->
name|ac_child
argument_list|,
name|object
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SECURITYERROR
expr_stmt|;
name|err
operator|->
name|ERR_SECURITY
operator|.
name|DSE_sc_problem
operator|=
name|DSE_SC_ACCESSRIGHTS
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|check_acl
argument_list|(
name|acl_who
argument_list|,
name|ACL_DETECT
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_acl
operator|->
name|ac_entry
argument_list|,
name|object
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SECURITYERROR
expr_stmt|;
name|err
operator|->
name|ERR_SECURITY
operator|.
name|DSE_sc_problem
operator|=
name|DSE_SC_ACCESSRIGHTS
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|find_child_entry
parameter_list|(
name|object
parameter_list|,
name|ca
parameter_list|,
name|acl_who
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|ent_p
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|object
decl_stmt|;
name|common_args
modifier|*
name|ca
decl_stmt|;
name|DN
name|acl_who
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
modifier|*
name|ent_p
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
comment|/* this is very similar to find_entry(), except a top level */
comment|/* constructor is allowed */
name|int
name|deref
init|=
name|FALSE
decl_stmt|;
name|int
name|res
decl_stmt|;
name|DN
name|dn_found
decl_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|Entry
name|akid
decl_stmt|;
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NOERROR
expr_stmt|;
if|if
condition|(
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_DONTDEREFERENCEALIAS
operator|)
operator|==
literal|0
condition|)
name|deref
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_DONTUSECOPY
operator|)
operator|!=
literal|0
condition|)
name|master
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|really_find_entry
argument_list|(
name|object
argument_list|,
name|deref
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|ent_p
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - rfe: OK"
operator|)
argument_list|)
expr_stmt|;
comment|/* Have set up ent_p continue processing */
break|break;
case|case
name|DS_CONTINUE
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - rfe: CONTINUE"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|(
operator|*
name|di_p
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Have set up di_blocks of DSAs to be questioned */
return|return
operator|(
name|DS_CONTINUE
operator|)
return|;
case|case
name|DS_X500_ERROR
case|:
comment|/* Have set up an error */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - rfe: X500_ERROR"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
default|default:
comment|/* Scream */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"really_find_entry failed in find_entry 1"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_ERROR_LOCAL
operator|)
return|;
block|}
comment|/* check to see if children OK */
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_children
operator|!=
name|NULLAVL
operator|&&
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_allchildrenpresent
operator|!=
name|FALSE
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_child
operator|!=
name|NULLENTRY
operator|)
operator|&&
operator|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_allchildrenpresent
operator|!=
name|FALSE
operator|)
condition|)
block|{
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - children OK"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|akid
operator|=
operator|(
name|Entry
operator|)
name|avl_getone
argument_list|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_children
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|akid
operator|->
name|e_data
condition|)
block|{
else|#
directive|else
switch|switch
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_child
operator|->
name|e_data
condition|)
block|{
endif|#
directive|endif
case|case
name|E_DATA_MASTER
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - children masters"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_TYPE_SLAVE
case|:
comment|/* see if we can use a copy ... */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - children slaves"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
condition|)
block|{
name|dn_found
operator|=
name|get_copy_dn
argument_list|(
operator|*
name|ent_p
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info_aux
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
break|break;
default|default:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - default"
operator|)
argument_list|)
expr_stmt|;
name|dn_found
operator|=
name|get_copy_dn
argument_list|(
operator|*
name|ent_p
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info_aux
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|isleaf
argument_list|(
operator|*
name|ent_p
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_external
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"find_child_entry - children NOTOK"
operator|)
argument_list|)
expr_stmt|;
name|dn_found
operator|=
name|get_copy_dn
argument_list|(
operator|*
name|ent_p
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info_aux
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
if|if
condition|(
name|check_acl
argument_list|(
name|acl_who
argument_list|,
name|ACL_DETECT
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_acl
operator|->
name|ac_child
argument_list|,
name|object
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SECURITYERROR
expr_stmt|;
name|err
operator|->
name|ERR_SECURITY
operator|.
name|DSE_sc_problem
operator|=
name|DSE_SC_ACCESSRIGHTS
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
name|int
name|really_find_entry
parameter_list|(
name|object
parameter_list|,
name|deref
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|ent_p
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|object
decl_stmt|;
name|int
name|deref
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
comment|/* Generate only master references - NB 				   does not imply returned entry is master */
name|Entry
modifier|*
name|ent_p
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TURBO_AVL
name|Entry
name|parent
decl_stmt|;
name|Avlnode
modifier|*
name|kids
decl_stmt|;
name|int
name|entryrdn_cmp
parameter_list|()
function_decl|;
else|#
directive|else
specifier|register
name|RDN
name|a_rdn
decl_stmt|;
name|Entry
name|trail
decl_stmt|;
endif|#
directive|endif
specifier|register
name|RDN
name|b_rdn
decl_stmt|;
name|DN
name|tdn
decl_stmt|,
name|dn
decl_stmt|,
name|dn_trail
init|=
name|NULLDN
decl_stmt|;
name|DN
name|aliasdn
init|=
name|NULLDN
decl_stmt|;
name|int
name|rdns
decl_stmt|,
name|aliases
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"really find entry"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* alias loop */
name|err
operator|->
name|dse_type
operator|=
name|DSE_NAMEERROR
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|=
name|DSE_NA_ALIASDEREFERENCE
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|=
name|NULLDN
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|database_root
operator|==
name|NULLENTRY
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"null root !!!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsa_info_parent
argument_list|(
name|object
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|,
name|master
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dn
operator|=
name|object
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"really_fe - DS_OK: database_root"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ent_p
operator|)
operator|=
name|database_root
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
name|b_rdn
operator|=
name|dn
operator|->
name|dn_rdn
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
operator|(
name|kids
operator|=
name|database_root
operator|->
name|e_children
operator|)
operator|==
name|NULLAVL
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
operator|(
operator|*
name|ent_p
operator|)
operator|=
name|database_root
operator|->
name|e_child
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"database->e_child == NULLENTRY"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_reply_child
argument_list|(
name|object
argument_list|,
name|dn
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|database_root
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
name|parent
operator|=
name|database_root
expr_stmt|;
else|#
directive|else
name|a_rdn
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_name
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|rdns
operator|=
literal|1
operator|,
name|aliases
operator|=
literal|0
init|;
condition|;
name|rdns
operator|++
control|)
block|{
comment|/* break or return out */
ifdef|#
directive|ifdef
name|TURBO_AVL
operator|*
name|ent_p
operator|=
operator|(
name|Entry
operator|)
name|avl_find
argument_list|(
name|kids
argument_list|,
operator|(
name|caddr_t
operator|)
name|b_rdn
argument_list|,
name|entryrdn_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ent_p
operator|==
name|NULLENTRY
condition|)
block|{
name|int
name|res
init|=
name|no_reply_edb
argument_list|(
name|object
argument_list|,
name|dn_trail
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|parent
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|DS_CONTINUE
condition|)
name|di_rdns
argument_list|(
operator|*
name|di_p
argument_list|,
name|rdns
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
else|#
directive|else
name|trail
operator|=
name|NULLENTRY
expr_stmt|;
while|while
condition|(
name|rdn_cmp
argument_list|(
name|a_rdn
argument_list|,
name|b_rdn
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|trail
operator|=
operator|(
operator|*
name|ent_p
operator|)
expr_stmt|;
operator|(
operator|*
name|ent_p
operator|)
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_sibling
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|int
name|res
init|=
name|no_reply_edb
argument_list|(
name|object
argument_list|,
name|dn_trail
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|trail
operator|->
name|e_parent
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|DS_CONTINUE
condition|)
name|di_rdns
argument_list|(
operator|*
name|di_p
argument_list|,
name|rdns
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
name|a_rdn
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_name
expr_stmt|;
block|}
comment|/* make found element first in list - optimistaion */
if|if
condition|(
name|trail
operator|!=
name|NULLENTRY
condition|)
block|{
comment|/* NOT already the first */
name|trail
operator|->
name|e_sibling
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_sibling
expr_stmt|;
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_sibling
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_parent
operator|->
name|e_child
expr_stmt|;
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_parent
operator|->
name|e_child
operator|=
operator|(
operator|*
name|ent_p
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TURBO_AVL */
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_alias
operator|!=
name|NULLDN
condition|)
comment|/* got an alias entry */
if|if
condition|(
name|deref
operator|!=
name|FALSE
condition|)
block|{
name|Entry
name|new_entry
decl_stmt|;
name|int
name|new_deref
decl_stmt|;
name|DN
name|t_aliasdn
decl_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NAMEERROR
expr_stmt|;
name|new_deref
operator|=
operator|(
name|deref
operator|==
operator|-
literal|1
operator|)
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|really_find_entry
argument_list|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_alias
argument_list|,
name|new_deref
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
operator|&
operator|(
name|new_entry
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"rfe:rfe:OK"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ent_p
operator|)
operator|=
name|new_entry
expr_stmt|;
name|t_aliasdn
operator|=
name|aliasdn
expr_stmt|;
name|aliasdn
operator|=
name|get_copy_dn
argument_list|(
name|new_entry
argument_list|)
expr_stmt|;
name|aliases
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tdn
operator|=
name|aliasdn
init|;
name|tdn
operator|!=
name|NULLDN
condition|;
name|tdn
operator|=
name|tdn
operator|->
name|dn_parent
control|)
name|aliases
operator|++
expr_stmt|;
name|tdn
operator|=
name|dn
operator|->
name|dn_parent
expr_stmt|;
if|if
condition|(
name|aliasdn
operator|==
name|NULLDN
condition|)
name|dn
operator|=
name|aliasdn
operator|=
name|dn_cpy
argument_list|(
name|tdn
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|dn
operator|=
name|aliasdn
init|;
name|dn
operator|->
name|dn_parent
operator|!=
name|NULLDN
condition|;
name|dn
operator|=
name|dn
operator|->
name|dn_parent
control|)
empty_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|dn_cpy
argument_list|(
name|tdn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t_aliasdn
condition|)
name|dn_free
argument_list|(
name|t_aliasdn
argument_list|)
expr_stmt|;
name|object
operator|=
name|aliasdn
expr_stmt|;
break|break;
case|case
name|DS_CONTINUE
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"rfe:rfe:CONT"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|(
operator|*
name|di_p
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|di_rdns
argument_list|(
operator|*
name|di_p
argument_list|,
name|rdns
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_CONTINUE
operator|)
return|;
case|case
name|DS_X500_ERROR
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"rfe:rfe:X500ERR"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|->
name|dse_type
operator|==
name|DSE_NAMEERROR
operator|)
operator|&&
operator|(
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|==
name|DSE_NA_ALIASDEREFERENCE
operator|)
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|==
name|NULLDN
condition|)
block|{
name|DN
name|tmp_dn
decl_stmt|;
name|tmp_dn
operator|=
name|dn
operator|->
name|dn_parent
expr_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|NULLDN
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|=
name|dn_cpy
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|tmp_dn
expr_stmt|;
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Alias deref Problem"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
else|else
block|{
name|ds_error_free
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NAMEERROR
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|=
name|DSE_NA_ALIASPROBLEM
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|=
name|dn_cpy
argument_list|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_alias
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Alias Problem"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
default|default:
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"rfe:rfe:localerror"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_ERROR_LOCAL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|dn_parent
operator|==
name|NULLDN
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"really_fe - DS_OK: ?1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
else|else
block|{
comment|/* alias on route - error in this case */
name|DN
name|tmp_dn
decl_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NAMEERROR
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|=
name|DSE_NA_ALIASDEREFERENCE
expr_stmt|;
name|tmp_dn
operator|=
name|dn
operator|->
name|dn_parent
expr_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|NULLDN
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|=
name|dn_cpy
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|tmp_dn
expr_stmt|;
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Alias deref(2) Problem"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_parent
operator|==
name|NULLDN
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"really_fe - DS_OK: ?2"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_children
operator|==
name|NULLAVL
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_child
operator|==
name|NULLENTRY
condition|)
block|{
endif|#
directive|endif
name|int
name|res
init|=
name|no_reply_child
argument_list|(
name|object
argument_list|,
name|dn
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
operator|(
operator|*
name|ent_p
operator|)
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|DS_CONTINUE
condition|)
name|di_rdns
argument_list|(
operator|*
name|di_p
argument_list|,
name|rdns
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasdn
condition|)
name|dn_free
argument_list|(
name|aliasdn
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
name|dn_trail
operator|=
name|dn
expr_stmt|;
name|dn
operator|=
name|dn
operator|->
name|dn_parent
expr_stmt|;
name|b_rdn
operator|=
name|dn
operator|->
name|dn_rdn
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|kids
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_children
expr_stmt|;
name|parent
operator|=
operator|*
name|ent_p
expr_stmt|;
else|#
directive|else
operator|(
operator|*
name|ent_p
operator|)
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_child
expr_stmt|;
name|a_rdn
operator|=
operator|(
operator|*
name|ent_p
operator|)
operator|->
name|e_name
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* NOTREACHED */
block|}
name|int
name|referral_dsa_info
parameter_list|(
name|object
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|ptr
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|,
name|chain
parameter_list|)
name|DN
name|object
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
name|ptr
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
name|char
name|chain
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"referral dsa_info"
operator|)
argument_list|)
expr_stmt|;
comment|/* generate a referral to a DUA if possible */
if|if
condition|(
name|ptr
operator|!=
name|NULLENTRY
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|e_parent
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|constructor_dsa_info_aux
argument_list|(
name|object
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|ptr
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
operator|)
operator|!=
name|DS_CONTINUE
condition|)
return|return
name|ret
return|;
comment|/* Try to make a referral - if not schedule a chain !!! */
if|if
condition|(
name|chain
condition|)
return|return
name|DS_CONTINUE
return|;
comment|/* PROBLEM: The following will get the best referral from our point  	 * of view.  This may not be the same from the DUAs point of view !!!          */
name|sort_dsa_list
argument_list|(
name|di_p
argument_list|)
expr_stmt|;
for|for
control|(
name|di_tmp
operator|=
operator|*
name|di_p
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|di_tmp
operator|->
name|di_state
operator|==
name|DI_DEFERRED
condition|)
continue|continue;
if|if
condition|(
name|di2cref
argument_list|(
name|di_tmp
argument_list|,
name|err
argument_list|,
name|DS_CTX_X500_DAP
argument_list|)
operator|==
name|OK
condition|)
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
comment|/* return the referral !! */
block|}
return|return
name|DS_CONTINUE
return|;
block|}
name|int
name|constructor_dsa_info
parameter_list|(
name|object
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|ptr
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|object
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
name|ptr
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"constructor dsa_info"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULLENTRY
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|e_parent
expr_stmt|;
return|return
operator|(
name|constructor_dsa_info_aux
argument_list|(
name|object
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|ptr
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
operator|)
return|;
block|}
name|int
name|constructor_dsa_info_aux
parameter_list|(
name|object
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|ptr
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|object
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
name|ptr
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"construct dsa_info aux"
operator|)
argument_list|)
expr_stmt|;
comment|/* follow entry back, until something that is not a CONSTRUCTOR */
for|for
control|(
init|;
name|ptr
operator|!=
name|NULLENTRY
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|e_parent
control|)
if|if
condition|(
operator|(
name|ptr
operator|->
name|e_data
operator|==
name|E_DATA_MASTER
operator|)
operator|||
operator|(
name|ptr
operator|->
name|e_data
operator|==
name|E_TYPE_SLAVE
operator|)
operator|||
operator|(
operator|(
name|ptr
operator|->
name|e_data
operator|==
name|E_TYPE_CACHE_FROM_MASTER
operator|)
operator|&&
operator|(
name|timenow
operator|-
name|ptr
operator|->
name|e_age
operator|<
name|cache_timeout
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ptr
operator|->
name|e_master
operator|==
name|NULLAV
operator|)
operator|&&
operator|(
name|ptr
operator|->
name|e_slave
operator|==
name|NULLAV
operator|)
condition|)
continue|continue ;
return|return
operator|(
name|dsa_info_new
argument_list|(
name|object
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|ptr
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|dsa_info_parent
argument_list|(
name|object
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|,
name|master
argument_list|)
operator|)
return|;
block|}
name|int
name|no_reply_child
parameter_list|(
name|object
parameter_list|,
name|dn
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|entryptr
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|object
decl_stmt|;
name|DN
name|dn
decl_stmt|;
comment|/* tail - not matched */
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
name|entryptr
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
name|DN
name|dn_tmp
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"no reply child"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isleaf
argument_list|(
name|entryptr
argument_list|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"definate NO"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|!=
name|NULLDN
condition|)
block|{
name|dn_tmp
operator|=
name|dn
operator|->
name|dn_parent
expr_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|NULLDN
expr_stmt|;
block|}
else|else
name|object
operator|=
name|NULLDN
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NAMEERROR
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|=
name|DSE_NA_NOSUCHOBJECT
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|=
name|dn_cpy
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|!=
name|NULLDN
condition|)
name|dn
operator|->
name|dn_parent
operator|=
name|dn_tmp
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|constructor_dsa_info_aux
argument_list|(
name|object
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|entryptr
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
operator|)
return|;
block|}
name|int
name|no_reply_edb
parameter_list|(
name|object
parameter_list|,
name|dn
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|entryptr
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|object
decl_stmt|;
name|DN
name|dn
decl_stmt|;
comment|/* tail - not matched */
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
name|entryptr
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
name|DN
name|dn_tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|Entry
name|akid
decl_stmt|;
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"no reply edb"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isleaf
argument_list|(
name|entryptr
argument_list|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"definate NO"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|!=
name|NULLDN
condition|)
block|{
name|dn_tmp
operator|=
name|dn
operator|->
name|dn_parent
expr_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|NULLDN
expr_stmt|;
block|}
else|else
name|object
operator|=
name|NULLDN
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NAMEERROR
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|=
name|DSE_NA_NOSUCHOBJECT
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|=
name|dn_cpy
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|!=
name|NULLDN
condition|)
name|dn
operator|->
name|dn_parent
operator|=
name|dn_tmp
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
name|entryptr
operator|->
name|e_children
operator|==
name|NULLAVL
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|entryptr
operator|->
name|e_child
operator|==
name|NULLENTRY
condition|)
block|{
endif|#
directive|endif
return|return
operator|(
name|constructor_dsa_info
argument_list|(
name|object
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|entryptr
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
name|akid
operator|=
operator|(
name|Entry
operator|)
name|avl_getone
argument_list|(
name|entryptr
operator|->
name|e_children
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|akid
operator|->
name|e_data
operator|==
name|E_DATA_MASTER
operator|)
operator|||
operator|(
operator|(
operator|!
name|master
operator|)
operator|&&
operator|(
name|akid
operator|->
name|e_data
operator|==
name|E_TYPE_SLAVE
operator|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|entryptr
operator|->
name|e_child
operator|->
name|e_data
operator|==
name|E_DATA_MASTER
operator|)
operator|||
operator|(
operator|(
operator|!
name|master
operator|)
operator|&&
operator|(
name|entryptr
operator|->
name|e_child
operator|->
name|e_data
operator|==
name|E_TYPE_SLAVE
operator|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"definate NO"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|!=
name|NULLDN
condition|)
block|{
name|dn_tmp
operator|=
name|dn
operator|->
name|dn_parent
expr_stmt|;
name|dn
operator|->
name|dn_parent
operator|=
name|NULLDN
expr_stmt|;
block|}
else|else
name|object
operator|=
name|NULLDN
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_NAMEERROR
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|=
name|DSE_NA_NOSUCHOBJECT
expr_stmt|;
name|err
operator|->
name|ERR_NAME
operator|.
name|DSE_na_matched
operator|=
name|dn_cpy
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|!=
name|NULLDN
condition|)
name|dn
operator|->
name|dn_parent
operator|=
name|dn_tmp
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
comment|/* build a referral */
return|return
operator|(
name|constructor_dsa_info_aux
argument_list|(
name|object
argument_list|,
name|dn_stack
argument_list|,
name|master
argument_list|,
name|entryptr
argument_list|,
name|err
argument_list|,
name|di_p
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

