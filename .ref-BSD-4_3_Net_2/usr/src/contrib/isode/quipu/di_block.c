begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* di_block.c - routines to handle operation activity blocks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/di_block.c,v 7.4 91/02/22 09:38:37 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/di_block.c,v 7.4 91/02/22 09:38:37 mrose Interim $  *  *  * $Log:	di_block.c,v $  * Revision 7.4  91/02/22  09:38:37  mrose  * Interim 6.8  *   * Revision 7.3  90/10/17  11:53:32  mrose  * sync  *   * Revision 7.2  90/07/09  14:45:34  mrose  * sync  *   * Revision 7.1  89/12/19  16:20:09  mrose  * sync  *   * Revision 7.0  89/11/23  22:17:00  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_include
include|#
directive|include
file|"tsap.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|di_block
modifier|*
name|di_alloc
parameter_list|()
block|{
name|struct
name|di_block
modifier|*
name|di_ret
decl_stmt|;
name|di_ret
operator|=
operator|(
expr|struct
name|di_block
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|di_block
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|di_ret
operator|)
return|;
block|}
end_function

begin_macro
name|di_free
argument_list|(
argument|di
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"di_free()"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|di
operator|->
name|di_state
condition|)
block|{
case|case
name|DI_GLOBAL
case|:
break|break;
case|case
name|DI_TASK
case|:
break|break;
case|case
name|DI_OPERATION
case|:
break|break;
default|default:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"di_free() of unknown type %d"
operator|,
name|di
operator|->
name|di_state
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dn_free
argument_list|(
name|di
operator|->
name|di_dn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|di
operator|->
name|di_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|di_accesspoints
operator|!=
name|NULLACCESSPOINT
condition|)
name|aps_free
argument_list|(
name|di
operator|->
name|di_accesspoints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|di
operator|->
name|di_type
operator|==
name|DI_TASK
operator|)
operator|&&
name|di
operator|->
name|di_entry
condition|)
name|entry_free
argument_list|(
name|di
operator|->
name|di_entry
argument_list|)
expr_stmt|;
name|di
operator|->
name|di_state
operator|=
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|di
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|di_extract
argument_list|(
argument|old_di
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|old_di
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|next_di
decl_stmt|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"di_extract"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_log
argument_list|(
name|old_di
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|old_di
operator|->
name|di_type
condition|)
block|{
case|case
name|DI_GLOBAL
case|:
name|next_di
operator|=
operator|&
operator|(
name|deferred_dis
operator|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|deferred_dis
init|;
name|di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di
operator|=
name|di
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|di
operator|==
name|old_di
condition|)
break|break;
name|next_di
operator|=
operator|&
operator|(
name|di
operator|->
name|di_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|di
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"di_block has escaped from global list"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
block|}
break|break;
case|case
name|DI_OPERATION
case|:
break|break;
case|case
name|DI_TASK
case|:
break|break;
default|default:
break|break;
block|}
name|di_free
argument_list|(
name|old_di
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|di_desist
argument_list|(
argument|di
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|di_block
modifier|*
name|di_tmp1
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di_tmp1_next
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di_tmp2
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p2
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"di_desist()"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|di_tmp1
operator|=
name|di
init|;
name|di_tmp1
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp1
operator|=
name|di_tmp1_next
control|)
block|{
name|di_tmp1_next
operator|=
name|di_tmp1
operator|->
name|di_next
expr_stmt|;
switch|switch
condition|(
name|di
operator|->
name|di_state
condition|)
block|{
case|case
name|DI_ACCESSPOINT
case|:
case|case
name|DI_COMPLETE
case|:
break|break;
case|case
name|DI_DEFERRED
case|:
name|di_p2
operator|=
operator|&
operator|(
name|di_tmp1
operator|->
name|di_perform
operator|->
name|on_wake_list
operator|)
expr_stmt|;
for|for
control|(
name|di_tmp2
operator|=
name|di_tmp1
operator|->
name|di_perform
operator|->
name|on_wake_list
init|;
name|di_tmp2
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp2
operator|=
name|di_tmp2
operator|->
name|di_wake_next
control|)
block|{
if|if
condition|(
name|di_tmp2
operator|==
name|di_tmp1
condition|)
break|break;
name|di_p2
operator|=
operator|&
operator|(
name|di_tmp2
operator|->
name|di_wake_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|di_tmp2
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"di_desist - di_block lost from performing operations wake up list"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|di_p2
operator|)
operator|=
name|di_tmp2
operator|->
name|di_wake_next
expr_stmt|;
block|}
break|break;
block|}
name|di_free
argument_list|(
name|di_tmp1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|di_log
argument_list|(
argument|di
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"di_block [%x] , state = %d, type = %d"
operator|,
name|di
operator|,
name|di
operator|->
name|di_state
operator|,
name|di
operator|->
name|di_type
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|di_list_log
argument_list|(
argument|di
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"di_list:"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|di_tmp
operator|=
name|di
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
name|di_log
argument_list|(
name|di_tmp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"di_list ends."
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|struct
name|dn_seq
modifier|*
name|prefer_dsa_list
init|=
name|NULLDNSEQ
decl_stmt|;
end_decl_stmt

begin_macro
name|prefer_dsa
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dn_seq
modifier|*
name|dsa
decl_stmt|,
modifier|*
name|loop
decl_stmt|;
if|if
condition|(
operator|(
name|dsa
operator|=
name|str2dnseq
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLDNSEQ
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid prefered DSA name %s"
operator|,
name|str
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prefer_dsa_list
operator|==
name|NULLDNSEQ
condition|)
name|prefer_dsa_list
operator|=
name|dsa
expr_stmt|;
else|else
block|{
for|for
control|(
name|loop
operator|=
name|prefer_dsa_list
init|;
name|loop
operator|->
name|dns_next
operator|!=
name|NULLDNSEQ
condition|;
name|loop
operator|=
name|loop
operator|->
name|dns_next
control|)
empty_stmt|;
name|loop
operator|->
name|dns_next
operator|=
name|dsa
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|di_prefer_dsa
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
name|DN
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|prefer_dsa_list
operator|==
name|NULLDNSEQ
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"NO DSAs to chose from"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* not fussy !!! */
block|}
if|if
condition|(
operator|(
name|b
operator|==
name|NULLDN
operator|)
operator|||
operator|(
name|a
operator|==
name|NULLDN
operator|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"di_pref DNs NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* safty catch - don't think it can happen */
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|dn_in_dnseq
argument_list|(
name|a
argument_list|,
name|prefer_dsa_list
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|y
operator|=
name|dn_in_dnseq
argument_list|(
name|b
argument_list|,
name|prefer_dsa_list
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA selected on preference"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|dn_in_dnseq
argument_list|(
name|b
argument_list|,
name|prefer_dsa_list
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA selected on preference"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|!=
name|y
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA selected on preference"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|>
name|y
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|di_ap2comp
argument_list|(
argument|di
argument_list|)
expr|struct
name|di_block
operator|*
operator|*
name|di
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|di_block
modifier|*
name|loop
decl_stmt|;
name|Entry
name|eptr
decl_stmt|;
comment|/* replace DI_ACCESSPOINT with DI_COMPLETE if possible... */
comment|/*	(data may have been cached since creating DI_ACCESSPOINT) */
for|for
control|(
name|loop
operator|=
operator|*
name|di
init|;
name|loop
operator|!=
name|NULL_DI_BLOCK
condition|;
name|loop
operator|=
name|loop
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|loop
operator|->
name|di_state
operator|!=
name|DI_ACCESSPOINT
condition|)
continue|continue;
if|if
condition|(
name|loop
operator|->
name|di_reftype
operator|==
name|RT_NONSPECIFICSUBORDINATE
condition|)
continue|continue;
comment|/* can't split these - all must be followed... */
if|if
condition|(
name|loop
operator|->
name|di_accesspoints
operator|->
name|ap_next
operator|==
name|NULLACCESSPOINT
condition|)
block|{
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry
argument_list|(
name|loop
operator|->
name|di_accesspoints
operator|->
name|ap_name
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULLENTRY
condition|)
if|if
condition|(
name|eptr
operator|->
name|e_dsainfo
operator|!=
name|NULLDSA
condition|)
block|{
name|loop
operator|->
name|di_entry
operator|=
name|eptr
expr_stmt|;
name|eptr
operator|->
name|e_refcount
operator|++
expr_stmt|;
name|loop
operator|->
name|di_state
operator|=
name|DI_COMPLETE
expr_stmt|;
name|aps_free
argument_list|(
name|loop
operator|->
name|di_accesspoints
argument_list|)
expr_stmt|;
name|loop
operator|->
name|di_accesspoints
operator|=
name|NULLACCESSPOINT
expr_stmt|;
block|}
block|}
else|else
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Many access points, but not a RT_NONSPECIFICSUBORDINATE"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|dsa_reliable
argument_list|(
argument|cn
argument_list|,
argument|good
argument_list|,
argument|when
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|connection
modifier|*
name|cn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|good
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|when
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Entry
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|local_find_entry
argument_list|(
name|cn
operator|->
name|cn_dn
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
return|return;
if|if
condition|(
name|ptr
operator|->
name|e_dsainfo
operator|==
name|NULLDSA
condition|)
return|return;
name|ptr
operator|->
name|e_dsainfo
operator|->
name|dsa_last_attempt
operator|=
name|when
expr_stmt|;
if|if
condition|(
name|good
condition|)
block|{
name|ptr
operator|->
name|e_dsainfo
operator|->
name|dsa_last_success
operator|=
name|when
expr_stmt|;
name|ptr
operator|->
name|e_dsainfo
operator|->
name|dsa_failures
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ptr
operator|->
name|e_dsainfo
operator|->
name|dsa_failures
operator|++
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|di_cmp_reliability
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
expr|struct
name|di_block
operator|*
name|a
operator|,
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|time_t
name|retry_timeout
decl_stmt|;
name|struct
name|dsa_info
modifier|*
name|da
decl_stmt|,
modifier|*
name|db
decl_stmt|;
comment|/* If we have used a DSA recently, with no failures - use it again */
if|if
condition|(
operator|(
name|da
operator|=
name|a
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|)
operator|==
name|NULLDSA
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|db
operator|=
name|b
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|)
operator|==
name|NULLDSA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|da
operator|->
name|dsa_last_attempt
operator|==
operator|(
name|time_t
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|dsa_failures
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|db
operator|->
name|dsa_last_success
operator|!=
operator|(
name|time_t
operator|)
literal|0
operator|)
operator|&&
operator|(
name|timenow
operator|-
name|db
operator|->
name|dsa_last_attempt
operator|<
name|retry_timeout
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* b worked recently */
block|}
elseif|else
if|if
condition|(
name|timenow
operator|-
name|db
operator|->
name|dsa_last_attempt
operator|<
name|retry_timeout
condition|)
return|return
literal|1
return|;
comment|/* b failed recently */
return|return
literal|0
return|;
comment|/* have not tried either recently  */
block|}
elseif|else
if|if
condition|(
name|db
operator|->
name|dsa_last_attempt
operator|==
operator|(
name|time_t
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|da
operator|->
name|dsa_failures
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|da
operator|->
name|dsa_last_success
operator|!=
operator|(
name|time_t
operator|)
literal|0
operator|)
operator|&&
operator|(
name|timenow
operator|-
name|da
operator|->
name|dsa_last_attempt
operator|<
name|retry_timeout
operator|)
condition|)
return|return
literal|1
return|;
comment|/* a worked recentdlry */
block|}
elseif|else
if|if
condition|(
name|timenow
operator|-
name|da
operator|->
name|dsa_last_attempt
operator|<
name|retry_timeout
condition|)
return|return
operator|-
literal|1
return|;
comment|/* a failed recently */
return|return
literal|0
return|;
comment|/* have not tried either recently  */
block|}
if|if
condition|(
name|da
operator|->
name|dsa_failures
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|dsa_failures
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* both OK */
return|return
literal|1
return|;
comment|/* a worked last time, b failed - use a */
block|}
if|if
condition|(
name|db
operator|->
name|dsa_failures
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* b worked last time, a failed - use b */
comment|/* both failed last time - see if either have suceeded recently */
if|if
condition|(
operator|(
name|timenow
operator|-
name|da
operator|->
name|dsa_last_success
operator|)
operator|>
name|retry_timeout
condition|)
block|{
if|if
condition|(
operator|(
name|timenow
operator|-
name|db
operator|->
name|dsa_last_success
operator|)
operator|>
name|retry_timeout
condition|)
return|return
literal|0
return|;
comment|/* too long ago to tell */
return|return
operator|-
literal|1
return|;
comment|/* use b it worked not that long ago... */
block|}
if|if
condition|(
operator|(
name|timenow
operator|-
name|db
operator|->
name|dsa_last_success
operator|)
operator|>
name|retry_timeout
condition|)
return|return
literal|1
return|;
comment|/* use a it worked not that long ago... */
comment|/* neither has worked recently chose some other way */
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|di_cmp_address
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
expr|struct
name|di_block
operator|*
name|a
operator|,
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|nb
decl_stmt|;
name|struct
name|NSAPaddr
name|nas
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|ta2norm
parameter_list|()
function_decl|;
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|tb
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
name|DN
name|dnptr
decl_stmt|,
name|mydnptr
decl_stmt|,
name|dna
decl_stmt|,
name|dnb
decl_stmt|;
name|int
name|ma
decl_stmt|,
name|mb
decl_stmt|;
comment|/* select DSA with best looking address !!! */
if|if
condition|(
name|a
operator|->
name|di_state
operator|==
name|DI_COMPLETE
condition|)
block|{
name|ta
operator|=
operator|&
operator|(
name|a
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
name|tb
operator|=
operator|&
operator|(
name|b
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
name|dna
operator|=
name|a
operator|->
name|di_dn
expr_stmt|;
name|dnb
operator|=
name|b
operator|->
name|di_dn
expr_stmt|;
block|}
else|else
block|{
comment|/* Use 1st access point only */
name|ta
operator|=
operator|&
operator|(
name|a
operator|->
name|di_accesspoints
operator|->
name|ap_address
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
name|tb
operator|=
operator|&
operator|(
name|b
operator|->
name|di_accesspoints
operator|->
name|ap_address
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
name|dna
operator|=
name|NULLDN
expr_stmt|;
name|dnb
operator|=
name|NULLDN
expr_stmt|;
block|}
comment|/* ta2norm return a static buffer */
name|ta
operator|=
name|ta2norm
argument_list|(
name|ta
argument_list|)
expr_stmt|;
name|nas
operator|=
operator|*
operator|(
name|ta
operator|->
name|ta_addrs
operator|)
expr_stmt|;
comment|/* struct copy */
name|na
operator|=
operator|&
name|nas
expr_stmt|;
name|tb
operator|=
name|ta2norm
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|nb
operator|=
name|tb
operator|->
name|ta_addrs
expr_stmt|;
comment|/* normalised, so look for first "na" match with ts_communities */
for|for
control|(
name|ip
operator|=
name|ts_communities
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ip
operator|==
name|na
operator|->
name|na_community
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|==
name|nb
operator|->
name|na_community
condition|)
break|break;
comment|/* same primary community */
return|return
literal|1
return|;
comment|/* 'a' preferred */
block|}
if|if
condition|(
operator|*
name|ip
operator|==
name|nb
operator|->
name|na_community
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 'b' preferred */
block|}
comment|/* Look at the DSA name to detect locality */
name|ma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dnptr
operator|=
name|dna
operator|,
name|mydnptr
operator|=
name|mydsadn
init|;
operator|(
name|dnptr
operator|!=
name|NULLDN
operator|)
operator|&&
operator|(
name|mydnptr
operator|!=
name|NULLDN
operator|)
condition|;
name|dnptr
operator|=
name|dnptr
operator|->
name|dn_parent
operator|,
name|mydnptr
operator|=
name|mydnptr
operator|->
name|dn_parent
control|)
block|{
if|if
condition|(
name|rdn_cmp
argument_list|(
name|dnptr
operator|->
name|dn_rdn
argument_list|,
name|mydnptr
operator|->
name|dn_rdn
argument_list|)
operator|==
literal|0
condition|)
name|ma
operator|++
expr_stmt|;
block|}
name|mb
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dnptr
operator|=
name|dnb
operator|,
name|mydnptr
operator|=
name|mydsadn
init|;
operator|(
name|dnptr
operator|!=
name|NULLDN
operator|)
operator|&&
operator|(
name|mydnptr
operator|!=
name|NULLDN
operator|)
condition|;
name|dnptr
operator|=
name|dnptr
operator|->
name|dn_parent
operator|,
name|mydnptr
operator|=
name|mydnptr
operator|->
name|dn_parent
control|)
block|{
if|if
condition|(
name|rdn_cmp
argument_list|(
name|dnptr
operator|->
name|dn_rdn
argument_list|,
name|mydnptr
operator|->
name|dn_rdn
argument_list|)
operator|==
literal|0
condition|)
name|mb
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ma
operator|!=
name|mb
condition|)
return|return
operator|(
name|ma
operator|>
name|mb
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
comment|/* check the DMD - NYI */
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|di_cmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
expr|struct
name|di_block
operator|*
name|a
operator|,
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*     *  Select best di_block     *    rule 1: deferred dsa infos have lowest preference,      *		 complete have highest.     *     *  If two block have same state, select using     *    preference 1: quipu DSAs with quipu context     *    preference 2: quipu DSAs     *    preference 3: reliable DSAs     *    preference 4: local DSAs     */
end_comment

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|di_state
operator|!=
name|b
operator|->
name|di_state
condition|)
return|return
operator|(
name|a
operator|->
name|di_state
operator|>
name|b
operator|->
name|di_state
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
comment|/* rule 1 */
switch|switch
condition|(
name|a
operator|->
name|di_state
condition|)
block|{
case|case
name|DI_DEFERRED
case|:
break|break;
case|case
name|DI_ACCESSPOINT
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|di_cmp_address
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"AP selected on address"
operator|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
comment|/* preference 4 - no info to asses 1,2 or 3 */
block|}
break|break;
case|case
name|DI_COMPLETE
case|:
name|x
operator|=
name|quipu_ctx_supported
argument_list|(
name|a
operator|->
name|di_entry
argument_list|)
expr_stmt|;
name|y
operator|=
name|quipu_ctx_supported
argument_list|(
name|b
operator|->
name|di_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|y
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA selected on context"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|>
name|y
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
comment|/* preference 1 or 2 */
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|di_cmp_reliability
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA selected on relibility"
operator|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
comment|/* preference 3 */
block|}
if|if
condition|(
operator|(
name|x
operator|=
name|di_cmp_address
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA selected on address"
operator|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
comment|/* preference 4 */
block|}
break|break;
block|}
return|return
operator|(
name|di_prefer_dsa
argument_list|(
name|a
operator|->
name|di_dn
argument_list|,
name|b
operator|->
name|di_dn
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|sort_dsa_list
argument_list|(
argument|dsas
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
modifier|*
name|dsas
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|di_block
modifier|*
name|trail
decl_stmt|;
name|struct
name|di_block
modifier|*
name|old_di
decl_stmt|,
modifier|*
name|new_di
decl_stmt|;
name|struct
name|di_block
modifier|*
name|result
decl_stmt|;
name|char
name|changed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|dsas
operator|==
name|NULL
condition|)
return|return;
comment|/* turn access point into complete references if possible */
name|di_ap2comp
argument_list|(
name|dsas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dsas
operator|==
name|NULL_DI_BLOCK
condition|)
return|return;
name|result
operator|=
operator|*
name|dsas
expr_stmt|;
if|if
condition|(
operator|(
name|old_di
operator|=
name|result
operator|->
name|di_next
operator|)
operator|==
name|NULL_DI_BLOCK
condition|)
return|return;
comment|/* only 1 - must be sorted !!! */
name|result
operator|->
name|di_next
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
for|for
control|(
init|;
name|old_di
operator|!=
name|NULL_DI_BLOCK
condition|;
control|)
block|{
name|trail
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
for|for
control|(
name|new_di
operator|=
name|result
init|;
name|new_di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|new_di
operator|=
name|new_di
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|di_cmp
argument_list|(
name|old_di
argument_list|,
name|new_di
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|trail
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
name|result
operator|=
name|old_di
expr_stmt|;
name|old_di
operator|=
name|old_di
operator|->
name|di_next
expr_stmt|;
name|result
operator|->
name|di_next
operator|=
name|new_di
expr_stmt|;
block|}
else|else
block|{
name|trail
operator|->
name|di_next
operator|=
name|old_di
expr_stmt|;
name|old_di
operator|=
name|old_di
operator|->
name|di_next
expr_stmt|;
name|trail
operator|->
name|di_next
operator|->
name|di_next
operator|=
name|new_di
expr_stmt|;
block|}
name|changed
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|trail
operator|=
name|new_di
expr_stmt|;
block|}
if|if
condition|(
name|new_di
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
name|trail
operator|->
name|di_next
operator|=
name|old_di
expr_stmt|;
if|if
condition|(
name|old_di
condition|)
block|{
name|old_di
operator|=
name|old_di
operator|->
name|di_next
expr_stmt|;
name|trail
operator|->
name|di_next
operator|->
name|di_next
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
block|}
block|}
block|}
operator|*
name|dsas
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA order changed"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"DSA order not changed"
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|common_address
parameter_list|(
name|a
parameter_list|,
name|tb
parameter_list|)
name|struct
name|di_block
modifier|*
name|a
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|tb
decl_stmt|;
block|{
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|nb
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* select DSA with best looking address !!! */
if|if
condition|(
name|a
operator|->
name|di_state
operator|==
name|DI_DEFERRED
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|a
operator|->
name|di_state
operator|==
name|DI_COMPLETE
condition|)
name|ta
operator|=
operator|&
operator|(
name|a
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
else|else
comment|/* Use 1 access point only */
name|ta
operator|=
operator|&
operator|(
name|a
operator|->
name|di_accesspoints
operator|->
name|ap_address
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
comment|/* compare ta and tb to see if they have a network in common */
for|for
control|(
name|na
operator|=
name|ta
operator|->
name|ta_addrs
operator|,
name|x
operator|=
name|ta
operator|->
name|ta_naddr
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|na
operator|++
operator|,
name|x
operator|--
control|)
block|{
for|for
control|(
name|nb
operator|=
name|tb
operator|->
name|ta_addrs
operator|,
name|y
operator|=
name|tb
operator|->
name|ta_naddr
operator|-
literal|1
init|;
name|y
operator|>=
literal|0
condition|;
name|nb
operator|++
operator|,
name|y
operator|--
control|)
block|{
if|if
condition|(
name|na
operator|->
name|na_community
operator|==
name|nb
operator|->
name|na_community
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|struct
name|di_block
modifier|*
name|select_refer_dsa
parameter_list|(
name|di
parameter_list|,
name|tk
parameter_list|)
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
block|{
name|struct
name|di_block
modifier|*
name|best
decl_stmt|;
name|struct
name|di_block
modifier|*
name|loop
decl_stmt|;
name|Entry
name|eptr
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|DN
name|rdsa
decl_stmt|;
comment|/* return the di block of the best DSA the other end should be 	   to contact... 	   If it can't contact any - return NULL         */
if|if
condition|(
name|di
operator|!=
name|NULL_DI_BLOCK
condition|)
name|best
operator|=
name|di
expr_stmt|;
else|else
name|best
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
comment|/* First set - find out who the remote end is... */
if|if
condition|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_X500_DAP
condition|)
return|return
name|best
return|;
comment|/* we will chain anyway - unless prevented by service control... */
name|rdsa
operator|=
name|tk
operator|->
name|tk_conn
operator|->
name|cn_dn
expr_stmt|;
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry
argument_list|(
name|rdsa
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
return|return
name|best
return|;
comment|/* no way of knowing */
if|if
condition|(
name|eptr
operator|->
name|e_dsainfo
operator|==
name|NULLDSA
condition|)
return|return
name|best
return|;
comment|/* no way of knowing */
name|ta
operator|=
operator|&
operator|(
name|eptr
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
name|ta
operator|=
name|ta2norm
argument_list|(
name|ta
argument_list|)
expr_stmt|;
comment|/* calculate subnets... */
for|for
control|(
name|loop
operator|=
name|di
init|;
name|loop
operator|!=
name|NULL_DI_BLOCK
condition|;
name|loop
operator|=
name|loop
operator|->
name|di_next
control|)
if|if
condition|(
name|common_address
argument_list|(
name|loop
argument_list|,
name|ta
argument_list|)
condition|)
return|return
name|loop
return|;
comment|/* nothing on the same network - chain if possible !!! */
return|return
name|NULL_DI_BLOCK
return|;
block|}
end_function

begin_macro
name|di_rdns
argument_list|(
argument|di
argument_list|,
argument|rdns
argument_list|,
argument|aliases
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rdns
decl_stmt|,
name|aliases
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|di_block
modifier|*
name|loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
name|di
init|;
name|loop
operator|!=
name|NULL_DI_BLOCK
condition|;
name|loop
operator|=
name|loop
operator|->
name|di_next
control|)
block|{
name|di
operator|->
name|di_rdn_resolved
operator|=
name|rdns
expr_stmt|;
name|di
operator|->
name|di_aliasedRDNs
operator|=
name|aliases
expr_stmt|;
block|}
block|}
end_block

end_unit

