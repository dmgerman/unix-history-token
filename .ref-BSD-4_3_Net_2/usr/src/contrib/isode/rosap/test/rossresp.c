begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * this is the example use of rosap taken from the manual  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"generic.h"
end_include

begin_include
include|#
directive|include
file|<isode/rosap.h>
end_include

begin_define
define|#
directive|define
name|error
value|fprintf
end_define

begin_function_decl
name|int
name|ros_indication
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|dfp
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|result
decl_stmt|,
name|sd
decl_stmt|;
name|int
name|res
decl_stmt|;
if|#
directive|if
literal|0
block|struct SSAPstart	sss;     register struct SSAPstart	*ss =&sss;     struct SSAPindication	sis;     register struct SSAPindication	*si =&sis;     register struct SSAPabort	*sa =&si->si_abort;     struct SSAPref	ref;
endif|#
directive|endif
name|struct
name|RoSAPindication
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
init|=
operator|&
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPpreject
modifier|*
name|rop
init|=
operator|&
name|roi
operator|->
name|roi_preject
decl_stmt|;
name|struct
name|RoSAPstart
name|ross
decl_stmt|;
name|dfp
operator|=
name|freopen
argument_list|(
literal|"/dev/console"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"Got to here\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (SInit(argc, argv, ss, si) == NOTOK) 	fprintf(dfp, "initialisation fails: %s", SErrString(sa->sa_reason));      sd = ss->ss_sd;
comment|/* would have read command line arguments here */
comment|/* This is rather an elegant scheme but there is no point in doing 	 * all this in line, a function would be more appropriate apart from 	 * the number of arguments required. 	 */
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \     if (sss.ss_requirements& requires) \ 	switch (sss.ss_settings& (ST_MASK<< shift)) { \ 	case ST_CALL_VALUE<< shift: \ 	    sss.ss_settings&= ~(ST_MASK<< shift); \ 	    sss.ss_settings |= ST_INIT_VALUE<< shift; \ 	    break; \ \         case ST_RESP_VALUE: \ 	case ST_INIT_VALUE: \ 	    break; \ \         default: \ 	    fprintf(stderr, "bad token setting for %s (%d)\n", type, \ 		sss.ss_settings& (ST_MASK<< shift)); \ 	} \ }
comment|/* expand out the above for each case */
block|dotokens();
undef|#
directive|undef
name|dotoken
block|bzero((char *)&ref, sizeof (ref));     if (SConnResponse(sd, ref, NULLSA, SC_ACCEPT, sss.ss_requirements, 	sss.ss_settings, sss.ss_isn, NULLCP, 0, si) == NOTOK) { 	fprintf(dfp, "A-ASSOCIATE.RESPONSE: %s", 	    SErrString(sis.si_abort.sa_reason)); 	exit(4);     }
endif|#
directive|endif
if|if
condition|(
name|RoInit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|ross
argument_list|,
operator|&
name|rois
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"initialisation fails: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sd
operator|=
name|ross
operator|.
name|ros_sd
expr_stmt|;
name|ROSFREE
argument_list|(
argument|&ross
argument_list|)
if|if
condition|(
name|RoBeginResponse
argument_list|(
name|sd
argument_list|,
name|ROS_ACCEPT
argument_list|,
name|NULLPE
argument_list|,
operator|&
name|rois
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"RO-BEGIN.RESPONSE fails: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RoSetService
argument_list|(
name|sd
argument_list|,
name|RoSService
argument_list|,
operator|&
name|rois
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|error
argument_list|(
literal|"RoSetService: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SHOW_BUG
if|if
condition|(
name|RoSetIndications
argument_list|(
name|sd
argument_list|,
name|ros_indication
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"RoSetIndications: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
else|#
directive|else
name|dfp
operator|=
name|freopen
argument_list|(
literal|"/dev/console"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"Got to here\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|res
operator|=
name|RoWaitRequest
argument_list|(
name|sd
argument_list|,
name|NOTOK
argument_list|,
name|roi
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"RoWaitRequest: %s\n"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"got a request %d\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|ros_indication
argument_list|(
name|sd
argument_list|,
name|roi
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONE
case|:
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"Done\n"
argument_list|)
expr_stmt|;
name|ros_indication
argument_list|(
name|sd
argument_list|,
name|roi
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should never get to here */
block|}
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Request/Reply loop of ROS server. Called when data arrives like a signal  * routine  */
end_comment

begin_function
specifier|static
name|int
name|ros_indication
parameter_list|(
name|sd
parameter_list|,
name|roi
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"ros_indication %d\n"
argument_list|,
name|roi
operator|->
name|roi_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|roi
operator|->
name|roi_type
condition|)
block|{
case|case
name|ROI_INVOKE
case|:
name|ros_invoke
argument_list|(
name|sd
argument_list|,
operator|&
name|roi
operator|->
name|roi_invoke
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_RESULT
case|:
name|ros_result
argument_list|(
name|sd
argument_list|,
operator|&
name|roi
operator|->
name|roi_result
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_ERROR
case|:
name|ros_error
argument_list|(
name|sd
argument_list|,
operator|&
name|roi
operator|->
name|roi_error
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_UREJECT
case|:
name|ros_ureject
argument_list|(
name|sd
argument_list|,
operator|&
name|roi
operator|->
name|roi_ureject
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_PREJECT
case|:
name|ros_preject
argument_list|(
name|sd
argument_list|,
operator|&
name|roi
operator|->
name|roi_preject
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_FINISH
case|:
name|ros_finish
argument_list|(
name|sd
argument_list|,
operator|&
name|roi
operator|->
name|roi_finish
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_END
case|:
name|ros_end
argument_list|(
name|sd
argument_list|,
operator|&
name|roi
operator|->
name|roi_end
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"unknown indication type=%d"
argument_list|,
name|roi
operator|->
name|roi_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|OP1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* OPERATIONS are numbered APDU_OPx, where each is a unique integer.  Further,    APDU_UNKNOWN is used as a tag different than any valid operation.     ERRORS are numbered ERROR_xyz, where each is a unique integer.    ERROR_MISTYPED is used to signal an argument error to an operation.    Further, ERROR_UNKNOWN is used as a tag to indicate that the operation    succeeded.     Finally, note that rox -> rox_args is updated in place by these routines.    If the routine returns ERROR_UNKNOWN, then rox_args contains the results    of the operation.  If the routine returns ERROR_MISTYPED, then rox_args is    untouched.  Otherwise, if the routine returns any other value, then    rox_args contains the parameters of the error which occurred.  Obviously,    each routine calls ROXFREE prior to setting rox_args to a new value.  */
end_comment

begin_struct
specifier|static
struct|struct
name|dispatch
block|{
name|int
name|ds_operation
decl_stmt|;
name|IFP
name|ds_vector
decl_stmt|;
block|}
name|dispatches
index|[]
init|=
block|{
name|APDU_OP1
block|,
name|OP1
block|,
name|APDU_ERR
block|,
name|OP1
block|,
name|APDU_URJ
block|,
name|OP1
block|,
comment|/* APDU_OPn,   OPn, */
name|APDU_UNKNOWN
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|ros_invoke
parameter_list|(
name|sd
parameter_list|,
name|rox
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|RoSAPinvoke
modifier|*
name|rox
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|;
name|struct
name|RoSAPindication
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
init|=
operator|&
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPpreject
modifier|*
name|rop
init|=
operator|&
name|roi
operator|->
name|roi_preject
decl_stmt|;
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|ds
operator|->
name|ds_operation
operator|!=
name|APDU_UNKNOWN
condition|;
name|ds
operator|++
control|)
if|if
condition|(
name|ds
operator|->
name|ds_operation
operator|==
name|rox
operator|->
name|rox_op
condition|)
break|break;
if|if
condition|(
name|ds
operator|->
name|ds_operation
operator|==
name|APDU_UNKNOWN
condition|)
block|{
if|if
condition|(
name|RoURejectRequest
argument_list|(
name|sd
argument_list|,
operator|&
name|rox
operator|->
name|rox_id
argument_list|,
name|ROS_IP_UNRECOG
argument_list|,
name|ROS_NOPRIO
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-U-REJECT.REQUEST: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|rox
operator|->
name|rox_nolinked
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|RoURejectRequest
argument_list|(
name|sd
argument_list|,
operator|&
name|rox
operator|->
name|rox_id
argument_list|,
name|ROS_IP_LINKED
argument_list|,
name|ROS_NOPRIO
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-U-REJECT.REQUEST: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|result
operator|=
call|(
modifier|*
name|ds
operator|->
name|ds_vector
call|)
argument_list|(
name|rox
argument_list|)
condition|)
block|{
case|case
name|ERROR_UNKNOWN
case|:
if|if
condition|(
name|RoResultRequest
argument_list|(
name|sd
argument_list|,
name|rox
operator|->
name|rox_id
argument_list|,
name|rox
operator|->
name|rox_op
argument_list|,
name|rox
operator|->
name|rox_args
argument_list|,
name|ROS_NOPRIO
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-RESULT.REQUEST: %s\n"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"RO-RESULT.REQUEST:done\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|RoErrorRequest
argument_list|(
name|sd
argument_list|,
name|rox
operator|->
name|rox_id
argument_list|,
name|result
argument_list|,
name|rox
operator|->
name|rox_args
argument_list|,
name|ROS_NOPRIO
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-ERROR.REQUEST: %s\n"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_MISTYPED
case|:
if|if
condition|(
name|RoURejectRequest
argument_list|(
name|sd
argument_list|,
operator|&
name|rox
operator|->
name|rox_id
argument_list|,
name|ROS_IP_MISTYPED
argument_list|,
name|ROS_NOPRIO
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-U-REJECT.REQUEST: %s\n"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
empty_stmt|;
name|ROXFREE
argument_list|(
name|rox
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ros_result
parameter_list|(
name|sd
parameter_list|,
name|ror
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|RoSAPresult
modifier|*
name|ror
decl_stmt|;
block|{
name|struct
name|RoSAPindication
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
init|=
operator|&
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPpreject
modifier|*
name|rop
init|=
operator|&
name|roi
operator|->
name|roi_preject
decl_stmt|;
if|if
condition|(
name|RoURejectRequest
argument_list|(
name|sd
argument_list|,
operator|&
name|ror
operator|->
name|ror_id
argument_list|,
name|ROS_RRP_UNRECOG
argument_list|,
name|ROS_NOPRIO
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-U-REJECT.REQUEST: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|RORFREE
argument_list|(
name|ror
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ros_error
parameter_list|(
name|sd
parameter_list|,
name|roe
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|RoSAPerror
modifier|*
name|roe
decl_stmt|;
block|{
name|struct
name|RoSAPindication
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
init|=
operator|&
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPpreject
modifier|*
name|rop
init|=
operator|&
name|roi
operator|->
name|roi_preject
decl_stmt|;
if|if
condition|(
name|RoURejectRequest
argument_list|(
name|sd
argument_list|,
operator|&
name|roe
operator|->
name|roe_id
argument_list|,
name|ROS_REP_UNRECOG
argument_list|,
name|ROS_NOPRIO
argument_list|,
name|roi
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-U-REJECT.REQUEST: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|ROEFREE
argument_list|(
name|roe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ros_ureject
parameter_list|(
name|sd
parameter_list|,
name|rou
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|RoSAPureject
modifier|*
name|rou
decl_stmt|;
block|{
comment|/* handle rejection here... */
block|}
end_function

begin_function
specifier|static
name|int
name|ros_preject
parameter_list|(
name|sd
parameter_list|,
name|rop
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|RoSAPpreject
modifier|*
name|rop
decl_stmt|;
block|{
if|if
condition|(
name|ROS_FATAL
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"RO-REJECT-P.INDICATION: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
comment|/* handle temporary failure here... */
block|}
end_function

begin_function
specifier|static
name|int
name|ros_finish
parameter_list|(
name|sd
parameter_list|,
name|acf
parameter_list|)
name|int
name|sd
decl_stmt|;
name|struct
name|AcSAPfinish
modifier|*
name|acf
decl_stmt|;
block|{
name|struct
name|AcSAPindication
name|acis
decl_stmt|;
specifier|register
name|struct
name|AcSAPabort
modifier|*
name|aca
init|=
operator|&
name|acis
operator|.
name|aci_abort
decl_stmt|;
name|ACFFREE
argument_list|(
name|acf
argument_list|)
expr_stmt|;
if|if
condition|(
name|AcRelResponse
argument_list|(
name|sd
argument_list|,
name|ACS_ACCEPT
argument_list|,
name|ACR_NORMAL
argument_list|,
name|NULLPEP
argument_list|,
literal|0
argument_list|,
operator|&
name|acis
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
name|dfp
argument_list|,
literal|"A-RELEASE.RESPONSE: %s"
argument_list|,
name|AcErrString
argument_list|(
name|aca
operator|->
name|aca_reason
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|dfp
argument_list|,
literal|"association released"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ros_end
parameter_list|(
name|sd
parameter_list|,
name|roe
parameter_list|)
name|int
name|sd
decl_stmt|;
name|struct
name|RoSAPend
modifier|*
name|roe
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|struct SSAPindication	sis;      if (SRelResponse(sd, SC_ACCEPT, NULLCP, 0,&sis) == NOTOK) { 	fprintf(dfp, "S-RELEASE.REPONSE: failed: %s\n", 	    SErrString(sis.si_abort.sa_reason)); 	exit(6);     }
endif|#
directive|endif
name|struct
name|RoSAPindication
name|rois
decl_stmt|;
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"RO-END.RESPONSE:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RoEndResponse
argument_list|(
name|sd
argument_list|,
operator|&
name|rois
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"RO-END.RESPONSE: failed: %s\n"
argument_list|,
name|RoErrString
argument_list|(
name|rois
operator|.
name|roi_preject
operator|.
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|OP1
argument_list|(
name|rox
argument_list|)
specifier|register
expr|struct
name|RoSAPinvoke
operator|*
name|rox
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"Invocation\nid %d"
argument_list|,
name|rox
operator|->
name|rox_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rox
operator|->
name|rox_nolinked
condition|)
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|" linked to %d"
argument_list|,
name|rox
operator|->
name|rox_linkid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|" operation %d\n"
argument_list|,
name|rox
operator|->
name|rox_op
argument_list|)
expr_stmt|;
comment|/* print the pe */
switch|switch
condition|(
name|rox
operator|->
name|rox_op
condition|)
block|{
case|case
name|APDU_OP1
case|:
return|return
operator|(
name|ERROR_UNKNOWN
operator|)
return|;
case|case
name|APDU_ERR
case|:
return|return
operator|(
name|ERROR_ERROR
operator|)
return|;
case|case
name|APDU_URJ
case|:
return|return
operator|(
name|ERROR_MISTYPED
operator|)
return|;
default|default:
name|fprintf
argument_list|(
name|dfp
argument_list|,
literal|"\nunknown operation %d\n"
argument_list|,
name|rox
operator|->
name|rox_op
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ERROR_ERROR
operator|)
return|;
block|}
end_block

end_unit

