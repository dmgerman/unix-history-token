begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftam-get.c - interactive initiator FTAM -- "get" */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftam-get.c,v 7.6 91/02/22 09:23:40 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftam-get.c,v 7.6 91/02/22 09:23:40 mrose Interim $  *  *  * $Log:	ftam-get.c,v $  * Revision 7.6  91/02/22  09:23:40  mrose  * Interim 6.8  *   * Revision 7.5  90/12/23  18:39:59  mrose  * update  *   * Revision 7.4  90/11/21  11:30:23  mrose  * sun  *   * Revision 7.3  90/09/07  11:13:59  mrose  * update  *   * Revision 7.2  90/07/01  21:03:08  mrose  * pepsy  *   * Revision 7.1  90/01/11  23:48:39  mrose  * lint  *   * Revision 7.0  89/11/23  21:54:17  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ftamuser.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|effector
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ubffnx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|vfsmap
modifier|*
name|findvf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_get
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|int
name|sglobbed
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
modifier|*
name|gp
decl_stmt|,
modifier|*
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|freedst
init|=
name|NULL
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
endif|#
directive|endif
name|struct
name|FADUidentity
name|faduids
decl_stmt|;
specifier|register
name|struct
name|FADUidentity
modifier|*
name|faduid
init|=
operator|&
name|faduids
decl_stmt|;
name|struct
name|vfsmap
modifier|*
name|vf
init|=
operator|&
name|vfs
index|[
name|tmode
index|]
decl_stmt|;
if|if
condition|(
name|vf
operator|==
operator|&
name|vfs
index|[
name|VFS_DEF
index|]
operator|&&
operator|(
operator|!
operator|(
name|units
operator|&
name|FUNIT_LIMITED
operator|)
operator|||
operator|(
name|class
operator|!=
name|FCLASS_MANAGE
operator|&&
name|class
operator|!=
name|FCLASS_TM
operator|)
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to use \"default\" document type on this association"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
else|#
directive|else
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"source: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
name|dst
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|vec
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
continue|continue;
if|if
condition|(
operator|--
name|ap
operator|!=
name|vec
condition|)
name|dst
operator|=
operator|*
name|ap
operator|,
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
else|else
name|dst
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|src
operator|=
name|xglob
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|OK
return|;
name|sglobbed
operator|=
name|xglobbed
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"destination: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|blkfree
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
switch|switch
condition|(
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|dst
operator|=
operator|*
name|vec
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"too many destinations"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|dst
operator|&&
operator|!
operator|(
name|dst
operator|=
name|freedst
operator|=
name|xglob1val
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
name|faduid
operator|->
name|fa_type
operator|=
name|FA_FIRSTLAST
expr_stmt|;
name|faduid
operator|->
name|fa_firstlast
operator|=
name|FA_FIRST
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|getvf
argument_list|(
operator|*
name|vec
argument_list|,
operator|*
name|vec
argument_list|,
name|faduid
argument_list|,
name|vf
argument_list|,
name|ubffnx
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|interrupted
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|src
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|src
expr_stmt|;
break|break;
default|default:
name|dst
operator|=
operator|*
name|src
expr_stmt|;
break|break;
block|}
name|ask_it
label|:
empty_stmt|;
if|if
condition|(
name|query
condition|)
switch|switch
condition|(
name|ask
argument_list|(
literal|"get %s %s"
argument_list|,
operator|*
name|src
argument_list|,
name|dst
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
goto|goto
name|out
goto|;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|dst
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
name|dst
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|src
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|src
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|buffer
expr_stmt|;
goto|goto
name|ask_it
goto|;
block|}
if|if
condition|(
name|check_get
argument_list|(
name|dst
argument_list|)
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|getvf
argument_list|(
operator|*
name|src
argument_list|,
name|dst
argument_list|,
name|faduid
argument_list|,
name|vf
argument_list|,
name|ubffnx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNKNOWN
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|rs_unknown
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|RFS_UNIX
case|:
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
name|dst
operator|&&
name|dst
index|[
name|strlen
argument_list|(
name|dst
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|dst
condition|?
name|dst
else|:
literal|"."
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|rs_support
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|buffer
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|dst
argument_list|,
literal|"unable to stat"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: not a directory"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|gp
operator|=
name|src
init|;
operator|*
name|gp
operator|&&
operator|!
name|interrupted
condition|;
name|gp
operator|++
control|)
block|{
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|gp
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|gp
expr_stmt|;
break|break;
default|default:
name|dst
operator|=
operator|*
name|gp
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|sglobbed
condition|)
block|{
if|if
condition|(
name|query
condition|)
switch|switch
condition|(
name|ask
argument_list|(
literal|"get %s %s"
argument_list|,
operator|*
name|gp
argument_list|,
name|dst
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
continue|continue;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"get %s %s"
argument_list|,
operator|*
name|gp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|check_get
argument_list|(
name|dst
argument_list|)
operator|==
name|NOTOK
condition|)
break|break;
operator|(
name|void
operator|)
name|getvf
argument_list|(
operator|*
name|gp
argument_list|,
name|dst
argument_list|,
name|faduid
argument_list|,
name|vf
argument_list|,
name|ubffnx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
condition|)
break|break;
block|}
name|out
label|:
empty_stmt|;
name|blkfree
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|freedst
condition|)
name|free
argument_list|(
name|freedst
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_function
specifier|static
name|int
name|check_get
parameter_list|(
name|dst
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|access
argument_list|(
name|dst
argument_list|,
name|W_OK
argument_list|)
operator|)
operator|==
name|NOTOK
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|dst
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|access
argument_list|(
operator|*
name|dst
condition|?
name|dst
else|:
literal|"/"
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
name|result
operator|=
name|access
argument_list|(
literal|"."
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|OK
condition|)
return|return
name|result
return|;
name|advise
argument_list|(
name|dst
argument_list|,
literal|"unable to write"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|getvf
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|faduid
parameter_list|,
name|vf
parameter_list|,
name|wfnx
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|struct
name|FADUidentity
modifier|*
name|faduid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|wfnx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|,
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|int
name|ftp_result
decl_stmt|;
endif|#
directive|endif
name|PE
name|param
decl_stmt|;
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
if|if
condition|(
name|vf
operator|==
operator|&
name|vfs
index|[
name|VFS_DEF
index|]
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|vf
operator|=
name|findvf
argument_list|(
name|src
argument_list|)
operator|)
condition|)
block|{
name|vf
operator|=
operator|&
name|vfs
index|[
name|VFS_UBF
index|]
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to determine document type associated with %s"
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* most likely reason: the file isn't there... */
if|if
condition|(
name|vf
operator|->
name|vf_oid
operator|==
name|NULLOID
operator|||
operator|!
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_OK
operator|)
condition|)
return|return
name|NOTOK
return|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"proposing %s transfer"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vf
operator|==
operator|&
name|vfs
index|[
name|VFS_FDF
index|]
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s is a %s"
argument_list|,
name|src
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|vf
operator|->
name|vf_oid
operator|==
name|NULLOID
operator|||
operator|!
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_OK
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no support for %ss"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|src
expr_stmt|;
name|ftse
operator|->
name|ftse_access
operator|=
name|FA_PERM_READ
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|param
operator|=
name|NULLPE
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_OPEN
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftg
operator|->
name|ftg_open
decl_stmt|;
name|ftop
operator|->
name|ftop_mode
operator|=
name|FA_PERM_READ
expr_stmt|;
name|ftop
operator|->
name|ftop_contents
operator|=
name|vf
operator|->
name|vf_oid
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|vf_parameter
condition|)
block|{
if|if
condition|(
name|enc_f
argument_list|(
name|vf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
operator|&
name|param
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|vf
operator|->
name|vf_parameter
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to build document type parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftop
operator|->
name|ftop_parameter
operator|=
name|param
expr_stmt|;
block|}
name|FCINIT
argument_list|(
operator|&
name|ftop
operator|->
name|ftop_conctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|concurrency
condition|)
name|ftop
operator|->
name|ftop_conctl
operator|.
name|fc_readlock
operator|=
name|FLOCK_SHARED
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|result
operator|=
name|FBulkBeginRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
condition|)
name|pe_free
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-BULK-BEGIN.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftse
operator|->
name|ftse_diags
argument_list|,
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
literal|1
argument_list|,
name|ftse
operator|->
name|ftse_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_OPEN
condition|)
block|{
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftg
operator|->
name|ftg_open
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftop
operator|->
name|ftop_diags
argument_list|,
name|ftop
operator|->
name|ftop_ndiag
argument_list|,
literal|1
argument_list|,
name|ftop
operator|->
name|ftop_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftop
operator|->
name|ftop_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
for|for
control|(
name|myvf
operator|=
name|vfs
init|;
name|myvf
operator|->
name|vf_entry
condition|;
name|myvf
operator|++
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|myvf
operator|->
name|vf_oid
argument_list|,
name|ftop
operator|->
name|ftop_contents
argument_list|)
operator|==
literal|0
condition|)
break|break;
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UBF
case|:
case|case
name|VFS_UTF
case|:
name|effector
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ftop
operator|->
name|ftop_parameter
operator|&&
name|myvf
operator|->
name|vf_number
operator|>=
literal|0
condition|)
block|{
name|caddr_t
name|parm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dec_f
argument_list|(
name|myvf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
name|ftop
operator|->
name|ftop_parameter
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|parm
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to parse document type parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
block|{
name|PElementID
name|id
decl_stmt|;
specifier|register
name|struct
name|type_DOCS_FTAM__1__Parameters
modifier|*
name|p1
init|=
operator|(
expr|struct
name|type_DOCS_FTAM__1__Parameters
operator|*
operator|)
name|parm
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|optionals
operator|&
name|opt_DOCS_FTAM__1__Parameters_universal__class__number
condition|)
name|id
operator|=
operator|(
name|PElementID
operator|)
name|p1
operator|->
name|universal__class__number
expr_stmt|;
else|else
name|id
operator|=
name|PE_DEFN_GFXS
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PE_DEFN_GFXS
case|:
if|if
condition|(
name|getenv
argument_list|(
literal|"HP-FTAM"
argument_list|)
condition|)
block|{
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* else fall... */
case|case
name|PE_DEFN_PRTS
case|:
case|case
name|PE_DEFN_VISS
case|:
name|effector
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PE_DEFN_T61S
case|:
case|case
name|PE_DEFN_VTXS
case|:
case|case
name|PE_DEFN_IA5S
case|:
case|case
name|PE_DEFN_GENS
case|:
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|VFS_UBF
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|parm
condition|)
operator|(
name|void
operator|)
name|fre_obj
argument_list|(
name|parm
argument_list|,
name|_ZDOCS_mod
operator|.
name|md_dtab
index|[
name|myvf
operator|->
name|vf_number
index|]
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"effector=%d"
argument_list|,
name|effector
argument_list|)
expr_stmt|;
comment|/* and fall... */
case|case
name|VFS_FDF
case|:
if|if
condition|(
name|myvf
operator|!=
name|vf
operator|||
name|watch
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s transfer"
argument_list|,
name|myvf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
name|vf
operator|=
name|myvf
expr_stmt|;
block|}
break|break;
default|default:
name|vf
operator|=
operator|&
name|vfs
index|[
name|VFS_UBF
index|]
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"document type mismatch; assuming %s (%s)"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|,
name|vf
operator|->
name|vf_entry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|myvf
operator|=
name|vf
expr_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
if|if
condition|(
name|FReadWriteRequest
argument_list|(
name|ftamfd
argument_list|,
name|FA_OPS_READ
argument_list|,
name|faduid
argument_list|,
name|myvf
operator|->
name|vf_context
argument_list|,
name|NOTOK
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-READWRITE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|dst
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
operator|(
name|fd
operator|=
name|dataconn
argument_list|(
name|dst
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|dst
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
endif|#
directive|endif
name|struct
name|FTAMdiagnostic
name|diags
index|[
name|NFDIAG
index|]
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|diags
decl_stmt|;
name|advise
argument_list|(
name|dst
argument_list|,
literal|"unable to write"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|ftp_result
operator|=
name|DONE
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"unable to write %s: %s"
argument_list|,
name|dst
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
if|if
condition|(
name|FCancelRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_PERM
argument_list|,
name|NULLPE
argument_list|,
name|diags
argument_list|,
name|dp
operator|-
name|diags
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|fti
operator|->
name|fti_type
operator|==
name|FTI_CANCEL
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done_transfer
goto|;
block|}
block|}
else|else
name|fd
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
call|(
modifier|*
name|wfnx
call|)
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|PSAPdata
operator|*
operator|)
literal|0
argument_list|,
name|OK
argument_list|)
expr_stmt|;
name|result
operator|=
name|getloop
argument_list|(
name|fd
argument_list|,
name|dst
argument_list|,
name|wfnx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
block|{
call|(
modifier|*
name|wfnx
call|)
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|PSAPdata
operator|*
operator|)
literal|0
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|done_transfer
goto|;
block|}
if|if
condition|(
name|FTransEndRequest
argument_list|(
name|ftamfd
argument_list|,
name|NULLPE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-TRANSFER-END.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
switch|switch
condition|(
name|fti
operator|->
name|fti_type
condition|)
block|{
case|case
name|FTI_TRANSEND
case|:
block|{
specifier|register
name|struct
name|FTAMtransend
modifier|*
name|ftre
init|=
operator|&
name|fti
operator|->
name|fti_transend
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftre
operator|->
name|ftre_diags
argument_list|,
name|ftre
operator|->
name|ftre_ndiag
argument_list|,
literal|1
argument_list|,
name|ftre
operator|->
name|ftre_action
argument_list|)
expr_stmt|;
name|FTREFREE
argument_list|(
name|ftre
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FTI_CANCEL
case|:
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"data transfer cancelled!"
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelResponse
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLPE
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.RESPONSE"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unexpected indication type=%d"
argument_list|,
name|fti
operator|->
name|fti_type
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
name|ftp_result
operator|=
name|OK
expr_stmt|;
endif|#
directive|endif
name|done_transfer
label|:
empty_stmt|;
name|ftg
operator|=
operator|&
name|ftgs
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CLOSE
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FBulkEndRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-BULK-END.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CLOSE
condition|)
block|{
specifier|register
name|struct
name|FTAMclose
modifier|*
name|ftcl
init|=
operator|&
name|ftg
operator|->
name|ftg_close
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftcl
operator|->
name|ftcl_diags
argument_list|,
name|ftcl
operator|->
name|ftcl_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcl
operator|->
name|ftcl_action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftde
operator|->
name|ftde_diags
argument_list|,
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
literal|1
argument_list|,
name|ftde
operator|->
name|ftde_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|)
expr_stmt|;
block|}
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|ftp_result
return|;
else|#
directive|else
return|return
name|OK
return|;
endif|#
directive|endif
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/*
comment|*/
specifier|static
name|struct
name|vfsmap
modifier|*
name|findvf
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|file
expr_stmt|;
name|ftse
operator|->
name|ftse_access
operator|=
name|FA_PERM_READATTR
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_RDATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMreadattr
modifier|*
name|ftra
init|=
operator|&
name|ftg
operator|->
name|ftg_readattr
decl_stmt|;
name|ftra
operator|->
name|ftra_attrnames
operator|=
name|FA_FILENAME
operator||
name|FA_CONTENTS
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FManageRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-MANAGE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|ftam_diag
argument_list|(
name|ftse
operator|->
name|ftse_diags
argument_list|,
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
literal|1
argument_list|,
name|ftse
operator|->
name|ftse_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
name|vf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_RDATTR
condition|)
block|{
specifier|register
name|struct
name|FTAMreadattr
modifier|*
name|ftra
init|=
operator|&
name|ftg
operator|->
name|ftg_readattr
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftra
operator|->
name|ftra_attrs
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|ftam_diag
argument_list|(
name|ftra
operator|->
name|ftra_diags
argument_list|,
name|ftra
operator|->
name|ftra_ndiag
argument_list|,
literal|1
argument_list|,
name|ftra
operator|->
name|ftra_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftra
operator|->
name|ftra_action
operator|!=
name|FACTION_SUCCESS
condition|)
name|fa
operator|->
name|fa_present
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_CONTENTS
condition|)
block|{
for|for
control|(
name|vf
operator|=
name|vfs
init|;
name|vf
operator|->
name|vf_entry
condition|;
name|vf
operator|++
control|)
if|if
condition|(
name|vf
operator|->
name|vf_oid
operator|&&
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_OK
operator|)
operator|&&
name|oid_cmp
argument_list|(
name|vf
operator|->
name|vf_oid
argument_list|,
name|fa
operator|->
name|fa_contents
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fa
operator|->
name|fa_parameter
operator|&&
name|vf
operator|->
name|vf_number
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|vf
operator|->
name|vf_parameter
operator|&&
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_PARM
operator|)
condition|)
operator|(
name|void
operator|)
name|fre_obj
argument_list|(
name|vf
operator|->
name|vf_parameter
argument_list|,
name|_ZDOCS_mod
operator|.
name|md_dtab
index|[
name|vf
operator|->
name|vf_number
index|]
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vf
operator|->
name|vf_parameter
operator|=
name|NULL
operator|,
name|vf
operator|->
name|vf_flags
operator|&=
operator|~
name|VF_PARM
expr_stmt|;
if|if
condition|(
name|dec_f
argument_list|(
name|vf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
name|fa
operator|->
name|fa_parameter
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|vf
operator|->
name|vf_parameter
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to parse document type parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|vf
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vf
operator|->
name|vf_check
operator|&&
call|(
modifier|*
name|vf
operator|->
name|vf_check
call|)
argument_list|(
name|vf
operator|->
name|vf_parameter
argument_list|,
name|PY_pepy
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|vf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|vf
operator|->
name|vf_entry
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown document type %s associated with %s"
argument_list|,
name|sprintoid
argument_list|(
name|fa
operator|->
name|fa_contents
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|vf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|ftam_diag
argument_list|(
name|ftde
operator|->
name|ftde_diags
argument_list|,
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
literal|1
argument_list|,
name|ftde
operator|->
name|ftde_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|)
expr_stmt|;
block|}
block|}
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|vf
return|;
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*
comment|*/
specifier|static
name|int
name|getloop
parameter_list|(
name|fd
parameter_list|,
name|dst
parameter_list|,
name|wfnx
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|IFP
name|wfnx
decl_stmt|;
block|{
name|int
name|reason
decl_stmt|,
name|result
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|interrupted
condition|)
block|{
name|int
name|nfds
decl_stmt|;
name|fd_set
name|rfds
decl_stmt|;
name|nfds
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
comment|/* interrupt causes EINTR */
if|if
condition|(
name|FSelectMask
argument_list|(
name|ftamfd
argument_list|,
operator|&
name|rfds
argument_list|,
operator|&
name|nfds
argument_list|,
name|fti
argument_list|)
operator|==
name|OK
condition|)
operator|(
name|void
operator|)
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|NOTOK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interrupted
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"cancelling transfer"
argument_list|)
expr_stmt|;
name|reason
operator|=
name|FS_GEN_INITIATOR
expr_stmt|;
name|errno
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|do_cancel
goto|;
block|}
switch|switch
condition|(
name|result
operator|=
name|FWaitRequest
argument_list|(
name|ftamfd
argument_list|,
name|NOTOK
argument_list|,
name|fti
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-WAIT.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
case|case
name|DONE
case|:
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown return from FWaitRequest=%d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fti
operator|->
name|fti_type
condition|)
block|{
case|case
name|FTI_DATA
case|:
if|if
condition|(
call|(
modifier|*
name|wfnx
call|)
argument_list|(
name|fd
argument_list|,
operator|&
name|fti
operator|->
name|fti_data
argument_list|,
name|OK
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|struct
name|FTAMdiagnostic
name|diags
index|[
name|NFDIAG
index|]
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
decl_stmt|;
name|advise
argument_list|(
name|dst
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
name|reason
operator|=
name|FS_ACC_WRITE
expr_stmt|;
name|do_cancel
label|:
empty_stmt|;
name|dp
operator|=
name|diags
expr_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|reason
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
if|if
condition|(
name|FCancelRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_PERM
argument_list|,
name|NULLPE
argument_list|,
name|diags
argument_list|,
name|dp
operator|-
name|diags
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|fti
operator|->
name|fti_type
operator|==
name|FTI_CANCEL
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
block|}
return|return
name|DONE
return|;
block|}
break|break;
case|case
name|FTI_DATAEND
case|:
return|return
name|OK
return|;
case|case
name|FTI_CANCEL
case|:
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"data transfer cancelled!"
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelResponse
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLPE
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.RESPONSE"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
return|return
name|DONE
return|;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unexpected indication type=%d"
argument_list|,
name|fti
operator|->
name|fti_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*
comment|*/
specifier|static
name|int
name|ubffnx
parameter_list|(
name|fd
parameter_list|,
name|px
parameter_list|,
name|status
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|PSAPdata
modifier|*
name|px
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|PE
name|pe
decl_stmt|,
modifier|*
name|pep
decl_stmt|;
specifier|static
name|int
name|cc
decl_stmt|;
if|if
condition|(
name|px
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|OK
case|:
default|default:
name|cc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|timer
argument_list|(
name|cc
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
condition|)
name|marks
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|DONE
case|:
if|if
condition|(
name|verbose
condition|)
name|timer
argument_list|(
name|cc
argument_list|,
literal|"received"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|OK
return|;
block|}
for|for
control|(
name|pep
operator|=
name|px
operator|->
name|px_info
operator|,
name|i
operator|=
name|px
operator|->
name|px_ninfo
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|pep
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|pe
operator|=
operator|*
name|pep
operator|)
operator|==
name|NULLPE
condition|)
continue|continue;
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UBF
case|:
default|default:
if|if
condition|(
name|debug
condition|)
name|WATCHP
argument_list|(
name|DOCS_FTAM__3__Datatype1
argument_list|,
name|pe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|de2fd
argument_list|(
name|fd
argument_list|,
name|pe
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|VFS_UTF
case|:
if|if
condition|(
name|debug
condition|)
name|WATCHP
argument_list|(
name|DOCS_FTAM__1__Datatype1
argument_list|,
name|pe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|de2fd
argument_list|(
name|fd
argument_list|,
name|pe
argument_list|,
literal|1
argument_list|,
name|effector
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NOTOK
condition|)
break|break;
if|if
condition|(
name|verbose
operator|||
name|hash
condition|)
name|cc
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|hash
condition|)
block|{
if|if
condition|(
name|hash
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%d\r"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|marks
operator|<
name|cc
condition|;
name|marks
operator|+=
name|BUFSIZ
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

end_unit

