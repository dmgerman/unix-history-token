begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftamd-trans.c - FTAM responder -- transfer */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftamd-trans.c,v 7.8 91/02/22 09:23:58 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftamd-trans.c,v 7.8 91/02/22 09:23:58 mrose Interim $  *  *  * $Log:	ftamd-trans.c,v $  * Revision 7.8  91/02/22  09:23:58  mrose  * Interim 6.8  *   * Revision 7.7  91/01/13  12:26:59  mrose  * NBS  *   * Revision 7.6  90/11/21  11:30:46  mrose  * sun  *   * Revision 7.5  90/11/11  10:01:15  mrose  * touch-up  *   * Revision 7.4  90/11/05  13:29:50  mrose  * nist  *   * Revision 7.3  90/08/14  14:28:28  mrose  * T1  *   * Revision 7.2  90/07/01  21:03:28  mrose  * pepsy  *   * Revision 7.1  90/01/16  20:43:01  mrose  * last check-out  *   * Revision 7.0  89/11/23  21:54:33  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"FTAM-types.h"
end_include

begin_include
include|#
directive|include
file|"ftamsystem.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HPUX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_define
define|#
directive|define
name|TMS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|TRANSFER */
end_comment

begin_function
name|int
name|ftam_bulkbeginindication
parameter_list|(
name|ftg
parameter_list|)
name|struct
name|FTAMgroup
modifier|*
name|ftg
decl_stmt|;
block|{
name|int
name|state
decl_stmt|;
name|struct
name|FTAMgroup
name|ftms
decl_stmt|;
name|struct
name|FTAMgroup
modifier|*
name|ftm
init|=
operator|&
name|ftms
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|ftam_selection
argument_list|(
name|ftg
argument_list|,
name|ftm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftm
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
name|state
operator|=
name|ftm
operator|->
name|ftg_select
operator|.
name|ftse_state
expr_stmt|;
else|else
name|state
operator|=
name|ftm
operator|->
name|ftg_create
operator|.
name|ftce_state
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|!=
name|FSTATE_SUCCESS
operator|||
operator|(
operator|(
name|ftm
operator|->
name|ftg_flags
operator|&
name|FTG_OPEN
operator|)
operator|&&
name|ftm
operator|->
name|ftg_open
operator|.
name|ftop_state
operator|!=
name|FSTATE_SUCCESS
operator|)
operator|)
operator|&&
name|myfd
operator|!=
name|NOTOK
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|unlock
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
name|myfd
operator|=
name|NOTOK
expr_stmt|;
block|}
if|if
condition|(
name|FBulkBeginResponse
argument_list|(
name|ftamfd
argument_list|,
name|ftm
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-BULK-BEGIN.RESPONSE"
argument_list|)
expr_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* we really pay the price here for not keeping more constraint set    information in the vfs structure...     regular files have the unstructured constraint set 	access context US     directory files have the sequential flat constraint set 	access context UA (is forced)     Hence, when FADUs are transmitted, only data elements of type  	File-Contents-Data-Element     are sent. */
end_comment

begin_function
name|int
name|ftam_readwriteindication
parameter_list|(
name|ftrw
parameter_list|)
name|struct
name|FTAMreadwrite
modifier|*
name|ftrw
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|FADUidentity
modifier|*
name|fa
init|=
operator|&
name|ftrw
operator|->
name|ftrw_identity
decl_stmt|;
name|struct
name|FTAMdiagnostic
name|diags
index|[
name|NFDIAG
index|]
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|diags
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|mylocation
operator|=
operator|*
name|fa
expr_stmt|;
comment|/* struct copy */
name|mylevel
operator|=
name|ftrw
operator|->
name|ftrw_level
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|myoperation
operator|=
name|ftrw
operator|->
name|ftrw_operation
expr_stmt|;
if|if
condition|(
name|ftp_type
argument_list|(
name|myvf
operator|-
name|vfs
argument_list|)
operator|==
name|NOTOK
operator|&&
name|myoperation
operator|==
name|FA_OPS_READ
operator|&&
operator|(
name|mycontext
operator|=
name|ftrw
operator|->
name|ftrw_context
operator|)
operator|!=
name|myvf
operator|->
name|vf_context
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|myoperation
operator|=
name|ftrw
operator|->
name|ftrw_operation
operator|)
operator|==
name|FA_OPS_READ
operator|&&
operator|(
name|mycontext
operator|=
name|ftrw
operator|->
name|ftrw_context
operator|)
operator|!=
name|myvf
operator|->
name|vf_context
condition|)
block|{
endif|#
directive|endif
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_CTXSUPRT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
goto|goto
name|do_cancel
goto|;
block|}
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UBF
case|:
case|case
name|VFS_UTF
case|:
default|default:
if|if
condition|(
name|fa
operator|->
name|fa_type
operator|!=
name|FA_FIRSTLAST
operator|||
name|fa
operator|->
name|fa_firstlast
operator|!=
name|FA_FIRST
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_FADULOC
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
goto|goto
name|do_cancel
goto|;
block|}
break|break;
block|}
switch|switch
condition|(
name|myoperation
condition|)
block|{
case|case
name|FA_OPS_READ
case|:
default|default:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"read %s"
argument_list|,
name|myfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FA_OPS_INSERT
case|:
comment|/* not valid on an FDF */
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_INSERT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
goto|goto
name|do_cancel
goto|;
case|case
name|FA_OPS_REPLACE
case|:
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
operator|(
name|myfd
operator|=
name|ftp_write
argument_list|(
name|myfile
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|statok
operator|&&
name|myst
operator|.
name|st_size
operator|==
literal|0
condition|)
goto|goto
name|replace
goto|;
ifdef|#
directive|ifdef
name|SUNOS4
if|if
condition|(
name|ftruncate
argument_list|(
name|myfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|ftruncate
argument_list|(
name|myfd
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
endif|#
directive|endif
endif|#
directive|endif
name|bad_operation
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|myoperation
operator|==
name|FA_OPS_REPLACE
condition|?
name|FS_ACC_REPLACE
else|:
name|FS_ACC_INSERT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|ftp_error
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
goto|goto
name|do_cancel
goto|;
block|}
ifndef|#
directive|ifndef
name|BRIDGE
name|replace
label|:
empty_stmt|;
endif|#
directive|endif
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"replace %s"
argument_list|,
name|myfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FA_OPS_EXTEND
case|:
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
operator|(
name|myfd
operator|=
name|ftp_append
argument_list|(
name|myfile
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
else|#
directive|else
if|if
condition|(
name|lseek
argument_list|(
name|myfd
argument_list|,
literal|0L
argument_list|,
name|L_XTND
argument_list|)
operator|==
operator|(
name|long
operator|)
name|NOTOK
condition|)
endif|#
directive|endif
goto|goto
name|bad_operation
goto|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"extend %s"
argument_list|,
name|myfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|FTRWFREE
argument_list|(
name|ftrw
argument_list|)
expr_stmt|;
name|timer
argument_list|(
name|nbytes
operator|=
literal|0
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|myoperation
operator|!=
name|FA_OPS_READ
condition|)
return|return;
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
case|case
name|VFS_UBF
case|:
default|default:
name|result
operator|=
name|uxfget
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
break|break;
case|case
name|VFS_FDF
case|:
name|result
operator|=
name|fdfget
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NOTOK
condition|)
return|return;
name|do_cancel
label|:
empty_stmt|;
name|FTRWFREE
argument_list|(
name|ftrw
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_PERM
argument_list|,
name|NULLPE
argument_list|,
name|diags
argument_list|,
name|dp
operator|-
name|diags
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-CANCEL-REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fti
operator|->
name|fti_type
operator|==
name|FTI_CANCEL
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"F-CANCEL.RESPONSE: %d"
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*
comment|*/
specifier|static
name|uxfget
argument_list|(
name|diags
argument_list|)
specifier|register
expr|struct
name|FTAMdiagnostic
operator|*
operator|*
name|diags
expr_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|bsize
decl_stmt|,
name|effector
decl_stmt|,
name|gd
decl_stmt|,
name|magic
decl_stmt|,
name|nc
decl_stmt|,
name|size
decl_stmt|,
name|cancelled
init|=
name|OK
decl_stmt|;
name|PE
name|pe
decl_stmt|,
name|de
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
operator|*
name|diags
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
specifier|register
name|struct
name|type_DOCS_FTAM__1__Parameters
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|type_DOCS_FTAM__3__Parameters
modifier|*
name|p3
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE
comment|/* try opening file for ftp read */
if|if
condition|(
operator|(
name|myfd
operator|=
name|ftp_read
argument_list|(
name|myfile
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"failed file access on remote host"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
endif|#
directive|endif
name|effector
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
name|p1
operator|=
operator|(
expr|struct
name|type_DOCS_FTAM__1__Parameters
operator|*
operator|)
name|myparam
expr_stmt|;
if|if
condition|(
operator|(
name|gd
operator|=
name|dup
argument_list|(
name|myfd
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|gd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gd
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|gd
argument_list|)
expr_stmt|;
if|if
condition|(
name|myfd
operator|!=
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
name|myfd
operator|=
name|NOTOK
expr_stmt|;
operator|(
name|void
operator|)
name|ftp_reply
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|no_mem
goto|;
block|}
block|{
name|PElementID
name|id
decl_stmt|;
if|if
condition|(
name|p1
operator|&&
operator|(
name|p1
operator|->
name|optionals
operator|&
name|opt_DOCS_FTAM__1__Parameters_universal__class__number
operator|)
condition|)
name|id
operator|=
operator|(
name|PElementID
operator|)
name|p1
operator|->
name|universal__class__number
expr_stmt|;
else|else
name|id
operator|=
name|PE_DEFN_GFXS
expr_stmt|;
name|pe
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pe
operator|->
name|pe_id
condition|)
block|{
case|case
name|PE_DEFN_GFXS
case|:
if|if
condition|(
name|getenv
argument_list|(
literal|"HP-FTAM"
argument_list|)
condition|)
block|{
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* else fall... */
case|case
name|PE_DEFN_PRTS
case|:
case|case
name|PE_DEFN_VISS
case|:
name|effector
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PE_DEFN_T61S
case|:
case|case
name|PE_DEFN_VTXS
case|:
case|case
name|PE_DEFN_IA5S
case|:
case|case
name|PE_DEFN_GENS
case|:
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|magic
operator|=
name|fadusize
operator|-
name|MAGIC_OCTET1
operator|)
operator|<
literal|0
condition|)
name|magic
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VFS_UBF
case|:
name|p3
operator|=
operator|(
expr|struct
name|type_DOCS_FTAM__3__Parameters
operator|*
operator|)
name|myparam
expr_stmt|;
comment|/* and fall */
default|default:
name|fp
operator|=
name|NULL
expr_stmt|;
name|pe
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_OCTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|magic
operator|=
name|fadusize
operator|-
name|MAGIC_SINGLE
operator|)
operator|<
literal|0
condition|)
name|magic
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pe
operator|==
name|NULLPE
condition|)
goto|goto
name|no_mem
goto|;
name|pe
operator|->
name|pe_context
operator|=
name|myvf
operator|->
name|vf_id
expr_stmt|;
if|if
condition|(
name|magic
operator|>
literal|6
operator|*
literal|1024
condition|)
comment|/* FTAM profile T1 or A/111 limits  to 7K */
name|magic
operator|=
literal|6
operator|*
literal|1024
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|bsize
operator|=
name|BUFSIZ
operator|<<
literal|2
expr_stmt|;
name|size
operator|=
name|magic
operator|>=
name|bsize
condition|?
name|magic
else|:
name|bsize
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|bsize
condition|)
name|size
operator|-=
name|size
operator|%
name|bsize
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|MAXBSIZE
name|bsize
operator|=
name|BUFSIZ
expr_stmt|;
else|#
directive|else
name|bsize
operator|=
name|myst
operator|.
name|st_blksize
operator|>
literal|0
condition|?
name|myst
operator|.
name|st_blksize
else|:
name|BUFSIZ
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
operator|(
literal|1024
operator|<=
name|magic
operator|&&
name|magic
operator|<
name|bsize
operator|)
condition|?
name|magic
else|:
name|bsize
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
if|if
condition|(
name|p1
operator|&&
operator|(
name|p1
operator|->
name|optionals
operator|&
name|opt_DOCS_FTAM__1__Parameters_maximum__string__length
operator|)
operator|&&
name|p1
operator|->
name|maximum__string__length
operator|>
literal|0
condition|)
name|size
operator|=
name|p1
operator|->
name|maximum__string__length
expr_stmt|;
break|break;
case|case
name|VFS_UBF
case|:
if|if
condition|(
name|p3
operator|&&
operator|(
name|p3
operator|->
name|optionals
operator|&
name|opt_DOCS_FTAM__3__Parameters_maximum__string__length
operator|)
operator|&&
name|p3
operator|->
name|maximum__string__length
operator|>
literal|0
condition|)
name|size
operator|=
name|p3
operator|->
name|maximum__string__length
expr_stmt|;
comment|/* and fall */
default|default:
break|break;
block|}
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"effector=%d id=0x%x size=%d"
argument_list|,
name|effector
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|->
name|pe_prim
operator|=
name|PEDalloc
argument_list|(
name|pe
operator|->
name|pe_len
operator|=
name|size
argument_list|)
operator|)
operator|==
name|NULLPED
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|error_return
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pe
operator|->
name|pe_prim
operator|)
operator|+
name|size
operator|-
operator|(
name|fp
condition|?
literal|2
else|:
literal|0
operator|)
operator|,
name|nc
operator|=
literal|0
init|;
name|bp
operator|<
name|ep
condition|;
control|)
block|{
if|if
condition|(
name|fp
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|||
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
operator|)
operator|<
operator|(
name|ep
operator|-
name|bp
operator|+
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
block|{
name|n
operator|=
operator|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|)
condition|?
name|NOTOK
else|:
name|OK
expr_stmt|;
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|fgets
argument_list|(
name|bp
argument_list|,
name|ep
operator|-
name|bp
operator|+
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
operator|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|)
condition|?
name|NOTOK
else|:
name|OK
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|cp
operator|=
name|bp
operator|+
name|strlen
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|effector
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|cp
operator|>
name|bp
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|cp
operator|==
literal|'\r'
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
operator|++
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|bp
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: losing! */
name|n
operator|=
name|cp
operator|-
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
operator|*
name|cp
operator|++
operator|=
literal|'\r'
expr_stmt|;
endif|#
directive|endif
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|n
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|bp
operator|=
name|cp
expr_stmt|;
name|nc
operator|++
expr_stmt|;
continue|continue;
block|}
name|n
operator|=
name|cp
operator|-
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|n
operator|=
name|read
argument_list|(
name|myfd
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
case|case
name|OK
case|:
break|break;
default|default:
name|bp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NOTOK
operator|||
operator|(
name|n
operator|=
name|bp
operator|-
operator|(
name|char
operator|*
operator|)
name|pe
operator|->
name|pe_prim
operator|)
operator|==
literal|0
condition|)
break|break;
name|pe
operator|->
name|pe_len
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
operator|!
name|effector
condition|)
block|{
if|if
condition|(
operator|(
name|de
operator|=
name|pe_cpy
argument_list|(
name|pe
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
goto|goto
name|no_mem
goto|;
block|}
else|else
name|de
operator|=
name|pe
expr_stmt|;
if|if
condition|(
name|debug
condition|)
if|if
condition|(
name|fp
condition|)
block|{
name|WATCHP
argument_list|(
name|DOCS_FTAM__1__Datatype1
argument_list|,
name|de
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|WATCHP
argument_list|(
name|DOCS_FTAM__3__Datatype1
argument_list|,
name|de
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cancelled
operator|=
name|de2fadu
argument_list|(
name|de
argument_list|,
name|pe
operator|!=
name|de
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
goto|goto
name|error_return
goto|;
case|case
name|OK
case|:
default|default:
name|nbytes
operator|+=
operator|(
name|n
operator|-
name|nc
operator|)
operator|,
name|nc
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|DONE
case|:
break|break;
block|}
break|break;
block|}
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|DONE
operator|||
name|cancelled
operator|==
name|DONE
condition|)
return|return
name|DONE
return|;
if|if
condition|(
name|n
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCLDEV
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|n
operator|=
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|DONE
condition|)
block|{
name|timer
argument_list|(
name|nbytes
argument_list|,
literal|"sent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FDataEndRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
name|fta
argument_list|,
literal|"F-DATA-END.REQUEST"
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/*
comment|*/
specifier|static
name|fdfget
argument_list|(
name|diags
argument_list|)
specifier|register
expr|struct
name|FTAMdiagnostic
operator|*
operator|*
name|diags
expr_stmt|;
block|{
name|int
name|names
decl_stmt|,
name|len
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|PE
name|pe
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|int
name|dd
decl_stmt|;
name|FILE
modifier|*
name|df
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dd
decl_stmt|;
endif|#
directive|endif
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
operator|*
name|diags
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
specifier|register
name|struct
name|type_DOCS_NBS__9__Parameters
modifier|*
name|p9
decl_stmt|;
name|struct
name|type_DOCS_NBS__9__Datatype1
modifier|*
name|d9
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|myfile
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pp
operator|=
name|path
expr_stmt|;
operator|*
name|pp
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
name|strcmp
argument_list|(
name|myfile
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|myfile
argument_list|,
literal|"//"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
operator|=
name|path
argument_list|,
literal|"%s"
argument_list|,
name|myfile
argument_list|)
expr_stmt|;
name|pp
operator|+=
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|pp
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
operator|=
name|path
argument_list|,
literal|"%s/"
argument_list|,
name|myfile
argument_list|)
expr_stmt|;
name|pp
operator|+=
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|pp
argument_list|)
operator|)
expr_stmt|;
block|}
name|pe
operator|=
name|NULLPE
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
operator|(
name|dd
operator|=
name|ftp_ls
argument_list|(
name|myfile
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
operator|(
name|df
operator|=
name|fdopen
argument_list|(
name|dd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|dd
operator|=
name|opendir
argument_list|(
name|myfile
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
endif|#
directive|endif
name|no_mem
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|error_return
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|dd
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|dd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftp_reply
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|dd
condition|)
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dd
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p9
operator|=
operator|(
expr|struct
name|type_DOCS_NBS__9__Parameters
operator|*
operator|)
name|myparam
expr_stmt|;
if|if
condition|(
name|fdf_p2names
argument_list|(
name|ftamfd
argument_list|,
name|p9
argument_list|,
operator|&
name|names
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|d2
init|=
name|fti
operator|->
name|fti_abort
operator|.
name|fta_diags
decl_stmt|;
name|dp
operator|=
name|d2
expr_stmt|;
comment|/* struct copy */
name|dp
operator|++
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|n
operator|=
name|OK
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|df
argument_list|)
condition|)
block|{
else|#
directive|else
for|for
control|(
name|errno
operator|=
literal|0
init|;
name|d
operator|=
name|readdir
argument_list|(
name|dd
argument_list|)
condition|;
name|errno
operator|=
literal|0
control|)
block|{
endif|#
directive|endif
name|struct
name|FTAMattributes
name|fas
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|fas
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
specifier|register
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|ptr
operator|=
name|rindex
argument_list|(
name|line
argument_list|,
literal|'\r'
argument_list|)
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
ifdef|#
directive|ifdef
name|BRIDGE
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"len=%d name=\"%s\""
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ino=%ld len=%d name=\"%s\""
argument_list|,
name|d
operator|->
name|d_ino
argument_list|,
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
operator|!
name|d
operator|->
name|d_ino
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|len
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
operator|>=
name|MAXPATHLEN
condition|)
else|#
directive|else
if|if
condition|(
name|len
operator|+
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
operator|>=
name|MAXPATHLEN
condition|)
endif|#
directive|endif
continue|continue;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pp
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pp
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
operator|||
operator|(
name|vf
operator|=
name|st2vfs
argument_list|(
name|NOTOK
argument_list|,
name|path
argument_list|,
operator|&
name|st
argument_list|,
name|NULLOID
argument_list|,
name|ftamfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fa
argument_list|,
sizeof|sizeof
expr|*
name|fa
argument_list|)
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|readattrs
argument_list|(
name|names
argument_list|,
name|fa
argument_list|,
name|vfs
index|[
name|VFS_UTF
index|]
operator|.
name|vf_oid
argument_list|,
name|NULLPE
argument_list|,
name|path
argument_list|,
operator|&
name|st
argument_list|,
name|diags
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|readattrs
argument_list|(
name|names
argument_list|,
name|fa
argument_list|,
name|vf
operator|->
name|vf_oid
argument_list|,
name|NULLPE
argument_list|,
name|path
argument_list|,
operator|&
name|st
argument_list|,
name|diags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
operator|*
name|diags
expr_stmt|;
if|if
condition|(
name|fdf_attrs2d
argument_list|(
name|ftamfd
argument_list|,
name|fa
argument_list|,
operator|&
name|d9
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|d2
init|=
name|fti
operator|->
name|fti_abort
operator|.
name|fta_diags
decl_stmt|;
name|dp
operator|=
name|d2
expr_stmt|;
comment|/* struct copy */
name|dp
operator|++
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|encode_DOCS_NBS__9__Datatype1
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|d9
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"error encoding Datatype1: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|free_DOCS_NBS__9__Datatype1
argument_list|(
name|d9
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|pe
operator|->
name|pe_context
operator|=
name|myvf
operator|->
name|vf_id
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|WATCHP
argument_list|(
name|DOCS_NBS__9__Datatype1
argument_list|,
name|pe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|de2fadu
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|)
operator|,
name|pe
operator|=
name|NULLPE
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|NOTOK
case|:
goto|goto
name|no_mem
goto|;
case|case
name|OK
case|:
default|default:
continue|continue;
case|case
name|DONE
case|:
break|break;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|dd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftp_reply
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"%s: %s"
argument_list|,
name|myfile
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
name|OK
condition|)
name|n
operator|=
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|DONE
case|:
return|return
name|DONE
return|;
case|case
name|OK
case|:
default|default:
if|if
condition|(
name|FDataEndRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
name|fta
argument_list|,
literal|"F-DATA-END.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
block|}
comment|/*
comment|*/
specifier|static
name|int
name|de2fadu
parameter_list|(
name|pe
parameter_list|,
name|concat
parameter_list|)
name|PE
name|pe
decl_stmt|;
name|int
name|concat
decl_stmt|;
block|{
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
specifier|static
name|int
name|ninfo
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|static
name|PE
name|info
index|[
name|NPDATA
index|]
decl_stmt|;
if|if
condition|(
name|pe
operator|==
name|NULLPE
condition|)
block|{
if|if
condition|(
name|concat
operator|&&
name|ninfo
operator|>
literal|0
operator|&&
name|FDataRequest
argument_list|(
name|ftamfd
argument_list|,
name|info
argument_list|,
name|ninfo
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
name|fta
argument_list|,
literal|"F-DATA.REQUEST"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ninfo
operator|>
literal|0
condition|)
name|pe_free
argument_list|(
name|info
index|[
operator|--
name|ninfo
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|concat
condition|)
block|{
name|int
name|flush
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|size
operator|+
operator|(
name|n
operator|=
name|ps_get_abs
argument_list|(
name|pe
argument_list|)
operator|+
name|MAGIC_OCTET2
operator|)
operator|>=
name|fadusize
operator|&&
name|ninfo
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"de2fadu flushing on %d FADUs, estimated size %d/%d"
argument_list|,
name|ninfo
argument_list|,
name|size
argument_list|,
name|fadusize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|flush
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|flush
operator|=
literal|0
expr_stmt|;
name|info
index|[
name|ninfo
operator|++
index|]
operator|=
name|pe
expr_stmt|;
name|size
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ninfo
operator|<
name|NPDATA
operator|&&
name|size
operator|<
name|fadusize
condition|)
block|{
if|if
condition|(
operator|!
name|flush
condition|)
return|return
name|OK
return|;
block|}
else|else
block|{
if|if
condition|(
name|FDataRequest
argument_list|(
name|ftamfd
argument_list|,
name|info
argument_list|,
name|ninfo
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
name|fta
argument_list|,
literal|"F-DATA.REQUEST"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ninfo
operator|>
literal|0
condition|)
name|pe_free
argument_list|(
name|info
index|[
operator|--
name|ninfo
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|FDataRequest
argument_list|(
name|ftamfd
argument_list|,
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
name|fta
argument_list|,
literal|"F-DATA.REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FWaitRequest
argument_list|(
name|ftamfd
argument_list|,
name|OK
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|fta
operator|->
name|fta_peer
operator|||
name|fta
operator|->
name|fta_action
operator|!=
name|FACTION_TRANS
operator|||
name|fta
operator|->
name|fta_ndiag
operator|<
literal|1
operator|||
name|fta
operator|->
name|fta_diags
index|[
literal|0
index|]
operator|.
name|ftd_type
operator|!=
name|DIAG_TRANS
operator|||
name|fta
operator|->
name|fta_diags
index|[
literal|0
index|]
operator|.
name|ftd_identifier
operator|!=
name|FS_PRO_TIMEOUT
condition|)
name|ftam_adios
argument_list|(
name|fta
argument_list|,
literal|"F-WAIT.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|fti
operator|->
name|fti_type
operator|==
name|FTI_CANCEL
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"F-CANCEL.INDICATION: %d"
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelResponse
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLPE
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.RESPONSE"
argument_list|)
expr_stmt|;
block|}
return|return
name|DONE
return|;
block|}
comment|/*
comment|*/
name|int
name|ftam_dataindication
parameter_list|(
name|px
parameter_list|)
specifier|register
name|struct
name|PSAPdata
modifier|*
name|px
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|effector
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|PE
name|pe
decl_stmt|,
modifier|*
name|pep
decl_stmt|;
name|struct
name|FTAMdiagnostic
name|diags
index|[
name|NFDIAG
index|]
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|diags
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|effector
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UBF
case|:
default|default:
break|break;
case|case
name|VFS_UTF
case|:
block|{
name|PElementID
name|id
decl_stmt|;
specifier|register
name|struct
name|type_DOCS_FTAM__1__Parameters
modifier|*
name|p1
init|=
operator|(
expr|struct
name|type_DOCS_FTAM__1__Parameters
operator|*
operator|)
name|myparam
decl_stmt|;
if|if
condition|(
name|p1
operator|&&
operator|(
name|p1
operator|->
name|optionals
operator|&
name|opt_DOCS_FTAM__1__Parameters_universal__class__number
operator|)
condition|)
name|id
operator|=
operator|(
name|PElementID
operator|)
name|p1
operator|->
name|universal__class__number
expr_stmt|;
else|else
name|id
operator|=
name|PE_DEFN_GFXS
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PE_DEFN_GFXS
case|:
if|if
condition|(
name|getenv
argument_list|(
literal|"HP-FTAM"
argument_list|)
condition|)
block|{
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* else fall... */
case|case
name|PE_DEFN_PRTS
case|:
case|case
name|PE_DEFN_VISS
case|:
name|effector
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PE_DEFN_T61S
case|:
case|case
name|PE_DEFN_VTXS
case|:
case|case
name|PE_DEFN_IA5S
case|:
case|case
name|PE_DEFN_GENS
case|:
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
block|}
for|for
control|(
name|pep
operator|=
name|px
operator|->
name|px_info
operator|,
name|i
operator|=
name|px
operator|->
name|px_ninfo
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|pep
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|pe
operator|=
operator|*
name|pep
operator|)
operator|==
name|NULLPE
condition|)
continue|continue;
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UBF
case|:
default|default:
if|if
condition|(
name|debug
condition|)
name|WATCHP
argument_list|(
name|DOCS_FTAM__3__Datatype1
argument_list|,
name|pe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|de2fd
argument_list|(
name|myfd
argument_list|,
name|pe
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|VFS_UTF
case|:
if|if
condition|(
name|debug
condition|)
name|WATCHP
argument_list|(
name|DOCS_FTAM__1__Datatype1
argument_list|,
name|pe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|de2fd
argument_list|(
name|myfd
argument_list|,
name|pe
argument_list|,
literal|1
argument_list|,
name|effector
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|!=
name|NOTOK
condition|)
block|{
name|nbytes
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOSPC
case|:
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCLSPACE
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EIO
case|:
case|case
name|ENXIO
case|:
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCLDEV
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_WRITE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
break|break;
block|}
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|++
expr_stmt|;
if|if
condition|(
name|FCancelRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_PERM
argument_list|,
name|NULLPE
argument_list|,
name|diags
argument_list|,
name|dp
operator|-
name|diags
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-CANCEL-REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fti
operator|->
name|fti_type
operator|==
name|FTI_CANCEL
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"F-CANCEL.RESPONSE: %d"
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
comment|/* ARGSUSED */
name|int
name|ftam_dataendindication
parameter_list|(
name|ftda
parameter_list|)
name|struct
name|FTAMdataend
modifier|*
name|ftda
decl_stmt|;
block|{
name|timer
argument_list|(
name|nbytes
argument_list|,
literal|"received"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
if|if
condition|(
name|ftda
operator|->
name|ftda_action
operator|==
name|FACTION_SUCCESS
condition|)
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*
comment|*/
name|int
name|ftam_cancelindication
parameter_list|(
name|ftcn
parameter_list|)
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
decl_stmt|;
block|{
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"F-CANCEL.INDICATION: %d"
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelResponse
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLPE
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-CANCEL.RESPONSE"
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
comment|/* ARGSUSED */
name|int
name|ftam_transendindication
parameter_list|(
name|ftre
parameter_list|)
name|struct
name|FTAMtransend
modifier|*
name|ftre
decl_stmt|;
block|{
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
name|FTransEndResponse
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLPE
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-TRANSFER-END.RESPONSE"
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
name|int
name|ftam_bulkendindication
parameter_list|(
name|ftg
parameter_list|)
name|struct
name|FTAMgroup
modifier|*
name|ftg
decl_stmt|;
block|{
name|struct
name|FTAMgroup
name|ftms
decl_stmt|;
name|struct
name|FTAMgroup
modifier|*
name|ftm
init|=
operator|&
name|ftms
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|ftam_selection
argument_list|(
name|ftg
argument_list|,
name|ftm
argument_list|)
expr_stmt|;
if|if
condition|(
name|myfd
operator|!=
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftp_reply
argument_list|()
expr_stmt|;
else|#
directive|else
name|unlock
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|myfd
operator|=
name|NOTOK
expr_stmt|;
block|}
if|if
condition|(
name|FBulkEndResponse
argument_list|(
name|ftamfd
argument_list|,
name|ftm
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-BULK-END.RESPONSE"
argument_list|)
expr_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
ifndef|#
directive|ifndef
name|NBBY
define|#
directive|define
name|NBBY
value|8
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TMS
name|timer
argument_list|(
argument|cc
argument_list|,
argument|action
argument_list|)
name|int
name|cc
decl_stmt|;
name|char
modifier|*
name|action
decl_stmt|;
block|{
name|long
name|ms
decl_stmt|;
name|float
name|bs
decl_stmt|;
name|struct
name|timeval
name|stop
decl_stmt|,
name|td
decl_stmt|;
specifier|static
name|struct
name|timeval
name|start
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|stop
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tvsub
argument_list|(
operator|&
name|td
argument_list|,
operator|&
name|stop
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|ms
operator|=
operator|(
name|td
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
expr_stmt|;
name|bs
operator|=
operator|(
operator|(
operator|(
name|float
operator|)
name|cc
operator|*
name|NBBY
operator|*
literal|1000
operator|)
operator|/
call|(
name|float
call|)
argument_list|(
name|ms
condition|?
name|ms
else|:
literal|1
argument_list|)
operator|)
operator|/
name|NBBY
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"%d bytes %s in %d.%02d seconds (%.2f Kbytes/s)"
argument_list|,
name|cc
argument_list|,
name|action
argument_list|,
name|td
operator|.
name|tv_sec
argument_list|,
name|td
operator|.
name|tv_usec
operator|/
literal|10000
argument_list|,
name|bs
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
specifier|static
name|tvsub
argument_list|(
name|tdiff
argument_list|,
name|t1
argument_list|,
name|t0
argument_list|)
specifier|register
expr|struct
name|timeval
operator|*
name|tdiff
operator|,
operator|*
name|t1
operator|,
operator|*
name|t0
expr_stmt|;
block|{
name|tdiff
operator|->
name|tv_sec
operator|=
name|t1
operator|->
name|tv_sec
operator|-
name|t0
operator|->
name|tv_sec
expr_stmt|;
name|tdiff
operator|->
name|tv_usec
operator|=
name|t1
operator|->
name|tv_usec
operator|-
name|t0
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|tdiff
operator|->
name|tv_usec
operator|<
literal|0
condition|)
name|tdiff
operator|->
name|tv_sec
operator|--
operator|,
name|tdiff
operator|->
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
else|#
directive|else
ifndef|#
directive|ifndef
name|HZ
define|#
directive|define
name|HZ
value|60
endif|#
directive|endif
name|long
name|times
parameter_list|()
function_decl|;
specifier|static
name|timer
argument_list|(
argument|cc
argument_list|,
argument|action
argument_list|)
name|int
name|cc
expr_stmt|;
name|char
modifier|*
name|action
decl_stmt|;
block|{
name|long
name|ms
decl_stmt|;
name|float
name|bs
decl_stmt|;
name|long
name|stop
decl_stmt|,
name|td
decl_stmt|,
name|secs
decl_stmt|,
name|msecs
decl_stmt|;
name|struct
name|tms
name|tm
decl_stmt|;
specifier|static
name|long
name|start
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|start
operator|=
name|times
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|stop
operator|=
name|times
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
name|td
operator|=
name|stop
operator|-
name|start
expr_stmt|;
name|secs
operator|=
name|td
operator|/
name|HZ
operator|,
name|msecs
operator|=
operator|(
name|td
operator|%
name|HZ
operator|)
operator|*
literal|1000
operator|/
name|HZ
expr_stmt|;
name|ms
operator|=
operator|(
name|secs
operator|*
literal|1000
operator|)
operator|+
name|msecs
expr_stmt|;
name|bs
operator|=
operator|(
operator|(
operator|(
name|float
operator|)
name|cc
operator|*
name|NBBY
operator|*
literal|1000
operator|)
operator|/
call|(
name|float
call|)
argument_list|(
name|ms
condition|?
name|ms
else|:
literal|1
argument_list|)
operator|)
operator|/
name|NBBY
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"%d bytes %s in %d.%02d seconds (%.2f Kbytes/s)"
argument_list|,
name|cc
argument_list|,
name|action
argument_list|,
name|secs
argument_list|,
name|msecs
operator|/
literal|10
argument_list|,
name|bs
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

