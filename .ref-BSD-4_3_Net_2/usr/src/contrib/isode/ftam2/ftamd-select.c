begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftamd-select.c - FTAM responder -- selection regime */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftamd-select.c,v 7.4 91/02/22 09:23:54 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftamd-select.c,v 7.4 91/02/22 09:23:54 mrose Interim $  *  *  * $Log:	ftamd-select.c,v $  * Revision 7.4  91/02/22  09:23:54  mrose  * Interim 6.8  *   * Revision 7.3  90/12/23  18:40:09  mrose  * update  *   * Revision 7.2  90/11/21  11:30:40  mrose  * sun  *   * Revision 7.1  90/07/01  21:03:20  mrose  * pepsy  *   * Revision 7.0  89/11/23  21:54:29  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"ftamsystem.h"
end_include

begin_define
define|#
directive|define
name|NUID
value|400
end_define

begin_define
define|#
directive|define
name|NGID
value|400
end_define

begin_define
define|#
directive|define
name|FA_CHATTR
define|\
value|(FA_FILENAME | FA_ACCOUNT)
end_define

begin_define
define|#
directive|define
name|FA_PERM_WRITE
value|(FA_PERM_INSERT | FA_PERM_REPLACE | FA_PERM_EXTEND \ 				| FA_PERM_ERASE)
end_define

begin_define
define|#
directive|define
name|FA_PERM_OWNER
value|FA_PERM_CHNGATTR
end_define

begin_define
define|#
directive|define
name|FA_PERM_PARENT
value|FA_PERM_DELETE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_function_decl
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwnam
argument_list|()
decl_stmt|,
modifier|*
name|getpwent
argument_list|()
decl_stmt|,
modifier|*
name|getpwuid
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mvfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PE
name|rdparam
init|=
name|NULLPE
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getfile
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_define
define|#
directive|define
name|E_OK
value|R_OK
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|getuser
argument_list|()
decl_stmt|,
modifier|*
name|getgroup
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_define
define|#
directive|define
name|EACCESS
value|access
end_define

begin_define
define|#
directive|define
name|rename
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
define|\
value|(unlink (f2), link (f1, f2) != NOTOK ? unlink (f1) : NOTOK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_define
define|#
directive|define
name|ftp_access
parameter_list|(
name|file
parameter_list|,
name|mode
parameter_list|)
value|ftp_exist (file)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|SELECTION REGIME */
end_comment

begin_function
name|int
name|ftam_selection
parameter_list|(
name|ftg
parameter_list|,
name|ftm
parameter_list|)
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
decl_stmt|,
decl|*
name|ftm
decl_stmt|;
end_function

begin_block
block|{
name|int
name|action
decl_stmt|,
name|state
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftm
argument_list|,
sizeof|sizeof
expr|*
name|ftm
argument_list|)
expr_stmt|;
name|ftm
operator|->
name|ftg_flags
operator|=
name|ftg
operator|->
name|ftg_flags
expr_stmt|;
name|statok
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|FSTATE_SUCCESS
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftm
operator|->
name|ftg_select
operator|.
name|ftse_diags
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_FILENAME
operator|)
operator|||
name|fa
operator|->
name|fa_nfile
operator|!=
literal|1
operator|||
operator|(
name|myfile
operator|=
name|getfile
argument_list|(
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
ifdef|#
directive|ifdef
name|BRIDGE
operator|||
name|ftp_access
argument_list|(
name|myfile
argument_list|,
name|E_OK
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
operator|||
name|stat
argument_list|(
name|myfile
argument_list|,
operator|&
name|myst
argument_list|)
operator|==
name|NOTOK
block|)
block|{
endif|#
directive|endif
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_FILENAME
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
block|}
else|else
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_select
goto|;
block|}
name|statok
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
switch|switch
condition|(
name|myst
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
case|case
name|S_IFDIR
case|:
break|break;
default|default:
if|if
condition|(
name|myst
operator|.
name|st_dev
operator|==
name|null_dev
operator|&&
name|myst
operator|.
name|st_ino
operator|==
name|null_ino
condition|)
block|{
name|myst
operator|.
name|st_mode
operator|&=
operator|~
name|S_IFMT
operator|,
name|myst
operator|.
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
break|break;
block|}
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_AVAIL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_select
goto|;
block|}
else|#
directive|else
comment|/* can't check a file you don't have */
endif|#
directive|endif
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_RDATTR
condition|)
name|ftse
operator|->
name|ftse_access
operator||=
name|FA_PERM_READATTR
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CHATTR
condition|)
name|ftse
operator|->
name|ftse_access
operator||=
name|FA_PERM_CHNGATTR
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DELETE
condition|)
name|ftse
operator|->
name|ftse_access
operator||=
name|FA_PERM_DELETE
expr_stmt|;
if|if
condition|(
name|chkaccess
argument_list|(
name|NOTOK
argument_list|,
name|ftse
operator|->
name|ftse_access
argument_list|,
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_select
goto|;
block|}
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|ftse
operator|->
name|ftse_account
operator|&&
name|strlen
argument_list|(
name|ftse
operator|->
name|ftse_account
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|mygid
operator|=
name|findgid
argument_list|(
name|ftse
operator|->
name|ftse_account
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_ACCOUNT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_select
goto|;
block|}
block|}
else|else
else|#
directive|else
comment|/* no account checking */
endif|#
directive|endif
name|mygid
operator|=
name|NOTOK
expr_stmt|;
name|done_select
label|:
empty_stmt|;
name|myaccess
operator|=
name|ftse
operator|->
name|ftse_access
expr_stmt|;
name|ftm
operator|->
name|ftg_select
operator|.
name|ftse_state
operator|=
name|state
expr_stmt|;
name|ftm
operator|->
name|ftg_select
operator|.
name|ftse_ndiag
operator|=
name|dp
operator|-
name|ftm
operator|->
name|ftg_select
operator|.
name|ftse_diags
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CREATE
condition|)
block|{
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftg
operator|->
name|ftg_create
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftce
operator|->
name|ftce_attrs
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftm
operator|->
name|ftg_create
operator|.
name|ftce_diags
decl_stmt|;
specifier|register
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_FILENAME
operator|)
operator|||
name|fa
operator|->
name|fa_nfile
operator|!=
literal|1
operator|||
operator|(
name|myfile
operator|=
name|getfile
argument_list|(
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_FILENAME
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|ftp_access
argument_list|(
name|myfile
argument_list|,
name|E_OK
argument_list|)
operator|!=
name|NOTOK
condition|)
else|#
directive|else
if|if
condition|(
name|stat
argument_list|(
name|myfile
argument_list|,
operator|&
name|myst
argument_list|)
operator|!=
name|NOTOK
condition|)
endif|#
directive|endif
name|statok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|statok
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
comment|/* Assume file type allow corrective action */
switch|switch
condition|(
name|myst
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
break|break;
case|case
name|S_IFDIR
case|:
switch|switch
condition|(
name|ftce
operator|->
name|ftce_override
condition|)
block|{
case|case
name|FOVER_WRITE
case|:
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_CRELOSE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
default|default:
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|myst
operator|.
name|st_dev
operator|==
name|null_dev
operator|&&
name|myst
operator|.
name|st_ino
operator|==
name|null_ino
condition|)
block|{
name|myst
operator|.
name|st_mode
operator|&=
operator|~
name|S_IFMT
operator|,
name|myst
operator|.
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
break|break;
block|}
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_AVAIL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|ftce
operator|->
name|ftce_override
condition|)
block|{
case|case
name|FOVER_FAIL
case|:
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_EXISTS
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
case|case
name|FOVER_SELECT
case|:
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_RDATTR
condition|)
name|ftce
operator|->
name|ftce_access
operator||=
name|FA_PERM_READATTR
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CHATTR
condition|)
name|ftce
operator|->
name|ftce_access
operator||=
name|FA_PERM_CHNGATTR
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DELETE
condition|)
name|ftce
operator|->
name|ftce_access
operator||=
name|FA_PERM_DELETE
expr_stmt|;
if|if
condition|(
name|chkaccess
argument_list|(
name|NOTOK
argument_list|,
name|ftce
operator|->
name|ftce_access
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_conctl
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
for|for
control|(
name|vf
operator|=
name|vfs
init|;
name|vf
operator|->
name|vf_entry
condition|;
name|vf
operator|++
control|)
if|if
condition|(
name|vf
operator|->
name|vf_oid
operator|&&
name|oid_cmp
argument_list|(
name|vf
operator|->
name|vf_oid
argument_list|,
name|fa
operator|->
name|fa_contents
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|vf
operator|->
name|vf_entry
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"invalid contents-type %s"
argument_list|,
name|sprintoid
argument_list|(
name|fa
operator|->
name|fa_contents
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_ATRVALUE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
block|}
if|if
condition|(
name|chkattrs
argument_list|(
name|fa
argument_list|,
name|fa
operator|->
name|fa_present
operator|&
operator|~
operator|(
name|FA_FILENAME
operator||
name|FA_CONTENTS
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
block|}
ifndef|#
directive|ifndef
name|BRIDGE
comment|/* no account checking */
if|if
condition|(
name|ftce
operator|->
name|ftce_account
operator|&&
name|strlen
argument_list|(
name|ftce
operator|->
name|ftce_account
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|mygid
operator|=
name|findgid
argument_list|(
name|ftce
operator|->
name|ftce_account
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_ACCOUNT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_create
goto|;
block|}
block|}
else|else
endif|#
directive|endif
name|mygid
operator|=
name|NOTOK
expr_stmt|;
name|done_create
label|:
empty_stmt|;
name|ftm
operator|->
name|ftg_create
operator|.
name|ftce_state
operator|=
name|state
expr_stmt|;
name|ftm
operator|->
name|ftg_create
operator|.
name|ftce_ndiag
operator|=
name|dp
operator|-
name|ftm
operator|->
name|ftg_create
operator|.
name|ftce_diags
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_RDATTR
condition|)
name|ftm
operator|->
name|ftg_readattr
operator|.
name|ftra_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CHATTR
condition|)
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftca
operator|->
name|ftca_attrs
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftm
operator|->
name|ftg_chngattr
operator|.
name|ftca_diags
decl_stmt|;
if|if
condition|(
name|chkattrs
argument_list|(
name|fa
argument_list|,
name|fa
operator|->
name|fa_present
argument_list|,
literal|0
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
name|action
operator|=
name|FACTION_PERM
expr_stmt|;
else|else
name|action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
name|ftm
operator|->
name|ftg_chngattr
operator|.
name|ftca_action
operator|=
name|action
expr_stmt|;
name|ftm
operator|->
name|ftg_chngattr
operator|.
name|ftca_ndiag
operator|=
name|dp
operator|-
name|ftm
operator|->
name|ftg_chngattr
operator|.
name|ftca_diags
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_OPEN
condition|)
block|{
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftm
operator|->
name|ftg_open
decl_stmt|;
name|ftop
operator|->
name|ftop_state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
name|ftop
operator|->
name|ftop_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
if|if
condition|(
name|ftop
operator|->
name|ftop_contents
operator|=
name|ftg
operator|->
name|ftg_open
operator|.
name|ftop_contents
condition|)
name|ftop
operator|->
name|ftop_parameter
operator|=
name|ftg
operator|->
name|ftg_open
operator|.
name|ftop_parameter
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftop
operator|->
name|ftop_conctl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CLOSE
condition|)
name|ftm
operator|->
name|ftg_close
operator|.
name|ftcl_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
name|ftm
operator|->
name|ftg_deselect
operator|.
name|ftde_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DELETE
condition|)
name|ftm
operator|->
name|ftg_delete
operator|.
name|ftxe_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftm
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|FSTATE_SUCCESS
condition|)
block|{
name|ftse
operator|->
name|ftse_action
operator|=
name|FACTION_PERM
expr_stmt|;
operator|*
name|fa
operator|=
name|ftg
operator|->
name|ftg_select
operator|.
name|ftse_attrs
expr_stmt|;
comment|/* struct copy */
name|ftm
operator|->
name|ftg_flags
operator|&=
operator|~
operator|(
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_OPEN
operator|)
expr_stmt|;
return|return;
block|}
name|ftse
operator|->
name|ftse_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|myfile
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CREATE
condition|)
block|{
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftg
operator|->
name|ftg_create
operator|.
name|ftce_attrs
decl_stmt|;
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftm
operator|->
name|ftg_create
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftce
operator|->
name|ftce_diags
operator|+
name|ftce
operator|->
name|ftce_ndiag
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|FSTATE_SUCCESS
condition|)
block|{
name|ftce
operator|->
name|ftce_action
operator|=
name|FACTION_PERM
expr_stmt|;
name|ftce
operator|->
name|ftce_attrs
operator|=
operator|*
name|fa
expr_stmt|;
comment|/* struct copy */
name|ftm
operator|->
name|ftg_flags
operator|&=
operator|~
operator|(
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_OPEN
operator|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ftg
operator|->
name|ftg_create
operator|.
name|ftce_override
condition|)
block|{
case|case
name|FOVER_SELECT
case|:
default|default:
if|if
condition|(
name|statok
condition|)
break|break;
goto|goto
name|do_create
goto|;
case|case
name|FOVER_DELETE
case|:
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|statok
operator|&&
name|ftp_delete
argument_list|(
name|myfile
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|statok
operator|&&
operator|(
operator|(
name|myst
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|?
name|unlink
argument_list|(
name|myfile
argument_list|)
else|:
name|rmdir
argument_list|(
name|myfile
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|bad_override
label|:
empty_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_CRELOSE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|ftp_error
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|bad_create
label|:
empty_stmt|;
name|ftce
operator|->
name|ftce_action
operator|=
name|FACTION_PERM
expr_stmt|;
name|ftce
operator|->
name|ftce_attrs
operator|=
operator|*
name|fa
expr_stmt|;
comment|/* struct copy */
name|ftce
operator|->
name|ftce_ndiag
operator|=
name|dp
operator|-
name|ftce
operator|->
name|ftce_diags
expr_stmt|;
name|ftce
operator|->
name|ftce_state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
name|ftm
operator|->
name|ftg_flags
operator|&=
operator|~
operator|(
name|FTG_RDATTR
operator||
name|FTG_CHATTR
operator||
name|FTG_OPEN
operator|)
expr_stmt|;
return|return;
block|}
comment|/* else fall */
case|case
name|FOVER_FAIL
case|:
name|statok
operator|=
literal|0
expr_stmt|;
name|do_create
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_CONTENTS
operator|)
operator|||
name|oid_cmp
argument_list|(
name|vfs
index|[
name|VFS_FDF
index|]
operator|.
name|vf_oid
argument_list|,
name|fa
operator|->
name|fa_contents
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|ftp_create
argument_list|(
name|myfile
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|myfd
operator|=
name|open
argument_list|(
name|myfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
endif|#
directive|endif
name|bad_open
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_CREATE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
goto|goto
name|bad_create
goto|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|ftp_mkdir
argument_list|(
name|myfile
argument_list|)
operator|==
name|NOTOK
condition|)
else|#
directive|else
if|if
condition|(
name|mkdir
argument_list|(
name|myfile
argument_list|,
literal|0755
argument_list|)
operator|==
name|NOTOK
condition|)
endif|#
directive|endif
goto|goto
name|bad_open
goto|;
if|if
condition|(
name|chngattrs
argument_list|(
name|fa
operator|->
name|fa_present
operator|&
operator|~
operator|(
name|FA_FILENAME
operator||
name|FA_CONTENTS
operator|)
argument_list|,
name|fa
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_create
goto|;
break|break;
case|case
name|FOVER_WRITE
case|:
if|if
condition|(
operator|!
name|statok
condition|)
goto|goto
name|do_create
goto|;
ifndef|#
directive|ifndef
name|BRIDGE
ifdef|#
directive|ifdef
name|SUNOS4
if|if
condition|(
name|myst
operator|.
name|st_size
operator|>
literal|0
operator|&&
name|truncate
argument_list|(
name|myfile
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_override
goto|;
else|#
directive|else
if|if
condition|(
name|myst
operator|.
name|st_size
operator|>
literal|0
operator|&&
name|truncate
argument_list|(
name|myfile
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_override
goto|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
name|ftce
operator|->
name|ftce_action
operator|=
name|FACTION_SUCCESS
expr_stmt|;
operator|(
name|void
operator|)
name|readattrs
argument_list|(
name|FA_FILENAME
operator||
name|FA_ACTIONS
operator||
name|FA_CONTENTS
argument_list|,
operator|&
name|ftce
operator|->
name|ftce_attrs
argument_list|,
name|fa
operator|->
name|fa_contents
argument_list|,
name|fa
operator|->
name|fa_parameter
argument_list|,
name|myfile
argument_list|,
operator|&
name|myst
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_ACTIONS
condition|)
name|ftce
operator|->
name|ftce_attrs
operator|.
name|fa_permitted
operator|&=
name|fa
operator|->
name|fa_permitted
expr_stmt|;
name|ftce
operator|->
name|ftce_ndiag
operator|=
name|dp
operator|-
name|ftce
operator|->
name|ftce_diags
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_RDATTR
operator|&&
operator|(
name|ftm
operator|->
name|ftg_readattr
operator|.
name|ftra_action
operator|==
name|FACTION_SUCCESS
operator|)
condition|)
block|{
specifier|register
name|struct
name|FTAMreadattr
modifier|*
name|ftra
init|=
operator|&
name|ftm
operator|->
name|ftg_readattr
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftra
operator|->
name|ftra_diags
operator|+
name|ftra
operator|->
name|ftra_ndiag
decl_stmt|;
if|if
condition|(
operator|!
name|statok
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
literal|0
condition|)
block|{
comment|/* assume OK */
else|#
directive|else
if|if
condition|(
operator|(
name|myfd
operator|!=
name|NOTOK
condition|?
name|fstat
argument_list|(
name|myfd
argument_list|,
operator|&
name|myst
argument_list|)
else|:
name|stat
argument_list|(
name|myfile
argument_list|,
operator|&
name|myst
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_MGT_READ
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
endif|#
directive|endif
name|bad_readattr
label|:
empty_stmt|;
name|ftra
operator|->
name|ftra_action
operator|=
name|FACTION_PERM
expr_stmt|;
name|ftra
operator|->
name|ftra_ndiag
operator|=
name|dp
operator|-
name|ftra
operator|->
name|ftra_diags
expr_stmt|;
return|return;
block|}
else|else
name|statok
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|readattrs
argument_list|(
name|ftg
operator|->
name|ftg_readattr
operator|.
name|ftra_attrnames
argument_list|,
operator|&
name|ftra
operator|->
name|ftra_attrs
argument_list|,
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_OPEN
condition|?
name|ftg
operator|->
name|ftg_open
operator|.
name|ftop_contents
else|:
name|NULLOID
argument_list|,
name|NULLPE
argument_list|,
name|myfile
argument_list|,
operator|&
name|myst
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_readattr
goto|;
name|ftra
operator|->
name|ftra_ndiag
operator|=
name|dp
operator|-
name|ftra
operator|->
name|ftra_diags
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CHATTR
operator|&&
operator|(
name|ftm
operator|->
name|ftg_chngattr
operator|.
name|ftca_action
operator|==
name|FACTION_SUCCESS
operator|)
condition|)
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftm
operator|->
name|ftg_chngattr
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
operator|.
name|ftca_attrs
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftca
operator|->
name|ftca_diags
operator|+
name|ftca
operator|->
name|ftca_ndiag
decl_stmt|;
if|if
condition|(
name|chngattrs
argument_list|(
name|fa
operator|->
name|fa_present
argument_list|,
name|fa
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftca
operator|->
name|ftca_action
operator|=
name|FACTION_PERM
expr_stmt|;
name|ftca
operator|->
name|ftca_ndiag
operator|=
name|dp
operator|-
name|ftca
operator|->
name|ftca_diags
expr_stmt|;
return|return;
block|}
name|ftca
operator|->
name|ftca_ndiag
operator|=
name|dp
operator|-
name|ftca
operator|->
name|ftca_diags
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_OPEN
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|int
name|mode
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftm
operator|->
name|ftg_open
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftop
operator|->
name|ftop_diags
operator|+
name|ftop
operator|->
name|ftop_ndiag
decl_stmt|;
name|ftop
operator|->
name|ftop_state
operator|=
name|FSTATE_SUCCESS
expr_stmt|;
if|if
condition|(
name|statok
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|myfile
argument_list|,
operator|&
name|myst
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|unavailable
label|:
empty_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_AVAIL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
block|}
else|else
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|ftop
operator|->
name|ftop_state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_open
goto|;
block|}
else|else
name|statok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ftop
operator|->
name|ftop_contents
operator|==
name|NULL
condition|)
block|{
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
decl_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CREATE
condition|)
block|{
name|fa
operator|=
operator|&
name|ftg
operator|->
name|ftg_create
operator|.
name|ftce_attrs
expr_stmt|;
name|ftop
operator|->
name|ftop_contents
operator|=
name|fa
operator|->
name|fa_contents
expr_stmt|;
name|ftop
operator|->
name|ftop_parameter
operator|=
name|fa
operator|->
name|fa_parameter
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"using contents-type from CREATE<%s, 0x%x>"
argument_list|,
name|oid2ode
argument_list|(
name|ftop
operator|->
name|ftop_contents
argument_list|)
argument_list|,
name|ftop
operator|->
name|ftop_parameter
argument_list|)
expr_stmt|;
goto|goto
name|find_myvfs
goto|;
block|}
if|if
condition|(
operator|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_RDATTR
operator|)
operator|&&
name|ftm
operator|->
name|ftg_readattr
operator|.
name|ftra_action
operator|==
name|FACTION_SUCCESS
operator|&&
operator|(
operator|(
name|fa
operator|=
operator|&
name|ftm
operator|->
name|ftg_readattr
operator|.
name|ftra_attrs
operator|)
operator|->
name|fa_present
operator|&
name|FA_CONTENTS
operator|)
condition|)
block|{
name|ftop
operator|->
name|ftop_contents
operator|=
name|fa
operator|->
name|fa_contents
expr_stmt|;
name|ftop
operator|->
name|ftop_parameter
operator|=
name|fa
operator|->
name|fa_parameter
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"using contents-type from READ-ATTRIBUTE<%s, 0x%x>"
argument_list|,
name|oid2ode
argument_list|(
name|ftop
operator|->
name|ftop_contents
argument_list|)
argument_list|,
name|ftop
operator|->
name|ftop_parameter
argument_list|)
expr_stmt|;
name|find_myvfs
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|myvf
operator|=
name|st2vfs
argument_list|(
name|myfd
argument_list|,
name|myfile
argument_list|,
operator|&
name|myst
argument_list|,
name|ftop
operator|->
name|ftop_contents
argument_list|,
name|ftamfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_ascertain
goto|;
if|if
condition|(
name|oid_cmp
argument_list|(
name|ftop
operator|->
name|ftop_contents
argument_list|,
name|myvf
operator|->
name|vf_oid
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|find_param
goto|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"wrong intuition; back to step one"
argument_list|)
expr_stmt|;
name|ftop
operator|->
name|ftop_contents
operator|=
name|NULLOID
expr_stmt|;
name|ftop
operator|->
name|ftop_parameter
operator|=
name|NULLPE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|myvf
operator|=
name|st2vfs
argument_list|(
name|myfd
argument_list|,
name|myfile
argument_list|,
operator|&
name|myst
argument_list|,
name|NULLOID
argument_list|,
name|ftamfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_ascertain
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"unable to ascertain contents-type"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|ftop
operator|->
name|ftop_state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_open
goto|;
block|}
name|ftop
operator|->
name|ftop_contents
operator|=
name|myvf
operator|->
name|vf_oid
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"using contents-type from st2vfs: %s"
argument_list|,
name|oid2ode
argument_list|(
name|ftop
operator|->
name|ftop_contents
argument_list|)
argument_list|)
expr_stmt|;
name|find_param
label|:
empty_stmt|;
if|if
condition|(
name|myvf
operator|->
name|vf_mandatory
operator|==
literal|0
operator|&&
name|ftop
operator|->
name|ftop_parameter
condition|)
name|ftop
operator|->
name|ftop_parameter
operator|=
name|NULLPE
expr_stmt|;
elseif|else
if|if
condition|(
name|ftop
operator|->
name|ftop_parameter
operator|==
name|NULL
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|rdparam
condition|)
name|pe_free
argument_list|(
name|rdparam
argument_list|)
operator|,
name|rdparam
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|enc_f
argument_list|(
name|myvf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
operator|&
name|rdparam
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|myvf
operator|->
name|vf_parameter
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to build parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdparam
condition|)
name|pe_free
argument_list|(
name|rdparam
argument_list|)
operator|,
name|rdparam
operator|=
name|NULLPE
expr_stmt|;
goto|goto
name|no_ascertain
goto|;
block|}
name|ftop
operator|->
name|ftop_parameter
operator|=
name|rdparam
expr_stmt|;
name|vpushstr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|vunknown
argument_list|(
name|ftop
operator|->
name|ftop_parameter
argument_list|)
expr_stmt|;
name|vpopstr
argument_list|()
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"generating parameter from vfs: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|myvf
operator|=
name|st2vfs
argument_list|(
name|myfd
argument_list|,
name|myfile
argument_list|,
operator|&
name|myst
argument_list|,
name|ftop
operator|->
name|ftop_contents
argument_list|,
name|ftamfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|bad_param
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_TYPINCON
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|ftop
operator|->
name|ftop_state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_open
goto|;
block|}
if|if
condition|(
name|oid_cmp
argument_list|(
name|ftop
operator|->
name|ftop_contents
argument_list|,
name|myvf
operator|->
name|vf_oid
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"simplifying document type"
argument_list|)
expr_stmt|;
name|ftop
operator|->
name|ftop_contents
operator|=
name|myvf
operator|->
name|vf_oid
expr_stmt|;
name|ftop
operator|->
name|ftop_parameter
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|myvf
operator|->
name|vf_mandatory
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|rdparam
condition|)
name|pe_free
argument_list|(
name|rdparam
argument_list|)
operator|,
name|rdparam
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|enc_f
argument_list|(
name|myvf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
operator|&
name|rdparam
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|myvf
operator|->
name|vf_parameter
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to build parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdparam
condition|)
name|pe_free
argument_list|(
name|rdparam
argument_list|)
operator|,
name|rdparam
operator|=
name|NULLPE
expr_stmt|;
goto|goto
name|no_ascertain
goto|;
block|}
name|ftop
operator|->
name|ftop_parameter
operator|=
name|rdparam
expr_stmt|;
name|vpushstr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|vunknown
argument_list|(
name|ftop
operator|->
name|ftop_parameter
argument_list|)
expr_stmt|;
name|vpopstr
argument_list|()
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"generating parameter from myvf: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ftop
operator|->
name|ftop_parameter
condition|)
block|{
if|if
condition|(
name|myvf
operator|->
name|vf_number
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"unexpected document type parameter"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
goto|goto
name|bad_param
goto|;
block|}
name|myparam
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dec_f
argument_list|(
name|myvf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
name|ftop
operator|->
name|ftop_parameter
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|myparam
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"unable to parse document type parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
goto|goto
name|bad_param
goto|;
block|}
if|if
condition|(
name|myvf
operator|->
name|vf_check
operator|&&
call|(
modifier|*
name|myvf
operator|->
name|vf_check
call|)
argument_list|(
name|myparam
argument_list|,
name|dp
operator|->
name|ftd_data
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_param
goto|;
block|}
elseif|else
if|if
condition|(
name|myvf
operator|->
name|vf_mandatory
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"mandatory document type parameter missing"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
goto|goto
name|bad_param
goto|;
block|}
name|mymode
operator|=
name|ftg
operator|->
name|ftg_open
operator|.
name|ftop_mode
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|mymode
operator|&
name|FA_PERM_WRITE
condition|)
name|mode
operator|=
operator|(
name|mymode
operator|&
name|FA_PERM_READ
operator|)
condition|?
name|O_RDWR
else|:
name|O_WRONLY
expr_stmt|;
else|else
name|mode
operator|=
name|O_RDONLY
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
switch|switch
condition|(
name|myst
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
if|if
condition|(
name|myfd
operator|==
name|NOTOK
operator|&&
operator|(
name|myfd
operator|=
name|open
argument_list|(
name|myfile
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
goto|goto
name|unavailable
goto|;
break|break;
case|case
name|S_IFDIR
case|:
if|if
condition|(
name|mode
operator|==
name|O_RDONLY
condition|)
break|break;
comment|/* else fall */
default|default:
goto|goto
name|unavailable
goto|;
block|}
endif|#
directive|endif
name|myconctl
operator|=
name|ftg
operator|->
name|ftg_open
operator|.
name|ftop_conctl
expr_stmt|;
comment|/* struct copy */
name|ftm
operator|->
name|ftg_open
operator|.
name|ftop_conctl
operator|=
name|myconctl
expr_stmt|;
comment|/*   .. */
name|mylockstyle
operator|=
name|ftg
operator|->
name|ftg_open
operator|.
name|ftop_locking
expr_stmt|;
if|if
condition|(
name|chkaccess
argument_list|(
name|myfd
argument_list|,
name|mymode
argument_list|,
operator|&
name|myconctl
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftop
operator|->
name|ftop_state
operator|=
name|FSTATE_FAILURE
expr_stmt|;
goto|goto
name|done_open
goto|;
block|}
name|done_open
label|:
empty_stmt|;
name|ftop
operator|->
name|ftop_ndiag
operator|=
name|dp
operator|-
name|ftop
operator|->
name|ftop_diags
expr_stmt|;
if|if
condition|(
name|ftop
operator|->
name|ftop_state
operator|!=
name|FSTATE_SUCCESS
condition|)
block|{
name|ftop
operator|->
name|ftop_action
operator|=
name|FACTION_PERM
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CLOSE
operator|&&
operator|(
name|ftm
operator|->
name|ftg_close
operator|.
name|ftcl_action
operator|==
name|FACTION_SUCCESS
operator|)
condition|)
block|{
if|if
condition|(
name|myfd
operator|!=
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftp_reply
argument_list|()
expr_stmt|;
else|#
directive|else
name|unlock
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|myfd
operator|=
name|NOTOK
expr_stmt|;
block|}
if|if
condition|(
name|myvf
operator|&&
name|myparam
condition|)
block|{
operator|(
name|void
operator|)
name|fre_obj
argument_list|(
name|myparam
argument_list|,
name|_ZDOCS_mod
operator|.
name|md_dtab
index|[
name|myvf
operator|->
name|vf_number
index|]
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|myparam
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftm
operator|->
name|ftg_deselect
decl_stmt|;
if|if
condition|(
name|ftde
operator|->
name|ftde_action
operator|==
name|FACTION_SUCCESS
condition|)
block|{
comment|/* anything to charge if (mygid != NOTOK)?  ha! */
block|}
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DELETE
condition|)
block|{
specifier|register
name|struct
name|FTAMdelete
modifier|*
name|ftxe
init|=
operator|&
name|ftm
operator|->
name|ftg_delete
decl_stmt|;
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|ftxe
operator|->
name|ftxe_diags
operator|+
name|ftxe
operator|->
name|ftxe_ndiag
decl_stmt|;
if|if
condition|(
name|ftxe
operator|->
name|ftxe_action
operator|==
name|FACTION_SUCCESS
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|ftp_delete
argument_list|(
name|myfile
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
name|statok
operator|&&
name|stat
argument_list|(
name|myfile
argument_list|,
operator|&
name|myst
argument_list|)
operator|==
name|NOTOK
condition|)
name|myst
operator|.
name|st_mode
operator|=
name|S_IFREG
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|myst
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|?
name|unlink
argument_list|(
name|myfile
argument_list|)
else|:
name|rmdir
argument_list|(
name|myfile
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
endif|#
directive|endif
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_DELETE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|ftp_error
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|ftxe
operator|->
name|ftxe_action
operator|=
name|FACTION_PERM
expr_stmt|;
name|ftxe
operator|->
name|ftxe_ndiag
operator|=
name|dp
operator|-
name|ftxe
operator|->
name|ftxe_diags
expr_stmt|;
return|return;
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"delete %s"
argument_list|,
name|myfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*
comment|*/
ifdef|#
directive|ifdef
name|BRIDGE
comment|/* ARGSUSED */
endif|#
directive|endif
specifier|static
name|int
name|chkaccess
parameter_list|(
name|fd
parameter_list|,
name|request
parameter_list|,
name|fc
parameter_list|,
name|diags
parameter_list|)
name|int
name|fd
decl_stmt|,
name|request
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
specifier|register
endif|#
directive|endif
name|struct
name|FTAMconcurrency
modifier|*
name|fc
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
modifier|*
name|diags
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
operator|*
name|diags
decl_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
operator|(
operator|(
name|request
operator|&
name|FA_PERM_READ
operator|)
operator|&&
name|EACCESS
argument_list|(
name|myfile
argument_list|,
name|R_OK
argument_list|)
operator|==
name|NOTOK
operator|)
operator|||
operator|(
operator|(
name|request
operator|&
name|FA_PERM_WRITE
operator|)
operator|&&
name|EACCESS
argument_list|(
name|myfile
argument_list|,
name|W_OK
argument_list|)
operator|==
name|NOTOK
operator|)
operator|||
operator|(
operator|(
name|request
operator|&
name|FA_PERM_OWNER
operator|)
operator|&&
operator|(
name|myuid
operator|!=
name|myst
operator|.
name|st_uid
operator|&&
name|myuid
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|no_access
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_ACCAVAIL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|request
operator|&
name|FA_PERM_PARENT
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|myfile
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|EACCESS
argument_list|(
operator|*
name|myfile
condition|?
name|myfile
else|:
literal|"/"
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
name|result
operator|=
name|EACCESS
argument_list|(
literal|"."
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
goto|goto
name|no_access
goto|;
block|}
else|#
directive|else
comment|/* already selected file and know it exists, FTP cannot tell us more */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
name|out
label|:
empty_stmt|;
if|if
condition|(
name|attrs
operator|&
name|FATTR_STORAGE
condition|)
block|{
if|if
condition|(
name|fd
operator|==
name|NOTOK
condition|)
block|{
name|mylock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|request
operator|&
name|FA_PERM_READATTR
operator|)
operator|&&
operator|(
name|fc
operator|->
name|fc_readattrlock
operator|&
name|FLOCK_RESTRICT
operator|)
operator|)
operator|||
operator|(
operator|(
name|request
operator|&
name|FA_PERM_CHNGATTR
operator|)
operator|&&
operator|(
name|fc
operator|->
name|fc_chngattrlock
operator|&
name|FLOCK_RESTRICT
operator|)
operator|)
operator|||
operator|(
operator|(
name|request
operator|&
name|FA_PERM_DELETE
operator|)
operator|&&
operator|(
name|fc
operator|->
name|fc_deletelock
operator|&
name|FLOCK_RESTRICT
operator|)
operator|)
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_SEL_CONSUPRT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SYS5
name|struct
name|flock
name|fs
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|request
operator|&
name|FA_PERM_WRITE
operator|)
operator|&&
operator|(
operator|(
name|fc
operator|->
name|fc_insertlock
operator|&
name|FLOCK_RESTRICT
operator|)
operator|||
operator|(
name|fc
operator|->
name|fc_replacelock
operator|&
name|FLOCK_RESTRICT
operator|)
operator|||
operator|(
name|fc
operator|->
name|fc_eraselock
operator|&
name|FLOCK_RESTRICT
operator|)
operator|||
operator|(
name|fc
operator|->
name|fc_extendlock
operator|&
name|FLOCK_RESTRICT
operator|)
operator|)
condition|)
block|{
name|mylock
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_concur
goto|;
else|#
directive|else
name|fs
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|fs
operator|.
name|l_whence
operator|=
name|L_SET
expr_stmt|;
name|fs
operator|.
name|l_start
operator|=
name|fs
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|fs
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_concur
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|request
operator|&
name|FA_PERM_READ
operator|)
operator|&&
operator|(
name|fc
operator|->
name|fc_readlock
operator|&
name|FLOCK_RESTRICT
operator|)
condition|)
block|{
name|mylock
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_SH
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
else|#
directive|else
name|fs
operator|.
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
name|fs
operator|.
name|l_whence
operator|=
name|L_SET
expr_stmt|;
name|fs
operator|.
name|l_start
operator|=
name|fs
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|fs
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
endif|#
directive|endif
name|bad_concur
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACC_CONAVAIL
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|mylock
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/*
comment|*/
specifier|static
name|int
name|chkattrs
parameter_list|(
name|fa
parameter_list|,
name|present
parameter_list|,
name|select
parameter_list|,
name|diags
parameter_list|)
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
decl_stmt|;
name|long
name|present
decl_stmt|;
name|int
name|select
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
modifier|*
name|diags
decl_stmt|;
block|{
name|int
name|id
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
operator|*
name|diags
decl_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
name|present
operator|&=
operator|~
name|FA_FUTURESIZE
expr_stmt|;
comment|/* be liberal in what you accept... */
if|if
condition|(
name|present
operator|&
operator|~
operator|(
name|FA_CHATTR
operator||
name|FA_RDATTR
operator|)
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|select
condition|?
name|FS_SEL_INITIAL
else|:
operator|(
name|present
operator|&
name|FA_RDATTR
operator|)
condition|?
name|FS_MGT_CHANGE
else|:
name|FS_MGT_EXIST
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
name|id
operator|=
name|select
condition|?
name|FS_SEL_ATRVALUE
else|:
name|FS_MGT_VALUE
expr_stmt|;
if|if
condition|(
name|present
operator|&
name|FA_FILENAME
condition|)
block|{
if|if
condition|(
name|fa
operator|->
name|fa_nfile
operator|!=
literal|1
operator|||
operator|(
name|file
operator|=
name|getfile
argument_list|(
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|id
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"00 bad filename"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mvfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
operator|(
name|present
operator|&
name|FA_ACCOUNT
operator|)
operator|&&
name|strlen
argument_list|(
name|fa
operator|->
name|fa_account
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|findgid
argument_list|(
name|fa
operator|->
name|fa_account
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|id
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"02 bad storage account"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|present
operator|&
name|FA_FILESIZE
operator|)
operator|&&
name|fa
operator|->
name|fa_filesize
operator|<
literal|0
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|id
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"13bad filesize"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/*
comment|*/
name|int
name|readattrs
parameter_list|(
name|attrnames
parameter_list|,
name|fa
parameter_list|,
name|proposed
parameter_list|,
name|parameter
parameter_list|,
name|file
parameter_list|,
name|st
parameter_list|,
name|diags
parameter_list|)
name|int
name|attrnames
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
decl_stmt|;
name|OID
name|proposed
decl_stmt|;
name|PE
name|parameter
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
modifier|*
name|diags
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
operator|*
name|diags
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|attrnames
expr_stmt|;
name|fa
operator|->
name|fa_novalue
operator|=
name|attrnames
operator|&
operator|(
name|FA_SECURITY
operator||
name|FA_PRIVATE
operator|)
expr_stmt|;
if|if
condition|(
name|attrnames
operator|&
name|FA_FILENAME
condition|)
block|{
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|file
expr_stmt|;
block|}
if|if
condition|(
name|attrnames
operator|&
name|FA_ACTIONS
condition|)
block|{
name|fa
operator|->
name|fa_permitted
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|EACCESS
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
name|NOTOK
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_permitted
operator||=
name|FA_PERM_READ
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|EACCESS
argument_list|(
name|file
argument_list|,
name|W_OK
argument_list|)
operator|!=
name|NOTOK
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_permitted
operator||=
name|FA_PERM_WRITE
expr_stmt|;
if|if
condition|(
name|fa
operator|->
name|fa_permitted
operator|&
operator|(
name|FA_PERM_READ
operator||
name|FA_PERM_WRITE
operator|)
condition|)
name|fa
operator|->
name|fa_permitted
operator||=
name|FA_PERM_TRAVERSAL
expr_stmt|;
name|fa
operator|->
name|fa_permitted
operator||=
name|FA_PERM_READATTR
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|myuid
operator|==
name|st
operator|->
name|st_uid
operator|||
name|myuid
operator|==
literal|0
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_permitted
operator||=
name|FA_PERM_OWNER
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|EACCESS
argument_list|(
operator|*
name|file
condition|?
name|file
else|:
literal|"/"
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
name|result
operator|=
name|EACCESS
argument_list|(
literal|"."
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NOTOK
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_permitted
operator||=
name|FA_PERM_PARENT
expr_stmt|;
block|}
if|if
condition|(
name|attrnames
operator|&
name|FA_CONTENTS
condition|)
block|{
specifier|register
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
if|if
condition|(
name|vf
operator|=
name|st2vfs
argument_list|(
name|myfd
argument_list|,
name|file
argument_list|,
name|st
argument_list|,
name|proposed
argument_list|,
name|ftamfd
argument_list|)
condition|)
block|{
name|fa
operator|->
name|fa_contents
operator|=
name|vf
operator|->
name|vf_oid
expr_stmt|;
if|if
condition|(
name|proposed
operator|&&
name|oid_cmp
argument_list|(
name|proposed
argument_list|,
name|vf
operator|->
name|vf_oid
argument_list|)
operator|==
literal|0
operator|&&
name|parameter
operator|&&
name|vf
operator|->
name|vf_number
operator|>=
literal|0
operator|&&
name|vf
operator|->
name|vf_check
condition|)
block|{
name|caddr_t
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dec_f
argument_list|(
name|vf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
name|parameter
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|p
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to parse document type parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|bad_param
goto|;
block|}
if|if
condition|(
call|(
modifier|*
name|vf
operator|->
name|vf_check
call|)
argument_list|(
name|p
argument_list|,
name|dp
operator|->
name|ftd_data
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"unacceptable document type parameter: %s"
argument_list|,
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
goto|goto
name|bad_param
goto|;
block|}
operator|(
name|void
operator|)
name|fre_obj
argument_list|(
name|p
argument_list|,
name|_ZDOCS_mod
operator|.
name|md_dtab
index|[
name|vf
operator|->
name|vf_number
index|]
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fa
operator|->
name|fa_parameter
operator|=
name|parameter
expr_stmt|;
block|}
name|bad_param
label|:
empty_stmt|;
if|if
condition|(
name|vf
operator|->
name|vf_parameter
condition|)
block|{
if|if
condition|(
name|rdparam
condition|)
name|pe_free
argument_list|(
name|rdparam
argument_list|)
operator|,
name|rdparam
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|enc_f
argument_list|(
name|vf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
operator|&
name|rdparam
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|vf
operator|->
name|vf_parameter
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to build parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdparam
condition|)
name|pe_free
argument_list|(
name|rdparam
argument_list|)
operator|,
name|rdparam
operator|=
name|NULLPE
expr_stmt|;
block|}
name|fa
operator|->
name|fa_parameter
operator|=
name|rdparam
expr_stmt|;
block|}
else|else
name|fa
operator|->
name|fa_parameter
operator|=
name|NULLPE
expr_stmt|;
block|}
else|else
name|fa
operator|->
name|fa_present
operator|&=
operator|~
name|FA_CONTENTS
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
comment|/* these values cannot be obtained from FTP */
if|if
condition|(
name|attrnames
operator|&
name|FA_ACCOUNT
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|attrnames
operator|&
name|FA_ACCOUNT
operator|)
operator|&&
operator|(
name|fa
operator|->
name|fa_account
operator|=
name|getgroup
argument_list|(
name|st
operator|->
name|st_gid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_present
operator|&=
operator|~
name|FA_ACCOUNT
expr_stmt|;
if|if
condition|(
name|attrnames
operator|&
name|FA_DATE_CREATE
condition|)
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|tm
operator|=
name|gmtime
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|st
operator|->
name|st_mtime
argument_list|)
condition|)
name|tm2ut
argument_list|(
name|tm
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_create
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_DATE_CREATE
expr_stmt|;
if|if
condition|(
name|attrnames
operator|&
name|FA_DATE_MODIFY
condition|)
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|tm
operator|=
name|gmtime
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|st
operator|->
name|st_mtime
argument_list|)
condition|)
name|tm2ut
argument_list|(
name|tm
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_modify
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_DATE_MODIFY
expr_stmt|;
if|if
condition|(
name|attrnames
operator|&
name|FA_DATE_READ
condition|)
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|tm
operator|=
name|gmtime
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|st
operator|->
name|st_atime
argument_list|)
condition|)
name|tm2ut
argument_list|(
name|tm
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_read
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_DATE_READ
expr_stmt|;
if|if
condition|(
name|attrnames
operator|&
name|FA_DATE_ATTR
condition|)
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|tm
operator|=
name|gmtime
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|st
operator|->
name|st_ctime
argument_list|)
condition|)
name|tm2ut
argument_list|(
name|tm
argument_list|,
operator|&
name|fa
operator|->
name|fa_date_attribute
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_DATE_ATTR
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|attrnames
operator|&
name|FA_ID_CREATE
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|attrnames
operator|&
name|FA_ID_CREATE
operator|)
operator|&&
operator|(
name|fa
operator|->
name|fa_id_create
operator|=
name|getuser
argument_list|(
name|st
operator|->
name|st_uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_ID_CREATE
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|attrnames
operator|&
name|FA_ID_MODIFY
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|attrnames
operator|&
name|FA_ID_MODIFY
operator|)
operator|&&
operator|(
operator|(
name|st
operator|->
name|st_mode
operator|&
literal|0022
operator|)
operator|||
operator|(
name|fa
operator|->
name|fa_id_modify
operator|=
name|getuser
argument_list|(
name|st
operator|->
name|st_uid
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_ID_MODIFY
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|attrnames
operator|&
name|FA_ID_READ
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|attrnames
operator|&
name|FA_ID_READ
operator|)
operator|&&
operator|(
operator|(
name|st
operator|->
name|st_mode
operator|&
literal|0044
operator|)
operator|||
operator|(
name|fa
operator|->
name|fa_id_read
operator|=
name|getuser
argument_list|(
name|st
operator|->
name|st_uid
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_ID_READ
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|attrnames
operator|&
name|FA_ID_ATTR
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|attrnames
operator|&
name|FA_ID_ATTR
operator|)
operator|&&
operator|(
operator|(
name|st
operator|->
name|st_mode
operator|&
literal|0022
operator|)
operator|||
operator|(
name|fa
operator|->
name|fa_id_attribute
operator|=
name|getuser
argument_list|(
name|st
operator|->
name|st_uid
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
endif|#
directive|endif
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_ID_ATTR
expr_stmt|;
if|if
condition|(
name|attrnames
operator|&
name|FA_AVAILABILITY
condition|)
name|fa
operator|->
name|fa_availability
operator|=
name|FA_AVAIL_IMMED
expr_stmt|;
if|if
condition|(
name|attrnames
operator|&
name|FA_FILESIZE
condition|)
ifdef|#
directive|ifdef
name|BRIDGE
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_FILESIZE
expr_stmt|;
else|#
directive|else
name|fa
operator|->
name|fa_filesize
operator|=
operator|(
name|int
operator|)
name|st
operator|->
name|st_size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|attrnames
operator|&
name|FA_FUTURESIZE
condition|)
name|fa
operator|->
name|fa_novalue
operator||=
name|FA_FUTURESIZE
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|OK
return|;
block|}
comment|/*
comment|*/
specifier|static
name|int
name|chngattrs
parameter_list|(
name|present
parameter_list|,
name|fa
parameter_list|,
name|diags
parameter_list|)
name|long
name|present
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
modifier|*
name|diags
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|int
name|gid
decl_stmt|,
name|result
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
operator|*
name|diags
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
name|struct
name|stat
name|n1
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE
name|statok
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|myfd
operator|!=
name|NOTOK
condition|?
name|fstat
argument_list|(
name|myfd
argument_list|,
operator|&
name|myst
argument_list|)
else|:
name|stat
argument_list|(
name|myfile
argument_list|,
operator|&
name|myst
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|bad_system
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
goto|goto
name|no_change
goto|;
block|}
name|statok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|myuid
operator|!=
name|myst
operator|.
name|st_uid
operator|&&
name|myuid
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad_system
goto|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
operator|(
name|present
operator|&
name|FA_ACCOUNT
operator|)
operator|&&
name|strlen
argument_list|(
name|fa
operator|->
name|fa_account
argument_list|)
operator|>
literal|1
condition|)
if|if
condition|(
operator|(
name|gid
operator|=
name|findgid
argument_list|(
name|fa
operator|->
name|fa_account
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS5
operator|(
name|void
operator|)
name|seteuid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|myfd
operator|!=
name|NOTOK
condition|?
name|fchown
argument_list|(
name|myfd
argument_list|,
operator|-
literal|1
argument_list|,
name|gid
argument_list|)
else|:
name|chown
argument_list|(
name|myfile
argument_list|,
operator|-
literal|1
argument_list|,
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|seteuid
argument_list|(
name|myuid
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|chgrp
argument_list|(
name|myfile
argument_list|,
name|gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"%s: %s"
argument_list|,
name|fa
operator|->
name|fa_account
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|no_change
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_MGT_CHANGE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|++
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|myst
operator|.
name|st_gid
operator|=
name|gid
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|present
operator|&
name|FA_FILENAME
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|ftp_rename
argument_list|(
name|myfile
argument_list|,
name|mvfile
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"%s: %s"
argument_list|,
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
argument_list|,
name|ftp_error
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|stat
argument_list|(
name|mvfile
argument_list|,
operator|&
name|n1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*file exists*/
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"file %s already exists"
argument_list|,
name|mvfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"File \"%s\" already exists"
argument_list|,
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_MGT_CHANGE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|++
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
elseif|else
if|if
condition|(
name|rename
argument_list|(
name|myfile
argument_list|,
name|mvfile
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
comment|/* on EXDEV could do gonzo 						   copy, but why bother? */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"%s: %s"
argument_list|,
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
goto|goto
name|no_change
goto|;
else|#
directive|else
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_MGT_CHANGE
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
name|dp
operator|++
expr_stmt|;
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|NOTOK
return|;
endif|#
directive|endif
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"rename %s to %s"
argument_list|,
name|myfile
argument_list|,
name|mvfile
argument_list|)
expr_stmt|;
name|myfile
operator|=
name|mvfile
expr_stmt|;
block|}
operator|*
name|diags
operator|=
name|dp
expr_stmt|;
return|return
name|OK
return|;
block|}
comment|/*
comment|*/
specifier|static
name|char
modifier|*
name|getfile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|buffer1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|buffer2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|bp
operator|=
operator|(
name|i
operator|++
operator|%
literal|2
operator|)
condition|?
name|buffer1
else|:
name|buffer2
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
switch|switch
condition|(
operator|*
name|file
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|>=
name|MAXPATHLEN
condition|)
goto|goto
name|trunc
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|pp
operator|=
name|file
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
name|NULL
condition|)
name|pp
operator|=
name|myhome
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|pp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
name|pp
operator|=
name|pw
operator|->
name|pw_dir
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|pp
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|cp
condition|?
name|strlen
argument_list|(
name|cp
argument_list|)
else|:
literal|0
operator|)
operator|>=
name|MAXPATHLEN
condition|)
goto|goto
name|trunc
goto|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s/%s"
argument_list|,
name|pp
argument_list|,
name|cp
condition|?
name|cp
operator|+
literal|1
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
name|myhomelen
operator|+
literal|1
operator|>=
name|MAXPATHLEN
condition|)
goto|goto
name|trunc
goto|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s/%s"
argument_list|,
name|myhome
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
name|compath
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|apollo
comment|/* always return RELATIVE pathnames */
if|if
condition|(
name|strncmp
argument_list|(
name|bp
argument_list|,
name|myhome
argument_list|,
name|myhomelen
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
switch|switch
condition|(
name|bp
index|[
name|myhomelen
operator|-
literal|1
index|]
condition|)
block|{
case|case
name|NULL
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|bp
operator|+=
name|myhomelen
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
return|return
name|bp
return|;
name|trunc
label|:
empty_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|NULLCP
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|bp
return|;
endif|#
directive|endif
block|}
comment|/*
comment|*/
ifndef|#
directive|ifndef
name|BRIDGE
comment|/* originally used algorithms similar to those in /bin/ls; Don Preuss of    Apollo suggested these algorithms as they work better with distributed    /etc/passwd and /etc/group files */
specifier|static
name|char
modifier|*
name|getuser
parameter_list|(
name|uid
parameter_list|)
name|int
name|uid
decl_stmt|;
block|{
specifier|static
name|struct
name|passwd
modifier|*
name|pw
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
operator|||
name|pw
operator|->
name|pw_uid
operator|!=
name|uid
condition|)
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
condition|?
name|pw
operator|->
name|pw_name
else|:
name|NULL
operator|)
return|;
block|}
comment|/*
comment|*/
specifier|static
name|char
modifier|*
name|getgroup
parameter_list|(
name|gid
parameter_list|)
name|int
name|gid
decl_stmt|;
block|{
specifier|register
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
specifier|static
name|int
name|my_gid
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|char
name|my_name
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|my_gid
operator|!=
name|gid
condition|)
block|{
if|if
condition|(
operator|(
name|gr
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|my_gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|my_name
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
return|return
name|my_name
return|;
block|}
comment|/*
comment|*/
name|int
name|findgid
parameter_list|(
name|group
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD42
name|int
name|gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
specifier|static
name|int
name|my_gid
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|char
name|my_name
index|[
name|NMAX
operator|+
literal|1
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|*
name|group
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|my_name
argument_list|,
name|group
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|gr
operator|=
name|getgrnam
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|BSD42
for|for
control|(
name|i
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gidset
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|gr
operator|->
name|gr_gid
operator|==
name|gidset
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|NOTOK
return|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|my_name
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|my_gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
block|}
return|return
name|my_gid
return|;
block|}
endif|#
directive|endif
comment|/*
comment|*/
ifndef|#
directive|ifndef
name|SYS5
ifndef|#
directive|ifndef
name|BRIDGE
specifier|static
name|int
name|EACCESS
parameter_list|(
name|file
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
operator|(
name|void
operator|)
name|seteuid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setruid
argument_list|(
name|myuid
argument_list|)
expr_stmt|;
name|result
operator|=
name|access
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setruid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|seteuid
argument_list|(
name|myuid
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
else|#
directive|else
comment|/*
comment|*/
specifier|static
name|int
name|chgrp
parameter_list|(
name|file
parameter_list|,
name|gid
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|gid
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|pid
decl_stmt|,
name|status
decl_stmt|;
name|char
name|group
index|[
literal|10
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|group
argument_list|,
literal|"%d"
argument_list|,
name|gid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
name|execl
argument_list|(
literal|"/bin/chgrp"
argument_list|,
literal|"chgrp"
argument_list|,
name|group
argument_list|,
name|file
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/chgrp"
argument_list|,
literal|"chgrp"
argument_list|,
name|group
argument_list|,
name|file
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/etc/chgrp"
argument_list|,
literal|"chgrp"
argument_list|,
name|group
argument_list|,
name|file
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
default|default:
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|NOTOK
operator|&&
name|pid
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
name|NOTOK
operator|&&
name|status
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
operator|||
name|st
operator|.
name|st_gid
operator|!=
name|gid
condition|)
block|{
name|i
operator|=
name|NOTOK
expr_stmt|;
name|errno
operator|=
name|EACCES
expr_stmt|;
block|}
else|else
name|status
operator|=
name|OK
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|==
name|NOTOK
condition|?
name|NOTOK
else|:
name|status
operator|)
return|;
block|}
block|}
comment|/*
comment|*/
specifier|static
name|int
name|mkdir
parameter_list|(
name|dir
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|pid
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|umask
argument_list|(
operator|~
name|mode
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|dir
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|dir
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/etc/mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|dir
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
default|default:
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|NOTOK
operator|&&
name|pid
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
name|NOTOK
operator|&&
name|status
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
operator|||
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|i
operator|=
name|NOTOK
expr_stmt|;
name|errno
operator|=
name|EACCES
expr_stmt|;
block|}
else|else
name|status
operator|=
name|OK
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|==
name|NOTOK
condition|?
name|NOTOK
else|:
name|status
operator|)
return|;
block|}
block|}
comment|/*
comment|*/
specifier|static
name|int
name|rmdir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|pid
decl_stmt|,
name|status
decl_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
name|execl
argument_list|(
literal|"/bin/rmdir"
argument_list|,
literal|"rmdir"
argument_list|,
name|dir
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/rmdir"
argument_list|,
literal|"rmdir"
argument_list|,
name|dir
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/etc/rmdir"
argument_list|,
literal|"rmdir"
argument_list|,
name|dir
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
default|default:
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|NOTOK
operator|&&
name|pid
operator|!=
name|i
condition|)
continue|continue;
if|if
condition|(
name|i
operator|!=
name|NOTOK
operator|&&
name|status
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|dir
argument_list|,
literal|0x00
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|i
operator|=
name|NOTOK
expr_stmt|;
name|errno
operator|=
name|EACCES
expr_stmt|;
block|}
else|else
name|status
operator|=
name|OK
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|==
name|NOTOK
condition|?
name|NOTOK
else|:
name|status
operator|)
return|;
block|}
block|}
comment|/*
comment|*/
specifier|static
name|int
name|truncate
parameter_list|(
name|file
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
comment|/* XXX: too much work to get right */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
comment|/* ARGSUSED */
name|int
name|ftruncate
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
comment|/* works only 'cause we're lucky */
name|int
name|fd
decl_stmt|,
name|length
decl_stmt|;
block|{
return|return
name|truncate
argument_list|(
name|myfile
argument_list|,
name|length
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/*
comment|DEBUG */
if|#
directive|if
name|defined
argument_list|(
name|FTAMDEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|BSD42
argument_list|)
include|#
directive|include
file|<syscall.h>
specifier|static
name|int
name|unlink
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unlink(\"%s\")? y, w, l: "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_unlink
argument_list|,
name|file
argument_list|)
return|;
block|}
specifier|static
name|int
name|rmdir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rmdir(\"%s\")? y, w, l: "
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_rmdir
argument_list|,
name|dir
argument_list|)
return|;
block|}
comment|/* VARARGS2 */
specifier|static
name|int
name|open
parameter_list|(
name|file
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"open(\"%s\",0x%x,0%o)? y, l: "
argument_list|,
name|file
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
condition|?
name|mode
else|:
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_open
argument_list|,
name|file
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
return|;
block|}
specifier|static
name|int
name|mkdir
parameter_list|(
name|dir
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mkdir(\"%s\",0%o)? y, w, l: "
argument_list|,
name|dir
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_mkdir
argument_list|,
name|dir
argument_list|,
name|mode
argument_list|)
return|;
block|}
specifier|static
name|int
name|chown
parameter_list|(
name|file
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chown(\"%s\",%d,%d)? y, w, l: "
argument_list|,
name|file
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_chown
argument_list|,
name|file
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
return|;
block|}
specifier|static
name|int
name|fchown
parameter_list|(
name|fd
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fchown(%d,%d,%d)? y, w, l: "
argument_list|,
name|fd
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_fchown
argument_list|,
name|fd
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
return|;
block|}
specifier|static
name|int
name|truncate
parameter_list|(
name|file
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"truncate(\"%s\",%d)? y, w, l: "
argument_list|,
name|file
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_truncate
argument_list|,
name|file
argument_list|,
name|length
argument_list|)
return|;
block|}
specifier|static
name|int
name|rename
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rename(\"%s\",\"%s\")? y, w, l: "
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_rename
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
return|;
block|}
specifier|static
name|int
name|flock
parameter_list|(
name|fd
parameter_list|,
name|operation
parameter_list|)
name|int
name|fd
decl_stmt|,
name|operation
decl_stmt|;
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|again
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"flock(%d,0x%x)? y, w, l: "
argument_list|,
name|fd
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'w'
case|:
return|return
name|OK
return|;
case|case
literal|'l'
case|:
return|return
name|NOTOK
return|;
default|default:
goto|goto
name|again
goto|;
block|}
block|}
return|return
name|syscall
argument_list|(
name|SYS_flock
argument_list|,
name|fd
argument_list|,
name|operation
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

