begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftam-put.c - interactive initiator FTAM -- "put" */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftam-put.c,v 7.9 91/02/22 09:23:48 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftam-put.c,v 7.9 91/02/22 09:23:48 mrose Interim $  *  *  * $Log:	ftam-put.c,v $  * Revision 7.9  91/02/22  09:23:48  mrose  * Interim 6.8  *   * Revision 7.8  90/12/23  18:40:03  mrose  * update  *   * Revision 7.7  90/11/21  11:30:33  mrose  * sun  *   * Revision 7.6  90/09/07  11:14:04  mrose  * update  *   * Revision 7.5  90/08/29  15:02:20  mrose  * fixes  *   * Revision 7.4  90/08/14  14:28:31  mrose  * T1  *   * Revision 7.3  90/07/01  21:03:16  mrose  * pepsy  *   * Revision 7.2  90/01/16  22:37:17  mrose  * very last time  *   * Revision 7.1  90/01/11  18:35:43  mrose  * real-sync  *   * Revision 7.0  89/11/23  21:54:24  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ftamuser.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_put
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|append
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|int
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
else|#
directive|else
name|int
name|sglobbed
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
modifier|*
name|gp
decl_stmt|,
modifier|*
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|freedst
init|=
name|NULL
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
name|append
operator|=
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"append"
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|NOTOK
return|;
else|#
directive|else
if|if
condition|(
name|getline
argument_list|(
literal|"source: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
name|dst
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BRIDGE
name|dst
operator|=
operator|*
name|vec
expr_stmt|;
else|#
directive|else
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|vec
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
continue|continue;
if|if
condition|(
operator|--
name|ap
operator|!=
name|vec
condition|)
name|dst
operator|=
operator|*
name|ap
operator|,
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
else|else
name|dst
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
operator|!
operator|(
name|src
operator|=
name|xglob
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|OK
return|;
name|sglobbed
operator|=
name|xglobbed
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"destination: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|blkfree
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
switch|switch
condition|(
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|dst
operator|=
operator|*
name|vec
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"too many destinations"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|dst
operator|&&
operator|!
operator|(
name|dst
operator|=
name|freedst
operator|=
name|xglob1val
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|interrupted
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|src
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|src
expr_stmt|;
break|break;
default|default:
name|dst
operator|=
operator|*
name|src
expr_stmt|;
break|break;
block|}
name|dst
operator|=
name|str2file
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ask_it
label|:
empty_stmt|;
if|if
condition|(
name|query
condition|)
switch|switch
condition|(
name|ask
argument_list|(
literal|"%s %s %s"
argument_list|,
name|append
condition|?
literal|"append"
else|:
literal|"put"
argument_list|,
operator|*
name|src
argument_list|,
name|dst
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
goto|goto
name|out
goto|;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
block|}
else|else
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|isdir
argument_list|(
name|dst
argument_list|,
name|NULLCP
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
break|break;
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
name|dst
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|src
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|src
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|buffer
expr_stmt|;
goto|goto
name|ask_it
goto|;
default|default:
break|break;
block|}
name|dst
operator|=
name|str2file
argument_list|(
name|dst
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|put
argument_list|(
operator|*
name|src
argument_list|,
name|dst
argument_list|,
name|append
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNKNOWN
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|rs_unknown
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|dst
condition|)
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
operator|(
name|bp
operator|=
name|str2file
argument_list|(
name|dst
argument_list|)
operator|)
operator|==
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
block|}
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|str2file
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rcwd
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s"
argument_list|,
name|str2file
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|rs_support
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|isdir
argument_list|(
name|str2file
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|gp
operator|=
name|src
init|;
operator|*
name|gp
operator|&&
operator|!
name|interrupted
condition|;
name|gp
operator|++
control|)
block|{
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|gp
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|gp
expr_stmt|;
break|break;
default|default:
name|dst
operator|=
operator|*
name|gp
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|str2file
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sglobbed
condition|)
block|{
if|if
condition|(
name|query
condition|)
switch|switch
condition|(
name|ask
argument_list|(
literal|"%s %s %s"
argument_list|,
name|append
condition|?
literal|"append"
else|:
literal|"put"
argument_list|,
operator|*
name|gp
argument_list|,
name|dst
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
continue|continue;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s %s %s"
argument_list|,
name|append
condition|?
literal|"append"
else|:
literal|"put"
argument_list|,
operator|*
name|gp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|put
argument_list|(
operator|*
name|gp
argument_list|,
name|dst
argument_list|,
name|append
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
condition|)
break|break;
block|}
name|out
label|:
empty_stmt|;
name|blkfree
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|freedst
condition|)
name|free
argument_list|(
name|freedst
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
else|#
directive|else
name|result
operator|=
name|put
argument_list|(
name|dst
argument_list|,
name|append
argument_list|)
expr_stmt|;
return|return
name|result
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_function
specifier|static
name|int
name|put
parameter_list|(
name|dst
parameter_list|,
name|append
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
else|#
directive|else
function|static int  put
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|append
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|append
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|bsize
decl_stmt|,
name|fd
decl_stmt|,
name|magic
decl_stmt|,
name|result
decl_stmt|,
name|size
decl_stmt|;
name|PE
name|pe
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
name|struct
name|stat
name|st
decl_stmt|;
endif|#
directive|endif
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
operator|(
name|fd
operator|=
name|dataconn
argument_list|(
name|dst
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|dst
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|src
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|src
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|src
argument_list|,
literal|"unable to fstat"
argument_list|)
expr_stmt|;
name|you_lose
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: not a regular file"
argument_list|,
name|src
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE
name|vf
operator|=
operator|&
name|vfs
index|[
name|tmode
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|vf
operator|=
name|st2vfs
argument_list|(
name|fd
argument_list|,
name|src
argument_list|,
operator|&
name|st
argument_list|,
name|vfs
index|[
name|tmode
index|]
operator|.
name|vf_oid
argument_list|,
name|ftamfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to determine document type for %s"
argument_list|,
name|src
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|vf
operator|==
operator|&
name|vfs
index|[
name|VFS_FDF
index|]
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s is a %s"
argument_list|,
name|src
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tmode
operator|!=
name|vf
operator|-
name|vfs
operator|&&
name|tmode
operator|!=
name|VFS_DEF
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"negotiating %s transfer"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_OCTS
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|you_lose
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
else|#
directive|else
goto|goto
name|you_lose
goto|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|vf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
if|if
condition|(
operator|(
name|magic
operator|=
name|fadusize
operator|-
name|MAGIC_OCTET1
operator|)
operator|<
literal|0
condition|)
name|magic
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VFS_UBF
case|:
default|default:
if|if
condition|(
operator|(
name|magic
operator|=
name|fadusize
operator|-
name|MAGIC_SINGLE
operator|)
operator|<
literal|0
condition|)
name|magic
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|magic
operator|>
literal|6
operator|*
literal|1024
condition|)
comment|/* FTAM profile T1 or A/111 limits  to 7K */
name|magic
operator|=
literal|6
operator|*
literal|1024
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|bsize
operator|=
name|BUFSIZ
operator|<<
literal|2
expr_stmt|;
name|size
operator|=
name|magic
operator|>=
name|bsize
condition|?
name|magic
else|:
name|bsize
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|bsize
condition|)
name|size
operator|-=
name|size
operator|%
name|bsize
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|MAXBSIZE
name|bsize
operator|=
name|BUFSIZ
expr_stmt|;
else|#
directive|else
name|bsize
operator|=
name|st
operator|.
name|st_blksize
operator|>
literal|0
condition|?
name|st
operator|.
name|st_blksize
else|:
name|BUFSIZ
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
operator|(
literal|1024
operator|<=
name|magic
operator|&&
name|magic
operator|<
name|bsize
operator|)
condition|?
name|magic
else|:
name|bsize
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|watch
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|printf
argument_list|(
literal|"Selecting FADU size of %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"based on blksize of %d and estimated integral FADU size of %d\n"
argument_list|,
name|bsize
argument_list|,
name|magic
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|pe
operator|->
name|pe_prim
operator|=
name|PEDalloc
argument_list|(
name|pe
operator|->
name|pe_len
operator|=
name|size
argument_list|)
operator|)
operator|==
name|NULLPED
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
goto|goto
name|you_lose
goto|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
name|result
operator|=
name|putaux
argument_list|(
name|dst
argument_list|,
name|append
argument_list|,
name|fd
argument_list|,
name|pe
argument_list|,
name|vf
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|putaux
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|append
argument_list|,
name|fd
argument_list|,
name|pe
argument_list|,
name|vf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_function
specifier|static
name|int
name|putaux
parameter_list|(
name|dst
parameter_list|,
name|append
parameter_list|,
name|fd
parameter_list|,
name|pe
parameter_list|,
name|vf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
else|#
directive|else
function|static int  putaux
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|append
parameter_list|,
name|fd
parameter_list|,
name|pe
parameter_list|,
name|vf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|append
decl_stmt|,
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|effector
decl_stmt|,
name|gd
decl_stmt|,
name|nc
decl_stmt|,
name|reason
decl_stmt|,
name|result
decl_stmt|;
name|PE
name|de
decl_stmt|,
name|param
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|FADUidentity
name|faduids
decl_stmt|;
specifier|register
name|struct
name|FADUidentity
modifier|*
name|faduid
init|=
operator|&
name|faduids
decl_stmt|;
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|pe
operator|->
name|pe_context
operator|=
name|vf
operator|->
name|vf_id
expr_stmt|;
name|param
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|vf
operator|->
name|vf_parameter
operator|&&
name|enc_f
argument_list|(
name|vf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
operator|&
name|param
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|vf
operator|->
name|vf_parameter
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to build document type parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|omode
operator|==
name|FOVER_SELECT
condition|)
name|append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|units
operator|&
name|FUNIT_LIMITED
condition|)
block|{
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CREATE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftg
operator|->
name|ftg_create
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftce
operator|->
name|ftce_attrs
decl_stmt|;
name|ftce
operator|->
name|ftce_override
operator|=
name|append
condition|?
name|FOVER_SELECT
else|:
name|omode
expr_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|dst
expr_stmt|;
name|fa
operator|->
name|fa_present
operator||=
name|FA_ACTIONS
expr_stmt|;
name|fa
operator|->
name|fa_permitted
operator|=
name|FA_PERM_READ
operator||
name|FA_PERM_REPLACE
operator||
name|FA_PERM_EXTEND
operator||
name|FA_PERM_READATTR
operator||
name|FA_PERM_CHNGATTR
operator||
name|FA_PERM_DELETE
operator||
name|FA_PERM_TRAV
expr_stmt|;
name|fa
operator|->
name|fa_present
operator||=
name|FA_CONTENTS
expr_stmt|;
name|fa
operator|->
name|fa_contents
operator|=
name|vf
operator|->
name|vf_oid
expr_stmt|;
name|fa
operator|->
name|fa_parameter
operator|=
name|param
expr_stmt|;
name|ftce
operator|->
name|ftce_access
operator|=
name|append
condition|?
name|FA_PERM_EXTEND
else|:
name|FA_PERM_REPLACE
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftce
operator|->
name|ftce_conctl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
if|if
condition|(
operator|!
name|append
operator|&&
name|omode
operator|==
name|FOVER_FAIL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"lack of limited-file-management conflicts with setting of \"override\" variable"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|dst
expr_stmt|;
name|ftse
operator|->
name|ftse_access
operator|=
name|append
condition|?
name|FA_PERM_EXTEND
else|:
name|FA_PERM_REPLACE
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
block|}
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_OPEN
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftg
operator|->
name|ftg_open
decl_stmt|;
name|ftop
operator|->
name|ftop_contents
operator|=
name|vf
operator|->
name|vf_oid
expr_stmt|;
name|ftop
operator|->
name|ftop_parameter
operator|=
name|param
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftop
operator|->
name|ftop_conctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|append
condition|)
block|{
name|ftop
operator|->
name|ftop_mode
operator|=
name|FA_PERM_EXTEND
expr_stmt|;
if|if
condition|(
name|concurrency
condition|)
name|ftop
operator|->
name|ftop_conctl
operator|.
name|fc_extendlock
operator|=
name|FLOCK_EXCLUSIVE
expr_stmt|;
block|}
else|else
block|{
name|ftop
operator|->
name|ftop_mode
operator|=
name|FA_PERM_REPLACE
expr_stmt|;
if|if
condition|(
name|concurrency
condition|)
name|ftop
operator|->
name|ftop_conctl
operator|.
name|fc_replacelock
operator|=
name|FLOCK_EXCLUSIVE
expr_stmt|;
block|}
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|result
operator|=
name|FBulkBeginRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
condition|)
name|pe_free
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-BULK-BEGIN.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftse
operator|->
name|ftse_diags
argument_list|,
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
literal|1
argument_list|,
name|ftse
operator|->
name|ftse_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
elseif|else
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CREATE
condition|)
block|{
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftg
operator|->
name|ftg_create
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftce
operator|->
name|ftce_diags
argument_list|,
name|ftce
operator|->
name|ftce_ndiag
argument_list|,
literal|1
argument_list|,
name|ftce
operator|->
name|ftce_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftce
operator|->
name|ftce_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_OPEN
condition|)
block|{
specifier|register
name|struct
name|FTAMopen
modifier|*
name|ftop
init|=
operator|&
name|ftg
operator|->
name|ftg_open
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftop
operator|->
name|ftop_diags
argument_list|,
name|ftop
operator|->
name|ftop_ndiag
argument_list|,
literal|1
argument_list|,
name|ftop
operator|->
name|ftop_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftop
operator|->
name|ftop_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
for|for
control|(
name|myvf
operator|=
name|vfs
init|;
name|myvf
operator|->
name|vf_entry
condition|;
name|myvf
operator|++
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|myvf
operator|->
name|vf_oid
argument_list|,
name|ftop
operator|->
name|ftop_contents
argument_list|)
operator|==
literal|0
condition|)
break|break;
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
name|pe
operator|->
name|pe_id
operator|=
call|(
name|PElementID
call|)
argument_list|(
operator|(
expr|struct
name|type_DOCS_FTAM__1__Parameters
operator|*
operator|)
name|myvf
operator|->
name|vf_parameter
argument_list|)
operator|->
name|universal__class__number
expr_stmt|;
comment|/* and fall... */
case|case
name|VFS_UBF
case|:
name|effector
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ftop
operator|->
name|ftop_parameter
operator|&&
name|myvf
operator|->
name|vf_number
operator|>=
literal|0
condition|)
block|{
name|caddr_t
name|parm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dec_f
argument_list|(
name|myvf
operator|->
name|vf_number
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
name|ftop
operator|->
name|ftop_parameter
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|parm
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to parse document type parameter: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
block|{
specifier|register
name|struct
name|type_DOCS_FTAM__1__Parameters
modifier|*
name|p1
init|=
operator|(
expr|struct
name|type_DOCS_FTAM__1__Parameters
operator|*
operator|)
name|parm
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|optionals
operator|&
name|opt_DOCS_FTAM__1__Parameters_universal__class__number
condition|)
name|pe
operator|->
name|pe_id
operator|=
operator|(
name|PElementID
operator|)
name|p1
operator|->
name|universal__class__number
expr_stmt|;
else|else
name|pe
operator|->
name|pe_id
operator|=
name|PE_DEFN_GFXS
expr_stmt|;
switch|switch
condition|(
name|pe
operator|->
name|pe_id
condition|)
block|{
case|case
name|PE_DEFN_GFXS
case|:
if|if
condition|(
name|getenv
argument_list|(
literal|"HP-FTAM"
argument_list|)
condition|)
block|{
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* else fall... */
case|case
name|PE_DEFN_PRTS
case|:
case|case
name|PE_DEFN_VISS
case|:
name|effector
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PE_DEFN_T61S
case|:
case|case
name|PE_DEFN_VTXS
case|:
case|case
name|PE_DEFN_IA5S
case|:
case|case
name|PE_DEFN_GENS
case|:
name|effector
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|VFS_UBF
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|parm
condition|)
operator|(
name|void
operator|)
name|fre_obj
argument_list|(
name|parm
argument_list|,
name|_ZDOCS_mod
operator|.
name|md_dtab
index|[
name|myvf
operator|->
name|vf_number
index|]
argument_list|,
operator|&
name|_ZDOCS_mod
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"effector=%d id=0x%x"
argument_list|,
name|effector
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|myvf
operator|!=
name|vf
operator|||
name|watch
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s transfer"
argument_list|,
name|myvf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
name|vf
operator|=
name|myvf
expr_stmt|;
block|}
break|break;
default|default:
name|vf
operator|=
operator|&
name|vfs
index|[
name|VFS_UBF
index|]
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"document type mismatch; assuming %s (%s)"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|,
name|vf
operator|->
name|vf_entry
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|myvf
operator|=
name|vf
expr_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
name|faduid
operator|->
name|fa_type
operator|=
name|FA_FIRSTLAST
expr_stmt|;
name|faduid
operator|->
name|fa_firstlast
operator|=
name|FA_FIRST
expr_stmt|;
if|if
condition|(
name|FReadWriteRequest
argument_list|(
name|ftamfd
argument_list|,
name|append
condition|?
name|FA_OPS_EXTEND
else|:
name|FA_OPS_REPLACE
argument_list|,
name|faduid
argument_list|,
name|myvf
operator|->
name|vf_context
argument_list|,
name|NOTOK
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-READWRITE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
switch|switch
condition|(
name|myvf
operator|-
name|vfs
condition|)
block|{
case|case
name|VFS_UTF
case|:
if|if
condition|(
operator|(
name|gd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|gd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gd
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|gd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|advise
argument_list|(
name|dst
argument_list|,
name|gd
operator|!=
name|NOTOK
condition|?
literal|"fdopen failed"
else|:
literal|"unable to dup"
argument_list|)
expr_stmt|;
else|#
directive|else
name|advise
argument_list|(
name|src
argument_list|,
name|gd
operator|!=
name|NOTOK
condition|?
literal|"fdopen failed on"
else|:
literal|"unable to dup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reason
operator|=
name|FS_ACC_LCL
expr_stmt|;
goto|goto
name|do_cancel
goto|;
block|}
break|break;
case|case
name|VFS_UBF
case|:
default|default:
name|fp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|cc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|timer
argument_list|(
name|cc
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
condition|)
name|marks
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|interrupted
condition|)
block|{
name|int
name|nfds
decl_stmt|;
name|fd_set
name|wfds
decl_stmt|;
name|nfds
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wfds
argument_list|)
expr_stmt|;
comment|/* interrupt causes EINTR */
if|if
condition|(
name|FSelectMask
argument_list|(
name|ftamfd
argument_list|,
operator|&
name|wfds
argument_list|,
operator|&
name|nfds
argument_list|,
name|fti
argument_list|)
operator|==
name|OK
condition|)
operator|(
name|void
operator|)
name|xselect
argument_list|(
name|nfds
argument_list|,
name|NULLFD
argument_list|,
operator|&
name|wfds
argument_list|,
name|NULLFD
argument_list|,
name|NOTOK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interrupted
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"cancelling transfer"
argument_list|)
expr_stmt|;
name|reason
operator|=
name|FS_GEN_INITIATOR
expr_stmt|;
name|errno
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|do_cancel
goto|;
block|}
for|for
control|(
name|ep
operator|=
operator|(
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pe
operator|->
name|pe_prim
operator|)
operator|+
name|size
operator|-
operator|(
name|fp
condition|?
literal|2
else|:
literal|0
operator|)
operator|,
name|nc
operator|=
literal|0
init|;
name|bp
operator|<
name|ep
condition|;
control|)
block|{
if|if
condition|(
name|fp
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|||
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
operator|)
operator|<
operator|(
name|ep
operator|-
name|bp
operator|-
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
block|{
else|#
directive|else
if|if
condition|(
name|fgets
argument_list|(
name|bp
argument_list|,
name|ep
operator|-
name|bp
operator|+
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
endif|#
directive|endif
name|n
operator|=
operator|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|)
condition|?
name|NOTOK
else|:
name|OK
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|bp
operator|+
name|strlen
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|effector
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|cp
operator|>
name|bp
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|cp
operator|==
literal|'\r'
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
operator|++
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|bp
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: losing! */
name|n
operator|=
name|cp
operator|-
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
ifndef|#
directive|ifndef
name|BRIDGE
operator|*
name|cp
operator|++
operator|=
literal|'\r'
expr_stmt|;
endif|#
directive|endif
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|n
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|bp
operator|=
name|cp
expr_stmt|;
name|nc
operator|++
expr_stmt|;
continue|continue;
block|}
name|n
operator|=
name|cp
operator|-
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BRIDGE
switch|switch
condition|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
condition|)
block|{
else|#
directive|else
switch|switch
condition|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
condition|)
block|{
endif|#
directive|endif
case|case
name|NOTOK
case|:
case|case
name|OK
case|:
break|break;
default|default:
name|bp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NOTOK
operator|||
operator|(
name|n
operator|=
name|bp
operator|-
operator|(
name|char
operator|*
operator|)
name|pe
operator|->
name|pe_prim
operator|)
operator|==
literal|0
condition|)
break|break;
name|pe
operator|->
name|pe_len
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
operator|!
name|effector
condition|)
block|{
if|if
condition|(
operator|(
name|de
operator|=
name|pe_cpy
argument_list|(
name|pe
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|reason
operator|=
name|FS_ACC_LCL
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|do_cancel
goto|;
block|}
block|}
else|else
name|de
operator|=
name|pe
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|fp
condition|)
block|{
name|WATCHP
argument_list|(
name|DOCS_FTAM__1__Datatype1
argument_list|,
name|de
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|WATCHP
argument_list|(
name|DOCS_FTAM__3__Datatype1
argument_list|,
name|de
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|de2fadu
argument_list|(
name|de
argument_list|,
name|pe
operator|!=
name|de
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
default|default:
if|if
condition|(
name|verbose
operator|||
name|hash
condition|)
name|cc
operator|+=
operator|(
name|n
operator|-
name|nc
operator|)
operator|,
name|nc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hash
condition|)
block|{
if|if
condition|(
name|hash
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%d\r"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|marks
operator|<
name|cc
condition|;
name|marks
operator|+=
name|BUFSIZ
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DONE
case|:
operator|(
name|void
operator|)
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|done_transfer
goto|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
name|timer
argument_list|(
name|cc
argument_list|,
literal|"sent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NOTOK
condition|)
block|{
name|struct
name|FTAMdiagnostic
name|diags
index|[
name|NFDIAG
index|]
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|advise
argument_list|(
name|dst
argument_list|,
literal|"error reading"
argument_list|)
expr_stmt|;
else|#
directive|else
name|advise
argument_list|(
name|src
argument_list|,
literal|"error reading"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reason
operator|=
name|FS_ACC_LCLDEV
expr_stmt|;
name|do_cancel
label|:
empty_stmt|;
name|dp
operator|=
name|diags
expr_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|reason
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_PERM
argument_list|,
name|NULLPE
argument_list|,
name|diags
argument_list|,
name|dp
operator|-
name|diags
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|fti
operator|->
name|fti_type
operator|==
name|FTI_CANCEL
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done_transfer
goto|;
block|}
if|if
condition|(
name|n
operator|==
name|OK
condition|)
name|n
operator|=
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FDataEndRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-DATA-END.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|FTransEndRequest
argument_list|(
name|ftamfd
argument_list|,
name|NULLPE
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-TRANSFER-END.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
switch|switch
condition|(
name|fti
operator|->
name|fti_type
condition|)
block|{
case|case
name|FTI_TRANSEND
case|:
block|{
specifier|register
name|struct
name|FTAMtransend
modifier|*
name|ftre
init|=
operator|&
name|fti
operator|->
name|fti_transend
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftre
operator|->
name|ftre_diags
argument_list|,
name|ftre
operator|->
name|ftre_ndiag
argument_list|,
literal|1
argument_list|,
name|ftre
operator|->
name|ftre_action
argument_list|)
expr_stmt|;
name|FTREFREE
argument_list|(
name|ftre
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FTI_CANCEL
case|:
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"data transfer canceled!"
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelResponse
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLPE
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.RESPONSE"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unexpected indication type=%d"
argument_list|,
name|fti
operator|->
name|fti_type
argument_list|)
expr_stmt|;
block|}
name|done_transfer
label|:
empty_stmt|;
name|ftg
operator|=
operator|&
name|ftgs
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CLOSE
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FBulkEndRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-BULK-END.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CLOSE
condition|)
block|{
specifier|register
name|struct
name|FTAMclose
modifier|*
name|ftcl
init|=
operator|&
name|ftg
operator|->
name|ftg_close
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftcl
operator|->
name|ftcl_diags
argument_list|,
name|ftcl
operator|->
name|ftcl_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcl
operator|->
name|ftcl_action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftde
operator|->
name|ftde_diags
argument_list|,
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
literal|1
argument_list|,
name|ftde
operator|->
name|ftde_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|)
expr_stmt|;
block|}
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/*
comment|*/
name|int
name|de2fadu
parameter_list|(
name|pe
parameter_list|,
name|concat
parameter_list|)
name|PE
name|pe
decl_stmt|;
name|int
name|concat
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|fti
operator|->
name|fti_abort
decl_stmt|;
specifier|static
name|int
name|ninfo
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|static
name|PE
name|info
index|[
name|NPDATA
index|]
decl_stmt|;
if|if
condition|(
name|pe
operator|==
name|NULLPE
condition|)
block|{
name|result
operator|=
name|OK
expr_stmt|;
if|if
condition|(
name|concat
operator|&&
name|ninfo
operator|>
literal|0
operator|&&
name|FDataRequest
argument_list|(
name|ftamfd
argument_list|,
name|info
argument_list|,
name|ninfo
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-DATA.REQUEST"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
while|while
condition|(
name|ninfo
operator|>
literal|0
condition|)
name|pe_free
argument_list|(
name|info
index|[
operator|--
name|ninfo
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|concat
condition|)
block|{
name|int
name|flush
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|size
operator|+
operator|(
name|n
operator|=
name|ps_get_abs
argument_list|(
name|pe
argument_list|)
operator|+
name|MAGIC_OCTET2
operator|)
operator|>=
name|fadusize
operator|&&
name|ninfo
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"de2fadu flushing on %d FADUs, estimated size %d/%d"
argument_list|,
name|ninfo
argument_list|,
name|size
argument_list|,
name|fadusize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|de2fadu
argument_list|(
name|NULLPE
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|OK
condition|)
return|return
name|result
return|;
name|flush
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|flush
operator|=
literal|0
expr_stmt|;
name|info
index|[
name|ninfo
operator|++
index|]
operator|=
name|pe
expr_stmt|;
name|size
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|ninfo
operator|<
name|NPDATA
operator|&&
name|size
operator|<
name|fadusize
condition|)
block|{
if|if
condition|(
operator|!
name|flush
condition|)
return|return
name|OK
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|FDataRequest
argument_list|(
name|ftamfd
argument_list|,
name|info
argument_list|,
name|ninfo
argument_list|,
name|fti
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-DATA.REQUEST"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ninfo
operator|>
literal|0
condition|)
name|pe_free
argument_list|(
name|info
index|[
operator|--
name|ninfo
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
return|return
name|result
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|FDataRequest
argument_list|(
name|ftamfd
argument_list|,
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-DATA.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|FWaitRequest
argument_list|(
name|ftamfd
argument_list|,
name|OK
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|fta
operator|->
name|fta_peer
operator|||
name|fta
operator|->
name|fta_action
operator|!=
name|FACTION_TRANS
operator|||
name|fta
operator|->
name|fta_ndiag
operator|<
literal|1
operator|||
name|fta
operator|->
name|fta_diags
index|[
literal|0
index|]
operator|.
name|ftd_type
operator|!=
name|DIAG_TRANS
operator|||
name|fta
operator|->
name|fta_diags
index|[
literal|0
index|]
operator|.
name|ftd_identifier
operator|!=
name|FS_PRO_TIMEOUT
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-WAIT.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
if|if
condition|(
name|fti
operator|->
name|fti_type
operator|==
name|FTI_CANCEL
condition|)
block|{
specifier|register
name|struct
name|FTAMcancel
modifier|*
name|ftcn
init|=
operator|&
name|fti
operator|->
name|fti_cancel
decl_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"data transfer cancelled!"
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftcn
operator|->
name|ftcn_diags
argument_list|,
name|ftcn
operator|->
name|ftcn_ndiag
argument_list|,
literal|1
argument_list|,
name|ftcn
operator|->
name|ftcn_action
argument_list|)
expr_stmt|;
name|FTCNFREE
argument_list|(
name|ftcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|FCancelResponse
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLPE
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
name|fta
argument_list|,
literal|"F-CANCEL.RESPONSE"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
return|return
name|DONE
return|;
block|}
end_block

end_unit

