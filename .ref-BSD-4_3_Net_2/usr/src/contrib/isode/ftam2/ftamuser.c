begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftamuser.c - FTAM initiator routines */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftamuser.c,v 7.8 91/02/22 09:24:11 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftamuser.c,v 7.8 91/02/22 09:24:11 mrose Interim $  *  *  * $Log:	ftamuser.c,v $  * Revision 7.8  91/02/22  09:24:11  mrose  * Interim 6.8  *   * Revision 7.7  91/01/13  12:27:10  mrose  * NBS  *   * Revision 7.6  90/12/23  18:40:19  mrose  * update  *   * Revision 7.5  90/11/21  11:30:54  mrose  * sun  *   * Revision 7.4  90/11/05  13:30:02  mrose  * nist  *   * Revision 7.3  90/09/07  11:14:08  mrose  * update  *   * Revision 7.2  90/07/01  21:03:37  mrose  * pepsy  *   * Revision 7.1  90/01/11  18:35:50  mrose  * real-sync  *   * Revision 7.0  89/11/23  21:54:42  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ftamuser.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HPUX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_define
define|#
directive|define
name|TMS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
name|int
name|ftamfd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|host
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|user
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|account
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|userdn
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|storename
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|bell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|concurrency
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_decl_stmt
name|int
name|globbing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|globbing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|marks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|omode
init|=
name|FOVER_WRITE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|query
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|runcom
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_decl_stmt
name|int
name|tmode
init|=
name|VFS_UTF
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|tmode
init|=
name|VFS_DEF
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|watch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|myuser
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myhome
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_decl_stmt
name|int
name|realstore
init|=
name|RFS_UNIX
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|realstore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|rs_unknown
init|=
literal|"type of remote realstore is unknown; use \"set realstore\""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rs_support
init|=
literal|"operation not supported on remote realstore"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rcwd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_decl_stmt
name|int
name|ftp_default
init|=
name|VFS_UTF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ftp_directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ftam_error
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|QOStype
name|myqos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|DISPATCH */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_decl_stmt
name|int
name|f_open
argument_list|()
decl_stmt|,
name|f_close
argument_list|()
decl_stmt|,
name|f_quit
argument_list|()
decl_stmt|,
name|f_status
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f_set
argument_list|()
decl_stmt|,
name|f_help
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f_lcd
argument_list|()
decl_stmt|,
name|f_cd
argument_list|()
decl_stmt|,
name|f_pwd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f_ls
argument_list|()
decl_stmt|,
name|f_fls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f_get
argument_list|()
decl_stmt|,
name|f_put
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f_mv
argument_list|()
decl_stmt|,
name|f_rm
argument_list|()
decl_stmt|,
name|f_chgrp
argument_list|()
decl_stmt|,
name|f_mkdir
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|f_echo
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|dispatch
name|dispatches
index|[]
init|=
block|{
literal|"append"
block|,
name|f_put
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_TRANSFER
block|,
name|FUNIT_WRITE
block|,
literal|"append to a file in the virtual filestore"
block|,
literal|"cd"
block|,
name|f_cd
block|,
name|DS_OPEN
block|,
literal|0
block|,
literal|0
block|,
literal|"change working directory on virtual filestore"
block|,
literal|"chgrp"
block|,
name|f_chgrp
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_ENHANCED
block|,
literal|"change group of a file"
block|,
literal|"close"
block|,
name|f_close
block|,
name|DS_OPEN
block|,
literal|0
block|,
literal|0
block|,
literal|"terminate association with virtual filestore"
block|,
literal|"dir"
block|,
name|f_ls
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_LIMITED
block|,
literal|"print long directory listing"
block|,
literal|"echo"
block|,
name|f_echo
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_LIMITED
block|,
literal|"echo globbed filenames"
block|,
literal|"fdir"
block|,
name|f_fls
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_LIMITED
block|,
literal|"print long directory listing to a file/program"
block|,
literal|"fls"
block|,
name|f_fls
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_LIMITED
block|,
literal|"print directory listing to a file/program"
block|,
literal|"get"
block|,
name|f_get
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_TRANSFER
block|,
name|FUNIT_READ
block|,
literal|"retrieve file"
block|,
literal|"help"
block|,
name|f_help
block|,
name|DS_NULL
block|,
literal|0
block|,
literal|0
block|,
literal|"print help information"
block|,
literal|"lcd"
block|,
name|f_lcd
block|,
name|DS_NULL
block|,
literal|0
block|,
literal|0
block|,
literal|"change working directory on local system"
block|,
literal|"ls"
block|,
name|f_ls
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_LIMITED
block|,
literal|"print directory listing"
block|,
literal|"mkdir"
block|,
name|f_mkdir
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_LIMITED
block|,
literal|"create directory"
block|,
literal|"mv"
block|,
name|f_mv
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_ENHANCED
block|,
literal|"rename file"
block|,
literal|"open"
block|,
name|f_open
block|,
name|DS_CLOSE
block|,
literal|0
block|,
literal|0
block|,
literal|"associate with virtual filestore"
block|,
literal|"put"
block|,
name|f_put
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_TRANSFER
block|,
name|FUNIT_WRITE
block|,
literal|"store file"
block|,
literal|"pwd"
block|,
name|f_pwd
block|,
name|DS_NULL
block|,
literal|0
block|,
literal|0
block|,
literal|"print working directories"
block|,
literal|"quit"
block|,
name|f_quit
block|,
name|DS_NULL
block|,
literal|0
block|,
literal|0
block|,
literal|"terminate association with virtual filestore and exit"
block|,
literal|"rm"
block|,
name|f_rm
block|,
name|DS_OPEN
operator||
name|DS_MODES
block|,
name|FCLASS_MANAGE
block|,
name|FUNIT_LIMITED
block|,
literal|"delete file"
block|,
literal|"set"
block|,
name|f_set
block|,
name|DS_NULL
block|,
literal|0
block|,
literal|0
block|,
literal|"display or change variables"
block|,
literal|"status"
block|,
name|f_status
block|,
name|DS_OPEN
block|,
literal|0
block|,
literal|0
block|,
literal|"show current status"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|struct
name|dispatch
modifier|*
name|getds
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|longest
decl_stmt|,
name|nmatches
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|p
operator|=
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
return|return
name|ds
return|;
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|fs
operator|=
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|nmatches
condition|)
block|{
case|case
literal|0
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown operation \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|1
case|:
return|return
name|fs
return|;
default|default:
for|for
control|(
name|ds
operator|=
name|dispatches
operator|,
name|p
operator|=
name|buffer
init|;
name|q
operator|=
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|longest
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|p
operator|!=
name|buffer
condition|?
literal|","
else|:
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ambiguous operation, it could be one of:%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|VARIABLES */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bool
index|[]
init|=
block|{
literal|"off"
block|,
literal|"on"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hmodes
index|[]
init|=
block|{
literal|"off"
block|,
literal|"on"
block|,
literal|"total"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|omodes
index|[]
init|=
block|{
literal|"fail"
block|,
literal|"select"
block|,
literal|"write"
block|,
literal|"delete"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmodes
index|[]
init|=
block|{
literal|"default"
block|,
literal|"binary"
block|,
literal|"text"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|realstores
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"unix"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xsaplevels
index|[]
init|=
block|{
literal|"none"
block|,
literal|"fatal"
block|,
literal|"exceptions"
block|,
literal|"notice"
block|,
literal|"pdus"
block|,
literal|"trace"
block|,
literal|"debug"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sversions
index|[]
init|=
block|{
literal|"default"
block|,
literal|"v1"
block|,
literal|"v2"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|var
block|{
name|char
modifier|*
name|v_name
decl_stmt|;
name|IP
name|v_value
decl_stmt|;
name|char
modifier|*
name|v_dname
decl_stmt|;
name|char
modifier|*
modifier|*
name|v_dvalue
decl_stmt|;
name|char
modifier|*
name|v_mask
decl_stmt|;
name|IFP
name|v_hook
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|var
modifier|*
name|getvar
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|set_realstore
argument_list|()
decl_stmt|,
name|set_trace
argument_list|()
decl_stmt|,
name|set_type
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|var
name|vars
index|[]
init|=
block|{
literal|"acsaplevel"
block|,
operator|&
name|_acsap_log
operator|.
name|ll_events
block|,
literal|"ACSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"acsapfile"
block|,
name|NULLIP
block|,
literal|"ACSAP trace file"
block|,
operator|&
name|_acsap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"addrlevel"
block|,
operator|&
name|_addr_log
operator|.
name|ll_events
block|,
literal|"address logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"addrfile"
block|,
name|NULLIP
block|,
literal|"address trace file"
block|,
operator|&
name|_addr_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"bell"
block|,
operator|&
name|bell
block|,
literal|"ring the bell when a command finishes"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"compatlevel"
block|,
operator|&
name|_compat_log
operator|.
name|ll_events
block|,
literal|"COMPAT logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"compatfile"
block|,
name|NULLIP
block|,
literal|"COMPAT trace file"
block|,
operator|&
name|_compat_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"concurrency"
block|,
operator|&
name|concurrency
block|,
comment|/* Olivier Dubois */
literal|"request concurrency control for transfers"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"debug"
block|,
operator|&
name|debug
block|,
literal|"debug FTAM"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"glob"
block|,
operator|&
name|globbing
block|,
literal|"expand metacharacters like the shell"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"hash"
block|,
operator|&
name|hash
block|,
literal|"hash mark printing"
block|,
name|hmodes
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"override"
block|,
operator|&
name|omode
block|,
literal|"creation override mode"
block|,
name|omodes
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"psaplevel"
block|,
operator|&
name|_psap_log
operator|.
name|ll_events
block|,
literal|"PSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"psapfile"
block|,
name|NULLIP
block|,
literal|"PSAP trace file"
block|,
operator|&
name|_psap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"psap2level"
block|,
operator|&
name|_psap2_log
operator|.
name|ll_events
block|,
literal|"PSAP2 logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"psap2file"
block|,
name|NULLIP
block|,
literal|"PSAP2 trace file"
block|,
operator|&
name|_psap2_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"qualifier"
block|,
name|NULLIP
block|,
literal|"service qualifier"
block|,
operator|&
name|storename
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"query"
block|,
operator|&
name|query
block|,
literal|"confirm operations on globbing"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"realstore"
block|,
operator|&
name|realstore
block|,
literal|"type of remote realstore"
block|,
name|realstores
block|,
name|NULLCP
block|,
name|set_realstore
block|,
literal|"ssaplevel"
block|,
operator|&
name|_ssap_log
operator|.
name|ll_events
block|,
literal|"SSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"ssapfile"
block|,
name|NULLIP
block|,
literal|"SSAP trace file"
block|,
operator|&
name|_ssap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"sversion"
block|,
operator|&
name|myqos
operator|.
name|qos_sversion
block|,
literal|"session version number"
block|,
name|sversions
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"trace"
block|,
operator|&
name|trace
block|,
literal|"trace FPDUs"
block|,
name|bool
block|,
name|NULLCP
block|,
name|set_trace
block|,
literal|"tracefile"
block|,
name|NULLIP
block|,
literal|"FTAM trace file"
block|,
operator|&
name|_ftam_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"tsaplevel"
block|,
operator|&
name|_tsap_log
operator|.
name|ll_events
block|,
literal|"TSAP logging"
block|,
name|xsaplevels
block|,
name|LLOG_MASK
block|,
name|NULLIFP
block|,
literal|"tsapfile"
block|,
name|NULLIP
block|,
literal|"TSAP trace file"
block|,
operator|&
name|_tsap_log
operator|.
name|ll_file
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"type"
block|,
operator|&
name|tmode
block|,
literal|"file transfer mode"
block|,
name|tmodes
block|,
name|NULLCP
block|,
name|set_type
block|,
literal|"verbose"
block|,
operator|&
name|verbose
block|,
literal|"verbose interaction"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"userdn"
block|,
name|NULLIP
block|,
literal|"DN to use when binding for AE-lookup"
block|,
operator|&
name|userdn
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
literal|"watch"
block|,
operator|&
name|watch
block|,
literal|"watch transfers"
block|,
name|bool
block|,
name|NULLCP
block|,
name|NULLIFP
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|varwidth1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|varwidth2
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
modifier|*
name|getval
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_set
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|value
decl_stmt|,
name|vflag
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
specifier|register
name|int
name|w
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|width
decl_stmt|,
name|lines
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|vars
init|;
name|u
operator|->
name|v_name
condition|;
name|u
operator|++
control|)
continue|continue;
name|width
operator|=
name|varwidth1
expr_stmt|;
if|if
condition|(
operator|(
name|columns
operator|=
name|ncols
argument_list|(
name|stdout
argument_list|)
operator|/
operator|(
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
operator|(
operator|(
name|u
operator|-
name|vars
operator|)
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
name|printf
argument_list|(
literal|"Variables:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|v
operator|=
name|vars
operator|+
name|j
operator|*
name|lines
operator|+
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|+
name|lines
operator|>=
name|u
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|w
operator|=
name|strlen
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
init|;
name|w
operator|<
name|width
condition|;
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|v
operator|=
name|vars
init|;
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|(
name|v
operator|=
name|getvar
argument_list|(
operator|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_value
operator|&&
operator|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"use %s of:"
argument_list|,
name|v
operator|->
name|v_mask
condition|?
literal|"any"
else|:
literal|"one"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|printf
argument_list|(
literal|"%s \"%s\""
argument_list|,
name|i
operator|++
condition|?
literal|","
else|:
literal|""
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
name|printf
argument_list|(
literal|";\n\tor  \"all\";\n\tor a hexadecimal number from 0 to 0x%x\n"
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|";\n\tor a number from 0 to %d\n"
argument_list|,
name|cp
operator|-
name|v
operator|->
name|v_dvalue
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"use any %s value\n"
argument_list|,
name|v
operator|->
name|v_value
condition|?
literal|"integer"
else|:
literal|"string"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_value
operator|==
name|NULLIP
condition|)
block|{
specifier|register
name|int
name|w
decl_stmt|;
if|if
condition|(
operator|*
name|v
operator|->
name|v_dvalue
condition|)
name|free
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
expr_stmt|;
operator|*
name|v
operator|->
name|v_dvalue
operator|=
name|strdup
argument_list|(
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
operator|+
literal|2
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|=
operator|*
name|vec
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
operator|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
name|i
operator|<<=
literal|1
expr_stmt|;
name|value
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|dp
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
name|sscanf
argument_list|(
name|dp
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|value
argument_list|)
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|dp
argument_list|)
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|j
operator|=
name|sscanf
argument_list|(
operator|*
name|vec
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
name|i
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|i
condition|)
goto|goto
name|out_of_range
goto|;
block|}
else|else
block|{
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
continue|continue;
if|if
condition|(
name|value
operator|>=
name|cp
operator|-
name|v
operator|->
name|v_dvalue
condition|)
block|{
name|out_of_range
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"value out of range \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
block|}
block|}
name|vflag
operator|=
name|verbose
expr_stmt|;
operator|*
name|v
operator|->
name|v_value
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|getval
argument_list|(
operator|*
name|vec
argument_list|,
name|v
operator|->
name|v_dvalue
argument_list|)
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"bad value \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
name|cp
operator|-
name|v
operator|->
name|v_dvalue
operator|)
operator|<=
literal|0
condition|)
continue|continue;
name|i
operator||=
literal|1
operator|<<
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|vflag
operator|=
name|verbose
expr_stmt|;
operator|*
name|v
operator|->
name|v_value
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|v
operator|->
name|v_dvalue
operator|&&
operator|(
name|cp
operator|=
name|getval
argument_list|(
operator|*
name|vec
argument_list|,
name|v
operator|->
name|v_dvalue
argument_list|)
operator|)
condition|)
block|{
name|vflag
operator|=
name|verbose
expr_stmt|;
operator|*
name|v
operator|->
name|v_value
operator|=
name|cp
operator|-
name|v
operator|->
name|v_dvalue
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_hook
condition|)
call|(
modifier|*
name|v
operator|->
name|v_hook
call|)
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printvar
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|v
operator|->
name|v_dvalue
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"bad value \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|printvar
argument_list|(
name|v
argument_list|)
specifier|register
expr|struct
name|var
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|runcom
condition|)
return|return;
name|printf
argument_list|(
literal|"%-*s = "
argument_list|,
name|varwidth1
argument_list|,
name|v
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_value
condition|)
block|{
name|i
operator|=
operator|*
name|v
operator|->
name|v_value
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_dvalue
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|v
operator|->
name|v_dvalue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|sprintb
argument_list|(
name|i
argument_list|,
name|v
operator|->
name|v_mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|<=
name|varwidth2
condition|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n%*s"
argument_list|,
name|buffer
argument_list|,
name|varwidth1
operator|+
name|varwidth2
operator|+
literal|3
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"0x%-*x"
argument_list|,
name|varwidth2
operator|-
literal|2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|v
operator|->
name|v_dvalue
condition|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|v
operator|->
name|v_dvalue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-*d"
argument_list|,
name|varwidth2
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|v
operator|->
name|v_dvalue
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"\"%s\""
argument_list|,
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|varwidth2
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    - %s\n"
argument_list|,
name|v
operator|->
name|v_dname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|set_realstore
parameter_list|(
name|v
parameter_list|)
name|struct
name|var
modifier|*
name|v
decl_stmt|;
block|{
name|char
modifier|*
name|vec
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|ftamfd
operator|!=
name|NOTOK
condition|)
block|{
name|vec
index|[
literal|0
index|]
operator|=
literal|"sd"
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
name|NULLCP
expr_stmt|;
operator|(
name|void
operator|)
name|f_cd
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|set_trace
parameter_list|(
name|v
parameter_list|)
name|struct
name|var
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
condition|)
return|return;
if|if
condition|(
name|FHookRequest
argument_list|(
name|ftamfd
argument_list|,
name|trace
condition|?
name|FTraceHook
else|:
name|NULLIFP
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-HOOK.REQUEST"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|set_type
parameter_list|(
name|v
parameter_list|)
name|struct
name|var
modifier|*
name|v
decl_stmt|;
block|{
specifier|register
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
condition|)
return|return;
if|if
condition|(
operator|(
name|vf
operator|=
operator|&
name|vfs
index|[
name|tmode
index|]
operator|)
operator|!=
operator|&
name|vfs
index|[
name|VFS_DEF
index|]
operator|&&
operator|(
name|vf
operator|->
name|vf_oid
operator|==
name|NULLOID
operator|||
operator|!
operator|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_OK
operator|)
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"negotiation prevents transfer of %ss"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|VFS_DEF
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|getval
parameter_list|(
name|name
parameter_list|,
name|choices
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|choices
decl_stmt|;
block|{
specifier|register
name|int
name|longest
decl_stmt|,
name|nmatches
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|fp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|choices
init|;
name|p
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
return|return
name|cp
return|;
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|nmatches
condition|)
block|{
case|case
literal|0
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown value \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|1
case|:
return|return
name|fp
return|;
default|default:
for|for
control|(
name|cp
operator|=
name|choices
operator|,
name|p
operator|=
name|buffer
init|;
name|q
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|longest
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|p
operator|!=
name|buffer
condition|?
literal|","
else|:
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ambiguous value, it could be one of:%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|var
modifier|*
name|getvar
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|longest
decl_stmt|,
name|nmatches
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|v
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
name|vars
init|;
name|p
operator|=
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
return|return
name|v
return|;
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|f
operator|=
name|v
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|nmatches
condition|)
block|{
case|case
literal|0
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown variable \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|1
case|:
return|return
name|f
return|;
default|default:
for|for
control|(
name|v
operator|=
name|vars
operator|,
name|p
operator|=
name|buffer
init|;
name|q
operator|=
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|longest
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|p
operator|!=
name|buffer
condition|?
literal|","
else|:
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ambiguous variable, it could be one of:%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|HELP */
end_comment

begin_decl_stmt
specifier|static
name|int
name|helpwidth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_help
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|w
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|width
decl_stmt|,
name|lines
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|,
modifier|*
name|es
decl_stmt|;
for|for
control|(
name|es
operator|=
name|dispatches
init|;
name|es
operator|->
name|ds_name
condition|;
name|es
operator|++
control|)
continue|continue;
name|width
operator|=
name|helpwidth
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|columns
operator|=
name|ncols
argument_list|(
name|stdout
argument_list|)
operator|/
operator|(
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
operator|(
operator|(
name|es
operator|-
name|dispatches
operator|)
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
name|printf
argument_list|(
literal|"Operations:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|ds
operator|=
name|dispatches
operator|+
name|j
operator|*
name|lines
operator|+
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|+
name|lines
operator|>=
name|es
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|w
operator|=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_name
argument_list|)
init|;
name|w
operator|<
name|width
condition|;
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nversion info:\t%s\n\t\t%s\n"
argument_list|,
name|ftamversion
argument_list|,
name|isodeversion
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
for|for
control|(
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
name|printf
argument_list|(
literal|"%-*s\t- %s\n"
argument_list|,
name|width
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|,
name|ds
operator|->
name|ds_help
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ds
operator|=
name|getds
argument_list|(
operator|*
name|vec
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%-*s\t- %s\n"
argument_list|,
name|width
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|,
name|ds
operator|->
name|ds_help
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|FTAM */
end_comment

begin_comment
comment|/* When going from an FADU to an SSDU via FTAM, we are talking about:  	octets = 2 +<number of FADUs>*12 +<size of each FADU>     in the best case, and probably  	octets = 3 +<number of FADUs>*16 +<size of each FADU>     on the average.       On a Berkeley UNIX system we typically see a blksize of 8192 octets.     When deciding how to read from the filesystem when writing to the network,    for the file's FADU size, we prefer to use the integral FADU size,    unless the blksize is larger.  This works well on LANs.  */
end_comment

begin_decl_stmt
name|OID
name|context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fqos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
init|=
name|FCLASS_TRANSFER
operator||
name|FCLASS_MANAGE
operator||
name|FCLASS_TM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|units
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|attrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fadusize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vfsmap
name|vfs
index|[]
init|=
block|{
comment|/* VFS_DEF */
literal|"default"
block|,
name|NULLOID
block|,
name|NULLCP
block|,
name|VF_NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULLIFP
block|,
literal|' '
block|,
name|VFS_XXX
block|,
literal|0
block|,
literal|0
block|,
name|NULLIFP
block|,
operator|-
literal|1
block|,
name|NULLCP
block|,
comment|/* VFS_UBF */
literal|"FTAM-3"
block|,
name|NULLOID
block|,
name|NULLCP
block|,
name|VF_WARN
block|,
literal|0
block|,
name|S_IFREG
block|,
name|binarypeek
block|,
literal|'b'
block|,
name|VFS_XXX
block|,
name|FA_ACC_UA
block|,
literal|1
block|,
name|binarycheck
block|,
name|_ZFTAM_3_ParametersDOCS
block|,
literal|"unstructured binary file"
block|,
comment|/* VFS_UTF */
literal|"FTAM-1"
block|,
name|NULLOID
block|,
name|NULLCP
block|,
name|VF_WARN
block|,
literal|0
block|,
name|S_IFREG
block|,
name|textpeek
block|,
literal|'t'
block|,
name|VFS_UBF
block|,
name|FA_ACC_UA
block|,
literal|1
block|,
name|textcheck
block|,
name|_ZFTAM_1_ParametersDOCS
block|,
literal|"unstructured text file"
block|,
comment|/* VFS_FDF */
literal|"NBS-9"
block|,
name|NULLOID
block|,
name|NULLCP
block|,
name|VF_NULL
block|,
literal|0
block|,
name|S_IFDIR
block|,
name|fdfpeek
block|,
literal|'d'
block|,
name|VFS_XXX
block|,
name|FA_ACC_UA
block|,
literal|0
block|,
name|NULLIFP
block|,
name|_ZNBS_9_ParametersDOCS
block|,
literal|"file directory file"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_decl_stmt
name|int
name|vfs_fdf
init|=
name|VFS_FDF
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|vfsmap
modifier|*
name|myvf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|void
name|ftam_advise
parameter_list|(
name|fta
parameter_list|,
name|event
parameter_list|)
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
block|{
if|if
condition|(
name|hash
operator|&&
name|marks
operator|>=
name|BUFSIZ
condition|)
block|{
name|marks
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fta
operator|->
name|fta_peer
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
argument_list|,
literal|"%s: peer aborted association, due to "
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: peer aborted association, due to "
argument_list|,
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fta
operator|->
name|fta_action
condition|)
block|{
case|case
name|FACTION_TRANS
case|:
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"transient-error"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"transient-error"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|FACTION_PERM
case|:
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"permanent-error"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"permanent-error"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"action result %d"
argument_list|,
name|fta
operator|->
name|fta_action
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"action result %d"
argument_list|,
name|fta
operator|->
name|fta_action
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifndef|#
directive|ifndef
name|BRIDGE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%s: failed\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|ftam_error
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: failed\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ftam_diag
argument_list|(
name|fta
operator|->
name|fta_diags
argument_list|,
name|fta
operator|->
name|fta_ndiag
argument_list|,
name|fta
operator|->
name|fta_peer
argument_list|,
name|FACTION_PERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|fta
operator|->
name|fta_action
operator|==
name|FACTION_PERM
condition|)
block|{
name|ftamfd
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|rcwd
condition|)
block|{
name|free
argument_list|(
name|rcwd
argument_list|)
expr_stmt|;
name|rcwd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|void
name|ftam_chrg
parameter_list|(
name|charges
parameter_list|)
specifier|register
name|struct
name|FTAMcharging
modifier|*
name|charges
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|fc_charge
modifier|*
name|fc
decl_stmt|;
name|cp
operator|=
literal|"charging information:\n    %s: %d %s\n"
expr_stmt|;
for|for
control|(
name|fc
operator|=
name|charges
operator|->
name|fc_charges
operator|,
name|i
operator|=
name|charges
operator|->
name|fc_ncharge
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|fc
operator|++
operator|,
name|i
operator|--
operator|,
name|cp
operator|=
literal|"    %s: %d %s\n"
control|)
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
argument_list|,
name|cp
argument_list|,
name|fc
operator|->
name|fc_resource
argument_list|,
name|fc
operator|->
name|fc_value
argument_list|,
name|fc
operator|->
name|fc_unit
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|ftam_error
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|cp
argument_list|,
name|fc
operator|->
name|fc_resource
argument_list|,
name|fc
operator|->
name|fc_value
argument_list|,
name|fc
operator|->
name|fc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entity
index|[]
init|=
block|{
literal|"unknown"
block|,
literal|"initiator"
block|,
literal|"initiator's FPM"
block|,
literal|"virtual filestore"
block|,
literal|"responder's FPM"
block|,
literal|"responder"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ftam_diag
parameter_list|(
name|diag
parameter_list|,
name|ndiag
parameter_list|,
name|peer
parameter_list|,
name|action
parameter_list|)
name|struct
name|FTAMdiagnostic
name|diag
index|[]
decl_stmt|;
name|int
name|ndiag
decl_stmt|;
name|int
name|peer
decl_stmt|,
name|action
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|didit
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|ftam_error
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|dp
operator|=
name|diag
operator|,
name|i
operator|=
name|ndiag
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|dp
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|ftd_identifier
operator|!=
name|FS_GEN_NOREASON
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|FErrString
argument_list|(
name|dp
operator|->
name|ftd_identifier
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|FErrString
argument_list|(
name|dp
operator|->
name|ftd_identifier
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|ftd_cc
operator|>
literal|0
condition|)
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|": %*.*s"
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|": %*.*s"
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|ftd_cc
operator|>
literal|0
condition|)
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%*.*s"
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%*.*s"
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_cc
argument_list|,
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|ftam_error
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|didit
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|ftd_type
condition|)
block|{
case|case
name|DIAG_INFORM
case|:
if|if
condition|(
name|action
operator|==
name|FACTION_SUCCESS
condition|)
break|break;
name|didit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"    type informative"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"    type informative"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DIAG_TRANS
case|:
name|didit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"    type transient"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"    type transient"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DIAG_PERM
case|:
if|if
condition|(
name|dp
operator|->
name|ftd_observer
operator|==
name|EREF_IFSU
condition|)
name|ftamfd
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|FACTION_SUCCESS
condition|)
break|break;
name|didit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"    type permanent"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"    type permanent"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|didit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"    type %d"
argument_list|,
name|dp
operator|->
name|ftd_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"    type %d"
argument_list|,
name|dp
operator|->
name|ftd_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
switch|switch
condition|(
name|dp
operator|->
name|ftd_observer
condition|)
block|{
case|case
name|EREF_IFSU
case|:
goto|goto
name|print_it
goto|;
case|case
name|EREF_IFPM
case|:
if|if
condition|(
name|peer
condition|)
goto|goto
name|print_it
goto|;
break|break;
case|case
name|EREF_RFSU
case|:
if|if
condition|(
name|peer
condition|)
break|break;
comment|/* else fall */
case|case
name|EREF_RFPM
case|:
name|print_it
label|:
empty_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%sobserver %s"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|entity
index|[
name|dp
operator|->
name|ftd_observer
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%sobserver %s"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|entity
index|[
name|dp
operator|->
name|ftd_observer
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%sobserver %d"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|dp
operator|->
name|ftd_observer
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%sobserver %d"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|dp
operator|->
name|ftd_observer
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
switch|switch
condition|(
name|dp
operator|->
name|ftd_source
condition|)
block|{
case|case
name|EREF_NONE
case|:
case|case
name|EREF_IFSU
case|:
break|break;
case|case
name|EREF_SERV
case|:
case|case
name|EREF_RFSU
case|:
if|if
condition|(
name|peer
condition|)
break|break;
comment|/* else fall */
case|case
name|EREF_IFPM
case|:
case|case
name|EREF_RFPM
case|:
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%ssource %s"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|entity
index|[
name|dp
operator|->
name|ftd_source
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%ssource %s"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|entity
index|[
name|dp
operator|->
name|ftd_source
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%ssource %d"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|dp
operator|->
name|ftd_source
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%ssource %d"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|dp
operator|->
name|ftd_source
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|dp
operator|->
name|ftd_delay
operator|!=
name|DIAG_NODELAY
condition|)
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
operator|+
name|strlen
argument_list|(
name|ftam_error
argument_list|)
argument_list|,
literal|"%ssuggested-delay %d"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|dp
operator|->
name|ftd_delay
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%ssuggested-delay %d"
argument_list|,
name|didit
operator|++
condition|?
literal|", "
else|:
literal|"    "
argument_list|,
name|dp
operator|->
name|ftd_delay
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|didit
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|ftam_error
index|[
literal|0
index|]
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|ftam_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|MISCELLANY */
end_comment

begin_macro
name|rcinit
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|BRIDGE
specifier|register
name|int
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|v
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|isodocument
modifier|*
name|id
decl_stmt|;
specifier|register
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
operator|(
name|myhome
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myhome
operator|=
literal|"."
expr_stmt|;
comment|/* could do passwd search... */
if|if
condition|(
operator|(
name|myuser
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|myuser
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|vf
operator|=
name|vfs
operator|+
literal|1
init|;
name|vf
operator|->
name|vf_entry
condition|;
name|vf
operator|++
control|)
comment|/* skip "default" entry */
if|if
condition|(
name|id
operator|=
name|getisodocumentbyentry
argument_list|(
name|vf
operator|->
name|vf_entry
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|vf
operator|->
name|vf_oid
operator|=
name|oid_cpy
argument_list|(
name|id
operator|->
name|id_type
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_WARN
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"warning: local realstore has no support for %ss (%s)"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|,
name|vf
operator|->
name|vf_entry
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|myqos
argument_list|,
sizeof|sizeof
name|myqos
argument_list|)
expr_stmt|;
name|myqos
operator|.
name|qos_sversion
operator|=
literal|2
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
for|for
control|(
name|ds
operator|=
name|dispatches
operator|,
name|helpwidth
operator|=
literal|0
init|;
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_name
argument_list|)
operator|)
operator|>
name|helpwidth
condition|)
name|helpwidth
operator|=
name|w
expr_stmt|;
name|userdn
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|vars
operator|,
name|varwidth1
operator|=
literal|0
init|;
name|v
operator|->
name|v_name
condition|;
name|v
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
operator|)
operator|>
name|varwidth1
condition|)
name|varwidth1
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|v_value
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|v
operator|->
name|v_dvalue
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|v_mask
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|w
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
name|w
operator|<<=
literal|1
expr_stmt|;
name|w
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|sprintb
argument_list|(
name|w
argument_list|,
name|v
operator|->
name|v_mask
argument_list|)
argument_list|)
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
endif|#
directive|endif
block|}
else|else
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|v
operator|->
name|v_dvalue
condition|)
block|{
operator|*
name|v
operator|->
name|v_dvalue
operator|=
name|strdup
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
operator|*
name|v
operator|->
name|v_dvalue
argument_list|)
operator|+
literal|2
operator|)
operator|>
name|varwidth2
condition|)
name|varwidth2
operator|=
name|w
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|TIOCGWINSZ
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ncols
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|int
name|i
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
operator|!=
name|NOTOK
operator|&&
operator|(
name|i
operator|=
name|ws
operator|.
name|ws_col
operator|)
operator|>
literal|0
condition|)
return|return
name|i
return|;
endif|#
directive|endif
return|return
literal|80
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NBBY
end_ifndef

begin_define
define|#
directive|define
name|NBBY
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TMS
end_ifndef

begin_macro
name|timer
argument_list|(
argument|cc
argument_list|,
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|ms
decl_stmt|;
name|float
name|bs
decl_stmt|;
name|struct
name|timeval
name|stop
decl_stmt|,
name|td
decl_stmt|;
specifier|static
name|struct
name|timeval
name|start
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|stop
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tvsub
argument_list|(
operator|&
name|td
argument_list|,
operator|&
name|stop
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|ms
operator|=
operator|(
name|td
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
expr_stmt|;
name|bs
operator|=
operator|(
operator|(
operator|(
name|float
operator|)
name|cc
operator|*
name|NBBY
operator|*
literal|1000
operator|)
operator|/
call|(
name|float
call|)
argument_list|(
name|ms
condition|?
name|ms
else|:
literal|1
argument_list|)
operator|)
operator|/
name|NBBY
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%d bytes %s in %d.%02d seconds (%.2f Kbytes/s)"
argument_list|,
name|cc
argument_list|,
name|action
argument_list|,
name|td
operator|.
name|tv_sec
argument_list|,
name|td
operator|.
name|tv_usec
operator|/
literal|10000
argument_list|,
name|bs
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|tvsub
argument_list|(
name|tdiff
argument_list|,
name|t1
argument_list|,
name|t0
argument_list|)
specifier|register
expr|struct
name|timeval
operator|*
name|tdiff
operator|,
operator|*
name|t1
operator|,
operator|*
name|t0
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|tdiff
operator|->
name|tv_sec
operator|=
name|t1
operator|->
name|tv_sec
operator|-
name|t0
operator|->
name|tv_sec
expr_stmt|;
name|tdiff
operator|->
name|tv_usec
operator|=
name|t1
operator|->
name|tv_usec
operator|-
name|t0
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|tdiff
operator|->
name|tv_usec
operator|<
literal|0
condition|)
name|tdiff
operator|->
name|tv_sec
operator|--
operator|,
name|tdiff
operator|->
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|HZ
end_ifndef

begin_define
define|#
directive|define
name|HZ
value|60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|long
name|times
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|timer
argument_list|(
argument|cc
argument_list|,
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|ms
decl_stmt|;
name|float
name|bs
decl_stmt|;
name|long
name|stop
decl_stmt|,
name|td
decl_stmt|,
name|secs
decl_stmt|,
name|msecs
decl_stmt|;
name|struct
name|tms
name|tm
decl_stmt|;
specifier|static
name|long
name|start
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|start
operator|=
name|times
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|stop
operator|=
name|times
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
name|td
operator|=
name|stop
operator|-
name|start
expr_stmt|;
name|secs
operator|=
name|td
operator|/
name|HZ
operator|,
name|msecs
operator|=
operator|(
name|td
operator|%
name|HZ
operator|)
operator|*
literal|1000
operator|/
name|HZ
expr_stmt|;
name|ms
operator|=
operator|(
name|secs
operator|*
literal|1000
operator|)
operator|+
name|msecs
expr_stmt|;
name|bs
operator|=
operator|(
operator|(
operator|(
name|float
operator|)
name|cc
operator|*
name|NBBY
operator|*
literal|1000
operator|)
operator|/
call|(
name|float
call|)
argument_list|(
name|ms
condition|?
name|ms
else|:
literal|1
argument_list|)
operator|)
operator|/
name|NBBY
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%d bytes %s in %d.%02d seconds (%.2f Kbytes/s)"
argument_list|,
name|cc
argument_list|,
name|action
argument_list|,
name|secs
argument_list|,
name|msecs
operator|/
literal|10
argument_list|,
name|bs
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_comment
comment|/* FTP TYPE Function */
end_comment

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_macro
name|f_type
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|TYPE_A
case|:
name|tmode
operator|=
name|VFS_UTF
expr_stmt|;
return|return
name|OK
return|;
case|case
name|TYPE_I
case|:
case|case
name|TYPE_L
case|:
name|tmode
operator|=
name|VFS_UBF
expr_stmt|;
return|return
name|OK
return|;
case|case
name|TYPE_E
case|:
default|default:
return|return
name|NOTOK
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

