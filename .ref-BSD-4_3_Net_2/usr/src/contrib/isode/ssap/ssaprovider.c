begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ssaprovider.c - implement the session protocol */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ssap/RCS/ssaprovider.c,v 7.5 91/02/22 09:46:03 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ssap/RCS/ssaprovider.c,v 7.5 91/02/22 09:46:03 mrose Interim $  *  *  * $Log:	ssaprovider.c,v $  * Revision 7.5  91/02/22  09:46:03  mrose  * Interim 6.8  *   * Revision 7.4  91/01/10  04:11:29  mrose  * foo  *   * Revision 7.3  90/11/21  11:31:47  mrose  * sun  *   * Revision 7.2  90/08/08  14:14:02  mrose  * update  *   * Revision 7.1  89/11/30  23:51:19  mrose  * touch-up  *   * Revision 7.0  89/11/23  22:25:45  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"spkt.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|int
name|once_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ssapblk
name|ssapque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ssapblk
modifier|*
name|SHead
init|=
operator|&
name|ssapque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TDATAser
argument_list|()
decl_stmt|,
name|TDISCser
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|S-DATA.REQUEST */
end_comment

begin_function
name|int
name|SDataRequest
parameter_list|(
name|sd
parameter_list|,
name|data
parameter_list|,
name|cc
parameter_list|,
name|si
parameter_list|)
name|int
name|sd
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
return|return
name|SSendRequest
argument_list|(
name|sd
argument_list|,
name|data
argument_list|,
name|cc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|si
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|SSendRequest
parameter_list|(
name|sd
parameter_list|,
name|data
parameter_list|,
name|cc
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|si
parameter_list|)
name|int
name|sd
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|begin
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|udvec
name|uvs
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|struct
name|udvec
modifier|*
name|uv
init|=
name|uvs
decl_stmt|;
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|missingP
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"illegal value for SSDU length (%d)"
argument_list|,
name|cc
argument_list|)
return|;
name|missingP
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|ssapPsig
argument_list|(
name|sb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|uv
operator|->
name|uv_base
operator|=
name|data
operator|,
name|uv
operator|->
name|uv_len
operator|=
name|cc
operator|,
name|uv
operator|++
expr_stmt|;
name|uv
operator|->
name|uv_base
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|SDataRequestAux
argument_list|(
name|sb
argument_list|,
name|SPDU_DT
argument_list|,
name|uvs
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|si
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|S-WRITE.REQUEST (pseudo; write user data vectors) */
end_comment

begin_function
name|int
name|SWriteRequest
parameter_list|(
name|sd
parameter_list|,
name|typed
parameter_list|,
name|uv
parameter_list|,
name|si
parameter_list|)
name|int
name|sd
decl_stmt|;
name|int
name|typed
decl_stmt|;
name|struct
name|udvec
modifier|*
name|uv
decl_stmt|;
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|missingP
argument_list|(
name|uv
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|ssapPsig
argument_list|(
name|sb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|result
operator|=
name|SDataRequestAux
argument_list|(
name|sb
argument_list|,
name|typed
condition|?
name|SPDU_TD
else|:
name|SPDU_DT
argument_list|,
name|uv
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|si
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|NSPUV
value|12
end_define

begin_comment
comment|/* really should be MSG_MAXIOVLEN - 4 */
end_comment

begin_function
name|int
name|SDataRequestAux
parameter_list|(
name|sb
parameter_list|,
name|code
parameter_list|,
name|uv
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|si
parameter_list|)
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|int
name|code
decl_stmt|;
specifier|register
name|struct
name|udvec
modifier|*
name|uv
decl_stmt|;
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|,
name|n
decl_stmt|,
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|ssapkt
modifier|*
name|s
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|struct
name|udvec
name|vvs
index|[
name|NSPUV
index|]
decl_stmt|;
specifier|register
name|struct
name|udvec
modifier|*
name|vv
decl_stmt|,
modifier|*
name|wv
decl_stmt|;
name|struct
name|udvec
modifier|*
name|xv
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SPDU_DT
case|:
if|if
condition|(
operator|(
name|sb
operator|->
name|sb_requirements
operator|&
name|SR_DAT_EXISTS
operator|)
operator|&&
operator|!
operator|(
name|sb
operator|->
name|sb_owned
operator|&
name|ST_DAT_TOKEN
operator|)
condition|)
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_OPERATION
argument_list|,
name|NULLCP
argument_list|,
literal|"data token not owned by you"
argument_list|)
return|;
break|break;
case|case
name|SPDU_TD
case|:
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_requirements
operator|&
name|SR_TYPEDATA
operator|)
condition|)
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_OPERATION
argument_list|,
name|NULLCP
argument_list|,
literal|"typed data service unavailable"
argument_list|)
return|;
break|break;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vv
operator|=
name|uv
init|;
name|vv
operator|->
name|uv_base
condition|;
name|vv
operator|++
control|)
name|n
operator|+=
name|vv
operator|->
name|uv_len
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"zero-length SSDU"
argument_list|)
return|;
name|ep
operator|=
operator|(
name|bp
operator|=
name|uv
operator|->
name|uv_base
operator|)
operator|+
operator|(
name|cc
operator|=
name|uv
operator|->
name|uv_len
operator|)
expr_stmt|;
while|while
condition|(
name|uv
operator|->
name|uv_base
condition|)
block|{
name|len
operator|=
name|sb
operator|->
name|sb_tsdu_us
condition|?
name|min
argument_list|(
name|n
argument_list|,
name|sb
operator|->
name|sb_tsdu_us
operator|-
name|SSDU_MAGIC
argument_list|)
else|:
name|n
expr_stmt|;
name|vv
operator|=
name|vvs
expr_stmt|;
name|vvs
index|[
literal|0
index|]
operator|.
name|uv_base
operator|=
name|vvs
index|[
literal|1
index|]
operator|.
name|uv_base
operator|=
name|NULL
expr_stmt|;
name|vvs
index|[
literal|1
index|]
operator|.
name|uv_inline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SPDU_DT
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|newspkt
argument_list|(
name|SPDU_GT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
return|;
name|s
operator|->
name|s_mask
operator||=
name|SMASK_SPDU_GT
expr_stmt|;
if|if
condition|(
name|spkt2tsdu
argument_list|(
name|s
argument_list|,
operator|&
name|vv
operator|->
name|uv_base
argument_list|,
operator|&
name|vv
operator|->
name|uv_len
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|s
operator|->
name|s_errno
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
name|vv
operator|++
expr_stmt|;
block|}
name|xv
operator|=
name|vv
operator|++
expr_stmt|;
name|wv
operator|=
name|vvs
operator|+
name|NSPUV
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
operator|&&
name|vv
operator|<
name|wv
condition|;
name|len
operator|-=
name|j
control|)
block|{
name|j
operator|=
name|min
argument_list|(
name|cc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vv
operator|->
name|uv_base
operator|=
name|bp
operator|,
name|vv
operator|->
name|uv_len
operator|=
name|j
operator|,
name|vv
operator|->
name|uv_inline
operator|=
literal|1
operator|,
name|vv
operator|++
expr_stmt|;
name|bp
operator|+=
name|j
operator|,
name|cc
operator|-=
name|j
operator|,
name|n
operator|-=
name|j
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|ep
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|=
operator|(
operator|++
name|uv
operator|)
operator|->
name|uv_base
operator|)
operator|==
name|NULL
condition|)
break|break;
name|ep
operator|=
name|bp
operator|+
operator|(
name|cc
operator|=
name|uv
operator|->
name|uv_len
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sb
operator|->
name|sb_tsdu_us
operator|&&
name|uv
operator|->
name|uv_base
condition|)
block|{
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"too many vector entries in SDU"
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
name|vv
operator|->
name|uv_base
operator|=
name|NULL
expr_stmt|;
name|vv
operator|=
name|xv
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|newspkt
argument_list|(
name|code
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_tsdu_us
condition|)
block|{
name|s
operator|->
name|s_mask
operator||=
name|SMASK_ENCLOSE
expr_stmt|;
if|if
condition|(
name|begin
condition|)
block|{
name|s
operator|->
name|s_enclose
operator||=
name|ENCL_BEGIN
expr_stmt|;
name|begin
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|&&
name|uv
operator|->
name|uv_base
operator|==
name|NULL
condition|)
name|s
operator|->
name|s_enclose
operator||=
name|ENCL_END
expr_stmt|;
block|}
if|if
condition|(
name|spkt2tsdu
argument_list|(
name|s
argument_list|,
operator|&
name|vv
operator|->
name|uv_base
argument_list|,
operator|&
name|vv
operator|->
name|uv_len
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|s
operator|->
name|s_errno
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out3
goto|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|TWriteRequest
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|vvs
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|ts2sslose
argument_list|(
name|si
argument_list|,
literal|"TWriteRequest"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vvs
index|[
literal|0
index|]
operator|.
name|uv_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SPDU_DT
condition|)
name|free
argument_list|(
name|vvs
index|[
literal|1
index|]
operator|.
name|uv_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
name|out3
label|:
empty_stmt|;
if|if
condition|(
name|vvs
index|[
literal|1
index|]
operator|.
name|uv_base
operator|&&
operator|!
name|vvs
index|[
literal|1
index|]
operator|.
name|uv_inline
condition|)
name|free
argument_list|(
name|vvs
index|[
literal|1
index|]
operator|.
name|uv_base
argument_list|)
expr_stmt|;
name|out2
label|:
empty_stmt|;
if|if
condition|(
name|vvs
index|[
literal|0
index|]
operator|.
name|uv_base
condition|)
name|free
argument_list|(
name|vvs
index|[
literal|0
index|]
operator|.
name|uv_base
argument_list|)
expr_stmt|;
name|out1
label|:
empty_stmt|;
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|S-READ.REQUEST (pseudo; synchronous read) */
end_comment

begin_function
name|int
name|SReadRequest
parameter_list|(
name|sd
parameter_list|,
name|sx
parameter_list|,
name|secs
parameter_list|,
name|si
parameter_list|)
name|int
name|sd
decl_stmt|;
name|struct
name|SSAPdata
modifier|*
name|sx
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|missingP
argument_list|(
name|sx
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|=
name|findsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"invalid session descriptor"
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_CONN
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"session descriptor not connected"
argument_list|)
return|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_FINN
condition|)
block|{
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_OPERATION
argument_list|,
name|NULLCP
argument_list|,
literal|"session descriptor finishing"
argument_list|)
return|;
block|}
name|result
operator|=
name|SReadRequestAux
argument_list|(
name|sb
argument_list|,
name|sx
argument_list|,
name|secs
argument_list|,
name|si
argument_list|,
literal|0
argument_list|,
name|NULLTX
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|SReadRequestAux
parameter_list|(
name|sb
parameter_list|,
name|sx
parameter_list|,
name|secs
parameter_list|,
name|si
parameter_list|,
name|async
parameter_list|,
name|tx
parameter_list|)
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
specifier|register
name|struct
name|SSAPdata
modifier|*
name|sx
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
name|int
name|async
decl_stmt|;
name|struct
name|TSAPdata
modifier|*
name|tx
decl_stmt|;
block|{
name|int
name|eot
decl_stmt|;
name|char
name|tokens
decl_stmt|;
specifier|register
name|struct
name|ssapkt
modifier|*
name|s
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sx
argument_list|,
sizeof|sizeof
expr|*
name|sx
argument_list|)
expr_stmt|;
name|sx
operator|->
name|sx_qbuf
operator|.
name|qb_forw
operator|=
name|sx
operator|->
name|sx_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|sx
operator|->
name|sx_qbuf
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|si
argument_list|,
sizeof|sizeof
expr|*
name|si
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|s
operator|=
name|sb2spkt
argument_list|(
name|sb
argument_list|,
name|si
argument_list|,
name|secs
argument_list|,
name|tx
argument_list|)
condition|;
name|tx
operator|=
name|NULLTX
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_EXPD
operator|)
condition|)
switch|switch
condition|(
name|sb
operator|->
name|sb_pr
condition|)
block|{
case|case
name|SPDU_PR
case|:
break|break;
case|case
name|SPDU_MAA
case|:
if|if
condition|(
name|s
operator|->
name|s_code
operator|==
name|SPDU_MAA
condition|)
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_PR
expr_stmt|;
break|break;
case|case
name|SPDU_RS
case|:
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
case|case
name|SPDU_AB
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_AI
case|:
comment|/* aka SPDU_AB */
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_AB
condition|)
break|break;
comment|/* else fall */
case|case
name|SPDU_AD
case|:
case|case
name|SPDU_RS
case|:
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_PR
expr_stmt|;
break|break;
default|default:
goto|goto
name|drop_it
goto|;
block|}
break|break;
case|case
name|SPDU_RA
case|:
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
case|case
name|SPDU_AB
case|:
break|break;
case|case
name|SPDU_AA
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_AIA
case|:
comment|/* aka SPDU_AA */
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_AA
condition|)
break|break;
comment|/* else fall */
case|case
name|SPDU_ADA
case|:
case|case
name|SPDU_RA
case|:
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_PR
expr_stmt|;
break|break;
default|default:
name|drop_it
label|:
empty_stmt|;
name|SLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"discarding 0x%x SPDU"
operator|,
name|s
operator|->
name|s_code
operator|)
argument_list|)
expr_stmt|;
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
break|break;
case|case
name|SPDU_AB
case|:
if|if
condition|(
name|s
operator|->
name|s_code
operator|!=
name|SPDU_AB
condition|)
goto|goto
name|drop_it
goto|;
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_PR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
operator|(
name|SB_RS
operator||
name|SB_AI
operator|)
condition|)
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
case|case
name|SPDU_PR
case|:
switch|switch
condition|(
name|s
operator|->
name|s_pr_type
condition|)
block|{
case|case
name|PR_RS
case|:
case|case
name|PR_RA
case|:
break|break;
default|default:
goto|goto
name|drop_it
goto|;
block|}
break|break;
case|case
name|SPDU_RS
case|:
if|if
condition|(
name|SDoCollideAux
argument_list|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_INIT
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sb
operator|->
name|sb_rs
argument_list|,
name|sb
operator|->
name|sb_rsn
argument_list|,
operator|(
name|int
operator|)
name|s
operator|->
name|s_rs_type
argument_list|,
operator|(
name|long
operator|)
name|s
operator|->
name|s_rs_serial
argument_list|)
operator|!=
name|NOTOK
condition|)
goto|goto
name|drop_it
goto|;
break|break;
case|case
name|SPDU_RA
case|:
break|break;
case|case
name|SPDU_AD
case|:
if|if
condition|(
name|SDoCollideAux
argument_list|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_INIT
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sb
operator|->
name|sb_rs
argument_list|,
name|sb
operator|->
name|sb_rsn
argument_list|,
name|SYNC_DISC
argument_list|,
literal|0L
argument_list|)
operator|!=
name|NOTOK
condition|)
goto|goto
name|drop_it
goto|;
break|break;
case|case
name|SPDU_AB
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_AI
case|:
comment|/* aka SPDU_AB */
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_AB
condition|)
break|break;
if|if
condition|(
name|SDoCollideAux
argument_list|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_INIT
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sb
operator|->
name|sb_rs
argument_list|,
name|sb
operator|->
name|sb_rsn
argument_list|,
name|SYNC_INTR
argument_list|,
literal|0L
argument_list|)
operator|!=
name|NOTOK
condition|)
goto|goto
name|drop_it
goto|;
break|break;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
operator|(
name|SB_ED
operator||
name|SB_ERACK
operator|)
condition|)
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
case|case
name|SPDU_AB
case|:
break|break;
case|case
name|SPDU_MAP
case|:
case|case
name|SPDU_MIP
case|:
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_ED
condition|)
break|break;
goto|goto
name|drop_it
goto|;
case|case
name|SPDU_PR
case|:
if|if
condition|(
name|s
operator|->
name|s_pr_type
operator|==
name|PR_RS
condition|)
break|break;
goto|goto
name|drop_it
goto|;
case|case
name|SPDU_GT
case|:
if|if
condition|(
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_GT
operator|)
operator|&&
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_GT_TOKEN
operator|)
operator|&&
operator|(
name|s
operator|->
name|s_gt_token
operator|&
name|ST_DAT_TOKEN
operator|)
condition|)
break|break;
comment|/* else fall */
default|default:
goto|goto
name|drop_it
goto|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_len
operator|>
literal|0
condition|)
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
case|case
name|SPDU_PT
case|:
case|case
name|SPDU_EX
case|:
break|break;
case|case
name|SPDU_PR
case|:
if|if
condition|(
name|s
operator|->
name|s_pr_type
operator|!=
name|PR_RS
condition|)
break|break;
case|case
name|SPDU_RS
case|:
case|case
name|SPDU_ER
case|:
case|case
name|SPDU_ED
case|:
case|case
name|SPDU_AD
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_AI
case|:
comment|/* aka SPDU_AB */
endif|#
directive|endif
case|case
name|SPDU_AB
case|:
name|SLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"flush partially assembled (T))SSDU"
operator|)
argument_list|)
expr_stmt|;
name|QBFREE
argument_list|(
operator|&
name|sb
operator|->
name|sb_qbuf
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SPDU_GT
case|:
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_GT
condition|)
break|break;
comment|/* else SPDU_DT */
default|default:
if|if
condition|(
name|sb
operator|->
name|sb_code
operator|==
name|s
operator|->
name|s_code
condition|)
break|break;
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"session protocol mangled: expecting 0x%x, got 0x%x during segmentation"
argument_list|,
name|sb
operator|->
name|sb_code
argument_list|,
name|s
operator|->
name|s_code
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* allows AB SPDUs to have 512, not 9, octets (which is fine by me) */
if|if
condition|(
name|s
operator|->
name|s_ulen
operator|>
name|CN_SIZE
operator|&&
name|sb
operator|->
name|sb_version
operator|<
name|SB_VRSN2
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"too much user data (%d) in SPDU 0x%x"
argument_list|,
name|s
operator|->
name|s_ulen
argument_list|,
name|s
operator|->
name|s_code
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_ENCLOSE
operator|)
operator|&&
operator|(
name|s
operator|->
name|s_code
operator|!=
name|SPDU_DT
operator|||
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_GT
operator|)
operator|)
operator|&&
name|s
operator|->
name|s_code
operator|!=
name|SPDU_TD
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|sb_version
operator|<
name|SB_VRSN2
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpected segmentation for SPDU 0x%x"
argument_list|,
name|s
operator|->
name|s_code
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* XXX: in practice, I don't think this is unreasonable.  It is 	however not too restrictive */
if|if
condition|(
name|s
operator|->
name|s_enclose
operator|!=
name|ENCL_MASK
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"non-trivial segmentation (0x%x) for SPDU 0x%x"
argument_list|,
name|s
operator|->
name|s_enclose
argument_list|,
name|s
operator|->
name|s_code
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
case|case
name|SPDU_PT
case|:
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_GTC
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|tokens
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_PT_TOKEN
condition|)
block|{
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \ 		    if ((sb -> sb_requirements& requires) \&& (s -> s_pt_token& bit)) \ 			tokens |= bit; \ }
name|dotokens
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dotoken
block|}
name|si
operator|->
name|si_type
operator|=
name|SI_TOKEN
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPtoken
modifier|*
name|st
init|=
operator|&
name|si
operator|->
name|si_token
decl_stmt|;
name|st
operator|->
name|st_type
operator|=
name|ST_PLEASE
expr_stmt|;
name|st
operator|->
name|st_tokens
operator|=
name|tokens
expr_stmt|;
name|st
operator|->
name|st_owned
operator|=
name|sb
operator|->
name|sb_owned
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_GT
case|:
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_GT
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_GTC
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|tokens
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_GT_TOKEN
condition|)
block|{
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \ 			if ((sb -> sb_requirements& requires) \&& (s -> s_gt_token& bit)) \ 				sb -> sb_owned |= bit, tokens |= bit; \ }
name|dotokens
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dotoken
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
operator|&
name|ST_DAT_TOKEN
condition|)
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
operator|(
name|SB_ED
operator||
name|SB_ERACK
operator|)
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_TOKEN
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPtoken
modifier|*
name|st
init|=
operator|&
name|si
operator|->
name|si_token
decl_stmt|;
name|st
operator|->
name|st_type
operator|=
name|ST_GIVE
expr_stmt|;
name|st
operator|->
name|st_tokens
operator|=
name|tokens
expr_stmt|;
name|st
operator|->
name|st_owned
operator|=
name|sb
operator|->
name|sb_owned
expr_stmt|;
block|}
return|return
name|DONE
return|;
block|}
comment|/* else fall for case SPDU_DT: */
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_DT
case|:
endif|#
directive|endif
case|case
name|SPDU_TD
case|:
name|sb
operator|->
name|sb_code
operator|=
name|s
operator|->
name|s_code
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_tsdu_them
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_ENCLOSE
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"no segmentation information"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|s_enclose
operator|&
name|ENCL_BEGIN
operator|)
condition|?
name|sb
operator|->
name|sb_len
operator|>
literal|0
else|:
name|sb
operator|->
name|sb_len
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"segmentation mismatch"
argument_list|)
expr_stmt|;
break|break;
block|}
name|eot
operator|=
name|s
operator|->
name|s_enclose
operator|&
name|ENCL_END
expr_stmt|;
block|}
else|else
name|eot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
operator|!=
operator|&
name|s
operator|->
name|s_qbuf
condition|)
block|{
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_back
operator|->
name|qb_forw
operator|=
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
expr_stmt|;
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
operator|->
name|qb_back
operator|=
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_back
expr_stmt|;
name|s
operator|->
name|s_qbuf
operator|.
name|qb_back
operator|->
name|qb_forw
operator|=
operator|&
name|sb
operator|->
name|sb_qbuf
expr_stmt|;
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_back
operator|=
name|s
operator|->
name|s_qbuf
operator|.
name|qb_back
expr_stmt|;
name|sb
operator|->
name|sb_len
operator|+=
name|s
operator|->
name|s_qlen
expr_stmt|;
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
operator|=
name|s
operator|->
name|s_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|s
operator|->
name|s_qbuf
expr_stmt|;
name|s
operator|->
name|s_qlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eot
operator|&&
operator|(
name|s
operator|->
name|s_code
operator|==
name|SPDU_DT
operator|)
operator|&&
name|sb
operator|->
name|sb_spdu
condition|)
block|{
name|freespkt
argument_list|(
name|sb
operator|->
name|sb_spdu
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_spdu
operator|=
name|NULL
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eot
condition|)
goto|goto
name|spin
goto|;
name|sx
operator|->
name|sx_type
operator|=
name|sb
operator|->
name|sb_code
operator|==
name|SPDU_DT
condition|?
name|SX_NORMAL
else|:
name|SX_TYPED
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_forw
operator|!=
operator|&
name|sb
operator|->
name|sb_qbuf
condition|)
block|{
name|sx
operator|->
name|sx_qbuf
operator|=
name|sb
operator|->
name|sb_qbuf
expr_stmt|;
comment|/* struct copy */
name|sx
operator|->
name|sx_qbuf
operator|.
name|qb_forw
operator|->
name|qb_back
operator|=
name|sx
operator|->
name|sx_qbuf
operator|.
name|qb_back
operator|->
name|qb_forw
operator|=
operator|&
name|sx
operator|->
name|sx_qbuf
expr_stmt|;
name|sx
operator|->
name|sx_cc
operator|=
name|sb
operator|->
name|sb_len
expr_stmt|;
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_forw
operator|=
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|sb
operator|->
name|sb_qbuf
expr_stmt|;
name|sb
operator|->
name|sb_len
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|OK
return|;
case|case
name|SPDU_EX
case|:
if|if
condition|(
name|sb
operator|->
name|sb_pr
operator|!=
name|SPDU_PR
condition|)
block|{
name|SLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"buffering XSDU during preparation"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_xspdu
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to buffer second XSDU"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sb
operator|->
name|sb_xspdu
operator|=
name|s
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sx
operator|->
name|sx_type
operator|=
name|SX_EXPEDITED
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
operator|!=
operator|&
name|s
operator|->
name|s_qbuf
condition|)
block|{
name|sx
operator|->
name|sx_qbuf
operator|=
name|s
operator|->
name|s_qbuf
expr_stmt|;
comment|/* struct copy */
name|sx
operator|->
name|sx_qbuf
operator|.
name|qb_forw
operator|->
name|qb_back
operator|=
name|sx
operator|->
name|sx_qbuf
operator|.
name|qb_back
operator|->
name|qb_forw
operator|=
operator|&
name|sx
operator|->
name|sx_qbuf
expr_stmt|;
name|sx
operator|->
name|sx_cc
operator|=
name|s
operator|->
name|s_qlen
expr_stmt|;
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
operator|=
name|s
operator|->
name|s_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|s
operator|->
name|s_qbuf
expr_stmt|;
name|s
operator|->
name|s_qlen
operator|=
literal|0
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
case|case
name|SPDU_CD
case|:
case|case
name|SPDU_CDA
case|:
if|if
condition|(
name|s
operator|->
name|s_code
operator|==
name|SPDU_CD
condition|)
block|{
name|sb
operator|->
name|sb_flags
operator||=
name|SB_CDA
expr_stmt|;
name|sx
operator|->
name|sx_type
operator|=
name|SX_CAPDIND
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_CD
expr_stmt|;
name|sx
operator|->
name|sx_type
operator|=
name|SX_CAPDCNF
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s_udata
condition|)
block|{
specifier|register
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
name|qb
operator|=
operator|(
expr|struct
name|qbuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|qb
operator|+
operator|(
name|unsigned
operator|)
name|s
operator|->
name|s_ulen
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|s
operator|->
name|s_udata
argument_list|,
name|qb
operator|->
name|qb_data
operator|=
name|qb
operator|->
name|qb_base
argument_list|,
name|qb
operator|->
name|qb_len
operator|=
name|s
operator|->
name|s_ulen
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|qb
argument_list|,
operator|&
name|sx
operator|->
name|sx_qbuf
argument_list|)
expr_stmt|;
name|sx
operator|->
name|sx_cc
operator|=
name|s
operator|->
name|s_ulen
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
case|case
name|SPDU_GTC
case|:
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vact
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \ 		if (sb -> sb_requirements& requires) \ 		    sb -> sb_owned |= bit; \ }
name|dotokens
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dotoken
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|newspkt
argument_list|(
name|SPDU_GTA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|spkt2sd
argument_list|(
name|s
argument_list|,
name|sb
operator|->
name|sb_fd
argument_list|,
literal|0
argument_list|,
name|si
argument_list|)
operator|==
name|NOTOK
condition|)
break|break;
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_TOKEN
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPtoken
modifier|*
name|st
init|=
operator|&
name|si
operator|->
name|si_token
decl_stmt|;
name|st
operator|->
name|st_type
operator|=
name|ST_CONTROL
expr_stmt|;
name|st
operator|->
name|st_tokens
operator|=
name|st
operator|->
name|st_owned
operator|=
name|sb
operator|->
name|sb_owned
expr_stmt|;
block|}
return|return
name|DONE
return|;
case|case
name|SPDU_GTA
case|:
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_GTC
operator|)
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_GTC
expr_stmt|;
name|spin
label|:
empty_stmt|;
if|if
condition|(
operator|!
name|async
operator|||
name|sb
operator|->
name|sb_spdu
condition|)
continue|continue;
name|si
operator|->
name|si_type
operator|=
name|SI_DATA
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPdata
modifier|*
name|sk
init|=
operator|&
name|si
operator|->
name|si_data
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sk
argument_list|,
sizeof|sizeof
expr|*
name|sk
argument_list|)
expr_stmt|;
name|sk
operator|->
name|sx_qbuf
operator|.
name|qb_forw
operator|=
name|sk
operator|->
name|sx_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|sk
operator|->
name|sx_qbuf
expr_stmt|;
block|}
return|return
name|DONE
return|;
case|case
name|SPDU_MAP
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_AE
case|:
comment|/* aka SPDU_MAP */
endif|#
directive|endif
if|if
condition|(
name|sb
operator|->
name|sb_V_M
operator|!=
name|s
operator|->
name|s_map_serial
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_MAP_SYNC
operator|)
operator|||
operator|!
operator|(
name|s
operator|->
name|s_map_sync
operator|&
name|MAP_SYNC_NOEND
operator|)
condition|)
goto|goto
name|spdu_ae
goto|;
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vsc
operator|)
condition|)
name|sb
operator|->
name|sb_V_A
operator|=
name|sb
operator|->
name|sb_V_M
expr_stmt|;
name|sb
operator|->
name|sb_V_M
operator|++
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
operator|(
name|SB_ED
operator||
name|SB_ERACK
operator|)
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_requirements
operator|&
name|SR_ACTIVITY
condition|)
name|sb
operator|->
name|sb_flags
operator||=
name|SB_Vnextact
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_MAA
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_SYNC
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPsync
modifier|*
name|sn
init|=
operator|&
name|si
operator|->
name|si_sync
decl_stmt|;
name|sn
operator|->
name|sn_type
operator|=
name|SN_MAJORIND
expr_stmt|;
name|sn
operator|->
name|sn_ssn
operator|=
name|s
operator|->
name|s_map_serial
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_MAA
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_AEA
case|:
comment|/* aka SPDU_MAA */
endif|#
directive|endif
if|if
condition|(
name|sb
operator|->
name|sb_V_M
operator|!=
name|s
operator|->
name|s_maa_serial
operator|+
literal|1
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_V_A
operator|=
name|sb
operator|->
name|sb_V_R
operator|=
name|sb
operator|->
name|sb_V_M
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_requirements
operator|&
name|SR_ACTIVITY
condition|)
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vnextact
condition|)
name|sb
operator|->
name|sb_flags
operator||=
name|SB_Vact
expr_stmt|;
else|else
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_Vact
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_MAP
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_AE
condition|)
block|{
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AE
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_ACTIVITY
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPactivity
modifier|*
name|sv
init|=
operator|&
name|si
operator|->
name|si_activity
decl_stmt|;
name|sv
operator|->
name|sv_type
operator|=
name|SV_ENDCNF
expr_stmt|;
name|sv
operator|->
name|sv_ssn
operator|=
name|s
operator|->
name|s_maa_serial
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|si
operator|->
name|si_type
operator|=
name|SI_SYNC
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPsync
modifier|*
name|sn
init|=
operator|&
name|si
operator|->
name|si_sync
decl_stmt|;
name|sn
operator|->
name|sn_type
operator|=
name|SN_MAJORCNF
expr_stmt|;
name|sn
operator|->
name|sn_ssn
operator|=
name|s
operator|->
name|s_maa_serial
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_MIP
case|:
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vsc
operator|)
condition|)
block|{
name|sb
operator|->
name|sb_V_A
operator|=
name|sb
operator|->
name|sb_V_M
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_Vsc
expr_stmt|;
block|}
name|sb
operator|->
name|sb_V_M
operator|++
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
operator|(
name|SB_ED
operator||
name|SB_ERACK
operator|)
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|si
operator|->
name|si_type
operator|=
name|SI_SYNC
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPsync
modifier|*
name|sn
init|=
operator|&
name|si
operator|->
name|si_sync
decl_stmt|;
name|sn
operator|->
name|sn_type
operator|=
name|SN_MINORIND
expr_stmt|;
name|sn
operator|->
name|sn_options
operator|=
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_MIP_SYNC
operator|)
operator|&&
operator|(
name|s
operator|->
name|s_mip_sync
operator|&
name|MIP_SYNC_NOEXPL
operator|)
condition|?
name|SYNC_NOCONFIRM
else|:
name|SYNC_CONFIRM
expr_stmt|;
name|sn
operator|->
name|sn_ssn
operator|=
name|s
operator|->
name|s_mip_serial
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_MIA
case|:
if|if
condition|(
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vsc
operator|)
operator|||
name|sb
operator|->
name|sb_V_A
operator|>
name|s
operator|->
name|s_mia_serial
operator|||
name|s
operator|->
name|s_mia_serial
operator|>=
name|sb
operator|->
name|sb_V_M
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_V_A
operator|=
name|s
operator|->
name|s_mia_serial
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_SYNC
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPsync
modifier|*
name|sn
init|=
operator|&
name|si
operator|->
name|si_sync
decl_stmt|;
name|sn
operator|->
name|sn_type
operator|=
name|SN_MINORCNF
expr_stmt|;
name|sn
operator|->
name|sn_ssn
operator|=
name|s
operator|->
name|s_mia_serial
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_RS
case|:
if|if
condition|(
name|s
operator|->
name|s_rs_type
operator|==
name|SYNC_RESTART
operator|&&
name|sb
operator|->
name|sb_V_R
operator|>
name|s
operator|->
name|s_rs_serial
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_RS
operator|,
name|sb
operator|->
name|sb_flags
operator||=
name|SB_RA
expr_stmt|;
name|sb
operator|->
name|sb_rs
operator|=
name|s
operator|->
name|s_rs_type
expr_stmt|;
name|sb
operator|->
name|sb_rsn
operator|=
name|s
operator|->
name|s_rs_serial
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_RS_SET
condition|)
name|sb
operator|->
name|sb_rsettings
operator|=
name|s
operator|->
name|s_rs_settings
expr_stmt|;
else|else
block|{
name|sb
operator|->
name|sb_rsettings
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \ 		    if (sb -> sb_requirements& requires) \ 			if ((sb -> sb_owned& bit) \&& (sb -> sb_flags& SB_INIT)) \ 			    sb -> sb_rsettings = ST_INIT_VALUE<< shift; \ 			else \ 			    sb -> sb_rsettings = ST_RESP_VALUE<< shift; \ }
name|dotokens
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dotoken
block|}
name|si
operator|->
name|si_type
operator|=
name|SI_SYNC
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPsync
modifier|*
name|sn
init|=
operator|&
name|si
operator|->
name|si_sync
decl_stmt|;
name|sn
operator|->
name|sn_type
operator|=
name|SN_RESETIND
expr_stmt|;
name|sn
operator|->
name|sn_options
operator|=
name|sb
operator|->
name|sb_rs
expr_stmt|;
name|sn
operator|->
name|sn_ssn
operator|=
name|sb
operator|->
name|sb_rsn
expr_stmt|;
name|sn
operator|->
name|sn_settings
operator|=
name|sb
operator|->
name|sb_rsettings
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_RA
case|:
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_RS
expr_stmt|;
name|sb
operator|->
name|sb_V_A
operator|=
name|sb
operator|->
name|sb_V_M
operator|=
name|s
operator|->
name|s_ra_serial
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_rs
operator|!=
name|SYNC_RESTART
condition|)
name|sb
operator|->
name|sb_V_R
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_RA_SET
condition|)
name|sb
operator|->
name|sb_rsettings
operator|=
name|s
operator|->
name|s_ra_settings
expr_stmt|;
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \ 		if (sb -> sb_requirements& requires) \ 		    switch (sb -> sb_rsettings& (ST_MASK<< shift)) { \ 			dotoken1 (requires,shift,bit,type); \  \ 			dotoken2 (requires,shift,bit,type); \ 		    } \ }
define|#
directive|define
name|dotoken1
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|case ST_CALL_VALUE<< shift: \ 			    switch (s -> s_ra_settings& (ST_MASK<< shift)) { \ 				case ST_INIT_VALUE: \ 				    if (sb -> sb_flags& SB_INIT) \ 					sb -> sb_owned |= bit; \ 				    else \ 					sb -> sb_owned&= ~bit; \ 				    break; \  \ 				case ST_RESP_VALUE: \ 				    if (!(sb -> sb_flags& SB_INIT)) \ 					sb -> sb_owned |= bit; \ 				    else \ 					sb -> sb_owned&= ~bit; \ 				    break; \ 			    } \ 			    break;
define|#
directive|define
name|dotoken2
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|case ST_INIT_VALUE<< shift: \ 			    if (sb -> sb_flags& SB_INIT) \ 				sb -> sb_owned |= bit; \ 			    else \ 				sb -> sb_owned&= ~bit; \ 			    break; \  \ 			case ST_RESP_VALUE<< shift: \ 			    if (!(sb -> sb_flags& SB_INIT)) \ 				sb -> sb_owned |= bit; \ 			    else \ 				sb -> sb_owned&= ~bit; \ 			    break;
name|dotokens
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dotoken
undef|#
directive|undef
name|dotoken1
undef|#
directive|undef
name|dotoken2
name|si
operator|->
name|si_type
operator|=
name|SI_SYNC
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPsync
modifier|*
name|sn
init|=
operator|&
name|si
operator|->
name|si_sync
decl_stmt|;
name|sn
operator|->
name|sn_type
operator|=
name|SN_RESETCNF
expr_stmt|;
name|sn
operator|->
name|sn_ssn
operator|=
name|sb
operator|->
name|sb_V_M
expr_stmt|;
name|sn
operator|->
name|sn_settings
operator|=
name|sb
operator|->
name|sb_rsettings
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_PR
case|:
switch|switch
condition|(
name|s
operator|->
name|s_pr_type
condition|)
block|{
case|case
name|PR_MAA
case|:
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_MAA
expr_stmt|;
break|break;
case|case
name|PR_RS
case|:
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
operator|(
name|SB_ED
operator||
name|SB_ERACK
operator|)
expr_stmt|;
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_RS
expr_stmt|;
break|break;
case|case
name|PR_RA
case|:
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_RA
expr_stmt|;
break|break;
case|case
name|PR_AB
case|:
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_AB
expr_stmt|;
break|break;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
case|case
name|SPDU_ER
case|:
comment|/* this implementation never generates these */
name|sb
operator|->
name|sb_flags
operator||=
name|SB_ERACK
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_REPORT
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPreport
modifier|*
name|sp
init|=
operator|&
name|si
operator|->
name|si_report
decl_stmt|;
name|sp
operator|->
name|sp_peer
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sp_reason
operator|=
name|SP_PROTOCOL
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_ED
case|:
if|if
condition|(
name|sb
operator|->
name|sb_owned
operator|&
name|ST_DAT_TOKEN
condition|)
name|sb
operator|->
name|sb_flags
operator||=
name|SB_EDACK
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_REPORT
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPreport
modifier|*
name|sp
init|=
operator|&
name|si
operator|->
name|si_report
decl_stmt|;
name|sp
operator|->
name|sp_peer
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|sp_reason
operator|=
name|s
operator|->
name|s_ed_reason
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_AS
case|:
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vact
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_V_A
operator|=
name|sb
operator|->
name|sb_V_M
operator|=
name|sb
operator|->
name|sb_V_R
operator|=
literal|1
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_Vact
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_ACTIVITY
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPactivity
modifier|*
name|sv
init|=
operator|&
name|si
operator|->
name|si_activity
decl_stmt|;
name|sv
operator|->
name|sv_type
operator|=
name|SV_START
expr_stmt|;
name|sv
operator|->
name|sv_id
operator|=
name|s
operator|->
name|s_as_id
expr_stmt|;
comment|/* struct copy */
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_AR
case|:
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vact
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_V_A
operator|=
name|sb
operator|->
name|sb_V_M
operator|=
name|s
operator|->
name|s_ar_serial
operator|+
literal|1
expr_stmt|;
name|sb
operator|->
name|sb_V_R
operator|=
literal|1
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_Vact
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_ACTIVITY
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPactivity
modifier|*
name|sv
init|=
operator|&
name|si
operator|->
name|si_activity
decl_stmt|;
name|sv
operator|->
name|sv_type
operator|=
name|SV_RESUME
expr_stmt|;
name|sv
operator|->
name|sv_id
operator|=
name|s
operator|->
name|s_ar_id
expr_stmt|;
comment|/* struct copy */
name|sv
operator|->
name|sv_oid
operator|=
name|s
operator|->
name|s_ar_oid
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_AR_REF
condition|)
comment|/* struct copy */
name|sv
operator|->
name|sv_connect
operator|=
name|s
operator|->
name|s_ar_reference
expr_stmt|;
name|sv
operator|->
name|sv_ssn
operator|=
name|s
operator|->
name|s_ar_serial
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_AD
case|:
name|spdu_ai
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vact
operator|)
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
operator|(
name|SB_RS
operator||
name|SB_RA
operator|)
operator|,
name|sb
operator|->
name|sb_flags
operator||=
name|SB_AIA
expr_stmt|;
name|sb
operator|->
name|sb_rs
operator|=
name|SYNC_INTR
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_ACTIVITY
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPactivity
modifier|*
name|sv
init|=
operator|&
name|si
operator|->
name|si_activity
decl_stmt|;
name|sv
operator|->
name|sv_type
operator|=
name|s
operator|->
name|s_code
operator|==
name|SPDU_AI
condition|?
name|SV_INTRIND
else|:
name|SV_DISCIND
expr_stmt|;
name|sv
operator|->
name|sv_reason
operator|=
name|s
operator|->
name|s_ai_reason
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_AA
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
name|SPDU_AIA
case|:
comment|/* aka SPDU_AA */
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_AA
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
comment|/* else fall */
case|case
name|SPDU_ADA
case|:
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vact
operator|)
condition|)
block|{
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|spin
goto|;
block|}
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
operator|(
name|SB_AI
operator||
name|SB_Vact
operator|)
expr_stmt|;
define|#
directive|define
name|dotoken
parameter_list|(
name|requires
parameter_list|,
name|shift
parameter_list|,
name|bit
parameter_list|,
name|type
parameter_list|)
define|\
value|{ \ 		if (sb -> sb_requirements& requires) \ 		    sb -> sb_owned |= bit; \ }
name|dotokens
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dotoken
name|si
operator|->
name|si_type
operator|=
name|SI_ACTIVITY
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPactivity
modifier|*
name|sv
init|=
operator|&
name|si
operator|->
name|si_activity
decl_stmt|;
name|sv
operator|->
name|sv_type
operator|=
name|s
operator|->
name|s_code
operator|==
name|SPDU_AIA
condition|?
name|SV_INTRCNF
else|:
name|SV_DISCCNF
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
name|spdu_ae
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_Vsc
operator|)
condition|)
name|sb
operator|->
name|sb_V_A
operator|=
name|sb
operator|->
name|sb_V_M
expr_stmt|;
name|sb
operator|->
name|sb_V_M
operator|++
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_Vnextact
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_MAA
operator||
name|SB_AE
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_ACTIVITY
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPactivity
modifier|*
name|sv
init|=
operator|&
name|si
operator|->
name|si_activity
decl_stmt|;
name|sv
operator|->
name|sv_type
operator|=
name|SV_ENDIND
expr_stmt|;
name|sv
operator|->
name|sv_ssn
operator|=
name|s
operator|->
name|s_map_serial
expr_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_FN
case|:
name|sb
operator|->
name|sb_flags
operator||=
name|SB_FINN
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_FINISH
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPfinish
modifier|*
name|sf
init|=
operator|&
name|si
operator|->
name|si_finish
decl_stmt|;
name|copySPKTdata
argument_list|(
name|s
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
case|case
name|SPDU_AB
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|s_mask
operator|&
name|SMASK_SPDU_AB
operator|)
condition|)
goto|goto
name|spdu_ai
goto|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
operator|(
name|SB_ED
operator||
name|SB_EDACK
operator||
name|SB_ERACK
operator|)
expr_stmt|;
name|si
operator|->
name|si_type
operator|=
name|SI_ABORT
expr_stmt|;
block|{
specifier|register
name|struct
name|SSAPabort
modifier|*
name|sa
init|=
operator|&
name|si
operator|->
name|si_abort
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sa
operator|->
name|sa_peer
operator|=
operator|(
name|s
operator|->
name|s_ab_disconnect
operator|&
name|AB_DISC_USER
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
condition|)
name|sa
operator|->
name|sa_reason
operator|=
name|SC_ABORT
expr_stmt|;
name|sa
operator|->
name|sa_info
operator|=
name|s
operator|->
name|s_udata
operator|,
name|sa
operator|->
name|sa_cc
operator|=
name|s
operator|->
name|s_ulen
expr_stmt|;
name|sa
operator|->
name|sa_realinfo
operator|=
name|s
operator|->
name|s_udata
operator|,
name|s
operator|->
name|s_udata
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* only if transport connection is to be re-used */
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|newspkt
argument_list|(
name|SPDU_AA
argument_list|)
condition|)
block|{
name|s
operator|->
name|s_mask
operator||=
name|SMASK_SPDU_AA
expr_stmt|;
operator|(
name|void
operator|)
name|spkt2sd
argument_list|(
name|s
argument_list|,
name|sb
operator|->
name|sb_fd
argument_list|,
name|sb
operator|->
name|sb_flags
operator|&
name|SB_EXPD
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
expr|struct
name|SSAPindication
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
operator|(
name|void
operator|)
name|spktlose
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"session protocol mangled: not expecting 0x%x"
argument_list|,
name|s
operator|->
name|s_code
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|si
operator|->
name|si_abort
operator|.
name|sa_reason
operator|==
name|SC_TIMER
condition|)
return|return
name|NOTOK
return|;
name|out
label|:
empty_stmt|;
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|freesblk
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* a decision tree (ugh!) */
end_comment

begin_function
name|int
name|SDoCollideAux
parameter_list|(
name|init
parameter_list|,
name|localop
parameter_list|,
name|localssn
parameter_list|,
name|remoteop
parameter_list|,
name|remotessn
parameter_list|)
name|int
name|init
decl_stmt|,
name|localop
decl_stmt|,
name|remoteop
decl_stmt|;
name|long
name|localssn
decl_stmt|,
name|remotessn
decl_stmt|;
block|{
name|SLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"collide: local<%d,%ld,%s> remote<%d,%ld,%s>"
operator|,
name|localop
operator|,
name|localssn
operator|,
name|init
condition|?
literal|"initiator"
else|:
literal|"responder"
operator|,
name|remoteop
operator|,
name|remotessn
operator|,
name|init
condition|?
literal|"responder"
else|:
literal|"initiator"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|localop
operator|==
name|SYNC_DISC
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|remoteop
operator|==
name|SYNC_DISC
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|localop
operator|==
name|SYNC_INTR
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|remoteop
operator|==
name|SYNC_DISC
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|localop
operator|==
name|SYNC_ABANDON
condition|)
block|{
if|if
condition|(
name|remoteop
operator|!=
name|SYNC_ABANDON
condition|)
return|return
name|OK
return|;
return|return
operator|(
name|init
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|remoteop
operator|==
name|SYNC_ABANDON
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|localop
operator|==
name|SYNC_SET
condition|)
block|{
if|if
condition|(
name|remoteop
operator|!=
name|SYNC_SET
condition|)
return|return
name|OK
return|;
return|return
operator|(
name|init
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|remoteop
operator|==
name|SYNC_SET
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|localssn
operator|==
name|remotessn
condition|)
return|return
operator|(
name|init
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
return|return
operator|(
name|localssn
operator|<
name|remotessn
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|define vectors for INDICATION events */
end_comment

begin_function
name|int
name|SSetIndications
parameter_list|(
name|sd
parameter_list|,
name|data
parameter_list|,
name|tokens
parameter_list|,
name|sync
parameter_list|,
name|activity
parameter_list|,
name|report
parameter_list|,
name|finish
parameter_list|,
name|abort
parameter_list|,
name|si
parameter_list|)
name|int
name|sd
decl_stmt|;
name|IFP
name|data
decl_stmt|,
name|tokens
decl_stmt|,
name|sync
decl_stmt|,
name|activity
decl_stmt|,
name|report
decl_stmt|,
name|finish
decl_stmt|,
name|abort
decl_stmt|;
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
if|if
condition|(
name|data
operator|||
name|tokens
operator|||
name|sync
operator|||
name|activity
operator|||
name|report
operator|||
name|finish
operator|||
name|abort
condition|)
block|{
name|missingP
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|sync
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|activity
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|report
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|finish
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|abort
argument_list|)
expr_stmt|;
block|}
name|_iosignals_set
operator|=
literal|1
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|ssapPsig
argument_list|(
name|sb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_DataIndication
operator|=
name|data
condition|)
name|sb
operator|->
name|sb_flags
operator||=
name|SB_ASYN
expr_stmt|;
else|else
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_ASYN
expr_stmt|;
name|sb
operator|->
name|sb_TokenIndication
operator|=
name|tokens
expr_stmt|;
name|sb
operator|->
name|sb_SyncIndication
operator|=
name|sync
expr_stmt|;
name|sb
operator|->
name|sb_ActivityIndication
operator|=
name|activity
expr_stmt|;
name|sb
operator|->
name|sb_ReportIndication
operator|=
name|report
expr_stmt|;
name|sb
operator|->
name|sb_ReleaseIndication
operator|=
name|finish
expr_stmt|;
name|sb
operator|->
name|sb_AbortIndication
operator|=
name|abort
expr_stmt|;
if|if
condition|(
name|TSetIndications
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|TDATAser
argument_list|,
name|TDISCser
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_ASYN
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_reason
operator|==
name|DR_WAITING
condition|)
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_WAITING
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
else|else
return|return
name|ts2sslose
argument_list|(
name|si
argument_list|,
literal|"TSetIndications"
argument_list|,
name|td
argument_list|)
return|;
block|}
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|TSAP interface */
end_comment

begin_function
name|int
name|spkt2sd
parameter_list|(
name|s
parameter_list|,
name|sd
parameter_list|,
name|expedited
parameter_list|,
name|si
parameter_list|)
specifier|register
name|struct
name|ssapkt
modifier|*
name|s
decl_stmt|;
name|int
name|sd
decl_stmt|,
name|expedited
decl_stmt|;
specifier|register
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|result
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
if|if
condition|(
name|expedited
condition|)
name|s
operator|->
name|s_mask
operator||=
name|SMASK_SPDU_EXPD
expr_stmt|;
if|if
condition|(
name|spkt2tsdu
argument_list|(
name|s
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|s
operator|->
name|s_errno
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|s
operator|->
name|s_code
operator|==
name|SPDU_EX
condition|)
block|{
comment|/* only SX_EXSIZE octets, so no big deal... */
if|if
condition|(
name|s
operator|->
name|s_udata
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|realloc
argument_list|(
name|base
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|=
name|len
operator|+
name|s
operator|->
name|s_ulen
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|bcopy
argument_list|(
name|s
operator|->
name|s_udata
argument_list|,
operator|(
name|base
operator|=
name|dp
operator|)
operator|+
name|len
argument_list|,
name|s
operator|->
name|s_ulen
argument_list|)
expr_stmt|;
name|len
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
name|TX_SIZE
condition|)
name|expedited
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|expedited
condition|?
name|TExpdRequest
argument_list|(
name|sd
argument_list|,
name|base
argument_list|,
name|len
argument_list|,
name|td
argument_list|)
else|:
name|TDataRequest
argument_list|(
name|sd
argument_list|,
name|base
argument_list|,
name|len
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|ts2sslose
argument_list|(
name|si
argument_list|,
name|expedited
condition|?
literal|"TExpdRequest"
else|:
literal|"TDataRequest"
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|struct
name|ssapkt
modifier|*
name|sb2spkt
parameter_list|(
name|sb
parameter_list|,
name|si
parameter_list|,
name|secs
parameter_list|,
name|ty
parameter_list|)
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
specifier|register
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
name|int
name|secs
decl_stmt|;
specifier|register
name|struct
name|TSAPdata
modifier|*
name|ty
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|;
specifier|register
name|struct
name|ssapkt
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|TSAPdata
name|txs
decl_stmt|;
specifier|register
name|struct
name|TSAPdata
modifier|*
name|tx
init|=
operator|&
name|txs
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_pr
operator|==
name|SPDU_PR
operator|&&
name|sb
operator|->
name|sb_xspdu
condition|)
block|{
name|SLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"returning XSDU buffered during preparation"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|sb
operator|->
name|sb_xspdu
expr_stmt|;
name|sb
operator|->
name|sb_xspdu
operator|=
name|NULL
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_spdu
condition|)
block|{
comment|/* get previous category 0 SPDU */
name|SLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"returning category 0 SPDU previously buffered"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|sb
operator|->
name|sb_spdu
expr_stmt|;
name|sb
operator|->
name|sb_spdu
operator|=
name|NULL
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|ty
condition|)
block|{
operator|*
name|tx
operator|=
operator|*
name|ty
expr_stmt|;
comment|/* struct copy */
name|tx
operator|->
name|tx_qbuf
operator|.
name|qb_forw
operator|->
name|qb_back
operator|=
name|tx
operator|->
name|tx_qbuf
operator|.
name|qb_back
operator|->
name|qb_forw
operator|=
operator|&
name|tx
operator|->
name|tx_qbuf
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ty
argument_list|,
sizeof|sizeof
expr|*
name|ty
argument_list|)
expr_stmt|;
name|ty
operator|->
name|tx_qbuf
operator|.
name|qb_forw
operator|=
name|ty
operator|->
name|tx_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|ty
operator|->
name|tx_qbuf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TReadRequest
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|tx
argument_list|,
name|secs
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_reason
operator|!=
name|DR_TIMER
condition|)
operator|(
name|void
operator|)
name|ts2sslose
argument_list|(
name|si
argument_list|,
literal|"TReadRequest"
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_TIMER
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|DLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"read TSDU, size %d"
operator|,
name|tx
operator|->
name|tx_cc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|tsdu2spkt
argument_list|(
operator|&
name|tx
operator|->
name|tx_qbuf
argument_list|,
name|tx
operator|->
name|tx_cc
argument_list|,
operator|(
name|cc
operator|=
literal|1
operator|,
operator|&
name|cc
operator|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|s
operator|->
name|s_errno
operator|!=
name|SC_ACCEPT
condition|)
block|{
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|s
condition|?
name|s
operator|->
name|s_errno
else|:
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|bad1
label|:
empty_stmt|;
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TXFREE
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tx
operator|->
name|tx_expedited
condition|)
name|s
operator|->
name|s_mask
operator||=
name|SMASK_SPDU_EXPD
expr_stmt|;
name|tx
operator|->
name|tx_cc
operator|-=
name|cc
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
case|case
name|SPDU_GT
case|:
comment|/* category 0 SPDUs */
case|case
name|SPDU_PT
case|:
if|if
condition|(
name|tx
operator|->
name|tx_cc
operator|<=
literal|0
condition|)
goto|goto
name|simple
goto|;
break|break;
case|case
name|SPDU_EX
case|:
comment|/* category 1 SPDUs with user data */
case|case
name|SPDU_TD
case|:
if|if
condition|(
name|tx
operator|->
name|tx_qbuf
operator|.
name|qb_forw
operator|!=
operator|&
name|tx
operator|->
name|tx_qbuf
condition|)
block|{
name|s
operator|->
name|s_qbuf
operator|=
name|tx
operator|->
name|tx_qbuf
expr_stmt|;
comment|/* struct copy */
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
operator|->
name|qb_back
operator|=
name|s
operator|->
name|s_qbuf
operator|.
name|qb_back
operator|->
name|qb_forw
operator|=
operator|&
name|s
operator|->
name|s_qbuf
expr_stmt|;
name|s
operator|->
name|s_qlen
operator|=
name|tx
operator|->
name|tx_cc
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
name|SPDU_CN
case|:
comment|/* category 1 SPDUs */
case|case
name|SPDU_AC
case|:
case|case
name|SPDU_RF
case|:
case|case
name|SPDU_FN
case|:
case|case
name|SPDU_DN
case|:
case|case
name|SPDU_NF
case|:
case|case
name|SPDU_AB
case|:
case|case
name|SPDU_AA
case|:
case|case
name|SPDU_GTC
case|:
case|case
name|SPDU_GTA
case|:
case|case
name|SPDU_PR
case|:
if|if
condition|(
name|tx
operator|->
name|tx_cc
operator|<=
literal|0
condition|)
block|{
name|simple
label|:
empty_stmt|;
name|TXFREE
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"session protocol mangled: not expecting user information after 0x%x (%d bytes)"
argument_list|,
name|s
operator|->
name|s_code
argument_list|,
name|tx
operator|->
name|tx_cc
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
default|default:
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"session protocol mangled: not expecting 0x%x"
argument_list|,
name|s
operator|->
name|s_code
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
name|sb
operator|->
name|sb_spdu
operator|=
name|p
operator|=
name|s
expr_stmt|;
comment|/* save category 0 SPDU */
if|if
condition|(
operator|(
name|s
operator|=
name|tsdu2spkt
argument_list|(
operator|&
name|tx
operator|->
name|tx_qbuf
argument_list|,
name|tx
operator|->
name|tx_cc
argument_list|,
operator|(
name|cc
operator|=
literal|0
operator|,
operator|&
name|cc
operator|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|s
operator|->
name|s_errno
operator|!=
name|SC_ACCEPT
condition|)
block|{
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|s
condition|?
name|s
operator|->
name|s_errno
else|:
name|SC_CONGEST
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|bad2
label|:
empty_stmt|;
name|freespkt
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|freespkt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_spdu
operator|=
name|NULL
expr_stmt|;
name|TXFREE
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tx
operator|->
name|tx_expedited
condition|)
name|s
operator|->
name|s_mask
operator||=
name|SMASK_SPDU_EXPD
expr_stmt|;
name|tx
operator|->
name|tx_cc
operator|-=
name|cc
expr_stmt|;
switch|switch
condition|(
operator|(
name|p
operator|->
name|s_code
operator|)
operator|<<
literal|8
operator||
name|s
operator|->
name|s_code
condition|)
block|{
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_DT
case|:
comment|/* category 2 SPDUs with user data */
if|if
condition|(
name|tx
operator|->
name|tx_qbuf
operator|.
name|qb_forw
operator|!=
operator|&
name|tx
operator|->
name|tx_qbuf
condition|)
block|{
name|s
operator|->
name|s_qbuf
operator|=
name|tx
operator|->
name|tx_qbuf
expr_stmt|;
comment|/* struct copy */
name|s
operator|->
name|s_qbuf
operator|.
name|qb_forw
operator|->
name|qb_back
operator|=
name|s
operator|->
name|s_qbuf
operator|.
name|qb_back
operator|->
name|qb_forw
operator|=
operator|&
name|s
operator|->
name|s_qbuf
expr_stmt|;
name|s
operator|->
name|s_qlen
operator|=
name|tx
operator|->
name|tx_cc
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_MIP
case|:
comment|/* category 2 SPDUs */
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_MIA
case|:
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_MAP
case|:
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_MAA
case|:
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_RS
case|:
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_RA
case|:
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_AS
case|:
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_AR
case|:
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_AD
case|:
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_ADA
case|:
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_AI
case|:
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_AIA
case|:
ifdef|#
directive|ifdef
name|notdef
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_AE
case|:
comment|/* aka SPDU_MAP */
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_AEA
case|:
comment|/* aka SPDU_MAA */
endif|#
directive|endif
case|case
operator|(
name|SPDU_GT
operator|<<
literal|8
operator|)
operator||
name|SPDU_CD
case|:
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_CDA
case|:
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_ER
case|:
case|case
operator|(
name|SPDU_PT
operator|<<
literal|8
operator|)
operator||
name|SPDU_ED
case|:
if|if
condition|(
name|tx
operator|->
name|tx_cc
operator|<=
literal|0
condition|)
block|{
name|TXFREE
argument_list|(
name|tx
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"session protocol mangled: not expecting user information after 0x%x (%d bytes)"
argument_list|,
name|s
operator|->
name|s_code
argument_list|,
name|tx
operator|->
name|tx_cc
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
default|default:
operator|(
name|void
operator|)
name|ssaplose
argument_list|(
name|si
argument_list|,
name|SC_PROTOCOL
argument_list|,
name|NULLCP
argument_list|,
literal|"session protocol mangled: not expecting 0x%x to be concatenated after 0x%x"
argument_list|,
name|s
operator|->
name|s_code
argument_list|,
name|p
operator|->
name|s_code
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
switch|switch
condition|(
name|s
operator|->
name|s_code
condition|)
block|{
default|default:
if|if
condition|(
name|p
operator|->
name|s_code
operator|==
name|SPDU_GT
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|s_mask
operator|&
name|SMASK_GT_TOKEN
operator|)
operator|&&
name|p
operator|->
name|s_gt_token
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|s_mask
operator|&
name|SMASK_PT_TOKEN
operator|)
operator|&&
name|p
operator|->
name|s_pt_token
operator|)
operator|||
name|p
operator|->
name|s_ulen
condition|)
break|break;
block|}
comment|/* fall... */
case|case
name|SPDU_RS
case|:
case|case
name|SPDU_AD
case|:
case|case
name|SPDU_AI
case|:
case|case
name|SPDU_CD
case|:
name|freespkt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_spdu
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|TDATAser
parameter_list|(
name|sd
parameter_list|,
name|tx
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|TSAPdata
modifier|*
name|tx
decl_stmt|;
block|{
name|IFP
name|abort
decl_stmt|;
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|struct
name|SSAPdata
name|sxs
decl_stmt|;
specifier|register
name|struct
name|SSAPdata
modifier|*
name|sx
init|=
operator|&
name|sxs
decl_stmt|;
name|struct
name|SSAPindication
name|sis
decl_stmt|;
specifier|register
name|struct
name|SSAPindication
modifier|*
name|si
init|=
operator|&
name|sis
decl_stmt|;
specifier|register
name|struct
name|SSAPabort
modifier|*
name|sa
init|=
operator|&
name|si
operator|->
name|si_abort
decl_stmt|;
if|if
condition|(
operator|(
name|sb
operator|=
name|findsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|abort
operator|=
name|sb
operator|->
name|sb_AbortIndication
expr_stmt|;
for|for
control|(
init|;
condition|;
name|tx
operator|=
name|NULLTX
control|)
block|{
switch|switch
condition|(
name|SReadRequestAux
argument_list|(
name|sb
argument_list|,
name|sx
argument_list|,
name|OK
argument_list|,
name|si
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
call|(
modifier|*
name|abort
call|)
argument_list|(
name|sd
argument_list|,
name|sa
argument_list|)
expr_stmt|;
return|return;
case|case
name|OK
case|:
call|(
modifier|*
name|sb
operator|->
name|sb_DataIndication
call|)
argument_list|(
name|sd
argument_list|,
name|sx
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONE
case|:
switch|switch
condition|(
name|si
operator|->
name|si_type
condition|)
block|{
case|case
name|SI_TOKEN
case|:
call|(
modifier|*
name|sb
operator|->
name|sb_TokenIndication
call|)
argument_list|(
name|sd
argument_list|,
operator|&
name|si
operator|->
name|si_token
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_SYNC
case|:
call|(
modifier|*
name|sb
operator|->
name|sb_SyncIndication
call|)
argument_list|(
name|sd
argument_list|,
operator|&
name|si
operator|->
name|si_sync
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_ACTIVITY
case|:
call|(
modifier|*
name|sb
operator|->
name|sb_ActivityIndication
call|)
argument_list|(
name|sd
argument_list|,
operator|&
name|si
operator|->
name|si_activity
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_REPORT
case|:
call|(
modifier|*
name|sb
operator|->
name|sb_ReportIndication
call|)
argument_list|(
name|sd
argument_list|,
operator|&
name|si
operator|->
name|si_report
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_FINISH
case|:
call|(
modifier|*
name|sb
operator|->
name|sb_ReleaseIndication
call|)
argument_list|(
name|sd
argument_list|,
operator|&
name|si
operator|->
name|si_finish
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_DATA
case|:
comment|/* partially assembled (T)SSDU */
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_spdu
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|TDISCser
parameter_list|(
name|sd
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|IFP
name|abort
decl_stmt|;
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|struct
name|SSAPindication
name|sis
decl_stmt|;
specifier|register
name|struct
name|SSAPindication
modifier|*
name|si
init|=
operator|&
name|sis
decl_stmt|;
if|if
condition|(
operator|(
name|sb
operator|=
name|findsblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|ts2sslose
argument_list|(
name|si
argument_list|,
name|NULLCP
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|abort
operator|=
name|sb
operator|->
name|sb_AbortIndication
expr_stmt|;
name|sb
operator|->
name|sb_fd
operator|=
name|NOTOK
expr_stmt|;
operator|(
name|void
operator|)
name|freesblk
argument_list|(
name|sb
argument_list|)
expr_stmt|;
call|(
modifier|*
name|abort
call|)
argument_list|(
name|sd
argument_list|,
operator|&
name|si
operator|->
name|si_abort
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|ts2sslose
parameter_list|(
name|si
parameter_list|,
name|event
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|SSAPindication
modifier|*
name|si
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|reason
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|event
condition|)
name|SLOG
argument_list|(
name|ssap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|td
operator|->
name|td_cc
operator|>
literal|0
condition|?
literal|"%s: %s [%*.*s]"
else|:
literal|"%s: %s"
operator|,
name|event
operator|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
operator|,
name|td
operator|->
name|td_cc
operator|,
name|td
operator|->
name|td_cc
operator|,
name|td
operator|->
name|td_data
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_reason
condition|)
block|{
case|case
name|DR_REMOTE
case|:
case|case
name|DR_CONGEST
case|:
name|reason
operator|=
name|SC_CONGEST
expr_stmt|;
break|break;
case|case
name|DR_SESSION
case|:
case|case
name|DR_ADDRESS
case|:
name|reason
operator|=
name|SC_ADDRESS
expr_stmt|;
break|break;
case|case
name|DR_REFUSED
case|:
name|reason
operator|=
name|SC_REFUSED
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|" (%s at transport)"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|DR_NETWORK
case|:
name|reason
operator|=
name|SC_TRANSPORT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|td
operator|->
name|td_cc
operator|>
literal|0
condition|)
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|reason
argument_list|,
name|NULLCP
argument_list|,
literal|"%*.*s%s"
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_data
argument_list|,
name|cp
argument_list|)
return|;
else|else
return|return
name|ssaplose
argument_list|(
name|si
argument_list|,
name|reason
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|cp
condition|?
name|cp
operator|+
literal|1
else|:
name|cp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|INTERNAL */
end_comment

begin_function
name|struct
name|ssapblk
modifier|*
name|newsblk
parameter_list|()
block|{
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
operator|(
expr|struct
name|ssapblk
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sb
operator|->
name|sb_fd
operator|=
name|NOTOK
expr_stmt|;
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_forw
operator|=
name|sb
operator|->
name|sb_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|sb
operator|->
name|sb_qbuf
expr_stmt|;
name|sb
operator|->
name|sb_pr
operator|=
name|SPDU_PR
expr_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|SHead
operator|->
name|sb_forw
operator|=
name|SHead
operator|->
name|sb_back
operator|=
name|SHead
expr_stmt|;
name|once_only
operator|++
expr_stmt|;
block|}
name|insque
argument_list|(
name|sb
argument_list|,
name|SHead
operator|->
name|sb_back
argument_list|)
expr_stmt|;
return|return
name|sb
return|;
block|}
end_function

begin_function
name|int
name|freesblk
parameter_list|(
name|sb
parameter_list|)
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
block|{
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sb
operator|->
name|sb_fd
operator|!=
name|NOTOK
condition|)
block|{
name|struct
name|TSAPdata
name|txs
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_FINN
condition|)
comment|/* Wait for a TDiscInd for ses_dn_timer seconds */
if|if
condition|(
name|ses_dn_timer
operator|>=
literal|0
condition|)
while|while
condition|(
name|TReadRequest
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
operator|&
name|txs
argument_list|,
name|ses_dn_timer
argument_list|,
operator|&
name|tds
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|TXFREE
argument_list|(
operator|&
name|txs
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|TDiscRequest
argument_list|(
name|sb
operator|->
name|sb_fd
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
operator|&
name|tds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_retry
condition|)
block|{
name|sb
operator|->
name|sb_retry
operator|->
name|s_mask
operator|&=
operator|~
name|SMASK_UDATA_PGI
expr_stmt|;
name|sb
operator|->
name|sb_retry
operator|->
name|s_udata
operator|=
name|NULL
operator|,
name|sb
operator|->
name|sb_retry
operator|->
name|s_ulen
operator|=
literal|0
expr_stmt|;
name|freespkt
argument_list|(
name|sb
operator|->
name|sb_retry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|->
name|sb_xspdu
condition|)
name|freespkt
argument_list|(
name|sb
operator|->
name|sb_xspdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_spdu
condition|)
name|freespkt
argument_list|(
name|sb
operator|->
name|sb_spdu
argument_list|)
expr_stmt|;
name|QBFREE
argument_list|(
operator|&
name|sb
operator|->
name|sb_qbuf
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|struct
name|ssapblk
modifier|*
name|findsblk
parameter_list|(
name|sd
parameter_list|)
specifier|register
name|int
name|sd
decl_stmt|;
block|{
specifier|register
name|struct
name|ssapblk
modifier|*
name|sb
decl_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|sb
operator|=
name|SHead
operator|->
name|sb_forw
init|;
name|sb
operator|!=
name|SHead
condition|;
name|sb
operator|=
name|sb
operator|->
name|sb_forw
control|)
if|if
condition|(
name|sb
operator|->
name|sb_fd
operator|==
name|sd
condition|)
return|return
name|sb
return|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

