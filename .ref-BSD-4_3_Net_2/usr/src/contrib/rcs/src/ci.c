begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Walter Tichy.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Report all problems and direct all questions to:  *   rcs-bugs@cs.purdue.edu  *         */
end_comment

begin_comment
comment|/*  *                     RCS checkin operation  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/local/bin/rcs/src/RCS/ci.c,v 4.9 89/05/01 15:10:54 narten Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************************  *                       check revisions into RCS files  *******************************************************************  */
end_comment

begin_comment
comment|/* $Log:	ci.c,v $  * Revision 4.9  89/05/01  15:10:54  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.8  88/11/08  13:38:23  narten  * changes from root@seismo.CSS.GOV (Super User)  * -d with no arguments uses the mod time of the file it is checking in  *   * Revision 4.7  88/11/08  10:59:04  narten  * changes from eggert  *   * Revision 4.7  88/08/09  19:12:07  eggert  * Make sure workfile is a regular file; use its mode if RCSfile doesn't have one.  * Use execv(), not system(); allow cc -R; remove lint.  * isatty(fileno(stdin)) -> ttystdin()  *   * Revision 4.6  87/12/18  11:34:41  narten  * lint cleanups (from Guy Harris)  *   * Revision 4.5  87/10/18  10:18:48  narten  * Updating version numbers. Changes relative to revision 1.1 are actually  * relative to 4.3  *   * Revision 1.3  87/09/24  13:57:19  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:21:33  jenkins  * Port to suns  *   * Revision 1.1  84/01/23  14:49:54  kcs  * Initial revision  *   * Revision 4.3  83/12/15  12:28:54  wft  * ci -u and ci -l now set mode of working file properly.  *   * Revision 4.2  83/12/05  13:40:54  wft  * Merged with 3.9.1.1: added calls to clearerr(stdin).  * made rewriteflag external.  *   * Revision 4.1  83/05/10  17:03:06  wft  * Added option -d and -w, and updated assingment of date, etc. to new delta.  * Added handling of default branches.  * Option -k generates std. log message; fixed undef. pointer in reading of log.  * Replaced getlock() with findlock(), link--unlink with rename(),  * getpwuid() with getcaller().  * Moved all revision number generation to new routine addelta().  * Removed calls to stat(); now done by pairfilenames().  * Changed most calls to catchints() with restoreints().  * Directed all interactive messages to stderr.  *   * Revision 3.9.1.1  83/10/19  04:21:03  lepreau  * Added clearerr(stdin) to getlogmsg() for re-reading stdin.  *   * Revision 3.9  83/02/15  15:25:44  wft  * 4.2 prerelease  *   * Revision 3.9  83/02/15  15:25:44  wft  * Added call to fastcopy() to copy remainder of RCS file.  *  * Revision 3.8  83/01/14  15:34:05  wft  * Added ignoring of interrupts while new RCS file is renamed;  * Avoids deletion of RCS files by interrupts.  *  * Revision 3.7  82/12/10  16:09:20  wft  * Corrected checking of return code from diff.  *  * Revision 3.6  82/12/08  21:34:49  wft  * Using DATEFORM to prepare date of checked-in revision;  * Fixed return from addbranch().  *  * Revision 3.5  82/12/04  18:32:42  wft  * Replaced getdelta() with gettree(), SNOOPDIR with SNOOPFILE. Updated  * field lockedby in removelock(), moved getlogmsg() before calling diff.  *  * Revision 3.4  82/12/02  13:27:13  wft  * added option -k.  *  * Revision 3.3  82/11/28  20:53:31  wft  * Added mustcheckin() to check for redundant checkins.  * Added xpandfile() to do keyword expansion for -u and -l;  * -m appends linefeed to log message if necessary.  * getlogmsg() suppresses prompt if stdin is not a terminal.  * Replaced keeplock with lockflag, fclose() with ffclose(),  * %02d with %.2d, getlogin() with getpwuid().  *  * Revision 3.2  82/10/18  20:57:23  wft  * An RCS file inherits its mode during the first ci from the working file,  * otherwise it stays the same, except that write permission is removed.  * Fixed ci -l, added ci -u (both do an implicit co after the ci).  * Fixed call to getlogin(), added call to getfullRCSname(), added check  * for write error.  * Changed conflicting identifiers.  *  * Revision 3.1  82/10/13  16:04:59  wft  * fixed type of variables receiving from getc() (char -> int).  * added include file dbm.h for getting BYTESIZ. This is used  * to check the return code from diff portably.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsbaseid
index|[]
init|=
name|RCSBASE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_function_decl
specifier|extern
name|int
name|rename
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*rename files                       */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getcaller
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*login of caller                    */
end_comment

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|genrevs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*generate delta numbers             */
end_comment

begin_extern
extern|extern quietflag;
end_extern

begin_comment
comment|/*suppresses diagnostics if true     */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*counter for errors                 */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|buildrevision
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*constructs desired revision        */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|checkid
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*check identifiers                  */
end_comment

begin_function_decl
specifier|extern
name|int
name|partime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*parse free-format date/time        */
end_comment

begin_function_decl
specifier|extern
name|long
name|maketime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*convert parsed time to unix time.  */
end_comment

begin_function_decl
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*get date and time                  */
end_comment

begin_function_decl
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*convert unixtime into tm-structure */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getdate
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*formates current date  (forward)   */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktempfile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*temporary file name generator      */
end_comment

begin_function_decl
specifier|extern
name|struct
name|lock
modifier|*
name|addlock
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*adds a new lock                    */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getlogmsg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*obtains log message; forward       */
end_comment

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|removelock
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*finds a caller's lock  (forward)   */
end_comment

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|findlock
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*finds a lock                       */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|xpandfile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*perform keyword expansion; forward */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|prevauthor
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|prevdate
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|prevrev
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|prevstate
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file                    */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new RCS file                      */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether input should be */
end_comment

begin_comment
comment|/* echoed to frewrite                */
end_comment

begin_decl_stmt
name|char
modifier|*
name|newRCSfilename
decl_stmt|,
modifier|*
name|diffilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|,
modifier|*
name|expfilename
decl_stmt|,
modifier|*
name|newworkfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|RCSstat
decl_stmt|,
name|workstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file status of RCS and work file   */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|haveRCSstat
decl_stmt|,
name|haveworkstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status indicators                  */
end_comment

begin_decl_stmt
name|int
name|copyflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether a string should be copied into memory*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|state
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|initflag
decl_stmt|,
name|rcsinitflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lockflag
decl_stmt|,
name|keepworkingfile
decl_stmt|,
name|keepflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forceciflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forces check in                    */
end_comment

begin_decl_stmt
name|int
name|symrebindflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|textflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|textfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|caller
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* caller's login;                    */
end_comment

begin_decl_stmt
name|char
modifier|*
name|author
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate author for -w option     */
end_comment

begin_decl_stmt
name|char
name|altdate
index|[
name|datelength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate date for -d              */
end_comment

begin_decl_stmt
name|int
name|usestatdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use mod time of file for -d 	    */
end_comment

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|targetdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old delta to be generated          */
end_comment

begin_decl_stmt
name|char
modifier|*
name|olddeltanum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of old delta                */
end_comment

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|gendeltas
index|[
name|hshsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stores deltas to be generated      */
end_comment

begin_decl_stmt
name|char
name|newdelnum
index|[
name|revlength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds new revision number          */
end_comment

begin_decl_stmt
name|int
name|newdnumlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual length of new rev. num.     */
end_comment

begin_decl_stmt
name|char
name|branchpointnum
index|[
name|revlength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of branchpoint              */
end_comment

begin_decl_stmt
name|struct
name|hshentry
name|newdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new delta to be inserted           */
end_comment

begin_decl_stmt
name|struct
name|branchhead
name|newbranch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new branch to be inserted          */
end_comment

begin_decl_stmt
name|char
name|logmsg
index|[
name|logsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for log message             */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|nametest
decl_stmt|;
name|char
modifier|*
name|cmdusage
decl_stmt|;
comment|/* holds command format                    */
name|struct
name|stat
name|filestatus
decl_stmt|;
comment|/* used for getting the mode               */
name|int
name|msglen
decl_stmt|;
comment|/* length of message given by -m           */
name|int
name|exit_stats
decl_stmt|;
comment|/* return code for command invocations     */
name|int
name|newRCSmode
decl_stmt|;
comment|/* mode for RCS file                       */
name|long
name|unixtime
decl_stmt|;
name|struct
name|tm
name|parseddate
decl_stmt|,
modifier|*
name|ftm
decl_stmt|;
name|catchints
argument_list|()
expr_stmt|;
name|cmdid
operator|=
literal|"ci"
expr_stmt|;
name|cmdusage
operator|=
literal|"command format:\nci -r[rev] -l[rev] -u[rev] -f[rev] -k[rev] -q[rev] -mmsg -nname -Nname -sstate -t[txtfile] file ..."
expr_stmt|;
name|rev
operator|=
name|state
operator|=
name|msg
operator|=
name|symbol
operator|=
name|textfile
operator|=
name|nil
expr_stmt|;
name|initflag
operator|=
name|rcsinitflag
operator|=
name|symrebindflag
operator|=
name|textflag
operator|=
name|quietflag
operator|=
name|false
expr_stmt|;
name|forceciflag
operator|=
name|lockflag
operator|=
name|keepworkingfile
operator|=
name|keepflag
operator|=
name|false
expr_stmt|;
name|caller
operator|=
name|getcaller
argument_list|()
expr_stmt|;
name|author
operator|=
name|nil
expr_stmt|;
comment|/* author may be reset by -w */
name|altdate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* empty alternate date for -d */
name|usestatdate
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|lockflag
operator|=
name|false
expr_stmt|;
name|revno
label|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|rev
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of revision number"
argument_list|)
expr_stmt|;
name|rev
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
name|keepworkingfile
operator|=
name|lockflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'u'
case|:
name|keepworkingfile
operator|=
name|true
expr_stmt|;
name|lockflag
operator|=
name|false
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'f'
case|:
name|forceciflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'k'
case|:
name|keepflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|msg
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -m option"
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|msglen
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|>=
name|logsize
condition|)
block|{
name|warn
argument_list|(
literal|"log message truncated to %d characters"
argument_list|,
name|logsize
argument_list|)
expr_stmt|;
name|msg
index|[
name|logsize
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|msg
index|[
name|logsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|msg
index|[
name|msglen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/*append linefeed*/
name|VOID
name|strcpy
argument_list|(
name|logmsg
argument_list|,
name|msg
argument_list|)
decl_stmt|;
name|msg
operator|=
name|logmsg
expr_stmt|;
name|msg
index|[
name|msglen
index|]
operator|=
literal|'\n'
expr_stmt|;
name|msg
index|[
operator|++
name|msglen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
name|warn
argument_list|(
literal|"Missing message for -m option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|symrebindflag
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|symbol
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of symbolic name"
argument_list|)
expr_stmt|;
name|symbol
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nametest
operator|=
name|checkid
argument_list|(
name|symbol
argument_list|,
literal|' '
argument_list|)
operator|)
operator|||
operator|*
name|nametest
condition|)
name|faterror
argument_list|(
literal|"Name %s must be one word"
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Missing name for -n option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|symrebindflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|symbol
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of symbolic name"
argument_list|)
expr_stmt|;
name|symbol
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nametest
operator|=
name|checkid
argument_list|(
name|symbol
argument_list|,
literal|' '
argument_list|)
operator|)
operator|||
operator|*
name|nametest
condition|)
name|faterror
argument_list|(
literal|"Name %s must be one word"
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Missing name for -N option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -s option"
argument_list|)
expr_stmt|;
name|state
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|VOID
name|checkid
argument_list|(
name|state
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Missing state for -s option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|textflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|textfile
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -t option"
argument_list|)
expr_stmt|;
name|textfile
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|altdate
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|usestatdate
operator|==
name|true
condition|)
name|warn
argument_list|(
literal|"Redefinition of -d option"
argument_list|)
expr_stmt|;
comment|/* process the date */
if|if
condition|(
name|partime
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|,
operator|&
name|parseddate
argument_list|)
operator|==
literal|0
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't parse date/time: %s"
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|unixtime
operator|=
name|maketime
argument_list|(
operator|&
name|parseddate
argument_list|)
operator|)
operator|==
literal|0L
condition|)
block|{
name|faterror
argument_list|(
literal|"Inconsistent date/time: %s"
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|altdate
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
decl_stmt|;
block|}
else|else
name|usestatdate
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|author
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -w option"
argument_list|)
expr_stmt|;
name|author
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|VOID
name|checkid
argument_list|(
name|author
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Missing author for -w option"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s\n%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end processing of options */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"No input file\n%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttystdin
argument_list|()
operator|&&
name|msg
operator|==
name|nil
operator|&&
name|textflag
operator|&&
name|textfile
operator|==
name|nil
condition|)
block|{
comment|/* would need both log message and descriptive text from a file */
name|faterror
argument_list|(
literal|"Can't take both log and description from redirected stdin; use -ttextfile"
argument_list|)
expr_stmt|;
block|}
comment|/* now handle all filenames */
do|do
block|{
name|gendeltas
index|[
literal|0
index|]
operator|=
name|nil
expr_stmt|;
name|copyflag
operator|=
name|rewriteflag
operator|=
name|false
expr_stmt|;
name|finptr
operator|=
name|frewrite
operator|=
name|NULL
expr_stmt|;
name|targetdelta
operator|=
name|nil
expr_stmt|;
name|olddeltanum
operator|=
name|nil
expr_stmt|;
switch|switch
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* New RCS file */
name|initflag
operator|=
name|true
expr_stmt|;
name|rcsinitflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Error */
continue|continue;
case|case
literal|1
case|:
comment|/* Normal checkin with prev . RCS file */
name|initflag
operator|=
name|false
expr_stmt|;
name|rcsinitflag
operator|=
operator|(
name|Head
operator|==
name|nil
operator|)
expr_stmt|;
block|}
comment|/* now RCSfilename contains the name of the RCS file, and          * workfilename contains the name of the working file.          * if !initflag, finptr contains the file descriptor for the          * RCS file. The admin node is initialized.          * workstat and RCSstat are set.          */
name|diagnose
argument_list|(
literal|"%s<--  %s"
argument_list|,
name|RCSfilename
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|workfilename
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"working file %s not readable or nonexistent"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          * make sure workfile is a regular file.          */
name|VOID
name|stat
argument_list|(
name|workfilename
argument_list|,
operator|&
name|filestatus
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|filestatus
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|error
argument_list|(
literal|"working file %s isn't a regular file"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          * if RCSfile doesn't exist, use mode from workfile, otherwise          * keep the one from the RCSfile.          */
if|if
condition|(
operator|!
operator|(
name|initflag
operator|||
name|rcsinitflag
operator|)
condition|)
name|VOID
name|fstat
argument_list|(
name|fileno
argument_list|(
name|finptr
argument_list|)
argument_list|,
operator|&
name|filestatus
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|trydiraccess
argument_list|(
name|RCSfilename
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
operator|!
name|initflag
operator|&&
operator|!
name|checkaccesslist
argument_list|(
name|caller
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
operator|!
name|trysema
argument_list|(
name|RCSfilename
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
name|keepflag
condition|)
block|{
comment|/* get keyword values from working file */
if|if
condition|(
operator|!
name|getoldkeys
argument_list|(
name|workfilename
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rev
operator|==
name|nil
operator|&&
operator|*
operator|(
name|rev
operator|=
name|prevrev
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Can't find a revision number in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|prevdate
operator|==
literal|'\0'
operator|&&
operator|*
name|altdate
operator|==
literal|'\0'
operator|&&
name|usestatdate
operator|==
name|false
condition|)
name|warn
argument_list|(
literal|"Can't find a date in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prevauthor
operator|==
literal|'\0'
operator|&&
name|author
operator|==
name|nil
condition|)
name|warn
argument_list|(
literal|"Can't find an author in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prevstate
operator|==
literal|'\0'
operator|&&
name|state
operator|==
name|nil
condition|)
name|warn
argument_list|(
literal|"Can't find a state in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
block|}
comment|/* end processing keepflag */
name|gettree
argument_list|()
expr_stmt|;
comment|/* reads in the delta tree.*/
comment|/* expand symbolic revision number */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|rev
argument_list|,
name|newdelnum
argument_list|)
condition|)
continue|continue;
comment|/* splice new delta into tree */
if|if
condition|(
operator|!
name|addelta
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|initflag
operator|||
name|rcsinitflag
condition|)
block|{
name|diagnose
argument_list|(
literal|"initial revision: %s"
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
block|}
else|else
name|diagnose
argument_list|(
literal|"new revision: %s; previous revision: %s"
argument_list|,
name|newdelnum
argument_list|,
name|olddeltanum
argument_list|)
expr_stmt|;
name|newdelta
operator|.
name|num
operator|=
name|newdelnum
expr_stmt|;
name|newdelta
operator|.
name|branches
operator|=
name|nil
expr_stmt|;
name|newdelta
operator|.
name|log
operator|=
name|nil
expr_stmt|;
name|newdelta
operator|.
name|lockedby
operator|=
name|nil
expr_stmt|;
comment|/*might be changed by addlock() */
comment|/* set author */
if|if
condition|(
name|author
operator|!=
name|nil
condition|)
name|newdelta
operator|.
name|author
operator|=
name|author
expr_stmt|;
comment|/* set author given by -w         */
name|elsif
argument_list|(
argument|keepflag&& *prevauthor!=
literal|'\0'
argument_list|)
name|newdelta
operator|.
name|author
operator|=
name|prevauthor
expr_stmt|;
comment|/* preserve old author of possible*/
else|else
name|newdelta
operator|.
name|author
operator|=
name|caller
expr_stmt|;
comment|/* otherwise use caller's id      */
if|if
condition|(
name|state
operator|!=
name|nil
condition|)
name|newdelta
operator|.
name|state
operator|=
name|state
expr_stmt|;
comment|/* set state given by -s          */
name|elsif
argument_list|(
argument|keepflag&& *prevstate!=
literal|'\0'
argument_list|)
name|newdelta
operator|.
name|state
operator|=
name|prevstate
expr_stmt|;
comment|/* preserve old state if possilbe */
else|else
name|newdelta
operator|.
name|state
operator|=
name|DEFAULTSTATE
expr_stmt|;
comment|/* otherwise use default state    */
if|if
condition|(
name|usestatdate
operator|==
name|true
condition|)
block|{
if|if
condition|(
name|haveworkstat
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"can't stat %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|workstat
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|altdate
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
operator|*
name|altdate
operator|!=
literal|'\0'
condition|)
name|newdelta
operator|.
name|date
operator|=
name|altdate
expr_stmt|;
comment|/* set date given by -d           */
name|elsif
argument_list|(
argument|keepflag&& *prevdate!=
literal|'\0'
argument_list|)
comment|/* preserve old date if possible  */
name|newdelta
operator|.
name|date
operator|=
name|prevdate
expr_stmt|;
else|else
name|newdelta
operator|.
name|date
operator|=
name|getdate
argument_list|()
expr_stmt|;
comment|/* use current date               */
comment|/* now check validity of date -- needed because of -d and -k          */
if|if
condition|(
name|targetdelta
operator|!=
name|nil
operator|&&
name|cmpnum
argument_list|(
name|newdelta
operator|.
name|date
argument_list|,
name|targetdelta
operator|->
name|date
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Date %s is not later than %s in existing revision %s"
argument_list|,
name|newdelta
operator|.
name|date
argument_list|,
name|targetdelta
operator|->
name|date
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lockflag
operator|&&
operator|!
name|addlock
argument_list|(
operator|&
name|newdelta
argument_list|,
name|caller
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|symbol
operator|&&
operator|!
name|addsymbol
argument_list|(
operator|&
name|newdelta
argument_list|,
name|symbol
argument_list|,
name|symrebindflag
argument_list|)
condition|)
continue|continue;
comment|/* prepare for rewriting the RCS file */
name|newRCSfilename
operator|=
name|mktempfile
argument_list|(
name|RCSfilename
argument_list|,
name|NEWRCSFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frewrite
operator|=
name|fopen
argument_list|(
name|newRCSfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Can't open file %s"
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|putadmin
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|putdesc
argument_list|(
name|initflag
argument_list|,
name|textflag
argument_list|,
name|textfile
argument_list|,
name|quietflag
argument_list|)
expr_stmt|;
comment|/* build rest of file */
if|if
condition|(
name|initflag
operator|||
name|rcsinitflag
condition|)
block|{
comment|/* get logmessage */
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|newdelnum
argument_list|,
name|newdelta
operator|.
name|log
argument_list|,
name|workfilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
name|ffclose
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|frewrite
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|diffilename
operator|=
name|mktempfile
argument_list|(
literal|"/tmp/"
argument_list|,
name|DIFFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|newdelta
operator|==
name|Head
condition|)
block|{
comment|/* prepend new one */
name|rewriteflag
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expfilename
operator|=
name|buildrevision
argument_list|(
name|gendeltas
argument_list|,
name|targetdelta
argument_list|,
literal|"/tmp/"
argument_list|,
name|false
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mustcheckin
argument_list|(
name|expfilename
argument_list|,
name|targetdelta
argument_list|)
condition|)
continue|continue;
comment|/* don't check in files that aren't different, unless forced*/
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
name|exit_stats
operator|=
name|run
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|diffilename
argument_list|,
name|DIFF
argument_list|,
literal|"-n"
argument_list|,
name|workfilename
argument_list|,
name|expfilename
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_stats
operator|!=
literal|0
operator|&&
name|exit_stats
operator|!=
operator|(
literal|1
operator|<<
name|BYTESIZ
operator|)
condition|)
name|faterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
comment|/* diff returns 2 in the upper byte on failure */
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|newdelnum
argument_list|,
name|newdelta
operator|.
name|log
argument_list|,
name|workfilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|olddeltanum
argument_list|,
name|targetdelta
operator|->
name|log
argument_list|,
name|diffilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* insert new delta text */
name|rewriteflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expfilename
operator|=
name|buildrevision
argument_list|(
name|gendeltas
argument_list|,
name|targetdelta
argument_list|,
literal|"/tmp/"
argument_list|,
name|false
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mustcheckin
argument_list|(
name|expfilename
argument_list|,
name|targetdelta
argument_list|)
condition|)
continue|continue;
comment|/* don't check in files that aren't different, unless forced*/
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
name|exit_stats
operator|=
name|run
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|diffilename
argument_list|,
name|DIFF
argument_list|,
literal|"-n"
argument_list|,
name|expfilename
argument_list|,
name|workfilename
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_stats
operator|!=
literal|0
operator|&&
name|exit_stats
operator|!=
operator|(
literal|1
operator|<<
name|BYTESIZ
operator|)
condition|)
name|faterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|newdelnum
argument_list|,
name|newdelta
operator|.
name|log
argument_list|,
name|diffilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
block|}
comment|/* rewrite rest of RCS file */
name|fastcopy
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|frewrite
operator|=
name|NULL
expr_stmt|;
block|}
name|ignoreints
argument_list|()
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|newRCSfilename
argument_list|,
name|RCSfilename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't write new RCS file %s; saved in %s"
argument_list|,
name|RCSfilename
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
name|newRCSfilename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* avoid deletion by cleanup*/
name|restoreints
argument_list|()
expr_stmt|;
name|VOID
name|cleanup
parameter_list|()
function_decl|;
break|break;
block|}
name|newRCSfilename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* avoid re-unlinking by cleanup()*/
name|newRCSmode
operator|=
operator|(
name|initflag
operator||
name|rcsinitflag
condition|?
name|workstat
operator|.
name|st_mode
else|:
name|RCSstat
operator|.
name|st_mode
operator|)
operator|&
operator|~
literal|0222
expr_stmt|;
comment|/* newRCSmode is also used to adjust mode of working file for -u and -l */
if|if
condition|(
name|chmod
argument_list|(
name|RCSfilename
argument_list|,
name|newRCSmode
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"Can't set mode of %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SNOOPFILE
name|logcommand
argument_list|(
literal|"ci"
argument_list|,
operator|&
name|newdelta
argument_list|,
name|gendeltas
argument_list|,
name|caller
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|keepworkingfile
condition|)
block|{
name|VOID
name|unlink
argument_list|(
name|workfilename
argument_list|)
decl_stmt|;
comment|/* get rid of old file */
block|}
else|else
block|{
comment|/* expand keywords in file */
name|newworkfilename
operator|=
name|xpandfile
argument_list|(
name|workfilename
argument_list|,
name|workfilename
comment|/*for directory*/
argument_list|,
operator|&
name|newdelta
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newworkfilename
condition|)
continue|continue;
comment|/* expand failed */
name|ignoreints
argument_list|()
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|newworkfilename
argument_list|,
name|workfilename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't expand keywords in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|newworkfilename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* avoid re-unlink by cleanup */
if|if
condition|(
name|chmod
argument_list|(
name|workfilename
argument_list|,
name|WORKMODE
argument_list|(
name|newRCSmode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"Can't adjust mode of %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
block|}
name|diagnose
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|exit
argument_list|(
name|nerror
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* end of main (ci) */
end_comment

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/* the rest are auxiliary routines                               */
end_comment

begin_function
name|int
name|addelta
parameter_list|()
comment|/* Function: Appends a delta to the delta tree, whose number is  * given by newdelnum[]. Updates Head, newdelnum, newdenumlength,  * olddeltanum and the links in newdelta.  * Retruns false on error, true on success.  */
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|newdnumlength
operator|=
name|countnumflds
argument_list|(
name|newdelnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|initflag
operator|||
name|rcsinitflag
condition|)
block|{
comment|/* this covers non-existing RCS file and a file initialized with rcs -i */
if|if
condition|(
operator|(
name|newdnumlength
operator|==
literal|0
operator|)
operator|&&
operator|(
name|Dbranch
operator|!=
name|nil
operator|)
condition|)
block|{
name|VOID
name|strcpy
argument_list|(
name|newdelnum
argument_list|,
name|Dbranch
operator|->
name|num
argument_list|)
decl_stmt|;
name|newdnumlength
operator|=
name|countnumflds
argument_list|(
name|newdelnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newdnumlength
operator|==
literal|0
condition|)
name|VOID
name|strcpy
argument_list|(
name|newdelnum
argument_list|,
literal|"1.1"
argument_list|)
decl_stmt|;
name|elsif
argument_list|(
argument|newdnumlength==
literal|1
argument_list|)
name|VOID
name|strcat
argument_list|(
name|newdelnum
argument_list|,
literal|".1"
argument_list|)
decl_stmt|;
name|elsif
argument_list|(
argument|newdnumlength>
literal|2
argument_list|)
block|{
name|error
argument_list|(
literal|"Branch point does not exist for %s"
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* newdnumlength == 2 is OK;  */
name|olddeltanum
operator|=
name|nil
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|newdnumlength
operator|==
literal|0
condition|)
block|{
comment|/* derive new revision number from locks */
name|targetdelta
operator|=
name|findlock
argument_list|(
name|caller
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/*find and delete it*/
if|if
condition|(
name|targetdelta
condition|)
block|{
comment|/* found an old lock */
name|olddeltanum
operator|=
name|targetdelta
operator|->
name|num
expr_stmt|;
comment|/* check whether locked revision exists */
if|if
condition|(
operator|!
name|genrevs
argument_list|(
name|olddeltanum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|targetdelta
operator|==
name|Head
condition|)
block|{
comment|/* make new head */
name|newdelta
operator|.
name|next
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|(targetdelta->next==nil)&&(countnumflds(olddeltanum)>
literal|2
argument|)
argument_list|)
block|{
comment|/* new tip revision on side branch */
name|targetdelta
operator|->
name|next
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* middle revision; start a new branch */
name|newdelnum
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|addbranch
argument_list|(
name|targetdelta
argument_list|,
name|newdelnum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
comment|/* successfull use of existing lock */
block|}
else|else
block|{
comment|/* no existing lock; try Dbranch */
comment|/* update newdelnum */
if|if
condition|(
operator|!
operator|(
operator|(
name|StrictLocks
operator|==
name|false
operator|)
operator|&&
operator|(
name|getuid
argument_list|()
operator|==
name|RCSstat
operator|.
name|st_uid
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"no lock set by %s"
argument_list|,
name|caller
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|Dbranch
condition|)
block|{
name|VOID
name|strcpy
argument_list|(
name|newdelnum
argument_list|,
name|Dbranch
operator|->
name|num
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|incnum
argument_list|(
name|Head
operator|->
name|num
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
block|}
name|newdnumlength
operator|=
name|countnumflds
argument_list|(
name|newdelnum
argument_list|)
expr_stmt|;
comment|/* now fall into next statement */
block|}
block|}
if|if
condition|(
name|newdnumlength
operator|<=
literal|2
condition|)
block|{
comment|/* add new head per given number */
name|olddeltanum
operator|=
name|Head
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|newdnumlength
operator|==
literal|1
condition|)
block|{
comment|/* make a two-field number out of it*/
if|if
condition|(
name|cmpnumfld
argument_list|(
name|newdelnum
argument_list|,
name|olddeltanum
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
else|else
name|VOID
name|strcat
argument_list|(
name|newdelnum
argument_list|,
literal|".1"
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|cmpnum
argument_list|(
name|newdelnum
argument_list|,
name|olddeltanum
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"deltanumber %s too low; must be higher than %s"
argument_list|,
name|newdelnum
argument_list|,
name|Head
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|removelock
argument_list|(
name|caller
argument_list|,
name|Head
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|(
name|genrevs
argument_list|(
name|olddeltanum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|newdelta
operator|.
name|next
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
block|}
else|else
block|{
comment|/* put new revision on side branch */
comment|/*first, get branch point */
name|tp
operator|=
name|branchpointnum
expr_stmt|;
name|sp
operator|=
name|newdelnum
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newdnumlength
operator|-
operator|(
name|newdnumlength
operator|%
literal|2
operator|==
literal|1
condition|?
literal|1
else|:
literal|2
operator|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'.'
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/*copy field*/
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/*copy dot  */
block|}
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* kill final dot */
name|olddeltanum
operator|=
name|branchpointnum
expr_stmt|;
comment|/*temporary old delta*/
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|branchpointnum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|cmpnum
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
name|branchpointnum
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find branchpoint %s"
argument_list|,
name|branchpointnum
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|addbranch
argument_list|(
name|targetdelta
argument_list|,
name|newdelnum
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|addbranch
parameter_list|(
name|branchpoint
parameter_list|,
name|num
parameter_list|)
name|struct
name|hshentry
modifier|*
name|branchpoint
decl_stmt|;
name|char
modifier|*
name|num
decl_stmt|;
comment|/* adds a new branch and branch delta at branchpoint.  * If num is the null string, appends the new branch, incrementing  * the highest branch number (initially 1), and setting the level number to 1.  * the new delta and branchhead are in globals newdelta and newbranch, resp.  * the new number is placed into num.  * returns false on error.  */
block|{
name|struct
name|branchhead
modifier|*
name|bhead
decl_stmt|,
modifier|*
name|btrail
decl_stmt|;
name|char
name|branchnum
index|[
name|revlength
index|]
decl_stmt|;
name|int
name|numlength
decl_stmt|,
name|result
decl_stmt|,
name|field
decl_stmt|;
name|numlength
operator|=
name|countnumflds
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|branchpoint
operator|->
name|branches
operator|==
name|nil
condition|)
block|{
comment|/* start first branch */
name|branchpoint
operator|->
name|branches
operator|=
operator|&
name|newbranch
expr_stmt|;
if|if
condition|(
name|numlength
operator|==
literal|0
condition|)
block|{
name|VOID
name|strcpy
argument_list|(
name|num
argument_list|,
name|branchpoint
operator|->
name|num
argument_list|)
decl_stmt|;
name|VOID
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1.1"
argument_list|)
decl_stmt|;
block|}
name|elsif
argument_list|(
argument|countnumflds(num)%
literal|2
argument|==
literal|1
argument_list|)
name|VOID
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
decl_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
name|nil
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|numlength==
literal|0
argument_list|)
block|{
comment|/* append new branch to the end */
name|bhead
operator|=
name|branchpoint
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|bhead
operator|->
name|nextbranch
condition|)
name|bhead
operator|=
name|bhead
operator|->
name|nextbranch
expr_stmt|;
name|bhead
operator|->
name|nextbranch
operator|=
operator|&
name|newbranch
expr_stmt|;
name|getbranchno
argument_list|(
name|bhead
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|branchnum
argument_list|)
expr_stmt|;
name|incnum
argument_list|(
name|branchnum
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|VOID
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
decl_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
comment|/* place the branch properly */
name|field
operator|=
name|numlength
operator|-
operator|(
name|numlength
operator|%
literal|2
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* field of branch number */
name|bhead
operator|=
name|branchpoint
operator|->
name|branches
expr_stmt|;
while|while
condition|(
operator|(
name|bhead
operator|!=
name|nil
operator|)
operator|&&
operator|(
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|num
argument_list|,
name|bhead
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|field
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|btrail
operator|=
name|bhead
expr_stmt|;
name|bhead
operator|=
name|bhead
operator|->
name|nextbranch
expr_stmt|;
block|}
if|if
condition|(
name|bhead
operator|==
name|nil
operator|||
name|result
operator|<
literal|0
condition|)
block|{
comment|/* insert/append new branchhead */
if|if
condition|(
name|bhead
operator|==
name|branchpoint
operator|->
name|branches
condition|)
name|branchpoint
operator|->
name|branches
operator|=
operator|&
name|newbranch
expr_stmt|;
else|else
name|btrail
operator|->
name|nextbranch
operator|=
operator|&
name|newbranch
expr_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
name|bhead
expr_stmt|;
if|if
condition|(
name|numlength
operator|%
literal|2
operator|==
literal|1
condition|)
name|VOID
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
decl_stmt|;
block|}
else|else
block|{
comment|/* branch exists; append to end */
name|getbranchno
argument_list|(
name|num
argument_list|,
name|branchnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|branchnum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|olddeltanum
operator|=
name|targetdelta
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|cmpnum
argument_list|(
name|num
argument_list|,
name|olddeltanum
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"deltanumber %s too low; must be higher than %s"
argument_list|,
name|num
argument_list|,
name|olddeltanum
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|removelock
argument_list|(
name|caller
argument_list|,
name|targetdelta
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|numlength
operator|%
literal|2
operator|==
literal|1
condition|)
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|targetdelta
operator|->
name|next
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
return|return
name|true
return|;
comment|/* Don't do anything to newbranch */
block|}
block|}
name|newbranch
operator|.
name|hsh
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|struct
name|hshentry
modifier|*
name|removelock
parameter_list|(
name|who
parameter_list|,
name|delta
parameter_list|)
name|char
modifier|*
name|who
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
comment|/* function: Finds the lock held by who on delta,  * removes it, and returns a pointer to the delta.  * Prints an error message and returns nil if there is no such lock.  * An exception is if StrictLocks==false, and who is the owner of  * the RCS file. If who does not have a lock in this case,  * delta is returned.  */
block|{
specifier|register
name|struct
name|lock
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
name|char
modifier|*
name|num
decl_stmt|;
name|struct
name|lock
name|dummy
decl_stmt|;
name|int
name|whomatch
decl_stmt|,
name|nummatch
decl_stmt|;
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
name|dummy
operator|.
name|nextlock
operator|=
name|next
operator|=
name|Locks
expr_stmt|;
name|trail
operator|=
operator|&
name|dummy
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
name|whomatch
operator|=
name|strcmp
argument_list|(
name|who
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
name|nummatch
operator|=
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|whomatch
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/*found a lock on delta by who*/
if|if
condition|(
operator|(
name|whomatch
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"revision %s locked by %s"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
comment|/*found one; delete it */
name|trail
operator|->
name|nextlock
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|Locks
operator|=
name|dummy
operator|.
name|nextlock
expr_stmt|;
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|nil
expr_stmt|;
comment|/* reset locked-by */
return|return
name|next
operator|->
name|delta
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|StrictLocks
operator|==
name|false
operator|)
operator|&&
operator|(
name|getuid
argument_list|()
operator|==
name|RCSstat
operator|.
name|st_uid
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"no lock set by %s for revision %s"
argument_list|,
name|who
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
else|else
block|{
return|return
name|delta
return|;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|getdate
parameter_list|()
comment|/* Function: returns a pointer to the current date in the form  * YY.MM.DD.hh.mm.ss\0  */
block|{
name|long
name|clock
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|datelength
index|]
decl_stmt|;
comment|/* date buffer */
name|clock
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|DATEFORM
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
decl_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xpandfile
parameter_list|(
name|unexfname
parameter_list|,
name|dir
parameter_list|,
name|delta
parameter_list|)
name|char
modifier|*
name|unexfname
decl_stmt|,
decl|*
name|dir
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Reads file unexpfname and copies it to a  * file in dir, performing keyword substitution with data from delta.  * returns the name of the expanded file if successful, nil otherwise.  */
end_comment

begin_block
block|{
name|char
modifier|*
name|targetfname
decl_stmt|;
name|FILE
modifier|*
name|unexfile
decl_stmt|,
modifier|*
name|exfile
decl_stmt|;
name|targetfname
operator|=
name|mktempfile
argument_list|(
name|dir
argument_list|,
name|TMPFILE3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unexfile
operator|=
name|fopen
argument_list|(
name|unexfname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|exfile
operator|=
name|fopen
argument_list|(
name|targetfname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Can't expand file %s"
argument_list|,
name|unexfname
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
while|while
condition|(
name|expandline
argument_list|(
name|unexfile
argument_list|,
name|exfile
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
empty_stmt|;
comment|/*expand*/
name|ffclose
argument_list|(
name|unexfile
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|exfile
argument_list|)
expr_stmt|;
return|return
name|targetfname
return|;
block|}
end_block

begin_macro
name|mustcheckin
argument_list|(
argument|unexfname
argument_list|,
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|unexfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: determines whether checkin should proceed.  * Compares the wrkfilename with unexfname, disregarding keywords.  * If the 2 files differ, returns true. If they do not differ, asks the user  * whether to return true or false (i.e., whether to checkin the file anyway.  * If the files do not differ, and quietflag==true, returns false.  * Shortcut: If forceciflag==true, mustcheckin() always returns true.  */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|response
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|forceciflag
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|rcsfcmp
argument_list|(
name|workfilename
argument_list|,
name|unexfname
argument_list|,
name|delta
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If files are different, must check them in. */
comment|/* files are the same */
name|diagnose
argument_list|(
literal|"File %s is unchanged with respect to revision %s"
argument_list|,
name|workfilename
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|quietflag
operator|||
operator|!
name|ttystdin
argument_list|()
condition|)
block|{
comment|/* Files are the same, but can't ask, so don't checkin*/
name|result
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* ask user whether to check in */
name|VOID
name|fputs
argument_list|(
literal|"checkin anyway? [ny](n): "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|response
operator|=
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip to end of line*/
name|result
operator|=
operator|(
name|response
operator|==
literal|'y'
operator|||
name|response
operator|==
literal|'Y'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|quietflag
condition|)
block|{
name|warn
argument_list|(
literal|"checkin aborted since %s was not changed; %s %sdeleted."
argument_list|,
name|workfilename
argument_list|,
name|workfilename
argument_list|,
name|keepworkingfile
condition|?
literal|"not "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"checkin aborted; %s %sdeleted."
argument_list|,
name|workfilename
argument_list|,
name|keepworkingfile
condition|?
literal|"not "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keepworkingfile
condition|)
name|VOID
name|unlink
parameter_list|(
name|workfilename
parameter_list|)
function_decl|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* --------------------- G E T L O G M S G --------------------------------*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stdinread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is>0 if redirected stdin has been read once.     */
end_comment

begin_function
name|char
modifier|*
name|getlogmsg
parameter_list|()
comment|/* Function: obtains a log message and returns a pointer to it.  * If a log message is given via the -m option, a pointer to that  * string is returned.  * If this is the initial revision, a standard log message is returned.  * Otherwise, reads a character string from the terminal.  * The string must be terminated with a control-d or a single '.' on a  * line. getlogmsg prompts the first time it is called for the  * log message; during all later calls it asks whether the previous  * log message can be reused.  * returns a pointer to the character string; the pointer is always non-nil.  */
block|{
specifier|static
name|logyet
expr_stmt|;
comment|/*indicates whether previous log present*/
specifier|static
name|char
name|emptylog
index|[]
init|=
literal|"*** empty log message ***\n"
decl_stmt|;
specifier|static
name|char
name|initiallog
index|[]
init|=
literal|"Initial revision\n"
decl_stmt|;
name|char
name|response
decl_stmt|;
name|int
name|cin
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|old1
decl_stmt|,
name|old2
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|msg
condition|)
return|return
name|msg
return|;
if|if
condition|(
operator|(
name|olddeltanum
operator|==
name|nil
operator|)
operator|&&
operator|(
operator|(
name|cmpnum
argument_list|(
name|newdelnum
argument_list|,
literal|"1.1"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|cmpnum
argument_list|(
name|newdelnum
argument_list|,
literal|"1.0"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
name|initiallog
return|;
block|}
if|if
condition|(
name|keepflag
condition|)
block|{
comment|/* generate std. log message */
name|VOID
name|sprintf
argument_list|(
name|logmsg
argument_list|,
literal|"checked in with -k by %s at %s.\n"
argument_list|,
name|caller
argument_list|,
name|getdate
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|logmsg
operator|)
return|;
block|}
if|if
condition|(
name|logyet
condition|)
block|{
comment|/*previous log available*/
if|if
condition|(
operator|!
name|ttystdin
argument_list|()
condition|)
return|return
name|logmsg
return|;
comment|/* reuse if stdin is not a terminal*/
comment|/* otherwise ask */
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* reset EOF ptr */
name|VOID
name|fputs
argument_list|(
literal|"reuse log message of previous file? [yn](y): "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|response
operator|=
name|cin
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|cin
operator|==
name|EOF
operator|||
name|cin
operator|==
literal|'\n'
operator|)
condition|)
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip to end of line*/
if|if
condition|(
name|response
operator|==
literal|'\n'
operator|||
name|response
operator|==
literal|'y'
operator|||
name|response
operator|==
literal|'Y'
condition|)
return|return
name|logmsg
return|;
else|else
name|logmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*kill existing log message */
block|}
comment|/* now read string from stdin */
if|if
condition|(
name|ttystdin
argument_list|()
condition|)
block|{
name|VOID
name|fputs
argument_list|(
literal|"enter log message:\n(terminate with ^D or single '.')\n>> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
block|}
else|else
block|{
comment|/* redirected stdin */
if|if
condition|(
name|stdinread
operator|>
literal|0
condition|)
name|faterror
argument_list|(
literal|"Can't reread redirected stdin for log message; use -m"
argument_list|)
expr_stmt|;
name|stdinread
operator|++
expr_stmt|;
block|}
name|tp
operator|=
name|logmsg
expr_stmt|;
name|old1
operator|=
literal|'\n'
expr_stmt|;
name|old2
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|cin
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ttystdin
argument_list|()
condition|)
block|{
name|VOID
name|printf
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp
operator|==
name|logmsg
operator|)
operator|||
operator|(
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
operator|)
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* append newline */
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
comment|/*terminate*/
break|break;
block|}
if|if
condition|(
name|cin
operator|==
literal|'\n'
operator|&&
name|old1
operator|==
literal|'.'
operator|&&
name|old2
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/*kill last period */
break|break;
block|}
if|if
condition|(
name|tp
operator|>=
name|logmsg
operator|+
name|logsize
operator|-
literal|2
condition|)
block|{
comment|/* overflow */
if|if
condition|(
operator|!
name|ttystdin
argument_list|()
condition|)
block|{
name|warn
argument_list|(
literal|"log message truncated to %d characters"
argument_list|,
name|logsize
argument_list|)
expr_stmt|;
name|logmsg
index|[
name|logsize
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|logmsg
index|[
name|logsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|logmsg
return|;
block|}
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"log message too long. Maximum: %d\n"
argument_list|,
name|logsize
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"reenter log message:\n>> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|tp
operator|=
name|logmsg
expr_stmt|;
name|old1
operator|=
literal|'\n'
expr_stmt|;
name|old2
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|cin
operator|!=
literal|'\n'
condition|)
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip line */
continue|continue;
block|}
if|if
condition|(
name|cin
operator|==
literal|'\n'
operator|&&
name|ttystdin
argument_list|()
condition|)
name|VOID
name|fputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
operator|*
name|tp
operator|++
operator|=
name|cin
expr_stmt|;
name|old2
operator|=
name|old1
expr_stmt|;
name|old1
operator|=
name|cin
expr_stmt|;
comment|/* this is the actual work!*/
comment|/*SDELIM will be changed to double SDELIM by putdtext*/
block|}
comment|/* end for */
comment|/* now check whether the log message is not empty */
name|tp
operator|=
name|logmsg
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|tp
operator|++
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\f'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|tp
operator|==
literal|'\0'
condition|)
block|{
name|logyet
operator|=
name|false
expr_stmt|;
return|return
name|emptylog
return|;
block|}
else|else
block|{
name|logyet
operator|=
name|true
expr_stmt|;
return|return
name|logmsg
return|;
block|}
block|}
end_function

end_unit

