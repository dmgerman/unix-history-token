begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Network Interface Machine Server  *  * Frank Pronk  * Copyright (c) 1984  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"../h/x29.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"nim.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|chartab
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|JmpBuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-local goto buffer for interval timer */
end_comment

begin_decl_stmt
name|short
name|PtyFd
init|=
operator|-
literal|1
decl_stmt|,
name|NetFd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|LogFd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|LogDev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|TimerOn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval timer armed */
end_comment

begin_decl_stmt
name|char
name|Banner
index|[]
init|=
literal|"NIM daemon\r"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|TraceFile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace file name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|PtyName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bufhd
name|ptyoqueue
decl_stmt|,
name|netoqueue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|packet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|user_name
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netinfo
name|NetInfo
init|=
block|{
name|CCITT1980
block|,
name|NX29_1980_PARMS
block|,
literal|128
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|PtyPacket
block|{
name|char
name|p_type
decl_stmt|;
name|char
name|p_data
index|[
literal|1
index|]
decl_stmt|;
comment|/* usually more than one byte */
block|}
struct|;
end_struct

begin_function_decl
name|char
modifier|*
name|x25err
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|uid
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|waterloo
comment|/* 	 * If this host doesn't support X.25, give up. 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_CCITT
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EPROTONOSUPPORT
condition|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"nimd: X.25 is not supported on this machine\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|argv
operator|++
init|;
name|argc
operator|>
literal|1
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
for|for
control|(
name|p
operator|=
operator|*
name|argv
operator|+
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"1978"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NetInfo
operator|.
name|n_nparms
operator|=
name|NX29_1978_PARMS
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"1980"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NetInfo
operator|.
name|n_nparms
operator|=
name|NX29_1980_PARMS
expr_stmt|;
break|break;
block|}
block|}
name|fatal
argument_list|(
literal|"1978 or 1980 expected after -c"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|TraceFile
operator|=
operator|*
name|argv
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"trace file name expected"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"usage: nimd [-c ccitt-date] [-h size] [-n size] [-t trace_file] pty_name"
argument_list|)
expr_stmt|;
block|}
else|else
name|PtyName
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
name|PtyName
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"No pseudo-tty specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|10
condition|;
name|s
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|{
name|int
name|tt
init|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|tt
operator|>
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|tt
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
block|}
name|OpenLog
argument_list|()
expr_stmt|;
name|packet
operator|=
name|getbuf
argument_list|(
name|MAXPSIZ
argument_list|)
expr_stmt|;
name|ResetBufs
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|bits
decl_stmt|;
if|if
condition|(
operator|(
name|PtyFd
operator|=
name|open
argument_list|(
name|PtyName
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|x25err
argument_list|(
name|PtyName
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|PtyFd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|PtyFd
argument_list|,
name|TIOCPKT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|PtyFd
argument_list|,
name|TIOCREMOTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
literal|1
operator|<<
name|PtyFd
operator|)
expr_stmt|;
name|select
argument_list|(
literal|16
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|bits
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* wait for pty to settle down */
ifdef|#
directive|ifdef
name|TIOCGSUID
comment|/* 		 * Get the slave's uid. 		 */
name|uid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|PtyFd
argument_list|,
name|TIOCGSUID
argument_list|,
operator|&
name|uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"nimd: ioctl TIOCGSUID"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|PtyFd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uid
operator|<
literal|0
operator|||
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"nimd: uid %d: Who are you?\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|PtyFd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|user_name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
comment|/* 		 * Set effective uid to the slave 		 * so he/she will be charged for X.25 usage. 		 */
name|setreuid
argument_list|(
literal|0
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nim
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* wait for slave to disconnect */
name|setreuid
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CloseLog
argument_list|()
expr_stmt|;
name|OpenLog
argument_list|()
expr_stmt|;
comment|/* allow log rollover */
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_macro
name|fatal
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|OpenLog
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"nimd: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|message
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprint
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
name|ToPty
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|FROMNIM
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|errp
decl_stmt|;
name|errp
operator|=
name|x25err
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|errp
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"nimd: %s\r"
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Main loop.  Select from pty and network, and  * hand data to nim receiver.  */
end_comment

begin_macro
name|nim
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|MAXPSIZ
index|]
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|ibits
decl_stmt|,
name|obits
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
name|InitProfile
argument_list|(
name|DEFAULT_PROFILE
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|Banner
argument_list|)
expr_stmt|;
name|State
operator|=
name|ST_COMMAND
expr_stmt|;
name|OpenLog
argument_list|()
expr_stmt|;
if|if
condition|(
name|user_name
index|[
literal|0
index|]
condition|)
name|log
argument_list|(
literal|"slave connect: %s"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
literal|"slave connect"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|JmpBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|obits
operator|=
operator|(
literal|1
operator|<<
name|PtyFd
operator|)
expr_stmt|;
name|ibits
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_io
goto|;
block|}
name|ibits
operator|=
name|obits
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Never look for input if there's still 		 * stuff in the corresponding output buffer 		 */
if|if
condition|(
name|PtyFd
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|QEMPTY
argument_list|(
operator|&
name|ptyoqueue
argument_list|)
condition|)
name|obits
operator||=
operator|(
literal|1
operator|<<
name|PtyFd
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NetFd
operator|>=
literal|0
operator|&&
name|State
operator|==
name|ST_DATA
condition|)
name|ibits
operator||=
operator|(
literal|1
operator|<<
name|NetFd
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|QEMPTY
argument_list|(
operator|&
name|netoqueue
argument_list|)
operator|&&
name|NetFd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|OutputBlocked
condition|)
name|obits
operator||=
operator|(
literal|1
operator|<<
name|NetFd
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PtyFd
operator|>=
literal|0
condition|)
name|ibits
operator||=
operator|(
literal|1
operator|<<
name|PtyFd
operator|)
expr_stmt|;
if|if
condition|(
name|ibits
operator|==
literal|0
operator|&&
name|obits
operator|==
literal|0
condition|)
comment|/* nothing to do; go home */
break|break;
if|if
condition|(
name|State
operator|&
name|ST_COMMAND
condition|)
block|{
name|struct
name|timeval
name|TimeOut
decl_stmt|;
name|TimeOut
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|TimeOut
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|16
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|TimeOut
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|log
argument_list|(
literal|"slave inactivity timeout"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TimerOn
condition|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|16
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TimerOn
condition|)
name|sigsetmask
argument_list|(
literal|1
operator|<<
operator|(
name|SIGALRM
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|do_io
label|:
comment|/* 		 * Something to read from the network... 		 */
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|NetFd
operator|)
condition|)
if|if
condition|(
operator|(
name|len
operator|=
name|ReadAndTrace
argument_list|(
name|NetFd
argument_list|,
name|buf
argument_list|,
name|MAXPSIZ
argument_list|,
literal|"net rx"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|NetworkError
argument_list|()
expr_stmt|;
block|}
else|else
name|FromNet
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * Something to read from the pty... 		 */
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|PtyFd
operator|)
condition|)
if|if
condition|(
operator|(
name|len
operator|=
name|ReadAndTrace
argument_list|(
name|PtyFd
argument_list|,
name|buf
argument_list|,
name|NetInfo
operator|.
name|n_psize
operator|+
literal|1
argument_list|,
literal|"pty rx"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|close
argument_list|(
name|PtyFd
argument_list|)
expr_stmt|;
name|PtyFd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|FromPty
argument_list|(
operator|(
expr|struct
name|PtyPacket
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|obits
operator|&
operator|(
literal|1
operator|<<
name|NetFd
operator|)
condition|)
block|{
if|if
condition|(
name|FlushQueue
argument_list|(
name|NetFd
argument_list|,
operator|&
name|netoqueue
argument_list|,
literal|"net tx"
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|NetworkError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|obits
operator|&
operator|(
literal|1
operator|<<
name|PtyFd
operator|)
condition|)
if|if
condition|(
name|FlushQueue
argument_list|(
name|PtyFd
argument_list|,
operator|&
name|ptyoqueue
argument_list|,
literal|"pty tx"
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|close
argument_list|(
name|PtyFd
argument_list|)
expr_stmt|;
name|PtyFd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ReadAndTrace
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|,
argument|who
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|who
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|bytes
decl_stmt|;
name|bytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|NimTrace
argument_list|(
name|who
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_block

begin_macro
name|NetworkError
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|()
expr_stmt|;
name|State
operator|=
name|ST_COMMAND
expr_stmt|;
name|close
argument_list|(
name|NetFd
argument_list|)
expr_stmt|;
name|NetFd
operator|=
operator|-
literal|1
expr_stmt|;
name|message
argument_list|(
name|Banner
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
name|log
argument_list|(
literal|"slave disconnect"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|NetFd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|PtyFd
argument_list|)
expr_stmt|;
name|NetFd
operator|=
name|PtyFd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TimerOn
condition|)
name|ClearTimer
argument_list|()
expr_stmt|;
name|ResetBufs
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ResetBufs
argument_list|()
end_macro

begin_block
block|{
name|InitQueue
argument_list|(
operator|&
name|ptyoqueue
argument_list|)
expr_stmt|;
name|InitQueue
argument_list|(
operator|&
name|netoqueue
argument_list|)
expr_stmt|;
name|RESET
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ToPty
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|from
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|end
init|=
name|str
operator|+
name|len
decl_stmt|,
name|c
decl_stmt|,
name|c1
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|lfcode
decl_stmt|;
while|while
condition|(
name|str
operator|<
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|c1
operator|=
name|c
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|CurrentX29Parms
index|[
name|X29_AUX_DEV_CONTROL_CODE
index|]
condition|)
block|{
if|if
condition|(
name|c1
operator|==
literal|023
condition|)
block|{
name|OutputBlocked
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c1
operator|==
literal|021
condition|)
block|{
name|OutputBlocked
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ptyoqueue
operator|.
name|b_count
operator|>
literal|256
condition|)
continue|continue;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
name|bp
operator|=
name|getbuf
argument_list|(
name|MAXPSIZ
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|c
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIZE
argument_list|(
name|bp
argument_list|)
operator|>=
name|MAXPSIZ
operator|-
literal|1
condition|)
block|{
name|enqueue
argument_list|(
name|bp
argument_list|,
operator|&
name|ptyoqueue
argument_list|)
expr_stmt|;
name|bp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|!=
literal|'\r'
operator|||
operator|(
name|lfcode
operator|=
name|CurrentX29Parms
index|[
name|X29_LF_AFTER_CR
index|]
operator|)
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|lfcode
operator|&
literal|01
operator|)
operator|&&
name|from
operator|==
name|FROMNET
operator|||
operator|(
name|lfcode
operator|&
literal|04
operator|)
operator|&&
name|from
operator|==
name|FROMPTY
operator|||
name|from
operator|==
name|FROMNIM
condition|)
name|PUTCHAR
argument_list|(
literal|'\n'
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
name|enqueue
argument_list|(
name|bp
argument_list|,
operator|&
name|ptyoqueue
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|FromPty
argument_list|(
name|pp
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|PtyPacket
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|echo
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|tp
init|=
name|packet
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
name|char
name|c1
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_type
operator|!=
name|TIOCPKT_DATA
condition|)
block|{
comment|/* fetch control byte */
name|PtyControl
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|State
operator|&
name|ST_UGLY_50_BAUD_BREAK_IN_PROGRESS
condition|)
return|return;
name|cp
operator|=
name|pp
operator|->
name|p_data
expr_stmt|;
name|echo
operator|=
name|CurrentX29Parms
index|[
name|X29_ECHO_CODE
index|]
operator|>
literal|0
operator|&&
name|ptyoqueue
operator|.
name|b_count
operator|<
literal|256
expr_stmt|;
while|while
condition|(
name|cp
operator|<
operator|(
operator|(
name|char
operator|*
operator|)
name|pp
operator|)
operator|+
name|len
condition|)
block|{
name|c
operator|=
operator|(
name|c1
operator|=
operator|*
name|cp
operator|++
operator|)
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|State
operator|&
name|ST_ESCSEEN
operator|&&
name|C_TYPE
argument_list|(
name|c
argument_list|)
operator|!=
name|C_ESCAPE
condition|)
name|EnterCommandState
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|C_TYPE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|C_ERASE
case|:
if|if
condition|(
operator|!
name|ISEMPTY
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|tp
operator|->
name|b_top
operator|--
expr_stmt|;
if|if
condition|(
name|echo
condition|)
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|ToPty
argument_list|(
literal|"\b \b"
argument_list|,
literal|3
argument_list|,
name|FROMPTY
argument_list|)
expr_stmt|;
else|else
name|ToPty
argument_list|(
operator|&
name|c1
argument_list|,
literal|1
argument_list|,
name|FROMPTY
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|C_KILL
case|:
name|RESET
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo
condition|)
name|ToPty
argument_list|(
literal|"*poof*\r"
argument_list|,
literal|7
argument_list|,
name|FROMPTY
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_DISPLAY
case|:
name|ToPty
argument_list|(
name|tp
operator|->
name|b_bot
argument_list|,
name|SIZE
argument_list|(
name|tp
argument_list|)
argument_list|,
name|FROMPTY
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_ESCAPE
case|:
if|if
condition|(
operator|(
name|State
operator|&
operator|(
name|ST_COMMAND
operator||
name|ST_ESCSEEN
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|State
operator||=
name|ST_ESCSEEN
expr_stmt|;
continue|continue;
block|}
name|State
operator|&=
operator|~
name|ST_ESCSEEN
expr_stmt|;
comment|/* fall through */
default|default:
if|if
condition|(
name|State
operator|&
name|ST_COMMAND
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|echo
condition|)
name|ToPty
argument_list|(
operator|&
name|c1
argument_list|,
literal|1
argument_list|,
name|FROMPTY
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
literal|'\0'
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|FlushQueue
argument_list|(
name|PtyFd
argument_list|,
operator|&
name|ptyoqueue
argument_list|,
literal|"pty tx"
argument_list|)
expr_stmt|;
name|NimCommand
argument_list|(
name|tp
operator|->
name|b_bot
argument_list|)
expr_stmt|;
name|RESET
argument_list|(
name|tp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SIZE
argument_list|(
name|tp
argument_list|)
operator|<
name|MAXPSIZ
operator|-
literal|1
condition|)
block|{
name|PUTCHAR
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo
condition|)
name|ToPty
argument_list|(
operator|&
name|c1
argument_list|,
literal|1
argument_list|,
name|FROMPTY
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*					ToPty ("\007", 1, FROMPTY)*/
empty_stmt|;
block|}
else|else
block|{
name|PUTCHAR
argument_list|(
name|c1
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo
condition|)
name|ToPty
argument_list|(
operator|&
name|c1
argument_list|,
literal|1
argument_list|,
name|FROMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFORWARD
argument_list|(
name|c
argument_list|)
operator|||
name|SIZE
argument_list|(
name|tp
argument_list|)
operator|>=
name|NetInfo
operator|.
name|n_psize
condition|)
block|{
name|ForwardPacket
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ISEMPTY
argument_list|(
name|tp
argument_list|)
operator|&&
operator|(
name|State
operator|&
name|ST_COMMAND
operator|)
operator|==
literal|0
condition|)
name|SetTimer
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|PtyControl
argument_list|(
name|pp
argument_list|)
specifier|register
expr|struct
name|PtyPacket
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|pp
operator|->
name|p_type
operator|&
operator|(
name|TIOCPKT_FLUSHWRITE
operator||
name|TIOCPKT_FLUSHREAD
operator|)
operator|)
operator|==
operator|(
name|TIOCPKT_FLUSHWRITE
operator||
name|TIOCPKT_FLUSHREAD
operator|)
condition|)
block|{
comment|/* break indication from pty */
if|if
condition|(
name|State
operator|&
name|ST_COMMAND
condition|)
name|RESET
argument_list|(
name|packet
argument_list|)
expr_stmt|;
else|else
name|Break
argument_list|(
name|CurrentX29Parms
index|[
name|X29_BREAK_PROCEDURE_CODE
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCPKT_IOCTL
if|if
condition|(
name|pp
operator|->
name|p_type
operator|&
name|TIOCPKT_IOCTL
condition|)
block|{
comment|/* some kind of set tty done by slave */
specifier|static
name|short
name|UnixToX29Speed
index|[]
init|=
block|{
literal|0
block|,
literal|10
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|6
block|,
literal|8
block|,
literal|2
block|,
literal|4
block|,
literal|3
block|,
comment|/* B0 thru B1200 */
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
comment|/* B2400 thru EXTB */
block|}
decl_stmt|;
name|struct
name|sgttyb
name|sg
decl_stmt|;
name|ioctl
argument_list|(
name|PtyFd
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|.
name|sg_ospeed
operator|==
name|B50
condition|)
block|{
name|State
operator||=
name|ST_UGLY_50_BAUD_BREAK_IN_PROGRESS
expr_stmt|;
return|return;
block|}
name|CurrentX29Parms
index|[
name|X29_TRANSMISSION_SPEED_CODE
index|]
operator|=
name|UnixToX29Speed
index|[
name|sg
operator|.
name|sg_ospeed
index|]
expr_stmt|;
if|if
condition|(
name|State
operator|&
name|ST_UGLY_50_BAUD_BREAK_IN_PROGRESS
operator|&&
name|sg
operator|.
name|sg_ospeed
operator|!=
name|B50
condition|)
block|{
name|State
operator|&=
operator|~
name|ST_UGLY_50_BAUD_BREAK_IN_PROGRESS
expr_stmt|;
if|if
condition|(
name|State
operator|&
name|ST_COMMAND
condition|)
name|RESET
argument_list|(
name|packet
argument_list|)
expr_stmt|;
else|else
name|Break
argument_list|(
name|CurrentX29Parms
index|[
name|X29_BREAK_PROCEDURE_CODE
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|EnterCommandState
argument_list|()
end_macro

begin_block
block|{
name|State
operator|&=
operator|~
name|ST_ESCSEEN
expr_stmt|;
name|State
operator||=
name|ST_COMMAND
operator||
name|ST_ESCCOMM
expr_stmt|;
name|ForwardPacket
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ExitDataState
argument_list|(
argument|cause
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cause
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ResetBufs
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|NetFd
argument_list|)
expr_stmt|;
name|NetFd
operator|=
operator|-
literal|1
expr_stmt|;
name|State
operator|=
name|ST_COMMAND
expr_stmt|;
name|OutputBlocked
operator|=
literal|0
expr_stmt|;
name|CurrentX29Parms
index|[
name|X29_DISCARD_OUTPUT_CODE
index|]
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
literal|"nimd: Call cleared - %s\r"
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Call cleared - %s"
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ForwardPacket
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tp
init|=
name|packet
decl_stmt|;
if|if
condition|(
operator|!
name|ISEMPTY
argument_list|(
name|tp
argument_list|)
operator|&&
operator|(
name|State
operator|&
name|ST_COMMAND
operator|)
operator|==
literal|0
condition|)
block|{
name|AddParity
argument_list|(
name|tp
operator|->
name|b_bot
argument_list|,
name|SIZE
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getbuf
argument_list|(
name|SIZE
argument_list|(
name|tp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|BufCopy
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|bp
argument_list|,
operator|&
name|netoqueue
argument_list|)
expr_stmt|;
block|}
name|RESET
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TimerOn
condition|)
name|ClearTimer
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ToNet
argument_list|(
argument|pp
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * round buffer size up to a multiple of 64 bytes 	 * to reduce accumulation of small and usually 	 * useless buffers in the free list.  This speeds 	 * up malloc(). 	 */
name|bp
operator|=
name|getbuf
argument_list|(
operator|(
name|len
operator|+
literal|63
operator|)
operator|&
operator|~
literal|63
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
name|bp
operator|->
name|b_bot
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_top
operator|=
name|bp
operator|->
name|b_bot
operator|+
name|len
expr_stmt|;
name|enqueue
argument_list|(
name|bp
argument_list|,
operator|&
name|netoqueue
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|timeout
argument_list|()
end_macro

begin_block
block|{
name|TimerOn
operator|=
literal|0
expr_stmt|;
name|ForwardPacket
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|JmpBuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SetTimer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
name|struct
name|itimerval
name|itv
decl_stmt|;
if|if
condition|(
name|TimerOn
operator|||
operator|(
name|t
operator|=
name|CurrentX29Parms
index|[
name|X29_IDLE_TIMER_CODE
index|]
operator|)
operator|<=
literal|0
condition|)
return|return;
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|t
operator|/
literal|20
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
name|t
operator|%
literal|20
operator|*
literal|1000000
operator|/
literal|20
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* cancel possible pending signal */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
literal|1
operator|<<
operator|(
name|SIGALRM
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|TimerOn
operator|++
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ClearTimer
argument_list|()
end_macro

begin_block
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|itv
argument_list|,
sizeof|sizeof
argument_list|(
name|itv
argument_list|)
argument_list|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|TimerOn
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|FromNet
argument_list|(
argument|bp
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|bp
operator|&
name|Q_BIT
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|x25packet
modifier|*
name|xp
init|=
operator|(
expr|struct
name|x25packet
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|CurrentX29Parms
index|[
name|X29_DISCARD_OUTPUT_CODE
index|]
operator|==
literal|0
condition|)
block|{
name|AddParity
argument_list|(
name|xp
operator|->
name|p_x25data
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ToPty
argument_list|(
name|xp
operator|->
name|p_x25data
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|FROMNET
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|X29ControlMessage
argument_list|(
operator|(
expr|struct
name|x29packet
operator|*
operator|)
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SendX25Interrupt
argument_list|()
end_macro

begin_block
block|{
name|char
name|c
init|=
literal|0x77
decl_stmt|;
name|send
argument_list|(
name|NetFd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|,
name|MSG_OOB
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|fastidious
end_ifdef

begin_comment
comment|/* we need stdio */
end_comment

begin_comment
comment|/*  * Sorry about this...  * Defining this dummy procedure prevents the stdio package  * (about 17K bytes worth) from being loaded.  This program  * does not require any support from the 4.2bsd stdio library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_macro
name|_cleanup
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|NimTrace
argument_list|(
argument|who
argument_list|,
argument|bp
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|who
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|TraceFile
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fd
operator|<=
literal|0
operator|&&
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|TraceFile
argument_list|,
literal|0640
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|DisplayPacketContents
argument_list|(
name|fd
argument_list|,
name|who
argument_list|,
name|bp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|OpenLog
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|LogFd
operator|>=
literal|0
condition|)
return|return;
if|if
condition|(
name|LogDev
operator|=
name|rindex
argument_list|(
name|PtyName
argument_list|,
literal|'/'
argument_list|)
condition|)
name|LogDev
operator|++
expr_stmt|;
else|else
name|LogDev
operator|=
name|PtyName
expr_stmt|;
if|if
condition|(
operator|(
name|LogFd
operator|=
name|open
argument_list|(
name|LOGFILE
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return;
name|LogFd
operator|=
name|creat
argument_list|(
name|LOGFILE
argument_list|,
literal|0640
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|CloseLog
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|LogFd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|LogFd
argument_list|)
expr_stmt|;
name|LogFd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|log
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|DateTime
decl_stmt|;
name|char
name|format
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|ctime
argument_list|()
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|LogFd
operator|<
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|DateTime
operator|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|DateTime
index|[
literal|19
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprint
argument_list|(
name|format
argument_list|,
literal|"%s %s %s\n"
argument_list|,
name|DateTime
operator|+
literal|4
argument_list|,
name|LogDev
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|LogFd
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprint
argument_list|(
name|LogFd
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|LogPacket
argument_list|(
argument|bp
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|LogFd
operator|<
literal|0
condition|)
return|return;
name|DisplayPacketContents
argument_list|(
name|LogFd
argument_list|,
literal|"net rx"
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DisplayPacketContents
argument_list|(
argument|fd
argument_list|,
argument|from
argument_list|,
argument|pp
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|first
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
do|do
block|{
name|ConvertToOctal
argument_list|(
name|pp
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|fprint
argument_list|(
name|fd
argument_list|,
literal|"%s[%d]\t%s\n"
argument_list|,
name|from
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fprint
argument_list|(
name|fd
argument_list|,
literal|"\t\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ConvertToAscii
argument_list|(
name|pp
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprint
argument_list|(
name|fd
argument_list|,
literal|"\t\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pp
operator|+=
literal|16
expr_stmt|;
name|len
operator|-=
literal|16
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_expr_stmt
name|ConvertToOctal
argument_list|(
name|start
argument_list|,
name|len
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|start
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|16
condition|)
name|len
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|-
name|start
operator|<
name|len
condition|;
name|cp
operator|++
control|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|(
operator|(
operator|*
name|cp
operator|&
literal|0300
operator|)
operator|>>
literal|6
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|(
operator|(
operator|*
name|cp
operator|&
literal|070
operator|)
operator|>>
literal|3
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|(
operator|*
name|cp
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|bp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ConvertToAscii
argument_list|(
name|start
argument_list|,
name|len
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|start
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|16
condition|)
name|len
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|-
name|start
operator|<
name|len
condition|;
name|cp
operator|++
control|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'\b'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'r'
expr_stmt|;
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
literal|0177
operator|)
operator|>
literal|' '
operator|&&
operator|(
operator|*
name|cp
operator|&
literal|0177
operator|)
operator|<
literal|0177
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
else|else
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|bp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

end_unit

