begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tickadj - read, and possibly modify, the kernel `tick' and  *	     `tickadj' variables, as well as `dosynctodr'.  Note that  *	     this operates on the running kernel only.  I'd like to be  *	     able to read and write the binary as well, but haven't  *	     mastered this yet.  *  * HMS: The #includes here are different from those in xntpd/ntp_unixclock.c  *      These seem "worse".  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"l_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMEX_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ADJTIMEX
end_ifdef

begin_comment
comment|/* Linux */
end_comment

begin_decl_stmt
name|struct
name|timex
name|txc
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int main( 	int argc, 	char *argv[] 	) { 	int     c, i; 	int     quiet = 0; 	int     errflg = 0; 	char    *progname; 	extern int ntp_optind; 	extern char *ntp_optarg;  	progname = argv[0]; 	if (argc==2&& argv[1][0] != '-') {
comment|/* old Linux format, for compatability */
end_comment

begin_else
unit|if ((i = atoi(argv[1]))> 0) { 		    txc.time_tick = i; 		    txc.modes = ADJ_TIMETICK; 	    } else { 		    fprintf(stderr, "Silly value for tick: %s\n", argv[1]); 		    errflg++; 	    } 	} else { 	    while ((c = ntp_getopt(argc, argv, "a:qt:")) != EOF) { 		switch (c) { 		    case 'a': 			if ((i=atoi(ntp_optarg))> 0) { 				txc.tickadj = i; 				txc.modes |= ADJ_TICKADJ; 			} else { 				fprintf(stderr, 					"%s: unlikely value for tickadj: %s\n", 					progname, ntp_optarg); 				errflg++; 			} 			break;  		    case 'q': 			quiet = 1; 			break;  		    case 't': 			if ((i=atoi(ntp_optarg))> 0) { 				txc.time_tick = i; 				txc.modes |= ADJ_TIMETICK; 			} else { 				(void) fprintf(stderr, 				       "%s: unlikely value for tick: %s\n", 				       progname, ntp_optarg); 				errflg++; 			} 			break;  		    default: 			fprintf(stderr, 			    "Usage: %s [tick_value]\n-or-   %s [ -q ] [ -t tick ] [ -a tickadj ]\n", 			    progname, progname); 			errflg++; 			break; 		} 	    } 	}  	if (!errflg) { 		if (adjtimex(&txc)< 0) 			perror("adjtimex"); 		else if (!quiet) 			printf("tick     = %ld\ntick_adj = %d\n", 			    txc.time_tick, txc.tickadj); 	}  	exit(errflg ? 1 : 0); }
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [tick_value]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|ADJ_TIMETICK
if|if
condition|(
operator|(
name|txc
operator|.
name|time_tick
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|txc
operator|.
name|tick
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|1
condition|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Silly value for tick: %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADJ_TIMETICK
name|txc
operator|.
name|modes
operator|=
name|ADJ_TIMETICK
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MOD_OFFSET
name|txc
operator|.
name|modes
operator|=
name|ADJ_TICK
expr_stmt|;
else|#
directive|else
name|txc
operator|.
name|mode
operator|=
name|ADJ_TICK
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ADJ_TIMETICK
name|txc
operator|.
name|modes
operator|=
literal|0
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MOD_OFFSET
name|txc
operator|.
name|modes
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|txc
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|adjtimex
argument_list|(
operator|&
name|txc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"adjtimex"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ADJ_TIMETICK
name|printf
argument_list|(
literal|"tick     = %ld\ntick_adj = %ld\n"
argument_list|,
name|txc
operator|.
name|time_tick
argument_list|,
name|txc
operator|.
name|tickadj
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"tick = %ld\n"
argument_list|,
name|txc
operator|.
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not Linux... kmem tweaking: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_FILE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NLIST_STRUCT
end_ifdef

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not NLIST_STRUCT */
end_comment

begin_comment
comment|/* was defined(SYS_AUX3) || defined(SYS_AUX2) */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_VAR_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hz
end_ifdef

begin_comment
comment|/* Was: RS6000 */
end_comment

begin_undef
undef|#
directive|undef
name|hz
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hz */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KVM_OPEN
end_ifdef

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_comment
comment|/* vxWorks needs mode flag -casey*/
end_comment

begin_define
define|#
directive|define
name|open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
value|open(name, flags, 0777)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|L_SET
end_ifndef

begin_comment
comment|/* Was: defined(SYS_PTX) || defined(SYS_IX86OSF1) */
end_comment

begin_define
define|#
directive|define
name|L_SET
value|SEEK_SET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HZ
end_ifndef

begin_define
define|#
directive|define
name|HZ
value|DEFAULT_HZ
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|KMEM
value|"/dev/kmem"
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dokmem
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|writetickadj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|writeopttickadj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unsetdosync
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|writetick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setnoprintf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|kmem
init|=
name|KMEM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|getoffsets
parameter_list|(
name|off_t
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|openfile
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writevar
parameter_list|(
name|int
parameter_list|,
name|off_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readvar
parameter_list|(
name|int
parameter_list|,
name|off_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
name|off_t
name|tickadj_offset
decl_stmt|;
name|off_t
name|tick_offset
decl_stmt|;
name|off_t
name|dosync_offset
decl_stmt|;
name|off_t
name|noprintf_offset
decl_stmt|;
name|int
name|tickadj
decl_stmt|,
name|ktickadj
decl_stmt|;
comment|/* HMS: Why isn't this u_long? */
name|int
name|tick
decl_stmt|,
name|ktick
decl_stmt|;
comment|/* HMS: Why isn't this u_long? */
name|int
name|dosynctodr
decl_stmt|;
name|int
name|noprintf
decl_stmt|;
name|int
name|hz
decl_stmt|;
name|int
name|hz_int
decl_stmt|,
name|hz_hundredths
decl_stmt|;
name|int
name|recommend_tickadj
decl_stmt|;
name|long
name|tmp
decl_stmt|;
name|init_lib
argument_list|()
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:Adkpqst:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|writetickadj
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|writetickadj
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unlikely value for tickadj: %s\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|SCO5_CLOCK
if|if
condition|(
name|writetickadj
operator|%
name|HZ
condition|)
block|{
name|writetickadj
operator|=
operator|(
name|writetickadj
operator|/
name|HZ
operator|)
operator|*
name|HZ
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tickadj truncated to: %d\n"
argument_list|,
name|writetickadj
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCO5_CLOCK */
break|break;
case|case
literal|'A'
case|:
name|writeopttickadj
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|dokmem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|setnoprintf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|unsetdosync
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|writetick
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|writetick
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unlikely value for tick: %s\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|!=
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-Adkpqs] [-a newadj] [-t newtick]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|getoffsets
argument_list|(
operator|&
name|tick_offset
argument_list|,
operator|&
name|tickadj_offset
argument_list|,
operator|&
name|dosync_offset
argument_list|,
operator|&
name|noprintf_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"tick offset = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tick_offset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"tickadj offset = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tickadj_offset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dosynctodr offset = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dosync_offset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"noprintf offset = %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|noprintf_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writetick
operator|&&
operator|(
name|tick_offset
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No tick kernel variable\n"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|writeopttickadj
operator|&&
operator|(
name|tickadj_offset
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No tickadj kernel variable\n"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|unsetdosync
operator|&&
operator|(
name|dosync_offset
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No dosynctodr kernel variable\n"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|setnoprintf
operator|&&
operator|(
name|noprintf_offset
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No noprintf kernel variable\n"
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tick_offset
operator|!=
literal|0
condition|)
block|{
name|readvar
argument_list|(
name|fd
argument_list|,
name|tick_offset
argument_list|,
operator|&
name|tick
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TICK_NANO
argument_list|)
operator|&&
name|defined
argument_list|(
name|K_TICK_NAME
argument_list|)
if|if
condition|(
operator|!
name|quiet
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"KERNEL %s = %d nsec\n"
argument_list|,
name|K_TICK_NAME
argument_list|,
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TICK_NANO&& K_TICK_NAME */
ifdef|#
directive|ifdef
name|TICK_NANO
name|tick
operator|/=
literal|1000
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tick
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tickadj_offset
operator|!=
literal|0
condition|)
block|{
name|readvar
argument_list|(
name|fd
argument_list|,
name|tickadj_offset
argument_list|,
operator|&
name|tickadj
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCO5_CLOCK
comment|/* scale from nsec/sec to usec/tick */
name|tickadj
operator|/=
operator|(
literal|1000L
operator|*
name|HZ
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/*SCO5_CLOCK */
if|#
directive|if
name|defined
argument_list|(
name|TICKADJ_NANO
argument_list|)
operator|&&
name|defined
argument_list|(
name|K_TICKADJ_NAME
argument_list|)
if|if
condition|(
operator|!
name|quiet
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"KERNEL %s = %d nsec\n"
argument_list|,
name|K_TICKADJ_NAME
argument_list|,
name|tickadj
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TICKADJ_NANO&& K_TICKADJ_NAME */
ifdef|#
directive|ifdef
name|TICKADJ_NANO
name|tickadj
operator|+=
literal|999
expr_stmt|;
name|tickadj
operator|/=
literal|1000
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tickadj
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dosync_offset
operator|!=
literal|0
condition|)
block|{
name|readvar
argument_list|(
name|fd
argument_list|,
name|dosync_offset
argument_list|,
operator|&
name|dosynctodr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noprintf_offset
operator|!=
literal|0
condition|)
block|{
name|readvar
argument_list|(
name|fd
argument_list|,
name|noprintf_offset
argument_list|,
operator|&
name|noprintf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsetdosync
operator|&&
name|dosync_offset
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't find %s in namelist\n"
argument_list|,
name|progname
argument_list|,
ifdef|#
directive|ifdef
name|K_DOSYNCTODR_NAME
name|K_DOSYNCTODR_NAME
else|#
directive|else
comment|/* not K_DOSYNCTODR_NAME */
literal|"dosynctodr"
endif|#
directive|endif
comment|/* not K_DOSYNCTODR_NAME */
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hz
operator|=
name|HZ
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSCONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|_SC_CLK_TCK
argument_list|)
name|hz
operator|=
operator|(
name|int
operator|)
name|sysconf
argument_list|(
name|_SC_CLK_TCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SYSCONF&& _SC_CLK_TCK */
ifdef|#
directive|ifdef
name|OVERRIDE_HZ
name|hz
operator|=
name|DEFAULT_HZ
expr_stmt|;
endif|#
directive|endif
name|ktick
operator|=
name|tick
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESET_TICK
name|tick
operator|=
name|PRESET_TICK
expr_stmt|;
endif|#
directive|endif
comment|/* PRESET_TICK */
ifdef|#
directive|ifdef
name|TICKADJ_NANO
name|tickadj
operator|/=
literal|1000
expr_stmt|;
if|if
condition|(
name|tickadj
operator|==
literal|0
condition|)
name|tickadj
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|ktickadj
operator|=
name|tickadj
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESET_TICKADJ
name|tickadj
operator|=
operator|(
name|PRESET_TICKADJ
operator|)
condition|?
name|PRESET_TICKADJ
else|:
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* PRESET_TICKADJ */
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|tick_offset
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"KERNEL tick = %d usec (from %s kernel variable)\n"
argument_list|,
name|ktick
argument_list|,
ifdef|#
directive|ifdef
name|K_TICK_NAME
name|K_TICK_NAME
else|#
directive|else
literal|"<this can't happen>"
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRESET_TICK
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"PRESET tick = %d usec\n"
argument_list|,
name|tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PRESET_TICK */
if|if
condition|(
name|tickadj_offset
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"KERNEL tickadj = %d usec (from %s kernel variable)\n"
argument_list|,
name|ktickadj
argument_list|,
ifdef|#
directive|ifdef
name|K_TICKADJ_NAME
name|K_TICKADJ_NAME
else|#
directive|else
literal|"<this can't happen>"
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRESET_TICKADJ
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"PRESET tickadj = %d usec\n"
argument_list|,
name|tickadj
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PRESET_TICKADJ */
if|if
condition|(
name|dosync_offset
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"dosynctodr is %s\n"
argument_list|,
name|dosynctodr
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noprintf_offset
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"kernel level printf's: %s\n"
argument_list|,
name|noprintf
condition|?
literal|"off"
else|:
literal|"on"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tick
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: the value of tick is silly!\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hz_int
operator|=
call|(
name|int
call|)
argument_list|(
literal|1000000L
operator|/
operator|(
name|long
operator|)
name|tick
argument_list|)
expr_stmt|;
name|hz_hundredths
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
literal|100000000L
operator|/
operator|(
name|long
operator|)
name|tick
operator|)
operator|-
operator|(
operator|(
name|long
operator|)
name|hz_int
operator|*
literal|100L
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"KERNEL hz = %d\n"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"calculated hz = %d.%02d Hz\n"
argument_list|,
name|hz_int
argument_list|,
name|hz_hundredths
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|SCO5_CLOCK
name|recommend_tickadj
operator|=
literal|100
expr_stmt|;
else|#
directive|else
comment|/* SCO5_CLOCK */
name|tmp
operator|=
operator|(
name|long
operator|)
name|tick
operator|*
literal|500L
expr_stmt|;
name|recommend_tickadj
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp
operator|/
literal|1000000L
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|%
literal|1000000L
operator|>
literal|0
condition|)
block|{
name|recommend_tickadj
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MIN_REC_TICKADJ
if|if
condition|(
name|recommend_tickadj
operator|<
name|MIN_REC_TICKADJ
condition|)
block|{
name|recommend_tickadj
operator|=
name|MIN_REC_TICKADJ
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MIN_REC_TICKADJ */
endif|#
directive|endif
comment|/* SCO5_CLOCK */
if|if
condition|(
operator|(
operator|!
name|quiet
operator|)
operator|&&
operator|(
name|tickadj_offset
operator|!=
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"recommended value of tickadj = %d us\n"
argument_list|,
name|recommend_tickadj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writetickadj
operator|==
literal|0
operator|&&
operator|!
name|writeopttickadj
operator|&&
operator|!
name|unsetdosync
operator|&&
name|writetick
operator|==
literal|0
operator|&&
operator|!
name|setnoprintf
condition|)
block|{
name|exit
argument_list|(
name|errflg
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writetickadj
operator|==
literal|0
operator|&&
name|writeopttickadj
condition|)
block|{
name|writetickadj
operator|=
name|recommend_tickadj
expr_stmt|;
block|}
name|fd
operator|=
name|openfile
argument_list|(
name|file
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|setnoprintf
operator|&&
operator|(
name|noprintf_offset
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setting noprintf: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|writevar
argument_list|(
name|fd
argument_list|,
name|noprintf_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|writetick
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tick_offset
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"writing tick, value %d: "
argument_list|,
name|writetick
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|writevar
argument_list|(
name|fd
argument_list|,
name|tick_offset
argument_list|,
name|writetick
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|writetickadj
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tickadj_offset
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"writing tickadj, value %d: "
argument_list|,
name|writetickadj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCO5_CLOCK
comment|/* scale from usec/tick to nsec/sec */
name|writetickadj
operator|*=
operator|(
literal|1000L
operator|*
name|HZ
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCO5_CLOCK */
name|writevar
argument_list|(
name|fd
argument_list|,
name|tickadj_offset
argument_list|,
name|writetickadj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unsetdosync
operator|&&
operator|(
name|dosync_offset
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zeroing dosynctodr: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|writevar
argument_list|(
name|fd
argument_list|,
name|dosync_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done!\n"
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|errflg
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getoffsets - read the magic offsets from the specified file  */
end_comment

begin_function
specifier|static
name|void
name|getoffsets
parameter_list|(
name|off_t
modifier|*
name|tick_off
parameter_list|,
name|off_t
modifier|*
name|tickadj_off
parameter_list|,
name|off_t
modifier|*
name|dosync_off
parameter_list|,
name|off_t
modifier|*
name|noprintf_off
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NOKMEM
ifndef|#
directive|ifndef
name|HAVE_KVM_OPEN
specifier|const
name|char
modifier|*
modifier|*
name|kname
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NOKMEM
ifdef|#
directive|ifdef
name|NLIST_NAME_UNION
define|#
directive|define
name|NL_B
value|{{
define|#
directive|define
name|NL_E
value|}}
else|#
directive|else
define|#
directive|define
name|NL_B
value|{
define|#
directive|define
name|NL_E
value|}
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|K_FILLER_NAME
value|"DavidLetterman"
ifdef|#
directive|ifdef
name|NLIST_EXTRA_INDIRECTION
name|int
name|i
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NOKMEM
specifier|static
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
name|NL_B
ifdef|#
directive|ifdef
name|K_TICKADJ_NAME
define|#
directive|define
name|N_TICKADJ
value|0
name|K_TICKADJ_NAME
else|#
directive|else
name|K_FILLER_NAME
endif|#
directive|endif
name|NL_E
block|,
name|NL_B
ifdef|#
directive|ifdef
name|K_TICK_NAME
define|#
directive|define
name|N_TICK
value|1
name|K_TICK_NAME
else|#
directive|else
name|K_FILLER_NAME
endif|#
directive|endif
name|NL_E
block|,
name|NL_B
ifdef|#
directive|ifdef
name|K_DOSYNCTODR_NAME
define|#
directive|define
name|N_DOSYNC
value|2
name|K_DOSYNCTODR_NAME
else|#
directive|else
name|K_FILLER_NAME
endif|#
directive|endif
name|NL_E
block|,
name|NL_B
ifdef|#
directive|ifdef
name|K_NOPRINTF_NAME
define|#
directive|define
name|N_NOPRINTF
value|3
name|K_NOPRINTF_NAME
else|#
directive|else
name|K_FILLER_NAME
endif|#
directive|endif
name|NL_E
block|,
name|NL_B
literal|""
name|NL_E
block|, 	}
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_KVM_OPEN
specifier|static
specifier|const
name|char
modifier|*
name|kernels
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|HAVE_GETBOOTFILE
name|NULL
block|,
comment|/* *** SEE BELOW! *** */
endif|#
directive|endif
literal|"/kernel/unix"
block|,
literal|"/kernel"
block|,
literal|"/vmunix"
block|,
literal|"/unix"
block|,
literal|"/mach"
block|,
literal|"/hp-ux"
block|,
literal|"/386bsd"
block|,
literal|"/netbsd"
block|,
literal|"/stand/vmunix"
block|,
literal|"/bsd"
block|,
name|NULL
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_KVM_OPEN */
ifdef|#
directive|ifdef
name|HAVE_KVM_OPEN
comment|/* 	 * Solaris> 2.5 doesn't have a kernel file.  Use the kvm_* interface 	 * to read the kernel name list. -- stolcke 3/4/96 	 */
name|kvm_t
modifier|*
name|kvm_handle
init|=
name|kvm_open
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|O_RDONLY
argument_list|,
name|progname
argument_list|)
decl_stmt|;
if|if
condition|(
name|kvm_handle
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: kvm_open failed\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kvm_nlist
argument_list|(
name|kvm_handle
argument_list|,
name|nl
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: kvm_nlist failed\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|kvm_close
argument_list|(
name|kvm_handle
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_KVM_OPEN */
ifdef|#
directive|ifdef
name|HAVE_GETBOOTFILE
comment|/* *** SEE HERE! *** */
if|if
condition|(
name|kernels
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|getbootfile
argument_list|()
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|kernels
index|[
literal|0
index|]
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|kernels
index|[
literal|0
index|]
operator|=
literal|"/Placeholder"
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_GETBOOTFILE */
for|for
control|(
name|kname
operator|=
name|kernels
init|;
operator|*
name|kname
operator|!=
name|NULL
condition|;
name|kname
operator|++
control|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
operator|*
name|kname
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|nlist
argument_list|(
operator|*
name|kname
argument_list|,
name|nl
argument_list|)
operator|>=
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: nlist didn't find needed symbols from<%s>: %s\n"
argument_list|,
name|progname
argument_list|,
operator|*
name|kname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|kname
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Couldn't find the kernel\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_KVM_OPEN */
if|if
condition|(
name|dokmem
condition|)
block|{
name|file
operator|=
name|kmem
expr_stmt|;
name|fd
operator|=
name|openfile
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NLIST_EXTRA_INDIRECTION
comment|/* 		 * Go one more round of indirection. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|nl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nl
index|[
name|i
index|]
operator|.
name|n_value
operator|)
operator|&&
operator|(
name|nl
index|[
name|i
index|]
operator|.
name|n_sclass
operator|==
literal|0x6b
operator|)
condition|)
block|{
name|readvar
argument_list|(
name|fd
argument_list|,
name|nl
index|[
name|i
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|nl
index|[
name|i
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NLIST_EXTRA_INDIRECTION */
block|}
endif|#
directive|endif
comment|/* not NOKMEM */
operator|*
name|tickadj_off
operator|=
literal|0
expr_stmt|;
operator|*
name|tick_off
operator|=
literal|0
expr_stmt|;
operator|*
name|dosync_off
operator|=
literal|0
expr_stmt|;
operator|*
name|noprintf_off
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|N_TICKADJ
argument_list|)
operator|*
name|tickadj_off
operator|=
name|nl
index|[
name|N_TICKADJ
index|]
operator|.
name|n_value
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|N_TICK
argument_list|)
operator|*
name|tick_off
operator|=
name|nl
index|[
name|N_TICK
index|]
operator|.
name|n_value
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|N_DOSYNC
argument_list|)
operator|*
name|dosync_off
operator|=
name|nl
index|[
name|N_DOSYNC
index|]
operator|.
name|n_value
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|N_NOPRINTF
argument_list|)
operator|*
name|noprintf_off
operator|=
name|nl
index|[
name|N_NOPRINTF
index|]
operator|.
name|n_value
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_undef
undef|#
directive|undef
name|N_TICKADJ
end_undef

begin_undef
undef|#
directive|undef
name|N_TICK
end_undef

begin_undef
undef|#
directive|undef
name|N_DOSYNC
end_undef

begin_undef
undef|#
directive|undef
name|N_NOPRINTF
end_undef

begin_comment
comment|/*  * openfile - open the file, check for errors  */
end_comment

begin_function
specifier|static
name|int
name|openfile
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|ifd
decl_stmt|;
name|ifd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: open %s: "
argument_list|,
name|progname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ifd
return|;
block|}
end_function

begin_comment
comment|/*  * writevar - write a variable into the file  */
end_comment

begin_function
specifier|static
name|void
name|writevar
parameter_list|(
name|int
name|ofd
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|var
parameter_list|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|ofd
argument_list|,
name|off
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: lseek fails: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|ofd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|var
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write fails: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * readvar - read a variable from the file  */
end_comment

begin_function
specifier|static
name|void
name|readvar
parameter_list|(
name|int
name|ifd
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
modifier|*
name|var
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|ifd
argument_list|,
name|off
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: lseek fails: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|var
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read fails: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read expected %d, got %d\n"
argument_list|,
name|progname
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not Linux */
end_comment

end_unit

