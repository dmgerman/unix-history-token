begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util/storage/lruhash.c - hashtable, hash function, LRU keeping.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains a hashtable with LRU keeping of entries.  *  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"util/storage/lruhash.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_function
name|void
name|bin_init
parameter_list|(
name|struct
name|lruhash_bin
modifier|*
name|array
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|THREADS_DISABLED
operator|(
name|void
operator|)
name|array
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|lock_quick_init
argument_list|(
operator|&
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
operator|&
name|array
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash_bin
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|lruhash
modifier|*
name|lruhash_create
parameter_list|(
name|size_t
name|start_size
parameter_list|,
name|size_t
name|maxmem
parameter_list|,
name|lruhash_sizefunc_t
name|sizefunc
parameter_list|,
name|lruhash_compfunc_t
name|compfunc
parameter_list|,
name|lruhash_delkeyfunc_t
name|delkeyfunc
parameter_list|,
name|lruhash_deldatafunc_t
name|deldatafunc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lruhash
modifier|*
name|table
init|=
operator|(
expr|struct
name|lruhash
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
name|NULL
return|;
name|lock_quick_init
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|table
operator|->
name|sizefunc
operator|=
name|sizefunc
expr_stmt|;
name|table
operator|->
name|compfunc
operator|=
name|compfunc
expr_stmt|;
name|table
operator|->
name|delkeyfunc
operator|=
name|delkeyfunc
expr_stmt|;
name|table
operator|->
name|deldatafunc
operator|=
name|deldatafunc
expr_stmt|;
name|table
operator|->
name|cb_arg
operator|=
name|arg
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|start_size
expr_stmt|;
name|table
operator|->
name|size_mask
operator|=
call|(
name|int
call|)
argument_list|(
name|start_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|table
operator|->
name|lru_start
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|lru_end
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|num
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|space_used
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|space_max
operator|=
name|maxmem
expr_stmt|;
name|table
operator|->
name|array
operator|=
name|calloc
argument_list|(
name|table
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash_bin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|array
condition|)
block|{
name|lock_quick_destroy
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bin_init
argument_list|(
name|table
operator|->
name|array
argument_list|,
name|table
operator|->
name|size
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|,
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|,
name|table
operator|->
name|array
argument_list|,
name|table
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash_bin
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_function
name|void
name|bin_delete
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_bin
modifier|*
name|bin
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|void
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|bin
condition|)
return|return;
name|lock_quick_destroy
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p
operator|=
name|bin
operator|->
name|overflow_list
expr_stmt|;
name|bin
operator|->
name|overflow_list
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|overflow_next
expr_stmt|;
name|d
operator|=
name|p
operator|->
name|data
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|delkeyfunc
call|)
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|table
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|deldatafunc
call|)
argument_list|(
name|d
argument_list|,
name|table
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bin_split
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_bin
modifier|*
name|newa
parameter_list|,
name|int
name|newmask
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|lruhash_bin
modifier|*
name|newbin
decl_stmt|;
comment|/* move entries to new table. Notice that since hash x is mapped to 	 * bin x& mask, and new mask uses one more bit, so all entries in 	 * one bin will go into the old bin or bin | newbit */
ifndef|#
directive|ifndef
name|THREADS_DISABLED
name|int
name|newbit
init|=
name|newmask
operator|-
name|table
operator|->
name|size_mask
decl_stmt|;
endif|#
directive|endif
comment|/* so, really, this task could also be threaded, per bin. */
comment|/* LRU list is not changed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|p
operator|=
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|overflow_list
expr_stmt|;
comment|/* lock both destination bins */
name|lock_quick_lock
argument_list|(
operator|&
name|newa
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|newa
index|[
name|newbit
operator||
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|overflow_next
expr_stmt|;
comment|/* link into correct new bin */
name|newbin
operator|=
operator|&
name|newa
index|[
name|p
operator|->
name|hash
operator|&
name|newmask
index|]
expr_stmt|;
name|p
operator|->
name|overflow_next
operator|=
name|newbin
operator|->
name|overflow_list
expr_stmt|;
name|newbin
operator|->
name|overflow_list
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|newa
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|newa
index|[
name|newbit
operator||
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lruhash_delete
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return;
comment|/* delete lock on hashtable to force check its OK */
name|lock_quick_destroy
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|bin_delete
argument_list|(
name|table
argument_list|,
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bin_overflow_remove
parameter_list|(
name|struct
name|lruhash_bin
modifier|*
name|bin
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|p
init|=
name|bin
operator|->
name|overflow_list
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
modifier|*
name|prevp
init|=
operator|&
name|bin
operator|->
name|overflow_list
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|entry
condition|)
block|{
operator|*
name|prevp
operator|=
name|p
operator|->
name|overflow_next
expr_stmt|;
return|return;
block|}
name|prevp
operator|=
operator|&
name|p
operator|->
name|overflow_next
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|overflow_next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reclaim_space
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|d
decl_stmt|;
name|struct
name|lruhash_bin
modifier|*
name|bin
decl_stmt|;
name|log_assert
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* does not delete MRU entry, so table will not be empty. */
while|while
condition|(
name|table
operator|->
name|num
operator|>
literal|1
operator|&&
name|table
operator|->
name|space_used
operator|>
name|table
operator|->
name|space_max
condition|)
block|{
comment|/* notice that since we hold the hashtable lock, nobody 		   can change the lru chain. So it cannot be deleted underneath 		   us. We still need the hashbin and entry write lock to make  		   sure we flush all users away from the entry.  		   which is unlikely, since it is LRU, if someone got a rdlock 		   it would be moved to front, but to be sure. */
name|d
operator|=
name|table
operator|->
name|lru_end
expr_stmt|;
comment|/* specialised, delete from end of double linked list, 		   and we know num>1, so there is a previous lru entry. */
name|log_assert
argument_list|(
name|d
operator|&&
name|d
operator|->
name|lru_prev
argument_list|)
expr_stmt|;
name|table
operator|->
name|lru_end
operator|=
name|d
operator|->
name|lru_prev
expr_stmt|;
name|d
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|NULL
expr_stmt|;
comment|/* schedule entry for deletion */
name|bin
operator|=
operator|&
name|table
operator|->
name|array
index|[
name|d
operator|->
name|hash
operator|&
name|table
operator|->
name|size_mask
index|]
expr_stmt|;
name|table
operator|->
name|num
operator|--
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin_overflow_remove
argument_list|(
name|bin
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|overflow_next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|d
expr_stmt|;
name|lock_rw_wrlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
name|table
operator|->
name|space_used
operator|-=
name|table
operator|->
name|sizefunc
argument_list|(
name|d
operator|->
name|key
argument_list|,
name|d
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|markdelfunc
condition|)
call|(
modifier|*
name|table
operator|->
name|markdelfunc
call|)
argument_list|(
name|d
operator|->
name|key
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|lruhash_entry
modifier|*
name|bin_find_entry
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_bin
modifier|*
name|bin
parameter_list|,
name|hashvalue_t
name|hash
parameter_list|,
name|void
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|p
init|=
name|bin
operator|->
name|overflow_list
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|hash
operator|==
name|hash
operator|&&
name|table
operator|->
name|compfunc
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
name|p
operator|=
name|p
operator|->
name|overflow_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|table_grow
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|)
block|{
name|struct
name|lruhash_bin
modifier|*
name|newa
decl_stmt|;
name|int
name|newmask
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|size_mask
operator|==
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
operator|>>
literal|1
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"hash array malloc: size_t too small"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to allocate new array, if not fail */
name|newa
operator|=
name|calloc
argument_list|(
name|table
operator|->
name|size
operator|*
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash_bin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newa
condition|)
block|{
name|log_err
argument_list|(
literal|"hash grow: malloc failed"
argument_list|)
expr_stmt|;
comment|/* continue with smaller array. Though its slower. */
return|return;
block|}
name|bin_init
argument_list|(
name|newa
argument_list|,
name|table
operator|->
name|size
operator|*
literal|2
argument_list|)
expr_stmt|;
name|newmask
operator|=
operator|(
name|table
operator|->
name|size_mask
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
name|bin_split
argument_list|(
name|table
argument_list|,
name|newa
argument_list|,
name|newmask
argument_list|)
expr_stmt|;
comment|/* delete the old bins */
name|lock_unprotect
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|,
name|table
operator|->
name|array
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|lock_quick_destroy
argument_list|(
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|table
operator|->
name|array
argument_list|)
expr_stmt|;
name|table
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|table
operator|->
name|size_mask
operator|=
name|newmask
expr_stmt|;
name|table
operator|->
name|array
operator|=
name|newa
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|,
name|table
operator|->
name|array
argument_list|,
name|table
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash_bin
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|lru_front
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|lru_prev
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|lru_next
operator|=
name|table
operator|->
name|lru_start
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|lru_start
condition|)
name|table
operator|->
name|lru_end
operator|=
name|entry
expr_stmt|;
else|else
name|table
operator|->
name|lru_start
operator|->
name|lru_prev
operator|=
name|entry
expr_stmt|;
name|table
operator|->
name|lru_start
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lru_remove
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|lru_prev
condition|)
name|entry
operator|->
name|lru_prev
operator|->
name|lru_next
operator|=
name|entry
operator|->
name|lru_next
expr_stmt|;
else|else
name|table
operator|->
name|lru_start
operator|=
name|entry
operator|->
name|lru_next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lru_next
condition|)
name|entry
operator|->
name|lru_next
operator|->
name|lru_prev
operator|=
name|entry
operator|->
name|lru_prev
expr_stmt|;
else|else
name|table
operator|->
name|lru_end
operator|=
name|entry
operator|->
name|lru_prev
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lru_touch
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
name|entry
parameter_list|)
block|{
name|log_assert
argument_list|(
name|table
operator|&&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|table
operator|->
name|lru_start
condition|)
return|return;
comment|/* nothing to do */
comment|/* remove from current lru position */
name|lru_remove
argument_list|(
name|table
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* add at front */
name|lru_front
argument_list|(
name|table
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lruhash_insert
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|hashvalue_t
name|hash
parameter_list|,
name|struct
name|lruhash_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|lruhash_bin
modifier|*
name|bin
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|found
decl_stmt|,
modifier|*
name|reclaimlist
init|=
name|NULL
decl_stmt|;
name|size_t
name|need_size
decl_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_sizefunc
argument_list|(
name|table
operator|->
name|sizefunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_delkeyfunc
argument_list|(
name|table
operator|->
name|delkeyfunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_deldatafunc
argument_list|(
name|table
operator|->
name|deldatafunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_compfunc
argument_list|(
name|table
operator|->
name|compfunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_markdelfunc
argument_list|(
name|table
operator|->
name|markdelfunc
argument_list|)
argument_list|)
expr_stmt|;
name|need_size
operator|=
name|table
operator|->
name|sizefunc
argument_list|(
name|entry
operator|->
name|key
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb_arg
operator|==
name|NULL
condition|)
name|cb_arg
operator|=
name|table
operator|->
name|cb_arg
expr_stmt|;
comment|/* find bin */
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|table
operator|->
name|array
index|[
name|hash
operator|&
name|table
operator|->
name|size_mask
index|]
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* see if entry exists already */
if|if
condition|(
operator|!
operator|(
name|found
operator|=
name|bin_find_entry
argument_list|(
name|table
argument_list|,
name|bin
argument_list|,
name|hash
argument_list|,
name|entry
operator|->
name|key
argument_list|)
operator|)
condition|)
block|{
comment|/* if not: add to bin */
name|entry
operator|->
name|overflow_next
operator|=
name|bin
operator|->
name|overflow_list
expr_stmt|;
name|bin
operator|->
name|overflow_list
operator|=
name|entry
expr_stmt|;
name|lru_front
argument_list|(
name|table
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|table
operator|->
name|num
operator|++
expr_stmt|;
name|table
operator|->
name|space_used
operator|+=
name|need_size
expr_stmt|;
block|}
else|else
block|{
comment|/* if so: update data - needs a writelock */
name|table
operator|->
name|space_used
operator|+=
name|need_size
operator|-
call|(
modifier|*
name|table
operator|->
name|sizefunc
call|)
argument_list|(
name|found
operator|->
name|key
argument_list|,
name|found
operator|->
name|data
argument_list|)
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|delkeyfunc
call|)
argument_list|(
name|entry
operator|->
name|key
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
name|lru_touch
argument_list|(
name|table
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|lock_rw_wrlock
argument_list|(
operator|&
name|found
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|deldatafunc
call|)
argument_list|(
name|found
operator|->
name|data
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
name|found
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|found
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|space_used
operator|>
name|table
operator|->
name|space_max
condition|)
name|reclaim_space
argument_list|(
name|table
argument_list|,
operator|&
name|reclaimlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|num
operator|>=
name|table
operator|->
name|size
condition|)
name|table_grow
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* finish reclaim if any (outside of critical region) */
while|while
condition|(
name|reclaimlist
condition|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|n
init|=
name|reclaimlist
operator|->
name|overflow_next
decl_stmt|;
name|void
modifier|*
name|d
init|=
name|reclaimlist
operator|->
name|data
decl_stmt|;
call|(
modifier|*
name|table
operator|->
name|delkeyfunc
call|)
argument_list|(
name|reclaimlist
operator|->
name|key
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|deldatafunc
call|)
argument_list|(
name|d
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
name|reclaimlist
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|lruhash_entry
modifier|*
name|lruhash_lookup
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|hashvalue_t
name|hash
parameter_list|,
name|void
modifier|*
name|key
parameter_list|,
name|int
name|wr
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|lruhash_bin
modifier|*
name|bin
decl_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_compfunc
argument_list|(
name|table
operator|->
name|compfunc
argument_list|)
argument_list|)
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|table
operator|->
name|array
index|[
name|hash
operator|&
name|table
operator|->
name|size_mask
index|]
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|bin_find_entry
argument_list|(
name|table
argument_list|,
name|bin
argument_list|,
name|hash
argument_list|,
name|key
argument_list|)
operator|)
condition|)
name|lru_touch
argument_list|(
name|table
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|wr
condition|)
block|{
name|lock_rw_wrlock
argument_list|(
operator|&
name|entry
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_rw_rdlock
argument_list|(
operator|&
name|entry
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
name|void
name|lruhash_remove
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|hashvalue_t
name|hash
parameter_list|,
name|void
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|lruhash_bin
modifier|*
name|bin
decl_stmt|;
name|void
modifier|*
name|d
decl_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_sizefunc
argument_list|(
name|table
operator|->
name|sizefunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_delkeyfunc
argument_list|(
name|table
operator|->
name|delkeyfunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_deldatafunc
argument_list|(
name|table
operator|->
name|deldatafunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_compfunc
argument_list|(
name|table
operator|->
name|compfunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_markdelfunc
argument_list|(
name|table
operator|->
name|markdelfunc
argument_list|)
argument_list|)
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|table
operator|->
name|array
index|[
name|hash
operator|&
name|table
operator|->
name|size_mask
index|]
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|bin_find_entry
argument_list|(
name|table
argument_list|,
name|bin
argument_list|,
name|hash
argument_list|,
name|key
argument_list|)
operator|)
condition|)
block|{
name|bin_overflow_remove
argument_list|(
name|bin
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|lru_remove
argument_list|(
name|table
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|table
operator|->
name|num
operator|--
expr_stmt|;
name|table
operator|->
name|space_used
operator|-=
call|(
modifier|*
name|table
operator|->
name|sizefunc
call|)
argument_list|(
name|entry
operator|->
name|key
argument_list|,
name|entry
operator|->
name|data
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_rw_wrlock
argument_list|(
operator|&
name|entry
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|markdelfunc
condition|)
call|(
modifier|*
name|table
operator|->
name|markdelfunc
call|)
argument_list|(
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|entry
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* finish removal */
name|d
operator|=
name|entry
operator|->
name|data
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|delkeyfunc
call|)
argument_list|(
name|entry
operator|->
name|key
argument_list|,
name|table
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|deldatafunc
call|)
argument_list|(
name|d
argument_list|,
name|table
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** clear bin, respecting locks, does not do space, LRU */
end_comment

begin_function
specifier|static
name|void
name|bin_clear
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|struct
name|lruhash_bin
modifier|*
name|bin
parameter_list|)
block|{
name|struct
name|lruhash_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|void
modifier|*
name|d
decl_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p
operator|=
name|bin
operator|->
name|overflow_list
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|lock_rw_wrlock
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
name|np
operator|=
name|p
operator|->
name|overflow_next
expr_stmt|;
name|d
operator|=
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|markdelfunc
condition|)
call|(
modifier|*
name|table
operator|->
name|markdelfunc
call|)
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|delkeyfunc
call|)
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|table
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
call|(
modifier|*
name|table
operator|->
name|deldatafunc
call|)
argument_list|(
name|d
argument_list|,
name|table
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
name|bin
operator|->
name|overflow_list
operator|=
name|NULL
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lruhash_clear
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_delkeyfunc
argument_list|(
name|table
operator|->
name|delkeyfunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_deldatafunc
argument_list|(
name|table
operator|->
name|deldatafunc
argument_list|)
argument_list|)
expr_stmt|;
name|fptr_ok
argument_list|(
name|fptr_whitelist_hash_markdelfunc
argument_list|(
name|table
operator|->
name|markdelfunc
argument_list|)
argument_list|)
expr_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|bin_clear
argument_list|(
name|table
argument_list|,
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|lru_start
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|lru_end
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|num
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|space_used
operator|=
literal|0
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lruhash_status
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|int
name|extended
parameter_list|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"%s: %u entries, memory %u / %u"
argument_list|,
name|id
argument_list|,
operator|(
name|unsigned
operator|)
name|table
operator|->
name|num
argument_list|,
operator|(
name|unsigned
operator|)
name|table
operator|->
name|space_used
argument_list|,
operator|(
name|unsigned
operator|)
name|table
operator|->
name|space_max
argument_list|)
expr_stmt|;
name|log_info
argument_list|(
literal|"  itemsize %u, array %u, mask %d"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|table
operator|->
name|num
condition|?
name|table
operator|->
name|space_used
operator|/
name|table
operator|->
name|num
else|:
literal|0
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|table
operator|->
name|size
argument_list|,
name|table
operator|->
name|size_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|extended
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|min
init|=
operator|(
name|int
operator|)
name|table
operator|->
name|size
operator|*
literal|2
decl_stmt|,
name|max
init|=
operator|-
literal|2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|here
init|=
literal|0
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|en
decl_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|en
operator|=
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|overflow_list
expr_stmt|;
while|while
condition|(
name|en
condition|)
block|{
name|here
operator|++
expr_stmt|;
name|en
operator|=
name|en
operator|->
name|overflow_next
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|extended
operator|>=
literal|2
condition|)
name|log_info
argument_list|(
literal|"bin[%d] %d"
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|,
name|here
argument_list|)
expr_stmt|;
if|if
condition|(
name|here
operator|>
name|max
condition|)
name|max
operator|=
name|here
expr_stmt|;
if|if
condition|(
name|here
operator|<
name|min
condition|)
name|min
operator|=
name|here
expr_stmt|;
block|}
name|log_info
argument_list|(
literal|"  bin min %d, avg %.2lf, max %d"
argument_list|,
name|min
argument_list|,
operator|(
name|double
operator|)
name|table
operator|->
name|num
operator|/
operator|(
name|double
operator|)
name|table
operator|->
name|size
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|lruhash_get_mem
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash
argument_list|)
operator|+
name|table
operator|->
name|space_used
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREAD_DEBUG
if|if
condition|(
name|table
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash_bin
argument_list|)
operator|+
name|lock_get_mem
argument_list|(
operator|&
name|table
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* no THREAD_DEBUG */
if|if
condition|(
name|table
operator|->
name|size
operator|!=
literal|0
condition|)
name|s
operator|+=
operator|(
name|table
operator|->
name|size
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|lruhash_bin
argument_list|)
operator|+
name|lock_get_mem
argument_list|(
operator|&
name|table
operator|->
name|array
index|[
literal|0
index|]
operator|.
name|lock
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|s
operator|+=
name|lock_get_mem
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|lruhash_setmarkdel
parameter_list|(
name|struct
name|lruhash
modifier|*
name|table
parameter_list|,
name|lruhash_markdelfunc_t
name|md
parameter_list|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
name|table
operator|->
name|markdelfunc
operator|=
name|md
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|table
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lruhash_traverse
parameter_list|(
name|struct
name|lruhash
modifier|*
name|h
parameter_list|,
name|int
name|wr
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|lruhash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|lruhash_entry
modifier|*
name|e
decl_stmt|;
name|lock_quick_lock
argument_list|(
operator|&
name|h
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|lock_quick_lock
argument_list|(
operator|&
name|h
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|h
operator|->
name|array
index|[
name|i
index|]
operator|.
name|overflow_list
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|overflow_next
control|)
block|{
if|if
condition|(
name|wr
condition|)
block|{
name|lock_rw_wrlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_rw_rdlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|func
call|)
argument_list|(
name|e
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|lock_rw_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|h
operator|->
name|array
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|h
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

