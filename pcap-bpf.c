begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1998  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* optionally get BSD define */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/*  *<net/bpf.h> defines ioctls, but doesn't include<sys/ioccom.h>.  *  * We include<sys/ioctl.h> as it might be necessary to declare ioctl();  * at least on *BSD and Mac OS X, it also defines various SIOC ioctls -  * we could include<sys/sockio.h>, but if we're already including  *<sys/ioctl.h>, which includes<sys/sockio.h> on those platforms,  * there's not much point in doing so.  *  * If we have<sys/ioccom.h>, we include it as well, to handle systems  * such as Solaris which don't arrange to include<sys/ioccom.h> if you  * include<sys/ioctl.h>  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCCOM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCIFCREATE2
argument_list|)
end_if

begin_comment
comment|/*  * Add support for capturing on FreeBSD usbusN interfaces.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|usbus_prefix
index|[]
init|=
literal|"usbus"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USBUS_PREFIX_LEN
value|(sizeof(usbus_prefix) - 1)
end_define

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
end_ifdef

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_comment
comment|/*  * Make "pcap.h" not include "pcap/bpf.h"; we are going to include the  * native OS version, as we need "struct bpf_config" from it.  */
end_comment

begin_define
define|#
directive|define
name|PCAP_DONT_INCLUDE_PCAP_BPF_H
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/*  * Prevent bpf.h from redefining the DLT_ values to their  * IFT_ values, as we're going to return the standard libpcap  * values, not IBM's non-standard IFT_ values.  */
end_comment

begin_undef
undef|#
directive|undef
name|_AIX
end_undef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_define
define|#
directive|define
name|_AIX
end_define

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_comment
comment|/* for IFT_ values */
end_comment

begin_include
include|#
directive|include
file|<sys/sysconfig.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/cfgodm.h>
end_include

begin_include
include|#
directive|include
file|<cf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__64BIT__
end_ifdef

begin_define
define|#
directive|define
name|domakedev
value|makedev64
end_define

begin_define
define|#
directive|define
name|getmajor
value|major64
end_define

begin_define
define|#
directive|define
name|bpf_hdr
value|bpf_hdr32
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __64BIT__ */
end_comment

begin_define
define|#
directive|define
name|domakedev
value|makedev
end_define

begin_define
define|#
directive|define
name|getmajor
value|major
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __64BIT__ */
end_comment

begin_define
define|#
directive|define
name|BPF_NAME
value|"bpf"
end_define

begin_define
define|#
directive|define
name|BPF_MINORS
value|4
end_define

begin_define
define|#
directive|define
name|DRIVER_PATH
value|"/usr/lib/drivers"
end_define

begin_define
define|#
directive|define
name|BPF_NODE
value|"/dev/bpf"
end_define

begin_decl_stmt
specifier|static
name|int
name|bpfloadedflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|odmlockid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|bpf_load
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _AIX */
end_comment

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIX */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NET_IF_MEDIA_H
end_ifdef

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Later versions of NetBSD stick padding in front of FDDI frames  * to align the IP header on a 4-byte boundary.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
name|__NetBSD_Version__
operator|>
literal|106000000
end_if

begin_define
define|#
directive|define
name|PCAP_FDDIPAD
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Private data for capturing on BPF devices.  */
end_comment

begin_struct
struct|struct
name|pcap_bpf
block|{
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
comment|/* 	 * Zero-copy read buffer -- for zero-copy BPF.  'buffer' above will 	 * alternative between these two actual mmap'd buffers as required. 	 * As there is a header on the front size of the mmap'd buffer, only 	 * some of the buffer is exposed to libpcap as a whole via bufsize; 	 * zbufsize is the true size.  zbuffer tracks the current zbuf 	 * assocated with buffer so that it can be used to decide which the 	 * next buffer to read will be. 	 */
name|u_char
modifier|*
name|zbuf1
decl_stmt|,
modifier|*
name|zbuf2
decl_stmt|,
modifier|*
name|zbuffer
decl_stmt|;
name|u_int
name|zbufsize
decl_stmt|;
name|u_int
name|zerocopy
decl_stmt|;
name|u_int
name|interrupted
decl_stmt|;
name|struct
name|timespec
name|firstsel
decl_stmt|;
comment|/* 	 * If there's currently a buffer being actively processed, then it is 	 * referenced here; 'buffer' is also pointed at it, but offset by the 	 * size of the header. 	 */
name|struct
name|bpf_zbuf_header
modifier|*
name|bzh
decl_stmt|;
name|int
name|nonblock
decl_stmt|;
comment|/* true if in nonblocking mode */
endif|#
directive|endif
comment|/* HAVE_ZEROCOPY_BPF */
name|char
modifier|*
name|device
decl_stmt|;
comment|/* device name */
name|int
name|filtering_in_kernel
decl_stmt|;
comment|/* using kernel filter */
name|int
name|must_do_on_close
decl_stmt|;
comment|/* stuff we must do when we close */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Stuff to do when we close.  */
end_comment

begin_define
define|#
directive|define
name|MUST_CLEAR_RFMON
value|0x00000001
end_define

begin_comment
comment|/* clear rfmon (monitor) mode */
end_comment

begin_define
define|#
directive|define
name|MUST_DESTROY_USBUS
value|0x00000002
end_define

begin_comment
comment|/* destroy usbusN interface */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
end_ifdef

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|HAVE_NET_IF_MEDIA_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|IFM_IEEE80211
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_BSD_IEEE80211
end_define

begin_comment
comment|/*  * The ifm_ulist member of a struct ifmediareq is an int * on most systems,  * but it's a uint64_t on newer versions of OpenBSD.  *  * We check this by checking whether IFM_GMASK is defined and> 2^32-1.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IFM_GMASK
argument_list|)
operator|&&
name|IFM_GMASK
operator|>
literal|0xFFFFFFFF
end_if

begin_define
define|#
directive|define
name|IFM_ULIST_TYPE
value|uint64_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFM_ULIST_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_IEEE80211
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|find_802_11
parameter_list|(
name|struct
name|bpf_dltlist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BSD_IEEE80211
end_ifdef

begin_function_decl
specifier|static
name|int
name|monitor_mode
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|remove_en
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_802_11
parameter_list|(
name|pcap_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__APPLE__) || defined(HAVE_BSD_IEEE80211) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIOCGDLTLIST */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|LIFNAMSIZ
argument_list|)
operator|&&
name|defined
argument_list|(
name|lifr_zoneid
argument_list|)
end_if

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We include the OS's<net/bpf.h>, not our "pcap/bpf.h", so we probably  * don't get DLT_DOCSIS defined.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DLT_DOCSIS
end_ifndef

begin_define
define|#
directive|define
name|DLT_DOCSIS
value|143
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * On OS X, we don't even get any of the 802.11-plus-radio-header DLT_'s  * defined, even though some of them are used by various Airport drivers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DLT_PRISM_HEADER
end_ifndef

begin_define
define|#
directive|define
name|DLT_PRISM_HEADER
value|119
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DLT_AIRONET_HEADER
end_ifndef

begin_define
define|#
directive|define
name|DLT_AIRONET_HEADER
value|120
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DLT_IEEE802_11_RADIO
end_ifndef

begin_define
define|#
directive|define
name|DLT_IEEE802_11_RADIO
value|127
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DLT_IEEE802_11_RADIO_AVS
end_ifndef

begin_define
define|#
directive|define
name|DLT_IEEE802_11_RADIO_AVS
value|163
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|pcap_can_set_rfmon_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_activate_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setfilter_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_setdirection_bpf
parameter_list|(
name|pcap_t
modifier|*
parameter_list|,
name|pcap_direction_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcap_set_datalink_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * For zerocopy bpf, the setnonblock/getnonblock routines need to modify  * pb->nonblock so we don't call select(2) if the pcap handle is in non-  * blocking mode.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_getnonblock_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|zerocopy
condition|)
return|return
operator|(
name|pb
operator|->
name|nonblock
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|pcap_getnonblock_fd
argument_list|(
name|p
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setnonblock_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|zerocopy
condition|)
block|{
name|pb
operator|->
name|nonblock
operator|=
name|nonblock
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pcap_setnonblock_fd
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
end_ifdef

begin_comment
comment|/*  * Zero-copy BPF buffer routines to check for and acknowledge BPF data in  * shared memory buffers.  *  * pcap_next_zbuf_shm(): Check for a newly available shared memory buffer,  * and set up p->buffer and cc to reflect one if available.  Notice that if  * there was no prior buffer, we select zbuf1 as this will be the first  * buffer filled for a fresh BPF session.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_next_zbuf_shm
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|cc
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|struct
name|bpf_zbuf_header
modifier|*
name|bzh
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|zbuffer
operator|==
name|pb
operator|->
name|zbuf2
operator|||
name|pb
operator|->
name|zbuffer
operator|==
name|NULL
condition|)
block|{
name|bzh
operator|=
operator|(
expr|struct
name|bpf_zbuf_header
operator|*
operator|)
name|pb
operator|->
name|zbuf1
expr_stmt|;
if|if
condition|(
name|bzh
operator|->
name|bzh_user_gen
operator|!=
name|atomic_load_acq_int
argument_list|(
operator|&
name|bzh
operator|->
name|bzh_kernel_gen
argument_list|)
condition|)
block|{
name|pb
operator|->
name|bzh
operator|=
name|bzh
expr_stmt|;
name|pb
operator|->
name|zbuffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pb
operator|->
name|zbuf1
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|pb
operator|->
name|zbuffer
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|bzh
argument_list|)
expr_stmt|;
operator|*
name|cc
operator|=
name|bzh
operator|->
name|bzh_kernel_len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pb
operator|->
name|zbuffer
operator|==
name|pb
operator|->
name|zbuf1
condition|)
block|{
name|bzh
operator|=
operator|(
expr|struct
name|bpf_zbuf_header
operator|*
operator|)
name|pb
operator|->
name|zbuf2
expr_stmt|;
if|if
condition|(
name|bzh
operator|->
name|bzh_user_gen
operator|!=
name|atomic_load_acq_int
argument_list|(
operator|&
name|bzh
operator|->
name|bzh_kernel_gen
argument_list|)
condition|)
block|{
name|pb
operator|->
name|bzh
operator|=
name|bzh
expr_stmt|;
name|pb
operator|->
name|zbuffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pb
operator|->
name|zbuf2
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|pb
operator|->
name|zbuffer
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|bzh
argument_list|)
expr_stmt|;
operator|*
name|cc
operator|=
name|bzh
operator|->
name|bzh_kernel_len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pcap_next_zbuf() -- Similar to pcap_next_zbuf_shm(), except wait using  * select() for data or a timeout, and possibly force rotation of the buffer  * in the event we time out or are in immediate mode.  Invoke the shared  * memory check before doing system calls in order to avoid doing avoidable  * work.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_next_zbuf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|cc
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|struct
name|bpf_zbuf
name|bz
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timespec
name|cur
decl_stmt|;
name|fd_set
name|r_set
decl_stmt|;
name|int
name|data
decl_stmt|,
name|r
decl_stmt|;
name|int
name|expire
decl_stmt|,
name|tmout
decl_stmt|;
define|#
directive|define
name|TSTOMILLI
parameter_list|(
name|ts
parameter_list|)
value|(((ts)->tv_sec * 1000) + ((ts)->tv_nsec / 1000000))
comment|/* 	 * Start out by seeing whether anything is waiting by checking the 	 * next shared memory buffer for data. 	 */
name|data
operator|=
name|pcap_next_zbuf_shm
argument_list|(
name|p
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
return|return
operator|(
name|data
operator|)
return|;
comment|/* 	 * If a previous sleep was interrupted due to signal delivery, make 	 * sure that the timeout gets adjusted accordingly.  This requires 	 * that we analyze when the timeout should be been expired, and 	 * subtract the current time from that.  If after this operation, 	 * our timeout is less then or equal to zero, handle it like a 	 * regular timeout. 	 */
name|tmout
operator|=
name|p
operator|->
name|opt
operator|.
name|timeout
expr_stmt|;
if|if
condition|(
name|tmout
condition|)
operator|(
name|void
operator|)
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|interrupted
operator|&&
name|p
operator|->
name|opt
operator|.
name|timeout
condition|)
block|{
name|expire
operator|=
name|TSTOMILLI
argument_list|(
operator|&
name|pb
operator|->
name|firstsel
argument_list|)
operator|+
name|p
operator|->
name|opt
operator|.
name|timeout
expr_stmt|;
name|tmout
operator|=
name|expire
operator|-
name|TSTOMILLI
argument_list|(
operator|&
name|cur
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|TSTOMILLI
if|if
condition|(
name|tmout
operator|<=
literal|0
condition|)
block|{
name|pb
operator|->
name|interrupted
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|pcap_next_zbuf_shm
argument_list|(
name|p
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
return|return
operator|(
name|data
operator|)
return|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCROTZBUF
argument_list|,
operator|&
name|bz
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCROTZBUF: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|pcap_next_zbuf_shm
argument_list|(
name|p
argument_list|,
name|cc
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * No data in the buffer, so must use select() to wait for data or 	 * the next timeout.  Note that we only call select if the handle 	 * is in blocking mode. 	 */
if|if
condition|(
operator|!
name|pb
operator|->
name|nonblock
condition|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|r_set
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|&
name|r_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmout
operator|!=
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|tmout
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|tmout
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
block|}
name|r
operator|=
name|select
argument_list|(
name|p
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|r_set
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
operator|->
name|opt
operator|.
name|timeout
operator|!=
literal|0
condition|?
operator|&
name|tv
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
operator|!
name|pb
operator|->
name|interrupted
operator|&&
name|p
operator|->
name|opt
operator|.
name|timeout
condition|)
block|{
name|pb
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
name|pb
operator|->
name|firstsel
operator|=
name|cur
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"select: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
name|pb
operator|->
name|interrupted
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check again for data, which may exist now that we've either been 	 * woken up as a result of data or timed out.  Try the "there's data" 	 * case first since it doesn't require a system call. 	 */
name|data
operator|=
name|pcap_next_zbuf_shm
argument_list|(
name|p
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
return|return
operator|(
name|data
operator|)
return|;
comment|/* 	 * Try forcing a buffer rotation to dislodge timed out or immediate 	 * data. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCROTZBUF
argument_list|,
operator|&
name|bz
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCROTZBUF: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|pcap_next_zbuf_shm
argument_list|(
name|p
argument_list|,
name|cc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify kernel that we are done with the buffer.  We don't reset zbuffer so  * that we know which buffer to use next time around.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_ack_zbuf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|pb
operator|->
name|bzh
operator|->
name|bzh_user_gen
argument_list|,
name|pb
operator|->
name|bzh
operator|->
name|bzh_kernel_gen
argument_list|)
expr_stmt|;
name|pb
operator|->
name|bzh
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ZEROCOPY_BPF */
end_comment

begin_function
name|pcap_t
modifier|*
name|pcap_create_interface
parameter_list|(
specifier|const
name|char
modifier|*
name|device
name|_U_
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pcap_create_common
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_bpf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|->
name|activate_op
operator|=
name|pcap_activate_bpf
expr_stmt|;
name|p
operator|->
name|can_set_rfmon_op
operator|=
name|pcap_can_set_rfmon_bpf
expr_stmt|;
ifdef|#
directive|ifdef
name|BIOCSTSTAMP
comment|/* 	 * We claim that we support microsecond and nanosecond time 	 * stamps. 	 */
name|p
operator|->
name|tstamp_precision_count
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|tstamp_precision_list
operator|=
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tstamp_precision_list
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|tstamp_precision_list
index|[
literal|0
index|]
operator|=
name|PCAP_TSTAMP_PRECISION_MICRO
expr_stmt|;
name|p
operator|->
name|tstamp_precision_list
index|[
literal|1
index|]
operator|=
name|PCAP_TSTAMP_PRECISION_NANO
expr_stmt|;
endif|#
directive|endif
comment|/* BIOCSTSTAMP */
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On success, returns a file descriptor for a BPF device.  * On failure, returns a PCAP_ERROR_ value, and sets p->errbuf.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_open
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_CLONING_BPF
specifier|static
specifier|const
name|char
name|device
index|[]
init|=
literal|"/dev/bpf"
decl_stmt|;
else|#
directive|else
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
name|device
index|[
sizeof|sizeof
expr|"/dev/bpf0000000000"]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_AIX
comment|/* 	 * Load the bpf driver, if it isn't already loaded, 	 * and create the BPF device entries, if they don't 	 * already exist. 	 */
if|if
condition|(
name|bpf_load
argument_list|(
name|errbuf
argument_list|)
operator|==
name|PCAP_ERROR
condition|)
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_CLONING_BPF
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|!=
name|EACCES
operator|||
operator|(
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
name|fd
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
else|else
name|fd
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"(cannot open device) %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * Go through all the minors and find one that isn't in use. 	 */
do|do
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|,
literal|"/dev/bpf%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 * Initially try a read/write open (to allow the inject 		 * method to work).  If that fails due to permission 		 * issues, fall back to read-only.  This allows a 		 * non-root user to be granted specific access to pcap 		 * capabilities via file permissions. 		 * 		 * XXX - we should have an API that has a flag that 		 * controls whether to open read-only or read-write, 		 * so that denial of permission to send (or inability 		 * to send, if sending packets isn't supported on 		 * the device in question) can be indicated at open 		 * time. 		 */
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EBUSY
condition|)
do|;
comment|/* 	 * XXX better message for all minors used 	 */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|fd
operator|=
name|PCAP_ERROR
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* 				 * /dev/bpf0 doesn't exist, which 				 * means we probably have no BPF 				 * devices. 				 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"(there are no BPF devices)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We got EBUSY on at least one 				 * BPF device, so we have BPF 				 * devices, but all the ones 				 * that exist are busy. 				 */
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"(all BPF devices are busy)"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EACCES
case|:
comment|/* 			 * Got EACCES on the last device we tried, 			 * and EBUSY on all devices before that, 			 * if any. 			 */
name|fd
operator|=
name|PCAP_ERROR_PERM_DENIED
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"(cannot open BPF device) %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Some other problem. 			 */
name|fd
operator|=
name|PCAP_ERROR
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"(cannot open BPF device) %s: %s"
argument_list|,
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open and bind to a device; used if we're not actually going to use  * the device, but are just testing whether it can be opened, or opening  * it to get information about it.  *  * Returns an error code on failure (always negative), and an FD for  * the now-bound BPF device on success (always non-negative).  */
end_comment

begin_function
specifier|static
name|int
name|bpf_open_and_bind
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
comment|/* 	 * First, open a BPF device. 	 */
name|fd
operator|=
name|bpf_open
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
comment|/* fd is the appropriate error code */
comment|/* 	 * Now bind to the device. 	 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENXIO
case|:
comment|/* 			 * There's no such device. 			 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
case|case
name|ENETDOWN
case|:
comment|/* 			 * Return a "network down" indication, so that 			 * the application can report that rather than 			 * saying we had a mysterious failure and 			 * suggest that they report a problem to the 			 * libpcap developers. 			 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_IFACE_NOT_UP
operator|)
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETIF: %s: %s"
argument_list|,
name|name
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
comment|/* 	 * Success. 	 */
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
end_ifdef

begin_function
specifier|static
name|int
name|get_dlt_list
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|v
parameter_list|,
name|struct
name|bpf_dltlist
modifier|*
name|bdlp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|memset
argument_list|(
name|bdlp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bdlp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLTLIST
argument_list|,
operator|(
name|caddr_t
operator|)
name|bdlp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|is_ethernet
decl_stmt|;
name|bdlp
operator|->
name|bfl_list
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|*
operator|(
name|bdlp
operator|->
name|bfl_len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdlp
operator|->
name|bfl_list
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLTLIST
argument_list|,
operator|(
name|caddr_t
operator|)
name|bdlp
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGDLTLIST: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bdlp
operator|->
name|bfl_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/* 		 * OK, for real Ethernet devices, add DLT_DOCSIS to the 		 * list, so that an application can let you choose it, 		 * in case you're capturing DOCSIS traffic that a Cisco 		 * Cable Modem Termination System is putting out onto 		 * an Ethernet (it doesn't put an Ethernet header onto 		 * the wire, it puts raw DOCSIS frames out on the wire 		 * inside the low-level Ethernet framing). 		 * 		 * A "real Ethernet device" is defined here as a device 		 * that has a link-layer type of DLT_EN10MB and that has 		 * no alternate link-layer types; that's done to exclude 		 * 802.11 interfaces (which might or might not be the 		 * right thing to do, but I suspect it is - Ethernet<-> 		 * 802.11 bridges would probably badly mishandle frames 		 * that don't have Ethernet headers). 		 * 		 * On Solaris with BPF, Ethernet devices also offer 		 * DLT_IPNET, so we, if DLT_IPNET is defined, we don't 		 * treat it as an indication that the device isn't an 		 * Ethernet. 		 */
if|if
condition|(
name|v
operator|==
name|DLT_EN10MB
condition|)
block|{
name|is_ethernet
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bdlp
operator|->
name|bfl_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bdlp
operator|->
name|bfl_list
index|[
name|i
index|]
operator|!=
name|DLT_EN10MB
ifdef|#
directive|ifdef
name|DLT_IPNET
operator|&&
name|bdlp
operator|->
name|bfl_list
index|[
name|i
index|]
operator|!=
name|DLT_IPNET
endif|#
directive|endif
condition|)
block|{
name|is_ethernet
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is_ethernet
condition|)
block|{
comment|/* 				 * We reserved one more slot at the end of 				 * the list. 				 */
name|bdlp
operator|->
name|bfl_list
index|[
name|bdlp
operator|->
name|bfl_len
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
name|bdlp
operator|->
name|bfl_len
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * EINVAL just means "we don't support this ioctl on 		 * this device"; don't treat it as an error. 		 */
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGDLTLIST: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pcap_can_set_rfmon_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
name|struct
name|utsname
name|osinfo
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
name|struct
name|bpf_dltlist
name|bdl
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * The joys of monitor mode on OS X. 	 * 	 * Prior to 10.4, it's not supported at all. 	 * 	 * In 10.4, if adapter enN supports monitor mode, there's a 	 * wltN adapter corresponding to it; you open it, instead of 	 * enN, to get monitor mode.  You get whatever link-layer 	 * headers it supplies. 	 * 	 * In 10.5, and, we assume, later releases, if adapter enN 	 * supports monitor mode, it offers, among its selectable 	 * DLT_ values, values that let you get the 802.11 header; 	 * selecting one of those values puts the adapter into monitor 	 * mode (i.e., you can't get 802.11 headers except in monitor 	 * mode, and you can't get Ethernet headers in monitor mode). 	 */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|osinfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Can't get the OS version; just say "no". 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We assume osinfo.sysname is "Darwin", because 	 * __APPLE__ is defined.  We just check the version. 	 */
if|if
condition|(
name|osinfo
operator|.
name|release
index|[
literal|0
index|]
operator|<
literal|'8'
operator|&&
name|osinfo
operator|.
name|release
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * 10.3 (Darwin 7.x) or earlier. 		 * Monitor mode not supported. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|osinfo
operator|.
name|release
index|[
literal|0
index|]
operator|==
literal|'8'
operator|&&
name|osinfo
operator|.
name|release
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * 10.4 (Darwin 8.x).  s/en/wlt/, and check 		 * whether the device exists. 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"en"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Not an enN device; no monitor mode. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
literal|"wlt"
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 			 * No such device? 			 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
comment|/* 	 * Everything else is 10.5 or later; for those, 	 * we just open the enN device, and check whether 	 * we have any 802.11 devices. 	 * 	 * First, open a BPF device. 	 */
name|fd
operator|=
name|bpf_open
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
comment|/* fd is the appropriate error code */
comment|/* 	 * Now bind to the device. 	 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENXIO
case|:
comment|/* 			 * There's no such device. 			 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
case|case
name|ENETDOWN
case|:
comment|/* 			 * Return a "network down" indication, so that 			 * the application can report that rather than 			 * saying we had a mysterious failure and 			 * suggest that they report a problem to the 			 * libpcap developers. 			 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_IFACE_NOT_UP
operator|)
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETIF: %s: %s"
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
comment|/* 	 * We know the default link type -- now determine all the DLTs 	 * this interface supports.  If this fails with EINVAL, it's 	 * not fatal; we just don't get to use the feature later. 	 * (We don't care about DLT_DOCSIS, so we pass DLT_NULL 	 * as the default DLT for this adapter.) 	 */
if|if
condition|(
name|get_dlt_list
argument_list|(
name|fd
argument_list|,
name|DLT_NULL
argument_list|,
operator|&
name|bdl
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|==
name|PCAP_ERROR
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|find_802_11
argument_list|(
operator|&
name|bdl
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * We have an 802.11 DLT, so we can set monitor mode. 		 */
name|free
argument_list|(
name|bdl
operator|.
name|bfl_list
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|bdl
operator|.
name|bfl_list
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BIOCGDLTLIST */
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_BSD_IEEE80211
argument_list|)
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|monitor_mode
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|PCAP_ERROR_RFMON_NOTSUP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not an error, just a "can't do" */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* success */
return|return
operator|(
name|ret
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_stats_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|bpf_stat
name|s
decl_stmt|;
comment|/* 	 * "ps_recv" counts packets handed to the filter, not packets 	 * that passed the filter.  This includes packets later dropped 	 * because we ran out of buffer space. 	 * 	 * "ps_drop" counts packets dropped inside the BPF device 	 * because we ran out of buffer space.  It doesn't count 	 * packets dropped by the interface driver.  It counts 	 * only packets that passed the filter. 	 * 	 * Both statistics include packets not yet read from the kernel 	 * by libpcap, and thus not yet seen by the application. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCGSTATS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGSTATS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|ps
operator|->
name|ps_recv
operator|=
name|s
operator|.
name|bs_recv
expr_stmt|;
name|ps
operator|->
name|ps_drop
operator|=
name|s
operator|.
name|bs_drop
expr_stmt|;
name|ps
operator|->
name|ps_ifdrop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_read_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|u_char
modifier|*
name|datap
decl_stmt|;
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
specifier|register
name|u_int
name|pad
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|again
label|:
comment|/* 	 * Has "pcap_breakloop()" been called? 	 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
comment|/* 		 * Yes - clear the flag that indicates that it 		 * has, and return PCAP_ERROR_BREAK to indicate 		 * that we were told to break out of the loop. 		 */
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_BREAK
operator|)
return|;
block|}
name|cc
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|cc
operator|==
literal|0
condition|)
block|{
comment|/* 		 * When reading without zero-copy from a file descriptor, we 		 * use a single buffer and return a length of data in the 		 * buffer.  With zero-copy, we update the p->buffer pointer 		 * to point at whatever underlying buffer contains the next 		 * data and update cc to reflect the data found in the 		 * buffer. 		 */
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
if|if
condition|(
name|pb
operator|->
name|zerocopy
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|buffer
operator|!=
name|NULL
condition|)
name|pcap_ack_zbuf
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|i
operator|=
name|pcap_next_zbuf
argument_list|(
name|p
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|cc
operator|=
name|read
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|p
operator|->
name|buffer
argument_list|,
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
comment|/* Don't choke when we get ptraced */
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINTR
case|:
goto|goto
name|again
goto|;
ifdef|#
directive|ifdef
name|_AIX
case|case
name|EFAULT
case|:
comment|/* 				 * Sigh.  More AIX wonderfulness. 				 * 				 * For some unknown reason the uiomove() 				 * operation in the bpf kernel extension 				 * used to copy the buffer into user 				 * space sometimes returns EFAULT. I have 				 * no idea why this is the case given that 				 * a kernel debugger shows the user buffer 				 * is correct. This problem appears to 				 * be mostly mitigated by the memset of 				 * the buffer before it is first used. 				 * Very strange.... Shaun Clowes 				 * 				 * In any case this means that we shouldn't 				 * treat EFAULT as a fatal error; as we 				 * don't have an API for returning 				 * a "some packets were dropped since 				 * the last packet you saw" indication, 				 * we just ignore EFAULT and keep reading. 				 */
goto|goto
name|again
goto|;
endif|#
directive|endif
case|case
name|EWOULDBLOCK
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ENXIO
case|:
comment|/* 				 * The device on which we're capturing 				 * went away. 				 * 				 * XXX - we should really return 				 * PCAP_ERROR_IFACE_NOT_UP, but 				 * pcap_dispatch() etc. aren't 				 * defined to retur that. 				 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The interface went down"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__SVR4
argument_list|)
comment|/* 			 * Due to a SunOS bug, after 2^31 bytes, the kernel 			 * file offset overflows and read fails with EINVAL. 			 * The lseek() to 0 will fix things. 			 */
case|case
name|EINVAL
case|:
if|if
condition|(
name|lseek
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|+
name|p
operator|->
name|bufsize
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|p
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* fall through */
endif|#
directive|endif
block|}
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"read: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|bp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|->
name|buffer
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|p
operator|->
name|bp
expr_stmt|;
comment|/* 	 * Loop through each packet. 	 */
ifdef|#
directive|ifdef
name|BIOCSTSTAMP
define|#
directive|define
name|bhp
value|((struct bpf_xhdr *)bp)
else|#
directive|else
define|#
directive|define
name|bhp
value|((struct bpf_hdr *)bp)
endif|#
directive|endif
name|ep
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
name|pad
operator|=
name|p
operator|->
name|fddipad
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
specifier|register
name|u_int
name|caplen
decl_stmt|,
name|hdrlen
decl_stmt|;
comment|/* 		 * Has "pcap_breakloop()" been called? 		 * If so, return immediately - if we haven't read any 		 * packets, clear the flag and return PCAP_ERROR_BREAK 		 * to indicate that we were told to break out of the loop, 		 * otherwise leave the flag set, so that the *next* call 		 * will break out of the loop without having read any 		 * packets, and return the number of packets we've 		 * processed so far. 		 */
if|if
condition|(
name|p
operator|->
name|break_loop
condition|)
block|{
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|p
operator|->
name|cc
operator|=
name|ep
operator|-
name|bp
expr_stmt|;
comment|/* 			 * ep is set based on the return value of read(), 			 * but read() from a BPF device doesn't necessarily 			 * return a value that's a multiple of the alignment 			 * value for BPF_WORDALIGN().  However, whenever we 			 * increment bp, we round up the increment value by 			 * a value rounded up by BPF_WORDALIGN(), so we 			 * could increment bp past ep after processing the 			 * last packet in the buffer. 			 * 			 * We treat ep< bp as an indication that this 			 * happened, and just set p->cc to 0. 			 */
if|if
condition|(
name|p
operator|->
name|cc
operator|<
literal|0
condition|)
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_BREAK
operator|)
return|;
block|}
else|else
return|return
operator|(
name|n
operator|)
return|;
block|}
name|caplen
operator|=
name|bhp
operator|->
name|bh_caplen
expr_stmt|;
name|hdrlen
operator|=
name|bhp
operator|->
name|bh_hdrlen
expr_stmt|;
name|datap
operator|=
name|bp
operator|+
name|hdrlen
expr_stmt|;
comment|/* 		 * Short-circuit evaluation: if using BPF filter 		 * in kernel, no need to do it now - we already know 		 * the packet passed the filter. 		 * #ifdef PCAP_FDDIPAD 		 * Note: the filter code was generated assuming 		 * that p->fddipad was the amount of padding 		 * before the header, as that's what's required 		 * in the kernel, so we run the filter before 		 * skipping that padding. #endif 		 */
if|if
condition|(
name|pb
operator|->
name|filtering_in_kernel
operator|||
name|bpf_filter
argument_list|(
name|p
operator|->
name|fcode
operator|.
name|bf_insns
argument_list|,
name|datap
argument_list|,
name|bhp
operator|->
name|bh_datalen
argument_list|,
name|caplen
argument_list|)
condition|)
block|{
name|struct
name|pcap_pkthdr
name|pkthdr
decl_stmt|;
ifdef|#
directive|ifdef
name|BIOCSTSTAMP
name|struct
name|bintime
name|bt
decl_stmt|;
name|bt
operator|.
name|sec
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|bt_sec
expr_stmt|;
name|bt
operator|.
name|frac
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|bt_frac
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|tstamp_precision
operator|==
name|PCAP_TSTAMP_PRECISION_NANO
condition|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|bintime2timespec
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|pkthdr
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|pkthdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
expr_stmt|;
block|}
else|else
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|pkthdr
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|pkthdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
else|#
directive|else
name|pkthdr
operator|.
name|ts
operator|.
name|tv_sec
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|tv_sec
expr_stmt|;
ifdef|#
directive|ifdef
name|_AIX
comment|/* 			 * AIX's BPF returns seconds/nanoseconds time 			 * stamps, not seconds/microseconds time stamps. 			 */
name|pkthdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
name|pkthdr
operator|.
name|ts
operator|.
name|tv_usec
operator|=
name|bhp
operator|->
name|bh_tstamp
operator|.
name|tv_usec
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* BIOCSTSTAMP */
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
if|if
condition|(
name|caplen
operator|>
name|pad
condition|)
name|pkthdr
operator|.
name|caplen
operator|=
name|caplen
operator|-
name|pad
expr_stmt|;
else|else
name|pkthdr
operator|.
name|caplen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bhp
operator|->
name|bh_datalen
operator|>
name|pad
condition|)
name|pkthdr
operator|.
name|len
operator|=
name|bhp
operator|->
name|bh_datalen
operator|-
name|pad
expr_stmt|;
else|else
name|pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|datap
operator|+=
name|pad
expr_stmt|;
else|#
directive|else
name|pkthdr
operator|.
name|caplen
operator|=
name|caplen
expr_stmt|;
name|pkthdr
operator|.
name|len
operator|=
name|bhp
operator|->
name|bh_datalen
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
operator|&
name|pkthdr
argument_list|,
name|datap
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|BPF_WORDALIGN
argument_list|(
name|caplen
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|cnt
operator|&&
operator|!
name|PACKET_COUNT_IS_UNLIMITED
argument_list|(
name|cnt
argument_list|)
condition|)
block|{
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|p
operator|->
name|cc
operator|=
name|ep
operator|-
name|bp
expr_stmt|;
comment|/* 				 * See comment above about p->cc< 0. 				 */
if|if
condition|(
name|p
operator|->
name|cc
operator|<
literal|0
condition|)
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Skip this packet. 			 */
name|bp
operator|+=
name|BPF_WORDALIGN
argument_list|(
name|caplen
operator|+
name|hdrlen
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|bhp
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_inject_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__APPLE__
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAFNOSUPPORT
condition|)
block|{
comment|/* 		 * In Mac OS X, there's a bug wherein setting the 		 * BIOCSHDRCMPLT flag causes writes to fail; see, 		 * for example: 		 * 		 *	http://cerberus.sourcefire.com/~jeff/archives/patches/macosx/BIOCSHDRCMPLT-10.3.3.patch 		 * 		 * So, if, on OS X, we get EAFNOSUPPORT from the write, we 		 * assume it's due to that bug, and turn off that flag 		 * and try again.  If we succeed, it either means that 		 * somebody applied the fix from that URL, or other patches 		 * for that bug from 		 * 		 *	http://cerberus.sourcefire.com/~jeff/archives/patches/macosx/ 		 * 		 * and are running a Darwin kernel with those fixes, or 		 * that Apple fixed the problem in some OS X release. 		 */
name|u_int
name|spoof_eth_src
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSHDRCMPLT
argument_list|,
operator|&
name|spoof_eth_src
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: can't turn off BIOCSHDRCMPLT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/* 		 * Now try the write again. 		 */
name|ret
operator|=
name|write
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __APPLE__ */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"send: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_function
specifier|static
name|int
name|bpf_odminit
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
modifier|*
name|errstr
decl_stmt|;
if|if
condition|(
name|odm_initialize
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_initialize failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|odmlockid
operator|=
name|odm_lock
argument_list|(
literal|"/etc/objrepos/config_lock"
argument_list|,
name|ODM_WAIT
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_lock of /etc/objrepos/config_lock failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|odm_terminate
argument_list|()
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_odmcleanup
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|char
modifier|*
name|errstr
decl_stmt|;
if|if
condition|(
name|odm_unlock
argument_list|(
name|odmlockid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_unlock failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|odm_terminate
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|odm_err_msg
argument_list|(
name|odmerrno
argument_list|,
operator|&
name|errstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errstr
operator|=
literal|"Unknown error"
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: odm_terminate failed: %s"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_load
parameter_list|(
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|long
name|major
decl_stmt|;
name|int
modifier|*
name|minors
decl_stmt|;
name|int
name|numminors
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|struct
name|bpf_config
name|cfg_bpf
decl_stmt|;
name|struct
name|cfg_load
name|cfg_ld
decl_stmt|;
name|struct
name|cfg_kmod
name|cfg_km
decl_stmt|;
comment|/* 	 * This is very very close to what happens in the real implementation 	 * but I've fixed some (unlikely) bug situations. 	 */
if|if
condition|(
name|bpfloadedflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bpf_odminit
argument_list|(
name|errbuf
argument_list|)
operator|==
name|PCAP_ERROR
condition|)
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
name|major
operator|=
name|genmajor
argument_list|(
name|BPF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|major
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: genmajor failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bpf_odmcleanup
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|minors
operator|=
name|getminor
argument_list|(
name|major
argument_list|,
operator|&
name|numminors
argument_list|,
name|BPF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|minors
condition|)
block|{
name|minors
operator|=
name|genminor
argument_list|(
literal|"bpf"
argument_list|,
name|major
argument_list|,
literal|0
argument_list|,
name|BPF_MINORS
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|minors
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: genminor failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bpf_odmcleanup
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bpf_odmcleanup
argument_list|(
name|errbuf
argument_list|)
operator|==
name|PCAP_ERROR
condition|)
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
name|rc
operator|=
name|stat
argument_list|(
name|BPF_NODE
literal|"0"
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: can't stat %s: %s"
argument_list|,
name|BPF_NODE
literal|"0"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
operator|||
name|getmajor
argument_list|(
name|sbuf
operator|.
name|st_rdev
argument_list|)
operator|!=
name|major
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BPF_MINORS
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|BPF_NODE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|buf
argument_list|,
name|S_IRUSR
operator||
name|S_IFCHR
argument_list|,
name|domakedev
argument_list|(
name|major
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: can't mknod %s: %s"
argument_list|,
name|buf
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
block|}
comment|/* Check if the driver is loaded */
name|memset
argument_list|(
operator|&
name|cfg_ld
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_ld
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_ld
operator|.
name|path
operator|=
name|buf
expr_stmt|;
name|sprintf
argument_list|(
name|cfg_ld
operator|.
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|DRIVER_PATH
argument_list|,
name|BPF_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sysconfig
argument_list|(
name|SYS_QUERYLOAD
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_ld
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_ld
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|cfg_ld
operator|.
name|kmid
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Driver isn't loaded, load it now */
if|if
condition|(
name|sysconfig
argument_list|(
name|SYS_SINGLELOAD
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_ld
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_ld
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: could not load driver: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
comment|/* Configure the driver */
name|cfg_km
operator|.
name|cmd
operator|=
name|CFG_INIT
expr_stmt|;
name|cfg_km
operator|.
name|kmid
operator|=
name|cfg_ld
operator|.
name|kmid
expr_stmt|;
name|cfg_km
operator|.
name|mdilen
operator|=
sizeof|sizeof
argument_list|(
name|cfg_bpf
argument_list|)
expr_stmt|;
name|cfg_km
operator|.
name|mdiptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_bpf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BPF_MINORS
condition|;
name|i
operator|++
control|)
block|{
name|cfg_bpf
operator|.
name|devno
operator|=
name|domakedev
argument_list|(
name|major
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysconfig
argument_list|(
name|SYS_CFGKMOD
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cfg_km
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_km
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"bpf_load: could not configure driver: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
name|bpfloadedflag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Undo any operations done when opening the device when necessary.  */
end_comment

begin_function
specifier|static
name|void
name|pcap_cleanup_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_BSD_IEEE80211
name|int
name|sock
decl_stmt|;
name|struct
name|ifmediareq
name|req
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pb
operator|->
name|must_do_on_close
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * There's something we have to do when closing this 		 * pcap_t. 		 */
ifdef|#
directive|ifdef
name|HAVE_BSD_IEEE80211
if|if
condition|(
name|pb
operator|->
name|must_do_on_close
operator|&
name|MUST_CLEAR_RFMON
condition|)
block|{
comment|/* 			 * We put the interface into rfmon mode; 			 * take it out of rfmon mode. 			 * 			 * XXX - if somebody else wants it in rfmon 			 * mode, this code cannot know that, so it'll take 			 * it out of rfmon mode. 			 */
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface flags (socket() failed: %s).\n"
literal|"Please adjust manually.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|req
operator|.
name|ifm_name
argument_list|,
name|pb
operator|->
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|.
name|ifm_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFMEDIA
argument_list|,
operator|&
name|req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface flags (SIOCGIFMEDIA failed: %s).\n"
literal|"Please adjust manually.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|req
operator|.
name|ifm_current
operator|&
name|IFM_IEEE80211_MONITOR
condition|)
block|{
comment|/* 						 * Rfmon mode is currently on; 						 * turn it off. 						 */
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|pb
operator|->
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|ifr
operator|.
name|ifr_media
operator|=
name|req
operator|.
name|ifm_current
operator|&
operator|~
name|IFM_IEEE80211_MONITOR
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCSIFMEDIA
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't restore interface flags (SIOCSIFMEDIA failed: %s).\n"
literal|"Please adjust manually.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_IEEE80211 */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCIFCREATE2
argument_list|)
comment|/* 		 * Attempt to destroy the usbusN interface that we created. 		 */
if|if
condition|(
name|pb
operator|->
name|must_do_on_close
operator|&
name|MUST_DESTROY_USBUS
condition|)
block|{
if|if
condition|(
name|if_nametoindex
argument_list|(
name|pb
operator|->
name|device
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_LOCAL
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|pb
operator|->
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCIFDESTROY
argument_list|,
operator|&
name|ifr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* defined(__FreeBSD__)&& defined(SIOCIFCREATE2) */
comment|/* 		 * Take this pcap out of the list of pcaps for which we 		 * have to take the interface out of some mode. 		 */
name|pcap_remove_from_pcaps_to_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pb
operator|->
name|must_do_on_close
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
if|if
condition|(
name|pb
operator|->
name|zerocopy
condition|)
block|{
comment|/* 		 * Delete the mappings.  Note that p->buffer gets 		 * initialized to one of the mmapped regions in 		 * this case, so do not try and free it directly; 		 * null it out so that pcap_cleanup_live_common() 		 * doesn't try to free it. 		 */
if|if
condition|(
name|pb
operator|->
name|zbuf1
operator|!=
name|MAP_FAILED
operator|&&
name|pb
operator|->
name|zbuf1
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|pb
operator|->
name|zbuf1
argument_list|,
name|pb
operator|->
name|zbufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|zbuf2
operator|!=
name|MAP_FAILED
operator|&&
name|pb
operator|->
name|zbuf2
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|pb
operator|->
name|zbuf2
argument_list|,
name|pb
operator|->
name|zbufsize
argument_list|)
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pb
operator|->
name|device
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pb
operator|->
name|device
argument_list|)
expr_stmt|;
name|pb
operator|->
name|device
operator|=
name|NULL
expr_stmt|;
block|}
name|pcap_cleanup_live_common
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_setif_failure
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|error
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__APPLE__
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|err
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
block|{
comment|/* 		 * No such device exists. 		 */
ifdef|#
directive|ifdef
name|__APPLE__
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
operator|&&
name|strncmp
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"wlt"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Monitor mode was requested, and we're trying 			 * to open a "wltN" device.  Assume that this 			 * is 10.4 and that we were asked to open an 			 * "enN" device; if that device exists, return 			 * "monitor mode not supported on the device". 			 */
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
literal|"en"
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
operator|+
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 					 * We assume this failed because 					 * the underlying device doesn't 					 * exist. 					 */
name|err
operator|=
name|PCAP_ERROR_NO_SUCH_DEVICE
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFFLAGS on %s failed: %s"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * The underlying "enN" device 					 * exists, but there's no 					 * corresponding "wltN" device; 					 * that means that the "enN" 					 * device doesn't support 					 * monitor mode, probably because 					 * it's an Ethernet device rather 					 * than a wireless device. 					 */
name|err
operator|=
name|PCAP_ERROR_RFMON_NOTSUP
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We can't find out whether there's 				 * an underlying "enN" device, so 				 * just report "no such device". 				 */
name|err
operator|=
name|PCAP_ERROR_NO_SUCH_DEVICE
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 		 * No such device. 		 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETIF failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENETDOWN
condition|)
block|{
comment|/* 		 * Return a "network down" indication, so that 		 * the application can report that rather than 		 * saying we had a mysterious failure and 		 * suggest that they report a problem to the 		 * libpcap developers. 		 */
return|return
operator|(
name|PCAP_ERROR_IFACE_NOT_UP
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Some other error; fill in the error string, and 		 * return PCAP_ERROR. 		 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETIF: %s: %s"
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Default capture buffer size.  * 32K isn't very much for modern machines with fast networks; we  * pick .5M, as that's the maximum on at least some systems with BPF.  *  * However, on AIX 3.5, the larger buffer sized caused unrecoverable  * read failures under stress, so we leave it as 32K; yet another  * place where AIX's BPF is broken.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_BUFSIZE
value|32768
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_BUFSIZE
value|524288
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pcap_activate_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_BSD_IEEE80211
name|int
name|retv
decl_stmt|;
endif|#
directive|endif
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|LIFNAMSIZ
name|char
modifier|*
name|zonesep
decl_stmt|;
name|struct
name|lifreq
name|ifr
decl_stmt|;
name|char
modifier|*
name|ifrname
init|=
name|ifr
operator|.
name|lifr_name
decl_stmt|;
specifier|const
name|size_t
name|ifnamsiz
init|=
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|lifr_name
argument_list|)
decl_stmt|;
else|#
directive|else
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|char
modifier|*
name|ifrname
init|=
name|ifr
operator|.
name|ifr_name
decl_stmt|;
specifier|const
name|size_t
name|ifnamsiz
init|=
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|struct
name|bpf_version
name|bv
decl_stmt|;
ifdef|#
directive|ifdef
name|__APPLE__
name|int
name|sockfd
decl_stmt|;
name|char
modifier|*
name|wltdev
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
name|struct
name|bpf_dltlist
name|bdl
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_IEEE80211
argument_list|)
name|int
name|new_dlt
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* BIOCGDLTLIST */
if|#
directive|if
name|defined
argument_list|(
name|BIOCGHDRCMPLT
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIOCSHDRCMPLT
argument_list|)
name|u_int
name|spoof_eth_src
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|u_int
name|v
decl_stmt|;
name|struct
name|bpf_insn
name|total_insn
decl_stmt|;
name|struct
name|bpf_program
name|total_prog
decl_stmt|;
name|struct
name|utsname
name|osinfo
decl_stmt|;
name|int
name|have_osinfo
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
name|struct
name|bpf_zbuf
name|bz
decl_stmt|;
name|u_int
name|bufmode
decl_stmt|,
name|zbufmax
decl_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|bpf_open
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|fd
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|p
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCVERSION
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCVERSION: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bv
operator|.
name|bv_major
operator|!=
name|BPF_MAJOR_VERSION
operator|||
name|bv
operator|.
name|bv_minor
operator|<
name|BPF_MINOR_VERSION
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"kernel bpf filter out of date"
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LIFNAMSIZ
argument_list|)
operator|&&
name|defined
argument_list|(
name|ZONENAME_MAX
argument_list|)
operator|&&
name|defined
argument_list|(
name|lifr_zoneid
argument_list|)
comment|/* 	 * Retrieve the zoneid of the zone we are currently executing in. 	 */
if|if
condition|(
operator|(
name|ifr
operator|.
name|lifr_zoneid
operator|=
name|getzoneid
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getzoneid(): %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check if the given source datalink name has a '/' separated 	 * zonename prefix string.  The zonename prefixed source datalink can 	 * be used by pcap consumers in the Solaris global zone to capture 	 * traffic on datalinks in non-global zones.  Non-global zones 	 * do not have access to datalinks outside of their own namespace. 	 */
if|if
condition|(
operator|(
name|zonesep
operator|=
name|strchr
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|path_zname
index|[
name|ZONENAME_MAX
index|]
decl_stmt|;
name|int
name|znamelen
decl_stmt|;
name|char
modifier|*
name|lnamep
decl_stmt|;
if|if
condition|(
name|ifr
operator|.
name|lifr_zoneid
operator|!=
name|GLOBAL_ZONEID
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"zonename/linkname only valid in global zone."
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|znamelen
operator|=
name|zonesep
operator|-
name|p
operator|->
name|opt
operator|.
name|device
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|path_zname
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|znamelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ifr
operator|.
name|lifr_zoneid
operator|=
name|getzoneidbyname
argument_list|(
name|path_zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|.
name|lifr_zoneid
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"getzoneidbyname(%s): %s"
argument_list|,
name|path_zname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|lnamep
operator|=
name|strdup
argument_list|(
name|zonesep
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnamep
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"strdup: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|free
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|device
operator|=
name|lnamep
expr_stmt|;
block|}
endif|#
directive|endif
name|pb
operator|->
name|device
operator|=
name|strdup
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|device
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"strdup: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Attempt to find out the version of the OS on which we're running. 	 */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|osinfo
argument_list|)
operator|==
literal|0
condition|)
name|have_osinfo
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|__APPLE__
comment|/* 	 * See comment in pcap_can_set_rfmon_bpf() for an explanation 	 * of why we check the version number. 	 */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
if|if
condition|(
name|have_osinfo
condition|)
block|{
comment|/* 			 * We assume osinfo.sysname is "Darwin", because 			 * __APPLE__ is defined.  We just check the version. 			 */
if|if
condition|(
name|osinfo
operator|.
name|release
index|[
literal|0
index|]
operator|<
literal|'8'
operator|&&
name|osinfo
operator|.
name|release
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 				 * 10.3 (Darwin 7.x) or earlier. 				 */
name|status
operator|=
name|PCAP_ERROR_RFMON_NOTSUP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|osinfo
operator|.
name|release
index|[
literal|0
index|]
operator|==
literal|'8'
operator|&&
name|osinfo
operator|.
name|release
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 				 * 10.4 (Darwin 8.x).  s/en/wlt/ 				 */
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
literal|"en"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * Not an enN device; check 					 * whether the device even exists. 					 */
name|sockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|strlcpy
argument_list|(
name|ifrname
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|ifnamsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sockfd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 							 * We assume this 							 * failed because 							 * the underlying 							 * device doesn't 							 * exist. 							 */
name|status
operator|=
name|PCAP_ERROR_NO_SUCH_DEVICE
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFFLAGS failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|PCAP_ERROR_RFMON_NOTSUP
expr_stmt|;
name|close
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 						 * We can't find out whether 						 * the device exists, so just 						 * report "no such device". 						 */
name|status
operator|=
name|PCAP_ERROR_NO_SUCH_DEVICE
expr_stmt|;
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"socket() failed: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bad
goto|;
block|}
name|wltdev
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wltdev
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|strcpy
argument_list|(
name|wltdev
argument_list|,
literal|"wlt"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|wltdev
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|device
operator|=
name|wltdev
expr_stmt|;
block|}
comment|/* 			 * Everything else is 10.5 or later; for those, 			 * we just open the enN device, and set the DLT. 			 */
block|}
block|}
endif|#
directive|endif
comment|/* __APPLE__ */
comment|/* 	 * If this is FreeBSD, and the device name begins with "usbus", 	 * try to create the interface if it's not available. 	 */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCIFCREATE2
argument_list|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|usbus_prefix
argument_list|,
name|USBUS_PREFIX_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Do we already have an interface with that name? 		 */
if|if
condition|(
name|if_nametoindex
argument_list|(
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No.  We need to create it, and, if we 			 * succeed, remember that we should destroy 			 * it when the pcap_t is closed. 			 */
name|int
name|s
decl_stmt|;
comment|/* 			 * Open a socket to use for ioctls to 			 * create the interface. 			 */
name|s
operator|=
name|socket
argument_list|(
name|AF_LOCAL
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't open socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * If we haven't already done so, arrange to have 			 * "pcap_close_all()" called when we exit. 			 */
if|if
condition|(
operator|!
name|pcap_do_addexit
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* 				 * "atexit()" failed; don't create the 				 * interface, just give up. 				 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"atexit failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * Create the interface. 			 */
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCIFCREATE2
argument_list|,
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Invalid USB bus interface %s"
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Can't create interface for %s: %s"
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * Make sure we clean this up when we close. 			 */
name|pb
operator|->
name|must_do_on_close
operator||=
name|MUST_DESTROY_USBUS
expr_stmt|;
comment|/* 			 * Add this to the list of pcaps to close when we exit. 			 */
name|pcap_add_to_pcaps_to_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* defined(__FreeBSD__)&& defined(SIOCIFCREATE2) */
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
comment|/* 	 * If the BPF extension to set buffer mode is present, try setting 	 * the mode to zero-copy.  If that fails, use regular buffering.  If 	 * it succeeds but other setup fails, return an error to the user. 	 */
name|bufmode
operator|=
name|BPF_BUFMODE_ZBUF
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETBUFMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bufmode
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We have zerocopy BPF; use it. 		 */
name|pb
operator|->
name|zerocopy
operator|=
literal|1
expr_stmt|;
comment|/* 		 * How to pick a buffer size: first, query the maximum buffer 		 * size supported by zero-copy.  This also lets us quickly 		 * determine whether the kernel generally supports zero-copy. 		 * Then, if a buffer size was specified, use that, otherwise 		 * query the default buffer size, which reflects kernel 		 * policy for a desired default.  Round to the nearest page 		 * size. 		 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGETZMAX
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|zbufmax
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGETZMAX: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * A buffer size was explicitly specified; use it. 			 */
name|v
operator|=
name|p
operator|->
name|opt
operator|.
name|buffer_size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|v
operator|<
name|DEFAULT_BUFSIZE
condition|)
name|v
operator|=
name|DEFAULT_BUFSIZE
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|roundup
define|#
directive|define
name|roundup
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((((x)+((y)-1))/(y))*(y))
comment|/* to any y */
endif|#
directive|endif
name|pb
operator|->
name|zbufsize
operator|=
name|roundup
argument_list|(
name|v
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|zbufsize
operator|>
name|zbufmax
condition|)
name|pb
operator|->
name|zbufsize
operator|=
name|zbufmax
expr_stmt|;
name|pb
operator|->
name|zbuf1
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|pb
operator|->
name|zbufsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pb
operator|->
name|zbuf2
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|pb
operator|->
name|zbufsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|zbuf1
operator|==
name|MAP_FAILED
operator|||
name|pb
operator|->
name|zbuf2
operator|==
name|MAP_FAILED
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"mmap: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|memset
argument_list|(
operator|&
name|bz
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bz
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bzero() deprecated, replaced with memset() */
name|bz
operator|.
name|bz_bufa
operator|=
name|pb
operator|->
name|zbuf1
expr_stmt|;
name|bz
operator|.
name|bz_bufb
operator|=
name|pb
operator|->
name|zbuf2
expr_stmt|;
name|bz
operator|.
name|bz_buflen
operator|=
name|pb
operator|->
name|zbufsize
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETZBUF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bz
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETZBUF: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifrname
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|ifnamsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETIF: %s: %s"
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|v
operator|=
name|pb
operator|->
name|zbufsize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_zbuf_header
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 		 * We don't have zerocopy BPF. 		 * Set the buffer size. 		 */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * A buffer size was explicitly specified; use it. 			 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|p
operator|->
name|opt
operator|.
name|buffer_size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSBLEN: %s: %s"
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * Now bind to the device. 			 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifrname
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|ifnamsiz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIOCSETLIF
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETLIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|status
operator|=
name|check_setif_failure
argument_list|(
name|p
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * No buffer size was explicitly specified. 			 * 			 * Try finding a good size for the buffer; 			 * DEFAULT_BUFSIZE may be too big, so keep 			 * cutting it in half until we find a size 			 * that works, or run out of sizes to try. 			 * If the default is larger, don't make it smaller. 			 */
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|v
operator|<
name|DEFAULT_BUFSIZE
condition|)
name|v
operator|=
name|DEFAULT_BUFSIZE
expr_stmt|;
for|for
control|(
init|;
name|v
operator|!=
literal|0
condition|;
name|v
operator|>>=
literal|1
control|)
block|{
comment|/* 				 * Ignore the return value - this is because the 				 * call fails on BPF systems that don't have 				 * kernel malloc.  And if the call fails, it's 				 * no big deal, we just continue to use the 				 * standard buffer size. 				 */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifrname
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
name|ifnamsiz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIOCSETLIF
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETLIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|>=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|>=
literal|0
condition|)
endif|#
directive|endif
break|break;
comment|/* that size worked; we're done */
if|if
condition|(
name|errno
operator|!=
name|ENOBUFS
condition|)
block|{
name|status
operator|=
name|check_setif_failure
argument_list|(
name|p
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSBLEN: %s: No buffer size worked"
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
comment|/* Get the data link layer type. */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGDLT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|_AIX
comment|/* 	 * AIX's BPF returns IFF_ types, not DLT_ types, in BIOCGDLT. 	 */
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_ISO88023
case|:
name|v
operator|=
name|DLT_EN10MB
expr_stmt|;
break|break;
case|case
name|IFT_FDDI
case|:
name|v
operator|=
name|DLT_FDDI
expr_stmt|;
break|break;
case|case
name|IFT_ISO88025
case|:
name|v
operator|=
name|DLT_IEEE802
expr_stmt|;
break|break;
case|case
name|IFT_LOOP
case|:
name|v
operator|=
name|DLT_NULL
expr_stmt|;
break|break;
default|default:
comment|/* 		 * We don't know what to map this to yet. 		 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"unknown interface type %u"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
if|#
directive|if
name|_BSDI_VERSION
operator|-
literal|0
operator|>=
literal|199510
comment|/* The SLIP and PPP link layer header changed in BSD/OS 2.1 */
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|DLT_SLIP
case|:
name|v
operator|=
name|DLT_SLIP_BSDOS
expr_stmt|;
break|break;
case|case
name|DLT_PPP
case|:
name|v
operator|=
name|DLT_PPP_BSDOS
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/*DLT_FR*/
name|v
operator|=
name|DLT_FRELAY
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/*DLT_C_HDLC*/
name|v
operator|=
name|DLT_CHDLC
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIOCGDLTLIST
comment|/* 	 * We know the default link type -- now determine all the DLTs 	 * this interface supports.  If this fails with EINVAL, it's 	 * not fatal; we just don't get to use the feature later. 	 */
if|if
condition|(
name|get_dlt_list
argument_list|(
name|fd
argument_list|,
name|v
argument_list|,
operator|&
name|bdl
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|p
operator|->
name|dlt_count
operator|=
name|bdl
operator|.
name|bfl_len
expr_stmt|;
name|p
operator|->
name|dlt_list
operator|=
name|bdl
operator|.
name|bfl_list
expr_stmt|;
ifdef|#
directive|ifdef
name|__APPLE__
comment|/* 	 * Monitor mode fun, continued. 	 * 	 * For 10.5 and, we're assuming, later releases, as noted above, 	 * 802.1 adapters that support monitor mode offer both DLT_EN10MB, 	 * DLT_IEEE802_11, and possibly some 802.11-plus-radio-information 	 * DLT_ value.  Choosing one of the 802.11 DLT_ values will turn 	 * monitor mode on. 	 * 	 * Therefore, if the user asked for monitor mode, we filter out 	 * the DLT_EN10MB value, as you can't get that in monitor mode, 	 * and, if the user didn't ask for monitor mode, we filter out 	 * the 802.11 DLT_ values, because selecting those will turn 	 * monitor mode on.  Then, for monitor mode, if an 802.11-plus- 	 * radio DLT_ value is offered, we try to select that, otherwise 	 * we try to select DLT_IEEE802_11. 	 */
if|if
condition|(
name|have_osinfo
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
operator|)
name|osinfo
operator|.
name|release
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|osinfo
operator|.
name|release
index|[
literal|0
index|]
operator|==
literal|'9'
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
operator|)
name|osinfo
operator|.
name|release
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * 10.5 (Darwin 9.x), or later. 			 */
name|new_dlt
operator|=
name|find_802_11
argument_list|(
operator|&
name|bdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dlt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 				 * We have at least one 802.11 DLT_ value, 				 * so this is an 802.11 interface. 				 * new_dlt is the best of the 802.11 				 * DLT_ values in the list. 				 */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 					 * Our caller wants monitor mode. 					 * Purge DLT_EN10MB from the list 					 * of link-layer types, as selecting 					 * it will keep monitor mode off. 					 */
name|remove_en
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 					 * If the new mode we want isn't 					 * the default mode, attempt to 					 * select the new mode. 					 */
if|if
condition|(
operator|(
name|u_int
operator|)
name|new_dlt
operator|!=
name|v
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSDLT
argument_list|,
operator|&
name|new_dlt
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 							 * We succeeded; 							 * make this the 							 * new DLT_ value. 							 */
name|v
operator|=
name|new_dlt
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 					 * Our caller doesn't want 					 * monitor mode.  Unless this 					 * is being done by pcap_open_live(), 					 * purge the 802.11 link-layer types 					 * from the list, as selecting 					 * one of them will turn monitor 					 * mode on. 					 */
if|if
condition|(
operator|!
name|p
operator|->
name|oldstyle
condition|)
name|remove_802_11
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 					 * The caller requested monitor 					 * mode, but we have no 802.11 					 * link-layer types, so they 					 * can't have it. 					 */
name|status
operator|=
name|PCAP_ERROR_RFMON_NOTSUP
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_BSD_IEEE80211
argument_list|)
comment|/* 	 * *BSD with the new 802.11 ioctls. 	 * Do we want monitor mode? 	 */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|rfmon
condition|)
block|{
comment|/* 		 * Try to put the interface into monitor mode. 		 */
name|retv
operator|=
name|monitor_mode
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We failed. 			 */
name|status
operator|=
name|retv
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * We're in monitor mode. 		 * Try to find the best 802.11 DLT_ value and, if we 		 * succeed, try to switch to that mode if we're not 		 * already in that mode. 		 */
name|new_dlt
operator|=
name|find_802_11
argument_list|(
operator|&
name|bdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dlt
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We have at least one 802.11 DLT_ value. 			 * new_dlt is the best of the 802.11 			 * DLT_ values in the list. 			 * 			 * If the new mode we want isn't the default mode, 			 * attempt to select the new mode. 			 */
if|if
condition|(
operator|(
name|u_int
operator|)
name|new_dlt
operator|!=
name|v
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSDLT
argument_list|,
operator|&
name|new_dlt
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 					 * We succeeded; make this the 					 * new DLT_ value. 					 */
name|v
operator|=
name|new_dlt
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* various platforms */
endif|#
directive|endif
comment|/* BIOCGDLTLIST */
comment|/* 	 * If this is an Ethernet device, and we don't have a DLT_ list, 	 * give it a list with DLT_EN10MB and DLT_DOCSIS.  (That'd give 	 * 802.11 interfaces DLT_DOCSIS, which isn't the right thing to 	 * do, but there's not much we can do about that without finding 	 * some other way of determining whether it's an Ethernet or 802.11 	 * device.) 	 */
if|if
condition|(
name|v
operator|==
name|DLT_EN10MB
operator|&&
name|p
operator|->
name|dlt_count
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|dlt_list
operator|=
operator|(
name|u_int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * If that fails, just leave the list empty. 		 */
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|=
name|DLT_EN10MB
expr_stmt|;
name|p
operator|->
name|dlt_list
index|[
literal|1
index|]
operator|=
name|DLT_DOCSIS
expr_stmt|;
name|p
operator|->
name|dlt_count
operator|=
literal|2
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PCAP_FDDIPAD
if|if
condition|(
name|v
operator|==
name|DLT_FDDI
condition|)
name|p
operator|->
name|fddipad
operator|=
name|PCAP_FDDIPAD
expr_stmt|;
else|else
endif|#
directive|endif
name|p
operator|->
name|fddipad
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|v
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BIOCGHDRCMPLT
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIOCSHDRCMPLT
argument_list|)
comment|/* 	 * Do a BIOCSHDRCMPLT, if defined, to turn that flag on, so 	 * the link-layer source address isn't forcibly overwritten. 	 * (Should we ignore errors?  Should we do this only if 	 * we're open for writing?) 	 * 	 * XXX - I seem to remember some packet-sending bug in some 	 * BSDs - check CVS log for "bpf.c"? 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSHDRCMPLT
argument_list|,
operator|&
name|spoof_eth_src
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSHDRCMPLT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* set timeout */
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
comment|/* 	 * In zero-copy mode, we just use the timeout in select(). 	 * XXX - what if we're in non-blocking mode and the *application* 	 * is using select() or poll() or kqueues or....? 	 */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|timeout
operator|&&
operator|!
name|pb
operator|->
name|zerocopy
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|timeout
condition|)
block|{
endif|#
directive|endif
comment|/* 		 * XXX - is this seconds/nanoseconds in AIX? 		 * (Treating it as such doesn't fix the timeout 		 * problem described below.) 		 * 		 * XXX - Mac OS X 10.6 mishandles BIOCSRTIMEOUT in 		 * 64-bit userland - it takes, as an argument, a 		 * "struct BPF_TIMEVAL", which has 32-bit tv_sec 		 * and tv_usec, rather than a "struct timeval". 		 * 		 * If this platform defines "struct BPF_TIMEVAL", 		 * we check whether the structure size in BIOCSRTIMEOUT 		 * is that of a "struct timeval" and, if not, we use 		 * a "struct BPF_TIMEVAL" rather than a "struct timeval". 		 * (That way, if the bug is fixed in a future release, 		 * we will still do the right thing.) 		 */
name|struct
name|timeval
name|to
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_BPF_TIMEVAL
name|struct
name|BPF_TIMEVAL
name|bpf_to
decl_stmt|;
if|if
condition|(
name|IOCPARM_LEN
argument_list|(
name|BIOCSRTIMEOUT
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
condition|)
block|{
name|bpf_to
operator|.
name|tv_sec
operator|=
name|p
operator|->
name|opt
operator|.
name|timeout
operator|/
literal|1000
expr_stmt|;
name|bpf_to
operator|.
name|tv_usec
operator|=
operator|(
name|p
operator|->
name|opt
operator|.
name|timeout
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSRTIMEOUT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bpf_to
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSRTIMEOUT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
name|to
operator|.
name|tv_sec
operator|=
name|p
operator|->
name|opt
operator|.
name|timeout
operator|/
literal|1000
expr_stmt|;
name|to
operator|.
name|tv_usec
operator|=
operator|(
name|p
operator|->
name|opt
operator|.
name|timeout
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSRTIMEOUT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|to
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSRTIMEOUT: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|HAVE_STRUCT_BPF_TIMEVAL
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|BIOCIMMEDIATE
comment|/* 	 * Darren Reed notes that 	 * 	 *	On AIX (4.2 at least), if BIOCIMMEDIATE is not set, the 	 *	timeout appears to be ignored and it waits until the buffer 	 *	is filled before returning.  The result of not having it 	 *	set is almost worse than useless if your BPF filter 	 *	is reducing things to only a few packets (i.e. one every 	 *	second or so). 	 * 	 * so we always turn BIOCIMMEDIATE mode on if this is AIX. 	 * 	 * For other platforms, we don't turn immediate mode on by default, 	 * as that would mean we get woken up for every packet, which 	 * probably isn't what you want for a packet sniffer. 	 * 	 * We set immediate mode if the caller requested it by calling 	 * pcap_set_immediate() before calling pcap_activate(). 	 */
ifndef|#
directive|ifndef
name|_AIX
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|immediate
condition|)
block|{
endif|#
directive|endif
comment|/* _AIX */
name|v
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCIMMEDIATE
argument_list|,
operator|&
name|v
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCIMMEDIATE: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifndef|#
directive|ifndef
name|_AIX
block|}
endif|#
directive|endif
comment|/* _AIX */
else|#
directive|else
comment|/* BIOCIMMEDIATE */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|immediate
condition|)
block|{
comment|/* 		 * We don't support immediate mode.  Fail. 		 */
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Immediate mode not supported"
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* BIOCIMMEDIATE */
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|promisc
condition|)
block|{
comment|/* set promiscuous mode, just warn if it fails */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCPROMISC
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCPROMISC: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_WARNING_PROMISC_NOTSUP
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BIOCSTSTAMP
name|v
operator|=
name|BPF_T_BINTIME
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSTSTAMP
argument_list|,
operator|&
name|v
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSTSTAMP: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* BIOCSTSTAMP */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|v
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCGBLEN: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|p
operator|->
name|bufsize
operator|=
name|v
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
if|if
condition|(
operator|!
name|pb
operator|->
name|zerocopy
condition|)
block|{
endif|#
directive|endif
name|p
operator|->
name|buffer
operator|=
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|_AIX
comment|/* For some strange reason this seems to prevent the EFAULT 	 * problems we have experienced from AIX BPF. */
name|memset
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
literal|0x0
argument_list|,
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ZEROCOPY_BPF
block|}
endif|#
directive|endif
comment|/* 	 * If there's no filter program installed, there's 	 * no indication to the kernel of what the snapshot 	 * length should be, so no snapshotting is done. 	 * 	 * Therefore, when we open the device, we install 	 * an "accept everything" filter with the specified 	 * snapshot length. 	 */
name|total_insn
operator|.
name|code
operator|=
call|(
name|u_short
call|)
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|)
expr_stmt|;
name|total_insn
operator|.
name|jt
operator|=
literal|0
expr_stmt|;
name|total_insn
operator|.
name|jf
operator|=
literal|0
expr_stmt|;
name|total_insn
operator|.
name|k
operator|=
name|p
operator|->
name|snapshot
expr_stmt|;
name|total_prog
operator|.
name|bf_len
operator|=
literal|1
expr_stmt|;
name|total_prog
operator|.
name|bf_insns
operator|=
operator|&
name|total_insn
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSETF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|total_prog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETF: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|PCAP_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * On most BPF platforms, either you can do a "select()" or 	 * "poll()" on a BPF file descriptor and it works correctly, 	 * or you can do it and it will return "readable" if the 	 * hold buffer is full but not if the timeout expires *and* 	 * a non-blocking read will, if the hold buffer is empty 	 * but the store buffer isn't empty, rotate the buffers 	 * and return what packets are available. 	 * 	 * In the latter case, the fact that a non-blocking read 	 * will give you the available packets means you can work 	 * around the failure of "select()" and "poll()" to wake up 	 * and return "readable" when the timeout expires by using 	 * the timeout as the "select()" or "poll()" timeout, putting 	 * the BPF descriptor into non-blocking mode, and read from 	 * it regardless of whether "select()" reports it as readable 	 * or not. 	 * 	 * However, in FreeBSD 4.3 and 4.4, "select()" and "poll()" 	 * won't wake up and return "readable" if the timer expires 	 * and non-blocking reads return EWOULDBLOCK if the hold 	 * buffer is empty, even if the store buffer is non-empty. 	 * 	 * This means the workaround in question won't work. 	 * 	 * Therefore, on FreeBSD 4.3 and 4.4, we set "p->selectable_fd" 	 * to -1, which means "sorry, you can't use 'select()' or 'poll()' 	 * here".  On all other BPF platforms, we set it to the FD for 	 * the BPF device; in NetBSD, OpenBSD, and Darwin, a non-blocking 	 * read will, if the hold buffer is empty and the store buffer 	 * isn't empty, rotate the buffers and return what packets are 	 * there (and in sufficiently recent versions of OpenBSD 	 * "select()" and "poll()" should work correctly). 	 * 	 * XXX - what about AIX? 	 */
name|p
operator|->
name|selectable_fd
operator|=
name|p
operator|->
name|fd
expr_stmt|;
comment|/* assume select() works until we know otherwise */
if|if
condition|(
name|have_osinfo
condition|)
block|{
comment|/* 		 * We can check what OS this is. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|osinfo
operator|.
name|sysname
argument_list|,
literal|"FreeBSD"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|osinfo
operator|.
name|release
argument_list|,
literal|"4.3-"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|osinfo
operator|.
name|release
argument_list|,
literal|"4.4-"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|p
operator|->
name|read_op
operator|=
name|pcap_read_bpf
expr_stmt|;
name|p
operator|->
name|inject_op
operator|=
name|pcap_inject_bpf
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
name|pcap_setfilter_bpf
expr_stmt|;
name|p
operator|->
name|setdirection_op
operator|=
name|pcap_setdirection_bpf
expr_stmt|;
name|p
operator|->
name|set_datalink_op
operator|=
name|pcap_set_datalink_bpf
expr_stmt|;
name|p
operator|->
name|getnonblock_op
operator|=
name|pcap_getnonblock_bpf
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
name|pcap_setnonblock_bpf
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_bpf
expr_stmt|;
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_bpf
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
name|bad
label|:
name|pcap_cleanup_bpf
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/*  * Not all interfaces can be bound to by BPF, so try to bind to  * the specified interface; return 0 if we fail with  * PCAP_ERROR_NO_SUCH_DEVICE (which means we got an ENXIO when we tried  * to bind, which means this interface isn't in the list of interfaces  * attached to BPF) and 1 otherwise.  */
specifier|static
name|int
name|check_bpf_bindable
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
index|]
decl_stmt|;
name|fd
operator|=
name|bpf_open_and_bind
argument_list|(
name|name
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Error - was it PCAP_ERROR_NO_SUCH_DEVICE? 		 */
if|if
condition|(
name|fd
operator|==
name|PCAP_ERROR_NO_SUCH_DEVICE
condition|)
block|{
comment|/* 			 * Yes, so we can't bind to this because it's 			 * not something supported by BPF. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * No, so we don't know whether it's supported or not; 		 * say it is, so that the user can at least try to 		 * open it and report the error (which is probably 		 * "you don't have permission to open BPF devices"; 		 * reporting those interfaces means users will ask 		 * "why am I getting a permissions error when I try 		 * to capture" rather than "why am I not seeing any 		 * interfaces", making the underlying problem clearer). 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Success. 	 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCIFCREATE2
argument_list|)
specifier|static
name|int
name|finddevs_usb
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|DIR
modifier|*
name|usbdir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|usbitem
decl_stmt|;
name|size_t
name|name_max
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 	 * We might have USB sniffing support, so try looking for USB 	 * interfaces. 	 * 	 * We want to report a usbusN device for each USB bus, but 	 * usbusN interfaces might, or might not, exist for them - 	 * we create one if there isn't already one. 	 * 	 * So, instead, we look in /dev/usb for all buses and create 	 * a "usbusN" device for each one. 	 */
name|usbdir
operator|=
name|opendir
argument_list|(
literal|"/dev/usb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbdir
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Just punt. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Leave enough room for a 32-bit (10-digit) bus number. 	 * Yes, that's overkill, but we won't be using 	 * the buffer very long. 	 */
name|name_max
operator|=
name|USBUS_PREFIX_LEN
operator|+
literal|10
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|malloc
argument_list|(
name|name_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|closedir
argument_list|(
name|usbdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|usbitem
operator|=
name|readdir
argument_list|(
name|usbdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|busnumlen
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|usbitem
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|usbitem
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Ignore these. 			 */
continue|continue;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|usbitem
operator|->
name|d_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
name|busnumlen
operator|=
name|p
operator|-
name|usbitem
operator|->
name|d_name
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|usbus_prefix
argument_list|,
name|USBUS_PREFIX_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
operator|+
name|USBUS_PREFIX_LEN
argument_list|,
name|usbitem
operator|->
name|d_name
argument_list|,
name|busnumlen
argument_list|)
expr_stmt|;
operator|*
operator|(
name|name
operator|+
name|USBUS_PREFIX_LEN
operator|+
name|busnumlen
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|pcap_add_if
argument_list|(
name|alldevsp
argument_list|,
name|name
argument_list|,
name|PCAP_IF_UP
argument_list|,
name|NULL
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|usbdir
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|usbdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|int
name|pcap_platform_finddevs
parameter_list|(
name|pcap_if_t
modifier|*
modifier|*
name|alldevsp
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
comment|/* 	 * Get the list of regular interfaces first. 	 */
if|if
condition|(
name|pcap_findalldevs_interfaces
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|,
name|check_bpf_bindable
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failure */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIOCIFCREATE2
argument_list|)
if|if
condition|(
name|finddevs_usb
argument_list|(
name|alldevsp
argument_list|,
name|errbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_BSD_IEEE80211
specifier|static
name|int
name|monitor_mode
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|ifmediareq
name|req
decl_stmt|;
name|IFM_ULIST_TYPE
modifier|*
name|media_list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|can_do
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't open socket: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|req
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|req
operator|.
name|ifm_name
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
sizeof|sizeof
name|req
operator|.
name|ifm_name
argument_list|)
expr_stmt|;
comment|/* 	 * Find out how many media types we have. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFMEDIA
argument_list|,
operator|&
name|req
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Can't get the media types. 		 */
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENXIO
case|:
comment|/* 			 * There's no such device. 			 */
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|)
return|;
case|case
name|EINVAL
case|:
comment|/* 			 * Interface doesn't support SIOC{G,S}IFMEDIA. 			 */
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_RFMON_NOTSUP
operator|)
return|;
default|default:
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFMEDIA 1: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|req
operator|.
name|ifm_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No media types. 		 */
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_RFMON_NOTSUP
operator|)
return|;
block|}
comment|/* 	 * Allocate a buffer to hold all the media types, and 	 * get the media types. 	 */
name|media_list
operator|=
name|malloc
argument_list|(
name|req
operator|.
name|ifm_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|media_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|media_list
operator|==
name|NULL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|req
operator|.
name|ifm_ulist
operator|=
name|media_list
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFMEDIA
argument_list|,
operator|&
name|req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCGIFMEDIA: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|media_list
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
comment|/* 	 * Look for an 802.11 "automatic" media type. 	 * We assume that all 802.11 adapters have that media type, 	 * and that it will carry the monitor mode supported flag. 	 */
name|can_do
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|req
operator|.
name|ifm_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|media_list
index|[
name|i
index|]
argument_list|)
operator|==
name|IFM_IEEE80211
operator|&&
name|IFM_SUBTYPE
argument_list|(
name|media_list
index|[
name|i
index|]
argument_list|)
operator|==
name|IFM_AUTO
condition|)
block|{
comment|/* OK, does it do monitor mode? */
if|if
condition|(
name|media_list
index|[
name|i
index|]
operator|&
name|IFM_IEEE80211_MONITOR
condition|)
block|{
name|can_do
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|media_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_do
condition|)
block|{
comment|/* 		 * This adapter doesn't support monitor mode. 		 */
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR_RFMON_NOTSUP
operator|)
return|;
block|}
if|if
condition|(
name|set
condition|)
block|{
comment|/* 		 * Don't just check whether we can enable monitor mode, 		 * do so, if it's not already enabled. 		 */
if|if
condition|(
operator|(
name|req
operator|.
name|ifm_current
operator|&
name|IFM_IEEE80211_MONITOR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Monitor mode isn't currently on, so turn it on, 			 * and remember that we should turn it off when the 			 * pcap_t is closed. 			 */
comment|/* 			 * If we haven't already done so, arrange to have 			 * "pcap_close_all()" called when we exit. 			 */
if|if
condition|(
operator|!
name|pcap_do_addexit
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* 				 * "atexit()" failed; don't put the interface 				 * in monitor mode, just give up. 				 */
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|ifr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|p
operator|->
name|opt
operator|.
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|ifr
operator|.
name|ifr_media
operator|=
name|req
operator|.
name|ifm_current
operator||
name|IFM_IEEE80211_MONITOR
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCSIFMEDIA
argument_list|,
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"SIOCSIFMEDIA: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
name|pb
operator|->
name|must_do_on_close
operator||=
name|MUST_CLEAR_RFMON
expr_stmt|;
comment|/* 			 * Add this to the list of pcaps to close when we exit. 			 */
name|pcap_add_to_pcaps_to_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_IEEE80211 */
if|#
directive|if
name|defined
argument_list|(
name|BIOCGDLTLIST
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_BSD_IEEE80211
argument_list|)
operator|)
comment|/*  * Check whether we have any 802.11 link-layer types; return the best  * of the 802.11 link-layer types if we find one, and return -1  * otherwise.  *  * DLT_IEEE802_11_RADIO, with the radiotap header, is considered the  * best 802.11 link-layer type; any of the other 802.11-plus-radio  * headers are second-best; 802.11 with no radio information is  * the least good.  */
specifier|static
name|int
name|find_802_11
parameter_list|(
name|struct
name|bpf_dltlist
modifier|*
name|bdlp
parameter_list|)
block|{
name|int
name|new_dlt
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* 	 * Scan the list of DLT_ values, looking for 802.11 values, 	 * and, if we find any, choose the best of them. 	 */
name|new_dlt
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bdlp
operator|->
name|bfl_len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|bdlp
operator|->
name|bfl_list
index|[
name|i
index|]
condition|)
block|{
case|case
name|DLT_IEEE802_11
case|:
comment|/* 			 * 802.11, but no radio. 			 * 			 * Offer this, and select it as the new mode 			 * unless we've already found an 802.11 			 * header with radio information. 			 */
if|if
condition|(
name|new_dlt
operator|==
operator|-
literal|1
condition|)
name|new_dlt
operator|=
name|bdlp
operator|->
name|bfl_list
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|DLT_PRISM_HEADER
case|:
case|case
name|DLT_AIRONET_HEADER
case|:
case|case
name|DLT_IEEE802_11_RADIO_AVS
case|:
comment|/* 			 * 802.11 with radio, but not radiotap. 			 * 			 * Offer this, and select it as the new mode 			 * unless we've already found the radiotap DLT_. 			 */
if|if
condition|(
name|new_dlt
operator|!=
name|DLT_IEEE802_11_RADIO
condition|)
name|new_dlt
operator|=
name|bdlp
operator|->
name|bfl_list
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|DLT_IEEE802_11_RADIO
case|:
comment|/* 			 * 802.11 with radiotap. 			 * 			 * Offer this, and select it as the new mode. 			 */
name|new_dlt
operator|=
name|bdlp
operator|->
name|bfl_list
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Not 802.11. 			 */
break|break;
block|}
block|}
return|return
operator|(
name|new_dlt
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* defined(BIOCGDLTLIST)&& (defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)) */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIOCGDLTLIST
argument_list|)
comment|/*  * Remove DLT_EN10MB from the list of DLT_ values, as we're in monitor mode,  * and DLT_EN10MB isn't supported in monitor mode.  */
specifier|static
name|void
name|remove_en
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Scan the list of DLT_ values and discard DLT_EN10MB. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dlt_count
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|dlt_list
index|[
name|i
index|]
condition|)
block|{
case|case
name|DLT_EN10MB
case|:
comment|/* 			 * Don't offer this one. 			 */
continue|continue;
default|default:
comment|/* 			 * Just copy this mode over. 			 */
break|break;
block|}
comment|/* 		 * Copy this DLT_ value to its new position. 		 */
name|p
operator|->
name|dlt_list
index|[
name|j
index|]
operator|=
name|p
operator|->
name|dlt_list
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 	 * Set the DLT_ count to the number of entries we copied. 	 */
name|p
operator|->
name|dlt_count
operator|=
name|j
expr_stmt|;
block|}
comment|/*  * Remove 802.11 link-layer types from the list of DLT_ values, as  * we're not in monitor mode, and those DLT_ values will switch us  * to monitor mode.  */
specifier|static
name|void
name|remove_802_11
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Scan the list of DLT_ values and discard 802.11 values. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dlt_count
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|dlt_list
index|[
name|i
index|]
condition|)
block|{
case|case
name|DLT_IEEE802_11
case|:
case|case
name|DLT_PRISM_HEADER
case|:
case|case
name|DLT_AIRONET_HEADER
case|:
case|case
name|DLT_IEEE802_11_RADIO
case|:
case|case
name|DLT_IEEE802_11_RADIO_AVS
case|:
comment|/* 			 * 802.11.  Don't offer this one. 			 */
continue|continue;
default|default:
comment|/* 			 * Just copy this mode over. 			 */
break|break;
block|}
comment|/* 		 * Copy this DLT_ value to its new position. 		 */
name|p
operator|->
name|dlt_list
index|[
name|j
index|]
operator|=
name|p
operator|->
name|dlt_list
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
comment|/* 	 * Set the DLT_ count to the number of entries we copied. 	 */
name|p
operator|->
name|dlt_count
operator|=
name|j
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(__APPLE__)&& defined(BIOCGDLTLIST) */
specifier|static
name|int
name|pcap_setfilter_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|pcap_bpf
modifier|*
name|pb
init|=
name|p
operator|->
name|priv
decl_stmt|;
comment|/* 	 * Free any user-mode filter we might happen to have installed. 	 */
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
comment|/* 	 * Try to install the kernel filter. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSETF
argument_list|,
operator|(
name|caddr_t
operator|)
name|fp
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * It worked. 		 */
name|pb
operator|->
name|filtering_in_kernel
operator|=
literal|1
expr_stmt|;
comment|/* filtering in the kernel */
comment|/* 		 * Discard any previously-received packets, as they might 		 * have passed whatever filter was formerly in effect, but 		 * might not pass this filter (BIOCSETF discards packets 		 * buffered in the kernel, so you can lose packets in any 		 * case). 		 */
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We failed. 	 * 	 * If it failed with EINVAL, that's probably because the program 	 * is invalid or too big.  Validate it ourselves; if we like it 	 * (we currently allow backward branches, to support protochain), 	 * run it in userland.  (There's no notion of "too big" for 	 * userland.) 	 * 	 * Otherwise, just give up. 	 * XXX - if the copy of the program into the kernel failed, 	 * we will get EINVAL rather than, say, EFAULT on at least 	 * some kernels. 	 */
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"BIOCSETF: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * install_bpf_program() validates the program. 	 * 	 * XXX - what if we already have a filter in the kernel? 	 */
if|if
condition|(
name|install_bpf_program
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pb
operator|->
name|filtering_in_kernel
operator|=
literal|0
expr_stmt|;
comment|/* filtering in userland */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Set direction flag: Which packets do we accept on a forwarding  * single device? IN, OUT or both?  */
specifier|static
name|int
name|pcap_setdirection_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_direction_t
name|d
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|BIOCSDIRECTION
argument_list|)
name|u_int
name|direction
decl_stmt|;
name|direction
operator|=
operator|(
name|d
operator|==
name|PCAP_D_IN
operator|)
condition|?
name|BPF_D_IN
else|:
operator|(
operator|(
name|d
operator|==
name|PCAP_D_OUT
operator|)
condition|?
name|BPF_D_OUT
else|:
name|BPF_D_INOUT
operator|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSDIRECTION
argument_list|,
operator|&
name|direction
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"Cannot set direction to %s: %s"
argument_list|,
operator|(
name|d
operator|==
name|PCAP_D_IN
operator|)
condition|?
literal|"PCAP_D_IN"
else|:
operator|(
operator|(
name|d
operator|==
name|PCAP_D_OUT
operator|)
condition|?
literal|"PCAP_D_OUT"
else|:
literal|"PCAP_D_INOUT"
operator|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|BIOCSSEESENT
argument_list|)
name|u_int
name|seesent
decl_stmt|;
comment|/* 	 * We don't support PCAP_D_OUT. 	 */
if|if
condition|(
name|d
operator|==
name|PCAP_D_OUT
condition|)
block|{
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"Setting direction to PCAP_D_OUT is not supported on BPF"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|seesent
operator|=
operator|(
name|d
operator|==
name|PCAP_D_INOUT
operator|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSSEESENT
argument_list|,
operator|&
name|seesent
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"Cannot set direction to %s: %s"
argument_list|,
operator|(
name|d
operator|==
name|PCAP_D_INOUT
operator|)
condition|?
literal|"PCAP_D_INOUT"
else|:
literal|"PCAP_D_IN"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"This system doesn't support BIOCSSEESENT, so the direction can't be set"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
specifier|static
name|int
name|pcap_set_datalink_bpf
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIOCSDLT
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|BIOCSDLT
argument_list|,
operator|&
name|dlt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|pcap_snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"Cannot set DLT %d: %s"
argument_list|,
name|dlt
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

