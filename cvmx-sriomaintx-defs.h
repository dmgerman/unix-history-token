begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-sriomaintx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon sriomaintx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_SRIOMAINTX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_SRIOMAINTX_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ASMBLY_ID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ASMBLY_ID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000008ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ASMBLY_ID
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000008ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ASMBLY_INFO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ASMBLY_INFO(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000000Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ASMBLY_INFO
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000000Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_BAR1_IDXX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|15
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
name|block_id
operator|==
literal|2
operator|)
operator|||
operator|(
name|block_id
operator|==
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_BAR1_IDXX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200010ull
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|15
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|4
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_BAR1_IDXX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(0x0000000000200010ull + (((offset)& 15) + ((block_id)& 3) * 0x0ull) * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_BELL_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_BELL_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200080ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_BELL_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200080ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_COMP_TAG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_COMP_TAG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000006Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_COMP_TAG
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000006Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_CORE_ENABLES
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_CORE_ENABLES(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200070ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_CORE_ENABLES
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200070ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_DEV_ID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_DEV_ID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_DEV_ID
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_DEV_REV
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_DEV_REV(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000004ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_DEV_REV
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000004ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_DST_OPS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_DST_OPS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000001Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_DST_OPS
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000001Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_ATTR_CAPT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_ATTR_CAPT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002048ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_ATTR_CAPT
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002048ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_ERR_DET
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_ERR_DET(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002040ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_ERR_DET
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002040ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_ERR_RATE
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_ERR_RATE(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002068ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_ERR_RATE
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002068ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_ERR_RATE_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_ERR_RATE_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002044ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_ERR_RATE_EN
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002044ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_ERR_RATE_THR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_ERR_RATE_THR(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000206Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_ERR_RATE_THR
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000206Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_HDR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_HDR(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_HDR
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_H
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002014ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_LT_ADDR_CAPT_L
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002014ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000201Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_LT_CTRL_CAPT
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000201Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_LT_DEV_ID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_LT_DEV_ID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002028ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_LT_DEV_ID
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002028ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002018ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_LT_DEV_ID_CAPT
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002018ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_LT_ERR_DET
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_LT_ERR_DET(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002008ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_LT_ERR_DET
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002008ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_LT_ERR_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_LT_ERR_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000200Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_LT_ERR_EN
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000200Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_PACK_CAPT_1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_PACK_CAPT_1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002050ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_PACK_CAPT_1
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002050ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_PACK_CAPT_2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_PACK_CAPT_2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002054ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_PACK_CAPT_2
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002054ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_PACK_CAPT_3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_PACK_CAPT_3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002058ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_PACK_CAPT_3
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000002058ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000204Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_ERB_PACK_SYM_CAPT
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000204Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_HB_DEV_ID_LOCK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_HB_DEV_ID_LOCK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000068ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_HB_DEV_ID_LOCK
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000068ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_BUFFER_CONFIG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_BUFFER_CONFIG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000102000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_BUFFER_CONFIG
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000102000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000102004ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_BUFFER_CONFIG2
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000102004ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_PD_PHY_CTRL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_PD_PHY_CTRL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107028ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_PD_PHY_CTRL
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107028ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_PD_PHY_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_PD_PHY_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000010702Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_PD_PHY_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000010702Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_PI_PHY_CTRL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_PI_PHY_CTRL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107020ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_PI_PHY_CTRL
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107020ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_PI_PHY_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_PI_PHY_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107024ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_PI_PHY_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107024ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_SP_RX_CTRL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_SP_RX_CTRL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000010700Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_SP_RX_CTRL
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000010700Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_SP_RX_DATA
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_SP_RX_DATA(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107014ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_SP_RX_DATA
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107014ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_SP_RX_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_SP_RX_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_SP_RX_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_SP_TX_CTRL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_SP_TX_DATA(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107008ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107008ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_IR_SP_TX_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_IR_SP_TX_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000107004ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_IR_SP_TX_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000107004ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_LANE_X_STATUS_0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
name|block_id
operator|==
literal|2
operator|)
operator|||
operator|(
name|block_id
operator|==
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_LANE_X_STATUS_0(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001010ull
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_LANE_X_STATUS_0
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(0x0000000000001010ull + (((offset)& 3) + ((block_id)& 3) * 0x0ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_LCS_BA0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_LCS_BA0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000058ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_LCS_BA0
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000058ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_LCS_BA1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_LCS_BA1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000005Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_LCS_BA1
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000005Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_M2S_BAR0_START0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_M2S_BAR0_START0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_M2S_BAR0_START0
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_M2S_BAR0_START1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_M2S_BAR0_START1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200004ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_M2S_BAR0_START1
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200004ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_M2S_BAR1_START0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_M2S_BAR1_START0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200008ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_M2S_BAR1_START0
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200008ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_M2S_BAR1_START1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_M2S_BAR1_START1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000020000Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_M2S_BAR1_START1
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000020000Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_M2S_BAR2_START
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_M2S_BAR2_START(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200050ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_M2S_BAR2_START
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200050ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_MAC_CTRL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_MAC_CTRL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200068ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_MAC_CTRL
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200068ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PE_FEAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PE_FEAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PE_FEAT
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PE_LLC
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PE_LLC(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000004Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PE_LLC
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000004Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_0_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_0_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000015Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_0_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000015Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_0_CTL2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_0_CTL2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000154ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_0_CTL2
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000154ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_0_ERR_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_0_ERR_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000158ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_0_ERR_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000158ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_0_LINK_REQ
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_0_LINK_REQ(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000140ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_0_LINK_REQ
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000140ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_0_LINK_RESP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_0_LINK_RESP(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000144ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_0_LINK_RESP
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000144ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000148ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000148ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_GEN_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_GEN_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000013Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_GEN_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000013Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_LT_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_LT_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000120ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_LT_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000120ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_MBH0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_MBH0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000100ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_MBH0
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000100ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_RT_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_RT_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000124ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_RT_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000124ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PORT_TTL_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PORT_TTL_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000000012Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PORT_TTL_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000000012Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_PRI_DEV_ID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_PRI_DEV_ID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000060ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_PRI_DEV_ID
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000060ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_SEC_DEV_CTRL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_SEC_DEV_CTRL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200064ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_SEC_DEV_CTRL
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200064ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_SEC_DEV_ID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_SEC_DEV_ID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000200060ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_SEC_DEV_ID
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000200060ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_SERIAL_LANE_HDR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_SERIAL_LANE_HDR(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_SERIAL_LANE_HDR
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000001000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_SRC_OPS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_SRC_OPS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000018ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_SRC_OPS
parameter_list|(
name|block_id
parameter_list|)
value|(0x0000000000000018ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRIOMAINTX_TX_DROP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|block_id
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRIOMAINTX_TX_DROP(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
literal|0x000000000020006Cull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRIOMAINTX_TX_DROP
parameter_list|(
name|block_id
parameter_list|)
value|(0x000000000020006Cull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_sriomaint#_asmbly_id  *  * SRIOMAINT_ASMBLY_ID = SRIO Assembly ID  *  * The Assembly ID register shows the Assembly ID and Vendor  *  * Notes:  * The Assembly ID register shows the Assembly ID and Vendor specified in $SRIO_ASMBLY_ID.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ASMBLY_ID     hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_asmbly_id
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_asmbly_id_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|assy_id
range|:
literal|16
decl_stmt|;
comment|/**< Assembly Identifer */
name|uint32_t
name|assy_ven
range|:
literal|16
decl_stmt|;
comment|/**< Assembly Vendor Identifer */
else|#
directive|else
name|uint32_t
name|assy_ven
range|:
literal|16
decl_stmt|;
name|uint32_t
name|assy_id
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_asmbly_id_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_asmbly_id_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_asmbly_id_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_asmbly_id
name|cvmx_sriomaintx_asmbly_id_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_asmbly_info  *  * SRIOMAINT_ASMBLY_INFO = SRIO Assembly Information  *  * The Assembly Info register shows the Assembly Revision specified in $SRIO_ASMBLY_INFO  *  * Notes:  * The Assembly Info register shows the Assembly Revision specified in $SRIO_ASMBLY_INFO and Extended  *  Feature Pointer.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ASMBLY_INFO   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_asmbly_info
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_asmbly_info_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|assy_rev
range|:
literal|16
decl_stmt|;
comment|/**< Assembly Revision */
name|uint32_t
name|ext_fptr
range|:
literal|16
decl_stmt|;
comment|/**< Pointer to the first entry in the extended feature                                                          list. */
else|#
directive|else
name|uint32_t
name|ext_fptr
range|:
literal|16
decl_stmt|;
name|uint32_t
name|assy_rev
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_asmbly_info_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_asmbly_info_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_asmbly_info_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_asmbly_info
name|cvmx_sriomaintx_asmbly_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_bar1_idx#  *  * SRIOMAINT_BAR1_IDXX = SRIO BAR1 IndexX Register  *  * Contains address index and control bits for access to memory ranges of BAR1.  *  * Notes:  * This register specifies the Octeon address, endian swap and cache status associated with each of  *  the 16 BAR1 entries.  The local address bits used are based on the BARSIZE field located in the  *  SRIOMAINT(0,2..3)_M2S_BAR1_START0 register.  This register is only writeable over SRIO if the  *  SRIO(0,2..3)_ACC_CTRL.DENY_BAR1 bit is zero.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_BAR1_IDX[0:15]        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_bar1_idxx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_bar1_idxx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint32_t
name|la
range|:
literal|22
decl_stmt|;
comment|/**< L2/DRAM Address bits [37:16]                                                          Not all LA[21:0] bits are used by SRIO hardware,                                                          depending on SRIOMAINT(0,2..3)_M2S_BAR1_START1[BARSIZE].                                                                                   Become                                                                                  L2/DRAM                                                                                  Address  Entry                                                          BARSIZE   LA Bits Used   Bits    Size                                                             0        LA[21:0]    [37:16]   64KB                                                             1        LA[21:1]    [37:17]  128KB                                                             2        LA[21:2]    [37:18]  256KB                                                             3        LA[21:3]    [37:19]  512KB                                                             4        LA[21:4]    [37:20]    1MB                                                             5        LA[21:5]    [37:21]    2MB                                                             6        LA[21:6]    [37:22]    4MB                                                             7        LA[21:7]    [37:23]    8MB                                                             8        LA[21:8]    [37:24]   16MB                                                             9        LA[21:9]    [37:25]   32MB                                                            10        LA[21:10]   [37:26]   64MB                                                            11        LA[21:11]   [37:27]  128MB                                                            12        LA[21:12]   [37:28]  256MB                                                            13        LA[21:13]   [37:29]  512MB */
name|uint32_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint32_t
name|es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode.                                                          0 = No Swap                                                          1 = 64-bit Swap Bytes [ABCD_EFGH] -> [HGFE_DCBA]                                                          2 = 32-bit Swap Words [ABCD_EFGH] -> [DCBA_HGFE]                                                          3 = 32-bit Word Exch  [ABCD_EFGH] -> [EFGH_ABCD] */
name|uint32_t
name|nca
range|:
literal|1
decl_stmt|;
comment|/**< Non-Cacheable Access Mode.  When set, transfers                                                          through this window are not cacheable. */
name|uint32_t
name|reserved_1_2
range|:
literal|2
decl_stmt|;
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< When set the selected index address is valid. */
else|#
directive|else
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_2
range|:
literal|2
decl_stmt|;
name|uint32_t
name|nca
range|:
literal|1
decl_stmt|;
name|uint32_t
name|es
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint32_t
name|la
range|:
literal|22
decl_stmt|;
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_bar1_idxx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_bar1_idxx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_bar1_idxx_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_bar1_idxx
name|cvmx_sriomaintx_bar1_idxx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_bell_status  *  * SRIOMAINT_BELL_STATUS = SRIO Incoming Doorbell Status  *  * The SRIO Incoming (RX) Doorbell Status  *  * Notes:  * This register displays the status of the doorbells received.  If FULL is set the SRIO device will  *  retry incoming transactions.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_BELL_STATUS   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_bell_status
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_bell_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_1_31
range|:
literal|31
decl_stmt|;
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
comment|/**< Not able to receive Doorbell Transactions */
else|#
directive|else
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_31
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_bell_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_bell_status_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_bell_status_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_bell_status
name|cvmx_sriomaintx_bell_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_comp_tag  *  * SRIOMAINT_COMP_TAG = SRIO Component Tag  *  * Component Tag  *  * Notes:  * This register contains a component tag value for the processing element and the value can be  *  assigned by software when the device is initialized.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_COMP_TAG      hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_comp_tag
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_comp_tag_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|comp_tag
range|:
literal|32
decl_stmt|;
comment|/**< Component Tag for Firmware Use */
else|#
directive|else
name|uint32_t
name|comp_tag
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_comp_tag_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_comp_tag_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_comp_tag_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_comp_tag
name|cvmx_sriomaintx_comp_tag_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_core_enables  *  * SRIOMAINT_CORE_ENABLES = SRIO Core Control  *  * Core Control  *  * Notes:  * This register displays the reset state of the Octeon Core Logic while the SRIO Link is running.  *  The bit should be set after the software has initialized the chip to allow memory operations.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_CORE_ENABLES  hclk    hrst_n, srst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_core_enables
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_core_enables_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
name|uint32_t
name|halt
range|:
literal|1
decl_stmt|;
comment|/**< OCTEON currently in Reset                                                          0 = All OCTEON resources are available.                                                          1 = The OCTEON is in reset. When this bit is set,                                                              SRIO maintenance registers can be accessed,                                                              but BAR0, BAR1, and BAR2 cannot be. */
name|uint32_t
name|imsg1
range|:
literal|1
decl_stmt|;
comment|/**< Allow Incoming Message Unit 1 Operations                                                          Note: This bit is cleared when the C63XX is reset                                                           0 = SRIO Incoming Messages to Unit 1 ignored and                                                               return error response                                                           1 = SRIO Incoming Messages to Unit 1 */
name|uint32_t
name|imsg0
range|:
literal|1
decl_stmt|;
comment|/**< Allow Incoming Message Unit 0 Operations                                                          Note: This bit is cleared when the C63XX is reset                                                           0 = SRIO Incoming Messages to Unit 0 ignored and                                                               return error response                                                           1 = SRIO Incoming Messages to Unit 0 */
name|uint32_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< Allow Inbound Doorbell Operations                                                          Note: This bit is cleared when the C63XX is reset                                                           0 = SRIO Doorbell OPs ignored and return error                                                               response                                                           1 = SRIO Doorbell OPs Allowed */
name|uint32_t
name|memory
range|:
literal|1
decl_stmt|;
comment|/**< Allow Inbound/Outbound Memory Operations                                                          Note: This bit is cleared when the C63XX is reset                                                           0 = SRIO Incoming Nwrites and Swrites are                                                               dropped.  Incoming Nreads, Atomics and                                                               NwriteRs return responses with ERROR status.                                                               SRIO Incoming Maintenance BAR Memory Accesses                                                               are processed normally.                                                               Outgoing Store Operations are Dropped                                                               Outgoing Load Operations are not issued and                                                               return all 1's with an ERROR status.                                                               In Flight Operations started while the bit is                                                               set in both directions will complete normally.                                                           1 = SRIO Memory Read/Write OPs Allowed */
else|#
directive|else
name|uint32_t
name|memory
range|:
literal|1
decl_stmt|;
name|uint32_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint32_t
name|imsg0
range|:
literal|1
decl_stmt|;
name|uint32_t
name|imsg1
range|:
literal|1
decl_stmt|;
name|uint32_t
name|halt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_core_enables_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_core_enables_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_core_enables_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_core_enables
name|cvmx_sriomaintx_core_enables_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_dev_id  *  * SRIOMAINT_DEV_ID = SRIO Device ID  *  * The DeviceVendor Identity field identifies the vendor that manufactured the device  *  * Notes:  * This register identifies Cavium Inc. and the Product ID.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_DEV_ID        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_dev_id
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_dev_id_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|device
range|:
literal|16
decl_stmt|;
comment|/**< Product Identity */
name|uint32_t
name|vendor
range|:
literal|16
decl_stmt|;
comment|/**< Cavium Vendor Identity */
else|#
directive|else
name|uint32_t
name|vendor
range|:
literal|16
decl_stmt|;
name|uint32_t
name|device
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_dev_id_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_dev_id_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_dev_id_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_dev_id
name|cvmx_sriomaintx_dev_id_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_dev_rev  *  * SRIOMAINT_DEV_REV = SRIO Device Revision  *  * The Device Revision register identifies the chip pass and revision  *  * Notes:  * This register identifies the chip pass and revision derived from the fuses.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_DEV_REV       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_dev_rev
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_dev_rev_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
name|uint32_t
name|revision
range|:
literal|8
decl_stmt|;
comment|/**< Chip Pass/Revision */
else|#
directive|else
name|uint32_t
name|revision
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_dev_rev_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_dev_rev_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_dev_rev_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_dev_rev
name|cvmx_sriomaintx_dev_rev_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_dst_ops  *  * SRIOMAINT_DST_OPS = SRIO Source Operations  *  * The logical operations supported from external devices.  *  * Notes:  * The logical operations supported from external devices.   The Destination OPs register shows the  *  operations specified in the SRIO(0,2..3)_IP_FEATURE.OPS register.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_DST_OPS       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_dst_ops
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_dst_ops_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|gsm_read
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Read Home operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<31>] */
name|uint32_t
name|i_read
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Instruction Read.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<30>] */
name|uint32_t
name|rd_own
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Read for Ownership.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<29>] */
name|uint32_t
name|d_invald
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Data Cache Invalidate.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<28>] */
name|uint32_t
name|castout
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Castout Operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<27>] */
name|uint32_t
name|d_flush
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Data Cache Flush.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<26>] */
name|uint32_t
name|io_read
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support IO Read.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<25>] */
name|uint32_t
name|i_invald
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Instruction Cache Invalidate.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<24>] */
name|uint32_t
name|tlb_inv
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support TLB Entry Invalidate.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<23>] */
name|uint32_t
name|tlb_invs
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support TLB Entry Invalidate Sync.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<22>] */
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|read
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Nread operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<15>] */
name|uint32_t
name|write
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Nwrite operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<14>] */
name|uint32_t
name|swrite
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Swrite operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<13>] */
name|uint32_t
name|write_r
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Write with Response operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<12>] */
name|uint32_t
name|msg
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Data Message operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<11>] */
name|uint32_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Doorbell operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<10>] */
name|uint32_t
name|compswap
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Atomic Compare and Swap.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<9>] */
name|uint32_t
name|testswap
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Atomic Test and Swap.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<8>] */
name|uint32_t
name|atom_inc
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic increment operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<7>] */
name|uint32_t
name|atom_dec
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic decrement operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<6>] */
name|uint32_t
name|atom_set
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic set operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<5>] */
name|uint32_t
name|atom_clr
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic clear operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<4>] */
name|uint32_t
name|atom_swp
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Atomic Swap.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<3>] */
name|uint32_t
name|port_wr
range|:
literal|1
decl_stmt|;
comment|/**< PE can Port Write operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<2>] */
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint32_t
name|port_wr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_swp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_clr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_set
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_dec
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_inc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|testswap
range|:
literal|1
decl_stmt|;
name|uint32_t
name|compswap
range|:
literal|1
decl_stmt|;
name|uint32_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg
range|:
literal|1
decl_stmt|;
name|uint32_t
name|write_r
range|:
literal|1
decl_stmt|;
name|uint32_t
name|swrite
range|:
literal|1
decl_stmt|;
name|uint32_t
name|write
range|:
literal|1
decl_stmt|;
name|uint32_t
name|read
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|tlb_invs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tlb_inv
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_invald
range|:
literal|1
decl_stmt|;
name|uint32_t
name|io_read
range|:
literal|1
decl_stmt|;
name|uint32_t
name|d_flush
range|:
literal|1
decl_stmt|;
name|uint32_t
name|castout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|d_invald
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rd_own
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_read
range|:
literal|1
decl_stmt|;
name|uint32_t
name|gsm_read
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_dst_ops_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_dst_ops_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_dst_ops_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_dst_ops
name|cvmx_sriomaintx_dst_ops_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_attr_capt  *  * SRIOMAINT_ERB_ATTR_CAPT = SRIO Attributes Capture  *  * Attributes Capture  *  * Notes:  * This register contains the information captured during the error.  *  The HW will not update this register (i.e. this register is locked) while  *  VALID is set in this CSR.  *  The HW sets SRIO_INT_REG[PHY_ERB] every time it sets VALID in this CSR.  *  To handle the interrupt, the following procedure may be best:  *       (1) clear SRIO_INT_REG[PHY_ERB],  *       (2) read this CSR, corresponding SRIOMAINT*_ERB_ERR_DET, SRIOMAINT*_ERB_PACK_SYM_CAPT,  *           SRIOMAINT*_ERB_PACK_CAPT_1, SRIOMAINT*_ERB_PACK_CAPT_2, and SRIOMAINT*_ERB_PACK_CAPT_3  *       (3) Write VALID in this CSR to 0.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ATTR_CAPT hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_attr_capt
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_attr_capt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|inf_type
range|:
literal|3
decl_stmt|;
comment|/**< Type of Information Logged.                                                          000 - Packet                                                          010 - Short Control Symbol                                                                (use only first capture register)                                                          100 - Implementation Specific Error Reporting                                                          All Others Reserved */
name|uint32_t
name|err_type
range|:
literal|5
decl_stmt|;
comment|/**< The encoded value of the 31 minus the bit in                                                          SRIOMAINT(0,2..3)_ERB_ERR_DET that describes the error                                                          captured in SRIOMAINT(0,2..3)_ERB_*CAPT Registers.                                                          (For example a value of 5 indicates 31-5 = bit 26) */
name|uint32_t
name|err_info
range|:
literal|20
decl_stmt|;
comment|/**< Error Info.                                                          ERR_TYPE Bits   Description                                                             0     23     TX Protocol Error                                                                   22     RX Protocol Error                                                                   21     TX Link Response Timeout                                                                   20     TX ACKID Timeout                                                                   - 19:16  Reserved                                                                   - 15:12  TX Protocol ID                                                                          1 = Rcvd Unexpected Link Response                                                                          2 = Rcvd Link Response before Req                                                                          3 = Rcvd NACK servicing NACK                                                                          4 = Rcvd NACK                                                                          5 = Rcvd RETRY servicing RETRY                                                                          6 = Rcvd RETRY servicing NACK                                                                          7 = Rcvd ACK servicing RETRY                                                                          8 = Rcvd ACK servicing NACK                                                                          9 = Unexp ACKID on ACK or RETRY                                                                         10 = Unexp ACK or RETRY                                                                   - 11:8   Reserved                                                                   - 7:4   RX Protocol ID                                                                          1 = Rcvd EOP w/o Prev SOP                                                                          2 = Rcvd STOMP w/o Prev SOP                                                                          3 = Unexp RESTART                                                                          4 = Redundant Status from LinkReq                                                           9-16    23:20  RX K Bits                                                                   - 19:0   Reserved                                                            26     23:20  RX K Bits                                                                   - 19:0   Reserved                                                            27     23:12  Type                                                                            0x000 TX                                                                            0x010 RX                                                                   - 11:8   RX or TX Protocol ID (see above)                                                                   - 7:4   Reserved                                                            30     23:20  RX K Bits                                                                   - 19:0   Reserved                                                            31     23:16  ACKID Timeout 0x2                                                                   - 15:14  Reserved                                                                   - 13:8   AckID                                                                   - 7:4   Reserved                                                            All others ERR_TYPEs are reserved. */
name|uint32_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set by hardware to indicate that the                                                          Packet/control symbol capture registers contain                                                          valid information. For control symbols, only                                                          capture register 0 will contain meaningful                                                          information.  This bit must be cleared by software                                                          to allow capture of other errors. */
else|#
directive|else
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint32_t
name|err_info
range|:
literal|20
decl_stmt|;
name|uint32_t
name|err_type
range|:
literal|5
decl_stmt|;
name|uint32_t
name|inf_type
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_attr_capt_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_attr_capt_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|inf_type
range|:
literal|3
decl_stmt|;
comment|/**< Type of Information Logged.                                                          000 - Packet                                                          010 - Short Control Symbol                                                                (use only first capture register)                                                          All Others Reserved */
name|uint32_t
name|err_type
range|:
literal|5
decl_stmt|;
comment|/**< The encoded value of the 31 minus the bit in                                                          SRIOMAINT(0..1)_ERB_ERR_DET that describes the error                                                          captured in SRIOMAINT(0..1)_ERB_*CAPT Registers.                                                          (For example a value of 5 indicates 31-5 = bit 26) */
name|uint32_t
name|reserved_1_23
range|:
literal|23
decl_stmt|;
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set by hardware to indicate that the                                                          Packet/control symbol capture registers contain                                                          valid information. For control symbols, only                                                          capture register 0 will contain meaningful                                                          information.  This bit must be cleared by software                                                          to allow capture of other errors. */
else|#
directive|else
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_23
range|:
literal|23
decl_stmt|;
name|uint32_t
name|err_type
range|:
literal|5
decl_stmt|;
name|uint32_t
name|inf_type
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_sriomaintx_erb_attr_capt_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_attr_capt
name|cvmx_sriomaintx_erb_attr_capt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_err_det  *  * SRIOMAINT_ERB_ERR_DET = SRIO Error Detect  *  * Error Detect  *  * Notes:  * The Error Detect Register indicates physical layer transmission errors detected by the hardware.  *  The HW will not update this register (i.e. this register is locked) while  *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_DET   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_err_det
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_err_det_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|imp_err
range|:
literal|1
decl_stmt|;
comment|/**< Implementation Specific Error. */
name|uint32_t
name|reserved_23_30
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
comment|/**< Received a control symbol with a bad CRC value                                                          Complete Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
comment|/**< Received an acknowledge control symbol with an                                                          unexpected ackID (packet-accepted or packet_retry)                                                          Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
comment|/**< Received packet-not-accepted acknowledge control                                                          symbols.                                                          Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
comment|/**< Received packet with unexpected ackID value                                                          Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
comment|/**< Received a packet with a bad CRC value                                                          Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
comment|/**< Received packet which exceeds the maximum allowed                                                          size of 276 bytes.                                                          Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|inv_char
range|:
literal|1
decl_stmt|;
comment|/**< Received illegal, 8B/10B error  or undefined                                                          codegroup within a packet.                                                          Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|inv_data
range|:
literal|1
decl_stmt|;
comment|/**< Received data codegroup or 8B/10B error within an                                                          IDLE sequence.                                                          Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|reserved_6_14
range|:
literal|9
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
comment|/**< Link_response received with an ackID that is not                                                          outstanding.                                                          Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
comment|/**< An unexpected packet or control symbol was                                                          received.                                                          Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
comment|/**< Received illegal or undefined codegroup.                                                          (either INV_DATA or INV_CHAR)                                                          Complete Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
comment|/**< An unexpected acknowledge control symbol was                                                          received.                                                          Partial Symbol in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
comment|/**< An acknowledge or link-response control symbol is                                                          not received within the specified timeout interval                                                          Partial Header in SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT */
else|#
directive|else
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_14
range|:
literal|9
decl_stmt|;
name|uint32_t
name|inv_data
range|:
literal|1
decl_stmt|;
name|uint32_t
name|inv_char
range|:
literal|1
decl_stmt|;
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_23_30
range|:
literal|8
decl_stmt|;
name|uint32_t
name|imp_err
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_err_det_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_err_det_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
comment|/**< Received a control symbol with a bad CRC value                                                          Complete Symbol in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
comment|/**< Received an acknowledge control symbol with an                                                          unexpected ackID (packet-accepted or packet_retry)                                                          Partial Symbol in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
comment|/**< Received packet-not-accepted acknowledge control                                                          symbols.                                                          Partial Symbol in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
comment|/**< Received packet with unexpected ackID value                                                          Header in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
comment|/**< Received a packet with a bad CRC value                                                          Header in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
comment|/**< Received packet which exceeds the maximum allowed                                                          size of 276 bytes.                                                          Header in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|reserved_6_16
range|:
literal|11
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
comment|/**< Link_response received with an ackID that is not                                                          outstanding.                                                          Partial Symbol in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
comment|/**< An unexpected packet or control symbol was                                                          received.                                                          Partial Symbol in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
comment|/**< Received illegal or undefined codegroup.                                                          (either INV_DATA or INV_CHAR) (Pass 2)                                                          Complete Symbol in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
comment|/**< An unexpected acknowledge control symbol was                                                          received.                                                          Partial Symbol in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
comment|/**< An acknowledge or link-response control symbol is                                                          not received within the specified timeout interval                                                          Partial Header in SRIOMAINT(0..1)_ERB_PACK_SYM_CAPT */
else|#
directive|else
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_16
range|:
literal|11
decl_stmt|;
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_sriomaintx_erb_err_det_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_err_det
name|cvmx_sriomaintx_erb_err_det_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_err_rate  *  * SRIOMAINT_ERB_ERR_RATE = SRIO Error Rate  *  * Error Rate  *  * Notes:  * The Error Rate register is used with the Error Rate Threshold register to monitor and control the  *  reporting of transmission errors.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_RATE  hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_err_rate
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_err_rate_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|err_bias
range|:
literal|8
decl_stmt|;
comment|/**< These bits provide the error rate bias value.                                                          0x00 - do not decrement the error rate counter                                                          0x01 - decrement every 1ms (+/-34%)                                                          0x02 - decrement every 10ms (+/-34%)                                                          0x04 - decrement every 100ms (+/-34%)                                                          0x08 - decrement every 1s (+/-34%)                                                          0x10 - decrement every 10s (+/-34%)                                                          0x20 - decrement every 100s (+/-34%)                                                          0x40 - decrement every 1000s (+/-34%)                                                          0x80 - decrement every 10000s (+/-34%)                                                          All other values are reserved */
name|uint32_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint32_t
name|rate_lim
range|:
literal|2
decl_stmt|;
comment|/**< These bits limit the incrementing of the error                                                          rate counter above the failed threshold trigger.                                                            00 - only count 2 errors above                                                            01 - only count 4 errors above                                                            10 - only count 16 error above                                                            11 - do not limit incrementing the error rate ct */
name|uint32_t
name|pk_rate
range|:
literal|8
decl_stmt|;
comment|/**< Peak Value attainted by the error rate counter */
name|uint32_t
name|rate_cnt
range|:
literal|8
decl_stmt|;
comment|/**< These bits maintain a count of the number of                                                          transmission errors that have been detected by the                                                          port, decremented by the Error Rate Bias                                                          mechanism, to create an indication of the link                                                          error rate. */
else|#
directive|else
name|uint32_t
name|rate_cnt
range|:
literal|8
decl_stmt|;
name|uint32_t
name|pk_rate
range|:
literal|8
decl_stmt|;
name|uint32_t
name|rate_lim
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint32_t
name|err_bias
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_err_rate
name|cvmx_sriomaintx_erb_err_rate_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_err_rate_en  *  * SRIOMAINT_ERB_ERR_RATE_EN = SRIO Error Rate Enable  *  * Error Rate Enable  *  * Notes:  * This register contains the bits that control when an error condition is allowed to increment the  *  error rate counter in the Error Rate Threshold Register and lock the Error Capture registers.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_RATE_EN       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_err_rate_en
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_err_rate_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|imp_err
range|:
literal|1
decl_stmt|;
comment|/**< Enable Implementation Specific Error. */
name|uint32_t
name|reserved_23_30
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of control symbols with                                                          bad CRC values */
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of acknowledge control                                                          symbol with unexpected ackIDs                                                          (packet-accepted or packet_retry) */
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of packet-not-accepted                                                          acknowledge control symbols. */
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received packet with                                                          unexpected ackID value */
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received a packet                                                          with a bad CRC value */
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received packet                                                          which exceeds the maximum size of 276 bytes. */
name|uint32_t
name|inv_char
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received illegal                                                          illegal, 8B/10B error or undefined codegroup                                                          within a packet. */
name|uint32_t
name|inv_data
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received data                                                          codegroup or 8B/10B error within IDLE sequence. */
name|uint32_t
name|reserved_6_14
range|:
literal|9
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of link_responses with                                                          an ackID that is not outstanding. */
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of unexpected packet or                                                          control symbols received. */
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of illegal or undefined                                                          codegroups (either INV_DATA or INV_CHAR). */
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of unexpected                                                          acknowledge control symbols received. */
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of acknowledge or                                                          link-response control symbols not received within                                                          the specified timeout interval */
else|#
directive|else
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_14
range|:
literal|9
decl_stmt|;
name|uint32_t
name|inv_data
range|:
literal|1
decl_stmt|;
name|uint32_t
name|inv_char
range|:
literal|1
decl_stmt|;
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_23_30
range|:
literal|8
decl_stmt|;
name|uint32_t
name|imp_err
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_en_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_err_rate_en_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of control symbols with                                                          bad CRC values */
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of acknowledge control                                                          symbol with unexpected ackIDs                                                          (packet-accepted or packet_retry) */
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of packet-not-accepted                                                          acknowledge control symbols. */
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received packet with                                                          unexpected ackID value */
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received a packet                                                          with a bad CRC value */
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of received packet                                                          which exceeds the maximum size of 276 bytes. */
name|uint32_t
name|reserved_6_16
range|:
literal|11
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of link_responses with                                                          an ackID that is not outstanding. */
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of unexpected packet or                                                          control symbols received. */
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of illegal or undefined                                                          codegroups (either INV_DATA or INV_CHAR). (Pass 2) */
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of unexpected                                                          acknowledge control symbols received. */
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
comment|/**< Enable error rate counting of acknowledge or                                                          link-response control symbols not received within                                                          the specified timeout interval */
else|#
directive|else
name|uint32_t
name|lnk_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|del_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|f_toggle
range|:
literal|1
decl_stmt|;
name|uint32_t
name|proterr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bad_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_16
range|:
literal|11
decl_stmt|;
name|uint32_t
name|size
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pkt_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|out_ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_id
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ctl_crc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_en_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_err_rate_en
name|cvmx_sriomaintx_erb_err_rate_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_err_rate_thr  *  * SRIOMAINT_ERB_ERR_RATE_THR = SRIO Error Rate Threshold  *  * Error Rate Threshold  *  * Notes:  * The Error Rate Threshold register is used to control the reporting of errors to the link status.  *  Typically the Degraded Threshold is less than the Fail Threshold.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR      hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_err_rate_thr
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_err_rate_thr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|fail_th
range|:
literal|8
decl_stmt|;
comment|/**< These bits provide the threshold value for                                                          reporting an error condition due to a possibly                                                          broken link.                                                            0x00 - Disable the Error Rate Failed Threshold                                                                   Trigger                                                            0x01 - Set the error reporting threshold to 1                                                            0x02 - Set the error reporting threshold to 2                                                            - ...                                                            0xFF - Set the error reporting threshold to 255 */
name|uint32_t
name|dgrad_th
range|:
literal|8
decl_stmt|;
comment|/**< These bits provide the threshold value for                                                          reporting an error condition due to a possibly                                                          degrading link.                                                            0x00 - Disable the Degrade Rate Failed Threshold                                                                   Trigger                                                            0x01 - Set the error reporting threshold to 1                                                            0x02 - Set the error reporting threshold to 2                                                            - ...                                                            0xFF - Set the error reporting threshold to 255 */
name|uint32_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
name|uint32_t
name|dgrad_th
range|:
literal|8
decl_stmt|;
name|uint32_t
name|fail_th
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_thr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_thr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_err_rate_thr_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_err_rate_thr
name|cvmx_sriomaintx_erb_err_rate_thr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_hdr  *  * SRIOMAINT_ERB_HDR = SRIO Error Reporting Block Header  *  * Error Reporting Block Header  *  * Notes:  * The error management extensions block header register contains the EF_PTR to the next EF_BLK and  *  the EF_ID that identifies this as the error management extensions block header. In this  *  implementation this is the last block and therefore the EF_PTR is a NULL pointer.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_HDR       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_hdr
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_hdr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|ef_ptr
range|:
literal|16
decl_stmt|;
comment|/**< Pointer to the next block in the extended features                                                          data structure. */
name|uint32_t
name|ef_id
range|:
literal|16
decl_stmt|;
comment|/**< Single Port ID */
else|#
directive|else
name|uint32_t
name|ef_id
range|:
literal|16
decl_stmt|;
name|uint32_t
name|ef_ptr
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_hdr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_hdr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_hdr_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_hdr
name|cvmx_sriomaintx_erb_hdr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_lt_addr_capt_h  *  * SRIOMAINT_ERB_LT_ADDR_CAPT_H = SRIO Logical/Transport Layer High Address Capture  *  * Logical/Transport Layer High Address Capture  *  * Notes:  * This register contains error information. It is locked when a Logical/Transport error is detected  *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero. This register should be  *  written only when error detection is disabled.  This register is only required for end point  *  transactions of 50 or 66 bits.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ADDR_CAPT_H    hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_lt_addr_capt_h
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_h_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr
range|:
literal|32
decl_stmt|;
comment|/**< Most significant 32 bits of the address associated                                                          with the error. Information supplied for requests                                                          and responses if available. */
else|#
directive|else
name|uint32_t
name|addr
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_h_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_h_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_h_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_lt_addr_capt_h
name|cvmx_sriomaintx_erb_lt_addr_capt_h_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_lt_addr_capt_l  *  * SRIOMAINT_ERB_LT_ADDR_CAPT_L = SRIO Logical/Transport Layer Low Address Capture  *  * Logical/Transport Layer Low Address Capture  *  * Notes:  * This register contains error information. It is locked when a Logical/Transport error is detected  *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero.  This register should be  *  written only when error detection is disabled.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ADDR_CAPT_L    hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_lt_addr_capt_l
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_l_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr
range|:
literal|29
decl_stmt|;
comment|/**< Least significant 29 bits of the address                                                          associated with the error.  Bits 31:24 specify the                                                          request HOP count for Maintenance Operations.                                                          Information supplied for requests and responses if                                                          available. */
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|xaddr
range|:
literal|2
decl_stmt|;
comment|/**< Extended address bits of the address associated                                                          with the error.  Information supplied for requests                                                          and responses if available. */
else|#
directive|else
name|uint32_t
name|xaddr
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint32_t
name|addr
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_l_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_l_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_addr_capt_l_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_lt_addr_capt_l
name|cvmx_sriomaintx_erb_lt_addr_capt_l_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_lt_ctrl_capt  *  * SRIOMAINT_ERB_LT_CTRL_CAPT = SRIO Logical/Transport Layer Control Capture  *  * Logical/Transport Layer Control Capture  *  * Notes:  * This register contains error information. It is locked when a Logical/Transport error is detected  *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero.  This register should be  *  written only when error detection is disabled.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_CTRL_CAPT      hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_lt_ctrl_capt
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_lt_ctrl_capt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|ftype
range|:
literal|4
decl_stmt|;
comment|/**< Format Type associated with the error */
name|uint32_t
name|ttype
range|:
literal|4
decl_stmt|;
comment|/**< Transaction Type associated with the error                                                          (For Messages)                                                          Message Length */
name|uint32_t
name|extra
range|:
literal|8
decl_stmt|;
comment|/**< Additional Information                                                          (For Messages)                                                          - 23:22 Letter                                                          - 21:20 Mbox                                                          - 19:16 Msgseg/xmbox                                                          Information for the last message request sent                                                          for the mailbox that had an error                                                          (For Responses)                                                          - 23:20 Response Request FTYPE                                                          - 19:16 Response Request TTYPE                                                          (For all other types)                                                          Reserved. */
name|uint32_t
name|status
range|:
literal|4
decl_stmt|;
comment|/**< Response Status.                                                          (For all other Requests)                                                          Reserved. */
name|uint32_t
name|size
range|:
literal|4
decl_stmt|;
comment|/**< Size associated with the transaction. */
name|uint32_t
name|tt
range|:
literal|1
decl_stmt|;
comment|/**< Transfer Type 0=ID8, 1=ID16. */
name|uint32_t
name|wdptr
range|:
literal|1
decl_stmt|;
comment|/**< Word Pointer associated with the error. */
name|uint32_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint32_t
name|capt_idx
range|:
literal|5
decl_stmt|;
comment|/**< Capture Index. 31 - Bit set in                                                          SRIOMAINT(0,2..3)_ERB_LT_ERR_DET. */
else|#
directive|else
name|uint32_t
name|capt_idx
range|:
literal|5
decl_stmt|;
name|uint32_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint32_t
name|wdptr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|size
range|:
literal|4
decl_stmt|;
name|uint32_t
name|status
range|:
literal|4
decl_stmt|;
name|uint32_t
name|extra
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ttype
range|:
literal|4
decl_stmt|;
name|uint32_t
name|ftype
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_lt_ctrl_capt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_ctrl_capt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_ctrl_capt_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_lt_ctrl_capt
name|cvmx_sriomaintx_erb_lt_ctrl_capt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_lt_dev_id  *  * SRIOMAINT_ERB_LT_DEV_ID = SRIO Port-write Target deviceID  *  * Port-write Target deviceID  *  * Notes:  * This SRIO interface does not support generating Port-Writes based on ERB Errors.  This register is  *  currently unused and should be treated as reserved.  *  * Clk_Rst:        SRIOMAINT_ERB_LT_DEV_ID hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_lt_dev_id
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_lt_dev_id_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|id16
range|:
literal|8
decl_stmt|;
comment|/**< This is the most significant byte of the                                                          port-write destination deviceID (large transport                                                          systems only)                                                          destination ID used for Port Write errors */
name|uint32_t
name|id8
range|:
literal|8
decl_stmt|;
comment|/**< This is the port-write destination deviceID */
name|uint32_t
name|tt
range|:
literal|1
decl_stmt|;
comment|/**< Transport Type used for Port Write                                                          0 = Small Transport, ID8 Only                                                          1 = Large Transport, ID16 and ID8 */
name|uint32_t
name|reserved_0_14
range|:
literal|15
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_14
range|:
literal|15
decl_stmt|;
name|uint32_t
name|tt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|id8
range|:
literal|8
decl_stmt|;
name|uint32_t
name|id16
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_lt_dev_id_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_dev_id_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_dev_id_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_lt_dev_id
name|cvmx_sriomaintx_erb_lt_dev_id_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_lt_dev_id_capt  *  * SRIOMAINT_ERB_LT_DEV_ID_CAPT = SRIO Logical/Transport Layer Device ID Capture  *  * Logical/Transport Layer Device ID Capture  *  * Notes:  * This register contains error information. It is locked when a Logical/Transport error is detected  *  and unlocked when the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET is written to zero.  This register should be  *  written only when error detection is disabled.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_DEV_ID_CAPT    hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_lt_dev_id_capt
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_lt_dev_id_capt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|dst_id16
range|:
literal|8
decl_stmt|;
comment|/**< Most significant byte of the large transport                                                          destination ID associated with the error */
name|uint32_t
name|dst_id8
range|:
literal|8
decl_stmt|;
comment|/**< Least significant byte of the large transport                                                          destination ID or the 8-bit small transport                                                          destination ID associated with the error */
name|uint32_t
name|src_id16
range|:
literal|8
decl_stmt|;
comment|/**< Most significant byte of the large transport                                                          source ID associated with the error */
name|uint32_t
name|src_id8
range|:
literal|8
decl_stmt|;
comment|/**< Least significant byte of the large transport                                                          source ID or the 8-bit small transport source ID                                                          associated with the error */
else|#
directive|else
name|uint32_t
name|src_id8
range|:
literal|8
decl_stmt|;
name|uint32_t
name|src_id16
range|:
literal|8
decl_stmt|;
name|uint32_t
name|dst_id8
range|:
literal|8
decl_stmt|;
name|uint32_t
name|dst_id16
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_lt_dev_id_capt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_dev_id_capt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_dev_id_capt_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_lt_dev_id_capt
name|cvmx_sriomaintx_erb_lt_dev_id_capt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_lt_err_det  *  * SRIOMAINT_ERB_LT_ERR_DET = SRIO Logical/Transport Layer Error Detect  *  * SRIO Logical/Transport Layer Error Detect  *  * Notes:  * This register indicates the error that was detected by the Logical or Transport logic layer.  *  Once a bit is set in this CSR, HW will lock the register until SW writes a zero to clear all the  *  fields.  The HW sets SRIO_INT_REG[LOG_ERB] every time it sets one of the bits.  *  To handle the interrupt, the following procedure may be best:  *       (1) clear SRIO_INT_REG[LOG_ERB],  *       (2) read this CSR, corresponding SRIOMAINT*_ERB_LT_ADDR_CAPT_H, SRIOMAINT*_ERB_LT_ADDR_CAPT_L,  *           SRIOMAINT*_ERB_LT_DEV_ID_CAPT, and SRIOMAINT*_ERB_LT_CTRL_CAPT  *       (3) Write this CSR to 0.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ERR_DET        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_lt_err_det
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_lt_err_det_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|io_err
range|:
literal|1
decl_stmt|;
comment|/**< Received a response of ERROR for an IO Logical                                                          Layer Request.  This includes all Maintenance and                                                          Memory Responses not destined for the RX Soft                                                          Packet FIFO. When SRIO receives an ERROR response                                                          for a read, the issuing core or DPI DMA engine                                                          receives result bytes with all bits set. In the                                                          case of writes with response, this bit is the only                                                          indication of failure. */
name|uint32_t
name|msg_err
range|:
literal|1
decl_stmt|;
comment|/**< Received a response of ERROR for an outgoing                                                          message segment. This bit is the only direct                                                          indication of a MSG_ERR. When a MSG_ERR occurs,                                                          SRIO drops the message segment and will not set                                                          SRIO*_INT_REG[OMSG*] after the message                                                          "transfer". NOTE: SRIO can continue to send or                                                          retry other segments from the same message after                                                          a MSG_ERR. */
name|uint32_t
name|gsm_err
range|:
literal|1
decl_stmt|;
comment|/**< Received a response of ERROR for an GSM Logical                                                          Request.  SRIO hardware never sets this bit. GSM                                                          operations are not supported (outside of the Soft                                                          Packet FIFO). */
name|uint32_t
name|msg_fmt
range|:
literal|1
decl_stmt|;
comment|/**< Received an incoming Message Segment with a                                                          formating error.  A MSG_FMT error occurs when SRIO                                                          receives a message segment with a reserved SSIZE,                                                          or a illegal data payload size, or a MSGSEG greater                                                          than MSGLEN, or a MSGSEG that is the duplicate of                                                          one already received by an inflight message.                                                          When a non-duplicate MSG_FMT error occurs, SRIO                                                          drops the segment and sends an ERROR response.                                                          When a duplicate MSG_FMT error occurs, SRIO                                                          (internally) terminates the currently-inflight                                                          message with an error and processes the duplicate,                                                          which may result in a new message being generated                                                          internally for the duplicate. */
name|uint32_t
name|ill_tran
range|:
literal|1
decl_stmt|;
comment|/**< Received illegal fields in the request/response                                                          packet for a supported transaction or any packet                                                          with a reserved transaction type. When an ILL_TRAN                                                          error occurs, SRIO ignores the packet. ILL_TRAN                                                          errors are 2nd priority after ILL_TGT and may mask                                                          other problems. Packets with ILL_TRAN errors cannot                                                          enter the RX Soft Packet FIFO.                                                          There are two things that can set ILL_TRAN:                                                          (1) SRIO received a packet with a tt value is not                                                          0 or 1, or (2) SRIO received a response to an                                                          outstanding message segment whose status was not                                                          DONE, RETRY, or ERROR. */
name|uint32_t
name|ill_tgt
range|:
literal|1
decl_stmt|;
comment|/**< Received a packet that contained a destination ID                                                          other than SRIOMAINT*_PRI_DEV_ID or                                                          SRIOMAINT*_SEC_DEV_ID. When an ILL_TGT error                                                          occurs, SRIO drops the packet. ILL_TGT errors are                                                          highest priority, so may mask other problems.                                                          Packets with ILL_TGT errors cannot enter the RX                                                          soft packet fifo. */
name|uint32_t
name|msg_tout
range|:
literal|1
decl_stmt|;
comment|/**< An expected incoming message request has not been                                                          received within the time-out interval specified in                                                          SRIOMAINT(0,2..3)_PORT_RT_CTL. When a MSG_TOUT occurs,                                                          SRIO (internally) terminates the inflight message                                                          with an error. */
name|uint32_t
name|pkt_tout
range|:
literal|1
decl_stmt|;
comment|/**< A required response has not been received to an                                                          outgoing memory, maintenance or message request                                                          before the time-out interval specified in                                                          SRIOMAINT(0,2..3)_PORT_RT_CTL.  When an IO or maintenance                                                          read request operation has a PKT_TOUT, the issuing                                                          core load or DPI DMA engine receive all ones for                                                          the result. When an IO NWRITE_R has a PKT_TOUT,                                                          this bit is the only indication of failure. When a                                                          message request operation has a PKT_TOUT, SRIO                                                          discards the the outgoing message segment,  and                                                          this bit is the only direct indication of failure.                                                          NOTE: SRIO may continue to send or retry other                                                          segments from the same message. When one or more of                                                          the segments in an outgoing message have a                                                          PKT_TOUT, SRIO will not set SRIO*_INT_REG[OMSG*]                                                          after the message "transfer". */
name|uint32_t
name|uns_resp
range|:
literal|1
decl_stmt|;
comment|/**< An unsolicited/unexpected memory, maintenance or                                                          message response packet was received that was not                                                          destined for the RX Soft Packet FIFO.  When this                                                          condition is detected, the packet is dropped. */
name|uint32_t
name|uns_tran
range|:
literal|1
decl_stmt|;
comment|/**< A transaction is received that is not supported.                                                          SRIO HW will never set this bit - SRIO routes all                                                          unsupported transactions to the RX soft packet                                                          FIFO. */
name|uint32_t
name|reserved_1_21
range|:
literal|21
decl_stmt|;
name|uint32_t
name|resp_sz
range|:
literal|1
decl_stmt|;
comment|/**< Received an incoming Memory or Maintenance                                                          Read response packet with a DONE status and less                                                          data then expected.  This condition causes the                                                          Read to be completed and an error response to be                                                          returned with all the data bits set to the issuing                                                          Core or DMA Engine. */
else|#
directive|else
name|uint32_t
name|resp_sz
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_21
range|:
literal|21
decl_stmt|;
name|uint32_t
name|uns_tran
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_resp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pkt_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ill_tgt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ill_tran
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg_fmt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|gsm_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|io_err
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_lt_err_det_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_err_det_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_err_det_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_lt_err_det
name|cvmx_sriomaintx_erb_lt_err_det_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_lt_err_en  *  * SRIOMAINT_ERB_LT_ERR_EN = SRIO Logical/Transport Layer Error Enable  *  * SRIO Logical/Transport Layer Error Enable  *  * Notes:  * This register contains the bits that control if an error condition locks the Logical/Transport  *  Layer Error Detect and Capture registers and is reported to the system host.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_LT_ERR_EN hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_lt_err_en
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_lt_err_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|io_err
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of an IO error response. Save and                                                          lock original request transaction information in                                                          all Logical/Transport Layer Capture CSRs. */
name|uint32_t
name|msg_err
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of a Message error response. Save                                                          and lock original request transaction information                                                          in all Logical/Transport Layer Capture CSRs. */
name|uint32_t
name|gsm_err
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of a GSM error response. Save and                                                          lock original request transaction capture                                                          information in all Logical/Transport Layer Capture                                                          CSRs. */
name|uint32_t
name|msg_fmt
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of a message format error. Save                                                          and lock transaction capture information in                                                          Logical/Transport Layer Device ID and Control                                                          Capture CSRs. */
name|uint32_t
name|ill_tran
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of an illegal transaction decode                                                          error Save and lock transaction capture                                                          information in Logical/Transport Layer Device ID                                                          and Control Capture CSRs. */
name|uint32_t
name|ill_tgt
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of an illegal transaction target                                                          error. Save and lock transaction capture                                                          information in Logical/Transport Layer Device ID                                                          and Control Capture CSRs. */
name|uint32_t
name|msg_tout
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of a Message Request time-out                                                          error. Save and lock transaction capture                                                          information in Logical/Transport Layer Device ID                                                          and Control Capture CSRs for the last Message                                                          request segment packet received. */
name|uint32_t
name|pkt_tout
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of a packet response time-out                                                          error.  Save and lock original request address in                                                          Logical/Transport Layer Address Capture CSRs.                                                          Save and lock original request Destination ID in                                                          Logical/Transport Layer Device ID Capture CSR. */
name|uint32_t
name|uns_resp
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of an unsolicited response error.                                                          Save and lock transaction capture information in                                                          Logical/Transport Layer Device ID and Control                                                          Capture CSRs. */
name|uint32_t
name|uns_tran
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of an unsupported transaction                                                          error.  Save and lock transaction capture                                                          information in Logical/Transport Layer Device ID                                                          and Control Capture CSRs. */
name|uint32_t
name|reserved_1_21
range|:
literal|21
decl_stmt|;
name|uint32_t
name|resp_sz
range|:
literal|1
decl_stmt|;
comment|/**< Enable reporting of an incoming response with                                                          unexpected data size */
else|#
directive|else
name|uint32_t
name|resp_sz
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_21
range|:
literal|21
decl_stmt|;
name|uint32_t
name|uns_tran
range|:
literal|1
decl_stmt|;
name|uint32_t
name|uns_resp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pkt_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg_tout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ill_tgt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ill_tran
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg_fmt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|gsm_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|io_err
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_lt_err_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_err_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_lt_err_en_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_lt_err_en
name|cvmx_sriomaintx_erb_lt_err_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_pack_capt_1  *  * SRIOMAINT_ERB_PACK_CAPT_1 = SRIO Packet Capture 1  *  * Packet Capture 1  *  * Notes:  * Error capture register 1 contains either long symbol capture information or bytes 4 through 7 of  *  the packet header.  *  The HW will not update this register (i.e. this register is locked) while  *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_CAPT_1       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_pack_capt_1
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_pack_capt_1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
comment|/**< Bytes 4 thru 7 of the packet header. */
else|#
directive|else
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_1_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_pack_capt_1
name|cvmx_sriomaintx_erb_pack_capt_1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_pack_capt_2  *  * SRIOMAINT_ERB_PACK_CAPT_2 = SRIO Packet Capture 2  *  * Packet Capture 2  *  * Notes:  * Error capture register 2 contains bytes 8 through 11 of the packet header.  *  The HW will not update this register (i.e. this register is locked) while  *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_CAPT_2       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_pack_capt_2
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_pack_capt_2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
comment|/**< Bytes 8 thru 11 of the packet header. */
else|#
directive|else
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_2_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_pack_capt_2
name|cvmx_sriomaintx_erb_pack_capt_2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_pack_capt_3  *  * SRIOMAINT_ERB_PACK_CAPT_3 = SRIO Packet Capture 3  *  * Packet Capture 3  *  * Notes:  * Error capture register 3 contains bytes 12 through 15 of the packet header.  *  The HW will not update this register (i.e. this register is locked) while  *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_CAPT_3       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_pack_capt_3
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_pack_capt_3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
comment|/**< Bytes 12 thru 15 of the packet header. */
else|#
directive|else
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_capt_3_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_pack_capt_3
name|cvmx_sriomaintx_erb_pack_capt_3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_erb_pack_sym_capt  *  * SRIOMAINT_ERB_PACK_SYM_CAPT = SRIO Packet/Control Symbol Capture  *  * Packet/Control Symbol Capture  *  * Notes:  * This register contains either captured control symbol information or the first 4 bytes of captured  *  packet information.  The Errors that generate Partial Control Symbols can be found in  *  SRIOMAINT*_ERB_ERR_DET.  The HW will not update this register (i.e. this register is locked) while  *  SRIOMAINT*_ERB_ATTR_CAPT[VALID] is set.  This register should only be read while this bit is set.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_ERB_PACK_SYM_CAPT     hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_erb_pack_sym_capt
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_erb_pack_sym_capt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
comment|/**< Control Character and Control Symbol or Bytes 0 to                                                          3 of Packet Header                                                          The Control Symbol consists of                                                            - 31:24 - SC Character (0 in Partial Symbol)                                                            - 23:21 - Stype 0                                                            - 20:16 - Parameter 0                                                            - 15:11 - Parameter 1                                                            - 10: 8 - Stype 1 (0 in Partial Symbol)                                                            - 7: 5 - Command (0 in Partial Symbol)                                                            - 4: 0 - CRC5    (0 in Partial Symbol) */
else|#
directive|else
name|uint32_t
name|capture
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_erb_pack_sym_capt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_sym_capt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_erb_pack_sym_capt_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_erb_pack_sym_capt
name|cvmx_sriomaintx_erb_pack_sym_capt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_hb_dev_id_lock  *  * SRIOMAINT_HB_DEV_ID_LOCK = SRIO Host Device ID Lock  *  * The Host Base Device ID  *  * Notes:  * This register contains the Device ID of the Host responsible for initializing this SRIO device.  *  The register contains a special write once function that captures the first HOSTID written to it  *  after reset.  The function allows several potential hosts to write to this register and then read  *  it to see if they have responsibility for initialization.  The register can be unlocked by  *  rewriting the current host value.  This will reset the lock and restore the value to 0xFFFF.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_HB_DEV_ID_LOCK        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_hb_dev_id_lock
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_hb_dev_id_lock_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|hostid
range|:
literal|16
decl_stmt|;
comment|/**< Primary 16-bit Device ID */
else|#
directive|else
name|uint32_t
name|hostid
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_hb_dev_id_lock_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_hb_dev_id_lock_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_hb_dev_id_lock_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_hb_dev_id_lock
name|cvmx_sriomaintx_hb_dev_id_lock_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_buffer_config  *  * SRIOMAINT_IR_BUFFER_CONFIG = SRIO Buffer Configuration  *  * Buffer Configuration  *  * Notes:  * This register controls the operation of the SRIO Core buffer mux logic.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG      hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_buffer_config
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_buffer_config_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|tx_wm0
range|:
literal|4
decl_stmt|;
comment|/**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
name|uint32_t
name|tx_wm1
range|:
literal|4
decl_stmt|;
comment|/**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
name|uint32_t
name|tx_wm2
range|:
literal|4
decl_stmt|;
comment|/**< Reserved. (See SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2) */
name|uint32_t
name|reserved_3_19
range|:
literal|17
decl_stmt|;
name|uint32_t
name|tx_flow
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether Transmitter Flow Control is                                                          permitted on this device.                                                            0 - Disabled                                                            1 - Permitted                                                          The reset value of this field is                                                          SRIO*_IP_FEATURE[TX_FLOW]. */
name|uint32_t
name|tx_sync
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint32_t
name|rx_sync
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
else|#
directive|else
name|uint32_t
name|rx_sync
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tx_sync
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tx_flow
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_3_19
range|:
literal|17
decl_stmt|;
name|uint32_t
name|tx_wm2
range|:
literal|4
decl_stmt|;
name|uint32_t
name|tx_wm1
range|:
literal|4
decl_stmt|;
name|uint32_t
name|tx_wm0
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_buffer_config_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_buffer_config_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_buffer_config_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_buffer_config
name|cvmx_sriomaintx_ir_buffer_config_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_buffer_config2  *  * SRIOMAINT_IR_BUFFER_CONFIG2 = SRIO Buffer Configuration 2  *  * Buffer Configuration 2  *  * Notes:  * This register controls the RX and TX Buffer availablility by priority.  The typical values are  *  optimized for normal operation.  Care must be taken when changing these values to avoid values  *  which can result in deadlocks.  Disabling a priority is not recommended and can result in system  *  level failures.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_BUFFER_CONFIG2     hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_buffer_config2
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_buffer_config2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|tx_wm3
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 3 packet                                                          will be transmitted.  A value of 9 will disable                                                          this priority. */
name|uint32_t
name|tx_wm2
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 2 packet                                                          will be transmitted.  A value of 9 will disable                                                          this priority. */
name|uint32_t
name|tx_wm1
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 1 packet                                                          will be transmitted.  A value of 9 will disable                                                          this priority. */
name|uint32_t
name|tx_wm0
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 0 packet                                                          will be transmitted.  A value of 9 will disable                                                          this priority. */
name|uint32_t
name|rx_wm3
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 3 packet                                                          will be accepted.  A value of 9 will disable this                                                          priority and always cause a physical layer RETRY. */
name|uint32_t
name|rx_wm2
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 2 packet                                                          will be accepted.  A value of 9 will disable this                                                          priority and always cause a physical layer RETRY. */
name|uint32_t
name|rx_wm1
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 1 packet                                                          will be accepted.  A value of 9 will disable this                                                          priority and always cause a physical layer RETRY. */
name|uint32_t
name|rx_wm0
range|:
literal|4
decl_stmt|;
comment|/**< Number of buffers free before a priority 0 packet                                                          will be accepted.  A value of 9 will disable this                                                          priority and always cause a physical layer RETRY. */
else|#
directive|else
name|uint32_t
name|rx_wm0
range|:
literal|4
decl_stmt|;
name|uint32_t
name|rx_wm1
range|:
literal|4
decl_stmt|;
name|uint32_t
name|rx_wm2
range|:
literal|4
decl_stmt|;
name|uint32_t
name|rx_wm3
range|:
literal|4
decl_stmt|;
name|uint32_t
name|tx_wm0
range|:
literal|4
decl_stmt|;
name|uint32_t
name|tx_wm1
range|:
literal|4
decl_stmt|;
name|uint32_t
name|tx_wm2
range|:
literal|4
decl_stmt|;
name|uint32_t
name|tx_wm3
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_buffer_config2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_buffer_config2_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_buffer_config2
name|cvmx_sriomaintx_ir_buffer_config2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_pd_phy_ctrl  *  * SRIOMAINT_IR_PD_PHY_CTRL = SRIO Platform Dependent PHY Control  *  * Platform Dependent PHY Control  *  * Notes:  * This register can be used for testing.  The register is otherwise unused by the hardware.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PD_PHY_CTRL        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_pd_phy_ctrl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_pd_phy_ctrl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|pd_ctrl
range|:
literal|32
decl_stmt|;
comment|/**< Unused Register available for testing */
else|#
directive|else
name|uint32_t
name|pd_ctrl
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_pd_phy_ctrl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_pd_phy_ctrl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_pd_phy_ctrl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_pd_phy_ctrl
name|cvmx_sriomaintx_ir_pd_phy_ctrl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_pd_phy_stat  *  * SRIOMAINT_IR_PD_PHY_STAT = SRIO Platform Dependent PHY Status  *  * Platform Dependent PHY Status  *  * Notes:  * This register is used to monitor PHY status on each lane.  They are documented here to assist in  *  debugging only.  The lane numbers take into account the lane swap pin.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PD_PHY_STAT        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_pd_phy_stat
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_pd_phy_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|ln3_rx
range|:
literal|3
decl_stmt|;
comment|/**< Phy Lane 3 RX Status                                                          0XX = Normal Operation                                                          100 = 8B/10B Error                                                          101 = Elastic Buffer Overflow (Data Lost)                                                          110 = Elastic Buffer Underflow (Data Corrupted)                                                          111 = Disparity Error */
name|uint32_t
name|ln3_dis
range|:
literal|1
decl_stmt|;
comment|/**< Lane 3 Phy Clock Disabled                                                          0 = Phy Clock Valid                                                          1 = Phy Clock InValid */
name|uint32_t
name|ln2_rx
range|:
literal|3
decl_stmt|;
comment|/**< Phy Lane 2 RX Status                                                          0XX = Normal Operation                                                          100 = 8B/10B Error                                                          101 = Elastic Buffer Overflow (Data Lost)                                                          110 = Elastic Buffer Underflow (Data Corrupted)                                                          111 = Disparity Error */
name|uint32_t
name|ln2_dis
range|:
literal|1
decl_stmt|;
comment|/**< Lane 2 Phy Clock Disabled                                                          0 = Phy Clock Valid                                                          1 = Phy Clock InValid */
name|uint32_t
name|ln1_rx
range|:
literal|3
decl_stmt|;
comment|/**< Phy Lane 1 RX Status                                                          0XX = Normal Operation                                                          100 = 8B/10B Error                                                          101 = Elastic Buffer Overflow (Data Lost)                                                          110 = Elastic Buffer Underflow (Data Corrupted)                                                          111 = Disparity Error */
name|uint32_t
name|ln1_dis
range|:
literal|1
decl_stmt|;
comment|/**< Lane 1 Phy Clock Disabled                                                          0 = Phy Clock Valid                                                          1 = Phy Clock InValid */
name|uint32_t
name|ln0_rx
range|:
literal|3
decl_stmt|;
comment|/**< Phy Lane 0 RX Status                                                          0XX = Normal Operation                                                          100 = 8B/10B Error                                                          101 = Elastic Buffer Overflow (Data Lost)                                                          110 = Elastic Buffer Underflow (Data Corrupted)                                                          111 = Disparity Error */
name|uint32_t
name|ln0_dis
range|:
literal|1
decl_stmt|;
comment|/**< Lane 0 Phy Clock Disabled                                                          0 = Phy Clock Valid                                                          1 = Phy Clock InValid */
else|#
directive|else
name|uint32_t
name|ln0_dis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ln0_rx
range|:
literal|3
decl_stmt|;
name|uint32_t
name|ln1_dis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ln1_rx
range|:
literal|3
decl_stmt|;
name|uint32_t
name|ln2_dis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ln2_rx
range|:
literal|3
decl_stmt|;
name|uint32_t
name|ln3_dis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ln3_rx
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_pd_phy_stat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_pd_phy_stat_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_pd_phy_stat_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_pd_phy_stat
name|cvmx_sriomaintx_ir_pd_phy_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_pi_phy_ctrl  *  * SRIOMAINT_IR_PI_PHY_CTRL = SRIO Platform Independent PHY Control  *  * Platform Independent PHY Control  *  * Notes:  * This register is used to control platform independent operating modes of the transceivers. These  *  control bits are uniform across all platforms.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PI_PHY_CTRL        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_pi_phy_ctrl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_pi_phy_ctrl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|tx_reset
range|:
literal|1
decl_stmt|;
comment|/**< Outgoing PHY Logic Reset.  0=Reset, 1=Normal Op */
name|uint32_t
name|rx_reset
range|:
literal|1
decl_stmt|;
comment|/**< Incoming PHY Logic Reset.  0=Reset, 1=Normal Op */
name|uint32_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint32_t
name|loopback
range|:
literal|2
decl_stmt|;
comment|/**< These bits control the state of the loopback                                                          control vector on the transceiver interface.  The                                                          loopback modes are enumerated as follows:                                                            00 - No Loopback                                                            01 - Near End PCS Loopback                                                            10 - Far End PCS Loopback                                                            11 - Both Near and Far End PCS Loopback */
name|uint32_t
name|reserved_0_26
range|:
literal|27
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_26
range|:
literal|27
decl_stmt|;
name|uint32_t
name|loopback
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_29_29
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_reset
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tx_reset
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_pi_phy_ctrl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_pi_phy_ctrl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_pi_phy_ctrl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_pi_phy_ctrl
name|cvmx_sriomaintx_ir_pi_phy_ctrl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_pi_phy_stat  *  * SRIOMAINT_IR_PI_PHY_STAT = SRIO Platform Independent PHY Status  *  * Platform Independent PHY Status  *  * Notes:  * This register displays the status of the link initialization state machine.  Changes to this state  *  cause the SRIO(0,2..3)_INT_REG.LINK_UP or SRIO(0,2..3)_INT_REG.LINK_DOWN interrupts.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_PI_PHY_STAT        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_pi_phy_stat
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_pi_phy_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_12_31
range|:
literal|20
decl_stmt|;
name|uint32_t
name|tx_rdy
range|:
literal|1
decl_stmt|;
comment|/**< Minimum number of Status Transmitted */
name|uint32_t
name|rx_rdy
range|:
literal|1
decl_stmt|;
comment|/**< Minimum number of Good Status Received */
name|uint32_t
name|init_sm
range|:
literal|10
decl_stmt|;
comment|/**< Initialization State Machine                                                          001 - Silent                                                          002 - Seek                                                          004 - Discovery                                                          008 - 1x_Mode_Lane0                                                          010 - 1x_Mode_Lane1                                                          020 - 1x_Mode_Lane2                                                          040 - 1x_Recovery                                                          080 - 2x_Mode                                                          100 - 2x_Recovery                                                          200 - 4x_Mode                                                          All others are reserved */
else|#
directive|else
name|uint32_t
name|init_sm
range|:
literal|10
decl_stmt|;
name|uint32_t
name|rx_rdy
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tx_rdy
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_12_31
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_pi_phy_stat_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_pi_phy_stat_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint32_t
name|init_sm
range|:
literal|10
decl_stmt|;
comment|/**< Initialization State Machine                                                          001 - Silent                                                          002 - Seek                                                          004 - Discovery                                                          008 - 1x_Mode_Lane0                                                          010 - 1x_Mode_Lane1                                                          020 - 1x_Mode_Lane2                                                          040 - 1x_Recovery                                                          080 - 2x_Mode                                                          100 - 2x_Recovery                                                          200 - 4x_Mode                                                          All others are reserved */
else|#
directive|else
name|uint32_t
name|init_sm
range|:
literal|10
decl_stmt|;
name|uint32_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_sriomaintx_ir_pi_phy_stat_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_pi_phy_stat
name|cvmx_sriomaintx_ir_pi_phy_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_sp_rx_ctrl  *  * SRIOMAINT_IR_SP_RX_CTRL = SRIO Soft Packet FIFO Receive Control  *  * Soft Packet FIFO Receive Control  *  * Notes:  * This register is used to configure events generated by the reception of packets using the soft  * packet FIFO.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_RX_CTRL hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_sp_rx_ctrl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_sp_rx_ctrl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_1_31
range|:
literal|31
decl_stmt|;
name|uint32_t
name|overwrt
range|:
literal|1
decl_stmt|;
comment|/**< When clear, SRIO drops received packets that should                                                          enter the soft packet FIFO when the FIFO is full.                                                          In this case, SRIO also increments                                                          SRIOMAINT(0,2..3)_IR_SP_RX_STAT.DROP_CNT. When set, SRIO                                                          stalls received packets that should enter the soft                                                          packet FIFO when the FIFO is full. SRIO may stop                                                          receiving any packets in this stall case if                                                          software does not drain the receive soft packet                                                          FIFO. */
else|#
directive|else
name|uint32_t
name|overwrt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_1_31
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_ctrl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_ctrl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_ctrl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_sp_rx_ctrl
name|cvmx_sriomaintx_ir_sp_rx_ctrl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_sp_rx_data  *  * SRIOMAINT_IR_SP_RX_DATA = SRIO Soft Packet FIFO Receive Data  *  * Soft Packet FIFO Receive Data  *  * Notes:  * This register is used to read data from the soft packet FIFO.  The Soft Packet FIFO contains the  *  majority of the packet data received from the SRIO link.  The packet does not include the Control  *  Symbols or the initial byte containing AckId, 2 Reserved Bits and the CRF.  In the case of packets  *  with less than 80 bytes (including AckId byte) both the trailing CRC and Pad (if present) are  *  included in the FIFO and Octet Count.  In the case of a packet with exactly 80 bytes (including  *  the AckId byte) the CRC is removed and the Pad is maintained so the Octet Count will read 81 bytes  *  instead of the expected 83.  In cases over 80 bytes the CRC at 80 bytes is removed but the  *  trailing CRC and Pad (if necessary) are present.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_RX_DATA hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_sp_rx_data
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_sp_rx_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|pkt_data
range|:
literal|32
decl_stmt|;
comment|/**< This register is used to read packet data from the                                                          RX FIFO. */
else|#
directive|else
name|uint32_t
name|pkt_data
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_data_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_data_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_data_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_sp_rx_data
name|cvmx_sriomaintx_ir_sp_rx_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_sp_rx_stat  *  * SRIOMAINT_IR_SP_RX_STAT = SRIO Soft Packet FIFO Receive Status  *  * Soft Packet FIFO Receive Status  *  * Notes:  * This register is used to monitor the reception of packets using the soft packet FIFO.  *  The HW sets SRIO_INT_REG[SOFT_RX] every time a packet arrives in the soft packet FIFO. To read  *  out (one or more) packets, the following procedure may be best:  *       (1) clear SRIO_INT_REG[SOFT_RX],  *       (2) read this CSR to determine how many packets there are,  *       (3) read the packets out (via SRIOMAINT*_IR_SP_RX_DATA).  *  This procedure could lead to situations where SOFT_RX will be set even though there are currently  *  no packets - the SW interrupt handler would need to properly handle this case  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_RX_STAT hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_sp_rx_stat
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_sp_rx_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
comment|/**< This field shows how many octets are remaining                                                          in the current packet in the RX FIFO. */
name|uint32_t
name|buffers
range|:
literal|4
decl_stmt|;
comment|/**< This field indicates how many complete packets are                                                          stored in the Rx FIFO. */
name|uint32_t
name|drop_cnt
range|:
literal|7
decl_stmt|;
comment|/**< Number of Packets Received when the RX FIFO was                                                          full and then discarded. */
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the value of Buffers Filled                                                          equals the number of available reception buffers. */
name|uint32_t
name|fifo_st
range|:
literal|4
decl_stmt|;
comment|/**< These bits display the state of the state machine                                                          that controls loading of packet data into the RX                                                          FIFO. The enumeration of states are as follows:                                                            0000 - Idle                                                            0001 - Armed                                                            0010 - Active                                                            All other states are reserved. */
else|#
directive|else
name|uint32_t
name|fifo_st
range|:
literal|4
decl_stmt|;
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
name|uint32_t
name|drop_cnt
range|:
literal|7
decl_stmt|;
name|uint32_t
name|buffers
range|:
literal|4
decl_stmt|;
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_stat_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_sp_rx_stat_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
comment|/**< This field shows how many octets are remaining                                                          in the current packet in the RX FIFO. */
name|uint32_t
name|buffers
range|:
literal|4
decl_stmt|;
comment|/**< This field indicates how many complete packets are                                                          stored in the Rx FIFO. */
name|uint32_t
name|reserved_5_11
range|:
literal|7
decl_stmt|;
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the value of Buffers Filled                                                          equals the number of available reception buffers.                                                          This bit always reads zero in Pass 1 */
name|uint32_t
name|fifo_st
range|:
literal|4
decl_stmt|;
comment|/**< These bits display the state of the state machine                                                          that controls loading of packet data into the RX                                                          FIFO. The enumeration of states are as follows:                                                            0000 - Idle                                                            0001 - Armed                                                            0010 - Active                                                            All other states are reserved. */
else|#
directive|else
name|uint32_t
name|fifo_st
range|:
literal|4
decl_stmt|;
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_11
range|:
literal|7
decl_stmt|;
name|uint32_t
name|buffers
range|:
literal|4
decl_stmt|;
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_sriomaintx_ir_sp_rx_stat_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_sp_rx_stat
name|cvmx_sriomaintx_ir_sp_rx_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_sp_tx_ctrl  *  * SRIOMAINT_IR_SP_TX_CTRL = SRIO Soft Packet FIFO Transmit Control  *  * Soft Packet FIFO Transmit Control  *  * Notes:  * This register is used to configure and control the transmission of packets using the soft packet  *  FIFO.  *  * Clk_Rst:        SRIOMAINT_IR_SP_TX_CTRL hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_sp_tx_ctrl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_sp_tx_ctrl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
comment|/**< Writing a non-zero value (N) to this field arms                                                          the packet FIFO for packet transmission. The FIFO                                                          control logic will transmit the next N bytes                                                          written 4-bytes at a time to the                                                          SRIOMAINT(0,2..3)_IR_SP_TX_DATA Register and create a                                                          single RapidIO packet. */
name|uint32_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_ctrl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_ctrl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_ctrl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_sp_tx_ctrl
name|cvmx_sriomaintx_ir_sp_tx_ctrl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_sp_tx_data  *  * SRIOMAINT_IR_SP_TX_DATA = SRIO Soft Packet FIFO Transmit Data  *  * Soft Packet FIFO Transmit Data  *  * Notes:  * This register is used to write data to the soft packet FIFO.  The format of the packet follows the  * Internal Packet Format (add link here).  Care must be taken on creating TIDs for the packets which  * generate a response.  Bits [7:6] of the 8 bit TID must be set for all Soft Packet FIFO generated  * packets.  TID values of 0x00 - 0xBF are reserved for hardware generated Tags.  The remainer of the  * TID[5:0] must be unique for each packet in flight and cannot be reused until a response is received  * in the SRIOMAINT(0,2..3)_IR_SP_RX_DATA register.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_TX_DATA hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_sp_tx_data
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_sp_tx_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|pkt_data
range|:
literal|32
decl_stmt|;
comment|/**< This register is used to write packet data to the                                                          Tx FIFO. Reads of this register will return zero. */
else|#
directive|else
name|uint32_t
name|pkt_data
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_data_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_data_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_data_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_sp_tx_data
name|cvmx_sriomaintx_ir_sp_tx_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_ir_sp_tx_stat  *  * SRIOMAINT_IR_SP_TX_STAT = SRIO Soft Packet FIFO Transmit Status  *  * Soft Packet FIFO Transmit Status  *  * Notes:  * This register is used to monitor the transmission of packets using the soft packet FIFO.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_IR_SP_TX_STAT hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_ir_sp_tx_stat
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_ir_sp_tx_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
comment|/**< This field shows how many octets are still to be                                                          loaded in the current packet. */
name|uint32_t
name|buffers
range|:
literal|4
decl_stmt|;
comment|/**< This field indicates how many complete packets are                                                          stored in the Tx FIFO.  The field always reads                                                          zero in the current hardware. */
name|uint32_t
name|reserved_5_11
range|:
literal|7
decl_stmt|;
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
comment|/**< This bit is set when the value of Buffers Filled                                                          equals the number of available transmission                                                          buffers. */
name|uint32_t
name|fifo_st
range|:
literal|4
decl_stmt|;
comment|/**< These bits display the state of the state machine                                                          that controls loading of packet data into the TX                                                          FIFO. The enumeration of states are as follows:                                                            0000 - Idle                                                            0001 - Armed                                                            0010 - Active                                                            All other states are reserved. */
else|#
directive|else
name|uint32_t
name|fifo_st
range|:
literal|4
decl_stmt|;
name|uint32_t
name|full
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_11
range|:
literal|7
decl_stmt|;
name|uint32_t
name|buffers
range|:
literal|4
decl_stmt|;
name|uint32_t
name|octets
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_stat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_stat_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_ir_sp_tx_stat_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_ir_sp_tx_stat
name|cvmx_sriomaintx_ir_sp_tx_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_lane_#_status_0  *  * SRIOMAINT_LANE_X_STATUS_0 = SRIO Lane X Status 0  *  * SRIO Lane Status 0  *  * Notes:  * This register contains status information about the local lane transceiver.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_LANE_[0:3]_STATUS_0   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_lane_x_status_0
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_lane_x_status_0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|port
range|:
literal|8
decl_stmt|;
comment|/**< The number of the port within the device to which                                                          the lane is assigned. */
name|uint32_t
name|lane
range|:
literal|4
decl_stmt|;
comment|/**< Lane Number within the port. */
name|uint32_t
name|tx_type
range|:
literal|1
decl_stmt|;
comment|/**< Transmitter Type                                                          0 = Short Run                                                          1 = Long Run */
name|uint32_t
name|tx_mode
range|:
literal|1
decl_stmt|;
comment|/**< Transmitter Operating Mode                                                          0 = Short Run                                                          1 = Long Run */
name|uint32_t
name|rx_type
range|:
literal|2
decl_stmt|;
comment|/**< Receiver Type                                                          0 = Short Run                                                          1 = Medium Run                                                          2 = Long Run                                                          3 = Reserved */
name|uint32_t
name|rx_inv
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Input Inverted                                                          0 = No Inversion                                                          1 = Input Inverted */
name|uint32_t
name|rx_adapt
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Trained                                                          0 = One or more adaptive equalizers are                                                              controlled by the lane receiver and at least                                                              one is not trained.                                                          1 = The lane receiver controls no adaptive                                                              equalizers or all the equalizers are trained. */
name|uint32_t
name|rx_sync
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Lane Sync'd */
name|uint32_t
name|rx_train
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Lane Trained */
name|uint32_t
name|dec_err
range|:
literal|4
decl_stmt|;
comment|/**< 8Bit/10Bit Decoding Errors                                                          0    = No Errors since last read                                                          1-14 = Number of Errors since last read                                                          15   = Fifteen or more Errors since last read */
name|uint32_t
name|xsync
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Lane Sync Change                                                          0 = Lane Sync has not changed since last read                                                          1 = Lane Sync has changed since last read */
name|uint32_t
name|xtrain
range|:
literal|1
decl_stmt|;
comment|/**< Receiver Training Change                                                          0 = Training has not changed since last read                                                          1 = Training has changed since last read */
name|uint32_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint32_t
name|status1
range|:
literal|1
decl_stmt|;
comment|/**< Status 1 CSR Implemented */
name|uint32_t
name|statusn
range|:
literal|3
decl_stmt|;
comment|/**< Status 2-7 Not Implemented */
else|#
directive|else
name|uint32_t
name|statusn
range|:
literal|3
decl_stmt|;
name|uint32_t
name|status1
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint32_t
name|xtrain
range|:
literal|1
decl_stmt|;
name|uint32_t
name|xsync
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dec_err
range|:
literal|4
decl_stmt|;
name|uint32_t
name|rx_train
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_sync
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_adapt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_inv
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_type
range|:
literal|2
decl_stmt|;
name|uint32_t
name|tx_mode
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tx_type
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lane
range|:
literal|4
decl_stmt|;
name|uint32_t
name|port
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_lane_x_status_0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_lane_x_status_0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_lane_x_status_0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_lane_x_status_0
name|cvmx_sriomaintx_lane_x_status_0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_lcs_ba0  *  * SRIOMAINT_LCS_BA0 = SRIO Local Configuration Space MSB Base Address  *  * MSBs of SRIO Address Space mapped to Maintenance BAR.  *  * Notes:  * The double word aligned SRIO address window mapped to the SRIO Maintenance BAR.  This window has  *  the highest priority and eclipses matches to the BAR0, BAR1 and BAR2 windows.  Note:  Address bits  *  not supplied in the transfer are considered zero.  For example, SRIO Address 65:35 must be set to  *  zero to match in a 34-bit access.  SRIO Address 65:50 must be set to zero to match in a 50-bit  *  access.  This coding allows the Maintenance Bar window to appear in specific address spaces. The  *  remaining bits are located in SRIOMAINT(0,2..3)_LCS_BA1. This SRIO maintenance BAR is effectively  *  disabled when LCSBA[30] is set with 34 or 50-bit addressing.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_LCS_BA0       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_lcs_ba0
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_lcs_ba0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lcsba
range|:
literal|31
decl_stmt|;
comment|/**< SRIO Address 65:35 */
else|#
directive|else
name|uint32_t
name|lcsba
range|:
literal|31
decl_stmt|;
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_lcs_ba0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_lcs_ba0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_lcs_ba0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_lcs_ba0
name|cvmx_sriomaintx_lcs_ba0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_lcs_ba1  *  * SRIOMAINT_LCS_BA1 = SRIO Local Configuration Space LSB Base Address  *  * LSBs of SRIO Address Space mapped to Maintenance BAR.  *  * Notes:  * The double word aligned SRIO address window mapped to the SRIO Maintenance BAR.  This window has  *  the highest priority and eclipses matches to the BAR0, BAR1 and BAR2 windows. Address bits not  *  supplied in the transfer are considered zero.  For example, SRIO Address 65:35 must be set to zero  *  to match in a 34-bit access and SRIO Address 65:50 must be set to zero to match in a 50-bit access.  *  This coding allows the Maintenance Bar window to appear in specific address spaces. Accesses  *  through this BAR are limited to single word (32-bit) aligned transfers of one to four bytes.  *  Accesses which violate this rule will return an error response if possible and be otherwise  *  ignored.  The remaining bits are located in SRIOMAINT(0,2..3)_LCS_BA0.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_LCS_BA1       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_lcs_ba1
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_lcs_ba1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|lcsba
range|:
literal|11
decl_stmt|;
comment|/**< SRIO Address 34:24 */
name|uint32_t
name|reserved_0_20
range|:
literal|21
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_20
range|:
literal|21
decl_stmt|;
name|uint32_t
name|lcsba
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_lcs_ba1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_lcs_ba1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_lcs_ba1_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_lcs_ba1
name|cvmx_sriomaintx_lcs_ba1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_m2s_bar0_start0  *  * SRIOMAINT_M2S_BAR0_START0 = SRIO Device Access BAR0 MSB Start  *  * The starting SRIO address to forwarded to the NPEI Configuration Space.  *  * Notes:  * This register specifies the 50-bit and 66-bit SRIO Address mapped to the BAR0 Space.  See  *  SRIOMAINT(0,2..3)_M2S_BAR0_START1 for more details. This register is only writeable over SRIO if the  *  SRIO(0,2..3)_ACC_CTRL.DENY_BAR0 bit is zero.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR0_START0       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_m2s_bar0_start0
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_m2s_bar0_start0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr64
range|:
literal|16
decl_stmt|;
comment|/**< SRIO Address 63:48 */
name|uint32_t
name|addr48
range|:
literal|16
decl_stmt|;
comment|/**< SRIO Address 47:32 */
else|#
directive|else
name|uint32_t
name|addr48
range|:
literal|16
decl_stmt|;
name|uint32_t
name|addr64
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_m2s_bar0_start0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar0_start0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar0_start0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_m2s_bar0_start0
name|cvmx_sriomaintx_m2s_bar0_start0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_m2s_bar0_start1  *  * SRIOMAINT_M2S_BAR0_START1 = SRIO Device Access BAR0 LSB Start  *  * The starting SRIO address to forwarded to the NPEI Configuration Space.  *  * Notes:  * This register specifies the SRIO Address mapped to the BAR0 RSL Space.  If the transaction has not  *  already been mapped to SRIO Maintenance Space through the SRIOMAINT_LCS_BA[1:0] registers, if  *  ENABLE is set and the address bits match then the SRIO Memory transactions will map to Octeon SLI  *  Registers.  34-bit address transactions require a match in SRIO Address 33:14 and require all the  *  other bits in ADDR48, ADDR64 and ADDR66 fields to be zero.  50-bit address transactions a match of  *  SRIO Address 49:14 and require all the other bits of ADDR64 and ADDR66 to be zero.  66-bit address  *  transactions require matches of all valid address field bits.  Reads and  Writes through Bar0  *  have a size limit of 8 bytes and cannot cross a 64-bit boundry.  All accesses with sizes greater  *  than this limit will be ignored and return an error on any SRIO responses.  Note: ADDR48 and  *  ADDR64 fields are located in SRIOMAINT(0,2..3)_M2S_BAR0_START0.  The ADDR32/66 fields of this register  *  are writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_ADR0 bit is zero.  The ENABLE field is  *  writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_BAR0 bit is zero.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR0_START1       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_m2s_bar0_start1
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_m2s_bar0_start1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr32
range|:
literal|18
decl_stmt|;
comment|/**< SRIO Address 31:14 */
name|uint32_t
name|reserved_3_13
range|:
literal|11
decl_stmt|;
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
comment|/**< SRIO Address 65:64 */
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Enable BAR0 Access */
else|#
directive|else
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_3_13
range|:
literal|11
decl_stmt|;
name|uint32_t
name|addr32
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_m2s_bar0_start1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar0_start1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar0_start1_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_m2s_bar0_start1
name|cvmx_sriomaintx_m2s_bar0_start1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_m2s_bar1_start0  *  * SRIOMAINT_M2S_BAR1_START0 = SRIO Device Access BAR1 MSB Start  *  * The starting SRIO address to forwarded to the BAR1 Memory Space.  *  * Notes:  * This register specifies the 50-bit and 66-bit SRIO Address mapped to the BAR1 Space.  See  *  SRIOMAINT(0,2..3)_M2S_BAR1_START1 for more details.  This register is only writeable over SRIO if the  *  SRIO(0,2..3)_ACC_CTRL.DENY_ADR1 bit is zero.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR1_START0       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_m2s_bar1_start0
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_m2s_bar1_start0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr64
range|:
literal|16
decl_stmt|;
comment|/**< SRIO Address 63:48 */
name|uint32_t
name|addr48
range|:
literal|16
decl_stmt|;
comment|/**< SRIO Address 47:32                                                          The SRIO hardware does not use the low order                                                          one or two bits of this field when BARSIZE is 12                                                          or 13, respectively.                                                          (BARSIZE is SRIOMAINT(0,2..3)_M2S_BAR1_START1[BARSIZE].) */
else|#
directive|else
name|uint32_t
name|addr48
range|:
literal|16
decl_stmt|;
name|uint32_t
name|addr64
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_m2s_bar1_start0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar1_start0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar1_start0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_m2s_bar1_start0
name|cvmx_sriomaintx_m2s_bar1_start0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_m2s_bar1_start1  *  * SRIOMAINT_M2S_BAR1_START1 = SRIO Device to BAR1 Start  *  * The starting SRIO address to forwarded to the BAR1 Memory Space.  *  * Notes:  * This register specifies the SRIO Address mapped to the BAR1 Space.  If the transaction has not  *  already been mapped to SRIO Maintenance Space through the SRIOMAINT_LCS_BA[1:0] registers and the  *  address bits do not match enabled BAR0 addresses and if ENABLE is set and the addresses match the  *  BAR1 addresses then SRIO Memory transactions will map to Octeon Memory Space specified by  *  SRIOMAINT(0,2..3)_BAR1_IDX[31:0] registers.  The BARSIZE field determines the size of BAR1, the entry  *  select bits, and the size of each entry. A 34-bit address matches BAR1 when it matches  *  SRIO_Address[33:20+BARSIZE] while all the other bits in ADDR48, ADDR64 and ADDR66 are zero.  *  A 50-bit address matches BAR1 when it matches SRIO_Address[49:20+BARSIZE] while all the  *  other bits of ADDR64 and ADDR66 are zero.  A 66-bit address matches BAR1 when all of  *  SRIO_Address[65:20+BARSIZE] match all corresponding address CSR field bits.  Note: ADDR48 and  *  ADDR64 fields are located in SRIOMAINT(0,2..3)_M2S_BAR1_START0. The ADDR32/66 fields of this register  *  are writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_ADR1 bit is zero.  The remaining fields are  *  writeable over SRIO if the SRIO(0,2..3)_ACC_CTRL.DENY_BAR1 bit is zero.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR1_START1       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_m2s_bar1_start1
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_m2s_bar1_start1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr32
range|:
literal|12
decl_stmt|;
comment|/**< SRIO Address 31:20                                                          This field is not used by the SRIO hardware for                                                          BARSIZE values 12 or 13.                                                          With BARSIZE< 12, the upper 12-BARSIZE                                                          bits of this field are used, and the lower BARSIZE                                                          bits of this field are unused by the SRIO hardware. */
name|uint32_t
name|reserved_7_19
range|:
literal|13
decl_stmt|;
name|uint32_t
name|barsize
range|:
literal|4
decl_stmt|;
comment|/**< Bar Size.                                                                               SRIO_Address*                                                                          ---------------------                                                                         /                     \                                                          BARSIZE         BAR     Entry   Entry    Entry                                                          Value   BAR    compare  Select  Offset   Size                                                                  Size    bits    bits    bits                                                           0       1MB    65:20   19:16   15:0     64KB                                                           1       2MB    65:21   20:17   16:0    128KB                                                           2       4MB    65:22   21:18   17:0    256KB                                                           3       8MB    65:23   22:19   18:0    512KB                                                           4      16MB    65:24   23:20   19:0      1MB                                                           5      32MB    65:25   24:21   20:0      2MB                                                           6      64MB    65:26   25:22   21:0      4MB                                                           7     128MB    65:27   26:23   22:0      8MB                                                           8     256MB    65:28   27:24   23:0     16MB                                                           9     512MB    65:29   28:25   24:0     32MB                                                          10    1024MB    65:30   29:26   25:0     64MB                                                          11    2048MB    65:31   30:27   26:0    128MB                                                          12    4096MB    65:32   31:28   27:0    256MB                                                          13    8192MB    65:33   32:29   28:0    512MB                                                           *The SRIO Transaction Address                                                          The entry select bits is the X that  select an                                                          SRIOMAINT(0,2..3)_BAR1_IDXX entry. */
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
comment|/**< SRIO Address 65:64 */
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Enable BAR1 Access */
else|#
directive|else
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
name|uint32_t
name|barsize
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_7_19
range|:
literal|13
decl_stmt|;
name|uint32_t
name|addr32
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_m2s_bar1_start1_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_m2s_bar1_start1_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr32
range|:
literal|12
decl_stmt|;
comment|/**< SRIO Address 31:20                                                          With BARSIZE< 12, the upper 12-BARSIZE                                                          bits of this field are used, and the lower BARSIZE                                                          bits of this field are unused by the SRIO hardware. */
name|uint32_t
name|reserved_6_19
range|:
literal|14
decl_stmt|;
name|uint32_t
name|barsize
range|:
literal|3
decl_stmt|;
comment|/**< Bar Size.                                                                               SRIO_Address*                                                                          ---------------------                                                                         /                     \                                                          BARSIZE         BAR     Entry   Entry    Entry                                                          Value   BAR    compare  Select  Offset   Size                                                                  Size    bits    bits    bits                                                           0       1MB    65:20   19:16   15:0     64KB                                                           1       2MB    65:21   20:17   16:0    128KB                                                           2       4MB    65:22   21:18   17:0    256KB                                                           3       8MB    65:23   22:19   18:0    512KB                                                           4      16MB    65:24   23:20   19:0      1MB                                                           5      32MB    65:25   24:21   20:0      2MB                                                           6      64MB    65:26   25:22   21:0      4MB                                                           7     128MB    65:27   26:23   22:0      8MB                                                           8     256MB  ** not in pass 1                                                           9     512MB  ** not in pass 1                                                          10       1GB  ** not in pass 1                                                          11       2GB  ** not in pass 1                                                          12       4GB  ** not in pass 1                                                          13       8GB  ** not in pass 1                                                           *The SRIO Transaction Address                                                          The entry select bits is the X that  select an                                                          SRIOMAINT(0..1)_BAR1_IDXX entry.                                                           In O63 pass 2, BARSIZE is 4 bits (6:3 in this                                                          CSR), and BARSIZE values 8-13 are implemented,                                                          providing a total possible BAR1 size range from                                                          1MB up to 8GB. */
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
comment|/**< SRIO Address 65:64 */
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Enable BAR1 Access */
else|#
directive|else
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
name|uint32_t
name|barsize
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_6_19
range|:
literal|14
decl_stmt|;
name|uint32_t
name|addr32
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_sriomaintx_m2s_bar1_start1_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_m2s_bar1_start1
name|cvmx_sriomaintx_m2s_bar1_start1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_m2s_bar2_start  *  * SRIOMAINT_M2S_BAR2_START = SRIO Device to BAR2 Start  *  * The starting SRIO address to forwarded to the BAR2 Memory Space.  *  * Notes:  * This register specifies the SRIO Address mapped to the BAR2 Space.  If ENABLE is set and the  *  address bits do not match and other enabled BAR address and match the BAR2 addresses then the SRIO  *  Memory transactions will map to Octeon BAR2 Memory Space.  34-bit address transactions require  *  ADDR66, ADDR64 and ADDR48 fields set to zero and supplies zeros for unused addresses 40:34.  *  50-bit address transactions a match of SRIO Address 49:41 and require all the other bits of ADDR64  *  and ADDR66 to be zero.  66-bit address transactions require matches of all valid address field  *  bits.  The ADDR32/48/64/66 fields of this register are writeable over SRIO if the  *  SRIO(0,2..3)_ACC_CTRL.DENY_ADR2 bit is zero.  The remaining fields are writeable over SRIO if the  *  SRIO(0,2..3)_ACC_CTRL.DENY_BAR2 bit is zero.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_M2S_BAR2_START        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_m2s_bar2_start
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_m2s_bar2_start_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|addr64
range|:
literal|16
decl_stmt|;
comment|/**< SRIO Address 63:48 */
name|uint32_t
name|addr48
range|:
literal|7
decl_stmt|;
comment|/**< SRIO Address 47:41 */
name|uint32_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint32_t
name|esx
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode used for SRIO 34-bit access.                                                          For 50/66-bit assesses Endian Swap is determine                                                          by ESX XOR'd with SRIO Addr 39:38.                                                          0 = No Swap                                                          1 = 64-bit Swap Bytes [ABCD_EFGH] -> [HGFE_DCBA]                                                          2 = 32-bit Swap Words [ABCD_EFGH] -> [DCBA_HGFE]                                                          3 = 32-bit Word Exch  [ABCD_EFGH] -> [EFGH_ABCD] */
name|uint32_t
name|cax
range|:
literal|1
decl_stmt|;
comment|/**< Cacheable Access Mode.  When set transfer is                                                          cached.  This bit is used for SRIO 34-bit access.                                                          For 50/66-bit accessas NCA is determine by CAX                                                          XOR'd with SRIO Addr 40. */
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
comment|/**< SRIO Address 65:64 */
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Enable BAR2 Access */
else|#
directive|else
name|uint32_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|addr66
range|:
literal|2
decl_stmt|;
name|uint32_t
name|cax
range|:
literal|1
decl_stmt|;
name|uint32_t
name|esx
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint32_t
name|addr48
range|:
literal|7
decl_stmt|;
name|uint32_t
name|addr64
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_m2s_bar2_start_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar2_start_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_m2s_bar2_start_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_m2s_bar2_start
name|cvmx_sriomaintx_m2s_bar2_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_mac_ctrl  *  * SRIOMAINT_MAC_CTRL = SRIO MAC Control  *  * Control for MAC Features  *  * Notes:  * This register enables MAC optimizations that may not be supported by all SRIO devices.  The  *  default values should be supported.  This register can be changed at any time while the MAC is  *  out of reset.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_MAC_CTRL      hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_mac_ctrl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_mac_ctrl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint32_t
name|sec_spf
range|:
literal|1
decl_stmt|;
comment|/**< Send all Incoming Packets matching Secondary ID to                                                          RX Soft Packet FIFO.  This bit is ignored if                                                          RX_SPF is set. */
name|uint32_t
name|ack_zero
range|:
literal|1
decl_stmt|;
comment|/**< Generate ACKs for all incoming Zero Byte packets.                                                          Default behavior is to issue a NACK.  Regardless                                                          of this setting the SRIO(0,2..3)_INT_REG.ZERO_PKT                                                          interrupt is generated.                                                          SRIO(0,2..3)_INT_REG. */
name|uint32_t
name|rx_spf
range|:
literal|1
decl_stmt|;
comment|/**< Route all received packets to RX Soft Packet FIFO.                                                          No logical layer ERB Errors will be reported.                                                          Used for Diagnostics Only. */
name|uint32_t
name|eop_mrg
range|:
literal|1
decl_stmt|;
comment|/**< Transmitted Packets can eliminate EOP Symbol on                                                          back to back packets. */
name|uint32_t
name|type_mrg
range|:
literal|1
decl_stmt|;
comment|/**< Allow STYPE Merging on Transmit. */
name|uint32_t
name|lnk_rtry
range|:
literal|16
decl_stmt|;
comment|/**< Number of times MAC will reissue Link Request                                                          after timeout.  If retry count is exceeded Fatal                                                          Port Error will occur (see SRIO(0,2..3)_INT_REG.F_ERROR) */
else|#
directive|else
name|uint32_t
name|lnk_rtry
range|:
literal|16
decl_stmt|;
name|uint32_t
name|type_mrg
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eop_mrg
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_spf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ack_zero
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sec_spf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sriomaintx_mac_ctrl_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint32_t
name|ack_zero
range|:
literal|1
decl_stmt|;
comment|/**< Generate ACKs for all incoming Zero Byte packets.                                                          Default behavior is to issue a NACK.  Regardless                                                          of this setting the SRIO(0..1)_INT_REG.ZERO_PKT                                                          interrupt is generated.                                                          SRIO(0..1)_INT_REG. */
name|uint32_t
name|rx_spf
range|:
literal|1
decl_stmt|;
comment|/**< Route all received packets to RX Soft Packet FIFO.                                                          No logical layer ERB Errors will be reported.                                                          Used for Diagnostics Only. */
name|uint32_t
name|eop_mrg
range|:
literal|1
decl_stmt|;
comment|/**< Transmitted Packets can eliminate EOP Symbol on                                                          back to back packets. */
name|uint32_t
name|type_mrg
range|:
literal|1
decl_stmt|;
comment|/**< Allow STYPE Merging on Transmit. */
name|uint32_t
name|lnk_rtry
range|:
literal|16
decl_stmt|;
comment|/**< Number of times MAC will reissue Link Request                                                          after timeout.  If retry count is exceeded Fatal                                                          Port Error will occur (see SRIO(0..1)_INT_REG.F_ERROR) */
else|#
directive|else
name|uint32_t
name|lnk_rtry
range|:
literal|16
decl_stmt|;
name|uint32_t
name|type_mrg
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eop_mrg
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rx_spf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ack_zero
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_sriomaintx_mac_ctrl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_mac_ctrl
name|cvmx_sriomaintx_mac_ctrl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_pe_feat  *  * SRIOMAINT_PE_FEAT = SRIO Processing Element Features  *  * The Supported Processing Element Features.  *  * Notes:  * The Processing Element Feature register describes the major functionality provided by the SRIO  *  device.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PE_FEAT       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_pe_feat
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_pe_feat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|bridge
range|:
literal|1
decl_stmt|;
comment|/**< Bridge Functions not supported. */
name|uint32_t
name|memory
range|:
literal|1
decl_stmt|;
comment|/**< PE contains addressable memory. */
name|uint32_t
name|proc
range|:
literal|1
decl_stmt|;
comment|/**< PE contains a local processor. */
name|uint32_t
name|switchf
range|:
literal|1
decl_stmt|;
comment|/**< Switch Functions not supported. */
name|uint32_t
name|mult_prt
range|:
literal|1
decl_stmt|;
comment|/**< Multiport Functions not supported. */
name|uint32_t
name|reserved_7_26
range|:
literal|20
decl_stmt|;
name|uint32_t
name|suppress
range|:
literal|1
decl_stmt|;
comment|/**< Error Recovery Suppression not supported. */
name|uint32_t
name|crf
range|:
literal|1
decl_stmt|;
comment|/**< Critical Request Flow not supported. */
name|uint32_t
name|lg_tran
range|:
literal|1
decl_stmt|;
comment|/**< Large Transport (16-bit Device IDs) supported. */
name|uint32_t
name|ex_feat
range|:
literal|1
decl_stmt|;
comment|/**< Extended Feature Pointer is valid. */
name|uint32_t
name|ex_addr
range|:
literal|3
decl_stmt|;
comment|/**< PE supports 66, 50 and 34-bit addresses.                                                          [2:1] are a RO copy of SRIO*_IP_FEATURE[A66,A50]. */
else|#
directive|else
name|uint32_t
name|ex_addr
range|:
literal|3
decl_stmt|;
name|uint32_t
name|ex_feat
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lg_tran
range|:
literal|1
decl_stmt|;
name|uint32_t
name|crf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|suppress
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_7_26
range|:
literal|20
decl_stmt|;
name|uint32_t
name|mult_prt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|switchf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|proc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|memory
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bridge
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_pe_feat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_pe_feat_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_pe_feat_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_pe_feat
name|cvmx_sriomaintx_pe_feat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_pe_llc  *  * SRIOMAINT_PE_LLC = SRIO Processing Element Logical Layer Control  *  * Addresses supported by the SRIO Device.  *  * Notes:  * The Processing Element Logical Layer is used for general configuration for the logical interface.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PE_LLC        hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_pe_llc
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_pe_llc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
name|uint32_t
name|ex_addr
range|:
literal|3
decl_stmt|;
comment|/**< Controls the number of address bits generated by                                                          PE as a source and processed by the PE as a                                                          target of an operation.                                                           001 = 34-bit Addresses                                                           010 = 50-bit Addresses                                                           100 = 66-bit Addresses                                                           All other encodings are reserved. */
else|#
directive|else
name|uint32_t
name|ex_addr
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_pe_llc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_pe_llc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_pe_llc_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_pe_llc
name|cvmx_sriomaintx_pe_llc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_0_ctl  *  * SRIOMAINT_PORT_0_CTL = SRIO Port 0 Control  *  * Port 0 Control  *  * Notes:  * This register contains assorted control bits.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_CTL    hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_0_ctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_0_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|pt_width
range|:
literal|2
decl_stmt|;
comment|/**< Hardware Port Width.                                                          00 = One Lane supported.                                                          01 = One/Four Lanes supported.                                                          10 = One/Two Lanes supported.                                                          11 = One/Two/Four Lanes supported.                                                          This value is a copy of SRIO*_IP_FEATURE[PT_WIDTH]                                                          limited by the number of lanes the MAC has. */
name|uint32_t
name|it_width
range|:
literal|3
decl_stmt|;
comment|/**< Initialized Port Width                                                          000 = Single-lane, Lane 0                                                          001 = Single-lane, Lane 1 or 2                                                          010 = Four-lane                                                          011 = Two-lane                                                          111 = Link Uninitialized                                                          Others = Reserved */
name|uint32_t
name|ov_width
range|:
literal|3
decl_stmt|;
comment|/**< Override Port Width.  Writing this register causes                                                          the port to reinitialize.                                                          000 = No Override all lanes possible                                                          001 = Reserved                                                          010 = Force Single-lane, Lane 0                                                                If Ln 0 is unavailable try Ln 2 then Ln 1                                                          011 = Force Single-lane, Lane 2                                                                If Ln 2 is unavailable try Ln 1 then Ln 0                                                          100 = Reserved                                                          101 = Enable Two-lane, Disable Four-Lane                                                          110 = Enable Four-lane, Disable Two-Lane                                                          111 = All lanes sizes enabled */
name|uint32_t
name|disable
range|:
literal|1
decl_stmt|;
comment|/**< Port Disable.  Setting this bit disables both                                                          drivers and receivers. */
name|uint32_t
name|o_enable
range|:
literal|1
decl_stmt|;
comment|/**< Port Output Enable.  When cleared, port will                                                          generate control symbols and respond to                                                          maintenance transactions only.  When set, all                                                          transactions are allowed. */
name|uint32_t
name|i_enable
range|:
literal|1
decl_stmt|;
comment|/**< Port Input Enable.  When cleared, port will                                                          generate control symbols and respond to                                                          maintenance packets only.  All other packets will                                                          not be accepted. */
name|uint32_t
name|dis_err
range|:
literal|1
decl_stmt|;
comment|/**< Disable Error Checking.  Diagnostic Only. */
name|uint32_t
name|mcast
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint32_t
name|reserved_18_18
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enumb
range|:
literal|1
decl_stmt|;
comment|/**< Enumeration Boundry. SW can use this bit to                                                          determine port enumeration. */
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ex_width
range|:
literal|2
decl_stmt|;
comment|/**< Extended Port Width not supported. */
name|uint32_t
name|ex_stat
range|:
literal|2
decl_stmt|;
comment|/**< Extended Port Width Status. 00 = not supported */
name|uint32_t
name|suppress
range|:
literal|8
decl_stmt|;
comment|/**< Retransmit Suppression Mask.  CRF not Supported. */
name|uint32_t
name|stp_port
range|:
literal|1
decl_stmt|;
comment|/**< Stop on Failed Port.  This bit is used with the                                                          DROP_PKT bit to force certain behavior when the                                                          Error Rate Failed Threshold has been met or                                                          exceeded. */
name|uint32_t
name|drop_pkt
range|:
literal|1
decl_stmt|;
comment|/**< Drop on Failed Port.  This bit is used with the                                                          STP_PORT bit to force certain behavior when the                                                          Error Rate Failed Threshold has been met or                                                          exceeded. */
name|uint32_t
name|prt_lock
range|:
literal|1
decl_stmt|;
comment|/**< When this bit is cleared, the packets that may be                                                          received and issued are controlled by the state of                                                          the O_ENABLE and I_ENABLE bits.  When this bit is                                                          set, this port is stopped and is not enabled to                                                          issue or receive any packets; the input port can                                                          still follow the training procedure and can still                                                          send and respond to link-requests; all received                                                          packets return packet-not-accepted control symbols                                                          to force an error condition to be signaled by the                                                          sending device. */
name|uint32_t
name|pt_type
range|:
literal|1
decl_stmt|;
comment|/**< Port Type.  1 = Serial port. */
else|#
directive|else
name|uint32_t
name|pt_type
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prt_lock
range|:
literal|1
decl_stmt|;
name|uint32_t
name|drop_pkt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|stp_port
range|:
literal|1
decl_stmt|;
name|uint32_t
name|suppress
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ex_stat
range|:
literal|2
decl_stmt|;
name|uint32_t
name|ex_width
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enumb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_18_18
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mcast
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dis_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_enable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|o_enable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|disable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ov_width
range|:
literal|3
decl_stmt|;
name|uint32_t
name|it_width
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pt_width
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_0_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_0_ctl
name|cvmx_sriomaintx_port_0_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_0_ctl2  *  * SRIOMAINT_PORT_0_CTL2 = SRIO Port 0 Control 2  *  * Port 0 Control 2  *  * Notes:  * These registers are accessed when a local processor or an external device wishes to examine the  *  port baudrate information.  The Automatic Baud Rate Feature is not available on this device.  The  *  SUP_* and ENB_* fields are set directly by the QLM_SPD bits as a reference but otherwise have  *  no effect.  WARNING:  Writes to this register will reinitialize the SRIO link.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_CTL2   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_0_ctl2
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_0_ctl2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|sel_baud
range|:
literal|4
decl_stmt|;
comment|/**< Link Baud Rate Selected.                                                            0000 - No rate selected                                                            0001 - 1.25 GBaud                                                            0010 - 2.5 GBaud                                                            0011 - 3.125 GBaud                                                            0100 - 5.0 GBaud                                                            0101 - 6.25 GBaud (reserved)                                                            0110 - 0b1111 - Reserved                                                          Indicates the speed of the interface SERDES lanes                                                          (selected by the QLM*_SPD straps). */
name|uint32_t
name|baud_sup
range|:
literal|1
decl_stmt|;
comment|/**< Automatic Baud Rate Discovery not supported. */
name|uint32_t
name|baud_enb
range|:
literal|1
decl_stmt|;
comment|/**< Auto Baud Rate Discovery Enable. */
name|uint32_t
name|sup_125g
range|:
literal|1
decl_stmt|;
comment|/**< 1.25GB Rate Operation supported.                                                          Set when the interface SERDES lanes are operating                                                          at 1.25 Gbaud (as selected by QLM*_SPD straps). */
name|uint32_t
name|enb_125g
range|:
literal|1
decl_stmt|;
comment|/**< 1.25GB Rate Operation enable.                                                          Reset to 1 when the interface SERDES lanes are                                                          operating at 1.25 Gbaud (as selected by QLM*_SPD                                                          straps). Reset to 0 otherwise. */
name|uint32_t
name|sup_250g
range|:
literal|1
decl_stmt|;
comment|/**< 2.50GB Rate Operation supported.                                                          Set when the interface SERDES lanes are operating                                                          at 2.5 Gbaud (as selected by QLM*_SPD straps). */
name|uint32_t
name|enb_250g
range|:
literal|1
decl_stmt|;
comment|/**< 2.50GB Rate Operation enable.                                                          Reset to 1 when the interface SERDES lanes are                                                          operating at 2.5 Gbaud (as selected by QLM*_SPD                                                          straps). Reset to 0 otherwise. */
name|uint32_t
name|sup_312g
range|:
literal|1
decl_stmt|;
comment|/**< 3.125GB Rate Operation supported.                                                          Set when the interface SERDES lanes are operating                                                          at 3.125 Gbaud (as selected by QLM*_SPD straps). */
name|uint32_t
name|enb_312g
range|:
literal|1
decl_stmt|;
comment|/**< 3.125GB Rate Operation enable.                                                          Reset to 1 when the interface SERDES lanes are                                                          operating at 3.125 Gbaud (as selected by QLM*_SPD                                                          straps). Reset to 0 otherwise. */
name|uint32_t
name|sub_500g
range|:
literal|1
decl_stmt|;
comment|/**< 5.0GB Rate Operation supported.                                                          Set when the interface SERDES lanes are operating                                                          at 5.0 Gbaud (as selected by QLM*_SPD straps). */
name|uint32_t
name|enb_500g
range|:
literal|1
decl_stmt|;
comment|/**< 5.0GB Rate Operation enable.                                                          Reset to 1 when the interface SERDES lanes are                                                          operating at 5.0 Gbaud (as selected by QLM*_SPD                                                          straps). Reset to 0 otherwise. */
name|uint32_t
name|sup_625g
range|:
literal|1
decl_stmt|;
comment|/**< 6.25GB Rate Operation (not supported). */
name|uint32_t
name|enb_625g
range|:
literal|1
decl_stmt|;
comment|/**< 6.25GB Rate Operation enable. */
name|uint32_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint32_t
name|tx_emph
range|:
literal|1
decl_stmt|;
comment|/**< Indicates whether is port is able to transmit                                                          commands to control the transmit emphasis in the                                                          connected port. */
name|uint32_t
name|emph_en
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether a port may adjust the                                                          transmit emphasis in the connected port.  This bit                                                          should be cleared for normal operation. */
else|#
directive|else
name|uint32_t
name|emph_en
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tx_emph
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint32_t
name|enb_625g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sup_625g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enb_500g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sub_500g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enb_312g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sup_312g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enb_250g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sup_250g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enb_125g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sup_125g
range|:
literal|1
decl_stmt|;
name|uint32_t
name|baud_enb
range|:
literal|1
decl_stmt|;
name|uint32_t
name|baud_sup
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sel_baud
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_0_ctl2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_ctl2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_ctl2_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_0_ctl2
name|cvmx_sriomaintx_port_0_ctl2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_0_err_stat  *  * SRIOMAINT_PORT_0_ERR_STAT = SRIO Port 0 Error and Status  *  * Port 0 Error and Status  *  * Notes:  * This register displays port error and status information.  Several port error conditions are  *  captured here and must be cleared by writing 1's to the individual bits.  *  Bits are R/W on 65/66xx pass 1 and R/W1C on pass 1.2  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_ERR_STAT       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_0_err_stat
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_0_err_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint32_t
name|pkt_drop
range|:
literal|1
decl_stmt|;
comment|/**< Output Packet Dropped. */
name|uint32_t
name|o_fail
range|:
literal|1
decl_stmt|;
comment|/**< Output Port has encountered a failure condition,                                                          meaning the port's failed error threshold has                                                          reached SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR.ER_FAIL value. */
name|uint32_t
name|o_dgrad
range|:
literal|1
decl_stmt|;
comment|/**< Output Port has encountered a degraded condition,                                                          meaning the port's degraded threshold has                                                          reached SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR.ER_DGRAD                                                          value. */
name|uint32_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint32_t
name|o_retry
range|:
literal|1
decl_stmt|;
comment|/**< Output Retry Encountered.  This bit is set when                                                          bit 18 is set. */
name|uint32_t
name|o_rtried
range|:
literal|1
decl_stmt|;
comment|/**< Output Port has received a packet-retry condition                                                          and cannot make forward progress.  This bit is set                                                          when  bit 18 is set and is cleared when a packet-                                                          accepted or a packet-not-accepted control symbol                                                          is received. */
name|uint32_t
name|o_sm_ret
range|:
literal|1
decl_stmt|;
comment|/**< Output Port State Machine has received a                                                          packet-retry control symbol and is retrying the                                                          packet. */
name|uint32_t
name|o_error
range|:
literal|1
decl_stmt|;
comment|/**< Output Error Encountered and possibly recovered                                                          from.  This sticky bit is set with bit 16. */
name|uint32_t
name|o_sm_err
range|:
literal|1
decl_stmt|;
comment|/**< Output Port State Machine has encountered an                                                          error. */
name|uint32_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint32_t
name|i_sm_ret
range|:
literal|1
decl_stmt|;
comment|/**< Input Port State Machine has received a                                                          packet-retry control symbol and is retrying the                                                          packet. */
name|uint32_t
name|i_error
range|:
literal|1
decl_stmt|;
comment|/**< Input Error Encountered and possibly recovered                                                          from.  This sticky bit is set with bit 8. */
name|uint32_t
name|i_sm_err
range|:
literal|1
decl_stmt|;
comment|/**< Input Port State Machine has encountered an                                                          error. */
name|uint32_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint32_t
name|pt_write
range|:
literal|1
decl_stmt|;
comment|/**< Port has encountered a condition which required it                                                          initiate a Maintenance Port-Write Operation.                                                          Never set by hardware. */
name|uint32_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pt_error
range|:
literal|1
decl_stmt|;
comment|/**< Input or Output Port has encountered an                                                          unrecoverable error condition. */
name|uint32_t
name|pt_ok
range|:
literal|1
decl_stmt|;
comment|/**< Input or Output Port are intitialized and the port                                                          is exchanging error free control symbols with                                                          attached device. */
name|uint32_t
name|pt_uinit
range|:
literal|1
decl_stmt|;
comment|/**< Port is uninitialized.  This bit and bit 1 are                                                          mutually exclusive. */
else|#
directive|else
name|uint32_t
name|pt_uinit
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pt_ok
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pt_error
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pt_write
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint32_t
name|i_sm_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_error
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_sm_ret
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint32_t
name|o_sm_err
range|:
literal|1
decl_stmt|;
name|uint32_t
name|o_error
range|:
literal|1
decl_stmt|;
name|uint32_t
name|o_sm_ret
range|:
literal|1
decl_stmt|;
name|uint32_t
name|o_rtried
range|:
literal|1
decl_stmt|;
name|uint32_t
name|o_retry
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint32_t
name|o_dgrad
range|:
literal|1
decl_stmt|;
name|uint32_t
name|o_fail
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pkt_drop
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_0_err_stat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_err_stat_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_err_stat_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_0_err_stat
name|cvmx_sriomaintx_port_0_err_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_0_link_req  *  * SRIOMAINT_PORT_0_LINK_REQ = SRIO Port 0 Link Request  *  * Port 0 Manual Link Request  *  * Notes:  * Writing this register generates the link request symbol or eight device reset symbols.   The  *  progress of the request can be determined by reading SRIOMAINT(0,2..3)_PORT_0_LINK_RESP.  Only a single  *  request should be generated at a time.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_LINK_REQ       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_0_link_req
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_0_link_req_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
name|uint32_t
name|cmd
range|:
literal|3
decl_stmt|;
comment|/**< Link Request Command.                                                          011 - Reset Device                                                          100 - Link Request                                                          All other values reserved. */
else|#
directive|else
name|uint32_t
name|cmd
range|:
literal|3
decl_stmt|;
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_0_link_req_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_link_req_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_0_link_req
name|cvmx_sriomaintx_port_0_link_req_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_0_link_resp  *  * SRIOMAINT_PORT_0_LINK_RESP = SRIO Port 0 Link Response  *  * Port 0 Manual Link Response  *  * Notes:  * This register only returns responses generated by writes to SRIOMAINT(0,2..3)_PORT_0_LINK_REQ.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_LINK_RESP      hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_0_link_resp
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_0_link_resp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/**< Link Response Valid.                                                          1 = Link Response Received or Reset Device                                                              Symbols Transmitted.  Value cleared on read.                                                          0 = No response received. */
name|uint32_t
name|reserved_11_30
range|:
literal|20
decl_stmt|;
name|uint32_t
name|ackid
range|:
literal|6
decl_stmt|;
comment|/**< AckID received from link response.                                                          Reset Device symbol response is always zero.                                                          Bit 10 is used for IDLE2 and always reads zero. */
name|uint32_t
name|status
range|:
literal|5
decl_stmt|;
comment|/**< Link Response Status.                                                          Status supplied by link response.                                                          Reset Device symbol response is always zero. */
else|#
directive|else
name|uint32_t
name|status
range|:
literal|5
decl_stmt|;
name|uint32_t
name|ackid
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_11_30
range|:
literal|20
decl_stmt|;
name|uint32_t
name|valid
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_0_link_resp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_link_resp_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_0_link_resp
name|cvmx_sriomaintx_port_0_link_resp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_0_local_ackid  *  * SRIOMAINT_PORT_0_LOCAL_ACKID = SRIO Port 0 Local AckID  *  * Port 0 Local AckID Control  *  * Notes:  * This register is typically only written when recovering from a failed link.  It may be read at any  *  time the MAC is out of reset.  Writes to the O_ACKID field will be used for both the O_ACKID and  *  E_ACKID.  Care must be taken to ensure that no packets are pending at the time of a write.  The  *  number of pending packets can be read in the TX_INUSE field of SRIO(0,2..3)_MAC_BUFFERS.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_0_LOCAL_ACKID    hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_0_local_ackid
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_0_local_ackid_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint32_t
name|i_ackid
range|:
literal|6
decl_stmt|;
comment|/**< Next Expected Inbound AckID.                                                          Bit 29 is used for IDLE2 and should be zero. */
name|uint32_t
name|reserved_14_23
range|:
literal|10
decl_stmt|;
name|uint32_t
name|e_ackid
range|:
literal|6
decl_stmt|;
comment|/**< Next Expected Unacknowledged AckID.                                                          Bit 13 is used for IDLE2 and should be zero. */
name|uint32_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint32_t
name|o_ackid
range|:
literal|6
decl_stmt|;
comment|/**< Next Outgoing Packet AckID.                                                          Bit 5 is used for IDLE2 and should be zero. */
else|#
directive|else
name|uint32_t
name|o_ackid
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint32_t
name|e_ackid
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_14_23
range|:
literal|10
decl_stmt|;
name|uint32_t
name|i_ackid
range|:
literal|6
decl_stmt|;
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_0_local_ackid_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_0_local_ackid_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_0_local_ackid
name|cvmx_sriomaintx_port_0_local_ackid_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_gen_ctl  *  * SRIOMAINT_PORT_GEN_CTL = SRIO Port General Control  *  * Port General Control  *  * Notes:  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_GEN_CTL  hclk    hrst_n  *  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_gen_ctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_gen_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|host
range|:
literal|1
decl_stmt|;
comment|/**< Host Device.                                                          The HOST reset value is based on corresponding                                                          MIO_RST_CTL*[PRTMODE].  HOST resets to 1 when                                                          this field selects RC (i.e. host) mode, else 0. */
name|uint32_t
name|menable
range|:
literal|1
decl_stmt|;
comment|/**< Master Enable.  Must be set for device to issue                                                          read, write, doorbell, message requests. */
name|uint32_t
name|discover
range|:
literal|1
decl_stmt|;
comment|/**< Discovered. The device has been discovered by the                                                          host responsible for initialization. */
name|uint32_t
name|reserved_0_28
range|:
literal|29
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_28
range|:
literal|29
decl_stmt|;
name|uint32_t
name|discover
range|:
literal|1
decl_stmt|;
name|uint32_t
name|menable
range|:
literal|1
decl_stmt|;
name|uint32_t
name|host
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_gen_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_gen_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_gen_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_gen_ctl
name|cvmx_sriomaintx_port_gen_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_lt_ctl  *  * SRIOMAINT_PORT_LT_CTL = SRIO Link Layer Timeout Control  *  * Link Layer Timeout Control  *  * Notes:  * This register controls the timeout for link layer transactions.  It is used as the timeout between  *  sending a packet (of any type) or link request to receiving the corresponding link acknowledge or  *  link-response.  Each count represents 200ns.  The minimum timeout period is the TIMEOUT x 200nS  *  and the maximum is twice that number.  A value less than 32 may not guarantee that all timeout  *  errors will be reported correctly.  When the timeout period expires the packet or link request is  *  dropped and the error is logged in the LNK_TOUT field of the SRIOMAINT(0,2..3)_ERB_ERR_DET register.  A  *  value of 0 in this register will allow the packet or link request to be issued but it will timeout  *  immediately.  This value is not recommended for normal operation.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_LT_CTL   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_lt_ctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_lt_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|timeout
range|:
literal|24
decl_stmt|;
comment|/**< Timeout Value */
name|uint32_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint32_t
name|timeout
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_lt_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_lt_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_lt_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_lt_ctl
name|cvmx_sriomaintx_port_lt_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_mbh0  *  * SRIOMAINT_PORT_MBH0 = SRIO Port Maintenance Block Header 0  *  * Port Maintenance Block Header 0  *  * Notes:  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_MBH0     hclk    hrst_n  *  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_mbh0
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_mbh0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|ef_ptr
range|:
literal|16
decl_stmt|;
comment|/**< Pointer to Error Management Block. */
name|uint32_t
name|ef_id
range|:
literal|16
decl_stmt|;
comment|/**< Extended Feature ID (Generic Endpoint Device) */
else|#
directive|else
name|uint32_t
name|ef_id
range|:
literal|16
decl_stmt|;
name|uint32_t
name|ef_ptr
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_mbh0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_mbh0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_mbh0_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_mbh0
name|cvmx_sriomaintx_port_mbh0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_rt_ctl  *  * SRIOMAINT_PORT_RT_CTL = SRIO Logical Layer Timeout Control  *  * Logical Layer Timeout Control  *  * Notes:  * This register controls the timeout for logical layer transactions.  It is used under two  *  conditions.  First, it is used as the timeout period between sending a packet requiring a packet  *  response being sent to receiving the corresponding response.  This is used for all outgoing packet  *  types including memory, maintenance, doorbells and message operations.  When the timeout period  *  expires the packet is disgarded and the error is logged in the PKT_TOUT field of the  *  SRIOMAINT(0,2..3)_ERB_LT_ERR_DET register.  The second use of this register is as a timeout period  *  between incoming message segments of the same message.  If a message segment is received then the  *  MSG_TOUT field of the SRIOMAINT(0,2..3)_ERB_LT_ERR_DET register is set if the next segment has not been  *  received before the time expires.  In both cases, each count represents 200ns.  The minimum  *  timeout period is the TIMEOUT x 200nS and the maximum is twice that number.  A value less than 32  *  may not guarantee that all timeout errors will be reported correctly.  A value of 0 disables the  *  logical layer timeouts and is not recommended for normal operation.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_RT_CTL   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_rt_ctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_rt_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|timeout
range|:
literal|24
decl_stmt|;
comment|/**< Timeout Value */
name|uint32_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint32_t
name|timeout
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_rt_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_rt_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_rt_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_rt_ctl
name|cvmx_sriomaintx_port_rt_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_port_ttl_ctl  *  * SRIOMAINT_PORT_TTL_CTL = SRIO Packet Time to Live Control  *  * Packet Time to Live  *  * Notes:  * This register controls the timeout for outgoing packets.  It is used to make sure packets are  *  being transmitted and acknowledged within a reasonable period of time.   The timeout value  *  corresponds to TIMEOUT x 200ns and a value of 0 disables the timer.  The actualy value of the  *  should be greater than the physical layer timout specified in SRIOMAINT(0,2..3)_PORT_LT_CTL and is  *  typically a less SRIOMAINT(0,2..3)_PORT_LT_CTL timeout than the response timeout specified in  *  SRIOMAINT(0,2..3)_PORT_RT_CTL.  A second application of this timer is to remove all the packets waiting  *  to be transmitted including those already in flight.  This may necessary in the case of a link  *  going down (see SRIO(0,2..3)_INT_REG.LINK_DWN).  This can accomplished by setting the TIMEOUT to small  *  value all so that all TX packets can be dropped.  In either case, when the timeout expires the TTL  *  interrupt is asserted, any packets currently being transmitted are dropped, the  *  SRIOMAINT(0,2..3)_TX_DROP.DROP bit is set (causing any scheduled packets to be dropped), the  *  SRIOMAINT(0,2..3)_TX_DROP.DROP_CNT is incremented for each packet and the SRIO output state is set to  *  IDLE (all errors are cleared).  Software must clear the SRIOMAINT(0,2..3)_TX_DROP.DROP bit to resume  *  transmitting packets.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PORT_RT_CTL   hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_port_ttl_ctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_port_ttl_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|timeout
range|:
literal|24
decl_stmt|;
comment|/**< Timeout Value */
name|uint32_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint32_t
name|timeout
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_port_ttl_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_port_ttl_ctl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_port_ttl_ctl
name|cvmx_sriomaintx_port_ttl_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_pri_dev_id  *  * SRIOMAINT_PRI_DEV_ID = SRIO Primary Device ID  *  * Primary 8 and 16 bit Device IDs  *  * Notes:  * This register defines the primary 8 and 16 bit device IDs used for large and small transport.  An  *  optional secondary set of device IDs are located in SRIOMAINT(0,2..3)_SEC_DEV_ID.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_PRI_DEV_ID    hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_pri_dev_id
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_pri_dev_id_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint32_t
name|id8
range|:
literal|8
decl_stmt|;
comment|/**< Primary 8-bit Device ID */
name|uint32_t
name|id16
range|:
literal|16
decl_stmt|;
comment|/**< Primary 16-bit Device ID */
else|#
directive|else
name|uint32_t
name|id16
range|:
literal|16
decl_stmt|;
name|uint32_t
name|id8
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_pri_dev_id_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_pri_dev_id_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_pri_dev_id_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_pri_dev_id
name|cvmx_sriomaintx_pri_dev_id_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_sec_dev_ctrl  *  * SRIOMAINT_SEC_DEV_CTRL = SRIO Secondary Device ID Control  *  * Control for Secondary Device IDs  *  * Notes:  * This register enables the secondary 8 and 16 bit device IDs used for large and small transport.  *  The corresponding secondary ID must be written before the ID is enabled.  The secondary IDs should  *  not be enabled if the values of the primary and secondary IDs are identical.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_SEC_DEV_CTRL  hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_sec_dev_ctrl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_sec_dev_ctrl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_2_31
range|:
literal|30
decl_stmt|;
name|uint32_t
name|enable8
range|:
literal|1
decl_stmt|;
comment|/**< Enable matches to secondary 8-bit Device ID */
name|uint32_t
name|enable16
range|:
literal|1
decl_stmt|;
comment|/**< Enable matches to secondary 16-bit Device ID */
else|#
directive|else
name|uint32_t
name|enable16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enable8
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_2_31
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_sec_dev_ctrl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_sec_dev_ctrl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_sec_dev_ctrl_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_sec_dev_ctrl
name|cvmx_sriomaintx_sec_dev_ctrl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_sec_dev_id  *  * SRIOMAINT_SEC_DEV_ID = SRIO Secondary Device ID  *  * Secondary 8 and 16 bit Device IDs  *  * Notes:  * This register defines the secondary 8 and 16 bit device IDs used for large and small transport.  *  The corresponding secondary ID must be written before the ID is enabled in the  *  SRIOMAINT(0,2..3)_SEC_DEV_CTRL register.  The primary set of device IDs are located in  *  SRIOMAINT(0,2..3)_PRI_DEV_ID register.  The secondary IDs should not be written to the same values as the  *  corresponding primary IDs.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_SEC_DEV_ID    hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_sec_dev_id
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_sec_dev_id_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint32_t
name|id8
range|:
literal|8
decl_stmt|;
comment|/**< Secondary 8-bit Device ID */
name|uint32_t
name|id16
range|:
literal|16
decl_stmt|;
comment|/**< Secondary 16-bit Device ID */
else|#
directive|else
name|uint32_t
name|id16
range|:
literal|16
decl_stmt|;
name|uint32_t
name|id8
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_sec_dev_id_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_sec_dev_id_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_sec_dev_id_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_sec_dev_id
name|cvmx_sriomaintx_sec_dev_id_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_serial_lane_hdr  *  * SRIOMAINT_SERIAL_LANE_HDR = SRIO Serial Lane Header  *  * SRIO Serial Lane Header  *  * Notes:  * The error management extensions block header register contains the EF_PTR to the next EF_BLK and  *  the EF_ID that identifies this as the Serial Lane Status Block.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_SERIAL_LANE_HDR       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_serial_lane_hdr
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_serial_lane_hdr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|ef_ptr
range|:
literal|16
decl_stmt|;
comment|/**< Pointer to the next block in the extended features                                                          data structure. */
name|uint32_t
name|ef_id
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint32_t
name|ef_id
range|:
literal|16
decl_stmt|;
name|uint32_t
name|ef_ptr
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_serial_lane_hdr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_serial_lane_hdr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_serial_lane_hdr_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_serial_lane_hdr
name|cvmx_sriomaintx_serial_lane_hdr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_src_ops  *  * SRIOMAINT_SRC_OPS = SRIO Source Operations  *  * The logical operations initiated by the Octeon.  *  * Notes:  * The logical operations initiated by the Cores.   The Source OPs register shows the operations  *  specified in the SRIO(0,2..3)_IP_FEATURE.OPS register.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_SRC_OPS       hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_src_ops
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_src_ops_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|gsm_read
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Read Home operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<31>] */
name|uint32_t
name|i_read
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Instruction Read.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<30>] */
name|uint32_t
name|rd_own
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Read for Ownership.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<29>] */
name|uint32_t
name|d_invald
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Data Cache Invalidate.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<28>] */
name|uint32_t
name|castout
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Castout Operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<27>] */
name|uint32_t
name|d_flush
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Data Cache Flush.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<26>] */
name|uint32_t
name|io_read
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support IO Read.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<25>] */
name|uint32_t
name|i_invald
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Instruction Cache Invalidate.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<24>] */
name|uint32_t
name|tlb_inv
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support TLB Entry Invalidate.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<23>] */
name|uint32_t
name|tlb_invs
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support TLB Entry Invalidate Sync.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<22>] */
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|read
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Nread operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<15>] */
name|uint32_t
name|write
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Nwrite operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<14>] */
name|uint32_t
name|swrite
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Swrite operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<13>] */
name|uint32_t
name|write_r
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Write with Response operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<12>] */
name|uint32_t
name|msg
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Data Message operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<11>] */
name|uint32_t
name|doorbell
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Doorbell operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<10>] */
name|uint32_t
name|compswap
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Atomic Compare and Swap.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<9>] */
name|uint32_t
name|testswap
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Atomic Test and Swap.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<8>] */
name|uint32_t
name|atom_inc
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic increment operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<7>] */
name|uint32_t
name|atom_dec
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic decrement operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<6>] */
name|uint32_t
name|atom_set
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic set operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<5>] */
name|uint32_t
name|atom_clr
range|:
literal|1
decl_stmt|;
comment|/**< PE can support Atomic clear operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<4>] */
name|uint32_t
name|atom_swp
range|:
literal|1
decl_stmt|;
comment|/**< PE does not support Atomic Swap.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<3>] */
name|uint32_t
name|port_wr
range|:
literal|1
decl_stmt|;
comment|/**< PE can Port Write operations.                                                          This is a RO copy of SRIO*_IP_FEATURE[OPS<2>] */
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint32_t
name|port_wr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_swp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_clr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_set
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_dec
range|:
literal|1
decl_stmt|;
name|uint32_t
name|atom_inc
range|:
literal|1
decl_stmt|;
name|uint32_t
name|testswap
range|:
literal|1
decl_stmt|;
name|uint32_t
name|compswap
range|:
literal|1
decl_stmt|;
name|uint32_t
name|doorbell
range|:
literal|1
decl_stmt|;
name|uint32_t
name|msg
range|:
literal|1
decl_stmt|;
name|uint32_t
name|write_r
range|:
literal|1
decl_stmt|;
name|uint32_t
name|swrite
range|:
literal|1
decl_stmt|;
name|uint32_t
name|write
range|:
literal|1
decl_stmt|;
name|uint32_t
name|read
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_21
range|:
literal|6
decl_stmt|;
name|uint32_t
name|tlb_invs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tlb_inv
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_invald
range|:
literal|1
decl_stmt|;
name|uint32_t
name|io_read
range|:
literal|1
decl_stmt|;
name|uint32_t
name|d_flush
range|:
literal|1
decl_stmt|;
name|uint32_t
name|castout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|d_invald
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rd_own
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i_read
range|:
literal|1
decl_stmt|;
name|uint32_t
name|gsm_read
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_src_ops_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_src_ops_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sriomaintx_src_ops_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_src_ops
name|cvmx_sriomaintx_src_ops_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sriomaint#_tx_drop  *  * SRIOMAINT_TX_DROP = SRIO MAC Outgoing Packet Drop  *  * Outging SRIO Packet Drop Control/Status  *  * Notes:  * This register controls and provides status for dropping outgoing SRIO packets.  The DROP bit  *  should only be cleared when no packets are currently being dropped.  This can be guaranteed by  *  clearing the SRIOMAINT(0,2..3)_PORT_0_CTL.O_ENABLE bit before changing the DROP bit and restoring the  *  O_ENABLE afterwards.  *  * Clk_Rst:        SRIOMAINT(0,2..3)_MAC_CTRL      hclk    hrst_n  */
end_comment

begin_union
union|union
name|cvmx_sriomaintx_tx_drop
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_sriomaintx_tx_drop_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint32_t
name|drop
range|:
literal|1
decl_stmt|;
comment|/**< All outgoing packets are dropped.  Any packets                                                          requiring a response will return 1's after the                                                          SRIOMAINT(0,2..3)_PORT_RT_CTL Timeout expires.  This bit                                                          is set automatically when the TTL Timeout occurs                                                          or can be set by software and must always be                                                          cleared by software. */
name|uint32_t
name|drop_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of packets dropped by transmit logic.                                                          Packets are dropped whenever a packet is ready to                                                          be transmitted and a TTL Timeouts occur, the  DROP                                                          bit is set or the SRIOMAINT(0,2..3)_ERB_ERR_RATE_THR                                                          FAIL_TH has been reached and the DROP_PKT bit is                                                          set in SRIOMAINT(0,2..3)_PORT_0_CTL.  This counter wraps                                                          on overflow and is cleared only on reset. */
else|#
directive|else
name|uint32_t
name|drop_cnt
range|:
literal|16
decl_stmt|;
name|uint32_t
name|drop
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sriomaintx_tx_drop_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sriomaintx_tx_drop_s
name|cn66xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sriomaintx_tx_drop
name|cvmx_sriomaintx_tx_drop_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

