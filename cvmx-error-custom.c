begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Prototypes for custom error handler function not handled by the default  * message display error function.  *  *<hr>$Revision: 44252 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error-custom.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-l2c.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pcie.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dfa-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-lmcx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pemx-defs.h>
end_include

begin_define
define|#
directive|define
name|PRINT_ERROR
parameter_list|(
name|format
parameter_list|,
modifier|...
parameter_list|)
value|cvmx_safe_printf("ERROR " format, ##__VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error-custom.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-l2c.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pcie.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * XAUI interfaces need to be reset whenever a local or remote fault  * is detected. Calling autoconf takes the link through a reset.  *  * @param info  *  * @return  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_error_handle_gmxx_rxx_int_reg
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
name|int
name|ipd_port
init|=
name|info
operator|->
name|group_index
decl_stmt|;
name|cvmx_helper_link_autoconf
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_write_csr
argument_list|(
name|info
operator|->
name|status_addr
argument_list|,
name|info
operator|->
name|status_mask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * When NPEI_INT_SUM[C0_LDWN] is set, the PCIe block requires a shutdown and  * initialization to bring the link back up. This handler does this for port 0.  * Note that config space is not enumerated again, so the devices will still be  * unusable.  *  * @param info  *  * @return  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_error_handle_npei_int_sum_c0_ldwn
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"NPEI_INT_SUM[C0_LDWN]: Reset request due to link0 down status.\n"
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
condition|)
block|{
comment|/* Attempt to automatically bring the link back up */
name|cvmx_pcie_rc_shutdown
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cvmx_pcie_rc_initialize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * When NPEI_INT_SUM[C1_LDWN] is set, the PCIe block requires a shutdown and  * initialization to bring the link back up. This handler does this for port 1.  * Note that config space is not enumerated again, so the devices will still be  * unusable.  *  * @param info  *  * @return  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_error_handle_npei_int_sum_c1_ldwn
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"NPEI_INT_SUM[C1_LDWN]: Reset request due to link1 down status.\n"
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
condition|)
block|{
comment|/* Attempt to automatically bring the link back up */
name|cvmx_pcie_rc_shutdown
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cvmx_pcie_rc_initialize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Some errors require more complicated error handing functions than the  * automatically generated functions in cvmx-error-init-*.c. This function  * replaces these handers with hand coded functions for these special cases.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|__cvmx_error_custom_initialize
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|cvmx_error_change_handler
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|21
comment|/* rem_fault */
argument_list|,
name|__cvmx_error_handle_gmxx_rxx_int_reg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_error_change_handler
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|20
comment|/* loc_fault */
argument_list|,
name|__cvmx_error_handle_gmxx_rxx_int_reg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|cvmx_error_change_handler
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|21
comment|/* rem_fault */
argument_list|,
name|__cvmx_error_handle_gmxx_rxx_int_reg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_error_change_handler
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|20
comment|/* loc_fault */
argument_list|,
name|__cvmx_error_handle_gmxx_rxx_int_reg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_error_change_handler
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|,
literal|1ull
operator|<<
literal|59
comment|/* c0_ldwn */
argument_list|,
name|__cvmx_error_handle_npei_int_sum_c0_ldwn
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_error_change_handler
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|,
literal|1ull
operator|<<
literal|60
comment|/* c1_ldwn */
argument_list|,
name|__cvmx_error_handle_npei_int_sum_c1_ldwn
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* CN63XX pass 1.x has a bug where the PCIe config CRS counter does not         stop. Disable reporting errors from CRS */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_error_disable
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_PEMX_INT_SUM
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|12
argument_list|)
expr_stmt|;
name|cvmx_error_disable
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_PEMX_INT_SUM
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|13
argument_list|)
expr_stmt|;
name|cvmx_error_disable
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_PEMX_INT_SUM
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|12
argument_list|)
expr_stmt|;
name|cvmx_error_disable
argument_list|(
name|CVMX_ERROR_REGISTER_IO64
argument_list|,
name|CVMX_PEMX_INT_SUM
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|1ull
operator|<<
literal|13
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * DFA_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_dfa_err_cp2dbe
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[CP2DBE]: DFA PP-CP2 Double Bit Error Detected\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * DFA_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_dfa_err_cp2perr
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[CP2PERR]: PP-CP2 Parity Error Detected\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * DFA_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_dfa_err_cp2sbe
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[CP2SBE]: DFA PP-CP2 Single Bit Error Corrected\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * DFA_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_dfa_err_dblovf
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DBLOVF]: Doorbell Overflow detected\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * DFA_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_dfa_err_dtedbe
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DTEDBE]: DFA DTE 29b Double Bit Error Detected\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * DFA_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_dfa_err_dteperr
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DTEPERR]: DTE Parity Error Detected\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * DFA_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_dfa_err_dtesbe
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_DFA_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"DFA_ERR[DTESBE]: DFA DTE 29b Single Bit Error Corrected\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * L2D_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_l2d_err_ded_err
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_l2d_err_t
name|derr
decl_stmt|;
name|cvmx_l2d_fadr_t
name|fadr
decl_stmt|;
name|uint64_t
name|syn0
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FSYN0
argument_list|)
decl_stmt|;
name|uint64_t
name|syn1
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FSYN1
argument_list|)
decl_stmt|;
name|derr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|)
expr_stmt|;
name|fadr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FADR
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"L2D_ERR[DED_ERR] ECC double: fadr: 0x%llx, syn0:0x%llx, syn1: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fadr
operator|.
name|u64
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn0
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn1
argument_list|)
expr_stmt|;
comment|/* Flush the line that had the error */
name|cvmx_l2c_flush_line
argument_list|(
name|fadr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|fadr
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|,
name|derr
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * L2D_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_l2d_err_sec_err
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_l2d_err_t
name|derr
decl_stmt|;
name|cvmx_l2d_fadr_t
name|fadr
decl_stmt|;
name|uint64_t
name|syn0
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FSYN0
argument_list|)
decl_stmt|;
name|uint64_t
name|syn1
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FSYN1
argument_list|)
decl_stmt|;
name|derr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|)
expr_stmt|;
name|fadr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FADR
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"L2D_ERR[SEC_ERR] ECC single: fadr: 0x%llx, syn0:0x%llx, syn1: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fadr
operator|.
name|u64
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn0
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|syn1
argument_list|)
expr_stmt|;
comment|/* Flush the line that had the error */
name|cvmx_l2c_flush_line
argument_list|(
name|fadr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|fadr
operator|.
name|s
operator|.
name|fadr
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2D_ERR
argument_list|,
name|derr
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * L2T_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_l2t_err_ded_err
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_l2t_err_t
name|terr
decl_stmt|;
name|terr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|terr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[DED_ERR]: double bit:\tfadr: 0x%x, fset: 0x%x, fsyn: 0x%x\n"
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fsyn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|terr
operator|.
name|s
operator|.
name|fsyn
condition|)
block|{
comment|/* Syndrome is zero, which means error was in non-hit line,             so flush all associations */
name|int
name|i
decl_stmt|;
name|int
name|l2_assoc
init|=
name|cvmx_l2c_get_num_assoc
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l2_assoc
condition|;
name|i
operator|++
control|)
name|cvmx_l2c_flush_line
argument_list|(
name|i
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|)
expr_stmt|;
block|}
else|else
name|cvmx_l2c_flush_line
argument_list|(
name|terr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * L2T_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_l2t_err_lckerr2
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[LCKERR2]: HW detected a case where a Rd/Wr Miss from PP#n could not find an available/unlocked set (for replacement).\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * L2T_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_l2t_err_lckerr
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[LCKERR]: SW attempted to LOCK DOWN the last available set of the INDEX (which is ignored by HW - but reported to SW).\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * L2T_ERR contains R/W1C bits along with R/W bits. This means that it requires  * special handling instead of the normal __cvmx_error_display() function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_l2t_err_sec_err
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_l2t_err_t
name|terr
decl_stmt|;
name|terr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|terr
operator|.
name|u64
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"L2T_ERR[SEC_ERR]: single bit:\tfadr: 0x%x, fset: 0x%x, fsyn: 0x%x\n"
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fsyn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|terr
operator|.
name|s
operator|.
name|fsyn
condition|)
block|{
comment|/* Syndrome is zero, which means error was in non-hit line,             so flush all associations */
name|int
name|i
decl_stmt|;
name|int
name|l2_assoc
init|=
name|cvmx_l2c_get_num_assoc
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l2_assoc
condition|;
name|i
operator|++
control|)
name|cvmx_l2c_flush_line
argument_list|(
name|i
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|)
expr_stmt|;
block|}
else|else
name|cvmx_l2c_flush_line
argument_list|(
name|terr
operator|.
name|s
operator|.
name|fset
argument_list|,
name|terr
operator|.
name|s
operator|.
name|fadr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * LMCX_MEM_CFG0 contains R/W1C bits along with R/W bits. This means that it  * requires special handling instead of the normal __cvmx_error_display()  * function.  *  * @param info  *  * @return  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_error_handle_lmcx_mem_cfg0
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|ddr_controller
init|=
name|info
operator|->
name|group_index
decl_stmt|;
name|cvmx_lmcx_mem_cfg0_t
name|mem_cfg0
decl_stmt|;
name|cvmx_lmcx_fadr_t
name|fadr
decl_stmt|;
name|int
name|sec_err
decl_stmt|;
name|int
name|ded_err
decl_stmt|;
name|mem_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_LMCX_MEM_CFG0
argument_list|(
name|ddr_controller
argument_list|)
argument_list|)
expr_stmt|;
name|fadr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_LMCX_FADR
argument_list|(
name|ddr_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_LMCX_MEM_CFG0
argument_list|(
name|ddr_controller
argument_list|)
argument_list|,
name|mem_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|sec_err
operator|=
name|cvmx_dpop
argument_list|(
name|mem_cfg0
operator|.
name|s
operator|.
name|sec_err
argument_list|)
expr_stmt|;
name|ded_err
operator|=
name|cvmx_dpop
argument_list|(
name|mem_cfg0
operator|.
name|s
operator|.
name|ded_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|ded_err
operator|||
name|sec_err
condition|)
block|{
name|PRINT_ERROR
argument_list|(
literal|"DDR%d ECC: %d Single bit corrections, %d Double bit errors\n"
literal|"DDR%d ECC:\tFailing dimm:   %u\n"
literal|"DDR%d ECC:\tFailing rank:   %u\n"
literal|"DDR%d ECC:\tFailing bank:   %u\n"
literal|"DDR%d ECC:\tFailing row:    0x%x\n"
literal|"DDR%d ECC:\tFailing column: 0x%x\n"
argument_list|,
name|ddr_controller
argument_list|,
name|sec_err
argument_list|,
name|ded_err
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|cn38xx
operator|.
name|fdimm
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|cn38xx
operator|.
name|fbunk
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|cn38xx
operator|.
name|fbank
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|cn38xx
operator|.
name|frow
argument_list|,
name|ddr_controller
argument_list|,
name|fadr
operator|.
name|cn38xx
operator|.
name|fcol
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * LMCX_MEM_CFG0 contains R/W1C bits along with R/W bits. This means that it  * requires special handling instead of the normal __cvmx_error_display()  * function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_lmcx_mem_cfg0_ded_err
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|__cvmx_error_handle_lmcx_mem_cfg0
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * LMCX_MEM_CFG0 contains R/W1C bits along with R/W bits. This means that it  * requires special handling instead of the normal __cvmx_error_display()  * function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_lmcx_mem_cfg0_sec_err
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|__cvmx_error_handle_lmcx_mem_cfg0
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * POW_ECC_ERR contains R/W1C bits along with R/W bits. This means that it  * requires special handling instead of the normal __cvmx_error_display()  * function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_pow_ecc_err_dbe
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[DBE]: POW double bit error\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * POW_ECC_ERR contains R/W1C bits along with R/W bits. This means that it  * requires special handling instead of the normal __cvmx_error_display()  * function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_pow_ecc_err_iop
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_pow_ecc_err_t
name|err
decl_stmt|;
name|err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|,
name|err
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP0]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL_NULL state\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP1]: Received SWTAG/SWTAG_DESCH/DESCH/UPD_WQP from PP in NULL state\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP2]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/GET_WORK from PP with pending tag switch to ORDERED or ATOMIC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP3]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL_NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP4]: Received SWTAG_FULL/SWTAG_DESCH from PP with tag specified as NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP5]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with GET_WORK pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP6]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with NULL_RD pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP7]: Received CLR_NSCHED from PP with SWTAG_DESCH/DESCH/CLR_NSCHED pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP8]: Received SWTAG/SWTAG_FULL/SWTAG_DESCH/DESCH/UPD_WQP/GET_WORK/NULL_RD from PP with CLR_NSCHED pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|9
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP9]: Received illegal opcode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|10
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP10]: Received ADD_WORK with tag specified as NULL_NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP11]: Received DBG load from PP with DBG load pending\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|s
operator|.
name|iop
operator|&
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[IOP12]: Received CSR load from PP with CSR load pending\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * POW_ECC_ERR contains R/W1C bits along with R/W bits. This means that it  * requires special handling instead of the normal __cvmx_error_display()  * function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_pow_ecc_err_rpe
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[RPE]: Remote pointer error\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * POW_ECC_ERR contains R/W1C bits along with R/W bits. This means that it  * requires special handling instead of the normal __cvmx_error_display()  * function.  *  * @param info  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_handle_pow_ecc_err_sbe
parameter_list|(
specifier|const
name|struct
name|cvmx_error_info
modifier|*
name|info
parameter_list|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_POW_ECC_ERR
argument_list|)
argument_list|)
expr_stmt|;
name|PRINT_ERROR
argument_list|(
literal|"POW_ECC_ERR[SBE]: POW single bit error\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

