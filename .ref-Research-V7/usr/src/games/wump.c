begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *	wumpus  *	stolen from PCC Vol 2 No 1  */
end_comment

begin_define
define|#
directive|define
name|NBAT
value|3
end_define

begin_define
define|#
directive|define
name|NROOM
value|20
end_define

begin_define
define|#
directive|define
name|NTUNN
value|3
end_define

begin_define
define|#
directive|define
name|NPIT
value|3
end_define

begin_struct
struct|struct
name|room
block|{
name|int
name|tunn
index|[
name|NTUNN
index|]
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|}
name|room
index|[
name|NROOM
index|]
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|intro
index|[]
block|{
literal|"\n"
operator|,
literal|"Welcome to 'Hunt the Wumpus.'\n"
operator|,
literal|"\n"
operator|,
literal|"The Wumpus lives in a cave of %d rooms.\n"
operator|,
literal|"Each room has %d tunnels leading to other rooms.\n"
operator|,
literal|"\n"
operator|,
literal|"Hazards:\n"
operator|,
literal|"\n"
operator|,
literal|"Bottomless Pits - Some rooms have Bottomless Pits in them.\n"
operator|,
literal|"	If you go there, you fall into the pit and lose!\n"
operator|,
literal|"Super Bats - Some other rooms have super bats.\n"
operator|,
literal|"	If you go there, a bat will grab you and take you to\n"
operator|,
literal|"	somewhere else in the cave where you could\n"
operator|,
literal|"	fall into a pit or run into the . . .\n"
operator|,
literal|"\n"
operator|,
literal|"Wumpus:\n"
operator|,
literal|"\n"
operator|,
literal|"The Wumpus is not bothered by the hazards since\n"
operator|,
literal|"he has sucker feet and is too big for a bat to lift.\n"
operator|,
literal|"\n"
operator|,
literal|"Usually he is asleep.\n"
operator|,
literal|"Two things wake him up:\n"
operator|,
literal|"	your entering his room\n"
operator|,
literal|"	your shooting an arrow anywhere in the cave.\n"
operator|,
literal|"If the wumpus wakes, he either decides to move one room or\n"
operator|,
literal|"stay where he was.  But if he ends up where you are,\n"
operator|,
literal|"he eats you up and you lose!\n"
operator|,
literal|"\n"
operator|,
literal|"You:\n"
operator|,
literal|"\n"
operator|,
literal|"Each turn you may either move or shoot a crooked arrow.\n"
operator|,
literal|"\n"
operator|,
literal|"Moving - You can move to one of the adjoining rooms;\n"
operator|,
literal|"	that is, to one that has a tunnel connecting it with\n"
operator|,
literal|"	the room you are in.\n"
operator|,
literal|"\n"
operator|,
literal|"Shooting - You have 5 arrows.  You lose when you run out.\n"
operator|,
literal|"	Each arrow can go from 1 to 5 rooms.\n"
operator|,
literal|"	You aim by telling the computer\n"
operator|,
literal|"	The arrow's path is a list of room numbers\n"
operator|,
literal|"	telling the arrow which room to go to next.\n"
operator|,
literal|"	The list is terminated with a 0.\n"
operator|,
literal|"	The first room in the path must be connected to the\n"
operator|,
literal|"	room you are in.  Each succeeding room must be\n"
operator|,
literal|"	connected to the previous room.\n"
operator|,
literal|"	If there is no tunnel between two of the rooms\n"
operator|,
literal|"	in the arrow's path, the arrow chooses one of the\n"
operator|,
literal|"	three tunnels from the room it's in and goes its\n"
operator|,
literal|"	own way.\n"
operator|,
literal|"\n"
operator|,
literal|"	If the arrow hits the wumpus, you win!\n"
operator|,
literal|"	If the arrow hits you, you lose!\n"
operator|,
literal|"\n"
operator|,
literal|"Warnings:\n"
operator|,
literal|"\n"
operator|,
literal|"When you are one or two rooms away from the wumpus,\n"
operator|,
literal|"the computer says:\n"
operator|,
literal|"		'I smell a Wumpus'\n"
operator|,
literal|"When you are one room away from some other hazard, it says:\n"
operator|,
literal|"		Bat    - 'Bats nearby'\n"
operator|,
literal|"		Pit    - 'I feel a draft'\n"
operator|,
literal|"\n"
operator|,
literal|0
operator|,
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|BAT
value|01
end_define

begin_define
define|#
directive|define
name|PIT
value|02
end_define

begin_define
define|#
directive|define
name|WUMP
value|04
end_define

begin_decl_stmt
name|int
name|arrow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tchar
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|struct
name|room
modifier|*
name|p
decl_stmt|;
name|int
name|k
decl_stmt|,
name|icomp
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"Instructions? (y-n) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rline
argument_list|()
operator|==
literal|'y'
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|intro
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|intro
index|[
name|i
index|]
argument_list|,
name|i
operator|&
literal|1
condition|?
name|NROOM
else|:
name|NTUNN
argument_list|)
expr_stmt|;
comment|/*  * initialize the room connections  */
name|init
label|:
name|p
operator|=
operator|&
name|room
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NROOM
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NTUNN
condition|;
name|j
operator|++
control|)
name|p
operator|->
name|tunn
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NROOM
condition|;
control|)
block|{
name|j
operator|=
name|rnum
argument_list|(
name|NROOM
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|room
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|k
operator|||
name|p
operator|->
name|tunn
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|p
operator|->
name|tunn
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
continue|continue;
name|p
operator|->
name|tunn
index|[
literal|1
index|]
operator|=
name|k
expr_stmt|;
name|room
index|[
name|k
index|]
operator|.
name|tunn
index|[
literal|0
index|]
operator|=
name|j
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|room
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NROOM
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NTUNN
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tunn
index|[
name|j
index|]
operator|<
literal|0
condition|)
name|p
operator|->
name|tunn
index|[
name|j
index|]
operator|=
name|tunnel
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tunn
index|[
name|j
index|]
operator|==
name|i
condition|)
goto|goto
name|init
goto|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|tunn
index|[
name|j
index|]
operator|==
name|p
operator|->
name|tunn
index|[
name|k
index|]
condition|)
goto|goto
name|init
goto|;
block|}
name|qsort
argument_list|(
operator|&
name|p
operator|->
name|tunn
index|[
literal|0
index|]
argument_list|,
name|NTUNN
argument_list|,
literal|2
argument_list|,
name|icomp
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/*  * put in player, wumpus,  * pits and bats  */
name|setup
label|:
name|arrow
operator|=
literal|5
expr_stmt|;
name|p
operator|=
operator|&
name|room
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NROOM
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPIT
condition|;
control|)
block|{
name|p
operator|=
operator|&
name|room
index|[
name|rnum
argument_list|(
name|NROOM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|flag
operator|&
name|PIT
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|flag
operator|=
operator||
name|PIT
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBAT
condition|;
control|)
block|{
name|p
operator|=
operator|&
name|room
index|[
name|rnum
argument_list|(
name|NROOM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|flag
operator|&
operator|(
name|PIT
operator||
name|BAT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|flag
operator|=
operator||
name|BAT
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|i
operator|=
name|rnum
argument_list|(
name|NROOM
argument_list|)
expr_stmt|;
name|wloc
operator|=
name|i
expr_stmt|;
name|room
index|[
name|i
index|]
operator|.
name|flag
operator|=
operator||
name|WUMP
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|rnum
argument_list|(
name|NROOM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|room
index|[
name|i
index|]
operator|.
name|flag
operator|&
operator|(
name|PIT
operator||
name|BAT
operator||
name|WUMP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|loc
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/*  *	main loop of the game  */
name|loop
label|:
name|printf
argument_list|(
literal|"You are in room %d\n"
argument_list|,
name|loc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|room
index|[
name|loc
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flag
operator|&
name|PIT
condition|)
block|{
name|printf
argument_list|(
literal|"You fell into a pit\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|flag
operator|&
name|WUMP
condition|)
block|{
name|printf
argument_list|(
literal|"You were eaten by the wumpus\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|flag
operator|&
name|BAT
condition|)
block|{
name|printf
argument_list|(
literal|"Theres a bat in your room\n"
argument_list|)
expr_stmt|;
name|loc
operator|=
name|rnum
argument_list|(
name|NROOM
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTUNN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|near
argument_list|(
operator|&
name|room
index|[
name|p
operator|->
name|tunn
index|[
name|i
index|]
index|]
argument_list|,
name|WUMP
argument_list|)
condition|)
goto|goto
name|nearwump
goto|;
if|if
condition|(
name|near
argument_list|(
name|p
argument_list|,
name|WUMP
argument_list|)
condition|)
block|{
name|nearwump
label|:
name|printf
argument_list|(
literal|"I smell a wumpus\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|near
argument_list|(
name|p
argument_list|,
name|BAT
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Bats nearby\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|near
argument_list|(
name|p
argument_list|,
name|PIT
argument_list|)
condition|)
name|printf
argument_list|(
literal|"I feel a draft\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"There are tunnels to"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTUNN
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|p
operator|->
name|tunn
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|again
label|:
name|printf
argument_list|(
literal|"Move or shoot (m-s) "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rline
argument_list|()
condition|)
block|{
case|case
literal|'m'
case|:
if|if
condition|(
name|tchar
operator|==
literal|'\n'
condition|)
name|printf
argument_list|(
literal|"which room? "
argument_list|)
expr_stmt|;
name|i
operator|=
name|rin
argument_list|()
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NTUNN
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|p
operator|->
name|tunn
index|[
name|j
index|]
condition|)
goto|goto
name|groom
goto|;
name|printf
argument_list|(
literal|"You hit the wall\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
name|groom
label|:
name|loc
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|wloc
condition|)
goto|goto
name|mwump
goto|;
goto|goto
name|loop
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
name|tchar
operator|==
literal|'\n'
condition|)
name|printf
argument_list|(
literal|"Give list of rooms terminated by 0\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|rin
argument_list|()
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
break|break;
name|ranarw
label|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NTUNN
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|j
operator|==
name|p
operator|->
name|tunn
index|[
name|k
index|]
condition|)
goto|goto
name|garow
goto|;
name|j
operator|=
name|rnum
argument_list|(
name|NROOM
argument_list|)
expr_stmt|;
goto|goto
name|ranarw
goto|;
name|garow
label|:
name|p
operator|=
operator|&
name|room
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|loc
condition|)
block|{
name|printf
argument_list|(
literal|"You shot yourself\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|flag
operator|&
name|WUMP
condition|)
block|{
name|printf
argument_list|(
literal|"You slew the wumpus\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
operator|--
name|arrow
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"That was your last shot\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|mwump
goto|;
block|}
goto|goto
name|again
goto|;
name|mwump
label|:
name|p
operator|=
operator|&
name|room
index|[
name|wloc
index|]
expr_stmt|;
name|p
operator|->
name|flag
operator|=
operator|&
operator|~
name|WUMP
expr_stmt|;
name|i
operator|=
name|rnum
argument_list|(
name|NTUNN
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|NTUNN
condition|)
name|wloc
operator|=
name|p
operator|->
name|tunn
index|[
name|i
index|]
expr_stmt|;
name|room
index|[
name|wloc
index|]
operator|.
name|flag
operator|=
operator||
name|WUMP
expr_stmt|;
goto|goto
name|loop
goto|;
name|done
label|:
name|printf
argument_list|(
literal|"Another game? (y-n) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rline
argument_list|()
operator|==
literal|'y'
condition|)
block|{
name|printf
argument_list|(
literal|"Same room setup? (y-n) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rline
argument_list|()
operator|==
literal|'y'
condition|)
goto|goto
name|setup
goto|;
goto|goto
name|init
goto|;
block|}
block|}
end_function

begin_macro
name|tunnel
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|room
modifier|*
name|p
decl_stmt|;
specifier|register
name|n
operator|,
name|j
expr_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|20
expr_stmt|;
name|loop
label|:
name|n
operator|=
name|rnum
argument_list|(
name|NROOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|i
condition|)
if|if
condition|(
operator|--
name|c
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|p
operator|=
operator|&
name|room
index|[
name|n
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NTUNN
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|tunn
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|p
operator|->
name|tunn
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
goto|goto
name|loop
goto|;
block|}
end_block

begin_macro
name|rline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|r
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|exit
argument_list|()
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|tchar
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_block

begin_macro
name|rnum
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|first
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|first
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|time
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|srand
argument_list|(
operator|(
name|first
index|[
literal|1
index|]
operator|*
name|first
index|[
literal|0
index|]
operator|)
operator|^
name|first
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|rand
argument_list|()
operator|/
literal|32768.0
operator|)
operator|*
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|rin
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
operator|,
name|c
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|exit
argument_list|()
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|near
argument_list|(
argument|ap
argument_list|,
argument|ahaz
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|room
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|room
modifier|*
name|p
decl_stmt|;
specifier|register
name|haz
operator|,
name|i
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
name|haz
operator|=
name|ahaz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTUNN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|room
index|[
name|p
operator|->
name|tunn
index|[
name|i
index|]
index|]
operator|.
name|flag
operator|&
name|haz
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|icomp
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|*
name|p1
operator|-
operator|*
name|p2
operator|)
return|;
block|}
end_block

end_unit

