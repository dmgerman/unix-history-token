begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"mfile1"
end_include

begin_comment
comment|/*	some special actions, used in finding the type of nodes */
end_comment

begin_define
define|#
directive|define
name|NCVT
value|01
end_define

begin_define
define|#
directive|define
name|PUN
value|02
end_define

begin_define
define|#
directive|define
name|TYPL
value|04
end_define

begin_define
define|#
directive|define
name|TYPR
value|010
end_define

begin_define
define|#
directive|define
name|TYMATCH
value|040
end_define

begin_define
define|#
directive|define
name|LVAL
value|0100
end_define

begin_define
define|#
directive|define
name|CVTO
value|0200
end_define

begin_define
define|#
directive|define
name|CVTL
value|0400
end_define

begin_define
define|#
directive|define
name|CVTR
value|01000
end_define

begin_define
define|#
directive|define
name|PTMATCH
value|02000
end_define

begin_define
define|#
directive|define
name|OTHER
value|04000
end_define

begin_define
define|#
directive|define
name|NCVTR
value|010000
end_define

begin_comment
comment|/* node conventions:  	NAME:	rval>0 is stab index for external 		rval<0 is -inlabel number 		lval is offset in bits 	ICON:	lval has the value 		rval has the STAB index, or - label number, 			if a name whose address is in the constant 		rval = NONAME means no name 	REG:	rval is reg. identification cookie  	*/
end_comment

begin_decl_stmt
name|int
name|bdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|NODE
modifier|*
name|buildtree
parameter_list|(
name|o
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
decl|*
name|r
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|actions
expr_stmt|;
specifier|register
name|opty
expr_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|lr
decl_stmt|,
modifier|*
name|ll
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|eprint
parameter_list|()
function_decl|;
if|if
condition|(
name|bdebug
condition|)
name|printf
argument_list|(
literal|"buildtree( %s, %o, %o )\n"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|opty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* check for constants */
if|if
condition|(
name|opty
operator|==
name|UTYPE
operator|&&
name|l
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|NOT
case|:
if|if
condition|(
name|hflag
condition|)
name|werror
argument_list|(
literal|"constant argument to NOT"
argument_list|)
expr_stmt|;
case|case
name|UNARY
name|MINUS
case|:
case|case
name|COMPL
case|:
if|if
condition|(
name|conval
argument_list|(
name|l
argument_list|,
name|o
argument_list|,
name|l
argument_list|)
condition|)
return|return
operator|(
name|l
operator|)
return|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|o
operator|==
name|UNARY
name|MINUS
operator|&&
name|l
operator|->
name|op
operator|==
name|FCON
condition|)
block|{
name|l
operator|->
name|dval
operator|=
operator|-
name|l
operator|->
name|dval
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
name|QUEST
operator|&&
name|l
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
name|l
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|r
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|lval
condition|)
block|{
name|tfree
argument_list|(
name|r
operator|->
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|->
name|left
operator|)
return|;
block|}
else|else
block|{
name|tfree
argument_list|(
name|r
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|->
name|right
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|==
name|ANDAND
operator|||
name|o
operator|==
name|OROR
operator|)
operator|&&
operator|(
name|l
operator|->
name|op
operator|==
name|ICON
operator|||
name|r
operator|->
name|op
operator|==
name|ICON
operator|)
condition|)
goto|goto
name|ccwarn
goto|;
elseif|else
if|if
condition|(
name|opty
operator|==
name|BITYPE
operator|&&
name|l
operator|->
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ULT
case|:
case|case
name|UGT
case|:
case|case
name|ULE
case|:
case|case
name|UGE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|CBRANCH
case|:
name|ccwarn
label|:
if|if
condition|(
name|hflag
condition|)
name|werror
argument_list|(
literal|"constant in conditional context"
argument_list|)
expr_stmt|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MUL
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|ER
case|:
case|case
name|LS
case|:
case|case
name|RS
case|:
if|if
condition|(
name|conval
argument_list|(
name|l
argument_list|,
name|o
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|r
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|opty
operator|==
name|BITYPE
operator|&&
operator|(
name|l
operator|->
name|op
operator|==
name|FCON
operator|||
name|l
operator|->
name|op
operator|==
name|ICON
operator|)
operator|&&
operator|(
name|r
operator|->
name|op
operator|==
name|FCON
operator|||
name|r
operator|->
name|op
operator|==
name|ICON
operator|)
condition|)
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MUL
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|l
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
name|l
operator|->
name|dval
operator|=
name|l
operator|->
name|lval
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
name|r
operator|->
name|dval
operator|=
name|r
operator|->
name|lval
expr_stmt|;
block|}
name|l
operator|->
name|op
operator|=
name|FCON
expr_stmt|;
name|l
operator|->
name|type
operator|=
name|l
operator|->
name|csiz
operator|=
name|DOUBLE
expr_stmt|;
name|r
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|PLUS
case|:
name|l
operator|->
name|dval
operator|+=
name|r
operator|->
name|dval
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
case|case
name|MINUS
case|:
name|l
operator|->
name|dval
operator|-=
name|r
operator|->
name|dval
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
case|case
name|MUL
case|:
name|l
operator|->
name|dval
operator|*=
name|r
operator|->
name|dval
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
case|case
name|DIV
case|:
if|if
condition|(
name|r
operator|->
name|dval
operator|==
literal|0
condition|)
name|uerror
argument_list|(
literal|"division by 0."
argument_list|)
expr_stmt|;
else|else
name|l
operator|->
name|dval
operator|/=
name|r
operator|->
name|dval
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
block|}
comment|/* its real; we must make a new node */
name|p
operator|=
name|block
argument_list|(
name|o
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|actions
operator|=
name|opact
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|actions
operator|&
name|LVAL
condition|)
block|{
comment|/* check left descendent */
if|if
condition|(
name|notlval
argument_list|(
name|p
operator|->
name|left
argument_list|)
condition|)
block|{
name|uerror
argument_list|(
literal|"lvalue required"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|actions
operator|&
name|NCVTR
condition|)
block|{
name|p
operator|->
name|left
operator|=
name|pconvert
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|actions
operator|&
name|NCVT
operator|)
condition|)
block|{
switch|switch
condition|(
name|opty
condition|)
block|{
case|case
name|BITYPE
case|:
name|p
operator|->
name|right
operator|=
name|pconvert
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
case|case
name|UTYPE
case|:
name|p
operator|->
name|left
operator|=
name|pconvert
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|actions
operator|&
name|PUN
operator|)
operator|&&
operator|(
name|o
operator|!=
name|CAST
operator|||
name|cflag
operator|)
condition|)
block|{
name|chkpun
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actions
operator|&
operator|(
name|TYPL
operator||
name|TYPR
operator|)
condition|)
block|{
name|q
operator|=
operator|(
name|actions
operator|&
name|TYPL
operator|)
condition|?
name|p
operator|->
name|left
else|:
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|q
operator|->
name|type
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|q
operator|->
name|cdim
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|q
operator|->
name|csiz
expr_stmt|;
block|}
if|if
condition|(
name|actions
operator|&
name|CVTL
condition|)
name|p
operator|=
name|convert
argument_list|(
name|p
argument_list|,
name|CVTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|actions
operator|&
name|CVTR
condition|)
name|p
operator|=
name|convert
argument_list|(
name|p
argument_list|,
name|CVTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|actions
operator|&
name|TYMATCH
condition|)
name|p
operator|=
name|tymatch
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|actions
operator|&
name|PTMATCH
condition|)
name|p
operator|=
name|ptmatch
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|actions
operator|&
name|OTHER
condition|)
block|{
name|l
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|right
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|NAME
case|:
name|sp
operator|=
operator|&
name|stab
index|[
name|idname
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|UNDEF
condition|)
block|{
name|uerror
argument_list|(
literal|"%.8s undefined"
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
comment|/* make p look reasonable */
name|p
operator|->
name|type
operator|=
name|p
operator|->
name|cdim
operator|=
name|p
operator|->
name|csiz
operator|=
name|INT
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|idname
expr_stmt|;
name|p
operator|->
name|lval
operator|=
literal|0
expr_stmt|;
name|defid
argument_list|(
name|p
argument_list|,
name|SNULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|type
operator|=
name|sp
operator|->
name|stype
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|sp
operator|->
name|dimoff
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|sp
operator|->
name|sizoff
expr_stmt|;
name|p
operator|->
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|idname
expr_stmt|;
comment|/* special case: MOETY is really an ICON... */
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|MOETY
condition|)
block|{
name|p
operator|->
name|rval
operator|=
name|NONAME
expr_stmt|;
name|p
operator|->
name|lval
operator|=
name|sp
operator|->
name|offset
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|ENUMTY
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|ICON
expr_stmt|;
block|}
break|break;
case|case
name|ICON
case|:
name|p
operator|->
name|type
operator|=
name|INT
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|INT
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|p
operator|->
name|op
operator|=
name|NAME
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|CHAR
operator|+
name|ARY
expr_stmt|;
name|p
operator|->
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|NOLAB
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|curdim
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|CHAR
expr_stmt|;
break|break;
case|case
name|FCON
case|:
name|p
operator|->
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|DOUBLE
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|DOUBLE
expr_stmt|;
break|break;
case|case
name|STREF
case|:
comment|/* p->x turned into *(p+offset) */
comment|/* rhs must be a name; check correctness */
name|i
operator|=
name|r
operator|->
name|rval
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
operator|(
operator|(
name|sp
operator|=
operator|&
name|stab
index|[
name|i
index|]
operator|)
operator|->
name|sclass
operator|!=
name|MOS
operator|&&
name|sp
operator|->
name|sclass
operator|!=
name|MOU
operator|&&
operator|!
operator|(
name|sp
operator|->
name|sclass
operator|&
name|FIELD
operator|)
operator|)
condition|)
block|{
name|uerror
argument_list|(
literal|"member of structure or union required"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|j
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|type
operator|!=
name|PTR
operator|+
name|STRTY
operator|&&
name|l
operator|->
name|type
operator|!=
name|PTR
operator|+
name|UNIONTY
condition|)
block|{
name|werror
argument_list|(
literal|"struct/union or struct/union pointer required"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|j
operator|=
name|l
operator|->
name|csiz
operator|+
literal|1
operator|)
operator|<
literal|0
condition|)
name|cerror
argument_list|(
literal|"undefined structure or union"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|chkstr
argument_list|(
name|i
argument_list|,
name|dimtab
index|[
name|j
index|]
argument_list|,
name|DECREF
argument_list|(
name|l
operator|->
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|werror
argument_list|(
literal|"illegal member use: %.8s"
argument_list|,
name|stab
index|[
name|i
index|]
operator|.
name|sname
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|=
name|stref
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNARY
name|MUL
case|:
if|if
condition|(
name|l
operator|->
name|op
operator|==
name|UNARY
name|AND
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|l
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|l
operator|->
name|left
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|l
operator|->
name|type
argument_list|)
condition|)
name|uerror
argument_list|(
literal|"illegal indirection"
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|DECREF
argument_list|(
name|l
operator|->
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|l
operator|->
name|cdim
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|l
operator|->
name|csiz
expr_stmt|;
break|break;
case|case
name|UNARY
name|AND
case|:
switch|switch
condition|(
name|l
operator|->
name|op
condition|)
block|{
case|case
name|UNARY
name|MUL
case|:
name|p
operator|->
name|op
operator|=
name|l
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|l
operator|->
name|left
expr_stmt|;
case|case
name|NAME
case|:
name|p
operator|->
name|type
operator|=
name|INCREF
argument_list|(
name|l
operator|->
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|l
operator|->
name|cdim
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|l
operator|->
name|csiz
expr_stmt|;
break|break;
case|case
name|COMOP
case|:
name|lr
operator|=
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|l->right
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|l
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|buildtree
argument_list|(
name|COMOP
argument_list|,
name|l
operator|->
name|left
argument_list|,
name|lr
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUEST
case|:
name|lr
operator|=
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|l->right->right
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
name|ll
operator|=
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|l->right->left
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|l
operator|->
name|op
operator|=
name|l
operator|->
name|right
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|buildtree
argument_list|(
name|QUEST
argument_list|,
name|l
operator|->
name|left
argument_list|,
name|buildtree
argument_list|(
name|COLON
argument_list|,
name|ll
argument_list|,
name|lr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|uerror
argument_list|(
literal|"unacceptable operand of&"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LS
case|:
case|case
name|RS
case|:
case|case
name|ASG
name|LS
case|:
case|case
name|ASG
name|RS
case|:
if|if
condition|(
name|tsize
argument_list|(
name|p
operator|->
name|right
operator|->
name|type
argument_list|,
name|p
operator|->
name|right
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|right
operator|->
name|csiz
argument_list|)
operator|>
name|SZINT
condition|)
name|p
operator|->
name|right
operator|=
name|makety
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
case|case
name|ASSIGN
case|:
case|case
name|CAST
case|:
comment|/* structure assignment */
comment|/* take the addresses of the two sides; then make an 			/* operator using STASG and 			/* the addresses of left and right */
block|{
specifier|register
name|TWORD
name|t
decl_stmt|;
specifier|register
name|d
operator|,
name|s
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|csiz
operator|!=
name|r
operator|->
name|csiz
condition|)
name|uerror
argument_list|(
literal|"assignment of different structures"
argument_list|)
expr_stmt|;
name|r
operator|=
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|r
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
name|t
operator|=
name|r
operator|->
name|type
expr_stmt|;
name|d
operator|=
name|r
operator|->
name|cdim
expr_stmt|;
name|s
operator|=
name|r
operator|->
name|csiz
expr_stmt|;
name|l
operator|=
name|block
argument_list|(
name|STASG
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|RETURN
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|l
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|op
operator|=
name|UNARY
name|MUL
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|l
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|NIL
expr_stmt|;
break|break;
block|}
case|case
name|COLON
case|:
comment|/* structure colon */
if|if
condition|(
name|l
operator|->
name|csiz
operator|!=
name|r
operator|->
name|csiz
condition|)
name|uerror
argument_list|(
literal|"type clash in conditional"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|p
operator|->
name|right
operator|=
name|r
operator|=
name|strargs
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
case|case
name|UNARY
name|CALL
case|:
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|l
operator|->
name|type
argument_list|)
condition|)
name|uerror
argument_list|(
literal|"illegal function"
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|DECREF
argument_list|(
name|l
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISFTN
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
name|uerror
argument_list|(
literal|"illegal function"
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|DECREF
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|l
operator|->
name|cdim
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|l
operator|->
name|csiz
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|op
operator|==
name|UNARY
name|AND
operator|&&
name|l
operator|->
name|left
operator|->
name|op
operator|==
name|NAME
operator|&&
name|l
operator|->
name|left
operator|->
name|rval
operator|>=
literal|0
operator|&&
name|l
operator|->
name|left
operator|->
name|rval
operator|!=
name|NONAME
operator|&&
operator|(
operator|(
name|i
operator|=
name|stab
index|[
name|l
operator|->
name|left
operator|->
name|rval
index|]
operator|.
name|sclass
operator|)
operator|==
name|FORTRAN
operator|||
name|i
operator|==
name|UFORTRAN
operator|)
condition|)
block|{
name|p
operator|->
name|op
operator|+=
operator|(
name|FORTCALL
operator|-
name|CALL
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|STRTY
operator|||
name|p
operator|->
name|type
operator|==
name|UNIONTY
condition|)
block|{
comment|/* function returning structure */
comment|/*  make function really return ptr to str., with * */
name|p
operator|->
name|op
operator|+=
name|STCALL
operator|-
name|CALL
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|INCREF
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|p
operator|=
name|buildtree
argument_list|(
argument|UNARY MUL
argument_list|,
argument|p
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|cerror
argument_list|(
literal|"other code %d"
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|actions
operator|&
name|CVTO
condition|)
name|p
operator|=
name|oconvert
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|clocal
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdebug
condition|)
name|fwalk
argument_list|(
name|p
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|strargs
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* rewrite structure flavored arguments */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CM
condition|)
block|{
name|p
operator|->
name|left
operator|=
name|strargs
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|strargs
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|STRTY
operator|||
name|p
operator|->
name|type
operator|==
name|UNIONTY
condition|)
block|{
name|p
operator|=
name|block
argument_list|(
name|STARG
argument_list|,
name|p
argument_list|,
name|NIL
argument_list|,
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|csiz
argument_list|)
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|p->left
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
name|p
operator|=
name|clocal
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|chkstr
argument_list|(
argument|i
argument_list|,
argument|j
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* is the MOS or MOU at stab[i] OK for strict reference by a ptr */
comment|/* i has been checked to contain a MOS or MOU */
comment|/* j is the index in dimtab of the members... */
name|int
name|k
decl_stmt|,
name|kk
decl_stmt|;
specifier|extern
name|int
name|ddebug
decl_stmt|;
if|if
condition|(
name|ddebug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"chkstr( %.8s(%d), %d )\n"
argument_list|,
name|stab
index|[
name|i
index|]
operator|.
name|sname
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|j
operator|)
operator|<
literal|0
condition|)
name|uerror
argument_list|(
literal|"undefined structure or union"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
operator|(
name|kk
operator|=
name|dimtab
index|[
name|k
index|]
operator|)
operator|>=
literal|0
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|kk
operator|>=
name|SYMTSZ
condition|)
block|{
name|cerror
argument_list|(
literal|"gummy structure"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|kk
operator|==
name|i
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|stab
index|[
name|kk
index|]
operator|.
name|stype
condition|)
block|{
case|case
name|STRTY
case|:
case|case
name|UNIONTY
case|:
if|if
condition|(
name|type
operator|==
name|STRTY
condition|)
continue|continue;
comment|/* no recursive looking for strs */
if|if
condition|(
name|chkstr
argument_list|(
name|i
argument_list|,
name|dimtab
index|[
name|stab
index|[
name|kk
index|]
operator|.
name|sizoff
operator|+
literal|1
index|]
argument_list|,
name|stab
index|[
name|kk
index|]
operator|.
name|stype
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|conval
argument_list|(
name|p
argument_list|,
name|o
argument_list|,
name|q
argument_list|)
specifier|register
name|NODE
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* apply the op o to the lval part of p; if binary, rhs is val */
name|int
name|i
decl_stmt|,
name|u
decl_stmt|;
name|CONSZ
name|val
decl_stmt|;
name|val
operator|=
name|q
operator|->
name|lval
expr_stmt|;
name|u
operator|=
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|type
argument_list|)
operator|||
name|ISUNSIGNED
argument_list|(
name|q
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|&&
operator|(
name|o
operator|==
name|LE
operator|||
name|o
operator|==
name|LT
operator|||
name|o
operator|==
name|GE
operator|||
name|o
operator|==
name|GT
operator|)
condition|)
name|o
operator|+=
operator|(
name|UGE
operator|-
name|GE
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rval
operator|!=
name|NONAME
operator|&&
name|q
operator|->
name|rval
operator|!=
name|NONAME
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|rval
operator|!=
name|NONAME
operator|&&
name|o
operator|!=
name|PLUS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|rval
operator|!=
name|NONAME
operator|&&
name|o
operator|!=
name|PLUS
operator|&&
name|o
operator|!=
name|MINUS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|PLUS
case|:
name|p
operator|->
name|lval
operator|+=
name|val
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rval
operator|==
name|NONAME
condition|)
block|{
name|p
operator|->
name|rval
operator|=
name|q
operator|->
name|rval
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|q
operator|->
name|type
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
name|p
operator|->
name|lval
operator|-=
name|val
expr_stmt|;
break|break;
case|case
name|MUL
case|:
name|p
operator|->
name|lval
operator|*=
name|val
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|uerror
argument_list|(
literal|"division by 0"
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|lval
operator|/=
name|val
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|uerror
argument_list|(
literal|"division by 0"
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|lval
operator|%=
name|val
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|p
operator|->
name|lval
operator|&=
name|val
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|p
operator|->
name|lval
operator||=
name|val
expr_stmt|;
break|break;
case|case
name|ER
case|:
name|p
operator|->
name|lval
operator|^=
name|val
expr_stmt|;
break|break;
case|case
name|LS
case|:
name|i
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|<<
name|i
expr_stmt|;
break|break;
case|case
name|RS
case|:
name|i
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|>>
name|i
expr_stmt|;
break|break;
case|case
name|UNARY
name|MINUS
case|:
name|p
operator|->
name|lval
operator|=
operator|-
name|p
operator|->
name|lval
expr_stmt|;
break|break;
case|case
name|COMPL
case|:
name|p
operator|->
name|lval
operator|=
operator|~
name|p
operator|->
name|lval
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|p
operator|->
name|lval
operator|=
operator|!
name|p
operator|->
name|lval
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|<
name|val
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|<=
name|val
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|>
name|val
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|>=
name|val
expr_stmt|;
break|break;
case|case
name|ULT
case|:
name|p
operator|->
name|lval
operator|=
operator|(
name|p
operator|->
name|lval
operator|-
name|val
operator|)
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|ULE
case|:
name|p
operator|->
name|lval
operator|=
operator|(
name|p
operator|->
name|lval
operator|-
name|val
operator|)
operator|<=
literal|0
expr_stmt|;
break|break;
case|case
name|UGE
case|:
name|p
operator|->
name|lval
operator|=
operator|(
name|p
operator|->
name|lval
operator|-
name|val
operator|)
operator|>=
literal|0
expr_stmt|;
break|break;
case|case
name|UGT
case|:
name|p
operator|->
name|lval
operator|=
operator|(
name|p
operator|->
name|lval
operator|-
name|val
operator|)
operator|>
literal|0
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|==
name|val
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|p
operator|->
name|lval
operator|=
name|p
operator|->
name|lval
operator|!=
name|val
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|chkpun
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* checks p for the existance of a pun */
comment|/* this is called when the op of p is ASSIGN, RETURN, CAST, COLON, or relational */
comment|/* one case is when enumerations are used: this applies only to lint */
comment|/* in the other case, one operand is a pointer, the other integer type */
comment|/* we check that this integer is in fact a constant zero... */
comment|/* in the case of ASSIGN, any assignment of pointer to integer is illegal */
comment|/* this falls out, because the LHS is never 0 */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|t1
operator|,
name|t2
expr_stmt|;
specifier|register
name|d1
operator|,
name|d2
expr_stmt|;
name|t1
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|t2
operator|=
name|p
operator|->
name|right
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|ENUMTY
operator|||
name|t2
operator|==
name|ENUMTY
condition|)
block|{
comment|/* check for enumerations */
if|if
condition|(
name|logop
argument_list|(
name|p
operator|->
name|op
argument_list|)
operator|&&
name|p
operator|->
name|op
operator|!=
name|EQ
operator|&&
name|p
operator|->
name|op
operator|!=
name|NE
condition|)
block|{
name|uerror
argument_list|(
literal|"illegal comparison of enums"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t1
operator|==
name|ENUMTY
operator|&&
name|t2
operator|==
name|ENUMTY
operator|&&
name|p
operator|->
name|left
operator|->
name|csiz
operator|==
name|p
operator|->
name|right
operator|->
name|csiz
condition|)
return|return;
name|werror
argument_list|(
literal|"enumeration type clash, operator %s"
argument_list|,
name|opst
index|[
name|p
operator|->
name|op
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ISPTR
argument_list|(
name|t1
argument_list|)
operator|||
name|ISARY
argument_list|(
name|t1
argument_list|)
condition|)
name|q
operator|=
name|p
operator|->
name|right
expr_stmt|;
else|else
name|q
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|q
operator|->
name|type
argument_list|)
operator|&&
operator|!
name|ISARY
argument_list|(
name|q
operator|->
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|op
operator|!=
name|ICON
operator|||
name|q
operator|->
name|lval
operator|!=
literal|0
condition|)
block|{
name|werror
argument_list|(
literal|"illegal combination of pointer and integer"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d1
operator|=
name|p
operator|->
name|left
operator|->
name|cdim
expr_stmt|;
name|d2
operator|=
name|p
operator|->
name|right
operator|->
name|cdim
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
block|{
empty_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|csiz
operator|!=
name|p
operator|->
name|right
operator|->
name|csiz
condition|)
block|{
name|werror
argument_list|(
literal|"illegal structure pointer combination"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ISARY
argument_list|(
name|t1
argument_list|)
operator|||
name|ISPTR
argument_list|(
name|t1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ISARY
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|ISPTR
argument_list|(
name|t2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ISARY
argument_list|(
name|t1
argument_list|)
operator|&&
name|ISARY
argument_list|(
name|t2
argument_list|)
operator|&&
name|dimtab
index|[
name|d1
index|]
operator|!=
name|dimtab
index|[
name|d2
index|]
condition|)
block|{
name|werror
argument_list|(
literal|"illegal array size combination"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ISARY
argument_list|(
name|t1
argument_list|)
condition|)
operator|++
name|d1
expr_stmt|;
if|if
condition|(
name|ISARY
argument_list|(
name|t2
argument_list|)
condition|)
operator|++
name|d2
expr_stmt|;
block|}
else|else
break|break;
name|t1
operator|=
name|DECREF
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|DECREF
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
name|werror
argument_list|(
literal|"illegal pointer combination"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|NODE
modifier|*
name|stref
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
name|TWORD
name|t
decl_stmt|;
name|int
name|d
decl_stmt|,
name|s
decl_stmt|,
name|dsc
decl_stmt|;
name|OFFSZ
name|off
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
comment|/* make p->x */
comment|/* this is also used to reference automatic variables */
name|q
operator|=
operator|&
name|stab
index|[
name|p
operator|->
name|right
operator|->
name|rval
index|]
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|pconvert
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* make p look like ptr to x */
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|PTR
operator|+
name|UNIONTY
expr_stmt|;
block|}
name|t
operator|=
name|INCREF
argument_list|(
name|q
operator|->
name|stype
argument_list|)
expr_stmt|;
name|d
operator|=
name|q
operator|->
name|dimoff
expr_stmt|;
name|s
operator|=
name|q
operator|->
name|sizoff
expr_stmt|;
name|p
operator|=
name|makety
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* compute the offset to be added */
name|off
operator|=
name|q
operator|->
name|offset
expr_stmt|;
name|dsc
operator|=
name|q
operator|->
name|sclass
expr_stmt|;
if|if
condition|(
name|dsc
operator|&
name|FIELD
condition|)
block|{
comment|/* make fields look like ints */
name|off
operator|=
operator|(
name|off
operator|/
name|ALINT
operator|)
operator|*
name|ALINT
expr_stmt|;
name|s
operator|=
name|INT
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
name|p
operator|=
name|clocal
argument_list|(
name|block
argument_list|(
name|PLUS
argument_list|,
name|p
argument_list|,
name|offcon
argument_list|(
name|off
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buildtree
argument_list|(
argument|UNARY MUL
argument_list|,
argument|p
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
comment|/* if field, build field info */
if|if
condition|(
name|dsc
operator|&
name|FIELD
condition|)
block|{
name|p
operator|=
name|block
argument_list|(
name|FLD
argument_list|,
name|p
argument_list|,
name|NIL
argument_list|,
name|q
operator|->
name|stype
argument_list|,
literal|0
argument_list|,
name|q
operator|->
name|sizoff
argument_list|)
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|PKFIELD
argument_list|(
name|dsc
operator|&
name|FLDSIZ
argument_list|,
name|q
operator|->
name|offset
operator|%
name|ALINT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|clocal
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|notlval
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* return 0 if p an lvalue, 1 otherwise */
name|again
label|:
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|FLD
case|:
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|NAME
case|:
case|case
name|OREG
case|:
case|case
name|UNARY
name|MUL
case|:
if|if
condition|(
name|ISARY
argument_list|(
name|p
operator|->
name|type
argument_list|)
operator|||
name|ISFTN
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|REG
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_function
name|NODE
modifier|*
name|bcon
parameter_list|(
name|i
parameter_list|)
block|{
comment|/* make a constant node with value i */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|block
argument_list|(
name|ICON
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|p
operator|->
name|lval
operator|=
name|i
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|NONAME
expr_stmt|;
return|return
operator|(
name|clocal
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|bpsize
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
name|offcon
argument_list|(
name|psize
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|csiz
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|OFFSZ
name|psize
parameter_list|(
name|p
parameter_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* p is a node of type pointer; psize returns the 	   size of the thing pointed to */
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
name|uerror
argument_list|(
literal|"pointer required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SZINT
operator|)
return|;
block|}
comment|/* note: no pointers to fields */
return|return
operator|(
name|tsize
argument_list|(
name|DECREF
argument_list|(
name|p
operator|->
name|type
argument_list|)
argument_list|,
name|p
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|csiz
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|convert
parameter_list|(
name|p
parameter_list|,
name|f
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/*  convert an operand of p 	    f is either CVTL or CVTR 	    operand has type int, and is converted by the size of the other side 	    */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|q
operator|=
operator|(
name|f
operator|==
name|CVTL
operator|)
condition|?
name|p
operator|->
name|left
else|:
name|p
operator|->
name|right
expr_stmt|;
name|r
operator|=
name|block
argument_list|(
name|PMCONV
argument_list|,
name|q
argument_list|,
name|bpsize
argument_list|(
name|f
operator|==
name|CVTL
condition|?
name|p
operator|->
name|right
else|:
name|p
operator|->
name|left
argument_list|)
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|r
operator|=
name|clocal
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|CVTL
condition|)
name|p
operator|->
name|left
operator|=
name|r
expr_stmt|;
else|else
name|p
operator|->
name|right
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|econvert
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* change enums to ints, or appropriate types */
specifier|register
name|TWORD
name|ty
decl_stmt|;
if|if
condition|(
operator|(
name|ty
operator|=
name|BTYPE
argument_list|(
name|p
operator|->
name|type
argument_list|)
operator|)
operator|==
name|ENUMTY
operator|||
name|ty
operator|==
name|MOETY
condition|)
block|{
if|if
condition|(
name|dimtab
index|[
name|p
operator|->
name|csiz
index|]
operator|==
name|SZCHAR
condition|)
name|ty
operator|=
name|CHAR
expr_stmt|;
elseif|else
if|if
condition|(
name|dimtab
index|[
name|p
operator|->
name|csiz
index|]
operator|==
name|SZINT
condition|)
name|ty
operator|=
name|INT
expr_stmt|;
elseif|else
if|if
condition|(
name|dimtab
index|[
name|p
operator|->
name|csiz
index|]
operator|==
name|SZSHORT
condition|)
name|ty
operator|=
name|SHORT
expr_stmt|;
else|else
name|ty
operator|=
name|LONG
expr_stmt|;
name|ty
operator|=
name|ctype
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|ty
expr_stmt|;
name|MODTYPE
argument_list|(
name|p
operator|->
name|type
argument_list|,
name|ty
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ICON
operator|&&
name|ty
operator|!=
name|LONG
condition|)
name|p
operator|->
name|type
operator|=
name|p
operator|->
name|csiz
operator|=
name|INT
expr_stmt|;
block|}
block|}
end_block

begin_function
name|NODE
modifier|*
name|pconvert
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* if p should be changed into a pointer, do so */
if|if
condition|(
name|ISARY
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|DECREF
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|cdim
expr_stmt|;
return|return
operator|(
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|p
argument_list|,
argument|NIL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ISFTN
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
return|return
operator|(
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|p
argument_list|,
argument|NIL
argument_list|)
operator|)
return|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|oconvert
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* convert the result itself: used for pointer and unsigned */
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
operator|||
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|right
operator|->
name|type
argument_list|)
condition|)
name|p
operator|->
name|op
operator|+=
operator|(
name|ULE
operator|-
name|LE
operator|)
expr_stmt|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
operator|(
name|p
operator|)
return|;
case|case
name|MINUS
case|:
return|return
operator|(
name|clocal
argument_list|(
name|block
argument_list|(
name|PVCONV
argument_list|,
name|p
argument_list|,
name|bpsize
argument_list|(
name|p
operator|->
name|left
argument_list|)
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|cerror
argument_list|(
literal|"illegal oconvert: %d"
argument_list|,
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|ptmatch
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* makes the operands of p agree; they are 	   either pointers or integers, by this time */
comment|/* with MINUS, the sizes must be the same */
comment|/* with COLON, the types must be the same */
name|TWORD
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t
decl_stmt|;
name|int
name|o
decl_stmt|,
name|d2
decl_stmt|,
name|d
decl_stmt|,
name|s2
decl_stmt|,
name|s
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
name|t
operator|=
name|t1
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|t2
operator|=
name|p
operator|->
name|right
operator|->
name|type
expr_stmt|;
name|d
operator|=
name|p
operator|->
name|left
operator|->
name|cdim
expr_stmt|;
name|d2
operator|=
name|p
operator|->
name|right
operator|->
name|cdim
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|left
operator|->
name|csiz
expr_stmt|;
name|s2
operator|=
name|p
operator|->
name|right
operator|->
name|csiz
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ASSIGN
case|:
case|case
name|RETURN
case|:
case|case
name|CAST
case|:
block|{
break|break;
block|}
case|case
name|MINUS
case|:
block|{
if|if
condition|(
name|psize
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|!=
name|psize
argument_list|(
name|p
operator|->
name|right
argument_list|)
condition|)
block|{
name|uerror
argument_list|(
literal|"illegal pointer subtraction"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|COLON
case|:
block|{
if|if
condition|(
name|t1
operator|!=
name|t2
condition|)
name|uerror
argument_list|(
literal|"illegal types in :"
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* must work harder: relationals or comparisons */
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|t1
argument_list|)
condition|)
block|{
name|t
operator|=
name|t2
expr_stmt|;
name|d
operator|=
name|d2
expr_stmt|;
name|s
operator|=
name|s2
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|t2
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* both are pointers */
if|if
condition|(
name|talign
argument_list|(
name|t2
argument_list|,
name|s2
argument_list|)
operator|<
name|talign
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|t
operator|=
name|t2
expr_stmt|;
name|s
operator|=
name|s2
expr_stmt|;
block|}
break|break;
block|}
name|p
operator|->
name|left
operator|=
name|makety
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|makety
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|MINUS
operator|&&
operator|!
name|logop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|d
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|s
expr_stmt|;
block|}
return|return
operator|(
name|clocal
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|tdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|NODE
modifier|*
name|tymatch
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* satisfy the types of various arithmetic binary ops */
comment|/* rules are: 		if assignment, op, type of LHS 		if any float or doubles, make double 		if any longs, make long 		otherwise, make int 		if either operand is unsigned, the result is... 	*/
specifier|register
name|TWORD
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t
decl_stmt|,
name|tu
decl_stmt|;
specifier|register
name|o
operator|,
name|u
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
name|t1
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|t2
operator|=
name|p
operator|->
name|right
operator|->
name|type
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
block|{
name|u
operator|=
literal|1
expr_stmt|;
name|t1
operator|=
name|DEUNSIGN
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|u
operator|=
literal|1
expr_stmt|;
name|t2
operator|=
name|DEUNSIGN
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t1
operator|==
name|CHAR
operator|||
name|t1
operator|==
name|SHORT
operator|)
operator|&&
name|o
operator|!=
name|RETURN
condition|)
name|t1
operator|=
name|INT
expr_stmt|;
if|if
condition|(
name|t2
operator|==
name|CHAR
operator|||
name|t2
operator|==
name|SHORT
condition|)
name|t2
operator|=
name|INT
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|DOUBLE
operator|||
name|t1
operator|==
name|FLOAT
operator|||
name|t2
operator|==
name|DOUBLE
operator|||
name|t2
operator|==
name|FLOAT
condition|)
name|t
operator|=
name|DOUBLE
expr_stmt|;
elseif|else
if|if
condition|(
name|t1
operator|==
name|LONG
operator|||
name|t2
operator|==
name|LONG
condition|)
name|t
operator|=
name|LONG
expr_stmt|;
else|else
name|t
operator|=
name|INT
expr_stmt|;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|tu
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
block|}
else|else
block|{
name|tu
operator|=
operator|(
name|u
operator|&&
name|UNSIGNABLE
argument_list|(
name|t
argument_list|)
operator|)
condition|?
name|ENUNSIGN
argument_list|(
name|t
argument_list|)
else|:
name|t
expr_stmt|;
block|}
comment|/* because expressions have values that are at least as wide 	   as INT or UNSIGNED, the only conversions needed 	   are those involving FLOAT/DOUBLE, and those 	   from LONG to INT and ULONG to UNSIGNED */
if|if
condition|(
name|t
operator|!=
name|t1
condition|)
name|p
operator|->
name|left
operator|=
name|makety
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|tu
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|tu
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|t2
operator|||
name|o
operator|==
name|CAST
condition|)
name|p
operator|->
name|right
operator|=
name|makety
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|tu
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|tu
argument_list|)
expr_stmt|;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|p
operator|->
name|left
operator|->
name|cdim
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|p
operator|->
name|left
operator|->
name|csiz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|logop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|tu
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|tdebug
condition|)
name|printf
argument_list|(
literal|"tymatch(%o): %o %s %o => %o\n"
argument_list|,
name|p
argument_list|,
name|t1
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|,
name|t2
argument_list|,
name|tu
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|makety
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|TWORD
name|t
decl_stmt|;
block|{
comment|/* make p into type t by inserting a conversion */
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|ENUMTY
operator|&&
name|p
operator|->
name|op
operator|==
name|ICON
condition|)
name|econvert
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|p
operator|->
name|type
condition|)
block|{
name|p
operator|->
name|cdim
operator|=
name|d
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|&
name|TMASK
condition|)
block|{
comment|/* non-simple type */
return|return
operator|(
name|block
argument_list|(
name|PCONV
argument_list|,
name|p
argument_list|,
name|NIL
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|DOUBLE
operator|||
name|t
operator|==
name|FLOAT
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|FCON
expr_stmt|;
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
name|p
operator|->
name|dval
operator|=
comment|/* (unsigned CONSZ) */
name|p
operator|->
name|lval
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|dval
operator|=
name|p
operator|->
name|lval
expr_stmt|;
block|}
name|p
operator|->
name|type
operator|=
name|p
operator|->
name|csiz
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|clocal
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|block
argument_list|(
name|SCONV
argument_list|,
name|p
argument_list|,
name|NIL
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|block
parameter_list|(
name|o
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
decl|*
name|r
decl_stmt|;
end_function

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|o
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|l
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|cdim
operator|=
name|d
expr_stmt|;
name|p
operator|->
name|csiz
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|icons
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* if p is an integer constant, return its value */
name|int
name|val
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|ICON
condition|)
block|{
name|uerror
argument_list|(
literal|"constant expected"
argument_list|)
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|p
operator|->
name|lval
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|p
operator|->
name|lval
condition|)
name|uerror
argument_list|(
literal|"constant too big for cross-compiler"
argument_list|)
expr_stmt|;
block|}
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	the intent of this table is to examine the 	operators, and to check them for 	correctness.  	The table is searched for the op and the 	modified type (where this is one of the 	types INT (includes char and short), LONG, 	DOUBLE (includes FLOAT), and POINTER  	The default action is to make the node type integer  	The actions taken include: 		PUN	  check for puns 		CVTL	  convert the left operand 		CVTR	  convert the right operand 		TYPL	  the type is determined by the left operand 		TYPR	  the type is determined by the right operand 		TYMATCH	  force type of left and right to match, by inserting conversions 		PTMATCH	  like TYMATCH, but for pointers 		LVAL	  left operand must be lval 		CVTO	  convert the op 		NCVT	  do not convert the operands 		OTHER	  handled by code 		NCVTR	  convert the left operand, not the right...  	*/
end_comment

begin_define
define|#
directive|define
name|MINT
value|01
end_define

begin_comment
comment|/* integer */
end_comment

begin_define
define|#
directive|define
name|MDBI
value|02
end_define

begin_comment
comment|/* integer or double */
end_comment

begin_define
define|#
directive|define
name|MSTR
value|04
end_define

begin_comment
comment|/* structure */
end_comment

begin_define
define|#
directive|define
name|MPTR
value|010
end_define

begin_comment
comment|/* pointer */
end_comment

begin_define
define|#
directive|define
name|MPTI
value|020
end_define

begin_comment
comment|/* pointer or integer */
end_comment

begin_define
define|#
directive|define
name|MENU
value|040
end_define

begin_comment
comment|/* enumeration variable or member */
end_comment

begin_macro
name|opact
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|mt12
operator|,
name|mt1
operator|,
name|mt2
operator|,
name|o
expr_stmt|;
name|mt12
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optype
argument_list|(
name|o
operator|=
name|p
operator|->
name|op
argument_list|)
condition|)
block|{
case|case
name|BITYPE
case|:
name|mt12
operator|=
name|mt2
operator|=
name|moditype
argument_list|(
name|p
operator|->
name|right
operator|->
name|type
argument_list|)
expr_stmt|;
case|case
name|UTYPE
case|:
name|mt12
operator|&=
operator|(
name|mt1
operator|=
name|moditype
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|NAME
case|:
case|case
name|STRING
case|:
case|case
name|ICON
case|:
case|case
name|FCON
case|:
case|case
name|CALL
case|:
case|case
name|UNARY
name|CALL
case|:
case|case
name|UNARY
name|MUL
case|:
block|{
return|return
operator|(
name|OTHER
operator|)
return|;
block|}
case|case
name|UNARY
name|MINUS
case|:
if|if
condition|(
name|mt1
operator|&
name|MDBI
condition|)
return|return
operator|(
name|TYPL
operator|)
return|;
break|break;
case|case
name|COMPL
case|:
if|if
condition|(
name|mt1
operator|&
name|MINT
condition|)
return|return
operator|(
name|TYPL
operator|)
return|;
break|break;
case|case
name|UNARY
name|AND
case|:
block|{
return|return
operator|(
name|NCVT
operator|+
name|OTHER
operator|)
return|;
block|}
case|case
name|INIT
case|:
case|case
name|CM
case|:
case|case
name|NOT
case|:
case|case
name|CBRANCH
case|:
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MUL
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|mt12
operator|&
name|MDBI
condition|)
return|return
operator|(
name|TYMATCH
operator|)
return|;
break|break;
case|case
name|MOD
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|ER
case|:
if|if
condition|(
name|mt12
operator|&
name|MINT
condition|)
return|return
operator|(
name|TYMATCH
operator|)
return|;
break|break;
case|case
name|LS
case|:
case|case
name|RS
case|:
if|if
condition|(
name|mt12
operator|&
name|MINT
condition|)
return|return
operator|(
name|TYPL
operator|+
name|OTHER
operator|)
return|;
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
if|if
condition|(
operator|(
name|mt1
operator|&
name|MENU
operator|)
operator|||
operator|(
name|mt2
operator|&
name|MENU
operator|)
condition|)
return|return
operator|(
name|PTMATCH
operator|+
name|PUN
operator|+
name|NCVT
operator|)
return|;
if|if
condition|(
name|mt12
operator|&
name|MDBI
condition|)
return|return
operator|(
name|TYMATCH
operator|+
name|CVTO
operator|)
return|;
elseif|else
if|if
condition|(
name|mt12
operator|&
name|MPTR
condition|)
return|return
operator|(
name|PTMATCH
operator|+
name|PUN
operator|)
return|;
elseif|else
if|if
condition|(
name|mt12
operator|&
name|MPTI
condition|)
return|return
operator|(
name|PTMATCH
operator|+
name|PUN
operator|)
return|;
else|else
break|break;
case|case
name|QUEST
case|:
case|case
name|COMOP
case|:
if|if
condition|(
name|mt2
operator|&
name|MENU
condition|)
return|return
operator|(
name|TYPR
operator|+
name|NCVTR
operator|)
return|;
return|return
operator|(
name|TYPR
operator|)
return|;
case|case
name|STREF
case|:
return|return
operator|(
name|NCVT
operator|+
name|OTHER
operator|)
return|;
case|case
name|FORCE
case|:
return|return
operator|(
name|TYPL
operator|)
return|;
case|case
name|COLON
case|:
if|if
condition|(
name|mt12
operator|&
name|MENU
condition|)
return|return
operator|(
name|NCVT
operator|+
name|PUN
operator|+
name|PTMATCH
operator|)
return|;
elseif|else
if|if
condition|(
name|mt12
operator|&
name|MDBI
condition|)
return|return
operator|(
name|TYMATCH
operator|)
return|;
elseif|else
if|if
condition|(
name|mt12
operator|&
name|MPTR
condition|)
return|return
operator|(
name|TYPL
operator|+
name|PTMATCH
operator|+
name|PUN
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|mt1
operator|&
name|MINT
operator|)
operator|&&
operator|(
name|mt2
operator|&
name|MPTR
operator|)
condition|)
return|return
operator|(
name|TYPR
operator|+
name|PUN
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|mt1
operator|&
name|MPTR
operator|)
operator|&&
operator|(
name|mt2
operator|&
name|MINT
operator|)
condition|)
return|return
operator|(
name|TYPL
operator|+
name|PUN
operator|)
return|;
elseif|else
if|if
condition|(
name|mt12
operator|&
name|MSTR
condition|)
return|return
operator|(
name|NCVT
operator|+
name|TYPL
operator|+
name|OTHER
operator|)
return|;
break|break;
case|case
name|ASSIGN
case|:
case|case
name|RETURN
case|:
if|if
condition|(
name|mt12
operator|&
name|MSTR
condition|)
return|return
operator|(
name|LVAL
operator|+
name|NCVT
operator|+
name|TYPL
operator|+
name|OTHER
operator|)
return|;
case|case
name|CAST
case|:
if|if
condition|(
name|mt12
operator|&
name|MDBI
condition|)
return|return
operator|(
name|TYPL
operator|+
name|LVAL
operator|+
name|TYMATCH
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|mt1
operator|&
name|MENU
operator|)
operator|||
operator|(
name|mt2
operator|&
name|MENU
operator|)
condition|)
return|return
operator|(
name|LVAL
operator|+
name|NCVT
operator|+
name|TYPL
operator|+
name|PTMATCH
operator|+
name|PUN
operator|)
return|;
elseif|else
if|if
condition|(
name|mt1
operator|&
name|MPTR
condition|)
return|return
operator|(
name|LVAL
operator|+
name|PTMATCH
operator|+
name|PUN
operator|)
return|;
elseif|else
if|if
condition|(
name|mt12
operator|&
name|MPTI
condition|)
return|return
operator|(
name|TYPL
operator|+
name|LVAL
operator|+
name|TYMATCH
operator|+
name|PUN
operator|)
return|;
break|break;
case|case
name|ASG
name|LS
case|:
case|case
name|ASG
name|RS
case|:
if|if
condition|(
name|mt12
operator|&
name|MINT
condition|)
return|return
operator|(
name|TYPL
operator|+
name|LVAL
operator|+
name|OTHER
operator|)
return|;
break|break;
case|case
name|ASG
name|MUL
case|:
case|case
name|ASG
name|DIV
case|:
if|if
condition|(
name|mt12
operator|&
name|MDBI
condition|)
return|return
operator|(
name|LVAL
operator|+
name|TYMATCH
operator|)
return|;
break|break;
case|case
name|ASG
name|MOD
case|:
case|case
name|ASG
name|AND
case|:
case|case
name|ASG
name|OR
case|:
case|case
name|ASG
name|ER
case|:
if|if
condition|(
name|mt12
operator|&
name|MINT
condition|)
return|return
operator|(
name|LVAL
operator|+
name|TYMATCH
operator|)
return|;
break|break;
case|case
name|ASG
name|PLUS
case|:
case|case
name|ASG
name|MINUS
case|:
case|case
name|INCR
case|:
case|case
name|DECR
case|:
if|if
condition|(
name|mt12
operator|&
name|MDBI
condition|)
return|return
operator|(
name|TYMATCH
operator|+
name|LVAL
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|mt1
operator|&
name|MPTR
operator|)
operator|&&
operator|(
name|mt2
operator|&
name|MINT
operator|)
condition|)
return|return
operator|(
name|TYPL
operator|+
name|LVAL
operator|+
name|CVTR
operator|)
return|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|mt12
operator|&
name|MPTR
condition|)
return|return
operator|(
name|CVTO
operator|+
name|PTMATCH
operator|+
name|PUN
operator|)
return|;
if|if
condition|(
name|mt2
operator|&
name|MPTR
condition|)
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|mt12
operator|&
name|MDBI
condition|)
return|return
operator|(
name|TYMATCH
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|mt1
operator|&
name|MPTR
operator|)
operator|&&
operator|(
name|mt2
operator|&
name|MINT
operator|)
condition|)
return|return
operator|(
name|TYPL
operator|+
name|CVTR
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|mt1
operator|&
name|MINT
operator|)
operator|&&
operator|(
name|mt2
operator|&
name|MPTR
operator|)
condition|)
return|return
operator|(
name|TYPR
operator|+
name|CVTL
operator|)
return|;
block|}
name|uerror
argument_list|(
literal|"operands of %s have incompatible types"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NCVT
operator|)
return|;
block|}
end_block

begin_macro
name|moditype
argument_list|(
argument|ty
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|ty
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|ty
condition|)
block|{
case|case
name|ENUMTY
case|:
case|case
name|MOETY
case|:
return|return
operator|(
name|MENU
operator|)
return|;
case|case
name|STRTY
case|:
case|case
name|UNIONTY
case|:
return|return
operator|(
name|MSTR
operator|)
return|;
case|case
name|CHAR
case|:
case|case
name|SHORT
case|:
case|case
name|UCHAR
case|:
case|case
name|USHORT
case|:
return|return
operator|(
name|MINT
operator||
name|MDBI
operator|)
return|;
case|case
name|UNSIGNED
case|:
case|case
name|ULONG
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
return|return
operator|(
name|MINT
operator||
name|MDBI
operator||
name|MPTI
operator|)
return|;
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
return|return
operator|(
name|MDBI
operator|)
return|;
default|default:
return|return
operator|(
name|MPTR
operator||
name|MPTI
operator|)
return|;
block|}
block|}
end_block

begin_function
name|NODE
modifier|*
name|doszof
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* do sizeof p */
name|int
name|i
decl_stmt|;
comment|/* whatever is the meaning of this if it is a bitfield? */
name|i
operator|=
name|tsize
argument_list|(
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|csiz
argument_list|)
operator|/
name|SZCHAR
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|werror
argument_list|(
literal|"sizeof returns 0"
argument_list|)
expr_stmt|;
return|return
operator|(
name|bcon
argument_list|(
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|eprint
argument_list|(
name|p
argument_list|,
name|down
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ty
expr_stmt|;
operator|*
name|a
operator|=
operator|*
name|b
operator|=
name|down
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|down
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|down
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|down
condition|)
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%o) %s, "
argument_list|,
name|p
argument_list|,
name|opst
index|[
name|p
operator|->
name|op
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|LTYPE
condition|)
block|{
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d, "
argument_list|,
name|p
operator|->
name|rval
argument_list|)
expr_stmt|;
block|}
name|tprint
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d, %d\n"
argument_list|,
name|p
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|csiz
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|prtdcon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|FCON
condition|)
block|{
name|locctr
argument_list|(
name|DATA
argument_list|)
expr_stmt|;
name|defalign
argument_list|(
name|ALDOUBLE
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|i
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|fincode
argument_list|(
name|p
operator|->
name|dval
argument_list|,
name|SZDOUBLE
argument_list|)
expr_stmt|;
name|p
operator|->
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rval
operator|=
operator|-
name|i
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|DOUBLE
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|NAME
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|int
name|edebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ecomp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|edebug
condition|)
name|fwalk
argument_list|(
name|p
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reached
condition|)
block|{
name|werror
argument_list|(
literal|"statement not reached"
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|optim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|walkf
argument_list|(
name|p
argument_list|,
name|prtdcon
argument_list|)
expr_stmt|;
name|locctr
argument_list|(
name|PROG
argument_list|)
expr_stmt|;
name|ecode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STDPRTREE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_expr_stmt
name|prtree
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
specifier|register
name|ty
expr_stmt|;
ifdef|#
directive|ifdef
name|MYPRTREE
name|MYPRTREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* local action can be taken here; then return... */
endif|#
directive|endif
name|ty
operator|=
name|optype
argument_list|(
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\t"
argument_list|,
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|LTYPE
condition|)
block|{
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ty
operator|!=
name|BITYPE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|op
operator|==
name|ICON
condition|)
name|printf
argument_list|(
literal|"0\t"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d\t"
argument_list|,
name|p
operator|->
name|rval
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%o\t"
argument_list|,
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* handle special cases */
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|NAME
case|:
case|case
name|ICON
case|:
comment|/* print external name */
if|if
condition|(
name|p
operator|->
name|rval
operator|==
name|NONAME
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|rval
operator|>=
literal|0
condition|)
block|{
name|q
operator|=
operator|&
name|stab
index|[
name|p
operator|->
name|rval
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|exname
argument_list|(
name|q
operator|->
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* label */
name|printf
argument_list|(
name|LABFMT
argument_list|,
operator|-
name|p
operator|->
name|rval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STARG
case|:
case|case
name|STASG
case|:
case|case
name|STCALL
case|:
case|case
name|UNARY
name|STCALL
case|:
comment|/* print out size */
comment|/* use lhs size, in order to avoid hassles with the structure `.' operator */
comment|/* note: p->left not a field... */
name|printf
argument_list|(
name|CONFMT
argument_list|,
operator|(
name|CONSZ
operator|)
name|tsize
argument_list|(
name|STRTY
argument_list|,
name|p
operator|->
name|left
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|left
operator|->
name|csiz
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d\t\n"
argument_list|,
name|talign
argument_list|(
name|STRTY
argument_list|,
name|p
operator|->
name|left
operator|->
name|csiz
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|prtree
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|prtree
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|p2tree
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ty
expr_stmt|;
ifdef|#
directive|ifdef
name|MYP2TREE
name|MYP2TREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* local action can be taken here; then return... */
endif|#
directive|endif
name|ty
operator|=
name|optype
argument_list|(
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|NAME
case|:
case|case
name|ICON
case|:
if|if
condition|(
name|p
operator|->
name|rval
operator|==
name|NONAME
condition|)
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|rval
operator|>=
literal|0
condition|)
block|{
comment|/* copy name from exname */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|cp
operator|=
name|exname
argument_list|(
name|stab
index|[
name|p
operator|->
name|rval
index|]
operator|.
name|sname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|name
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|LABFMT
argument_list|,
operator|-
name|p
operator|->
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|STARG
case|:
case|case
name|STASG
case|:
case|case
name|STCALL
case|:
case|case
name|UNARY
name|STCALL
case|:
comment|/* set up size parameters */
name|p
operator|->
name|stsize
operator|=
operator|(
name|tsize
argument_list|(
name|STRTY
argument_list|,
name|p
operator|->
name|left
operator|->
name|cdim
argument_list|,
name|p
operator|->
name|left
operator|->
name|csiz
argument_list|)
operator|+
name|SZCHAR
operator|-
literal|1
operator|)
operator|/
name|SZCHAR
expr_stmt|;
name|p
operator|->
name|stalign
operator|=
name|talign
argument_list|(
name|STRTY
argument_list|,
name|p
operator|->
name|left
operator|->
name|csiz
argument_list|)
operator|/
name|SZCHAR
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|rbusy
argument_list|(
name|p
operator|->
name|rval
argument_list|,
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
default|default:
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|p
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|p2tree
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|p2tree
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

