begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_function_decl
name|PROC
name|BOOL
name|chkid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|NAMNOD
name|ps2nod
init|=
block|{
name|NIL
block|,
name|NIL
block|,
name|ps2name
block|}
decl_stmt|,
name|fngnod
init|=
block|{
name|NIL
block|,
name|NIL
block|,
name|fngname
block|}
decl_stmt|,
name|pathnod
init|=
block|{
name|NIL
block|,
name|NIL
block|,
name|pathname
block|}
decl_stmt|,
name|ifsnod
init|=
block|{
name|NIL
block|,
name|NIL
block|,
name|ifsname
block|}
decl_stmt|,
name|ps1nod
init|=
block|{
operator|&
name|pathnod
block|,
operator|&
name|ps2nod
block|,
name|ps1name
block|}
decl_stmt|,
name|homenod
init|=
block|{
operator|&
name|fngnod
block|,
operator|&
name|ifsnod
block|,
name|homename
block|}
decl_stmt|,
name|mailnod
init|=
block|{
operator|&
name|homenod
block|,
operator|&
name|ps1nod
block|,
name|mailname
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NAMPTR
name|namep
init|=
operator|&
name|mailnod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========	variable and string handling	======== */
end_comment

begin_macro
name|syslook
argument_list|(
argument|w
argument_list|,
argument|syswds
argument_list|)
end_macro

begin_decl_stmt
name|STRING
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SYSTAB
name|syswds
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|CHAR
name|first
decl_stmt|;
name|REG
name|STRING
name|s
decl_stmt|;
name|REG
name|SYSPTR
name|syscan
decl_stmt|;
name|syscan
operator|=
name|syswds
expr_stmt|;
name|first
operator|=
operator|*
name|w
expr_stmt|;
name|WHILE
name|s
init|=
name|syscan
operator|->
name|sysnam
name|DO
name|IF
name|first
operator|==
operator|*
name|s
name|ANDF
name|eq
argument_list|(
argument|w
argument_list|,
argument|s
argument_list|)
name|THEN
return|return
operator|(
name|syscan
operator|->
name|sysval
operator|)
return|;
name|FI
name|syscan
operator|++
expr_stmt|;
name|OD
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|setlist
argument_list|(
argument|arg
argument_list|,
argument|xp
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|ARGPTR
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|xp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|WHILE
name|arg
name|DO
name|REG
name|STRING
name|s
init|=
name|mactrim
argument_list|(
name|arg
operator|->
name|argval
argument_list|)
decl_stmt|;
name|setname
argument_list|(
name|s
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|arg
operator|=
name|arg
operator|->
name|argnxt
expr_stmt|;
name|IF
name|flags
modifier|&
name|execpr
name|THEN
name|prs
parameter_list|(
name|s
parameter_list|)
function_decl|;
name|IF
name|arg
name|THEN
name|blank
parameter_list|()
function_decl|;
name|ELSE
name|newline
parameter_list|()
function_decl|;
name|FI
name|FI
name|OD
block|}
end_block

begin_function
name|VOID
name|setname
parameter_list|(
name|argi
parameter_list|,
name|xp
parameter_list|)
name|STRING
name|argi
decl_stmt|;
name|INT
name|xp
decl_stmt|;
block|{
name|REG
name|STRING
name|argscan
init|=
name|argi
decl_stmt|;
name|REG
name|NAMPTR
name|n
decl_stmt|;
name|IF
name|letter
argument_list|(
operator|*
name|argscan
argument_list|)
name|THEN
name|WHILE
name|alphanum
argument_list|(
operator|*
name|argscan
argument_list|)
name|DO
name|argscan
decl|++
name|OD
name|IF
modifier|*
name|argscan
decl|=='='
name|THEN
modifier|*
name|argscan
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|lookup
argument_list|(
name|argi
argument_list|)
expr_stmt|;
operator|*
name|argscan
operator|++
operator|=
literal|'='
expr_stmt|;
name|attrib
argument_list|(
name|n
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|IF
name|xp
modifier|&
name|N_ENVNAM
name|THEN
name|n
operator|->
name|namenv
init|=
name|n
operator|->
name|namval
operator|=
name|argscan
decl_stmt|;
name|ELSE
name|assign
argument_list|(
name|n
argument_list|,
name|argscan
argument_list|)
decl_stmt|;
name|FI
return|return;
name|FI
name|FI
name|failed
argument_list|(
name|argi
argument_list|,
name|notid
argument_list|)
decl_stmt|;
block|}
end_function

begin_macro
name|replace
argument_list|(
argument|a
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|STRING
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|free
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
operator|*
name|a
operator|=
name|make
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dfault
argument_list|(
argument|n
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|NAMPTR
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IF
name|n
operator|->
name|namval
operator|==
literal|0
name|THEN
name|assign
argument_list|(
argument|n
argument_list|,
argument|v
argument_list|)
name|FI
block|}
end_block

begin_macro
name|assign
argument_list|(
argument|n
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|NAMPTR
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IF
name|n
operator|->
name|namflg
modifier|&
name|N_RDONLY
name|THEN
name|failed
parameter_list|(
name|n
operator|->
name|namid
parameter_list|,
name|wtfailed
parameter_list|)
function_decl|;
name|ELSE
name|replace
argument_list|(
operator|&
name|n
operator|->
name|namval
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|FI
block|}
end_block

begin_function
name|INT
name|readvar
parameter_list|(
name|names
parameter_list|)
name|STRING
modifier|*
name|names
decl_stmt|;
block|{
name|FILEBLK
name|fb
decl_stmt|;
name|REG
name|FILE
name|f
init|=
operator|&
name|fb
decl_stmt|;
name|REG
name|CHAR
name|c
decl_stmt|;
name|REG
name|INT
name|rc
init|=
literal|0
decl_stmt|;
name|NAMPTR
name|n
init|=
name|lookup
argument_list|(
operator|*
name|names
operator|++
argument_list|)
decl_stmt|;
comment|/* done now to avoid storage mess */
name|STKPTR
name|rel
init|=
name|relstak
argument_list|()
decl_stmt|;
name|push
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|initf
argument_list|(
name|dup
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|IF
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
decl|==-1
name|THEN
name|f
operator|->
name|fsiz
init|=
literal|1
decl_stmt|;
name|FI
name|LOOP
name|c
init|=
name|nextc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|IF
argument_list|(
argument|*names ANDF any(c, ifsnod.namval)
argument_list|)
name|ORF
name|eolchar
argument_list|(
name|c
argument_list|)
name|THEN
name|zerostak
argument_list|()
decl_stmt|;
name|assign
argument_list|(
name|n
argument_list|,
name|absstak
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|setstak
argument_list|(
name|rel
argument_list|)
expr_stmt|;
name|IF
modifier|*
name|names
name|THEN
name|n
init|=
name|lookup
argument_list|(
operator|*
name|names
operator|++
argument_list|)
decl_stmt|;
name|ELSE
name|n
init|=
literal|0
decl_stmt|;
name|FI
name|IF
name|eolchar
argument_list|(
name|c
argument_list|)
name|THEN
decl|break
decl_stmt|;
name|FI
name|ELSE
name|pushstak
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|FI
name|POOL
name|WHILE
name|n
name|DO
name|assign
argument_list|(
name|n
argument_list|,
name|nullstr
argument_list|)
decl_stmt|;
name|IF
modifier|*
name|names
name|THEN
name|n
init|=
name|lookup
argument_list|(
operator|*
name|names
operator|++
argument_list|)
decl_stmt|;
name|ELSE
name|n
init|=
literal|0
decl_stmt|;
name|FI
name|OD
name|IF
name|eof
name|THEN
name|rc
init|=
literal|1
name|FI
name|lseek
argument_list|(
literal|0
argument_list|,
call|(
name|long
call|)
argument_list|(
name|f
operator|->
name|fnxt
operator|-
name|f
operator|->
name|fend
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_macro
name|assnum
argument_list|(
argument|p
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|STRING
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INT
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|itos
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|replace
argument_list|(
name|p
argument_list|,
name|numbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|STRING
name|make
parameter_list|(
name|v
parameter_list|)
name|STRING
name|v
decl_stmt|;
block|{
name|REG
name|STRING
name|p
decl_stmt|;
name|IF
name|v
name|THEN
name|movstr
parameter_list|(
name|v
parameter_list|,
name|p
init|=
name|alloc
argument_list|(
name|length
argument_list|(
name|v
argument_list|)
parameter_list|)
block|)
function|;
end_function

begin_return
return|return
operator|(
name|p
operator|)
return|;
end_return

begin_macro
name|ELSE
end_macro

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_expr_stmt
name|FI
end_expr_stmt

begin_macro
unit|}   NAMPTR
name|lookup
argument_list|(
argument|nam
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|STRING
name|nam
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|NAMPTR
name|nscan
init|=
name|namep
decl_stmt|;
name|REG
name|NAMPTR
modifier|*
name|prev
decl_stmt|;
name|INT
name|LR
decl_stmt|;
name|IF
operator|!
name|chkid
argument_list|(
argument|nam
argument_list|)
name|THEN
name|failed
argument_list|(
name|nam
argument_list|,
name|notid
argument_list|)
expr_stmt|;
name|FI
name|WHILE
name|nscan
name|DO
name|IF
argument_list|(
name|LR
operator|=
name|cf
argument_list|(
name|nam
argument_list|,
name|nscan
operator|->
name|namid
argument_list|)
argument_list|)
decl|==0
name|THEN
decl|return
argument_list|(
name|nscan
argument_list|)
decl_stmt|;
name|ELIF
name|LR
operator|<
literal|0
name|THEN
name|prev
operator|=
operator|&
operator|(
name|nscan
operator|->
name|namlft
operator|)
expr_stmt|;
name|ELSE
name|prev
init|=
operator|&
operator|(
name|nscan
operator|->
name|namrgt
operator|)
decl_stmt|;
name|FI
name|nscan
init|=
operator|*
name|prev
decl_stmt|;
name|OD
comment|/* add name node */
name|nscan
init|=
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|nscan
argument_list|)
decl_stmt|;
name|nscan
operator|->
name|namlft
operator|=
name|nscan
operator|->
name|namrgt
operator|=
name|NIL
expr_stmt|;
name|nscan
operator|->
name|namid
operator|=
name|make
argument_list|(
name|nam
argument_list|)
expr_stmt|;
name|nscan
operator|->
name|namval
operator|=
literal|0
expr_stmt|;
name|nscan
operator|->
name|namflg
operator|=
name|N_DEFAULT
expr_stmt|;
name|nscan
operator|->
name|namenv
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|*
name|prev
operator|=
name|nscan
operator|)
return|;
block|}
end_block

begin_function
name|LOCAL
name|BOOL
name|chkid
parameter_list|(
name|nam
parameter_list|)
name|STRING
name|nam
decl_stmt|;
block|{
name|REG
name|CHAR
modifier|*
name|cp
init|=
name|nam
decl_stmt|;
name|IF
operator|!
name|letter
argument_list|(
argument|*cp
argument_list|)
name|THEN
return|return
operator|(
name|FALSE
operator|)
return|;
name|ELSE
name|WHILE
operator|*
operator|++
name|cp
name|DO
name|IF
operator|!
name|alphanum
argument_list|(
argument|*cp
argument_list|)
name|THEN
return|return
operator|(
name|FALSE
operator|)
return|;
name|FI
name|OD
name|FI
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function_decl
name|LOCAL
name|VOID
function_decl|(
modifier|*
name|namfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|namscan
function_decl|(
name|fn
function_decl|)
name|VOID
argument_list|(
argument|*fn
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|namfn
operator|=
name|fn
expr_stmt|;
name|namwalk
argument_list|(
name|namep
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|VOID
name|namwalk
parameter_list|(
name|np
parameter_list|)
name|REG
name|NAMPTR
name|np
decl_stmt|;
block|{
name|IF
name|np
name|THEN
name|namwalk
argument_list|(
name|np
operator|->
name|namlft
argument_list|)
decl_stmt|;
call|(
modifier|*
name|namfn
call|)
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|namwalk
argument_list|(
name|np
operator|->
name|namrgt
argument_list|)
expr_stmt|;
name|FI
block|}
end_function

begin_function
name|VOID
name|printnam
parameter_list|(
name|n
parameter_list|)
name|NAMPTR
name|n
decl_stmt|;
block|{
name|REG
name|STRING
name|s
decl_stmt|;
name|sigchk
argument_list|()
expr_stmt|;
name|IF
name|s
init|=
name|n
operator|->
name|namval
name|THEN
name|prs
argument_list|(
name|n
operator|->
name|namid
argument_list|)
decl_stmt|;
name|prc
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|FI
block|}
end_function

begin_function
name|LOCAL
name|STRING
name|staknam
parameter_list|(
name|n
parameter_list|)
name|REG
name|NAMPTR
name|n
decl_stmt|;
block|{
name|REG
name|STRING
name|p
decl_stmt|;
name|p
operator|=
name|movstr
argument_list|(
name|n
operator|->
name|namid
argument_list|,
name|staktop
argument_list|)
expr_stmt|;
name|p
operator|=
name|movstr
argument_list|(
literal|"="
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|movstr
argument_list|(
name|n
operator|->
name|namval
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|getstak
argument_list|(
name|p
operator|+
literal|1
operator|-
name|ADR
argument_list|(
name|stakbot
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|VOID
name|exname
parameter_list|(
name|n
parameter_list|)
name|REG
name|NAMPTR
name|n
decl_stmt|;
block|{
name|IF
name|n
operator|->
name|namflg
modifier|&
name|N_EXPORT
name|THEN
name|free
argument_list|(
name|n
operator|->
name|namenv
argument_list|)
decl_stmt|;
name|n
operator|->
name|namenv
operator|=
name|make
argument_list|(
name|n
operator|->
name|namval
argument_list|)
expr_stmt|;
name|ELSE
name|free
argument_list|(
name|n
operator|->
name|namval
argument_list|)
decl_stmt|;
name|n
operator|->
name|namval
operator|=
name|make
argument_list|(
name|n
operator|->
name|namenv
argument_list|)
expr_stmt|;
name|FI
block|}
end_function

begin_function
name|VOID
name|printflg
parameter_list|(
name|n
parameter_list|)
name|REG
name|NAMPTR
name|n
decl_stmt|;
block|{
name|IF
name|n
operator|->
name|namflg
modifier|&
name|N_EXPORT
name|THEN
name|prs
argument_list|(
name|export
argument_list|)
decl_stmt|;
name|blank
argument_list|()
expr_stmt|;
name|FI
name|IF
name|n
operator|->
name|namflg
modifier|&
name|N_RDONLY
name|THEN
name|prs
argument_list|(
name|readonly
argument_list|)
decl_stmt|;
name|blank
argument_list|()
expr_stmt|;
name|FI
name|IF
name|n
operator|->
name|namflg
modifier|&
argument_list|(
name|N_EXPORT
operator||
name|N_RDONLY
argument_list|)
name|THEN
name|prs
argument_list|(
name|n
operator|->
name|namid
argument_list|)
decl_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|FI
block|}
end_function

begin_function
name|VOID
name|getenv
parameter_list|()
block|{
name|REG
name|STRING
modifier|*
name|e
init|=
name|environ
decl_stmt|;
name|WHILE
modifier|*
name|e
name|DO
name|setname
argument_list|(
operator|*
name|e
operator|++
argument_list|,
name|N_ENVNAM
argument_list|)
name|OD
block|}
end_function

begin_decl_stmt
name|LOCAL
name|INT
name|namec
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|countnam
parameter_list|(
name|n
parameter_list|)
name|NAMPTR
name|n
decl_stmt|;
block|{
name|namec
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|LOCAL
name|STRING
modifier|*
name|argnam
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|pushnam
parameter_list|(
name|n
parameter_list|)
name|NAMPTR
name|n
decl_stmt|;
block|{
name|IF
name|n
operator|->
name|namval
name|THEN
operator|*
name|argnam
operator|++
operator|=
name|staknam
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|FI
block|}
end_function

begin_function
name|STRING
modifier|*
name|setenv
parameter_list|()
block|{
name|REG
name|STRING
modifier|*
name|er
decl_stmt|;
name|namec
operator|=
literal|0
expr_stmt|;
name|namscan
argument_list|(
name|countnam
argument_list|)
expr_stmt|;
name|argnam
operator|=
name|er
operator|=
name|getstak
argument_list|(
name|namec
operator|*
name|BYTESPERWORD
operator|+
name|BYTESPERWORD
argument_list|)
expr_stmt|;
name|namscan
argument_list|(
name|pushnam
argument_list|)
expr_stmt|;
operator|*
name|argnam
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|er
operator|)
return|;
block|}
end_function

end_unit

