begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * C compiler  *  *  */
end_comment

begin_include
include|#
directive|include
file|"c0.h"
end_include

begin_comment
comment|/*  * Reduce the degree-of-reference by one.  * e.g. turn "ptr-to-int" into "int".  */
end_comment

begin_macro
name|decref
argument_list|(
argument|at
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|t
expr_stmt|;
name|t
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|&
operator|~
name|TYPE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Illegal indirection"
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|t
operator|>>
name|TYLEN
operator|)
operator|&
operator|~
name|TYPE
operator||
name|t
operator|&
name|TYPE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Increase the degree of reference by  * one; e.g. turn "int" to "ptr-to-int".  */
end_comment

begin_macro
name|incref
argument_list|(
argument|t
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
operator|(
name|t
operator|&
operator|~
name|TYPE
operator|)
operator|<<
name|TYLEN
operator|)
operator||
operator|(
name|t
operator|&
name|TYPE
operator|)
operator||
name|PTR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Make a tree that causes a branch to lbl  * if the tree's value is non-zero together with the cond.  */
end_comment

begin_macro
name|cbranch
argument_list|(
argument|t
argument_list|,
argument|lbl
argument_list|,
argument|cond
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|treeout
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BNNN"
argument_list|,
name|CBRANCH
argument_list|,
name|lbl
argument_list|,
name|cond
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write out a tree.  */
end_comment

begin_macro
name|rcexpr
argument_list|(
argument|atp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Special optimization 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|atp
operator|)
operator|->
name|op
operator|==
name|INIT
operator|&&
name|tp
operator|->
name|tr1
operator|->
name|op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|type
operator|==
name|CHAR
condition|)
block|{
name|outcode
argument_list|(
literal|"B1N0"
argument_list|,
name|BDATA
argument_list|,
name|tp
operator|->
name|tr1
operator|->
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|type
operator|==
name|INT
operator|||
name|tp
operator|->
name|type
operator|==
name|UNSIGN
condition|)
block|{
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|SINIT
argument_list|,
name|tp
operator|->
name|tr1
operator|->
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|treeout
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|EXPR
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|treeout
argument_list|(
argument|atp
argument_list|,
argument|isstruct
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|hp
decl_stmt|;
specifier|register
name|nextisstruct
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|atp
operator|)
operator|==
literal|0
condition|)
block|{
name|outcode
argument_list|(
literal|"B"
argument_list|,
name|NULLOP
argument_list|)
expr_stmt|;
return|return;
block|}
name|nextisstruct
operator|=
name|tp
operator|->
name|type
operator|==
name|STRUCT
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|hp
operator|=
name|tp
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|hclass
operator|==
name|TYPEDEF
condition|)
name|error
argument_list|(
literal|"Illegal use of type name"
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BNN"
argument_list|,
name|NAME
argument_list|,
name|hp
operator|->
name|hclass
operator|==
literal|0
condition|?
name|STATIC
else|:
name|hp
operator|->
name|hclass
argument_list|,
name|tp
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|hclass
operator|==
name|EXTERN
condition|)
name|outcode
argument_list|(
literal|"S"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|outcode
argument_list|(
literal|"N"
argument_list|,
name|hp
operator|->
name|hoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|LCON
case|:
name|outcode
argument_list|(
literal|"BNNN"
argument_list|,
name|tp
operator|->
name|op
argument_list|,
name|tp
operator|->
name|type
argument_list|,
name|tp
operator|->
name|lvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|CON
case|:
name|outcode
argument_list|(
literal|"BNN"
argument_list|,
name|tp
operator|->
name|op
argument_list|,
name|tp
operator|->
name|type
argument_list|,
name|tp
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCON
case|:
name|outcode
argument_list|(
literal|"BNF"
argument_list|,
name|tp
operator|->
name|op
argument_list|,
name|tp
operator|->
name|type
argument_list|,
name|tp
operator|->
name|cstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|outcode
argument_list|(
literal|"BNNN"
argument_list|,
name|NAME
argument_list|,
name|STATIC
argument_list|,
name|tp
operator|->
name|type
argument_list|,
name|tp
operator|->
name|tr1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSEL
case|:
name|treeout
argument_list|(
name|tp
operator|->
name|tr1
argument_list|,
name|nextisstruct
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BNNN"
argument_list|,
name|tp
operator|->
name|op
argument_list|,
name|tp
operator|->
name|type
argument_list|,
name|tp
operator|->
name|tr2
operator|->
name|bitoffs
argument_list|,
name|tp
operator|->
name|tr2
operator|->
name|flen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETYPE
case|:
name|error
argument_list|(
literal|"Illegal use of type"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMPER
case|:
name|treeout
argument_list|(
name|tp
operator|->
name|tr1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|tp
operator|->
name|op
argument_list|,
name|tp
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|treeout
argument_list|(
name|tp
operator|->
name|tr1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|treeout
argument_list|(
name|tp
operator|->
name|tr2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|CALL
argument_list|,
name|tp
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|treeout
argument_list|(
name|tp
operator|->
name|tr1
argument_list|,
name|nextisstruct
argument_list|)
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|tp
operator|->
name|op
index|]
operator|&
name|BINARY
condition|)
name|treeout
argument_list|(
name|tp
operator|->
name|tr2
argument_list|,
name|nextisstruct
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|tp
operator|->
name|op
argument_list|,
name|tp
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nextisstruct
operator|&&
name|isstruct
operator|==
literal|0
condition|)
name|outcode
argument_list|(
literal|"BNN"
argument_list|,
name|STRASG
argument_list|,
name|STRUCT
argument_list|,
name|tp
operator|->
name|strp
operator|->
name|ssize
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate a branch  */
end_comment

begin_macro
name|branch
argument_list|(
argument|lab
argument_list|)
end_macro

begin_block
block|{
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|BRANCH
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate a label  */
end_comment

begin_macro
name|label
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|LABEL
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * ap is a tree node whose type  * is some kind of pointer; return the size of the object  * to which the pointer points.  */
end_comment

begin_macro
name|plength
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tname
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|t
operator|,
name|l
expr_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
operator|(
operator|(
name|t
operator|=
name|p
operator|->
name|type
operator|)
operator|&
operator|~
name|TYPE
operator|)
operator|==
literal|0
condition|)
comment|/* not a reference */
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|type
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|l
operator|=
name|length
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * return the number of bytes in the object  * whose tree node is acs.  */
end_comment

begin_macro
name|length
argument_list|(
argument|acs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|acs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|t
operator|,
name|elsz
expr_stmt|;
name|long
name|n
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|cs
decl_stmt|;
name|int
name|nd
decl_stmt|;
name|cs
operator|=
name|acs
expr_stmt|;
name|t
operator|=
name|cs
operator|->
name|type
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
name|nd
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|&
name|XTYPE
operator|)
operator|==
name|ARRAY
condition|)
block|{
name|t
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cs
operator|->
name|subsp
index|[
name|nd
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|&
operator|~
name|TYPE
operator|)
operator|==
name|FUNC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|t
operator|>=
name|PTR
condition|)
name|elsz
operator|=
name|SZPTR
expr_stmt|;
else|else
switch|switch
condition|(
name|t
operator|&
name|TYPE
condition|)
block|{
case|case
name|INT
case|:
case|case
name|UNSIGN
case|:
name|elsz
operator|=
name|SZINT
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|elsz
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|elsz
operator|=
name|SZFLOAT
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|elsz
operator|=
name|SZLONG
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|elsz
operator|=
name|SZDOUB
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
if|if
condition|(
operator|(
name|elsz
operator|=
name|cs
operator|->
name|strp
operator|->
name|ssize
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Undefined structure"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Compiler error (length)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|*=
name|elsz
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|unsigned
operator|)
literal|50000
condition|)
block|{
name|error
argument_list|(
literal|"Warning: very large data structure"
argument_list|)
expr_stmt|;
name|nerror
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The number of bytes in an object, rounded up to a word.  */
end_comment

begin_macro
name|rlength
argument_list|(
argument|cs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|cs
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|length
argument_list|(
name|cs
argument_list|)
operator|+
name|ALIGN
operator|)
operator|&
operator|~
name|ALIGN
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * After an "if (...) goto", look to see if the transfer  * is to a simple label.  */
end_comment

begin_macro
name|simplegoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hshtab
modifier|*
name|csp
decl_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|NAME
operator|&&
name|nextchar
argument_list|()
operator|==
literal|';'
condition|)
block|{
name|csp
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|hblklev
operator|==
literal|0
condition|)
name|pushdecl
argument_list|(
name|csp
argument_list|)
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|hclass
operator|==
literal|0
operator|&&
name|csp
operator|->
name|htype
operator|==
literal|0
condition|)
block|{
name|csp
operator|->
name|htype
operator|=
name|ARRAY
expr_stmt|;
name|csp
operator|->
name|hflag
operator|=
operator||
name|FLABL
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|hoffset
operator|==
literal|0
condition|)
name|csp
operator|->
name|hoffset
operator|=
name|isn
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csp
operator|->
name|hclass
operator|==
literal|0
operator|||
name|csp
operator|->
name|hclass
operator|==
name|STATIC
operator|)
operator|&&
name|csp
operator|->
name|htype
operator|==
name|ARRAY
condition|)
block|{
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|csp
operator|->
name|hoffset
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the next non-white-space character  */
end_comment

begin_macro
name|nextchar
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|spnextchar
argument_list|()
operator|==
literal|' '
condition|)
name|peekc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|peekc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the next character, translating all white space  * to blank and handling line-ends.  */
end_comment

begin_macro
name|spnextchar
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|peekc
operator|)
operator|==
literal|0
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\014'
condition|)
comment|/* FF */
name|c
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|inhdr
operator|==
literal|0
condition|)
name|line
operator|++
expr_stmt|;
name|inhdr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\001'
condition|)
block|{
comment|/* SOH, insert marker */
name|inhdr
operator|++
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
name|peekc
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * is a break or continue legal?  */
end_comment

begin_macro
name|chconbrk
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Break/continue error"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The goto statement.  */
end_comment

begin_macro
name|dogoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|np
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tree
argument_list|()
expr_stmt|;
name|build
argument_list|(
name|STAR
argument_list|)
expr_stmt|;
name|chkw
argument_list|(
name|np
operator|=
operator|*
operator|--
name|cp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
name|block
argument_list|(
name|JUMP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The return statement, which has to convert  * the returned object to the function's type.  */
end_comment

begin_macro
name|doret
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|nextchar
argument_list|()
operator|!=
literal|';'
condition|)
block|{
name|t
operator|=
name|tree
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|&
name|funcblk
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|t
expr_stmt|;
name|build
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
name|cp
index|[
operator|-
literal|1
index|]
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|funcblk
operator|.
name|type
operator|==
name|CHAR
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
name|block
argument_list|(
name|ITOC
argument_list|,
name|INT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|build
argument_list|(
name|RFORCE
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
block|}
name|branch
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write a character on the error output.  */
end_comment

begin_comment
comment|/*  * Coded output:  *   B: beginning of line; an operator  *   N: a number  *   S: a symbol (external)  *   1: number 1  *   0: number 0  */
end_comment

begin_macro
name|outcode
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|ap
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|bufp
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
name|bufp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|strflg
condition|)
name|bufp
operator|=
name|sbufp
expr_stmt|;
name|ap
operator|=
operator|&
name|a
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'B'
case|:
name|putc
argument_list|(
operator|*
name|ap
operator|++
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0376
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'N'
case|:
name|putc
argument_list|(
operator|*
name|ap
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|ap
operator|++
operator|>>
literal|8
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
name|n
operator|=
literal|1000
expr_stmt|;
name|np
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
goto|goto
name|str
goto|;
case|case
literal|'S'
case|:
name|n
operator|=
name|NCPS
expr_stmt|;
name|np
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|np
condition|)
name|putc
argument_list|(
literal|'_'
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|str
label|:
while|while
condition|(
name|n
operator|--
operator|&&
operator|*
name|np
condition|)
block|{
name|putc
argument_list|(
operator|*
name|np
operator|++
operator|&
literal|0177
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|0
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
name|putc
argument_list|(
literal|1
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
name|putc
argument_list|(
literal|0
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
if|if
condition|(
name|ferror
argument_list|(
name|bufp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Write error on temp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|error
argument_list|(
literal|"Botch in outcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

