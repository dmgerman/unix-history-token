begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  	    	C compiler, part 2   */
end_comment

begin_include
include|#
directive|include
file|"c1.h"
end_include

begin_define
define|#
directive|define
name|dbprint
parameter_list|(
name|op
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dbprint
parameter_list|(
name|op
parameter_list|)
value|printf("	/ %s", opntab[op])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|maprel
index|[]
block|{
name|EQUAL
operator|,
name|NEQUAL
operator|,
name|GREATEQ
operator|,
name|GREAT
operator|,
name|LESSEQ
operator|,
name|LESS
operator|,
name|GREATQP
operator|,
name|GREATP
operator|,
name|LESSEQP
operator|,
name|LESSP
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
name|notrel
index|[]
block|{
name|NEQUAL
operator|,
name|EQUAL
operator|,
name|GREAT
operator|,
name|GREATEQ
operator|,
name|LESS
operator|,
name|LESSEQ
operator|,
name|GREATP
operator|,
name|GREATQP
operator|,
name|LESSP
operator|,
name|LESSEQP
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|tconst
name|czero
block|{
name|CON
operator|,
name|INT
operator|,
literal|0
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tconst
name|cone
block|{
name|CON
operator|,
name|INT
operator|,
literal|1
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tname
name|sfuncr
block|{
name|NAME
operator|,
name|STRUCT
operator|,
name|STATIC
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|table
modifier|*
name|cregtab
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|nreg
literal|3
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|isn
literal|10000
expr_stmt|;
end_expr_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|error
argument_list|(
literal|"Arg count"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Missing temp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|freopen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Can't create %s"
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|funcbase
operator|=
name|curbase
operator|=
name|coremax
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|getree
argument_list|()
expr_stmt|;
comment|/* 	 * If any floating-point instructions 	 * were used, generate a reference that 	 * pulls in the floating-point part of printf. 	 */
if|if
condition|(
name|nfloat
condition|)
name|printf
argument_list|(
literal|".globl	fltused\n"
argument_list|)
expr_stmt|;
comment|/* 	 * tack on the string file. 	 */
name|printf
argument_list|(
literal|".globl\n.data\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argv
index|[
literal|2
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Missing temp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|getree
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|totspace
operator|>=
operator|(
name|unsigned
operator|)
literal|56000
condition|)
block|{
name|error
argument_list|(
literal|"Warning: possibly too much data"
argument_list|)
expr_stmt|;
name|nerror
operator|--
expr_stmt|;
block|}
name|exit
argument_list|(
name|nerror
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a tree, a code table, and a  * count of available registers, find the code table  * for the appropriate operator such that the operands  * are of the right type and the number of registers  * required is not too large.  * Return a ptr to the table entry or 0 if none found.  */
end_comment

begin_function
name|char
modifier|*
name|match
parameter_list|(
name|atree
parameter_list|,
name|table
parameter_list|,
name|nrleft
parameter_list|,
name|nocvt
parameter_list|)
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
name|struct
name|table
modifier|*
name|table
decl_stmt|;
block|{
define|#
directive|define
name|NOCVL
value|1
define|#
directive|define
name|NOCVR
value|2
name|int
name|op
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|dope
decl_stmt|;
name|struct
name|tnode
modifier|*
name|p2
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p1
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
specifier|register
name|struct
name|optab
modifier|*
name|opt
decl_stmt|;
if|if
condition|(
operator|(
name|tree
operator|=
name|atree
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|table
operator|==
name|lsptab
condition|)
name|table
operator|=
name|sptab
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|=
name|tree
operator|->
name|op
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dope
operator|=
name|opdope
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dope
operator|&
name|LEAF
operator|)
operator|==
literal|0
condition|)
name|p1
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
else|else
name|p1
operator|=
name|tree
expr_stmt|;
name|d1
operator|=
name|dcalc
argument_list|(
name|p1
argument_list|,
name|nrleft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dope
operator|&
name|BINARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|p2
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
comment|/* 		 * If a subtree starts off with a conversion operator, 		 * try for a match with the conversion eliminated. 		 * E.g. int = double can be done without generating 		 * the converted int in a register by 		 * movf double,fr0; movfi fr0,int . 		 */
if|if
condition|(
name|opdope
index|[
name|p2
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|&&
operator|(
name|nocvt
operator|&
name|NOCVR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|opdope
index|[
name|p2
operator|->
name|tr1
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
operator|->
name|tr2
operator|=
name|p2
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|nrleft
argument_list|,
name|NOCVL
argument_list|)
condition|)
return|return
operator|(
name|opt
operator|)
return|;
name|tree
operator|->
name|tr2
operator|=
name|p2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opdope
index|[
name|p1
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|&&
operator|(
name|nocvt
operator|&
name|NOCVL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|opdope
index|[
name|p1
operator|->
name|tr1
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
operator|->
name|tr1
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|nrleft
argument_list|,
name|NOCVR
argument_list|)
condition|)
return|return
operator|(
name|opt
operator|)
return|;
name|tree
operator|->
name|tr1
operator|=
name|p1
expr_stmt|;
block|}
name|d2
operator|=
name|dcalc
argument_list|(
name|p2
argument_list|,
name|nrleft
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|table
operator|->
name|op
operator|!=
name|op
condition|;
name|table
operator|++
control|)
if|if
condition|(
name|table
operator|->
name|op
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|opt
operator|=
name|table
operator|->
name|tabp
init|;
name|opt
operator|->
name|tabdeg1
operator|!=
literal|0
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
name|d1
operator|>
operator|(
name|opt
operator|->
name|tabdeg1
operator|&
literal|077
operator|)
operator|||
operator|(
name|opt
operator|->
name|tabdeg1
operator|>=
literal|0100
operator|&&
operator|(
name|p1
operator|->
name|op
operator|!=
name|STAR
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|notcompat
argument_list|(
name|p1
argument_list|,
name|opt
operator|->
name|tabtyp1
argument_list|,
name|op
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|opdope
index|[
name|op
index|]
operator|&
name|BINARY
operator|)
operator|!=
literal|0
operator|&&
name|p2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|d2
operator|>
operator|(
name|opt
operator|->
name|tabdeg2
operator|&
literal|077
operator|)
operator|||
operator|(
name|opt
operator|->
name|tabdeg2
operator|>=
literal|0100
operator|)
operator|&&
operator|(
name|p2
operator|->
name|op
operator|!=
name|STAR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|notcompat
argument_list|(
name|p2
argument_list|,
name|opt
operator|->
name|tabtyp2
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
block|}
return|return
operator|(
name|opt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a tree, a code table, and a register,  * produce code to evaluate the tree with the appropriate table.  * Registers reg and upcan be used.  * If there is a value, it is desired that it appear in reg.  * The routine returns the register in which the value actually appears.  * This routine must work or there is an error.  * If the table called for is cctab, sptab, or efftab,  * and tree can't be done using the called-for table,  * another try is made.  * If the tree can't be compiled using cctab, regtab is  * used and a "tst" instruction is produced.  * If the tree can't be compiled using sptab,  * regtab is used and the register is pushed on the stack.  * If the tree can't be compiled using efftab,  * just use regtab.  * Regtab must succeed or an "op not found" error results.  *  * A number of special cases are recognized, and  * there is an interaction with the optimizer routines.  */
end_comment

begin_macro
name|rcexpr
argument_list|(
argument|atree
argument_list|,
argument|atable
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|atable
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
expr_stmt|;
name|int
name|modf
decl_stmt|,
name|nargs
decl_stmt|,
name|recurf
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
specifier|register
name|struct
name|table
modifier|*
name|table
decl_stmt|;
name|table
operator|=
name|atable
expr_stmt|;
name|recurf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
block|{
name|recurf
operator|++
expr_stmt|;
name|reg
operator|=
operator|~
name|reg
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|020
condition|)
block|{
name|reg
operator|=
operator|-
literal|020
expr_stmt|;
name|recurf
operator|++
expr_stmt|;
block|}
block|}
name|again
label|:
if|if
condition|(
operator|(
name|tree
operator|=
name|atree
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|opdope
index|[
name|tree
operator|->
name|op
index|]
operator|&
name|RELAT
operator|&&
name|tree
operator|->
name|tr2
operator|->
name|op
operator|==
name|CON
operator|&&
name|tree
operator|->
name|tr2
operator|->
name|value
operator|==
literal|0
operator|&&
name|table
operator|==
name|cctab
condition|)
name|tree
operator|=
name|atree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
comment|/* 	 * fieldselect(...) : in efftab mode, 	 * ignore the select, otherwise 	 * do the shift and mask. 	 */
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|FSELT
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|efftab
condition|)
name|atree
operator|=
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
else|else
block|{
name|tree
operator|->
name|op
operator|=
name|FSEL
expr_stmt|;
name|atree
operator|=
name|tree
operator|=
name|optim
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
comment|/* 	 * Structure assignments 	 */
case|case
name|STRASG
case|:
name|strasg
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * An initializing expression 	 */
case|case
name|INIT
case|:
name|tree
operator|=
name|optim
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|doinit
argument_list|(
name|tree
operator|->
name|type
argument_list|,
name|tree
operator|->
name|tr1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Put the value of an expression in r0, 	 * for a switch or a return 	 */
case|case
name|RFORCE
case|:
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|movreg
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
name|tree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * sequential execution 	 */
case|case
name|SEQNC
case|:
name|r
operator|=
name|nstack
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|efftab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|nstack
operator|=
name|r
expr_stmt|;
name|atree
operator|=
name|tree
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* 	 * In the generated&~ operator, 	 * fiddle things so a PDP-11 "bit" 	 * instruction will be produced when cctab is used. 	 */
case|case
name|ANDN
case|:
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
block|{
name|tree
operator|->
name|op
operator|=
name|TAND
expr_stmt|;
name|tree
operator|->
name|tr2
operator|=
name|optim
argument_list|(
name|tnode
argument_list|(
name|COMPL
argument_list|,
name|tree
operator|->
name|type
argument_list|,
name|tree
operator|->
name|tr2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Handle a subroutine call. It has to be done 	 * here because if cexpr got called twice, the 	 * arguments might be compiled twice. 	 * There is also some fiddling so the 	 * first argument, in favorable circumstances, 	 * goes to (sp) instead of -(sp), reducing 	 * the amount of stack-popping. 	 */
case|case
name|CALL
case|:
name|r
operator|=
literal|0
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
name|modf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|NAME
operator|||
name|tree
operator|->
name|tr1
operator|->
name|class
operator|!=
name|EXTERN
condition|)
block|{
name|nargs
operator|++
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
name|tree
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
condition|)
block|{
while|while
condition|(
name|tree
operator|->
name|op
operator|==
name|COMMA
condition|)
block|{
name|r
operator|=
operator|+
name|comarg
argument_list|(
name|tree
operator|->
name|tr2
argument_list|,
operator|&
name|modf
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
block|}
name|r
operator|=
operator|+
name|comarg
argument_list|(
name|tree
argument_list|,
operator|&
name|modf
argument_list|)
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
block|}
name|tree
operator|=
name|atree
expr_stmt|;
name|tree
operator|->
name|op
operator|=
name|CALL2
expr_stmt|;
if|if
condition|(
name|modf
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|class
operator|==
name|EXTERN
condition|)
name|tree
operator|->
name|op
operator|=
name|CALL1
expr_stmt|;
if|if
condition|(
name|cexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"compiler botch: call"
argument_list|)
expr_stmt|;
name|popstk
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|nstack
operator|=
operator|-
name|nargs
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|efftab
operator|||
name|table
operator|==
name|regtab
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
literal|0
expr_stmt|;
goto|goto
name|fixup
goto|;
comment|/* 	 * Longs need special treatment. 	 */
case|case
name|ASLSH
case|:
case|case
name|LSHIFT
case|:
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|LONG
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|tr2
operator|->
name|op
operator|==
name|ITOL
condition|)
name|tree
operator|->
name|tr2
operator|=
name|tree
operator|->
name|tr2
operator|->
name|tr1
expr_stmt|;
else|else
name|tree
operator|->
name|tr2
operator|=
name|optim
argument_list|(
name|tnode
argument_list|(
name|LTOI
argument_list|,
name|INT
argument_list|,
name|tree
operator|->
name|tr2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|ASLSH
condition|)
name|tree
operator|->
name|op
operator|=
name|ASLSHL
expr_stmt|;
else|else
name|tree
operator|->
name|op
operator|=
name|LLSHIFT
expr_stmt|;
block|}
break|break;
comment|/* 	 * Try to change * to shift. 	 */
case|case
name|TIMES
case|:
case|case
name|ASTIMES
case|:
name|tree
operator|=
name|pow2
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try to find postfix ++ and -- operators that can be 	 * pulled out and done after the rest of the expression 	 */
if|if
condition|(
name|table
operator|!=
name|cctab
operator|&&
name|table
operator|!=
name|cregtab
operator|&&
name|recurf
operator|<
literal|2
operator|&&
operator|(
name|opdope
index|[
name|tree
operator|->
name|op
index|]
operator|&
name|LEAF
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|=
name|delay
argument_list|(
operator|&
name|atree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|tree
operator|=
name|atree
expr_stmt|;
name|table
operator|=
name|efftab
expr_stmt|;
name|reg
operator|=
name|r
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Basically, try to reorder the computation 	 * so  reg = x+y  is done as  reg = x; reg =+ y 	 */
if|if
condition|(
name|recurf
operator|==
literal|0
operator|&&
name|reorder
argument_list|(
operator|&
name|atree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|cctab
operator|&&
name|atree
operator|->
name|op
operator|==
name|NAME
condition|)
return|return
operator|(
name|reg
operator|)
return|;
block|}
name|tree
operator|=
name|atree
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|efftab
operator|&&
name|tree
operator|->
name|op
operator|==
name|NAME
condition|)
return|return
operator|(
name|reg
operator|)
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|cexpr
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|table
operator|!=
name|regtab
operator|&&
operator|(
name|table
operator|!=
name|cctab
operator|||
operator|(
name|opdope
index|[
name|tree
operator|->
name|op
index|]
operator|&
name|RELAT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|cexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|fixup
label|:
name|modf
operator|=
name|isfloat
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|dbprint
argument_list|(
name|tree
operator|->
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|sptab
operator|||
name|table
operator|==
name|lsptab
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|LONG
condition|)
block|{
name|printf
argument_list|(
literal|"mov\tr%d,-(sp)\n"
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"mov%c	r%d,%c(sp)\n"
argument_list|,
name|modf
argument_list|,
name|r
argument_list|,
name|table
operator|==
name|sptab
condition|?
literal|'-'
else|:
literal|0
argument_list|)
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
name|printf
argument_list|(
literal|"tst%c	r%d\n"
argument_list|,
name|modf
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
comment|/* 	 * There's a last chance for this operator 	 */
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|LTOI
condition|)
block|{
name|r
operator|=
name|rcexpr
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
name|r
operator|++
expr_stmt|;
goto|goto
name|fixup
goto|;
block|}
block|}
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|STRUCT
condition|)
name|error
argument_list|(
literal|"Illegal operation on structure"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|>
literal|0
operator|&&
name|tree
operator|->
name|op
operator|<
name|RFORCE
operator|&&
name|opntab
index|[
name|tree
operator|->
name|op
index|]
condition|)
name|error
argument_list|(
literal|"No code table for op: %s"
argument_list|,
name|opntab
index|[
name|tree
operator|->
name|op
index|]
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No code table for op %d"
argument_list|,
name|tree
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Try to compile the tree with the code table using  * registers areg and up.  If successful,  * return the register where the value actually ended up.  * If unsuccessful, return -1.  *  * Most of the work is the macro-expansion of the  * code table.  */
end_comment

begin_macro
name|cexpr
argument_list|(
argument|atree
argument_list|,
argument|table
argument_list|,
argument|areg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
name|struct
name|table
modifier|*
name|ctable
decl_stmt|;
name|struct
name|tnode
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|reg1
decl_stmt|,
name|rreg
decl_stmt|,
name|flag
decl_stmt|,
name|opd
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
name|reg
operator|=
name|areg
expr_stmt|;
name|p1
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
name|c
operator|=
name|tree
operator|->
name|op
expr_stmt|;
name|opd
operator|=
name|opdope
index|[
name|c
index|]
expr_stmt|;
comment|/* 	 * When the value of a relational or a logical expression is 	 * desired, more work must be done. 	 */
if|if
condition|(
operator|(
name|opd
operator|&
name|RELAT
operator|||
name|c
operator|==
name|LOGAND
operator|||
name|c
operator|==
name|LOGOR
operator|||
name|c
operator|==
name|EXCLA
operator|)
operator|&&
name|table
operator|!=
name|cctab
condition|)
block|{
name|cbranch
argument_list|(
name|tree
argument_list|,
name|c
operator|=
name|isn
operator|++
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|&
name|czero
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|&
name|cone
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|isn
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QUEST
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cbranch
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|c
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|flag
operator|=
name|nstack
expr_stmt|;
name|rreg
operator|=
name|rcexpr
argument_list|(
name|p1
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|nstack
operator|=
name|flag
expr_stmt|;
name|branch
argument_list|(
name|r
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rcexpr
argument_list|(
name|p1
operator|->
name|tr2
argument_list|,
name|table
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rreg
operator|!=
name|reg
condition|)
name|movreg
argument_list|(
name|reg
argument_list|,
name|rreg
argument_list|,
name|tree
operator|->
name|tr2
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|rreg
operator|)
return|;
block|}
name|reg
operator|=
name|oddreg
argument_list|(
name|tree
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
comment|/* 	 * long values take 2 registers. 	 */
if|if
condition|(
operator|(
name|tree
operator|->
name|type
operator|==
name|LONG
operator|||
name|opd
operator|&
name|RELAT
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|type
operator|==
name|LONG
operator|)
operator|&&
name|tree
operator|->
name|op
operator|!=
name|ITOL
condition|)
name|reg1
operator|++
expr_stmt|;
comment|/* 	 * Leaves of the expression tree 	 */
if|if
condition|(
operator|(
name|r
operator|=
name|chkleaf
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * x + (-1) is better done as x-1. 	 */
if|if
condition|(
operator|(
name|tree
operator|->
name|op
operator|==
name|PLUS
operator|||
name|tree
operator|->
name|op
operator|==
name|ASPLUS
operator|)
operator|&&
operator|(
name|p1
operator|=
name|tree
operator|->
name|tr2
operator|)
operator|->
name|op
operator|==
name|CON
operator|&&
name|p1
operator|->
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|p1
operator|->
name|value
operator|=
literal|1
expr_stmt|;
name|tree
operator|->
name|op
operator|=
operator|+
operator|(
name|MINUS
operator|-
name|PLUS
operator|)
expr_stmt|;
block|}
comment|/* 	 * Because of a peculiarity of the PDP11 table 	 * char = *intreg++ and *--intreg cannot go through.  	 */
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|type
operator|==
name|CHAR
operator|&&
name|tree
operator|->
name|tr2
operator|->
name|type
operator|!=
name|CHAR
operator|&&
operator|(
name|tree
operator|->
name|tr2
operator|->
name|op
operator|==
name|AUTOI
operator|||
name|tree
operator|->
name|tr2
operator|->
name|op
operator|==
name|AUTOD
operator|)
condition|)
name|tree
operator|->
name|tr2
operator|=
name|tnode
argument_list|(
name|LOAD
argument_list|,
name|tree
operator|->
name|tr2
operator|->
name|type
argument_list|,
name|tree
operator|->
name|tr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|cregtab
condition|)
name|table
operator|=
name|regtab
expr_stmt|;
comment|/* 	 * The following peculiar code depends on the fact that 	 * if you just want the codition codes set, efftab 	 * will generate the right code unless the operator is 	 * a shift or 	 * postfix ++ or --. Unravelled, if the table is 	 * cctab and the operator is not special, try first 	 * for efftab;  if the table isn't, if the operator is, 	 * or the first match fails, try to match 	 * with the table actually asked for. 	 */
comment|/* 	 * Account for longs and oddregs; below is really 	 * r = nreg - reg - (reg-areg) - (reg1-reg-1); 	 */
name|r
operator|=
name|nreg
operator|-
name|reg
operator|+
name|areg
operator|-
name|reg1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|cctab
operator|||
name|c
operator|==
name|INCAFT
operator|||
name|c
operator|==
name|DECAFT
operator|||
name|tree
operator|->
name|type
operator|==
name|LONG
operator|||
name|c
operator|==
name|ASRSH
operator|||
name|c
operator|==
name|ASLSH
operator|||
name|c
operator|==
name|ASULSH
operator|||
operator|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|efftab
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|string
operator|=
name|opt
operator|->
name|tabstring
expr_stmt|;
name|p1
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|FCON
operator|&&
name|p1
operator|->
name|value
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|".data\nL%d:%o;%o;%o;%o\n.text\n"
argument_list|,
name|p1
operator|->
name|value
argument_list|,
name|p1
operator|->
name|fvalue
argument_list|)
expr_stmt|;
name|p1
operator|->
name|value
operator|=
operator|-
name|p1
operator|->
name|value
expr_stmt|;
block|}
name|p2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|tree
operator|->
name|op
index|]
operator|&
name|BINARY
condition|)
block|{
name|p2
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|p2
operator|->
name|op
operator|==
name|FCON
operator|&&
name|p2
operator|->
name|value
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|".data\nL%d:%o;%o;%o;%o\n.text\n"
argument_list|,
name|p2
operator|->
name|value
argument_list|,
name|p2
operator|->
name|fvalue
argument_list|)
expr_stmt|;
name|p2
operator|->
name|value
operator|=
operator|-
name|p2
operator|->
name|value
expr_stmt|;
block|}
block|}
name|loop
label|:
comment|/* 	 * The 0200 bit asks for a tab. 	 */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|&
literal|0200
condition|)
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|dbprint
argument_list|(
name|tree
operator|->
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
operator|!
name|isfloat
argument_list|(
name|tree
argument_list|)
condition|)
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|DIVIDE
operator|||
name|tree
operator|->
name|op
operator|==
name|ASDIV
operator|||
name|tree
operator|->
name|op
operator|==
name|PTOI
condition|)
name|reg
operator|--
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
comment|/* A1 */
case|case
literal|'A'
case|:
name|p
operator|=
name|p1
expr_stmt|;
goto|goto
name|adr
goto|;
comment|/* A2 */
case|case
literal|'B'
case|:
name|p
operator|=
name|p2
expr_stmt|;
goto|goto
name|adr
goto|;
name|adr
label|:
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|string
operator|==
literal|'\''
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string
operator|==
literal|'+'
condition|)
block|{
name|c
operator|=
literal|100
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
name|pname
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* I */
case|case
literal|'M'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|)
operator|==
literal|'\''
condition|)
name|string
operator|++
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
name|prins
argument_list|(
name|tree
operator|->
name|op
argument_list|,
name|c
argument_list|,
name|instab
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* B1 */
case|case
literal|'C'
case|:
if|if
condition|(
operator|(
name|opd
operator|&
name|LEAF
operator|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|tree
expr_stmt|;
else|else
name|p
operator|=
name|p1
expr_stmt|;
goto|goto
name|pbyte
goto|;
comment|/* BF */
case|case
literal|'P'
case|:
name|p
operator|=
name|tree
expr_stmt|;
goto|goto
name|pb1
goto|;
comment|/* B2 */
case|case
literal|'D'
case|:
name|p
operator|=
name|p2
expr_stmt|;
name|pbyte
label|:
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CHAR
condition|)
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|pb1
label|:
if|if
condition|(
name|isfloat
argument_list|(
name|p
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* BE */
case|case
literal|'L'
case|:
if|if
condition|(
name|p1
operator|->
name|type
operator|==
name|CHAR
operator|||
name|p2
operator|->
name|type
operator|==
name|CHAR
condition|)
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|p
operator|=
name|tree
expr_stmt|;
goto|goto
name|pb1
goto|;
comment|/* F */
case|case
literal|'G'
case|:
name|p
operator|=
name|p1
expr_stmt|;
name|flag
operator|=
literal|01
expr_stmt|;
goto|goto
name|subtre
goto|;
comment|/* S */
case|case
literal|'K'
case|:
name|p
operator|=
name|p2
expr_stmt|;
name|flag
operator|=
literal|02
expr_stmt|;
goto|goto
name|subtre
goto|;
comment|/* H */
case|case
literal|'H'
case|:
name|p
operator|=
name|tree
expr_stmt|;
name|flag
operator|=
literal|04
expr_stmt|;
name|subtre
label|:
name|ctable
operator|=
name|regtab
expr_stmt|;
if|if
condition|(
name|flag
operator|&
literal|04
condition|)
name|ctable
operator|=
name|cregtab
expr_stmt|;
name|c
operator|=
operator|*
name|string
operator|++
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'!'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|c
operator|=
operator||
literal|020
expr_stmt|;
comment|/* force right register */
block|}
if|if
condition|(
operator|(
name|c
operator|&
literal|02
operator|)
operator|!=
literal|0
condition|)
name|ctable
operator|=
name|sptab
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|04
operator|)
operator|!=
literal|0
condition|)
name|ctable
operator|=
name|cctab
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
literal|01
operator|)
operator|&&
name|ctable
operator|==
name|regtab
operator|&&
operator|(
name|c
operator|&
literal|01
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tree
operator|->
name|op
operator|==
name|DIVIDE
operator|||
name|tree
operator|->
name|op
operator|==
name|MOD
operator|||
name|tree
operator|->
name|op
operator|==
name|ASDIV
operator|||
name|tree
operator|->
name|op
operator|==
name|ASMOD
operator|||
name|tree
operator|->
name|op
operator|==
name|ITOL
operator|)
condition|)
name|ctable
operator|=
name|cregtab
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|01
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|collcon
argument_list|(
name|p
argument_list|)
operator|&&
name|ctable
operator|!=
name|sptab
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
condition|)
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|table
operator|==
name|lsptab
operator|&&
name|ctable
operator|==
name|sptab
condition|)
name|ctable
operator|=
name|lsptab
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|010
condition|)
name|r
operator|=
name|reg1
expr_stmt|;
elseif|else
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|LEAF
operator|||
name|p
operator|->
name|degree
operator|<
literal|2
condition|)
name|r
operator|=
name|reg
expr_stmt|;
else|else
name|r
operator|=
name|areg
expr_stmt|;
name|rreg
operator|=
name|rcexpr
argument_list|(
name|p
argument_list|,
name|ctable
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctable
operator|!=
name|regtab
operator|&&
name|ctable
operator|!=
name|cregtab
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|c
operator|&
literal|010
condition|)
block|{
if|if
condition|(
name|c
operator|&
literal|020
operator|&&
name|rreg
operator|!=
name|reg1
condition|)
name|movreg
argument_list|(
name|rreg
argument_list|,
name|reg1
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|reg1
operator|=
name|rreg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rreg
operator|!=
name|reg
condition|)
if|if
condition|(
operator|(
name|c
operator|&
literal|020
operator|)
operator|==
literal|0
operator|&&
name|oddreg
argument_list|(
name|tree
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
name|tree
operator|->
name|type
operator|!=
name|LONG
operator|&&
operator|(
name|flag
operator|&
literal|04
operator|||
name|flag
operator|&
literal|01
operator|&&
name|xdcalc
argument_list|(
name|p2
argument_list|,
name|nreg
operator|-
name|rreg
operator|-
literal|1
argument_list|)
operator|<=
operator|(
name|opt
operator|->
name|tabdeg2
operator|&
literal|077
operator|)
operator|||
name|flag
operator|&
literal|02
operator|&&
name|xdcalc
argument_list|(
name|p1
argument_list|,
name|nreg
operator|-
name|rreg
operator|-
literal|1
argument_list|)
operator|<=
operator|(
name|opt
operator|->
name|tabdeg1
operator|&
literal|077
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|rreg
expr_stmt|;
name|reg1
operator|=
name|rreg
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|movreg
argument_list|(
name|rreg
argument_list|,
name|reg
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* R */
case|case
literal|'I'
case|:
name|r
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|r
operator|--
expr_stmt|;
block|}
goto|goto
name|preg
goto|;
comment|/* R1 */
case|case
literal|'J'
case|:
name|r
operator|=
name|reg1
expr_stmt|;
name|preg
label|:
if|if
condition|(
operator|*
name|string
operator|==
literal|'+'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|>
name|nreg
operator|||
name|r
operator|>=
literal|4
operator|&&
name|tree
operator|->
name|type
operator|==
name|DOUBLE
condition|)
name|error
argument_list|(
literal|"Register overflow: simplify expression"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'-'
case|:
comment|/* check -(sp) */
if|if
condition|(
operator|*
name|string
operator|==
literal|'('
condition|)
block|{
name|nstack
operator|++
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|lsptab
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
break|break;
case|case
literal|')'
case|:
comment|/* check (sp)+ */
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'+'
condition|)
name|nstack
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* #1 */
case|case
literal|'#'
case|:
name|p
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
goto|goto
name|nmbr
goto|;
comment|/* #2 */
case|case
literal|'"'
case|:
name|p
operator|=
name|p2
operator|->
name|tr1
expr_stmt|;
name|nmbr
label|:
if|if
condition|(
name|collcon
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
condition|)
block|{
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|tr2
operator|)
operator|->
name|op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|value
condition|)
name|psoct
argument_list|(
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|AMPER
condition|)
name|pname
argument_list|(
name|p
operator|->
name|tr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
comment|/* 	 * Certain adjustments for / % and PTOI 	 */
case|case
literal|'T'
case|:
name|c
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|PTOI
condition|)
block|{
name|printf
argument_list|(
literal|"bic	r%d,r%d\nsbc	r%d\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|p1
operator|->
name|type
operator|==
name|UNSIGN
operator|||
name|p1
operator|->
name|type
operator|&
name|XTYPE
condition|)
block|{
name|printf
argument_list|(
literal|"clr	r%d\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|dcalc
argument_list|(
name|p1
argument_list|,
literal|5
argument_list|)
operator|>
literal|12
operator|&&
operator|!
name|match
argument_list|(
name|p1
argument_list|,
name|cctab
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tst	r%d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sxt	r%d\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'V'
case|:
comment|/* adc sbc, clr, or sxt as required for longs */
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|ASPLUS
case|:
case|case
name|INCBEF
case|:
case|case
name|INCAFT
case|:
name|printf
argument_list|(
literal|"adc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
case|case
name|ASMINUS
case|:
case|case
name|NEG
case|:
case|case
name|DECBEF
case|:
case|case
name|DECAFT
case|:
name|printf
argument_list|(
literal|"sbc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASSIGN
case|:
name|p
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
goto|goto
name|lcasev
goto|;
case|case
name|ASDIV
case|:
case|case
name|ASMOD
case|:
case|case
name|ASULSH
case|:
name|p
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|lcasev
label|:
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|LONG
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|UNSIGN
operator|||
name|p
operator|->
name|type
operator|&
name|XTYPE
condition|)
name|printf
argument_list|(
literal|"clr"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"sxt"
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
default|default:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
empty_stmt|;
break|break;
block|}
goto|goto
name|loop
goto|;
comment|/* 	 * Mask used in field assignments 	 */
case|case
literal|'Z'
case|:
name|printf
argument_list|(
literal|"$%o"
argument_list|,
name|tree
operator|->
name|mask
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* 	 * Relational on long values. 	 * Might bug out early. E.g., 	 * (long<0) can be determined with only 1 test. 	 */
case|case
literal|'X'
case|:
if|if
condition|(
name|xlongrel
argument_list|(
operator|*
name|string
operator|++
operator|-
literal|'0'
argument_list|)
condition|)
return|return
operator|(
name|reg
operator|)
return|;
goto|goto
name|loop
goto|;
block|}
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * This routine just calls sreorder (below)  * on the subtrees and then on the tree itself.  * It returns non-zero if anything changed.  */
end_comment

begin_macro
name|reorder
argument_list|(
argument|treep
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|treep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
operator|,
name|o
expr_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|treep
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|o
index|]
operator|&
name|LEAF
operator|||
name|o
operator|==
name|LOGOR
operator|||
name|o
operator|==
name|LOGAND
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|sreorder
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|opdope
index|[
name|o
index|]
operator|&
name|BINARY
condition|)
while|while
condition|(
name|sreorder
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|cctab
condition|)
while|while
condition|(
name|sreorder
argument_list|(
name|treep
argument_list|,
name|table
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
condition|)
name|r
operator|++
expr_stmt|;
operator|*
name|treep
operator|=
name|optim
argument_list|(
operator|*
name|treep
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Basically this routine carries out two kinds of optimization.  * First, it observes that "x + (reg = y)" where actually  * the = is any assignment op is better done as "reg=y; x+reg".  * In this case rcexpr is called to do the first part and the  * tree is modified so the name of the register  * replaces the assignment.  * Moreover, expressions like "reg = x+y" are best done as  * "reg = x; reg =+ y" (so long as "reg" and "y" are not the same!).  */
end_comment

begin_macro
name|sreorder
argument_list|(
argument|treep
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|,
argument|recurf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|treep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
operator|*
name|treep
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|LEAF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PLUS
operator|&&
name|recurf
condition|)
if|if
condition|(
name|reorder
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
operator|*
name|treep
operator|=
name|p
operator|=
name|optim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
operator|||
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|recurf
operator|&&
name|reorder
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
operator|*
name|treep
operator|=
name|p
operator|=
name|optim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|NAME
condition|)
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ASLSH
case|:
case|case
name|ASRSH
case|:
case|case
name|ASSIGN
case|:
if|if
condition|(
name|p1
operator|->
name|class
operator|!=
name|REG
operator|||
name|p1
operator|->
name|type
operator|==
name|CHAR
operator|||
name|isfloat
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASSIGN
condition|)
switch|switch
condition|(
name|p
operator|->
name|tr2
operator|->
name|op
condition|)
block|{
case|case
name|TIMES
case|:
if|if
condition|(
operator|!
name|ispow2
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
condition|)
break|break;
name|p
operator|->
name|tr2
operator|=
name|pow2
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
expr_stmt|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|AND
case|:
case|case
name|ANDN
case|:
case|case
name|OR
case|:
case|case
name|EXOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|RSHIFT
case|:
name|p1
operator|=
name|p
operator|->
name|tr2
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|xdcalc
argument_list|(
name|p1
argument_list|,
literal|16
argument_list|)
operator|>
literal|12
operator|||
name|p1
operator|->
name|op
operator|==
name|NAME
operator|&&
operator|(
name|p1
operator|->
name|nloc
operator|==
name|p
operator|->
name|tr1
operator|->
name|nloc
operator|||
name|p1
operator|->
name|regno
operator|==
name|p
operator|->
name|tr1
operator|->
name|nloc
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p1
operator|=
name|p
operator|->
name|tr2
expr_stmt|;
name|p
operator|->
name|tr2
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|tr1
operator|->
name|op
operator|!=
name|NAME
operator|||
name|p1
operator|->
name|tr1
operator|->
name|class
operator|!=
name|REG
operator|||
name|p1
operator|->
name|tr1
operator|->
name|nloc
operator|!=
name|p
operator|->
name|tr1
operator|->
name|nloc
condition|)
name|rcexpr
argument_list|(
name|p
argument_list|,
name|efftab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|p
operator|->
name|tr2
operator|=
name|p1
operator|->
name|tr2
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|p1
operator|->
name|op
operator|+
name|ASPLUS
operator|-
name|PLUS
expr_stmt|;
operator|*
name|treep
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
goto|goto
name|OK
goto|;
case|case
name|ASTIMES
case|:
if|if
condition|(
operator|!
name|ispow2
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ASPLUS
case|:
case|case
name|ASMINUS
case|:
case|case
name|ASAND
case|:
case|case
name|ASANDN
case|:
case|case
name|ASOR
case|:
case|case
name|ASXOR
case|:
case|case
name|INCBEF
case|:
case|case
name|DECBEF
case|:
name|OK
label|:
if|if
condition|(
name|table
operator|==
name|cctab
operator|||
name|table
operator|==
name|cregtab
condition|)
name|reg
operator|=
operator|+
literal|020
expr_stmt|;
name|rcexpr
argument_list|(
name|optim
argument_list|(
name|p
argument_list|)
argument_list|,
name|efftab
argument_list|,
operator|~
name|reg
argument_list|)
expr_stmt|;
operator|*
name|treep
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Delay handles postfix ++ and --   * It observes that "x + y++" is better  * treated as "x + y; y++".  * If the operator is ++ or -- itself,  * it calls rcexpr to load the operand, letting  * the calling instance of rcexpr to do the  * ++ using efftab.  * Otherwise it uses sdelay to search for inc/dec  * among the operands.  */
end_comment

begin_macro
name|delay
argument_list|(
argument|treep
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|treep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|r
expr_stmt|;
name|p
operator|=
operator|*
name|treep
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|INCAFT
operator|||
name|p
operator|->
name|op
operator|==
name|DECAFT
operator|)
operator|&&
name|p
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
condition|)
block|{
return|return
operator|(
literal|1
operator|+
name|rcexpr
argument_list|(
name|p
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
name|p1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|BINARY
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LOGAND
operator|||
name|p
operator|->
name|op
operator|==
name|LOGOR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p1
operator|=
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
literal|0
condition|)
name|p1
operator|=
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
block|{
name|r
operator|=
name|rcexpr
argument_list|(
name|optim
argument_list|(
name|p
argument_list|)
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
operator|*
name|treep
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|r
operator|+
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|sdelay
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
operator|*
name|ap
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|INCAFT
operator|||
name|p
operator|->
name|op
operator|==
name|DECAFT
operator|)
operator|&&
name|p
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
condition|)
block|{
operator|*
name|ap
operator|=
name|ncopy
argument_list|(
name|p
operator|->
name|tr1
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
operator|||
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
if|if
condition|(
name|p1
operator|=
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|)
condition|)
return|return
operator|(
name|p1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
return|return
operator|(
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Copy a tree node for a register variable.  * Used by sdelay because if *reg-- is turned  * into *reg; reg-- the *reg will in turn  * be changed to some offset class, accidentally  * modifying the reg--.  */
end_comment

begin_macro
name|ncopy
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tname
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tname
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|class
operator|!=
name|REG
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|q
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|op
operator|=
name|p
operator|->
name|op
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|q
operator|->
name|class
operator|=
name|p
operator|->
name|class
expr_stmt|;
name|q
operator|->
name|offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|q
operator|->
name|nloc
operator|=
name|p
operator|->
name|nloc
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * If the tree can be immediately loaded into a register,  * produce code to do so and return success.  */
end_comment

begin_macro
name|chkleaf
argument_list|(
argument|atree
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tnode
name|lbuf
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|!=
name|STAR
operator|&&
name|dcalc
argument_list|(
name|tree
argument_list|,
name|nreg
operator|-
name|reg
argument_list|)
operator|>
literal|12
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lbuf
operator|.
name|op
operator|=
name|LOAD
expr_stmt|;
name|lbuf
operator|.
name|type
operator|=
name|tree
operator|->
name|type
expr_stmt|;
name|lbuf
operator|.
name|degree
operator|=
name|tree
operator|->
name|degree
expr_stmt|;
name|lbuf
operator|.
name|tr1
operator|=
name|tree
expr_stmt|;
return|return
operator|(
name|rcexpr
argument_list|(
operator|&
name|lbuf
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compile a function argument.  * If the stack is currently empty, put it in (sp)  * rather than -(sp); this will save a pop.  * Return the number of bytes pushed,  * for future popping.  */
end_comment

begin_macro
name|comarg
argument_list|(
argument|atree
argument_list|,
argument|flagp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|flagp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
specifier|register
name|retval
expr_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|STRASG
condition|)
block|{
name|size
operator|=
name|tree
operator|->
name|mask
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|tree
operator|=
name|strfunc
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|2
condition|)
block|{
name|setype
argument_list|(
name|tree
argument_list|,
name|INT
argument_list|)
expr_stmt|;
goto|goto
name|normal
goto|;
block|}
if|if
condition|(
name|size
operator|<=
literal|4
condition|)
block|{
name|setype
argument_list|(
name|tree
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
goto|goto
name|normal
goto|;
block|}
if|if
condition|(
name|tree
operator|->
name|op
operator|!=
name|NAME
operator|&&
name|tree
operator|->
name|op
operator|!=
name|STAR
condition|)
block|{
name|error
argument_list|(
literal|"Unimplemented structure assignment"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tree
operator|=
name|tnode
argument_list|(
name|AMPER
argument_list|,
name|STRUCT
operator|+
name|PTR
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tnode
argument_list|(
name|PLUS
argument_list|,
name|STRUCT
operator|+
name|PTR
argument_list|,
name|tree
argument_list|,
name|tconst
argument_list|(
name|size
argument_list|,
name|INT
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|optim
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|retval
operator|=
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|5
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"mov	-(r%d),-(sp)\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"mov	r%d,r0\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mov	$%o,r1\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:mov	-(r0),-(sp)\ndec\tr1\njne\tL%d\n"
argument_list|,
name|isn
argument_list|,
name|isn
argument_list|)
expr_stmt|;
name|isn
operator|++
expr_stmt|;
block|}
name|nstack
operator|++
expr_stmt|;
return|return
operator|(
name|size
operator|*
literal|2
operator|)
return|;
block|}
name|normal
label|:
if|if
condition|(
name|nstack
operator|||
name|isfloat
argument_list|(
name|tree
argument_list|)
operator|||
name|tree
operator|->
name|type
operator|==
name|LONG
condition|)
block|{
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|sptab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|arlength
argument_list|(
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|flagp
operator|)
operator|++
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|lsptab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|tnode
modifier|*
name|strfunc
parameter_list|(
name|atp
parameter_list|)
name|struct
name|tnode
modifier|*
name|atp
decl_stmt|;
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|atp
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|op
operator|!=
name|CALL
condition|)
return|return
operator|(
name|tp
operator|)
return|;
name|setype
argument_list|(
name|tp
argument_list|,
name|STRUCT
operator|+
name|PTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|tnode
argument_list|(
name|STAR
argument_list|,
name|STRUCT
argument_list|,
name|tp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compile an initializing expression  */
end_comment

begin_macro
name|doinit
argument_list|(
argument|atype
argument_list|,
argument|atree
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|float
name|sfval
decl_stmt|;
name|double
name|fval
decl_stmt|;
name|long
name|lval
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
name|type
operator|=
name|atype
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CHAR
condition|)
block|{
name|printf
argument_list|(
literal|".byte "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|&
name|XTYPE
condition|)
goto|goto
name|illinit
goto|;
name|type
operator|=
name|INT
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&
name|XTYPE
condition|)
name|type
operator|=
name|INT
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INT
case|:
case|case
name|UNSIGN
case|:
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|FTOI
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|FCON
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|SFCON
condition|)
goto|goto
name|illinit
goto|;
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|tree
operator|->
name|value
operator|=
name|tree
operator|->
name|fvalue
expr_stmt|;
name|tree
operator|->
name|op
operator|=
name|CON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|LTOI
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|LCON
condition|)
goto|goto
name|illinit
goto|;
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|lval
operator|=
name|tree
operator|->
name|lvalue
expr_stmt|;
name|tree
operator|->
name|op
operator|=
name|CON
expr_stmt|;
name|tree
operator|->
name|value
operator|=
name|lval
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|CON
condition|)
name|printf
argument_list|(
literal|"%o\n"
argument_list|,
name|tree
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|AMPER
condition|)
block|{
name|pname
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|illinit
goto|;
return|return;
case|case
name|DOUBLE
case|:
case|case
name|FLOAT
case|:
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|ITOF
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|==
name|CON
condition|)
block|{
name|fval
operator|=
name|tree
operator|->
name|tr1
operator|->
name|value
expr_stmt|;
block|}
else|else
goto|goto
name|illinit
goto|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|FCON
operator|||
name|tree
operator|->
name|op
operator|==
name|SFCON
condition|)
name|fval
operator|=
name|tree
operator|->
name|fvalue
expr_stmt|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|LTOF
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|LCON
condition|)
goto|goto
name|illinit
goto|;
name|fval
operator|=
name|tree
operator|->
name|tr1
operator|->
name|lvalue
expr_stmt|;
block|}
else|else
goto|goto
name|illinit
goto|;
if|if
condition|(
name|type
operator|==
name|FLOAT
condition|)
block|{
name|sfval
operator|=
name|fval
expr_stmt|;
name|printf
argument_list|(
literal|"%o; %o\n"
argument_list|,
name|sfval
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%o; %o; %o; %o\n"
argument_list|,
name|fval
argument_list|)
expr_stmt|;
return|return;
case|case
name|LONG
case|:
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|FTOL
condition|)
block|{
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|SFCON
condition|)
name|tree
operator|->
name|op
operator|=
name|FCON
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|!=
name|FCON
condition|)
goto|goto
name|illinit
goto|;
name|lval
operator|=
name|tree
operator|->
name|fvalue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|ITOL
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|CON
condition|)
goto|goto
name|illinit
goto|;
name|lval
operator|=
name|tree
operator|->
name|tr1
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|LCON
condition|)
name|lval
operator|=
name|tree
operator|->
name|lvalue
expr_stmt|;
else|else
goto|goto
name|illinit
goto|;
name|printf
argument_list|(
literal|"%o; %o\n"
argument_list|,
name|lval
argument_list|)
expr_stmt|;
return|return;
block|}
name|illinit
label|:
name|error
argument_list|(
literal|"Illegal initialization"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|movreg
argument_list|(
argument|r0
argument_list|,
argument|r1
argument_list|,
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|r0
operator|==
name|r1
condition|)
return|return;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|LONG
condition|)
block|{
name|s
operator|=
literal|"mov	r%d,r%d\nmov	r%d,r%d\n"
expr_stmt|;
if|if
condition|(
name|r0
operator|<
name|r1
condition|)
name|printf
argument_list|(
name|s
argument_list|,
name|r0
operator|+
literal|1
argument_list|,
name|r1
operator|+
literal|1
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|s
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|,
name|r0
operator|+
literal|1
argument_list|,
name|r1
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"mov%c	r%d,r%d\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
argument_list|)
argument_list|,
name|r0
argument_list|,
name|r1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

