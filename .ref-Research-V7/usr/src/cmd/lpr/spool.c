begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|ONL
value|0
end_define

begin_define
define|#
directive|define
name|TOSS
value|1
end_define

begin_decl_stmt
name|int
name|INCHAR
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*index of incremented character in 					temporary file names. */
end_comment

begin_decl_stmt
name|char
name|version
index|[]
init|=
literal|"Version 2/6/79"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|grade
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|remote
index|[]
init|=
literal|"$	remote	**,onl"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|toss
index|[]
init|=
literal|"$	sysout	toss"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|remotsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*toss-output flag*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|mailfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wantmail
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*recipient of mail*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|identf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ident card info*/
end_comment

begin_decl_stmt
name|int
name|uidf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|gcosid
index|[
literal|13
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*gcos userid*/
end_comment

begin_decl_stmt
name|char
name|cpflag
init|=
literal|'l'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*copy/link flag*/
end_comment

begin_decl_stmt
name|int
name|rmflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*remove flag*/
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gcdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*GCOS debug switch*/
end_comment

begin_decl_stmt
name|int
name|archsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*archive switch*/
end_comment

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*used by card */
end_comment

begin_decl_stmt
name|int
name|nact
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*number of non-null files to process.*/
end_comment

begin_decl_stmt
name|int
name|gsize
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*size of current file in GCOS blocks.*/
end_comment

begin_decl_stmt
name|long
name|usize
init|=
literal|20
operator|*
literal|1200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*size of current file in bytes.*/
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|tff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*temporary control card file*/
end_comment

begin_function_decl
name|FILE
modifier|*
name|nfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getarg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|comopt
argument_list|(
argument|o
argument_list|)
end_macro

begin_comment
comment|/*routine to test for common options.*/
end_comment

begin_decl_stmt
name|char
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
literal|'c'
case|:
name|cpflag
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|identf
operator|=
name|getarg
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|wantmail
operator|++
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|2
index|]
condition|)
name|pp
operator|=
operator|&
name|arg
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/*new option to suppress mail. MRW*/
name|wantmail
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|remotsw
operator|=
name|ONL
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rmflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|<
literal|'1'
operator|||
name|arg
index|[
literal|2
index|]
operator|>
literal|'3'
condition|)
goto|goto
name|unknown
goto|;
name|grade
operator|=
name|arg
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
condition|)
goto|goto
name|unknown
goto|;
name|remotsw
operator|=
name|TOSS
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/*GCOS debugging switch*/
name|gcdebug
operator|=
literal|1
expr_stmt|;
break|break;
name|unknown
label|:
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|LPR
operator|==
literal|0
end_if

begin_macro
name|spool1
argument_list|()
end_macro

begin_comment
comment|/*set up common initial GCOS control cards.*/
end_comment

begin_block
block|{
if|if
condition|(
name|debug
condition|)
name|tff
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tff
operator|=
name|nfile
argument_list|(
name|tfname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't create %s.\n"
argument_list|,
name|NAME
argument_list|,
name|tfname
argument_list|)
expr_stmt|;
name|out
argument_list|()
expr_stmt|;
block|}
name|card
argument_list|(
literal|'S'
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|card
argument_list|(
literal|'L'
argument_list|,
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$	sgrade	%c   %s"
argument_list|,
name|grade
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
argument_list|()
condition|)
name|out
argument_list|()
expr_stmt|;
name|card
argument_list|(
literal|'L'
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|remotsw
operator|==
name|TOSS
condition|)
name|card
argument_list|(
literal|'L'
argument_list|,
name|toss
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|spool2
argument_list|()
end_macro

begin_comment
comment|/*add final control cards, and spool job.*/
end_comment

begin_block
block|{
if|if
condition|(
name|wantmail
condition|)
name|card
argument_list|(
literal|'N'
argument_list|,
name|mailfile
argument_list|)
expr_stmt|;
name|card
argument_list|(
literal|'L'
argument_list|,
literal|"$	endjob"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|out
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|tff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nact
condition|)
block|{
name|dfname
index|[
name|INCHAR
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|tfname
argument_list|,
name|dfname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot rename %s\n"
argument_list|,
name|NAME
argument_list|,
name|tfname
argument_list|)
expr_stmt|;
name|out
argument_list|()
expr_stmt|;
block|}
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/lib/dpd"
argument_list|,
literal|"dpd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/etc/dpd"
argument_list|,
literal|"dpd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't find dpd.\nFiles left in spooling dir.\n"
argument_list|,
name|NAME
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|FGET
operator|==
literal|0
end_if

begin_macro
name|filargs
argument_list|()
end_macro

begin_comment
comment|/*process file arguments for dpr, gcat, fsend, lpr.*/
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|mailfile
operator|==
literal|0
condition|)
name|mailfile
operator|=
literal|"pipe.end"
expr_stmt|;
if|if
condition|(
name|copy
argument_list|(
name|stdin
argument_list|,
name|mailfile
argument_list|,
name|GCAT
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|out
argument_list|()
expr_stmt|;
if|if
condition|(
name|archsw
condition|)
name|archive
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|argc
condition|)
block|{
name|arg
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
switch|switch
condition|(
name|cpflag
condition|)
block|{
case|case
literal|'l'
case|:
if|if
condition|(
name|lfname
index|[
name|INCHAR
index|]
operator|++
operator|>=
literal|'z'
condition|)
name|cpflag
operator|=
name|rmflag
condition|?
literal|'c'
else|:
literal|'n'
expr_stmt|;
elseif|else
if|if
condition|(
name|link
argument_list|(
name|arg
argument_list|,
name|lfname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|size
argument_list|(
name|arg
argument_list|,
name|arg
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|nuact
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|card
argument_list|(
name|BF
argument_list|,
name|lfname
argument_list|)
expr_stmt|;
name|card
argument_list|(
literal|'U'
argument_list|,
name|lfname
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'n'
case|:
if|if
condition|(
operator|*
name|arg
operator|==
literal|'/'
operator|&&
operator|!
name|rmflag
condition|)
block|{
if|if
condition|(
name|size
argument_list|(
name|arg
argument_list|,
name|arg
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|nuact
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|card
argument_list|(
name|BF
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'c'
case|:
name|f
operator|=
name|fopen
argument_list|(
name|arg
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot open %s\n"
argument_list|,
name|NAME
argument_list|,
name|arg
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|copy
argument_list|(
name|f
argument_list|,
name|arg
argument_list|,
name|GCAT
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|archsw
condition|)
name|archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|rmflag
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|arg
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot remove %s\n"
argument_list|,
name|NAME
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mailfile
operator|==
literal|0
condition|)
name|mailfile
operator|=
name|arg
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|FILE
modifier|*
name|nfile
parameter_list|(
name|name
parameter_list|)
comment|/*generate a new file name, and open file.*/
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|name
index|[
name|INCHAR
index|]
operator|>=
literal|'z'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|name
index|[
name|INCHAR
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|FGET
operator|==
literal|0
end_if

begin_macro
name|copy
argument_list|(
argument|f
argument_list|,
argument|gname
argument_list|,
argument|gcatsw
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gcatsw
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|ff
decl_stmt|;
name|long
name|cnt
decl_stmt|;
if|if
condition|(
operator|(
name|ff
operator|=
name|nfile
argument_list|(
name|cfname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Too many copy files; %s not copied\n"
argument_list|,
name|NAME
argument_list|,
name|gname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|gcatsw
condition|)
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad input from %s.\n"
argument_list|,
name|NAME
argument_list|,
name|gname
argument_list|)
expr_stmt|;
name|out
argument_list|()
expr_stmt|;
block|}
else|else
name|gcatsw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|putc
argument_list|(
name|c
argument_list|,
name|ff
argument_list|)
operator|==
name|EOF
operator|)
operator|&&
name|ferror
argument_list|(
name|ff
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Write error on copy of %s.\n"
argument_list|,
name|NAME
argument_list|,
name|gname
argument_list|)
expr_stmt|;
break|break;
block|}
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|MAXCOPY
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Copy file %s is too large\n"
argument_list|,
name|NAME
argument_list|,
name|gname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|ff
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|(
name|cfname
argument_list|,
name|gname
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nuact
argument_list|(
name|gname
argument_list|)
expr_stmt|;
name|card
argument_list|(
name|BF
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
name|card
argument_list|(
literal|'U'
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|card
argument_list|(
argument|c
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|tff
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|tff
argument_list|)
expr_stmt|;
name|c
operator|=
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|tff
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error writing control file.\n"
argument_list|,
name|NAME
argument_list|)
expr_stmt|;
name|out
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|size
argument_list|(
argument|file
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot open %s\n"
argument_list|,
name|NAME
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|stbuf
operator|.
name|st_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: File %s is empty.\n"
argument_list|,
name|NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|usize
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
name|gsize
operator|=
name|usize
operator|/
literal|1200
expr_stmt|;
name|gsize
operator|++
expr_stmt|;
name|nact
operator|++
expr_stmt|;
return|return
operator|(
name|gsize
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|getarg
parameter_list|(
name|c
parameter_list|)
comment|/*get modifier for complex options -- 			    from either same or next argument. MRW 			    e.g. either "-ffile" or "-f file"*/
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|arg
index|[
literal|2
index|]
condition|)
return|return
operator|(
operator|&
name|arg
index|[
literal|2
index|]
operator|)
return|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|>
literal|1
condition|)
return|return
operator|(
name|arg
operator|=
operator|(
operator|++
name|argv
operator|)
index|[
literal|1
index|]
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Incomplete -%c option\n"
argument_list|,
name|NAME
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|out
argument_list|()
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|ident
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|test
decl_stmt|,
name|jsave
decl_stmt|;
name|struct
name|passwd
modifier|*
name|b1
decl_stmt|;
specifier|static
name|char
name|b2
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|b1
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid user id\n"
argument_list|,
name|NAME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|LPR
operator|==
literal|0
while|while
condition|(
name|c
operator|=
literal|"$	ident	"
index|[
name|j
index|]
condition|)
name|b2
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|identf
condition|)
while|while
condition|(
name|c
operator|=
name|identf
index|[
name|i
operator|++
index|]
condition|)
name|b2
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|jsave
operator|=
name|j
expr_stmt|;
comment|/*use either usg or pwb-style passwd. MRW*/
while|while
condition|(
operator|(
name|c
operator|=
name|b1
operator|->
name|pw_gecos
index|[
name|i
operator|++
index|]
operator|)
operator|&&
name|c
operator|!=
literal|':'
condition|)
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|j
operator|=
name|jsave
expr_stmt|;
else|else
name|b2
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|b2
index|[
name|j
operator|++
index|]
operator|=
literal|','
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pp
condition|)
name|pp
operator|=
operator|&
name|b2
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|b1
operator|->
name|pw_name
index|[
name|i
operator|++
index|]
condition|)
name|b2
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|b2
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|LPR
operator|==
literal|0
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|3
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
block|{
name|test
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|b2
index|[
name|i
operator|++
index|]
operator|)
operator|&&
name|c
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|test
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
name|test
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|test
operator|==
literal|0
condition|)
block|{
name|b2
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Invalid IDENT information - %s\n"
argument_list|,
name|NAME
argument_list|,
name|b2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|uidf
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|b2
index|[
name|i
operator|++
index|]
operator|)
operator|&&
name|c
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
name|n
operator|>=
literal|12
condition|)
break|break;
name|gcosid
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|gcosid
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|card
argument_list|(
literal|'L'
argument_list|,
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantmail
condition|)
block|{
name|card
argument_list|(
literal|'M'
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|identf
condition|)
name|card
argument_list|(
literal|'Q'
argument_list|,
name|b2
argument_list|)
expr_stmt|;
comment|/*mail back $IDENT card.*/
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|pidfn
argument_list|()
end_macro

begin_comment
comment|/*rewrite using mktemp. MRW*/
end_comment

begin_block
block|{
name|int
name|out
parameter_list|()
function_decl|;
while|while
condition|(
name|tfname
index|[
name|INCHAR
index|]
operator|!=
literal|'X'
condition|)
name|INCHAR
operator|++
expr_stmt|;
name|INCHAR
operator|--
expr_stmt|;
name|mktemp
argument_list|(
name|cfname
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|zfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|out
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|i
operator|=
name|INCHAR
expr_stmt|;
for|for
control|(
init|;
name|cfname
index|[
name|i
index|]
operator|!=
name|FIRSTCHAR
condition|;
name|cfname
index|[
name|i
index|]
operator|--
control|)
name|unlink
argument_list|(
name|cfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfname
index|[
name|i
index|]
operator|!=
name|FIRSTCHAR
condition|)
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|lfname
index|[
name|i
index|]
operator|!=
name|FIRSTCHAR
condition|;
name|lfname
index|[
name|i
index|]
operator|--
control|)
name|unlink
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfname
index|[
name|i
index|]
operator|!=
name|FIRSTCHAR
condition|)
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|zfname
index|[
name|i
index|]
operator|!=
name|FIRSTCHAR
condition|;
name|zfname
index|[
name|i
index|]
operator|--
control|)
name|unlink
argument_list|(
name|zfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

