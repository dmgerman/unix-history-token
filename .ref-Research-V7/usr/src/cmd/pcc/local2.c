begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"mfile2"
end_include

begin_comment
comment|/* a lot of the machine dependent parts of the second pass */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|n
parameter_list|)
value|((1L<<n)-1)
end_define

begin_macro
name|lineid
argument_list|(
argument|l
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* identify line l and file fn */
name|printf
argument_list|(
literal|"/	line %d, file %s\n"
argument_list|,
name|l
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eobl2
argument_list|()
end_macro

begin_block
block|{
name|OFFSZ
name|spoff
decl_stmt|;
comment|/* offset from stack pointer */
name|spoff
operator|=
name|maxoff
expr_stmt|;
if|if
condition|(
name|spoff
operator|>=
name|AUTOINIT
condition|)
name|spoff
operator|-=
name|AUTOINIT
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	.F%d = %Ld.\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|fltused
condition|)
block|{
name|fltused
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"	.globl	fltused\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_struct
struct|struct
name|hoptab
block|{
name|int
name|opmask
decl_stmt|;
name|char
modifier|*
name|opstring
decl_stmt|;
block|}
name|ioptab
index|[]
init|=
block|{
name|ASG
name|PLUS
block|,
literal|"add"
block|,
name|ASG
name|MINUS
block|,
literal|"sub"
block|,
name|ASG
name|OR
block|,
literal|"bis"
block|,
name|ASG
name|AND
block|,
literal|"bic"
block|,
name|ASG
name|ER
block|,
literal|"xor"
block|,
name|ASG
name|MUL
block|,
literal|"mul"
block|,
name|ASG
name|DIV
block|,
literal|"div"
block|,
name|ASG
name|MOD
block|,
literal|"div"
block|,
name|ASG
name|LS
block|,
literal|"asl"
block|,
name|ASG
name|RS
block|,
literal|"asr"
block|,
operator|-
literal|1
block|,
literal|""
block|}
struct|;
end_struct

begin_macro
name|hopcode
argument_list|(
argument|f
argument_list|,
argument|o
argument_list|)
end_macro

begin_block
block|{
comment|/* output the appropriate string from the above table */
specifier|register
name|struct
name|hoptab
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|ioptab
init|;
name|q
operator|->
name|opmask
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|opmask
operator|==
name|o
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|q
operator|->
name|opstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|'F'
condition|)
name|printf
argument_list|(
literal|"f"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|cerror
argument_list|(
literal|"no hoptab for %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
comment|/* keyed to register number tokens */
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"sp"
block|,
literal|"pc"
block|,
literal|"fr0"
block|,
literal|"fr1"
block|,
literal|"fr2"
block|,
literal|"fr3"
block|,
literal|"fr4"
block|,
literal|"fr5"
block|,
comment|/* not accumulators - used for temps */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rstatus
index|[]
init|=
block|{
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
comment|/* use as scratch if not reg var */
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SBREG
operator||
name|STBREG
block|,
name|SBREG
operator||
name|STBREG
block|,
name|SBREG
operator||
name|STBREG
block|,
name|SBREG
operator||
name|STBREG
block|,
name|SBREG
block|,
name|SBREG
block|, 	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|brnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brcase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|toff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of stack locations used for args */
end_comment

begin_macro
name|zzzcode
argument_list|(
argument|p
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|m
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* output b if type is byte */
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CHAR
operator|||
name|p
operator|->
name|type
operator|==
name|UCHAR
condition|)
name|printf
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'N'
case|:
comment|/* logical ops, turned into 0-1 */
comment|/* use register given by register 1 */
name|cbgen
argument_list|(
literal|0
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	clr	%s\n"
argument_list|,
name|rnames
index|[
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|LONG
operator|||
name|p
operator|->
name|type
operator|==
name|ULONG
condition|)
name|printf
argument_list|(
literal|"	clr	%s\n"
argument_list|,
name|rnames
index|[
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|rval
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
case|case
literal|'F'
case|:
name|cbgen
argument_list|(
name|p
operator|->
name|op
argument_list|,
name|p
operator|->
name|label
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
case|case
literal|'C'
case|:
comment|/* logical operators for longs 		   defer comparisons until branch occurs */
name|brnode
operator|=
name|tcopy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|brcase
operator|=
name|c
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* fix up unsigned shifts */
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|r
operator|,
name|l
expr_stmt|;
name|TWORD
name|t
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASG
name|LS
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|ASG
name|RS
condition|)
name|cerror
argument_list|(
literal|"ZH bad"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|!=
name|REG
condition|)
name|cerror
argument_list|(
literal|"SH left bad"
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|left
operator|->
name|rval
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|l
operator|=
operator|(
name|t
operator|==
name|LONG
operator|||
name|t
operator|==
name|ULONG
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|UNSIGNED
operator|&&
name|t
operator|!=
name|UCHAR
operator|&&
name|t
operator|!=
name|ULONG
condition|)
return|return;
comment|/* signed is ok */
comment|/* there are three cases:  right side is a constant, 				and has the shift value; right side is 				a temporary reg, and has the - shift value, 				and right side is something else: A1 has the 				- shift value then */
comment|/* in the case where the value is known (rhs a constant), 				the mask is just computed and put out... */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|p
operator|->
name|right
operator|->
name|lval
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|s
operator|>=
literal|16
condition|)
block|{
name|printf
argument_list|(
literal|"	clr	r%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|s
operator|-=
literal|16
expr_stmt|;
operator|++
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|>=
literal|16
condition|)
name|printf
argument_list|(
literal|"	clr	r%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
else|else
block|{
name|m
operator|=
literal|0100000
expr_stmt|;
name|m
operator|>>=
name|s
expr_stmt|;
comment|/* sign extends... */
name|m
operator|<<=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"	bic	$%o,r%d\n"
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* general case */
if|if
condition|(
name|istnode
argument_list|(
name|p
operator|->
name|right
argument_list|)
condition|)
name|q
operator|=
name|p
operator|->
name|right
expr_stmt|;
else|else
name|q
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
expr_stmt|;
comment|/* where -shift is stored */
comment|/* first, we store the shifted value on the stack */
name|printf
argument_list|(
literal|"	mov	r%d,-(sp)\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|printf
argument_list|(
literal|"	mov	r%d,-(sp)\n"
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* now, make a mask */
name|printf
argument_list|(
literal|"	mov	$100000,r%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|printf
argument_list|(
literal|"	clr	r%d\n"
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* shift (arithmetically ) */
if|if
condition|(
name|l
condition|)
name|expand
argument_list|(
name|q
argument_list|,
name|RNOP
argument_list|,
literal|"	ashc	AR"
argument_list|)
expr_stmt|;
else|else
name|expand
argument_list|(
name|q
argument_list|,
name|RNOP
argument_list|,
literal|"	ash	AR"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",r%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
name|printf
argument_list|(
literal|"	ashc	$1,r%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"	asl	r%d\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* now, we have a mask: use it to clear sp, and reload */
if|if
condition|(
name|l
condition|)
block|{
name|printf
argument_list|(
literal|"\tbic\tr%d,(sp)\n\tmov\t(sp)+,r%d\n"
argument_list|,
name|r
operator|+
literal|1
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\tbic\tr%d,(sp)\n\tmov\t(sp)+,r%d\n"
argument_list|,
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* whew! */
return|return;
block|}
case|case
literal|'V'
case|:
comment|/* sign extend or not -- register is one less than the 		   left descendent */
name|m
operator|=
name|p
operator|->
name|left
operator|->
name|rval
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"	clr	r%d\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"	sxt	r%d\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* stack management macros */
case|case
literal|'-'
case|:
if|if
condition|(
name|toff
operator|++
condition|)
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(sp)"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'4'
case|:
if|if
condition|(
name|toff
operator|==
literal|0
condition|)
operator|++
name|toff
expr_stmt|;
comment|/* can't push doubles that way */
name|printf
argument_list|(
literal|"-(sp)"
argument_list|)
expr_stmt|;
name|toff
operator|+=
literal|4
expr_stmt|;
return|return;
case|case
literal|'~'
case|:
comment|/* complimented CR */
name|p
operator|->
name|right
operator|->
name|lval
operator|=
operator|~
name|p
operator|->
name|right
operator|->
name|lval
expr_stmt|;
name|conput
argument_list|(
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|lval
operator|=
operator|~
name|p
operator|->
name|right
operator|->
name|lval
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* negated CR */
name|p
operator|->
name|right
operator|->
name|lval
operator|=
operator|-
name|p
operator|->
name|right
operator|->
name|lval
expr_stmt|;
name|conput
argument_list|(
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|lval
operator|=
operator|-
name|p
operator|->
name|right
operator|->
name|lval
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* INIT for long constants */
block|{
name|unsigned
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|lo
operator|=
name|p
operator|->
name|left
operator|->
name|lval
operator|&
name|BITMASK
argument_list|(
name|SZINT
argument_list|)
expr_stmt|;
name|hi
operator|=
operator|(
name|p
operator|->
name|left
operator|->
name|lval
operator|>>
name|SZINT
operator|)
operator|&
name|BITMASK
argument_list|(
name|SZINT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	%o; %o\n"
argument_list|,
name|hi
argument_list|,
name|lo
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'T'
case|:
comment|/* Truncate longs for type conversions: 		    LONG|ULONG -> CHAR|UCHAR|INT|UNSIGNED 		   increment offset to second word */
name|m
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|NAME
case|:
case|case
name|OREG
case|:
name|p
operator|->
name|lval
operator|+=
name|SZINT
operator|/
name|SZCHAR
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|rfree
argument_list|(
name|p
operator|->
name|rval
argument_list|,
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|rval
operator|+=
literal|1
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|m
expr_stmt|;
name|rbusy
argument_list|(
name|p
operator|->
name|rval
argument_list|,
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"Illegal ZT type conversion"
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'U'
case|:
comment|/* same as AL for exp under U* */
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|adrput
argument_list|(
name|getlr
argument_list|(
name|p
operator|->
name|left
argument_list|,
literal|'L'
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|cerror
argument_list|(
literal|"Illegal ZU"
argument_list|)
expr_stmt|;
comment|/* NO RETURN */
case|case
literal|'W'
case|:
comment|/* structure size */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STASG
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|p
operator|->
name|stsize
argument_list|)
expr_stmt|;
else|else
name|cerror
argument_list|(
literal|"Not a structure"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* structure assignment */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|size
operator|,
name|count
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STASG
condition|)
block|{
name|l
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STARG
condition|)
block|{
comment|/* store an arg onto the stack */
name|r
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
else|else
name|cerror
argument_list|(
literal|"STASG bad"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|ICON
condition|)
name|r
operator|->
name|op
operator|=
name|NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|REG
condition|)
name|r
operator|->
name|op
operator|=
name|OREG
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|!=
name|OREG
condition|)
name|cerror
argument_list|(
literal|"STASG-r"
argument_list|)
expr_stmt|;
name|size
operator|=
name|p
operator|->
name|stsize
expr_stmt|;
name|count
operator|=
name|size
operator|/
literal|2
expr_stmt|;
name|r
operator|->
name|lval
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STASG
condition|)
name|l
operator|->
name|lval
operator|+=
name|size
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* simple load/store loop */
name|r
operator|->
name|lval
operator|-=
literal|2
expr_stmt|;
name|expand
argument_list|(
name|r
argument_list|,
name|FOREFF
argument_list|,
literal|"	mov	AR,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STASG
condition|)
block|{
name|l
operator|->
name|lval
operator|-=
literal|2
expr_stmt|;
name|expand
argument_list|(
name|l
argument_list|,
name|FOREFF
argument_list|,
literal|"AR\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"-(sp)\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|NAME
condition|)
name|r
operator|->
name|op
operator|=
name|ICON
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|OREG
condition|)
name|r
operator|->
name|op
operator|=
name|REG
expr_stmt|;
block|}
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal zzzcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rmove
argument_list|(
argument|rt
argument_list|,
argument|rs
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"	%s	%s,%s\n"
argument_list|,
operator|(
name|t
operator|==
name|FLOAT
operator|||
name|t
operator|==
name|DOUBLE
operator|)
condition|?
literal|"movf"
else|:
literal|"mov"
argument_list|,
name|rnames
index|[
name|rs
index|]
argument_list|,
name|rnames
index|[
name|rt
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|respref
name|respref
index|[]
init|=
block|{
name|INTAREG
operator||
name|INTBREG
block|,
name|INTAREG
operator||
name|INTBREG
block|,
name|INAREG
operator||
name|INBREG
block|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|SNAME
operator||
name|STARNM
operator||
name|SCON
block|,
name|INTEMP
block|,
name|INTEMP
block|,
name|FORARG
block|,
name|FORARG
block|,
name|INTAREG
block|,
name|SOREG
operator||
name|SNAME
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setregs
argument_list|()
end_macro

begin_block
block|{
comment|/* set up temporary registers */
specifier|register
name|i
expr_stmt|;
comment|/* use any unused variable registers as scratch registers */
name|fregs
operator|=
name|maxtreg
operator|>=
name|MINRVAR
condition|?
name|maxtreg
operator|+
literal|1
else|:
name|MINRVAR
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
block|{
comment|/* -x changes number of free regs to 2, -xx to 3, etc. */
if|if
condition|(
operator|(
name|xdebug
operator|+
literal|1
operator|)
operator|<
name|fregs
condition|)
name|fregs
operator|=
name|xdebug
operator|+
literal|1
expr_stmt|;
block|}
comment|/* NOTE: for pdp11 fregs<= 4 for float regs */
if|if
condition|(
name|fregs
operator|>
literal|4
condition|)
name|fregs
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MINRVAR
init|;
name|i
operator|<=
name|MAXRVAR
condition|;
name|i
operator|++
control|)
name|rstatus
index|[
name|i
index|]
operator|=
name|i
operator|<
name|fregs
condition|?
name|SAREG
operator||
name|STAREG
else|:
name|SAREG
expr_stmt|;
block|}
end_block

begin_macro
name|szty
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* size, in words, needed to hold thing of type t */
comment|/* really is the number of registers to hold type t */
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
return|return
operator|(
name|SZLONG
operator|/
name|SZINT
operator|)
return|;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|rewfld
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|callreg
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|p
operator|->
name|type
operator|==
name|DOUBLE
operator|||
name|p
operator|->
name|type
operator|==
name|FLOAT
operator|)
condition|?
name|FR0
else|:
name|R0
operator|)
return|;
block|}
end_block

begin_macro
name|shltype
argument_list|(
argument|o
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|flshape
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|==
name|STARNM
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shtemp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|REG
operator|||
name|p
operator|->
name|op
operator|==
name|OREG
condition|)
return|return
operator|(
operator|!
name|istreg
argument_list|(
name|p
operator|->
name|rval
argument_list|)
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|op
operator|==
name|ICON
operator|)
return|;
block|}
end_block

begin_macro
name|spsz
argument_list|(
argument|t
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONSZ
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* is v the size to increment something of type t */
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPTR
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|v
operator|==
literal|2
operator|)
return|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|UCHAR
case|:
case|case
name|CHAR
case|:
return|return
operator|(
name|v
operator|==
literal|1
operator|)
return|;
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
return|return
operator|(
name|v
operator|==
literal|2
operator|)
return|;
case|case
name|FLOAT
case|:
return|return
operator|(
name|v
operator|==
literal|4
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
name|v
operator|==
literal|8
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shumul
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|o
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|OREG
operator|||
name|o
operator|==
name|ICON
condition|)
return|return
operator|(
name|STARNM
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|INCR
operator|||
name|o
operator|==
name|ASG
name|MINUS
operator|)
operator|&&
operator|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
operator|)
operator|&&
name|p
operator|->
name|right
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|spsz
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|,
name|p
operator|->
name|right
operator|->
name|lval
argument_list|)
condition|)
return|return
operator|(
name|STARREG
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|adrcon
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|CONSZ
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|conput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal conput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|insput
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"insput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|upput
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* output the address of the second word in the 	   pair pointed to by p (for LONGs)*/
name|CONSZ
name|save
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
name|save
operator|=
name|p
operator|->
name|lval
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|p
operator|->
name|lval
operator|+=
name|SZINT
operator|/
name|SZCHAR
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICON
case|:
comment|/* addressable value of the constant */
name|p
operator|->
name|lval
operator|&=
name|BITMASK
argument_list|(
name|SZINT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OREG
case|:
name|p
operator|->
name|lval
operator|+=
name|SZINT
operator|/
name|SZCHAR
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rval
operator|==
name|R5
condition|)
block|{
comment|/* in the argument region */
if|if
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|werror
argument_list|(
literal|"bad arg temp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal upper address"
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|lval
operator|=
name|save
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|adrput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* output an address, with offsets, from p */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ICON
case|:
comment|/* addressable value of the constant */
if|if
condition|(
name|szty
argument_list|(
name|p
operator|->
name|type
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* print the high order value */
name|CONSZ
name|save
decl_stmt|;
name|save
operator|=
name|p
operator|->
name|lval
expr_stmt|;
name|p
operator|->
name|lval
operator|=
operator|(
name|p
operator|->
name|lval
operator|>>
name|SZINT
operator|)
operator|&
name|BITMASK
argument_list|(
name|SZINT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|lval
operator|=
name|save
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|OREG
case|:
if|if
condition|(
name|p
operator|->
name|rval
operator|==
name|R5
condition|)
block|{
comment|/* in the argument region */
if|if
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|werror
argument_list|(
literal|"bad arg temp"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".(r5)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNARY
name|MUL
case|:
comment|/* STARNM or STARREG found */
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|STARNM
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* STARREG - really auto inc or dec */
comment|/* turn into OREG so replacement node will 			   reflect the value of the expression */
specifier|register
name|i
expr_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|q
operator|=
name|l
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|OREG
expr_stmt|;
name|p
operator|->
name|rall
operator|=
name|q
operator|->
name|rall
expr_stmt|;
name|p
operator|->
name|lval
operator|=
name|q
operator|->
name|lval
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|q
operator|->
name|rval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|name
index|[
name|i
index|]
operator|=
name|q
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|op
operator|==
name|INCR
condition|)
block|{
name|adrput
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|p
operator|->
name|lval
operator|-=
name|l
operator|->
name|right
operator|->
name|lval
expr_stmt|;
block|}
else|else
block|{
comment|/* l->op == ASG MINUS */
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|tfree
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal address"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|acon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* print out a constant */
if|if
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* constant only */
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|lval
operator|==
literal|0
condition|)
block|{
comment|/* name only */
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* name + offset */
name|printf
argument_list|(
literal|"%.8s+"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|genscall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure valued call */
return|return
operator|(
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate the call given by p */
specifier|register
name|temp
expr_stmt|;
specifier|register
name|m
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|temp
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
block|{
comment|/* generate args */
name|genargs
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shltype
argument_list|(
name|p
operator|->
name|left
operator|->
name|op
argument_list|,
name|p
operator|->
name|left
argument_list|)
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|INAREG
operator||
name|SOREG
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|op
operator|=
name|UNARY
name|CALL
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
name|popargs
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|popargs
argument_list|(
name|size
argument_list|)
specifier|register
name|size
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* pop arguments from stack */
name|toff
operator|-=
name|size
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|toff
operator|==
literal|0
operator|&&
name|size
operator|>=
literal|2
condition|)
name|size
operator|-=
literal|2
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"	tst	(sp)+\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"	cmp	(sp)+,(sp)+\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"	add	$%d.,sp\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|ccbranches
index|[]
init|=
block|{
literal|"	jeq	L%d\n"
block|,
literal|"	jne	L%d\n"
block|,
literal|"	jle	L%d\n"
block|,
literal|"	jlt	L%d\n"
block|,
literal|"	jge	L%d\n"
block|,
literal|"	jgt	L%d\n"
block|,
literal|"	jlos	L%d\n"
block|,
literal|"	jlo	L%d\n"
block|,
literal|"	jhis	L%d\n"
block|,
literal|"	jhi	L%d\n"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	long branch table     This table, when indexed by a logical operator,    selects a set of three logical conditions required    to generate long comparisons and branches.  A zero    entry indicates that no branch is required.    E.G.:  The<= operator would generate: 	cmp	AL,AR 	jlt	lable	/ 1st entry LT -> lable 	jgt	1f	/ 2nd entry GT -> 1f 	cmp	UL,UR 	jlos	lable	/ 3rd entry ULE -> lable    1:  */
end_comment

begin_decl_stmt
name|int
name|lbranches
index|[]
index|[
literal|3
index|]
init|=
block|{
comment|/*EQ*/
literal|0
block|,
name|NE
block|,
name|EQ
block|,
comment|/*NE*/
name|NE
block|,
literal|0
block|,
name|NE
block|,
comment|/*LE*/
name|LT
block|,
name|GT
block|,
name|ULE
block|,
comment|/*LT*/
name|LT
block|,
name|GT
block|,
name|ULT
block|,
comment|/*GE*/
name|GT
block|,
name|LT
block|,
name|UGE
block|,
comment|/*GT*/
name|GT
block|,
name|LT
block|,
name|UGT
block|,
comment|/*ULE*/
name|ULT
block|,
name|UGT
block|,
name|ULE
block|,
comment|/*ULT*/
name|ULT
block|,
name|UGT
block|,
name|ULT
block|,
comment|/*UGE*/
name|UGT
block|,
name|ULT
block|,
name|UGE
block|,
comment|/*UGT*/
name|UGT
block|,
name|ULT
block|,
name|UGT
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logical relations when compared in reverse order (cmp R,L) */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|revrel
index|[]
decl_stmt|;
end_decl_stmt

begin_macro
name|cbgen
argument_list|(
argument|o
argument_list|,
argument|lab
argument_list|,
argument|mode
argument_list|)
end_macro

begin_block
block|{
comment|/*   printf conditional and unconditional branches */
specifier|register
operator|*
name|plb
expr_stmt|;
name|int
name|lab1f
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"	jbr	L%d\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|o
operator|>
name|UGT
condition|)
name|cerror
argument_list|(
literal|"bad conditional branch: %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|brcase
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'C'
case|:
name|plb
operator|=
name|lbranches
index|[
name|o
operator|-
name|EQ
index|]
expr_stmt|;
name|lab1f
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|expand
argument_list|(
name|brnode
argument_list|,
name|FORCC
argument_list|,
name|brcase
operator|==
literal|'C'
condition|?
literal|"\tcmp\tAL,AR\n"
else|:
literal|"\ttst\tAR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|plb
operator|!=
literal|0
condition|)
name|printf
argument_list|(
name|ccbranches
index|[
operator|*
name|plb
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|plb
operator|!=
literal|0
condition|)
name|printf
argument_list|(
name|ccbranches
index|[
operator|*
name|plb
operator|-
name|EQ
index|]
argument_list|,
name|lab1f
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|brnode
argument_list|,
name|FORCC
argument_list|,
name|brcase
operator|==
literal|'C'
condition|?
literal|"\tcmp\tUL,UR\n"
else|:
literal|"\ttst\tUR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|ccbranches
index|[
operator|*
operator|++
name|plb
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|lab1f
argument_list|)
expr_stmt|;
name|reclaim
argument_list|(
name|brnode
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|mode
operator|==
literal|'F'
condition|)
name|o
operator|=
name|revrel
index|[
name|o
operator|-
name|EQ
index|]
expr_stmt|;
name|printf
argument_list|(
name|ccbranches
index|[
name|o
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
break|break;
block|}
name|brcase
operator|=
literal|0
expr_stmt|;
name|brnode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|nextcook
argument_list|(
argument|p
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* we have failed to match p with cookie; try another */
if|if
condition|(
name|cookie
operator|==
name|FORREW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hopeless! */
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
operator|)
condition|)
return|return
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
name|INTEMP
operator|)
operator|&&
name|asgop
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
return|return
operator|(
name|INTEMP
operator||
name|INAREG
operator||
name|INTAREG
operator||
name|INTBREG
operator||
name|INBREG
operator|)
return|;
return|return
operator|(
name|FORREW
operator|)
return|;
block|}
end_block

begin_macro
name|lastchance
argument_list|(
argument|p
argument_list|,
argument|cook
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* forget it! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|functbl
block|{
name|int
name|fop
decl_stmt|;
name|TWORD
name|ftype
decl_stmt|;
name|char
modifier|*
name|func
decl_stmt|;
block|}
name|opfunc
index|[]
init|=
block|{
name|MUL
block|,
name|LONG
block|,
literal|"lmul"
block|,
name|DIV
block|,
name|LONG
block|,
literal|"ldiv"
block|,
name|MOD
block|,
name|LONG
block|,
literal|"lrem"
block|,
name|ASG
name|MUL
block|,
name|LONG
block|,
literal|"almul"
block|,
name|ASG
name|DIV
block|,
name|LONG
block|,
literal|"aldiv"
block|,
name|ASG
name|MOD
block|,
name|LONG
block|,
literal|"alrem"
block|,
name|MUL
block|,
name|ULONG
block|,
literal|"lmul"
block|,
name|DIV
block|,
name|ULONG
block|,
literal|"uldiv"
block|,
name|MOD
block|,
name|ULONG
block|,
literal|"ulrem"
block|,
name|ASG
name|MUL
block|,
name|ULONG
block|,
literal|"almul"
block|,
name|ASG
name|DIV
block|,
name|ULONG
block|,
literal|"auldiv"
block|,
name|ASG
name|MOD
block|,
name|ULONG
block|,
literal|"aulrem"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_expr_stmt
name|hardops
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* change hard to do operators into function calls. 	   for pdp11 do long * / %	*/
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|functbl
modifier|*
name|f
decl_stmt|;
specifier|register
name|o
expr_stmt|;
specifier|register
name|TWORD
name|t
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|LONG
operator|&&
name|t
operator|!=
name|ULONG
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|opfunc
init|;
name|f
operator|->
name|fop
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|o
operator|==
name|f
operator|->
name|fop
operator|&&
name|t
operator|==
name|f
operator|->
name|ftype
condition|)
goto|goto
name|convert
goto|;
block|}
return|return;
comment|/* need address of left node for ASG OP */
comment|/* WARNING - this won't work for long in a REG */
name|convert
label|:
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|left
operator|->
name|op
condition|)
block|{
case|case
name|UNARY
name|MUL
case|:
comment|/* convert to address */
name|p
operator|->
name|left
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|left
operator|->
name|left
expr_stmt|;
break|break;
case|case
name|NAME
case|:
comment|/* convert to ICON pointer */
name|p
operator|->
name|left
operator|->
name|op
operator|=
name|ICON
expr_stmt|;
name|p
operator|->
name|left
operator|->
name|type
operator|=
name|INCREF
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OREG
case|:
comment|/* convert OREG to address */
name|p
operator|->
name|left
operator|->
name|op
operator|=
name|REG
expr_stmt|;
name|p
operator|->
name|left
operator|->
name|type
operator|=
name|INCREF
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|lval
operator|!=
literal|0
condition|)
block|{
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|op
operator|=
name|PLUS
expr_stmt|;
name|q
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|q
operator|->
name|left
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|q
operator|->
name|right
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|right
operator|->
name|op
operator|=
name|ICON
expr_stmt|;
name|q
operator|->
name|right
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|right
operator|->
name|type
operator|=
name|INT
expr_stmt|;
name|q
operator|->
name|right
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|->
name|right
operator|->
name|lval
operator|=
name|p
operator|->
name|left
operator|->
name|lval
expr_stmt|;
name|q
operator|->
name|right
operator|->
name|rval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|left
operator|->
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|q
expr_stmt|;
block|}
break|break;
default|default:
name|cerror
argument_list|(
literal|"Bad address for hard ops"
argument_list|)
expr_stmt|;
comment|/* NO RETURN */
block|}
block|}
comment|/* build comma op for args to function */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|op
operator|=
name|CM
expr_stmt|;
name|q
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|INT
expr_stmt|;
name|q
operator|->
name|left
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|q
operator|->
name|right
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|CALL
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|q
expr_stmt|;
comment|/* put function name in left node of call */
name|p
operator|->
name|left
operator|=
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|op
operator|=
name|ICON
expr_stmt|;
name|q
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|INCREF
argument_list|(
name|FTN
operator|+
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
operator|->
name|name
argument_list|,
name|f
operator|->
name|func
argument_list|)
expr_stmt|;
name|q
operator|->
name|lval
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|rval
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
name|optim2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* do local tree transformations and optimizations */
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|AND
case|:
comment|/* commute L and R to eliminate compliments and constants */
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|ICON
operator|||
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|COMPL
condition|)
block|{
name|r
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
case|case
name|ASG
name|AND
case|:
comment|/* change meaning of AND to ~R&L - bic on pdp11 */
name|r
operator|=
name|p
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
comment|/* compliment constant */
name|r
operator|->
name|lval
operator|=
operator|~
name|r
operator|->
name|lval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|COMPL
condition|)
block|{
comment|/* ~~A => A */
name|r
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|r
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
comment|/* insert complement node */
name|p
operator|->
name|right
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|op
operator|=
name|COMPL
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|type
operator|=
name|r
operator|->
name|type
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|left
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|myreader
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|walkf
argument_list|(
name|p
argument_list|,
name|hardops
argument_list|)
expr_stmt|;
comment|/* convert ops to function calls */
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expands r-vals for fileds */
name|walkf
argument_list|(
name|p
argument_list|,
name|optim2
argument_list|)
expr_stmt|;
name|toff
operator|=
literal|0
expr_stmt|;
comment|/* stack offset swindle */
block|}
end_block

begin_expr_stmt
name|special
argument_list|(
name|p
argument_list|,
name|shape
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* special shape matching routine */
switch|switch
condition|(
name|shape
condition|)
block|{
case|case
name|SCCON
case|:
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|p
operator|->
name|lval
operator|>=
operator|-
literal|128
operator|&&
name|p
operator|->
name|lval
operator|<=
literal|127
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|SICON
case|:
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|p
operator|->
name|lval
operator|>=
literal|0
operator|&&
name|p
operator|->
name|lval
operator|<=
literal|32767
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"bad special shape"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
return|return
operator|(
name|mainp2
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

