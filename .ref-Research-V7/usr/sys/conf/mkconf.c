begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|CHAR
value|01
end_define

begin_define
define|#
directive|define
name|BLOCK
value|02
end_define

begin_define
define|#
directive|define
name|INTR
value|04
end_define

begin_define
define|#
directive|define
name|EVEN
value|010
end_define

begin_define
define|#
directive|define
name|KL
value|020
end_define

begin_define
define|#
directive|define
name|ROOT
value|040
end_define

begin_define
define|#
directive|define
name|SWAP
value|0100
end_define

begin_define
define|#
directive|define
name|PIPE
value|0200
end_define

begin_decl_stmt
name|char
modifier|*
name|btab
index|[]
init|=
block|{
literal|"rk"
block|,
literal|"rp"
block|,
literal|"rf"
block|,
literal|"tm"
block|,
literal|"tc"
block|,
literal|"hs"
block|,
literal|"hp"
block|,
literal|"ht"
block|,
literal|"rl"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ctab
index|[]
init|=
block|{
literal|"console"
block|,
literal|"pc"
block|,
literal|"lp"
block|,
literal|"dc"
block|,
literal|"dh"
block|,
literal|"dp"
block|,
literal|"dj"
block|,
literal|"dn"
block|,
literal|"mem"
block|,
literal|"rk"
block|,
literal|"rf"
block|,
literal|"rp"
block|,
literal|"tm"
block|,
literal|"hs"
block|,
literal|"hp"
block|,
literal|"ht"
block|,
literal|"du"
block|,
literal|"tty"
block|,
literal|"rl"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tab
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|address
decl_stmt|;
name|int
name|key
decl_stmt|;
name|char
modifier|*
name|codea
decl_stmt|;
name|char
modifier|*
name|codeb
decl_stmt|;
name|char
modifier|*
name|codec
decl_stmt|;
name|char
modifier|*
name|coded
decl_stmt|;
name|char
modifier|*
name|codee
decl_stmt|;
name|char
modifier|*
name|codef
decl_stmt|;
name|char
modifier|*
name|codeg
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
literal|"console"
block|,
operator|-
literal|1
block|,
literal|60
block|,
name|CHAR
operator|+
name|INTR
operator|+
name|KL
block|,
literal|"	klin; br4\n	klou; br4\n"
block|,
literal|".globl	_klrint\nklin:	jsr	r0,call; jmp _klrint\n"
block|,
literal|".globl	_klxint\nklou:	jsr	r0,call; jmp _klxint\n"
block|,
literal|""
block|,
literal|"	klopen, klclose, klread, klwrite, klioctl, nulldev, 0,"
block|,
literal|""
block|,
literal|"int	klopen(), klclose(), klread(), klwrite(), klioctl();"
block|,
literal|"mem"
block|,
operator|-
literal|1
block|,
literal|300
block|,
name|CHAR
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"	nulldev, nulldev, mmread, mmwrite, nodev, nulldev, 0, "
block|,
literal|""
block|,
literal|"int	mmread(), mmwrite();"
block|,
literal|"pc"
block|,
literal|0
block|,
literal|70
block|,
name|CHAR
operator|+
name|INTR
block|,
literal|"	pcin; br4\n	pcou; br4\n"
block|,
literal|".globl	_pcrint\npcin:	jsr	r0,call; jmp _pcrint\n"
block|,
literal|".globl	_pcpint\npcou:	jsr	r0,call; jmp _pcpint\n"
block|,
literal|""
block|,
literal|"	pcopen, pcclose, pcread, pcwrite, nodev, nulldev, 0, "
block|,
literal|""
block|,
literal|"int	pcopen(), pcclose(), pcread(), pcwrite();"
block|,
literal|"clock"
block|,
operator|-
literal|2
block|,
literal|100
block|,
name|INTR
block|,
literal|"	kwlp; br6\n"
block|,
literal|".globl	_clock\n"
block|,
literal|"kwlp:	jsr	r0,call; jmp _clock\n"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"parity"
block|,
operator|-
literal|1
block|,
literal|114
block|,
name|INTR
block|,
literal|"	trap; br7+7.		/ 11/70 parity\n"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/*  * 110 unused  * 114 memory parity  * 120 XY plotter  * 124 DR11-B  * 130 AD01& RL01 */
literal|"rl"
block|,
literal|0
block|,
literal|130
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	rlio; br5\n"
block|,
literal|".globl	_rlintr\n"
block|,
literal|"rlio:	jsr	r0,call; jmp _rlintr\n"
block|,
literal|"	nulldev, nulldev, rlstrategy,&rltab,"
block|,
literal|"	rlopen, rlclose, rlread, rlwrite, nodev, nulldev, 0,"
block|,
literal|"int	rlstrategy();\nstruct	buf	rltab;"
block|,
literal|"int	rlopen(), rlclose(), rlread(), rlwrite();"
block|,
comment|/*  * 134 AFC11  * 140 AA11  * 144 AA11  * 150-174 unused  */
literal|"lp"
block|,
literal|0
block|,
literal|200
block|,
name|CHAR
operator|+
name|INTR
block|,
literal|"	lpou; br4\n"
block|,
literal|""
block|,
literal|".globl	_lpint\nlpou:	jsr	r0,call; jmp _lpint\n"
block|,
literal|""
block|,
literal|"	lpopen, lpclose, nodev, lpwrite, nodev, nulldev, 0,"
block|,
literal|""
block|,
literal|"int	lpopen(), lpclose(), lpwrite();"
block|,
literal|"rf"
block|,
literal|0
block|,
literal|204
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	rfio; br5\n"
block|,
literal|".globl	_rfintr\n"
block|,
literal|"rfio:	jsr	r0,call; jmp _rfintr\n"
block|,
literal|"	nulldev, nulldev, rfstrategy,&rftab, "
block|,
literal|"	nulldev, nulldev, rfread, rfwrite, nodev, nulldev, 0,"
block|,
literal|"int	rfstrategy();\nstruct	buf	rftab;"
block|,
literal|"int	rfread(), rfwrite();"
block|,
literal|"hs"
block|,
literal|0
block|,
literal|204
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	hsio; br5\n"
block|,
literal|".globl	_hsintr\n"
block|,
literal|"hsio:	jsr	r0,call; jmp _hsintr\n"
block|,
literal|"	nulldev, nulldev, hsstrategy,&hstab, "
block|,
literal|"	nulldev, nulldev, hsread, hswrite, nodev, nulldev, 0,"
block|,
literal|"int	hsstrategy();\nstruct	buf	hstab;"
block|,
literal|"int	hsread(), hswrite();"
block|,
comment|/*  * 210 RC  */
literal|"tc"
block|,
literal|0
block|,
literal|214
block|,
name|BLOCK
operator|+
name|INTR
block|,
literal|"	tcio; br6\n"
block|,
literal|".globl	_tcintr\n"
block|,
literal|"tcio:	jsr	r0,call; jmp _tcintr\n"
block|,
literal|"	nulldev, tcclose, tcstrategy,&tctab,"
block|,
literal|""
block|,
literal|"int	tcstrategy(), tcclose();\nstruct	buf	tctab;"
block|,
literal|""
block|,
literal|"rk"
block|,
literal|0
block|,
literal|220
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	rkio; br5\n"
block|,
literal|".globl	_rkintr\n"
block|,
literal|"rkio:	jsr	r0,call; jmp _rkintr\n"
block|,
literal|"	nulldev, nulldev, rkstrategy,&rktab,"
block|,
literal|"	nulldev, nulldev, rkread, rkwrite, nodev, nulldev, 0,"
block|,
literal|"int	rkstrategy();\nstruct	buf	rktab;"
block|,
literal|"int	rkread(), rkwrite();"
block|,
literal|"tm"
block|,
literal|0
block|,
literal|224
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	tmio; br5\n"
block|,
literal|".globl	_tmintr\n"
block|,
literal|"tmio:	jsr	r0,call; jmp _tmintr\n"
block|,
literal|"	tmopen, tmclose, tmstrategy,&tmtab, "
block|,
literal|"	tmopen, tmclose, tmread, tmwrite, nodev, nulldev, 0,"
block|,
literal|"int	tmopen(), tmclose(), tmstrategy();\nstruct	buf	tmtab;"
block|,
literal|"int	tmread(), tmwrite();"
block|,
literal|"ht"
block|,
literal|0
block|,
literal|224
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	htio; br5\n"
block|,
literal|".globl	_htintr\n"
block|,
literal|"htio:	jsr	r0,call; jmp _htintr\n"
block|,
literal|"	htopen, htclose, htstrategy,&httab,"
block|,
literal|"	htopen, htclose, htread, htwrite, nodev, nulldev, 0,"
block|,
literal|"int	htopen(), htclose(), htstrategy();\nstruct	buf	httab;"
block|,
literal|"int	htread(), htwrite();"
block|,
literal|"cr"
block|,
literal|0
block|,
literal|230
block|,
name|CHAR
operator|+
name|INTR
block|,
literal|"	crin; br6\n"
block|,
literal|""
block|,
literal|".globl	_crint\ncrin:	jsr	r0,call; jmp _crint\n"
block|,
literal|""
block|,
literal|"	cropen, crclose, crread, nodev, nodev, nulldev, 0,"
block|,
literal|""
block|,
literal|"int	cropen(), crclose(), crread();"
block|,
comment|/*  * 234 UDC11  */
literal|"rp"
block|,
literal|0
block|,
literal|254
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	rpio; br5\n"
block|,
literal|".globl	_rpintr\n"
block|,
literal|"rpio:	jsr	r0,call; jmp _rpintr\n"
block|,
literal|"	nulldev, nulldev, rpstrategy,&rptab,"
block|,
literal|"	nulldev, nulldev, rpread, rpwrite, nodev, nulldev, 0,"
block|,
literal|"int	rpstrategy();\nstruct	buf	rptab;"
block|,
literal|"int	rpread(), rpwrite();"
block|,
literal|"hp"
block|,
literal|0
block|,
literal|254
block|,
name|BLOCK
operator|+
name|CHAR
operator|+
name|INTR
block|,
literal|"	hpio; br5\n"
block|,
literal|".globl	_hpintr\n"
block|,
literal|"hpio:	jsr	r0,call; jmp _hpintr\n"
block|,
literal|"	nulldev, nulldev, hpstrategy,&hptab,"
block|,
literal|"	nulldev, nulldev, hpread, hpwrite, nodev, nulldev, 0,"
block|,
literal|"int	hpstrategy();\nstruct	buf	hptab;"
block|,
literal|"int	hpread(), hpwrite();"
block|,
comment|/*  * 260 TA11  * 264-274 unused  */
literal|"dc"
block|,
literal|0
block|,
literal|308
block|,
name|CHAR
operator|+
name|INTR
block|,
literal|"	dcin; br5+%d.\n	dcou; br5+%d.\n"
block|,
literal|".globl	_dcrint\ndcin:	jsr	r0,call; jmp _dcrint\n"
block|,
literal|".globl	_dcxint\ndcou:	jsr	r0,call; jmp _dcxint\n"
block|,
literal|""
block|,
literal|"	dcopen, dcclose, dcread, dcwrite, dcioctl, nulldev, dc11,"
block|,
literal|""
block|,
literal|"int	dcopen(), dcclose(), dcread(), dcwrite(), dcioctl();\nstruct	tty	dc11[];"
block|,
literal|"kl"
block|,
literal|0
block|,
literal|308
block|,
name|INTR
operator|+
name|KL
block|,
literal|"	klin; br4+%d.\n	klou; br4+%d.\n"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"dp"
block|,
literal|0
block|,
literal|308
block|,
name|CHAR
operator|+
name|INTR
block|,
literal|"	dpin; br6+%d.\n	dpou; br6+%d.\n"
block|,
literal|".globl	_dprint\ndpin:	jsr	r0,call; jmp _dprint\n"
block|,
literal|".globl	_dpxint\ndpou:	jsr	r0,call; jmp _dpxint\n"
block|,
literal|""
block|,
literal|"	dpopen, dpclose, dpread, dpwrite, nodev, nulldev, 0,"
block|,
literal|""
block|,
literal|"int	dpopen(), dpclose(), dpread(), dpwrite();"
block|,
comment|/*  * DM11-A  */
literal|"dn"
block|,
literal|0
block|,
literal|304
block|,
name|CHAR
operator|+
name|INTR
block|,
literal|"	dnou; br5+%d.\n"
block|,
literal|""
block|,
literal|".globl	_dnint\ndnou:	jsr	r0,call; jmp _dnint\n"
block|,
literal|""
block|,
literal|"	dnopen, dnclose, nodev, dnwrite, nodev, nulldev, 0,"
block|,
literal|""
block|,
literal|"int	dnopen(), dnclose(), dnwrite();"
block|,
literal|"dhdm"
block|,
literal|0
block|,
literal|304
block|,
name|INTR
block|,
literal|"	dmin; br4+%d.\n"
block|,
literal|""
block|,
literal|".globl	_dmint\ndmin:	jsr	r0,call; jmp _dmint\n"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/*  * DR11-A+  * DR11-C+  * PA611+  * PA611+  * DT11+  * DX11+  */
literal|"dl"
block|,
literal|0
block|,
literal|308
block|,
name|INTR
operator|+
name|KL
block|,
literal|"	klin; br4+%d.\n	klou; br4+%d.\n"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/*  * DJ11  */
literal|"dh"
block|,
literal|0
block|,
literal|308
block|,
name|CHAR
operator|+
name|INTR
operator|+
name|EVEN
block|,
literal|"	dhin; br5+%d.\n	dhou; br5+%d.\n"
block|,
literal|".globl	_dhrint\ndhin:	jsr	r0,call; jmp _dhrint\n"
block|,
literal|".globl	_dhxint\ndhou:	jsr	r0,call; jmp _dhxint\n"
block|,
literal|""
block|,
literal|"	dhopen, dhclose, dhread, dhwrite, dhioctl, dhstop, dh11,"
block|,
literal|""
block|,
literal|"int	dhopen(), dhclose(), dhread(), dhwrite(), dhioctl(), dhstop();\nstruct	tty	dh11[];"
block|,
comment|/*  * GT40  * LPS+  * DQ11  * KW11-W  */
literal|"du"
block|,
literal|0
block|,
literal|308
block|,
name|CHAR
operator|+
name|INTR
block|,
literal|"	duin; br6+%d.\n	duou; br6+%d.\n"
block|,
literal|".globl	_durint\nduin:	jsr	r0,call; jmp _durint\n"
block|,
literal|".globl	_duxint\nduou:	jsr	r0,call; jmp _duxint\n"
block|,
literal|""
block|,
literal|"	duopen, duclose, duread, duwrite, nodev, nulldev, 0,"
block|,
literal|""
block|,
literal|"int	duopen(), duclose(), duread(), duwrite();"
block|,
literal|"tty"
block|,
literal|1
block|,
literal|0
block|,
name|CHAR
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"	syopen, nulldev, syread, sywrite, sysioctl, nulldev, 0,"
block|,
literal|""
block|,
literal|"int	syopen(), syread(), sywrite(), sysioctl();"
block|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|stra
index|[]
init|=
block|{
literal|"/ low core"
block|,
literal|""
block|,
literal|".data"
block|,
literal|"ZERO:"
block|,
literal|""
block|,
literal|"br4 = 200"
block|,
literal|"br5 = 240"
block|,
literal|"br6 = 300"
block|,
literal|"br7 = 340"
block|,
literal|""
block|,
literal|". = ZERO+0"
block|,
literal|"	br	1f"
block|,
literal|"	4"
block|,
literal|""
block|,
literal|"/ trap vectors"
block|,
literal|"	trap; br7+0.		/ bus error"
block|,
literal|"	trap; br7+1.		/ illegal instruction"
block|,
literal|"	trap; br7+2.		/ bpt-trace trap"
block|,
literal|"	trap; br7+3.		/ iot trap"
block|,
literal|"	trap; br7+4.		/ power fail"
block|,
literal|"	trap; br7+5.		/ emulator trap"
block|,
literal|"	start;br7+6.		/ system  (overlaid by 'trap')"
block|,
literal|""
block|,
literal|". = ZERO+40"
block|,
literal|".globl	start, dump"
block|,
literal|"1:	jmp	start"
block|,
literal|"	jmp	dump"
block|,
literal|""
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strb
index|[]
init|=
block|{
literal|""
block|,
literal|". = ZERO+240"
block|,
literal|"	trap; br7+7.		/ programmed interrupt"
block|,
literal|"	trap; br7+8.		/ floating point"
block|,
literal|"	trap; br7+9.		/ segmentation violation"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strc
index|[]
init|=
block|{
literal|""
block|,
literal|"/ floating vectors"
block|,
literal|". = ZERO+300"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strd
index|[]
init|=
block|{
literal|""
block|,
literal|"//////////////////////////////////////////////////////"
block|,
literal|"/		interface code to C"
block|,
literal|"//////////////////////////////////////////////////////"
block|,
literal|""
block|,
literal|".text"
block|,
literal|".globl	call, trap"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stre
index|[]
init|=
block|{
literal|"#include \"../h/param.h\""
block|,
literal|"#include \"../h/systm.h\""
block|,
literal|"#include \"../h/buf.h\""
block|,
literal|"#include \"../h/tty.h\""
block|,
literal|"#include \"../h/conf.h\""
block|,
literal|"#include \"../h/proc.h\""
block|,
literal|"#include \"../h/text.h\""
block|,
literal|"#include \"../h/dir.h\""
block|,
literal|"#include \"../h/user.h\""
block|,
literal|"#include \"../h/file.h\""
block|,
literal|"#include \"../h/inode.h\""
block|,
literal|"#include \"../h/acct.h\""
block|,
literal|""
block|,
literal|"int	nulldev();"
block|,
literal|"int	nodev();"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stre1
index|[]
init|=
block|{
literal|"struct	bdevsw	bdevsw[] ="
block|,
literal|"{"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strf
index|[]
init|=
block|{
literal|"	0"
block|,
literal|"};"
block|,
literal|""
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strf1
index|[]
init|=
block|{
literal|""
block|,
literal|"struct	cdevsw	cdevsw[] ="
block|,
literal|"{"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|strg
index|[]
init|=
block|{
literal|"	0\n\ };\n\ int	rootdev	= makedev(%d, %d);\n\ int	swapdev	= makedev(%d, %d);\n\ int	pipedev = makedev(%d, %d);\n\ int	nldisp = %d;\n\ daddr_t	swplo	= %ld;\n\ int	nswap	= %l;\n\ "
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|strg1
index|[]
init|=
block|{
literal|"	\n\ struct	buf	buf[NBUF];\n\ struct	file	file[NFILE];\n\ struct	inode	inode[NINODE];\n"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strg1a
index|[]
init|=
block|{
literal|"int	mpxchan();"
block|,
literal|"int	(*ldmpx)() = mpxchan;"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|strg2
index|[]
init|=
block|{
literal|"struct	proc	proc[NPROC];\n\ struct	text	text[NTEXT];\n\ struct	buf	bfreelist;\n\ struct	acct	acctbuf;\n\ struct	inode	*acctp;\n"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strh
index|[]
init|=
block|{
literal|"	0"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"int	ttyopen(), ttyclose(), ttread(), ttwrite(), ttyinput(), ttstart();"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stri
index|[]
init|=
block|{
literal|"int	pkopen(), pkclose(), pkread(), pkwrite(), pkioctl(), pkrint(), pkxint();"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strj
index|[]
init|=
block|{
literal|"struct	linesw	linesw[] ="
block|,
literal|"{"
block|,
literal|"	ttyopen, nulldev, ttread, ttwrite, nodev, ttyinput, ttstart, /* 0 */"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strk
index|[]
init|=
block|{
literal|"	pkopen, pkclose, pkread, pkwrite, pkioctl, pkrint, pkxint, /* 1 */"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mpx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rootmaj
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rootmin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swapmaj
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swapmin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pipemaj
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pipemin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|swplo
init|=
literal|4000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nswap
init|=
literal|872
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nldisp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
specifier|register
name|struct
name|tab
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|ev
decl_stmt|,
name|nkl
decl_stmt|;
name|int
name|flagf
decl_stmt|,
name|flagb
decl_stmt|,
name|dumpht
decl_stmt|;
while|while
condition|(
name|input
argument_list|()
condition|)
empty_stmt|;
comment|/*  * pass1 -- create interrupt vectors  */
name|nkl
operator|=
literal|0
expr_stmt|;
name|flagf
operator|=
name|flagb
operator|=
literal|1
expr_stmt|;
name|freopen
argument_list|(
literal|"l.s"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|puke
argument_list|(
name|stra
argument_list|)
expr_stmt|;
name|ev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|table
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
operator|&&
name|p
operator|->
name|key
operator|&
name|INTR
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|address
operator|>
literal|240
operator|&&
name|flagb
condition|)
block|{
name|flagb
operator|=
literal|0
expr_stmt|;
name|puke
argument_list|(
name|strb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|address
operator|>=
literal|300
condition|)
block|{
if|if
condition|(
name|flagf
condition|)
block|{
name|ev
operator|=
literal|0
expr_stmt|;
name|flagf
operator|=
literal|0
expr_stmt|;
name|puke
argument_list|(
name|strc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|key
operator|&
name|EVEN
operator|&&
name|ev
operator|&
literal|07
condition|)
block|{
name|printf
argument_list|(
literal|"	.=.+4\n"
argument_list|)
expr_stmt|;
name|ev
operator|+=
literal|4
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/%s %o\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
literal|0300
operator|+
name|ev
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n. = ZERO+%d\n"
argument_list|,
name|p
operator|->
name|address
argument_list|)
expr_stmt|;
name|n
operator|=
name|p
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
operator|-
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|key
operator|&
name|KL
condition|)
block|{
name|printf
argument_list|(
name|p
operator|->
name|codea
argument_list|,
name|nkl
argument_list|,
name|nkl
argument_list|)
expr_stmt|;
name|nkl
operator|++
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|p
operator|->
name|codea
argument_list|,
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|address
operator|<
literal|300
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s at %d\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|address
operator|+
literal|4
operator|*
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s at %o\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
literal|0300
operator|+
name|ev
argument_list|)
expr_stmt|;
name|ev
operator|+=
name|p
operator|->
name|address
operator|-
literal|300
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flagb
condition|)
name|puke
argument_list|(
name|strb
argument_list|)
expr_stmt|;
name|puke
argument_list|(
name|strd
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|table
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
operator|&&
name|p
operator|->
name|key
operator|&
name|INTR
condition|)
name|printf
argument_list|(
literal|"\n%s%s"
argument_list|,
name|p
operator|->
name|codeb
argument_list|,
name|p
operator|->
name|codec
argument_list|)
expr_stmt|;
comment|/*  * pass 2 -- create configuration table  */
name|freopen
argument_list|(
literal|"c.c"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* 	 * declarations 	 */
name|puke
argument_list|(
name|stre
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|q
operator|=
name|btab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
name|table
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|q
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|key
operator|&
name|BLOCK
operator|)
operator|&&
name|p
operator|->
name|count
operator|&&
operator|*
name|p
operator|->
name|codef
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
operator|->
name|codef
argument_list|)
expr_stmt|;
block|}
name|puke
argument_list|(
name|stre1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|q
operator|=
name|btab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
name|table
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|q
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|key
operator|&
name|BLOCK
operator|)
operator|&&
name|p
operator|->
name|count
condition|)
block|{
name|printf
argument_list|(
literal|"%s	/* %s = %d */\n"
argument_list|,
name|p
operator|->
name|coded
argument_list|,
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|key
operator|&
name|ROOT
condition|)
name|rootmaj
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|key
operator|&
name|SWAP
condition|)
name|swapmaj
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|key
operator|&
name|PIPE
condition|)
name|pipemaj
operator|=
name|i
expr_stmt|;
goto|goto
name|newb
goto|;
block|}
name|printf
argument_list|(
literal|"	nodev, nodev, nodev, 0, /* %s = %d */\n"
argument_list|,
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|newb
label|:
empty_stmt|;
block|}
if|if
condition|(
name|swapmaj
operator|==
operator|-
literal|1
condition|)
block|{
name|swapmaj
operator|=
name|rootmaj
expr_stmt|;
name|swapmin
operator|=
name|rootmin
expr_stmt|;
block|}
if|if
condition|(
name|pipemaj
operator|==
operator|-
literal|1
condition|)
block|{
name|pipemaj
operator|=
name|rootmaj
expr_stmt|;
name|pipemin
operator|=
name|rootmin
expr_stmt|;
block|}
name|puke
argument_list|(
name|strf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|q
operator|=
name|ctab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
name|table
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|q
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|key
operator|&
name|CHAR
operator|)
operator|&&
name|p
operator|->
name|count
operator|&&
operator|*
name|p
operator|->
name|codeg
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
operator|->
name|codeg
argument_list|)
expr_stmt|;
block|}
name|puke
argument_list|(
name|strf1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|q
operator|=
name|ctab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
name|table
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|q
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|key
operator|&
name|CHAR
operator|)
operator|&&
name|p
operator|->
name|count
condition|)
block|{
name|printf
argument_list|(
literal|"%s	/* %s = %d */\n"
argument_list|,
name|p
operator|->
name|codee
argument_list|,
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|newc
goto|;
block|}
name|printf
argument_list|(
literal|"	nodev, nodev, nodev, nodev, nodev, nulldev, 0, /* %s = %d */\n"
argument_list|,
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|newc
label|:
empty_stmt|;
block|}
name|puke
argument_list|(
name|strh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
condition|)
block|{
name|nldisp
operator|++
expr_stmt|;
name|puke
argument_list|(
name|stri
argument_list|)
expr_stmt|;
block|}
name|puke
argument_list|(
name|strj
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
condition|)
name|puke
argument_list|(
name|strk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|strg
argument_list|,
name|rootmaj
argument_list|,
name|rootmin
argument_list|,
name|swapmaj
argument_list|,
name|swapmin
argument_list|,
name|pipemaj
argument_list|,
name|pipemin
argument_list|,
name|nldisp
argument_list|,
name|swplo
argument_list|,
name|nswap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|strg1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mpx
condition|)
name|puke
argument_list|(
name|strg1a
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|strg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootmaj
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No root device given\n"
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
literal|"mch0.s"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|dumpht
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|equal
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"ht"
argument_list|)
operator|&&
name|table
index|[
name|i
index|]
operator|.
name|count
condition|)
name|dumpht
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dumpht
condition|)
block|{
name|printf
argument_list|(
literal|"HTDUMP = 1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TUDUMP = 0\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"HTDUMP = 0\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TUDUMP = 1\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|puke
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
name|printf
argument_list|(
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|input
argument_list|()
end_macro

begin_block
block|{
name|char
name|line
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|struct
name|tab
modifier|*
name|q
decl_stmt|;
name|int
name|count
decl_stmt|,
name|n
decl_stmt|;
name|long
name|num
decl_stmt|;
name|char
name|keyw
index|[
literal|32
index|]
decl_stmt|,
name|dev
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|100
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%d%s%s%ld"
argument_list|,
operator|&
name|count
argument_list|,
name|keyw
argument_list|,
name|dev
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|2
condition|)
goto|goto
name|badl
goto|;
for|for
control|(
name|q
operator|=
name|table
init|;
name|q
operator|->
name|name
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|q
operator|->
name|name
argument_list|,
name|keyw
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no more, no less\n"
argument_list|,
name|keyw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|q
operator|->
name|count
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|address
operator|<
literal|300
operator|&&
name|q
operator|->
name|count
operator|>
literal|1
condition|)
block|{
name|q
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: only one\n"
argument_list|,
name|keyw
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"nswap"
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|3
condition|)
goto|goto
name|badl
goto|;
if|if
condition|(
name|sscanf
argument_list|(
name|dev
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|num
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|badl
goto|;
name|nswap
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"swplo"
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|3
condition|)
goto|goto
name|badl
goto|;
if|if
condition|(
name|sscanf
argument_list|(
name|dev
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|num
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|badl
goto|;
name|swplo
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"pack"
argument_list|)
condition|)
block|{
name|pack
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"mpx"
argument_list|)
condition|)
block|{
name|mpx
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"done"
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"root"
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|4
condition|)
goto|goto
name|badl
goto|;
for|for
control|(
name|q
operator|=
name|table
init|;
name|q
operator|->
name|name
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|equal
argument_list|(
name|q
operator|->
name|name
argument_list|,
name|dev
argument_list|)
condition|)
block|{
name|q
operator|->
name|key
operator||=
name|ROOT
expr_stmt|;
name|rootmin
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find root\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"swap"
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|4
condition|)
goto|goto
name|badl
goto|;
for|for
control|(
name|q
operator|=
name|table
init|;
name|q
operator|->
name|name
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|equal
argument_list|(
name|q
operator|->
name|name
argument_list|,
name|dev
argument_list|)
condition|)
block|{
name|q
operator|->
name|key
operator||=
name|SWAP
expr_stmt|;
name|swapmin
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find swap\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|keyw
argument_list|,
literal|"pipe"
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|4
condition|)
goto|goto
name|badl
goto|;
for|for
control|(
name|q
operator|=
name|table
init|;
name|q
operator|->
name|name
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|equal
argument_list|(
name|q
operator|->
name|name
argument_list|,
name|dev
argument_list|)
condition|)
block|{
name|q
operator|->
name|key
operator||=
name|PIPE
expr_stmt|;
name|pipemin
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find pipe\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot find\n"
argument_list|,
name|keyw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|badl
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad line: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|equal
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|!
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

