begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: dns.c,v 1.31 2014/06/24 01:13:21 djm Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003 Wesley Griffin. All rights reserved.  * Copyright (c) 2003 Jakob Schlyter. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"dns.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|errset_text
index|[]
init|=
block|{
literal|"success"
block|,
comment|/* 0 ERRSET_SUCCESS */
literal|"out of memory"
block|,
comment|/* 1 ERRSET_NOMEMORY */
literal|"general failure"
block|,
comment|/* 2 ERRSET_FAIL */
literal|"invalid parameter"
block|,
comment|/* 3 ERRSET_INVAL */
literal|"name does not exist"
block|,
comment|/* 4 ERRSET_NONAME */
literal|"data does not exist"
block|,
comment|/* 5 ERRSET_NODATA */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dns_result_totext
parameter_list|(
name|unsigned
name|int
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|ERRSET_SUCCESS
case|:
return|return
name|errset_text
index|[
name|ERRSET_SUCCESS
index|]
return|;
case|case
name|ERRSET_NOMEMORY
case|:
return|return
name|errset_text
index|[
name|ERRSET_NOMEMORY
index|]
return|;
case|case
name|ERRSET_FAIL
case|:
return|return
name|errset_text
index|[
name|ERRSET_FAIL
index|]
return|;
case|case
name|ERRSET_INVAL
case|:
return|return
name|errset_text
index|[
name|ERRSET_INVAL
index|]
return|;
case|case
name|ERRSET_NONAME
case|:
return|return
name|errset_text
index|[
name|ERRSET_NONAME
index|]
return|;
case|case
name|ERRSET_NODATA
case|:
return|return
name|errset_text
index|[
name|ERRSET_NODATA
index|]
return|;
default|default:
return|return
literal|"unknown error"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read SSHFP parameters from key buffer.  */
end_comment

begin_function
specifier|static
name|int
name|dns_read_key
parameter_list|(
name|u_int8_t
modifier|*
name|algorithm
parameter_list|,
name|u_int8_t
modifier|*
name|digest_type
parameter_list|,
name|u_char
modifier|*
modifier|*
name|digest
parameter_list|,
name|u_int
modifier|*
name|digest_len
parameter_list|,
name|Key
modifier|*
name|key
parameter_list|)
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
name|enum
name|fp_type
name|fp_type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|key
operator|->
name|type
condition|)
block|{
case|case
name|KEY_RSA
case|:
operator|*
name|algorithm
operator|=
name|SSHFP_KEY_RSA
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|digest_type
condition|)
operator|*
name|digest_type
operator|=
name|SSHFP_HASH_SHA1
expr_stmt|;
break|break;
case|case
name|KEY_DSA
case|:
operator|*
name|algorithm
operator|=
name|SSHFP_KEY_DSA
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|digest_type
condition|)
operator|*
name|digest_type
operator|=
name|SSHFP_HASH_SHA1
expr_stmt|;
break|break;
case|case
name|KEY_ECDSA
case|:
operator|*
name|algorithm
operator|=
name|SSHFP_KEY_ECDSA
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|digest_type
condition|)
operator|*
name|digest_type
operator|=
name|SSHFP_HASH_SHA256
expr_stmt|;
break|break;
case|case
name|KEY_ED25519
case|:
operator|*
name|algorithm
operator|=
name|SSHFP_KEY_ED25519
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|digest_type
condition|)
operator|*
name|digest_type
operator|=
name|SSHFP_HASH_SHA256
expr_stmt|;
break|break;
default|default:
operator|*
name|algorithm
operator|=
name|SSHFP_KEY_RESERVED
expr_stmt|;
comment|/* 0 */
operator|*
name|digest_type
operator|=
name|SSHFP_HASH_RESERVED
expr_stmt|;
comment|/* 0 */
block|}
switch|switch
condition|(
operator|*
name|digest_type
condition|)
block|{
case|case
name|SSHFP_HASH_SHA1
case|:
name|fp_type
operator|=
name|SSH_FP_SHA1
expr_stmt|;
break|break;
case|case
name|SSHFP_HASH_SHA256
case|:
name|fp_type
operator|=
name|SSH_FP_SHA256
expr_stmt|;
break|break;
default|default:
operator|*
name|digest_type
operator|=
name|SSHFP_HASH_RESERVED
expr_stmt|;
comment|/* 0 */
block|}
if|if
condition|(
operator|*
name|algorithm
operator|&&
operator|*
name|digest_type
condition|)
block|{
operator|*
name|digest
operator|=
name|key_fingerprint_raw
argument_list|(
name|key
argument_list|,
name|fp_type
argument_list|,
name|digest_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|digest
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"dns_read_key: null from key_fingerprint_raw()"
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|digest
operator|=
name|NULL
expr_stmt|;
operator|*
name|digest_len
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Read SSHFP parameters from rdata buffer.  */
end_comment

begin_function
specifier|static
name|int
name|dns_read_rdata
parameter_list|(
name|u_int8_t
modifier|*
name|algorithm
parameter_list|,
name|u_int8_t
modifier|*
name|digest_type
parameter_list|,
name|u_char
modifier|*
modifier|*
name|digest
parameter_list|,
name|u_int
modifier|*
name|digest_len
parameter_list|,
name|u_char
modifier|*
name|rdata
parameter_list|,
name|int
name|rdata_len
parameter_list|)
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
operator|*
name|algorithm
operator|=
name|SSHFP_KEY_RESERVED
expr_stmt|;
operator|*
name|digest_type
operator|=
name|SSHFP_HASH_RESERVED
expr_stmt|;
if|if
condition|(
name|rdata_len
operator|>=
literal|2
condition|)
block|{
operator|*
name|algorithm
operator|=
name|rdata
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|digest_type
operator|=
name|rdata
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|digest_len
operator|=
name|rdata_len
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|digest_len
operator|>
literal|0
condition|)
block|{
operator|*
name|digest
operator|=
operator|(
name|u_char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|*
name|digest_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|digest
argument_list|,
name|rdata
operator|+
literal|2
argument_list|,
operator|*
name|digest_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|digest
operator|=
operator|(
name|u_char
operator|*
operator|)
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Check if hostname is numerical.  * Returns -1 if hostname is numeric, 0 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|is_numeric_hostname
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
comment|/* 	 * We shouldn't ever get a null host but if we do then log an error 	 * and return -1 which stops DNS key fingerprint processing. 	 */
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"is_numeric_hostname called with NULL hostname"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|hostname
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
operator|==
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Verify the given hostname, address and host key using DNS.  * Returns 0 if lookup succeeds, -1 otherwise  */
end_comment

begin_function
name|int
name|verify_host_key_dns
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|address
parameter_list|,
name|Key
modifier|*
name|hostkey
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
name|u_int
name|counter
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|rrsetinfo
modifier|*
name|fingerprints
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|hostkey_algorithm
decl_stmt|;
name|u_int8_t
name|hostkey_digest_type
init|=
name|SSHFP_HASH_RESERVED
decl_stmt|;
name|u_char
modifier|*
name|hostkey_digest
decl_stmt|;
name|u_int
name|hostkey_digest_len
decl_stmt|;
name|u_int8_t
name|dnskey_algorithm
decl_stmt|;
name|u_int8_t
name|dnskey_digest_type
decl_stmt|;
name|u_char
modifier|*
name|dnskey_digest
decl_stmt|;
name|u_int
name|dnskey_digest_len
decl_stmt|;
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
name|debug3
argument_list|(
literal|"verify_host_key_dns"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostkey
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"No key to look up!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_numeric_hostname
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"skipped DNS lookup for numerical hostname"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|result
operator|=
name|getrrsetbyname
argument_list|(
name|hostname
argument_list|,
name|DNS_RDATACLASS_IN
argument_list|,
name|DNS_RDATATYPE_SSHFP
argument_list|,
literal|0
argument_list|,
operator|&
name|fingerprints
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|verbose
argument_list|(
literal|"DNS lookup error: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fingerprints
operator|->
name|rri_flags
operator|&
name|RRSET_VALIDATED
condition|)
block|{
operator|*
name|flags
operator||=
name|DNS_VERIFY_SECURE
expr_stmt|;
name|debug
argument_list|(
literal|"found %d secure fingerprints in DNS"
argument_list|,
name|fingerprints
operator|->
name|rri_nrdatas
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"found %d insecure fingerprints in DNS"
argument_list|,
name|fingerprints
operator|->
name|rri_nrdatas
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize default host key parameters */
if|if
condition|(
operator|!
name|dns_read_key
argument_list|(
operator|&
name|hostkey_algorithm
argument_list|,
operator|&
name|hostkey_digest_type
argument_list|,
operator|&
name|hostkey_digest
argument_list|,
operator|&
name|hostkey_digest_len
argument_list|,
name|hostkey
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Error calculating host key fingerprint."
argument_list|)
expr_stmt|;
name|freerrset
argument_list|(
name|fingerprints
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fingerprints
operator|->
name|rri_nrdatas
condition|)
operator|*
name|flags
operator||=
name|DNS_VERIFY_FOUND
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|fingerprints
operator|->
name|rri_nrdatas
condition|;
name|counter
operator|++
control|)
block|{
comment|/* 		 * Extract the key from the answer. Ignore any badly 		 * formatted fingerprints. 		 */
if|if
condition|(
operator|!
name|dns_read_rdata
argument_list|(
operator|&
name|dnskey_algorithm
argument_list|,
operator|&
name|dnskey_digest_type
argument_list|,
operator|&
name|dnskey_digest
argument_list|,
operator|&
name|dnskey_digest_len
argument_list|,
name|fingerprints
operator|->
name|rri_rdatas
index|[
name|counter
index|]
operator|.
name|rdi_data
argument_list|,
name|fingerprints
operator|->
name|rri_rdatas
index|[
name|counter
index|]
operator|.
name|rdi_length
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
literal|"Error parsing fingerprint from DNS."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|hostkey_digest_type
operator|!=
name|dnskey_digest_type
condition|)
block|{
name|hostkey_digest_type
operator|=
name|dnskey_digest_type
expr_stmt|;
name|free
argument_list|(
name|hostkey_digest
argument_list|)
expr_stmt|;
comment|/* Initialize host key parameters */
if|if
condition|(
operator|!
name|dns_read_key
argument_list|(
operator|&
name|hostkey_algorithm
argument_list|,
operator|&
name|hostkey_digest_type
argument_list|,
operator|&
name|hostkey_digest
argument_list|,
operator|&
name|hostkey_digest_len
argument_list|,
name|hostkey
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Error calculating key fingerprint."
argument_list|)
expr_stmt|;
name|freerrset
argument_list|(
name|fingerprints
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Check if the current key is the same as the given key */
if|if
condition|(
name|hostkey_algorithm
operator|==
name|dnskey_algorithm
operator|&&
name|hostkey_digest_type
operator|==
name|dnskey_digest_type
condition|)
block|{
if|if
condition|(
name|hostkey_digest_len
operator|==
name|dnskey_digest_len
operator|&&
name|timingsafe_bcmp
argument_list|(
name|hostkey_digest
argument_list|,
name|dnskey_digest
argument_list|,
name|hostkey_digest_len
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|flags
operator||=
name|DNS_VERIFY_MATCH
expr_stmt|;
block|}
name|free
argument_list|(
name|dnskey_digest
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|hostkey_digest
argument_list|)
expr_stmt|;
comment|/* from key_fingerprint_raw() */
name|freerrset
argument_list|(
name|fingerprints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|DNS_VERIFY_FOUND
condition|)
if|if
condition|(
operator|*
name|flags
operator|&
name|DNS_VERIFY_MATCH
condition|)
name|debug
argument_list|(
literal|"matching host key fingerprint found in DNS"
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
literal|"mismatching host key fingerprint found in DNS"
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
literal|"no host key fingerprint found in DNS"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Export the fingerprint of a key as a DNS resource record  */
end_comment

begin_function
name|int
name|export_dns_rr
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|Key
modifier|*
name|key
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|generic
parameter_list|)
block|{
name|u_int8_t
name|rdata_pubkey_algorithm
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|rdata_digest_type
init|=
name|SSHFP_HASH_RESERVED
decl_stmt|;
name|u_int8_t
name|dtype
decl_stmt|;
name|u_char
modifier|*
name|rdata_digest
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|rdata_digest_len
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
for|for
control|(
name|dtype
operator|=
name|SSHFP_HASH_SHA1
init|;
name|dtype
operator|<
name|SSHFP_HASH_MAX
condition|;
name|dtype
operator|++
control|)
block|{
name|rdata_digest_type
operator|=
name|dtype
expr_stmt|;
if|if
condition|(
name|dns_read_key
argument_list|(
operator|&
name|rdata_pubkey_algorithm
argument_list|,
operator|&
name|rdata_digest_type
argument_list|,
operator|&
name|rdata_digest
argument_list|,
operator|&
name|rdata_digest_len
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|generic
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s IN TYPE%d \\# %d %02x %02x "
argument_list|,
name|hostname
argument_list|,
name|DNS_RDATATYPE_SSHFP
argument_list|,
literal|2
operator|+
name|rdata_digest_len
argument_list|,
name|rdata_pubkey_algorithm
argument_list|,
name|rdata_digest_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s IN SSHFP %d %d "
argument_list|,
name|hostname
argument_list|,
name|rdata_pubkey_algorithm
argument_list|,
name|rdata_digest_type
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdata_digest_len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%02x"
argument_list|,
name|rdata_digest
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rdata_digest
argument_list|)
expr_stmt|;
comment|/* from key_fingerprint_raw() */
name|success
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* No SSHFP record was generated at all */
if|if
condition|(
name|success
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: unsupported algorithm and/or digest_type"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function

end_unit

