begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * This file provides bootbus flash operations  *  *<hr>$Revision: 41586 $<hr>  *  *  */
end_comment

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-flash.h"
end_include

begin_define
define|#
directive|define
name|MAX_NUM_FLASH_CHIPS
value|8
end_define

begin_comment
comment|/* Maximum number of flash chips */
end_comment

begin_define
define|#
directive|define
name|MAX_NUM_REGIONS
value|8
end_define

begin_comment
comment|/* Maximum number of block regions per chip */
end_comment

begin_define
define|#
directive|define
name|DEBUG
value|1
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_NONE
value|0
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_INTEL_EXTENDED
value|1
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_AMD_STANDARD
value|2
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_INTEL_STANDARD
value|3
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_AMD_EXTENDED
value|4
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_MITSU_STANDARD
value|256
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_MITSU_EXTENDED
value|257
end_define

begin_define
define|#
directive|define
name|CFI_CMDSET_SST
value|258
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|base_ptr
decl_stmt|;
comment|/**< Memory pointer to start of flash */
name|int
name|is_16bit
decl_stmt|;
comment|/**< Chip is 16bits wide in 8bit mode */
name|uint16_t
name|vendor
decl_stmt|;
comment|/**< Vendor ID of Chip */
name|int
name|size
decl_stmt|;
comment|/**< Size of the chip in bytes */
name|uint64_t
name|erase_timeout
decl_stmt|;
comment|/**< Erase timeout in cycles */
name|uint64_t
name|write_timeout
decl_stmt|;
comment|/**< Write timeout in cycles */
name|int
name|num_regions
decl_stmt|;
comment|/**< Number of block regions */
name|cvmx_flash_region_t
name|region
index|[
name|MAX_NUM_REGIONS
index|]
decl_stmt|;
block|}
name|cvmx_flash_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_flash_t
name|flash_info
index|[
name|MAX_NUM_FLASH_CHIPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|flash_lock
init|=
name|CVMX_SPINLOCK_UNLOCKED_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @INTERNAL  * Read a byte from flash  *  * @param chip_id Chip to read from  * @param offset  Offset into the chip  * @return Value read  */
end_comment

begin_function
specifier|static
name|uint8_t
name|__cvmx_flash_read8
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
operator|(
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|base_ptr
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Read a byte from flash (for commands)  *  * @param chip_id Chip to read from  * @param offset  Offset into the chip  * @return Value read  */
end_comment

begin_function
specifier|static
name|uint8_t
name|__cvmx_flash_read_cmd
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|is_16bit
condition|)
name|offset
operator|<<=
literal|1
expr_stmt|;
return|return
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Read 16bits from flash (for commands)  *  * @param chip_id Chip to read from  * @param offset  Offset into the chip  * @return Value read  */
end_comment

begin_function
specifier|static
name|uint16_t
name|__cvmx_flash_read_cmd16
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|uint16_t
name|v
init|=
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|v
operator||=
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a byte to flash  *  * @param chip_id Chip to write to  * @param offset  Offset into the chip  * @param data    Value to write  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_flash_write8
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
specifier|volatile
name|uint8_t
modifier|*
name|flash_ptr
init|=
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|base_ptr
decl_stmt|;
name|flash_ptr
index|[
name|offset
index|]
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a byte to flash (for commands)  *  * @param chip_id Chip to write to  * @param offset  Offset into the chip  * @param data    Value to write  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_flash_write_cmd
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
specifier|volatile
name|uint8_t
modifier|*
name|flash_ptr
init|=
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|base_ptr
decl_stmt|;
name|flash_ptr
index|[
name|offset
operator|<<
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|is_16bit
index|]
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Query a address and see if a CFI flash chip is there.  *  * @param chip_id  Chip ID data to fill in if the chip is there  * @param base_ptr Memory pointer to the start address to query  * @return Zero on success, Negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_flash_queury_cfi
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|void
modifier|*
name|base_ptr
parameter_list|)
block|{
name|int
name|region
decl_stmt|;
name|cvmx_flash_t
modifier|*
name|flash
init|=
name|flash_info
operator|+
name|chip_id
decl_stmt|;
comment|/* Set the minimum needed for the read and write primitives to work */
name|flash
operator|->
name|base_ptr
operator|=
name|base_ptr
expr_stmt|;
name|flash
operator|->
name|is_16bit
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: Currently assumes the chip is 16bits */
comment|/* Put flash in CFI query mode */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x55
argument_list|,
literal|0x98
argument_list|)
expr_stmt|;
comment|/* Make sure we get the QRY response we should */
if|if
condition|(
operator|(
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x10
argument_list|)
operator|!=
literal|'Q'
operator|)
operator|||
operator|(
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x11
argument_list|)
operator|!=
literal|'R'
operator|)
operator|||
operator|(
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x12
argument_list|)
operator|!=
literal|'Y'
operator|)
condition|)
block|{
name|flash
operator|->
name|base_ptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Read the 16bit vendor ID */
name|flash
operator|->
name|vendor
operator|=
name|__cvmx_flash_read_cmd16
argument_list|(
name|chip_id
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Read the write timeout. The timeout is microseconds(us) is 2^0x1f         typically. The worst case is this value time 2^0x23 */
name|flash
operator|->
name|write_timeout
operator|=
literal|1ull
operator|<<
operator|(
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x1f
argument_list|)
operator|+
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x23
argument_list|)
operator|)
expr_stmt|;
comment|/* Read the erase timeout. The timeout is milliseconds(ms) is 2^0x21         typically. The worst case is this value time 2^0x25 */
name|flash
operator|->
name|erase_timeout
operator|=
literal|1ull
operator|<<
operator|(
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x21
argument_list|)
operator|+
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x25
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the flash size. This is 2^0x27 */
name|flash
operator|->
name|size
operator|=
literal|1
operator|<<
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x27
argument_list|)
expr_stmt|;
comment|/* Get the number of different sized block regions from 0x2c */
name|flash
operator|->
name|num_regions
operator|=
name|__cvmx_flash_read_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x2c
argument_list|)
expr_stmt|;
name|int
name|start_offset
init|=
literal|0
decl_stmt|;
comment|/* Loop through all regions get information about each */
for|for
control|(
name|region
operator|=
literal|0
init|;
name|region
operator|<
name|flash
operator|->
name|num_regions
condition|;
name|region
operator|++
control|)
block|{
name|cvmx_flash_region_t
modifier|*
name|rgn_ptr
init|=
name|flash
operator|->
name|region
operator|+
name|region
decl_stmt|;
name|rgn_ptr
operator|->
name|start_offset
operator|=
name|start_offset
expr_stmt|;
comment|/* The number of blocks in each region is a 16 bit little endian             endian field. It is encoded at 0x2d + region*4 as (blocks-1) */
name|uint16_t
name|blocks
init|=
name|__cvmx_flash_read_cmd16
argument_list|(
name|chip_id
argument_list|,
literal|0x2d
operator|+
name|region
operator|*
literal|4
argument_list|)
decl_stmt|;
name|rgn_ptr
operator|->
name|num_blocks
operator|=
literal|1u
operator|+
name|blocks
expr_stmt|;
comment|/* The size of each block is a 16 bit little endian endian field. It             is encoded at 0x2d + region*4 + 2 as (size/256). Zero is a special             case representing 128 */
name|uint16_t
name|size
init|=
name|__cvmx_flash_read_cmd16
argument_list|(
name|chip_id
argument_list|,
literal|0x2d
operator|+
name|region
operator|*
literal|4
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|rgn_ptr
operator|->
name|block_size
operator|=
literal|128
expr_stmt|;
else|else
name|rgn_ptr
operator|->
name|block_size
operator|=
literal|256u
operator|*
name|size
expr_stmt|;
name|start_offset
operator|+=
name|rgn_ptr
operator|->
name|block_size
operator|*
name|rgn_ptr
operator|->
name|num_blocks
expr_stmt|;
block|}
comment|/* Take the chip out of CFI query mode */
switch|switch
condition|(
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|vendor
condition|)
block|{
case|case
name|CFI_CMDSET_AMD_STANDARD
case|:
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
case|case
name|CFI_CMDSET_INTEL_STANDARD
case|:
case|case
name|CFI_CMDSET_INTEL_EXTENDED
case|:
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Convert the timeouts to cycles */
name|flash
operator|->
name|write_timeout
operator|*=
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|1000000
expr_stmt|;
name|flash
operator|->
name|erase_timeout
operator|*=
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|1000
expr_stmt|;
if|#
directive|if
name|DEBUG
comment|/* Print the information about the chip */
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Base pointer:  %p\n"
literal|"            Vendor:        0x%04x\n"
literal|"            Size:          %d bytes\n"
literal|"            Num regions:   %d\n"
literal|"            Erase timeout: %llu cycles\n"
literal|"            Write timeout: %llu cycles\n"
argument_list|,
name|flash
operator|->
name|base_ptr
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|flash
operator|->
name|vendor
argument_list|,
name|flash
operator|->
name|size
argument_list|,
name|flash
operator|->
name|num_regions
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|flash
operator|->
name|erase_timeout
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|flash
operator|->
name|write_timeout
argument_list|)
expr_stmt|;
for|for
control|(
name|region
operator|=
literal|0
init|;
name|region
operator|<
name|flash
operator|->
name|num_regions
condition|;
name|region
operator|++
control|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"            Region %d: offset 0x%x, %d blocks, %d bytes/block\n"
argument_list|,
name|region
argument_list|,
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|start_offset
argument_list|,
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|num_blocks
argument_list|,
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|block_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the flash access library  */
end_comment

begin_function
name|void
name|cvmx_flash_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|boot_region
decl_stmt|;
name|int
name|chip_id
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|flash_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|flash_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop through each boot bus chip select region */
for|for
control|(
name|boot_region
operator|=
literal|0
init|;
name|boot_region
operator|<
name|MAX_NUM_FLASH_CHIPS
condition|;
name|boot_region
operator|++
control|)
block|{
name|cvmx_mio_boot_reg_cfgx_t
name|region_cfg
decl_stmt|;
name|region_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_BOOT_REG_CFG0
operator|+
name|boot_region
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Only try chip select regions that are enabled. This assumes the             bootloader already setup the flash */
if|if
condition|(
name|region_cfg
operator|.
name|s
operator|.
name|en
condition|)
block|{
comment|/* Convert the hardware address to a pointer. Note that the bootbus,                 unlike memory, isn't 1:1 mapped in the simple exec */
name|void
modifier|*
name|base_ptr
init|=
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|region_cfg
operator|.
name|s
operator|.
name|base
operator|<<
literal|16
operator|)
operator||
literal|0xffffffff80000000ull
argument_list|)
decl_stmt|;
if|if
condition|(
name|__cvmx_flash_queury_cfi
argument_list|(
name|chip_id
argument_list|,
name|base_ptr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Valid CFI flash chip found */
name|chip_id
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|chip_id
operator|==
literal|0
condition|)
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: No CFI chips found\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return a pointer to the flash chip  *  * @param chip_id Chip ID to return  * @return NULL if the chip doesn't exist  */
end_comment

begin_function
name|void
modifier|*
name|cvmx_flash_get_base
parameter_list|(
name|int
name|chip_id
parameter_list|)
block|{
return|return
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|base_ptr
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of erasable regions on the chip  *  * @param chip_id Chip to return info for  * @return Number of regions  */
end_comment

begin_function
name|int
name|cvmx_flash_get_num_regions
parameter_list|(
name|int
name|chip_id
parameter_list|)
block|{
return|return
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|num_regions
return|;
block|}
end_function

begin_comment
comment|/**  * Return information about a flash chips region  *  * @param chip_id Chip to get info for  * @param region  Region to get info for  * @return Region information  */
end_comment

begin_function
specifier|const
name|cvmx_flash_region_t
modifier|*
name|cvmx_flash_get_region_info
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|region
parameter_list|)
block|{
return|return
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|region
operator|+
name|region
return|;
block|}
end_function

begin_comment
comment|/**  * Erase a block on the flash chip  *  * @param chip_id Chip to erase a block on  * @param region  Region to erase a block in  * @param block   Block number to erase  * @return Zero on success. Negative on failure  */
end_comment

begin_function
name|int
name|cvmx_flash_erase_block
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|region
parameter_list|,
name|int
name|block
parameter_list|)
block|{
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Erasing chip %d, region %d, block %d\n"
argument_list|,
name|chip_id
argument_list|,
name|region
argument_list|,
name|block
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|offset
init|=
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|region
index|[
name|region
index|]
operator|.
name|start_offset
operator|+
name|block
operator|*
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|region
index|[
name|region
index|]
operator|.
name|block_size
decl_stmt|;
switch|switch
condition|(
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|vendor
condition|)
block|{
case|case
name|CFI_CMDSET_AMD_STANDARD
case|:
block|{
comment|/* Send the erase sector command sequence */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x555
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x2aa
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x555
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x555
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x2aa
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|__cvmx_flash_write8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* Loop checking status */
name|uint8_t
name|status
init|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|uint64_t
name|start_cycle
init|=
name|cvmx_get_cycle
argument_list|()
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Read the status and xor it with the old status so we can                     find toggling bits */
name|uint8_t
name|old_status
init|=
name|status
decl_stmt|;
name|status
operator|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|uint8_t
name|toggle
init|=
name|status
operator|^
name|old_status
decl_stmt|;
comment|/* Check if the erase in progress bit is toggling */
if|if
condition|(
name|toggle
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
block|{
comment|/* Check hardware timeout */
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
block|{
comment|/* Chip has signalled a timeout. Reread the status */
name|old_status
operator|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|status
operator|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|status
operator|^
name|old_status
expr_stmt|;
comment|/* Check if the erase in progress bit is toggling */
if|if
condition|(
name|toggle
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Hardware timeout erasing block\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
break|break;
comment|/* Not toggling, erase complete */
block|}
block|}
else|else
break|break;
comment|/* Not toggling, erase complete */
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|start_cycle
operator|+
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|erase_timeout
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Timeout erasing block\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|CFI_CMDSET_INTEL_STANDARD
case|:
case|case
name|CFI_CMDSET_INTEL_EXTENDED
case|:
block|{
comment|/* Send the erase sector command sequence */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|__cvmx_flash_write8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|__cvmx_flash_write8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|,
literal|0xd0
argument_list|)
expr_stmt|;
comment|/* Loop checking status */
name|uint8_t
name|status
init|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|uint64_t
name|start_cycle
init|=
name|cvmx_get_cycle
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|status
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|start_cycle
operator|+
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|erase_timeout
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Timeout erasing block\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|status
operator|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Check the final status */
if|if
condition|(
name|status
operator|&
literal|0x7f
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Hardware failure erasing block\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Unsupported flash vendor\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Write a block on the flash chip  *  * @param chip_id Chip to write a block on  * @param region  Region to write a block in  * @param block   Block number to write  * @param data    Data to write  * @return Zero on success. Negative on failure  */
end_comment

begin_function
name|int
name|cvmx_flash_write_block
parameter_list|(
name|int
name|chip_id
parameter_list|,
name|int
name|region
parameter_list|,
name|int
name|block
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Writing chip %d, region %d, block %d\n"
argument_list|,
name|chip_id
argument_list|,
name|region
argument_list|,
name|block
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|offset
init|=
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|region
index|[
name|region
index|]
operator|.
name|start_offset
operator|+
name|block
operator|*
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|region
index|[
name|region
index|]
operator|.
name|block_size
decl_stmt|;
name|int
name|len
init|=
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|region
index|[
name|region
index|]
operator|.
name|block_size
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ptr
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|data
decl_stmt|;
switch|switch
condition|(
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|vendor
condition|)
block|{
case|case
name|CFI_CMDSET_AMD_STANDARD
case|:
block|{
comment|/* Loop through one byte at a time */
while|while
condition|(
name|len
operator|--
condition|)
block|{
comment|/* Send the program sequence */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x555
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x2aa
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x555
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
name|__cvmx_flash_write8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
comment|/* Loop polling for status */
name|uint64_t
name|start_cycle
init|=
name|cvmx_get_cycle
argument_list|()
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|uint8_t
name|status
init|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|^
operator|*
name|ptr
operator|)
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* Data matches, this byte is done */
elseif|else
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
block|{
comment|/* Hardware timeout, recheck status */
name|status
operator|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|^
operator|*
name|ptr
operator|)
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* Data matches, this byte is done */
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Hardware write timeout\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|start_cycle
operator|+
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|write_timeout
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Timeout writing block\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Increment to the next byte */
name|ptr
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|CFI_CMDSET_INTEL_STANDARD
case|:
case|case
name|CFI_CMDSET_INTEL_EXTENDED
case|:
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s:%d len=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Loop through one byte at a time */
while|while
condition|(
name|len
operator|--
condition|)
block|{
comment|/* Send the program sequence */
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|__cvmx_flash_write8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|__cvmx_flash_write8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
comment|/* Loop polling for status */
name|uint8_t
name|status
init|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|uint64_t
name|start_cycle
init|=
name|cvmx_get_cycle
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|status
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|>
name|start_cycle
operator|+
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|write_timeout
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Timeout writing block\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|status
operator|=
name|__cvmx_flash_read8
argument_list|(
name|chip_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Check the final status */
if|if
condition|(
name|status
operator|&
literal|0x7f
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Hardware failure erasing block\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Increment to the next byte */
name|ptr
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|cvmx_dprintf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|__cvmx_flash_write_cmd
argument_list|(
name|chip_id
argument_list|,
literal|0x00
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Reset the flash chip */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Unsupported flash vendor\n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|flash_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Erase and write data to a flash  *  * @param address Memory address to write to  * @param data    Data to write  * @param len     Length of the data  * @return Zero on success. Negative on failure  */
end_comment

begin_function
name|int
name|cvmx_flash_write
parameter_list|(
name|void
modifier|*
name|address
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|chip_id
decl_stmt|;
comment|/* Find which chip controls this address. Don't allow the write to span         multiple chips */
for|for
control|(
name|chip_id
operator|=
literal|0
init|;
name|chip_id
operator|<
name|MAX_NUM_FLASH_CHIPS
condition|;
name|chip_id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|base_ptr
operator|<=
name|address
operator|)
operator|&&
operator|(
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|base_ptr
operator|+
name|flash_info
index|[
name|chip_id
index|]
operator|.
name|size
operator|>=
name|address
operator|+
name|len
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|chip_id
operator|==
name|MAX_NUM_FLASH_CHIPS
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Unable to find chip that contains address %p\n"
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cvmx_flash_t
modifier|*
name|flash
init|=
name|flash_info
operator|+
name|chip_id
decl_stmt|;
comment|/* Determine which block region we need to start writing to */
name|void
modifier|*
name|region_base
init|=
name|flash
operator|->
name|base_ptr
decl_stmt|;
name|int
name|region
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|region_base
operator|+
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|num_blocks
operator|*
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|block_size
operator|<=
name|address
condition|)
block|{
name|region
operator|++
expr_stmt|;
name|region_base
operator|=
name|flash
operator|->
name|base_ptr
operator|+
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|start_offset
expr_stmt|;
block|}
comment|/* Determine which block in the region to start at */
name|int
name|block
init|=
operator|(
name|address
operator|-
name|region_base
operator|)
operator|/
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|block_size
decl_stmt|;
comment|/* Require all writes to start on block boundries */
if|if
condition|(
name|address
operator|!=
name|region_base
operator|+
name|block
operator|*
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|block_size
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-flash: Write address not aligned on a block boundry\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Loop until we're out of data */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Erase the current block */
if|if
condition|(
name|cvmx_flash_erase_block
argument_list|(
name|chip_id
argument_list|,
name|region
argument_list|,
name|block
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Write the new data */
if|if
condition|(
name|cvmx_flash_write_block
argument_list|(
name|chip_id
argument_list|,
name|region
argument_list|,
name|block
argument_list|,
name|data
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Increment to the next block */
name|data
operator|+=
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|block_size
expr_stmt|;
name|len
operator|-=
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|block_size
expr_stmt|;
name|block
operator|++
expr_stmt|;
if|if
condition|(
name|block
operator|>=
name|flash
operator|->
name|region
index|[
name|region
index|]
operator|.
name|num_blocks
condition|)
block|{
name|block
operator|=
literal|0
expr_stmt|;
name|region
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

