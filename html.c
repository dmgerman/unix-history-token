begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: html.c,v 1.183 2014/12/02 10:08:06 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008-2011, 2014 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2011, 2012, 2013, 2014 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_struct
struct|struct
name|htmldata
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|HTML_CLRLINE
value|(1<< 0)
define|#
directive|define
name|HTML_NOSTACK
value|(1<< 1)
define|#
directive|define
name|HTML_AUTOCLOSE
value|(1<< 2)
comment|/* Tag has auto-closure. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|htmldata
name|htmltags
index|[
name|TAG_MAX
index|]
init|=
block|{
block|{
literal|"html"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_HTML */
block|{
literal|"head"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_HEAD */
block|{
literal|"body"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_BODY */
block|{
literal|"meta"
block|,
name|HTML_CLRLINE
operator||
name|HTML_NOSTACK
operator||
name|HTML_AUTOCLOSE
block|}
block|,
comment|/* TAG_META */
block|{
literal|"title"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_TITLE */
block|{
literal|"div"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_DIV */
block|{
literal|"h1"
block|,
literal|0
block|}
block|,
comment|/* TAG_H1 */
block|{
literal|"h2"
block|,
literal|0
block|}
block|,
comment|/* TAG_H2 */
block|{
literal|"span"
block|,
literal|0
block|}
block|,
comment|/* TAG_SPAN */
block|{
literal|"link"
block|,
name|HTML_CLRLINE
operator||
name|HTML_NOSTACK
operator||
name|HTML_AUTOCLOSE
block|}
block|,
comment|/* TAG_LINK */
block|{
literal|"br"
block|,
name|HTML_CLRLINE
operator||
name|HTML_NOSTACK
operator||
name|HTML_AUTOCLOSE
block|}
block|,
comment|/* TAG_BR */
block|{
literal|"a"
block|,
literal|0
block|}
block|,
comment|/* TAG_A */
block|{
literal|"table"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_TABLE */
block|{
literal|"tbody"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_TBODY */
block|{
literal|"col"
block|,
name|HTML_CLRLINE
operator||
name|HTML_NOSTACK
operator||
name|HTML_AUTOCLOSE
block|}
block|,
comment|/* TAG_COL */
block|{
literal|"tr"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_TR */
block|{
literal|"td"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_TD */
block|{
literal|"li"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_LI */
block|{
literal|"ul"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_UL */
block|{
literal|"ol"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_OL */
block|{
literal|"dl"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_DL */
block|{
literal|"dt"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_DT */
block|{
literal|"dd"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_DD */
block|{
literal|"blockquote"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_BLOCKQUOTE */
block|{
literal|"pre"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_PRE */
block|{
literal|"b"
block|,
literal|0
block|}
block|,
comment|/* TAG_B */
block|{
literal|"i"
block|,
literal|0
block|}
block|,
comment|/* TAG_I */
block|{
literal|"code"
block|,
literal|0
block|}
block|,
comment|/* TAG_CODE */
block|{
literal|"small"
block|,
literal|0
block|}
block|,
comment|/* TAG_SMALL */
block|{
literal|"style"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_STYLE */
block|{
literal|"math"
block|,
name|HTML_CLRLINE
block|}
block|,
comment|/* TAG_MATH */
block|{
literal|"mrow"
block|,
literal|0
block|}
block|,
comment|/* TAG_MROW */
block|{
literal|"mi"
block|,
literal|0
block|}
block|,
comment|/* TAG_MI */
block|{
literal|"mo"
block|,
literal|0
block|}
block|,
comment|/* TAG_MO */
block|{
literal|"msup"
block|,
literal|0
block|}
block|,
comment|/* TAG_MSUP */
block|{
literal|"msub"
block|,
literal|0
block|}
block|,
comment|/* TAG_MSUB */
block|{
literal|"msubsup"
block|,
literal|0
block|}
block|,
comment|/* TAG_MSUBSUP */
block|{
literal|"mfrac"
block|,
literal|0
block|}
block|,
comment|/* TAG_MFRAC */
block|{
literal|"msqrt"
block|,
literal|0
block|}
block|,
comment|/* TAG_MSQRT */
block|{
literal|"mfenced"
block|,
literal|0
block|}
block|,
comment|/* TAG_MFENCED */
block|{
literal|"mtable"
block|,
literal|0
block|}
block|,
comment|/* TAG_MTABLE */
block|{
literal|"mtr"
block|,
literal|0
block|}
block|,
comment|/* TAG_MTR */
block|{
literal|"mtd"
block|,
literal|0
block|}
block|,
comment|/* TAG_MTD */
block|{
literal|"munderover"
block|,
literal|0
block|}
block|,
comment|/* TAG_MUNDEROVER */
block|{
literal|"munder"
block|,
literal|0
block|}
block|,
comment|/* TAG_MUNDER*/
block|{
literal|"mover"
block|,
literal|0
block|}
block|,
comment|/* TAG_MOVER*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|htmlattrs
index|[
name|ATTR_MAX
index|]
init|=
block|{
literal|"name"
block|,
comment|/* ATTR_NAME */
literal|"rel"
block|,
comment|/* ATTR_REL */
literal|"href"
block|,
comment|/* ATTR_HREF */
literal|"type"
block|,
comment|/* ATTR_TYPE */
literal|"media"
block|,
comment|/* ATTR_MEDIA */
literal|"class"
block|,
comment|/* ATTR_CLASS */
literal|"style"
block|,
comment|/* ATTR_STYLE */
literal|"id"
block|,
comment|/* ATTR_ID */
literal|"colspan"
block|,
comment|/* ATTR_COLSPAN */
literal|"charset"
block|,
comment|/* ATTR_CHARSET */
literal|"open"
block|,
comment|/* ATTR_OPEN */
literal|"close"
block|,
comment|/* ATTR_CLOSE */
literal|"mathvariant"
block|,
comment|/* ATTR_MATHVARIANT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|roffscales
index|[
name|SCALE_MAX
index|]
init|=
block|{
literal|"cm"
block|,
comment|/* SCALE_CM */
literal|"in"
block|,
comment|/* SCALE_IN */
literal|"pc"
block|,
comment|/* SCALE_PC */
literal|"pt"
block|,
comment|/* SCALE_PT */
literal|"em"
block|,
comment|/* SCALE_EM */
literal|"em"
block|,
comment|/* SCALE_MM */
literal|"ex"
block|,
comment|/* SCALE_EN */
literal|"ex"
block|,
comment|/* SCALE_BU */
literal|"em"
block|,
comment|/* SCALE_VS */
literal|"ex"
block|,
comment|/* SCALE_FS */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|bufncat
parameter_list|(
name|struct
name|html
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ctag
parameter_list|(
name|struct
name|html
modifier|*
parameter_list|,
name|enum
name|htmltag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_escape
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_encode
parameter_list|(
name|struct
name|html
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_metaf
parameter_list|(
name|struct
name|html
modifier|*
parameter_list|,
name|enum
name|mandoc_esc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_attr
parameter_list|(
name|struct
name|html
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
modifier|*
name|html_alloc
parameter_list|(
specifier|const
name|struct
name|mchars
modifier|*
name|mchars
parameter_list|,
name|char
modifier|*
name|outopts
parameter_list|)
block|{
name|struct
name|html
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|toks
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|toks
index|[
literal|0
index|]
operator|=
literal|"style"
expr_stmt|;
name|toks
index|[
literal|1
index|]
operator|=
literal|"man"
expr_stmt|;
name|toks
index|[
literal|2
index|]
operator|=
literal|"includes"
expr_stmt|;
name|toks
index|[
literal|3
index|]
operator|=
literal|"fragment"
expr_stmt|;
name|toks
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|html
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|tags
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|symtab
operator|=
name|mchars
expr_stmt|;
while|while
condition|(
name|outopts
operator|&&
operator|*
name|outopts
condition|)
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|outopts
argument_list|,
name|UNCONST
argument_list|(
name|toks
argument_list|)
argument_list|,
operator|&
name|v
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|h
operator|->
name|style
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|h
operator|->
name|base_man
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|h
operator|->
name|base_includes
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|h
operator|->
name|oflags
operator||=
name|HTML_FRAGMENT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
name|void
name|html_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|tag
decl_stmt|;
name|struct
name|html
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|html
operator|*
operator|)
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|tag
operator|=
name|h
operator|->
name|tags
operator|.
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|tags
operator|.
name|head
operator|=
name|tag
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_gen_head
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|htmlpair
name|tag
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|tag
index|[
literal|0
index|]
operator|.
name|key
operator|=
name|ATTR_CHARSET
expr_stmt|;
name|tag
index|[
literal|0
index|]
operator|.
name|val
operator|=
literal|"utf-8"
expr_stmt|;
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_META
argument_list|,
literal|1
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Print a default style-sheet. 	 */
name|t
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_STYLE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_text
argument_list|(
name|h
argument_list|,
literal|"table.head, table.foot { width: 100%; }\n"
literal|"td.head-rtitle, td.foot-os { text-align: right; }\n"
literal|"td.head-vol { text-align: center; }\n"
literal|"table.foot td { width: 50%; }\n"
literal|"table.head td { width: 33%; }\n"
literal|"div.spacer { margin: 1em 0; }\n"
argument_list|)
expr_stmt|;
name|print_tagq
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|style
condition|)
block|{
name|tag
index|[
literal|0
index|]
operator|.
name|key
operator|=
name|ATTR_REL
expr_stmt|;
name|tag
index|[
literal|0
index|]
operator|.
name|val
operator|=
literal|"stylesheet"
expr_stmt|;
name|tag
index|[
literal|1
index|]
operator|.
name|key
operator|=
name|ATTR_HREF
expr_stmt|;
name|tag
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|h
operator|->
name|style
expr_stmt|;
name|tag
index|[
literal|2
index|]
operator|.
name|key
operator|=
name|ATTR_TYPE
expr_stmt|;
name|tag
index|[
literal|2
index|]
operator|.
name|val
operator|=
literal|"text/css"
expr_stmt|;
name|tag
index|[
literal|3
index|]
operator|.
name|key
operator|=
name|ATTR_MEDIA
expr_stmt|;
name|tag
index|[
literal|3
index|]
operator|.
name|val
operator|=
literal|"all"
expr_stmt|;
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_LINK
argument_list|,
literal|4
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_metaf
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
name|enum
name|mandoc_esc
name|deco
parameter_list|)
block|{
name|enum
name|htmlfont
name|font
decl_stmt|;
switch|switch
condition|(
name|deco
condition|)
block|{
case|case
name|ESCAPE_FONTPREV
case|:
name|font
operator|=
name|h
operator|->
name|metal
expr_stmt|;
break|break;
case|case
name|ESCAPE_FONTITALIC
case|:
name|font
operator|=
name|HTMLFONT_ITALIC
expr_stmt|;
break|break;
case|case
name|ESCAPE_FONTBOLD
case|:
name|font
operator|=
name|HTMLFONT_BOLD
expr_stmt|;
break|break;
case|case
name|ESCAPE_FONTBI
case|:
name|font
operator|=
name|HTMLFONT_BI
expr_stmt|;
break|break;
case|case
name|ESCAPE_FONT
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_FONTROMAN
case|:
name|font
operator|=
name|HTMLFONT_NONE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|h
operator|->
name|metaf
condition|)
block|{
name|print_tagq
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|metaf
argument_list|)
expr_stmt|;
name|h
operator|->
name|metaf
operator|=
name|NULL
expr_stmt|;
block|}
name|h
operator|->
name|metal
operator|=
name|h
operator|->
name|metac
expr_stmt|;
name|h
operator|->
name|metac
operator|=
name|font
expr_stmt|;
switch|switch
condition|(
name|font
condition|)
block|{
case|case
name|HTMLFONT_ITALIC
case|:
name|h
operator|->
name|metaf
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_I
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTMLFONT_BOLD
case|:
name|h
operator|->
name|metaf
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_B
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTMLFONT_BI
case|:
name|h
operator|->
name|metaf
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_B
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_I
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|html_strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|size_t
name|rsz
decl_stmt|;
name|int
name|skip
decl_stmt|,
name|sz
decl_stmt|;
comment|/* 	 * Account for escaped sequences within string length 	 * calculations.  This follows the logic in term_strlen() as we 	 * must calculate the width of produced strings. 	 * Assume that characters are always width of "1".  This is 	 * hacky, but it gets the job done for approximation of widths. 	 */
name|sz
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rsz
operator|=
name|strcspn
argument_list|(
name|cp
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsz
condition|)
block|{
name|cp
operator|+=
name|rsz
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
name|rsz
operator|--
expr_stmt|;
block|}
name|sz
operator|+=
name|rsz
expr_stmt|;
block|}
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|cp
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|mandoc_escape
argument_list|(
operator|&
name|cp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|ESCAPE_ERROR
case|:
return|return
operator|(
name|sz
operator|)
return|;
case|case
name|ESCAPE_UNICODE
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_NUMBERED
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_SPECIAL
case|:
if|if
condition|(
name|skip
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
else|else
name|sz
operator|++
expr_stmt|;
break|break;
case|case
name|ESCAPE_SKIPCHAR
case|:
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|sz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_escape
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|printf
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|printf
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|printf
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|printf
argument_list|(
literal|"&quot;"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCII_NBRSP
case|:
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCII_HYPH
case|:
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ASCII_BREAK
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_encode
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|norecurse
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|int
name|c
decl_stmt|,
name|len
decl_stmt|,
name|nospace
decl_stmt|;
specifier|const
name|char
modifier|*
name|seq
decl_stmt|;
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
specifier|static
specifier|const
name|char
name|rejs
index|[
literal|9
index|]
init|=
block|{
literal|'\\'
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'&'
block|,
literal|'"'
block|,
name|ASCII_NBRSP
block|,
name|ASCII_HYPH
block|,
name|ASCII_BREAK
block|,
literal|'\0'
block|}
decl_stmt|;
name|nospace
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|HTML_SKIPCHAR
operator|&
name|h
operator|->
name|flags
operator|&&
literal|'\\'
operator|!=
operator|*
name|p
condition|)
block|{
name|h
operator|->
name|flags
operator|&=
operator|~
name|HTML_SKIPCHAR
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
name|sz
operator|=
name|strcspn
argument_list|(
name|p
argument_list|,
name|rejs
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|sz
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
name|int
operator|)
name|sz
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
break|break;
if|if
condition|(
name|print_escape
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
continue|continue;
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|seq
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESCAPE_ERROR
operator|==
name|esc
condition|)
break|break;
switch|switch
condition|(
name|esc
condition|)
block|{
case|case
name|ESCAPE_FONT
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_FONTPREV
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_FONTBOLD
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_FONTITALIC
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_FONTBI
case|:
comment|/* FALLTHROUGH */
case|case
name|ESCAPE_FONTROMAN
case|:
if|if
condition|(
literal|0
operator|==
name|norecurse
condition|)
name|print_metaf
argument_list|(
name|h
argument_list|,
name|esc
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ESCAPE_SKIPCHAR
case|:
name|h
operator|->
name|flags
operator||=
name|HTML_SKIPCHAR
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|HTML_SKIPCHAR
condition|)
block|{
name|h
operator|->
name|flags
operator|&=
operator|~
name|HTML_SKIPCHAR
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|esc
condition|)
block|{
case|case
name|ESCAPE_UNICODE
case|:
comment|/* Skip past "u" header. */
name|c
operator|=
name|mchars_num2uc
argument_list|(
name|seq
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESCAPE_NUMBERED
case|:
name|c
operator|=
name|mchars_num2char
argument_list|(
name|seq
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
continue|continue;
break|break;
case|case
name|ESCAPE_SPECIAL
case|:
name|c
operator|=
name|mchars_spec2cp
argument_list|(
name|h
operator|->
name|symtab
argument_list|,
name|seq
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
continue|continue;
break|break;
case|case
name|ESCAPE_NOSPACE
case|:
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
name|nospace
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|<
literal|0x20
operator|&&
name|c
operator|!=
literal|0x09
operator|)
operator|||
operator|(
name|c
operator|>
literal|0x7E
operator|&&
name|c
operator|<
literal|0xA0
operator|)
condition|)
name|c
operator|=
literal|0xFFFD
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0x7E
condition|)
name|printf
argument_list|(
literal|"&#%d;"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|print_escape
argument_list|(
name|c
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nospace
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_attr
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|printf
argument_list|(
literal|" %s=\""
argument_list|,
name|key
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|print_encode
argument_list|(
name|h
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|tag
modifier|*
name|print_otag
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
name|enum
name|htmltag
name|tag
parameter_list|,
name|int
name|sz
parameter_list|,
specifier|const
name|struct
name|htmlpair
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
comment|/* Push this tags onto the stack of open scopes. */
if|if
condition|(
operator|!
operator|(
name|HTML_NOSTACK
operator|&
name|htmltags
index|[
name|tag
index|]
operator|.
name|flags
operator|)
condition|)
block|{
name|t
operator|=
name|mandoc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|h
operator|->
name|tags
operator|.
name|head
expr_stmt|;
name|h
operator|->
name|tags
operator|.
name|head
operator|=
name|t
expr_stmt|;
block|}
else|else
name|t
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|HTML_NOSPACE
operator|&
name|h
operator|->
name|flags
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|HTML_CLRLINE
operator|&
name|htmltags
index|[
name|tag
index|]
operator|.
name|flags
operator|)
condition|)
block|{
comment|/* Manage keeps! */
if|if
condition|(
operator|!
operator|(
name|HTML_KEEP
operator|&
name|h
operator|->
name|flags
operator|)
condition|)
block|{
if|if
condition|(
name|HTML_PREKEEP
operator|&
name|h
operator|->
name|flags
condition|)
name|h
operator|->
name|flags
operator||=
name|HTML_KEEP
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"&#160;"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|flags
operator|&
name|HTML_NONOSPACE
operator|)
condition|)
name|h
operator|->
name|flags
operator|&=
operator|~
name|HTML_NOSPACE
expr_stmt|;
else|else
name|h
operator|->
name|flags
operator||=
name|HTML_NOSPACE
expr_stmt|;
comment|/* Print out the tag name and attributes. */
name|printf
argument_list|(
literal|"<%s"
argument_list|,
name|htmltags
index|[
name|tag
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
name|print_attr
argument_list|(
name|h
argument_list|,
name|htmlattrs
index|[
name|p
index|[
name|i
index|]
operator|.
name|key
index|]
argument_list|,
name|p
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
comment|/* Accommodate for "well-formed" singleton escaping. */
if|if
condition|(
name|HTML_AUTOCLOSE
operator|&
name|htmltags
index|[
name|tag
index|]
operator|.
name|flags
condition|)
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|HTML_NOSPACE
expr_stmt|;
if|if
condition|(
operator|(
name|HTML_AUTOCLOSE
operator||
name|HTML_CLRLINE
operator|)
operator|&
name|htmltags
index|[
name|tag
index|]
operator|.
name|flags
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_ctag
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
name|enum
name|htmltag
name|tag
parameter_list|)
block|{
name|printf
argument_list|(
literal|"</%s>"
argument_list|,
name|htmltags
index|[
name|tag
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|HTML_CLRLINE
operator|&
name|htmltags
index|[
name|tag
index|]
operator|.
name|flags
condition|)
block|{
name|h
operator|->
name|flags
operator||=
name|HTML_NOSPACE
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_gen_decls
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|)
block|{
name|puts
argument_list|(
literal|"<!DOCTYPE html>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_text
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|HTML_NOSPACE
operator|&
name|h
operator|->
name|flags
operator|)
condition|)
block|{
comment|/* Manage keeps! */
if|if
condition|(
operator|!
operator|(
name|HTML_KEEP
operator|&
name|h
operator|->
name|flags
operator|)
condition|)
block|{
if|if
condition|(
name|HTML_PREKEEP
operator|&
name|h
operator|->
name|flags
condition|)
name|h
operator|->
name|flags
operator||=
name|HTML_KEEP
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"&#160;"
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|NULL
operator|==
name|h
operator|->
name|metaf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|metac
condition|)
block|{
case|case
name|HTMLFONT_ITALIC
case|:
name|h
operator|->
name|metaf
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_I
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTMLFONT_BOLD
case|:
name|h
operator|->
name|metaf
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_B
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTMLFONT_BI
case|:
name|h
operator|->
name|metaf
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_B
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_I
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|assert
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|print_encode
argument_list|(
name|h
argument_list|,
name|word
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|flags
operator|&
name|HTML_NONOSPACE
operator|)
condition|)
name|h
operator|->
name|flags
operator|&=
operator|~
name|HTML_NOSPACE
expr_stmt|;
name|h
operator|->
name|flags
operator|&=
operator|~
name|HTML_NONEWLINE
expr_stmt|;
block|}
else|else
name|h
operator|->
name|flags
operator||=
name|HTML_NOSPACE
operator||
name|HTML_NONEWLINE
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|metaf
condition|)
block|{
name|print_tagq
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|metaf
argument_list|)
expr_stmt|;
name|h
operator|->
name|metaf
operator|=
name|NULL
expr_stmt|;
block|}
name|h
operator|->
name|flags
operator|&=
operator|~
name|HTML_IGNDELIM
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_tagq
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|struct
name|tag
modifier|*
name|until
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|tag
decl_stmt|;
while|while
condition|(
operator|(
name|tag
operator|=
name|h
operator|->
name|tags
operator|.
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Remember to close out and nullify the current 		 * meta-font and table, if applicable. 		 */
if|if
condition|(
name|tag
operator|==
name|h
operator|->
name|metaf
condition|)
name|h
operator|->
name|metaf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|h
operator|->
name|tblt
condition|)
name|h
operator|->
name|tblt
operator|=
name|NULL
expr_stmt|;
name|print_ctag
argument_list|(
name|h
argument_list|,
name|tag
operator|->
name|tag
argument_list|)
expr_stmt|;
name|h
operator|->
name|tags
operator|.
name|head
operator|=
name|tag
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|until
operator|&&
name|tag
operator|==
name|until
condition|)
return|return;
block|}
block|}
end_function

begin_function
name|void
name|print_stagq
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|struct
name|tag
modifier|*
name|suntil
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|tag
decl_stmt|;
while|while
condition|(
operator|(
name|tag
operator|=
name|h
operator|->
name|tags
operator|.
name|head
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|suntil
operator|&&
name|tag
operator|==
name|suntil
condition|)
return|return;
comment|/* 		 * Remember to close out and nullify the current 		 * meta-font and table, if applicable. 		 */
if|if
condition|(
name|tag
operator|==
name|h
operator|->
name|metaf
condition|)
name|h
operator|->
name|metaf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|h
operator|->
name|tblt
condition|)
name|h
operator|->
name|tblt
operator|=
name|NULL
expr_stmt|;
name|print_ctag
argument_list|(
name|h
argument_list|,
name|tag
operator|->
name|tag
argument_list|)
expr_stmt|;
name|h
operator|->
name|tags
operator|.
name|head
operator|=
name|tag
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_paragraph
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|struct
name|htmlpair
name|tag
decl_stmt|;
name|PAIR_CLASS_INIT
argument_list|(
operator|&
name|tag
argument_list|,
literal|"spacer"
argument_list|)
expr_stmt|;
name|t
operator|=
name|print_otag
argument_list|(
name|h
argument_list|,
name|TAG_DIV
argument_list|,
literal|1
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
name|print_tagq
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufinit
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|)
block|{
name|h
operator|->
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|->
name|buflen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufcat_style
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|bufcat
argument_list|(
name|h
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|bufcat
argument_list|(
name|h
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|bufcat
argument_list|(
name|h
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bufcat
argument_list|(
name|h
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufcat
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * XXX This is broken and not easy to fix. 	 * When using the -Oincludes option, buffmt_includes() 	 * may pass in strings overrunning BUFSIZ, causing a crash. 	 */
name|h
operator|->
name|buflen
operator|=
name|strlcat
argument_list|(
name|h
operator|->
name|buf
argument_list|,
name|p
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|h
operator|->
name|buflen
operator|<
name|BUFSIZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufcat_fmt
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|h
operator|->
name|buf
operator|+
operator|(
name|int
operator|)
name|h
operator|->
name|buflen
argument_list|,
name|BUFSIZ
operator|-
name|h
operator|->
name|buflen
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|h
operator|->
name|buflen
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bufncat
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|assert
argument_list|(
name|h
operator|->
name|buflen
operator|+
name|sz
operator|+
literal|1
operator|<
name|BUFSIZ
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|h
operator|->
name|buf
argument_list|,
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|h
operator|->
name|buflen
operator|+=
name|sz
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buffmt_includes
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|h
operator|->
name|base_includes
expr_stmt|;
name|bufinit
argument_list|(
name|h
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|'%'
argument_list|)
operator|)
condition|)
block|{
name|bufncat
argument_list|(
name|h
argument_list|,
name|pp
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|pp
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'I'
case|:
name|bufcat
argument_list|(
name|h
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bufncat
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pp
condition|)
name|bufcat
argument_list|(
name|h
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|buffmt_man
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|h
operator|->
name|base_man
expr_stmt|;
name|bufinit
argument_list|(
name|h
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|'%'
argument_list|)
operator|)
condition|)
block|{
name|bufncat
argument_list|(
name|h
argument_list|,
name|pp
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|pp
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'S'
case|:
name|bufcat
argument_list|(
name|h
argument_list|,
name|sec
condition|?
name|sec
else|:
literal|"1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|bufcat_fmt
argument_list|(
name|h
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bufncat
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pp
condition|)
name|bufcat
argument_list|(
name|h
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufcat_su
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|roffsu
modifier|*
name|su
parameter_list|)
block|{
name|double
name|v
decl_stmt|;
name|v
operator|=
name|su
operator|->
name|scale
expr_stmt|;
if|if
condition|(
name|SCALE_MM
operator|==
name|su
operator|->
name|unit
operator|&&
literal|0.0
operator|==
operator|(
name|v
operator|/=
literal|100.0
operator|)
condition|)
name|v
operator|=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|SCALE_BU
operator|==
name|su
operator|->
name|unit
condition|)
name|v
operator|/=
literal|24.0
expr_stmt|;
name|bufcat_fmt
argument_list|(
name|h
argument_list|,
literal|"%s: %.2f%s;"
argument_list|,
name|p
argument_list|,
name|v
argument_list|,
name|roffscales
index|[
name|su
operator|->
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufcat_id
parameter_list|(
name|struct
name|html
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
comment|/* Cf.<http://www.w3.org/TR/html4/types.html#h-6.2>. */
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|src
condition|)
name|bufcat_fmt
argument_list|(
name|h
argument_list|,
literal|"%.2x"
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

