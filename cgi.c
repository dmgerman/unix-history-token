begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: cgi.c,v 1.46 2013/10/11 00:06:48 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, 2012 Kristaps Dzonsons<kristaps@bsd.lv>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
end_if

begin_comment
comment|/* for stat() */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"apropos_db.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"manpath.h"
end_include

begin_include
include|#
directive|include
file|"mandocdb.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<db_185.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|page
block|{
name|PAGE_INDEX
block|,
name|PAGE_SEARCH
block|,
name|PAGE_SHOW
block|,
name|PAGE__MAX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|paths
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A query as passed to the search function.  */
end_comment

begin_struct
struct|struct
name|query
block|{
specifier|const
name|char
modifier|*
name|arch
decl_stmt|;
comment|/* architecture */
specifier|const
name|char
modifier|*
name|sec
decl_stmt|;
comment|/* manual section */
specifier|const
name|char
modifier|*
name|expr
decl_stmt|;
comment|/* unparsed expression string */
name|int
name|manroot
decl_stmt|;
comment|/* manroot index (or -1)*/
name|int
name|legacy
decl_stmt|;
comment|/* whether legacy mode */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|req
block|{
name|struct
name|query
name|q
decl_stmt|;
name|struct
name|paths
modifier|*
name|p
decl_stmt|;
name|size_t
name|psz
decl_stmt|;
name|enum
name|page
name|page
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|atou
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catman
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|format
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|html_print
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|html_printquery
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|html_putchar
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|http_decode
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|http_parse
parameter_list|(
name|struct
name|req
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|http_print
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|http_putchar
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|http_printquery
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pathstop
parameter_list|(
name|DIR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pathgen
parameter_list|(
name|DIR
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pg_index
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pg_search
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pg_show
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_bad
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_baddb
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_error400
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_error404
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_begin_html
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_begin_http
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_end_html
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_index
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_search
parameter_list|(
name|struct
name|res
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resp_searchform
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cgi script name */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache directory */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|css
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* css directory */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|pages
index|[
name|PAGE__MAX
index|]
init|=
block|{
literal|"index"
block|,
comment|/* PAGE_INDEX */
literal|"search"
block|,
comment|/* PAGE_SEARCH */
literal|"show"
block|,
comment|/* PAGE_SHOW */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is just OpenBSD's strtol(3) suggestion.  * I use it instead of strtonum(3) for portability's sake.  */
end_comment

begin_function
specifier|static
name|int
name|atou
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
modifier|*
name|v
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|long
name|lval
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|lval
operator|=
name|strtol
argument_list|(
name|buf
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|errno
operator|==
name|ERANGE
operator|&&
operator|(
name|lval
operator|==
name|LONG_MAX
operator|||
name|lval
operator|==
name|LONG_MIN
operator|)
operator|)
operator|||
operator|(
name|lval
operator|>
name|INT_MAX
operator|||
name|lval
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|v
operator|=
operator|(
name|unsigned
name|int
operator|)
name|lval
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a character, escaping HTML along the way.  * This will pass non-ASCII straight to output: be warned!  */
end_comment

begin_function
specifier|static
name|void
name|html_putchar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
operator|(
literal|'"'
operator|)
case|:
name|printf
argument_list|(
literal|"&quote;"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'&'
operator|)
case|:
name|printf
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'>'
operator|)
case|:
name|printf
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
literal|'<'
operator|)
case|:
name|printf
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|http_printquery
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|)
block|{
name|printf
argument_list|(
literal|"&expr="
argument_list|)
expr_stmt|;
name|http_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|expr
condition|?
name|req
operator|->
name|q
operator|.
name|expr
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&sec="
argument_list|)
expr_stmt|;
name|http_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|sec
condition|?
name|req
operator|->
name|q
operator|.
name|sec
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&arch="
argument_list|)
expr_stmt|;
name|http_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|arch
condition|?
name|req
operator|->
name|q
operator|.
name|arch
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|html_printquery
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|)
block|{
name|printf
argument_list|(
literal|"&amp;expr="
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|expr
condition|?
name|req
operator|->
name|q
operator|.
name|expr
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&amp;sec="
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|sec
condition|?
name|req
operator|->
name|q
operator|.
name|sec
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&amp;arch="
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|arch
condition|?
name|req
operator|->
name|q
operator|.
name|arch
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|http_print
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
return|return;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
name|http_putchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call through to html_putchar().  * Accepts NULL strings.  */
end_comment

begin_function
specifier|static
name|void
name|html_print
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
return|return;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
name|html_putchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse out key-value pairs from an HTTP request variable.  * This can be either a cookie or a POST/GET string, although man.cgi  * uses only GET for simplicity.  */
end_comment

begin_function
specifier|static
name|void
name|http_parse
parameter_list|(
name|struct
name|req
modifier|*
name|req
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|val
decl_stmt|,
modifier|*
name|manroot
decl_stmt|;
name|int
name|i
decl_stmt|,
name|legacy
decl_stmt|;
name|memset
argument_list|(
operator|&
name|req
operator|->
name|q
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|legacy
operator|=
operator|-
literal|1
expr_stmt|;
name|manroot
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
block|{
name|key
operator|=
name|p
expr_stmt|;
name|val
operator|=
name|NULL
expr_stmt|;
name|p
operator|+=
operator|(
name|int
operator|)
name|strcspn
argument_list|(
name|p
argument_list|,
literal|";&"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|val
operator|=
name|strchr
argument_list|(
name|key
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|key
operator|||
name|NULL
operator|==
name|val
operator|||
literal|'\0'
operator|==
operator|*
name|val
condition|)
continue|continue;
comment|/* Just abort handling. */
if|if
condition|(
operator|!
name|http_decode
argument_list|(
name|key
argument_list|)
condition|)
break|break;
if|if
condition|(
name|NULL
operator|!=
name|val
operator|&&
operator|!
name|http_decode
argument_list|(
name|val
argument_list|)
condition|)
break|break;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"expr"
argument_list|)
condition|)
name|req
operator|->
name|q
operator|.
name|expr
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"query"
argument_list|)
condition|)
name|req
operator|->
name|q
operator|.
name|expr
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sec"
argument_list|)
condition|)
name|req
operator|->
name|q
operator|.
name|sec
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sektion"
argument_list|)
condition|)
name|req
operator|->
name|q
operator|.
name|sec
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"arch"
argument_list|)
condition|)
name|req
operator|->
name|q
operator|.
name|arch
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"manpath"
argument_list|)
condition|)
name|manroot
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"apropos"
argument_list|)
condition|)
name|legacy
operator|=
literal|0
operator|==
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
comment|/* Test for old man.cgi compatibility mode. */
name|req
operator|->
name|q
operator|.
name|legacy
operator|=
name|legacy
operator|>
literal|0
expr_stmt|;
comment|/*  	 * Section "0" means no section when in legacy mode. 	 * For some man.cgi scripts, "default" arch is none. 	 */
if|if
condition|(
name|req
operator|->
name|q
operator|.
name|legacy
operator|&&
name|NULL
operator|!=
name|req
operator|->
name|q
operator|.
name|sec
condition|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|req
operator|->
name|q
operator|.
name|sec
argument_list|,
literal|"0"
argument_list|)
condition|)
name|req
operator|->
name|q
operator|.
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|q
operator|.
name|legacy
operator|&&
name|NULL
operator|!=
name|req
operator|->
name|q
operator|.
name|arch
condition|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|req
operator|->
name|q
operator|.
name|arch
argument_list|,
literal|"default"
argument_list|)
condition|)
name|req
operator|->
name|q
operator|.
name|arch
operator|=
name|NULL
expr_stmt|;
comment|/* Default to first manroot. */
if|if
condition|(
name|NULL
operator|!=
name|manroot
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|req
operator|->
name|psz
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|req
operator|->
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|manroot
argument_list|)
condition|)
break|break;
name|req
operator|->
name|q
operator|.
name|manroot
operator|=
name|i
operator|<
operator|(
name|int
operator|)
name|req
operator|->
name|psz
condition|?
name|i
else|:
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|http_putchar
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
literal|' '
operator|==
name|c
condition|)
block|{
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%%%.2x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * HTTP-decode a string.  The standard explanation is that this turns  * "%4e+foo" into "n foo" in the regular way.  This is done in-place  * over the allocated string.  */
end_comment

begin_function
specifier|static
name|int
name|http_decode
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
name|hex
index|[
literal|3
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|hex
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
literal|'\0'
operator|!=
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
literal|'%'
operator|==
operator|*
name|p
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|==
operator|(
name|hex
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
literal|'\0'
operator|==
operator|(
name|hex
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|hex
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
literal|'\0'
operator|==
name|c
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|p
operator|+
literal|3
argument_list|,
name|strlen
argument_list|(
name|p
operator|+
literal|3
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
literal|'+'
operator|==
operator|*
name|p
condition|?
literal|' '
else|:
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_begin_http
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
literal|200
operator|!=
name|code
condition|)
name|printf
argument_list|(
literal|"Status: %d %s\n"
argument_list|,
name|code
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Content-Type: text/html; charset=utf-8\n"
literal|"Cache-Control: no-cache\n"
literal|"Pragma: no-cache\n"
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_begin_html
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|resp_begin_http
argument_list|(
name|code
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<!DOCTYPE HTML PUBLIC "
literal|" \"-//W3C//DTD HTML 4.01//EN\""
literal|" \"http://www.w3.org/TR/html4/strict.dtd\">\n"
literal|"<HTML>\n"
literal|"<HEAD>\n"
literal|"<META HTTP-EQUIV=\"Content-Type\""
literal|" CONTENT=\"text/html; charset=utf-8\">\n"
literal|"<LINK REL=\"stylesheet\" HREF=\"%s/man-cgi.css\""
literal|" TYPE=\"text/css\" media=\"all\">\n"
literal|"<LINK REL=\"stylesheet\" HREF=\"%s/man.css\""
literal|" TYPE=\"text/css\" media=\"all\">\n"
literal|"<TITLE>System Manpage Reference</TITLE>\n"
literal|"</HEAD>\n"
literal|"<BODY>\n"
literal|"<!-- Begin page content. //-->\n"
argument_list|,
name|css
argument_list|,
name|css
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_end_html
parameter_list|(
name|void
parameter_list|)
block|{
name|puts
argument_list|(
literal|"</BODY>\n"
literal|"</HTML>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_searchform
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|puts
argument_list|(
literal|"<!-- Begin search form. //-->"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<DIV ID=\"mancgi\">\n"
literal|"<FORM ACTION=\"%s/search.html\" METHOD=\"get\">\n"
literal|"<FIELDSET>\n"
literal|"<LEGEND>Search Parameters</LEGEND>\n"
literal|"<INPUT TYPE=\"submit\" "
literal|" VALUE=\"Search\"> for manuals satisfying \n"
literal|"<INPUT TYPE=\"text\" NAME=\"expr\" VALUE=\""
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|expr
condition|?
name|req
operator|->
name|q
operator|.
name|expr
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\">, section "
literal|"<INPUT TYPE=\"text\""
literal|" SIZE=\"4\" NAME=\"sec\" VALUE=\""
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|sec
condition|?
name|req
operator|->
name|q
operator|.
name|sec
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\">, arch "
literal|"<INPUT TYPE=\"text\""
literal|" SIZE=\"8\" NAME=\"arch\" VALUE=\""
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|q
operator|.
name|arch
condition|?
name|req
operator|->
name|q
operator|.
name|arch
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|psz
operator|>
literal|1
condition|)
block|{
name|puts
argument_list|(
literal|",<SELECT NAME=\"manpath\">"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|req
operator|->
name|psz
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"<OPTION %s VALUE=\""
argument_list|,
operator|(
name|i
operator|==
name|req
operator|->
name|q
operator|.
name|manroot
operator|)
operator|||
operator|(
literal|0
operator|==
name|i
operator|&&
operator|-
literal|1
operator|==
name|req
operator|->
name|q
operator|.
name|manroot
operator|)
condition|?
literal|"SELECTED=\"selected\""
else|:
literal|""
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|req
operator|->
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"</OPTION>"
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"</SELECT>"
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|".\n"
literal|"<INPUT TYPE=\"reset\" VALUE=\"Reset\">\n"
literal|"</FIELDSET>\n"
literal|"</FORM>\n"
literal|"</DIV>"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<!-- End search form. //-->"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_index
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|)
block|{
name|resp_begin_html
argument_list|(
literal|200
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|resp_searchform
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|resp_end_html
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_error400
parameter_list|(
name|void
parameter_list|)
block|{
name|resp_begin_html
argument_list|(
literal|400
argument_list|,
literal|"Query Malformed"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<H1>Malformed Query</H1>\n"
literal|"<P>\n"
literal|"The query your entered was malformed.\n"
literal|"Try again from the\n"
literal|"<A HREF=\"%s/index.html\">main page</A>.\n"
literal|"</P>"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|resp_end_html
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_error404
parameter_list|(
specifier|const
name|char
modifier|*
name|page
parameter_list|)
block|{
name|resp_begin_html
argument_list|(
literal|404
argument_list|,
literal|"Not Found"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<H1>Page Not Found</H1>\n"
literal|"<P>\n"
literal|"The page you're looking for, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<B>"
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"</B>,\n"
literal|"could not be found.\n"
literal|"Try searching from the\n"
literal|"<A HREF=\"%s/index.html\">main page</A>.\n"
literal|"</P>"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|resp_end_html
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_bad
parameter_list|(
name|void
parameter_list|)
block|{
name|resp_begin_html
argument_list|(
literal|500
argument_list|,
literal|"Internal Server Error"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<P>Generic badness happened.</P>"
argument_list|)
expr_stmt|;
name|resp_end_html
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_baddb
parameter_list|(
name|void
parameter_list|)
block|{
name|resp_begin_html
argument_list|(
literal|500
argument_list|,
literal|"Internal Server Error"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<P>Your database is broken.</P>"
argument_list|)
expr_stmt|;
name|resp_end_html
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|resp_search
parameter_list|(
name|struct
name|res
modifier|*
name|r
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|matched
decl_stmt|;
specifier|const
name|struct
name|req
modifier|*
name|req
decl_stmt|;
name|req
operator|=
operator|(
specifier|const
expr|struct
name|req
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sz
operator|>
literal|0
condition|)
name|assert
argument_list|(
name|req
operator|->
name|q
operator|.
name|manroot
operator|>=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|matched
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r
index|[
name|i
index|]
operator|.
name|matched
condition|)
name|matched
operator|++
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|matched
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r
index|[
name|i
index|]
operator|.
name|matched
condition|)
break|break;
comment|/* 		 * If we have just one result, then jump there now 		 * without any delay. 		 */
name|puts
argument_list|(
literal|"Status: 303 See Other"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Location: http://%s%s/show/%d/%u/%u.html?"
argument_list|,
name|host
argument_list|,
name|progname
argument_list|,
name|req
operator|->
name|q
operator|.
name|manroot
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|volume
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|rec
argument_list|)
expr_stmt|;
name|http_printquery
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\n"
literal|"Content-Type: text/html; charset=utf-8\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|resp_begin_html
argument_list|(
literal|200
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|resp_searchform
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<DIV CLASS=\"results\">"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|matched
condition|)
block|{
name|puts
argument_list|(
literal|"<P>\n"
literal|"No results found.\n"
literal|"</P>\n"
literal|"</DIV>"
argument_list|)
expr_stmt|;
name|resp_end_html
argument_list|()
expr_stmt|;
return|return;
block|}
name|qsort
argument_list|(
name|r
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|res
argument_list|)
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<TABLE>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|r
index|[
name|i
index|]
operator|.
name|matched
condition|)
continue|continue;
name|printf
argument_list|(
literal|"<TR>\n"
literal|"<TD CLASS=\"title\">\n"
literal|"<A HREF=\"%s/show/%d/%u/%u.html?"
argument_list|,
name|progname
argument_list|,
name|req
operator|->
name|q
operator|.
name|manroot
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|volume
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|rec
argument_list|)
expr_stmt|;
name|html_printquery
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|r
index|[
name|i
index|]
operator|.
name|title
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|r
index|[
name|i
index|]
operator|.
name|cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
index|[
name|i
index|]
operator|.
name|arch
operator|&&
literal|'\0'
operator|!=
operator|*
name|r
index|[
name|i
index|]
operator|.
name|arch
condition|)
block|{
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|r
index|[
name|i
index|]
operator|.
name|arch
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")</A>\n"
literal|"</TD>\n"
literal|"<TD CLASS=\"desc\">"
argument_list|)
expr_stmt|;
name|html_print
argument_list|(
name|r
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"</TD>\n"
literal|"</TR>"
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"</TABLE>\n"
literal|"</DIV>"
argument_list|)
expr_stmt|;
name|resp_end_html
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|pg_index
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|resp_index
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|catman
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|italic
decl_stmt|,
name|bold
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|resp_baddb
argument_list|()
expr_stmt|;
return|return;
block|}
name|resp_begin_html
argument_list|(
literal|200
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|resp_searchform
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<DIV CLASS=\"catman\">\n"
literal|"<PRE>"
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|fgetln
argument_list|(
name|f
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
name|bold
operator|=
name|italic
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/*  			 * This means that the catpage is out of state. 			 * Ignore it and keep going (although the 			 * catpage is bogus). 			 */
if|if
condition|(
literal|'\b'
operator|==
name|p
index|[
name|i
index|]
operator|||
literal|'\n'
operator|==
name|p
index|[
name|i
index|]
condition|)
continue|continue;
comment|/* 			 * Print a regular character. 			 * Close out any bold/italic scopes. 			 * If we're in back-space mode, make sure we'll 			 * have something to enter when we backspace. 			 */
if|if
condition|(
literal|'\b'
operator|!=
name|p
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|italic
condition|)
name|printf
argument_list|(
literal|"</I>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bold
condition|)
name|printf
argument_list|(
literal|"</B>"
argument_list|)
expr_stmt|;
name|italic
operator|=
name|bold
operator|=
literal|0
expr_stmt|;
name|html_putchar
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|2
operator|>=
operator|(
name|int
operator|)
name|len
condition|)
continue|continue;
comment|/* Italic mode. */
if|if
condition|(
literal|'_'
operator|==
name|p
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|bold
condition|)
name|printf
argument_list|(
literal|"</B>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|italic
condition|)
name|printf
argument_list|(
literal|"<I>"
argument_list|)
expr_stmt|;
name|bold
operator|=
literal|0
expr_stmt|;
name|italic
operator|=
literal|1
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|html_putchar
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  			 * Handle funny behaviour troff-isms. 			 * These grok'd from the original man2html.c. 			 */
if|if
condition|(
operator|(
literal|'+'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'o'
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'o'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'+'
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'|'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'='
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'='
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'|'
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'*'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'='
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'='
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'*'
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'*'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'|'
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'|'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'*'
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|italic
condition|)
name|printf
argument_list|(
literal|"</I>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bold
condition|)
name|printf
argument_list|(
literal|"</B>"
argument_list|)
expr_stmt|;
name|italic
operator|=
name|bold
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
literal|'|'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'-'
operator|==
name|p
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|||
operator|(
literal|'-'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'|'
operator|==
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|||
operator|(
literal|'+'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'-'
operator|==
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|||
operator|(
literal|'-'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'+'
operator|==
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|||
operator|(
literal|'+'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'|'
operator|==
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|||
operator|(
literal|'|'
operator|==
name|p
index|[
name|i
index|]
operator|&&
literal|'+'
operator|==
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|italic
condition|)
name|printf
argument_list|(
literal|"</I>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bold
condition|)
name|printf
argument_list|(
literal|"</B>"
argument_list|)
expr_stmt|;
name|italic
operator|=
name|bold
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* Bold mode. */
if|if
condition|(
name|italic
condition|)
name|printf
argument_list|(
literal|"</I>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bold
condition|)
name|printf
argument_list|(
literal|"<B>"
argument_list|)
expr_stmt|;
name|bold
operator|=
literal|1
expr_stmt|;
name|italic
operator|=
literal|0
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|html_putchar
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*  		 * Clean up the last character. 		 * We can get to a newline; don't print that.  		 */
if|if
condition|(
name|italic
condition|)
name|printf
argument_list|(
literal|"</I>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bold
condition|)
name|printf
argument_list|(
literal|"</B>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|len
operator|-
literal|1
operator|&&
literal|'\n'
operator|!=
name|p
index|[
name|i
index|]
condition|)
name|html_putchar
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"</PRE>\n"
literal|"</DIV>\n"
literal|"</BODY>\n"
literal|"</HTML>"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|format
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|mparse
modifier|*
name|mp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|mdoc
modifier|*
name|mdoc
decl_stmt|;
name|struct
name|man
modifier|*
name|man
decl_stmt|;
name|void
modifier|*
name|vp
decl_stmt|;
name|enum
name|mandoclevel
name|rc
decl_stmt|;
name|char
name|opts
index|[
name|PATH_MAX
operator|+
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|resp_baddb
argument_list|()
expr_stmt|;
return|return;
block|}
name|mp
operator|=
name|mparse_alloc
argument_list|(
name|MPARSE_AUTO
argument_list|,
name|MANDOCLEVEL_FATAL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mparse_readfd
argument_list|(
name|mp
argument_list|,
name|fd
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>=
name|MANDOCLEVEL_FATAL
condition|)
block|{
name|resp_baddb
argument_list|()
expr_stmt|;
return|return;
block|}
name|snprintf
argument_list|(
name|opts
argument_list|,
sizeof|sizeof
argument_list|(
name|opts
argument_list|)
argument_list|,
literal|"fragment,"
literal|"man=%s/search.html?sec=%%S&expr=Nm~^%%N$,"
comment|/*"includes=/cgi-bin/man.cgi/usr/include/%%I"*/
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|mparse_result
argument_list|(
name|mp
argument_list|,
operator|&
name|mdoc
argument_list|,
operator|&
name|man
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|man
operator|&&
name|NULL
operator|==
name|mdoc
condition|)
block|{
name|resp_baddb
argument_list|()
expr_stmt|;
name|mparse_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|resp_begin_html
argument_list|(
literal|200
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|resp_searchform
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|vp
operator|=
name|html_alloc
argument_list|(
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|mdoc
condition|)
name|html_mdoc
argument_list|(
name|vp
argument_list|,
name|mdoc
argument_list|)
expr_stmt|;
else|else
name|html_man
argument_list|(
name|vp
argument_list|,
name|man
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"</BODY>\n"
literal|"</HTML>"
argument_list|)
expr_stmt|;
name|html_free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mparse_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pg_show
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|manpaths
name|ps
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|char
modifier|*
name|sub
decl_stmt|;
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|catm
decl_stmt|;
name|unsigned
name|int
name|vol
decl_stmt|,
name|rec
decl_stmt|,
name|mr
decl_stmt|;
name|DB
modifier|*
name|idx
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|idx
operator|=
name|NULL
expr_stmt|;
comment|/* Parse out mroot, volume, and record from the path. */
if|if
condition|(
name|NULL
operator|==
name|path
operator|||
name|NULL
operator|==
operator|(
name|sub
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|resp_error400
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|sub
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|atou
argument_list|(
name|path
argument_list|,
operator|&
name|mr
argument_list|)
condition|)
block|{
name|resp_error400
argument_list|()
expr_stmt|;
return|return;
block|}
name|path
operator|=
name|sub
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|sub
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|resp_error400
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|sub
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|atou
argument_list|(
name|path
argument_list|,
operator|&
name|vol
argument_list|)
operator|||
operator|!
name|atou
argument_list|(
name|sub
argument_list|,
operator|&
name|rec
argument_list|)
condition|)
block|{
name|resp_error400
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mr
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|req
operator|->
name|psz
condition|)
block|{
name|resp_error400
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * Begin by chdir()ing into the manroot. 	 * This way we can pick up the database files, which are 	 * relative to the manpath root. 	 */
if|if
condition|(
operator|-
literal|1
operator|==
name|chdir
argument_list|(
name|req
operator|->
name|p
index|[
operator|(
name|int
operator|)
name|mr
index|]
operator|.
name|path
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|req
operator|->
name|p
index|[
operator|(
name|int
operator|)
name|mr
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
name|resp_baddb
argument_list|()
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpaths
argument_list|)
argument_list|)
expr_stmt|;
name|manpath_manconf
argument_list|(
operator|&
name|ps
argument_list|,
literal|"etc/catman.conf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|ps
operator|.
name|sz
condition|)
block|{
name|resp_error400
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sz
operator|=
name|strlcpy
argument_list|(
name|file
argument_list|,
name|ps
operator|.
name|paths
index|[
name|vol
index|]
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz
operator|<
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|file
argument_list|,
literal|"/"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|file
argument_list|,
name|MANDOC_IDX
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Open the index recno(3) database. */
name|idx
operator|=
name|dbopen
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|DB_RECNO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|idx
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|resp_baddb
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|key
operator|.
name|data
operator|=
operator|&
name|rec
expr_stmt|;
name|key
operator|.
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|rc
operator|=
call|(
modifier|*
name|idx
operator|->
name|get
call|)
argument_list|(
name|idx
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|rc
operator|<
literal|0
condition|?
name|resp_baddb
argument_list|()
else|:
name|resp_error400
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|val
operator|.
name|size
condition|)
block|{
name|resp_baddb
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|val
operator|.
name|data
expr_stmt|;
name|catm
operator|=
literal|'c'
operator|==
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|memchr
argument_list|(
name|cp
argument_list|,
literal|'\0'
argument_list|,
name|val
operator|.
name|size
operator|-
literal|1
argument_list|)
condition|)
name|resp_baddb
argument_list|()
expr_stmt|;
else|else
block|{
name|file
index|[
operator|(
name|int
operator|)
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|file
argument_list|,
literal|"/"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|file
argument_list|,
name|cp
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|catm
condition|)
name|catman
argument_list|(
name|req
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|format
argument_list|(
name|req
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|idx
condition|)
call|(
modifier|*
name|idx
operator|->
name|close
call|)
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|manpath_free
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pg_search
parameter_list|(
specifier|const
name|struct
name|req
modifier|*
name|req
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|tt
decl_stmt|,
name|ressz
decl_stmt|;
name|struct
name|manpaths
name|ps
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sz
decl_stmt|,
name|rc
decl_stmt|;
specifier|const
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|struct
name|res
modifier|*
name|res
decl_stmt|;
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|struct
name|opts
name|opt
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|q
operator|.
name|manroot
operator|<
literal|0
operator|||
literal|0
operator|==
name|req
operator|->
name|psz
condition|)
block|{
name|resp_search
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|opts
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|=
name|req
operator|->
name|q
operator|.
name|expr
expr_stmt|;
name|opt
operator|.
name|arch
operator|=
name|req
operator|->
name|q
operator|.
name|arch
expr_stmt|;
name|opt
operator|.
name|cat
operator|=
name|req
operator|->
name|q
operator|.
name|sec
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|ressz
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Begin by chdir()ing into the root of the manpath. 	 * This way we can pick up the database files, which are 	 * relative to the manpath root. 	 */
name|assert
argument_list|(
name|req
operator|->
name|q
operator|.
name|manroot
operator|<
operator|(
name|int
operator|)
name|req
operator|->
name|psz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
operator|(
name|chdir
argument_list|(
name|req
operator|->
name|p
index|[
name|req
operator|->
name|q
operator|.
name|manroot
index|]
operator|.
name|path
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|req
operator|->
name|p
index|[
name|req
operator|->
name|q
operator|.
name|manroot
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
name|resp_search
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpaths
argument_list|)
argument_list|)
expr_stmt|;
name|manpath_manconf
argument_list|(
operator|&
name|ps
argument_list|,
literal|"etc/catman.conf"
argument_list|)
expr_stmt|;
comment|/* 	 * Poor man's tokenisation: just break apart by spaces. 	 * Yes, this is half-ass.  But it works for now. 	 */
while|while
condition|(
name|ep
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
while|while
condition|(
name|ep
operator|&&
literal|'\0'
operator|!=
operator|*
name|ep
condition|)
block|{
name|cp
operator|=
name|mandoc_realloc
argument_list|(
name|cp
argument_list|,
operator|(
name|sz
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|ep
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
name|cp
index|[
name|sz
index|]
operator|=
name|mandoc_malloc
argument_list|(
operator|(
name|ep
operator|-
name|start
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
index|[
name|sz
index|]
argument_list|,
name|start
argument_list|,
name|ep
operator|-
name|start
argument_list|)
expr_stmt|;
name|cp
index|[
name|sz
operator|++
index|]
index|[
name|ep
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ep
argument_list|)
condition|)
name|ep
operator|++
expr_stmt|;
block|}
comment|/* 	 * Pump down into apropos backend. 	 * The resp_search() function is called with the results. 	 */
name|expr
operator|=
name|req
operator|->
name|q
operator|.
name|legacy
condition|?
name|termcomp
argument_list|(
name|sz
argument_list|,
name|cp
argument_list|,
operator|&
name|tt
argument_list|)
else|:
name|exprcomp
argument_list|(
name|sz
argument_list|,
name|cp
argument_list|,
operator|&
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|expr
condition|)
name|rc
operator|=
name|apropos_search
argument_list|(
name|ps
operator|.
name|sz
argument_list|,
name|ps
operator|.
name|paths
argument_list|,
operator|&
name|opt
argument_list|,
name|expr
argument_list|,
name|tt
argument_list|,
operator|(
name|void
operator|*
operator|)
name|req
argument_list|,
operator|&
name|ressz
argument_list|,
operator|&
name|res
argument_list|,
name|resp_search
argument_list|)
expr_stmt|;
comment|/* ...unless errors occured. */
if|if
condition|(
literal|0
operator|==
name|rc
condition|)
name|resp_baddb
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
name|resp_search
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|resfree
argument_list|(
name|res
argument_list|,
name|ressz
argument_list|)
expr_stmt|;
name|exprfree
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|manpath_free
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|DIR
modifier|*
name|cwd
decl_stmt|;
name|struct
name|req
name|req
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|subpath
decl_stmt|;
comment|/* Scan our run-time environment. */
if|if
condition|(
name|NULL
operator|==
operator|(
name|cache
operator|=
name|getenv
argument_list|(
literal|"CACHE_DIR"
argument_list|)
operator|)
condition|)
name|cache
operator|=
literal|"/cache/man.cgi"
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|progname
operator|=
name|getenv
argument_list|(
literal|"SCRIPT_NAME"
argument_list|)
operator|)
condition|)
name|progname
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|css
operator|=
name|getenv
argument_list|(
literal|"CSS_DIR"
argument_list|)
operator|)
condition|)
name|css
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|host
operator|=
name|getenv
argument_list|(
literal|"HTTP_HOST"
argument_list|)
operator|)
condition|)
name|host
operator|=
literal|"localhost"
expr_stmt|;
comment|/* 	 * First we change directory into the cache directory so that 	 * subsequent scanning for manpath directories is rooted 	 * relative to the same position. 	 */
if|if
condition|(
operator|-
literal|1
operator|==
name|chdir
argument_list|(
name|cache
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|resp_bad
argument_list|()
expr_stmt|;
return|return
operator|(
name|EXIT_FAILURE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|==
operator|(
name|cwd
operator|=
name|opendir
argument_list|(
name|cache
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|resp_bad
argument_list|()
expr_stmt|;
return|return
operator|(
name|EXIT_FAILURE
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|pathgen
argument_list|(
name|cwd
argument_list|,
name|buf
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
comment|/* Next parse out the query string. */
if|if
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"QUERY_STRING"
argument_list|)
operator|)
condition|)
name|http_parse
argument_list|(
operator|&
name|req
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Now juggle paths to extract information. 	 * We want to extract our filetype (the file suffix), the 	 * initial path component, then the trailing component(s). 	 * Start with leading subpath component.  	 */
name|subpath
operator|=
name|path
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|page
operator|=
name|PAGE__MAX
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|path
operator|=
name|getenv
argument_list|(
literal|"PATH_INFO"
argument_list|)
operator|)
operator|||
literal|'\0'
operator|==
operator|*
name|path
condition|)
name|req
operator|.
name|page
operator|=
name|PAGE_INDEX
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|path
operator|&&
literal|'/'
operator|==
operator|*
name|path
operator|&&
literal|'\0'
operator|==
operator|*
operator|++
name|path
condition|)
name|req
operator|.
name|page
operator|=
name|PAGE_INDEX
expr_stmt|;
comment|/* Strip file suffix. */
if|if
condition|(
name|NULL
operator|!=
name|path
operator|&&
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
if|if
condition|(
name|NULL
operator|!=
name|p
operator|&&
name|NULL
operator|==
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Resolve subpath component. */
if|if
condition|(
name|NULL
operator|!=
name|path
operator|&&
name|NULL
operator|!=
operator|(
name|subpath
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
operator|*
name|subpath
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Map path into one we recognise. */
if|if
condition|(
name|NULL
operator|!=
name|path
operator|&&
literal|'\0'
operator|!=
operator|*
name|path
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|PAGE__MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|,
name|path
argument_list|)
condition|)
block|{
name|req
operator|.
name|page
operator|=
operator|(
expr|enum
name|page
operator|)
name|i
expr_stmt|;
break|break;
block|}
comment|/* Route pages. */
switch|switch
condition|(
name|req
operator|.
name|page
condition|)
block|{
case|case
operator|(
name|PAGE_INDEX
operator|)
case|:
name|pg_index
argument_list|(
operator|&
name|req
argument_list|,
name|subpath
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|PAGE_SEARCH
operator|)
case|:
name|pg_search
argument_list|(
operator|&
name|req
argument_list|,
name|subpath
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|PAGE_SHOW
operator|)
case|:
name|pg_show
argument_list|(
operator|&
name|req
argument_list|,
name|subpath
argument_list|)
expr_stmt|;
break|break;
default|default:
name|resp_error404
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|req
operator|.
name|psz
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|req
operator|.
name|p
index|[
name|i
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|req
operator|.
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|req
operator|.
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
name|strcasecmp
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|res
operator|*
operator|)
name|p1
operator|)
operator|->
name|title
argument_list|,
operator|(
operator|(
specifier|const
expr|struct
name|res
operator|*
operator|)
name|p2
operator|)
operator|->
name|title
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if an "etc" path consists of a catman.conf file.  If it  * does, that means that the path contains a tree created by catman(8)  * and should be used for indexing.  */
end_comment

begin_function
specifier|static
name|int
name|pathstop
parameter_list|(
name|DIR
modifier|*
name|dir
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
name|struct
name|stat
name|sb
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|NULL
operator|!=
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
name|stat
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_IFREG
operator|&
name|sb
operator|.
name|st_mode
condition|)
else|#
directive|else
if|if
condition|(
name|DT_REG
operator|==
name|d
operator|->
name|d_type
condition|)
endif|#
directive|endif
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|"catman.conf"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan for indexable paths.  * This adds all paths with "etc/catman.conf" to the buffer.  */
end_comment

begin_function
specifier|static
name|void
name|pathgen
parameter_list|(
name|DIR
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|DIR
modifier|*
name|cd
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|ssz
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
name|struct
name|stat
name|sb
decl_stmt|;
endif|#
directive|endif
name|sz
operator|=
name|strlcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>=
name|PATH_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Path too long"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * First, scan for the "etc" directory. 	 * If it's found, then see if it should cause us to stop.  This 	 * happens when a catman.conf is found in the directory. 	 */
name|rc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|0
operator|==
name|rc
operator|&&
name|NULL
operator|!=
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
name|stat
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|S_IFDIR
operator|&
name|sb
operator|.
name|st_mode
operator|)
else|#
directive|else
if|if
condition|(
name|DT_DIR
operator|!=
name|d
operator|->
name|d_type
endif|#
directive|endif
operator|||
name|strcmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|"etc"
argument_list|)
condition|)
continue|continue;
name|path
index|[
operator|(
name|int
operator|)
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ssz
operator|=
name|strlcat
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssz
operator|>=
name|PATH_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Path too long"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|==
operator|(
name|cd
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|rc
operator|=
name|pathstop
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
comment|/* This also strips the trailing slash. */
name|path
index|[
operator|(
name|int
operator|)
operator|--
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|req
operator|->
name|p
operator|=
name|mandoc_realloc
argument_list|(
name|req
operator|->
name|p
argument_list|,
operator|(
name|req
operator|->
name|psz
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|paths
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Strip out the leading "./" unless we're just a ".", 		 * in which case use an empty string as our name. 		 */
name|req
operator|->
name|p
index|[
operator|(
name|int
operator|)
name|req
operator|->
name|psz
index|]
operator|.
name|path
operator|=
name|mandoc_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|req
operator|->
name|p
index|[
operator|(
name|int
operator|)
name|req
operator|->
name|psz
index|]
operator|.
name|name
operator|=
name|cp
operator|=
name|mandoc_strdup
argument_list|(
name|path
operator|+
operator|(
literal|1
operator|==
name|sz
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|psz
operator|++
expr_stmt|;
comment|/*  		 * The name is just the path with all the slashes taken 		 * out of it.  Simple but effective.  		 */
for|for
control|(
init|;
literal|'\0'
operator|!=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
literal|'/'
operator|==
operator|*
name|cp
condition|)
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
return|return;
block|}
comment|/* 	 * If no etc/catman.conf was found, recursively enter child 	 * directory and continue scanning. 	 */
name|rewinddir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__sun
argument_list|)
name|stat
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|S_IFDIR
operator|&
name|sb
operator|.
name|st_mode
operator|)
else|#
directive|else
if|if
condition|(
name|DT_DIR
operator|!=
name|d
operator|->
name|d_type
endif|#
directive|endif
operator|||
literal|'.'
operator|==
name|d
operator|->
name|d_name
index|[
literal|0
index|]
condition|)
continue|continue;
name|path
index|[
operator|(
name|int
operator|)
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ssz
operator|=
name|strlcat
argument_list|(
name|path
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssz
operator|>=
name|PATH_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Path too long"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|==
operator|(
name|cd
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|pathgen
argument_list|(
name|cd
argument_list|,
name|path
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

