begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Functions for SGMII initialization, configuration,  * and monitoring.  *  *<hr>$Revision: 52004 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-board.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pcsx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ciu-defs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-mdio.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * @INTERNAL  * Perform initialization required only once for an SGMII port.  *  * @param interface Interface to init  * @param index     Index of prot on the interface  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_sgmii_hardware_init_one_time
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|const
name|uint64_t
name|clock_mhz
init|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_SCLK
argument_list|)
operator|/
literal|1000000
decl_stmt|;
name|cvmx_pcsx_miscx_ctl_reg_t
name|pcsx_miscx_ctl_reg
decl_stmt|;
name|cvmx_pcsx_linkx_timer_count_reg_t
name|pcsx_linkx_timer_count_reg
decl_stmt|;
name|cvmx_gmxx_prtx_cfg_t
name|gmxx_prtx_cfg
decl_stmt|;
comment|/* Disable GMX */
name|gmxx_prtx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_prtx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Write PCS*_LINK*_TIMER_COUNT_REG[COUNT] with the appropriate         value. 1000BASE-X specifies a 10ms interval. SGMII specifies a 1.6ms         interval. */
name|pcsx_miscx_ctl_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MISCX_CTL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsx_linkx_timer_count_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_LINKX_TIMER_COUNT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|mode
condition|)
block|{
comment|/* 1000BASE-X */
name|pcsx_linkx_timer_count_reg
operator|.
name|s
operator|.
name|count
operator|=
operator|(
literal|10000ull
operator|*
name|clock_mhz
operator|)
operator|>>
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* SGMII */
name|pcsx_linkx_timer_count_reg
operator|.
name|s
operator|.
name|count
operator|=
operator|(
literal|1600ull
operator|*
name|clock_mhz
operator|)
operator|>>
literal|10
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_LINKX_TIMER_COUNT_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|pcsx_linkx_timer_count_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Write the advertisement register to be used as the         tx_Config_Reg<D15:D0> of the autonegotiation.         In 1000BASE-X mode, tx_Config_Reg<D15:D0> is PCS*_AN*_ADV_REG.         In SGMII PHY mode, tx_Config_Reg<D15:D0> is PCS*_SGM*_AN_ADV_REG.         In SGMII MAC mode, tx_Config_Reg<D15:D0> is the fixed value 0x4001, so         this step can be skipped. */
if|if
condition|(
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|mode
condition|)
block|{
comment|/* 1000BASE-X */
name|cvmx_pcsx_anx_adv_reg_t
name|pcsx_anx_adv_reg
decl_stmt|;
name|pcsx_anx_adv_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_ANX_ADV_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsx_anx_adv_reg
operator|.
name|s
operator|.
name|rem_flt
operator|=
literal|0
expr_stmt|;
name|pcsx_anx_adv_reg
operator|.
name|s
operator|.
name|pause
operator|=
literal|3
expr_stmt|;
name|pcsx_anx_adv_reg
operator|.
name|s
operator|.
name|hfd
operator|=
literal|1
expr_stmt|;
name|pcsx_anx_adv_reg
operator|.
name|s
operator|.
name|fd
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_ANX_ADV_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|pcsx_anx_adv_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|mac_phy
condition|)
block|{
comment|/* PHY Mode */
name|cvmx_pcsx_sgmx_an_adv_reg_t
name|pcsx_sgmx_an_adv_reg
decl_stmt|;
name|pcsx_sgmx_an_adv_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_SGMX_AN_ADV_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsx_sgmx_an_adv_reg
operator|.
name|s
operator|.
name|link
operator|=
literal|1
expr_stmt|;
name|pcsx_sgmx_an_adv_reg
operator|.
name|s
operator|.
name|dup
operator|=
literal|1
expr_stmt|;
name|pcsx_sgmx_an_adv_reg
operator|.
name|s
operator|.
name|speed
operator|=
literal|2
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_SGMX_AN_ADV_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|pcsx_sgmx_an_adv_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MAC Mode - Nothing to do */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize the SERTES link for the first time or after a loss  * of link.  *  * @param interface Interface to init  * @param index     Index of prot on the interface  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_sgmii_hardware_init_link
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|cvmx_pcsx_mrx_control_reg_t
name|control_reg
decl_stmt|;
comment|/* Take PCS through a reset sequence.         PCS*_MR*_CONTROL_REG[PWR_DN] should be cleared to zero.         Write PCS*_MR*_CONTROL_REG[RESET]=1 (while not changing the value of             the other PCS*_MR*_CONTROL_REG bits).         Read PCS*_MR*_CONTROL_REG[RESET] until it changes value to zero. */
name|control_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MRX_CONTROL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
condition|)
block|{
name|control_reg
operator|.
name|s
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_MRX_CONTROL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|control_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSX_MRX_CONTROL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsx_mrx_control_reg_t
argument_list|,
name|reset
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SGMII%d: Timeout waiting for port %d to finish reset\n"
argument_list|,
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Write PCS*_MR*_CONTROL_REG[RST_AN]=1 to ensure a fresh sgmii negotiation starts. */
name|control_reg
operator|.
name|s
operator|.
name|rst_an
operator|=
literal|1
expr_stmt|;
name|control_reg
operator|.
name|s
operator|.
name|an_en
operator|=
literal|1
expr_stmt|;
name|control_reg
operator|.
name|s
operator|.
name|pwr_dn
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_MRX_CONTROL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|control_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for PCS*_MR*_STATUS_REG[AN_CPT] to be set, indicating that         sgmii autonegotiation is complete. In MAC mode this isn't an ethernet         link, but a link between Octeon and the PHY */
if|if
condition|(
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|!=
name|CVMX_BOARD_TYPE_SIM
operator|)
operator|&&
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSX_MRX_STATUS_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsx_mrx_status_reg_t
argument_list|,
name|an_cpt
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
comment|//cvmx_dprintf("SGMII%d: Port %d link timeout\n", interface, index);
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure an SGMII link to the specified speed after the SERTES  * link is up.  *  * @param interface Interface to init  * @param index     Index of prot on the interface  * @param link_info Link state to configure  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_sgmii_hardware_init_link_speed
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|index
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|int
name|is_enabled
decl_stmt|;
name|cvmx_gmxx_prtx_cfg_t
name|gmxx_prtx_cfg
decl_stmt|;
name|cvmx_pcsx_miscx_ctl_reg_t
name|pcsx_miscx_ctl_reg
decl_stmt|;
comment|/* Disable GMX before we make any changes. Remember the enable state */
name|gmxx_prtx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|is_enabled
operator|=
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|en
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_prtx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for GMX to be idle */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|rx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
operator|||
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|tx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SGMII%d: Timeout waiting for port %d to be idle\n"
argument_list|,
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Read GMX CFG again to make sure the disable completed */
name|gmxx_prtx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the misc control for PCS. We will need to set the duplication amount */
name|pcsx_miscx_ctl_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MISCX_CTL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use GMXENO to force the link down if the status we get says it should be down */
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|gmxeno
operator|=
operator|!
name|link_info
operator|.
name|s
operator|.
name|link_up
expr_stmt|;
comment|/* Only change the duplex setting if the link is up */
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|link_up
condition|)
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|duplex
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
comment|/* Do speed based setting for GMX */
switch|switch
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
condition|)
block|{
case|case
literal|10
case|:
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|1
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|0
expr_stmt|;
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|samp_pt
operator|=
literal|25
expr_stmt|;
comment|/* Setting from GMX-603 */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|0
expr_stmt|;
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|samp_pt
operator|=
literal|0x5
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|samp_pt
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|duplex
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// full duplex
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
comment|// half duplex
break|break;
default|default:
break|break;
block|}
comment|/* Write the new misc control for PCS */
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_MISCX_CTL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|pcsx_miscx_ctl_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Write the new GMX settings with the port still disabled */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_prtx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Read GMX CFG again to make sure the config completed */
name|gmxx_prtx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the enabled / disabled state */
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|en
operator|=
name|is_enabled
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_prtx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Bring up the SGMII interface to be ready for packet I/O but  * leave I/O disabled using the GMX override. This function  * follows the bringup documented in 10.6.3 of the manual.  *  * @param interface Interface to bringup  * @param num_ports Number of ports on the interface  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_sgmii_hardware_init
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|num_ports
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
comment|/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be programmed */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_0
argument_list|)
condition|)
block|{
name|cvmx_ciu_qlm2_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM2
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|0xf
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0xd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM2
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|__cvmx_helper_setup_gmx
argument_list|(
name|interface
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
name|int
name|ipd_port
init|=
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|__cvmx_helper_sgmii_hardware_init_one_time
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|__cvmx_helper_sgmii_link_set
argument_list|(
name|ipd_port
argument_list|,
name|__cvmx_helper_sgmii_link_get
argument_list|(
name|ipd_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Probe a SGMII interface and determine the number of ports  * connected to it. The SGMII interface should still be down after  * this call.  *  * @param interface Interface to probe  *  * @return Number of ports on the interface. Zero to disable.  */
end_comment

begin_function
name|int
name|__cvmx_helper_sgmii_probe
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
comment|/* Due to errata GMX-700 on CN56XXp1.x and CN52XXp1.x, the interface         needs to be enabled before IPD otherwise per port backpressure         may not work properly */
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|,
name|mode
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Bringup and enable a SGMII interface. After this call packet  * I/O should be fully functional. This is called with IPD  * enabled but PKO disabled.  *  * @param interface Interface to bring up  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_sgmii_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|num_ports
init|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|;
name|__cvmx_helper_sgmii_hardware_init
argument_list|(
name|interface
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmxx_prtx_cfg
decl_stmt|;
name|gmxx_prtx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_prtx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Return the link state of an IPD/PKO port as returned by  * auto negotiation. The result of this function may not match  * Octeon's link config if auto negotiation has changed since  * the last call to cvmx_helper_link_set().  *  * @param ipd_port IPD/PKO port to query  *  * @return Link state  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_sgmii_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|cvmx_pcsx_miscx_ctl_reg_t
name|pcsx_miscx_ctl_reg
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_pcsx_mrx_control_reg_t
name|pcsx_mrx_control_reg
decl_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
block|{
comment|/* The simulator gives you a simulated 1Gbps full duplex link */
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
name|pcsx_mrx_control_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MRX_CONTROL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsx_mrx_control_reg
operator|.
name|s
operator|.
name|loopbck1
condition|)
block|{
comment|/* Force 1Gbps full duplex link for internal loopback */
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
name|pcsx_miscx_ctl_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MISCX_CTL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|mode
condition|)
block|{
comment|/* 1000BASE-X */
comment|// FIXME
block|}
else|else
block|{
if|if
condition|(
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|mac_phy
condition|)
block|{
comment|/* PHY Mode */
name|cvmx_pcsx_mrx_status_reg_t
name|pcsx_mrx_status_reg
decl_stmt|;
name|cvmx_pcsx_anx_results_reg_t
name|pcsx_anx_results_reg
decl_stmt|;
comment|/* Don't bother continuing if the SERTES low level link is down */
name|pcsx_mrx_status_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MRX_STATUS_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsx_mrx_status_reg
operator|.
name|s
operator|.
name|lnk_st
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|__cvmx_helper_sgmii_hardware_init_link
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
comment|/* Read the autoneg results */
name|pcsx_anx_results_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_ANX_RESULTS_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsx_anx_results_reg
operator|.
name|s
operator|.
name|an_cpt
condition|)
block|{
comment|/* Auto negotiation is complete. Set status accordingly */
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
name|pcsx_anx_results_reg
operator|.
name|s
operator|.
name|dup
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
name|pcsx_anx_results_reg
operator|.
name|s
operator|.
name|link_ok
expr_stmt|;
switch|switch
condition|(
name|pcsx_anx_results_reg
operator|.
name|s
operator|.
name|spd
condition|)
block|{
case|case
literal|0
case|:
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
default|default:
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Auto negotiation isn't complete. Return link down */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
comment|/* MAC Mode */
block|{
name|result
operator|=
name|__cvmx_helper_board_link_get
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure an IPD/PKO port for the specified link state. This  * function does not influence auto negotiation at the PHY level.  * The passed link state must always match the link state returned  * by cvmx_helper_link_get(). It is normally best to use  * cvmx_helper_link_autoconf() instead.  *  * @param ipd_port  IPD/PKO port to configure  * @param link_info The new link state  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_sgmii_link_set
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|__cvmx_helper_sgmii_hardware_init_link
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|__cvmx_helper_sgmii_hardware_init_link_speed
argument_list|(
name|interface
argument_list|,
name|index
argument_list|,
name|link_info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure a port for internal and/or external loopback. Internal loopback  * causes packets sent by the port to be received by Octeon. External loopback  * causes packets received from the wire to sent out again.  *  * @param ipd_port IPD/PKO port to loopback.  * @param enable_internal  *                 Non zero if you want internal loopback  * @param enable_external  *                 Non zero if you want external loopback  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|__cvmx_helper_sgmii_configure_loopback
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|int
name|enable_internal
parameter_list|,
name|int
name|enable_external
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_pcsx_mrx_control_reg_t
name|pcsx_mrx_control_reg
decl_stmt|;
name|cvmx_pcsx_miscx_ctl_reg_t
name|pcsx_miscx_ctl_reg
decl_stmt|;
name|pcsx_mrx_control_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MRX_CONTROL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsx_mrx_control_reg
operator|.
name|s
operator|.
name|loopbck1
operator|=
name|enable_internal
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_MRX_CONTROL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|pcsx_mrx_control_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|pcsx_miscx_ctl_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSX_MISCX_CTL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsx_miscx_ctl_reg
operator|.
name|s
operator|.
name|loopbck2
operator|=
name|enable_external
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSX_MISCX_CTL_REG
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|pcsx_miscx_ctl_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|__cvmx_helper_sgmii_hardware_init_link
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_PKO_FUNCTIONS */
end_comment

end_unit

