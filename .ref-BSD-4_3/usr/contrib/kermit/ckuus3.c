begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  C K U U S 3 --  "User Interface" for Unix Kermit, part 3  */
end_comment

begin_comment
comment|/*  Author: Frank da Cruz (SY.FDC@CU20B),  Columbia University Center for Computing Activities, January 1985.  Copyright (C) 1985, Trustees of Columbia University in the City of New York.  Permission is granted to any individual or institution to use, copy, or  redistribute this software so long as it is not sold for profit, provided this  copyright notice is retained.  */
end_comment

begin_comment
comment|/*  SET and REMOTE commands; screen, debug, interrupt, and logging functions */
end_comment

begin_comment
comment|/* Includes */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckucmd.h"
end_include

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_comment
comment|/* Variables */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size
decl_stmt|,
name|spsiz
decl_stmt|,
name|rpsiz
decl_stmt|,
name|npad
decl_stmt|,
name|timint
decl_stmt|,
name|rtimo
decl_stmt|,
name|speed
decl_stmt|,
name|local
decl_stmt|,
name|server
decl_stmt|,
name|image
decl_stmt|,
name|flow
decl_stmt|,
name|displa
decl_stmt|,
name|binary
decl_stmt|,
name|fncnv
decl_stmt|,
name|delay
decl_stmt|,
name|parity
decl_stmt|,
name|deblog
decl_stmt|,
name|escape
decl_stmt|,
name|xargc
decl_stmt|,
name|turn
decl_stmt|,
name|duplex
decl_stmt|,
name|cxseen
decl_stmt|,
name|czseen
decl_stmt|,
name|nfils
decl_stmt|,
name|ckxech
decl_stmt|,
name|pktlog
decl_stmt|,
name|seslog
decl_stmt|,
name|tralog
decl_stmt|,
name|stdouf
decl_stmt|,
name|turnch
decl_stmt|,
name|chklen
decl_stmt|,
name|bctr
decl_stmt|,
name|bctu
decl_stmt|,
name|dfloc
decl_stmt|,
name|mdmtyp
decl_stmt|,
name|keep
decl_stmt|,
name|rptflg
decl_stmt|,
name|ebqflg
decl_stmt|,
name|warn
decl_stmt|,
name|quiet
decl_stmt|,
name|cnflg
decl_stmt|,
name|timef
decl_stmt|,
name|spsizf
decl_stmt|,
name|mypadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|filcnt
decl_stmt|,
name|tlci
decl_stmt|,
name|tlco
decl_stmt|,
name|ffc
decl_stmt|,
name|tfc
decl_stmt|,
name|fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|versio
decl_stmt|,
modifier|*
name|protv
decl_stmt|,
modifier|*
name|ckxv
decl_stmt|,
modifier|*
name|ckzv
decl_stmt|,
modifier|*
name|fnsv
decl_stmt|,
modifier|*
name|connv
decl_stmt|,
modifier|*
name|dftty
decl_stmt|,
modifier|*
name|cmdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
modifier|*
modifier|*
name|xargv
decl_stmt|,
modifier|*
modifier|*
name|cmlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|stchr
decl_stmt|,
name|mystch
decl_stmt|,
name|sstate
decl_stmt|,
name|padch
decl_stmt|,
name|mypadc
decl_stmt|,
name|eol
decl_stmt|,
name|seol
decl_stmt|,
name|ctlq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|filnam
index|[]
decl_stmt|,
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Declarations from cmd package */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|cmdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_comment
comment|/* From main ckuser module... */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|line
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|debfil
index|[
literal|50
index|]
decl_stmt|,
comment|/* Debugging log file name */
name|pktfil
index|[
literal|50
index|]
decl_stmt|,
comment|/* Packet log file name */
name|sesfil
index|[
literal|50
index|]
decl_stmt|,
comment|/* Session log file name */
name|trafil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transaction log file name */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tlevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take Command file level */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|tfile
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of take command fd's */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Keyword tables for SET commands */
end_comment

begin_comment
comment|/* Block checks */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|blktab
index|[]
init|=
block|{
literal|"1"
block|,
literal|1
block|,
literal|0
block|,
literal|"2"
block|,
literal|2
block|,
literal|0
block|,
literal|"3"
block|,
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Duplex keyword table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|dpxtab
index|[]
init|=
block|{
literal|"full"
block|,
literal|0
block|,
literal|0
block|,
literal|"half"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|filtab
index|[]
init|=
block|{
literal|"display"
block|,
name|XYFILD
block|,
literal|0
block|,
literal|"names"
block|,
name|XYFILN
block|,
literal|0
block|,
literal|"type"
block|,
name|XYFILT
block|,
literal|0
block|,
literal|"warning"
block|,
name|XYFILW
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfilp
init|=
operator|(
sizeof|sizeof
argument_list|(
name|filtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send/Receive Parameters */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|srtab
index|[]
init|=
block|{
literal|"end-of-packet"
block|,
name|XYEOL
block|,
literal|0
block|,
literal|"packet-length"
block|,
name|XYLEN
block|,
literal|0
block|,
literal|"pad-character"
block|,
name|XYPADC
block|,
literal|0
block|,
literal|"padding"
block|,
name|XYNPAD
block|,
literal|0
block|,
literal|"start-of-packet"
block|,
name|XYMARK
block|,
literal|0
block|,
literal|"timeout"
block|,
name|XYTIMO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsrtab
init|=
operator|(
sizeof|sizeof
argument_list|(
name|srtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flow Control */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|flotab
index|[]
init|=
block|{
literal|"none"
block|,
literal|0
block|,
literal|0
block|,
literal|"xon/xoff"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nflo
init|=
operator|(
sizeof|sizeof
argument_list|(
name|flotab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  Handshake characters  */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|hshtab
index|[]
init|=
block|{
literal|"bell"
block|,
literal|007
block|,
literal|0
block|,
literal|"cr"
block|,
literal|015
block|,
literal|0
block|,
literal|"esc"
block|,
literal|033
block|,
literal|0
block|,
literal|"lf"
block|,
literal|012
block|,
literal|0
block|,
literal|"none"
block|,
literal|999
block|,
literal|0
block|,
comment|/* (can't use negative numbers) */
literal|"xoff"
block|,
literal|023
block|,
literal|0
block|,
literal|"xon"
block|,
literal|021
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nhsh
init|=
operator|(
sizeof|sizeof
argument_list|(
name|hshtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|fntab
index|[]
init|=
block|{
comment|/* File naming */
literal|"converted"
block|,
literal|1
block|,
literal|0
block|,
literal|"literal"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|fttab
index|[]
init|=
block|{
comment|/* File types */
literal|"binary"
block|,
literal|1
block|,
literal|0
block|,
literal|"text"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|mdmtab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Modem types (in module ckudia.c) */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nmdm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parity keyword table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|partab
index|[]
init|=
block|{
literal|"even"
block|,
literal|'e'
block|,
literal|0
block|,
literal|"mark"
block|,
literal|'m'
block|,
literal|0
block|,
literal|"none"
block|,
literal|0
block|,
literal|0
block|,
literal|"odd"
block|,
literal|'o'
block|,
literal|0
block|,
literal|"space"
block|,
literal|'s'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npar
init|=
operator|(
sizeof|sizeof
argument_list|(
name|partab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On/Off table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|onoff
index|[]
init|=
block|{
literal|"off"
block|,
literal|0
block|,
literal|0
block|,
literal|"on"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incomplete File Disposition table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|ifdtab
index|[]
init|=
block|{
literal|"discard"
block|,
literal|0
block|,
literal|0
block|,
literal|"keep"
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  D O P R M  --  Set a parameter.  */
end_comment

begin_comment
comment|/*  Returns:   -2: illegal input   -1: reparse needed    0: success */
end_comment

begin_macro
name|doprm
argument_list|(
argument|xx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|xx
condition|)
block|{
case|case
name|XYEOL
case|:
comment|/* These have all been moved to set send/receive... */
case|case
name|XYLEN
case|:
comment|/* Let the user know what to do. */
case|case
name|XYMARK
case|:
case|case
name|XYNPAD
case|:
case|case
name|XYPADC
case|:
case|case
name|XYTIMO
case|:
name|printf
argument_list|(
literal|"...Use 'set send' or 'set receive' instead.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Type 'help set send' or 'help set receive' for more info.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYIFD
case|:
comment|/* Incomplete file disposition */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|ifdtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"discard"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|keep
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYLINE
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Device name"
argument_list|,
name|dftty
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|ttclos
argument_list|()
expr_stmt|;
comment|/* close old line, if any was open */
name|x
operator|=
name|strcmp
argument_list|(
name|s
argument_list|,
name|dftty
argument_list|)
condition|?
operator|-
literal|1
else|:
name|dfloc
expr_stmt|;
comment|/* Maybe let ttopen figure it out... */
if|if
condition|(
name|ttopen
argument_list|(
name|s
argument_list|,
operator|&
name|x
argument_list|,
name|mdmtyp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Can we open the new line? */
name|perror
argument_list|(
literal|"Sorry, can't open line"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* If not, give bad return */
block|}
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
name|local
operator|=
name|x
expr_stmt|;
comment|/* Set local/remote status. */
name|strcpy
argument_list|(
name|ttname
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* OK, copy name into real place. */
if|if
condition|(
operator|!
name|local
condition|)
name|speed
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If remote, say speed unknown. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"set line "
argument_list|,
name|ttname
argument_list|,
name|local
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYCHKT
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|blktab
argument_list|,
literal|3
argument_list|,
literal|""
argument_list|,
literal|"1"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|bctr
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYDEBU
case|:
return|return
operator|(
name|seton
argument_list|(
operator|&
name|deblog
argument_list|)
operator|)
return|;
case|case
name|XYDELA
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Number of seconds before starting to send"
argument_list|,
literal|"5"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"XYDELA: y"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|setnum
argument_list|(
operator|&
name|delay
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
case|case
name|XYDUPL
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|dpxtab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"full"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|duplex
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYESC
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Decimal ASCII code for escape character"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|setcc
argument_list|(
operator|&
name|escape
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
case|case
name|XYFILE
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|filtab
argument_list|,
name|nfilp
argument_list|,
literal|"File parameter"
argument_list|,
literal|""
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
name|int
name|z
decl_stmt|;
case|case
name|XYFILD
case|:
comment|/* Display */
name|y
operator|=
name|seton
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|quiet
operator|=
operator|!
name|z
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYFILN
case|:
comment|/* Names */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fntab
argument_list|,
literal|2
argument_list|,
literal|"how to handle filenames"
argument_list|,
literal|"converted"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|fncnv
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYFILT
case|:
comment|/* Type */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|fttab
argument_list|,
literal|2
argument_list|,
literal|"type of file"
argument_list|,
literal|"text"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|binary
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYFILW
case|:
comment|/* Warning/Write-Protect */
return|return
operator|(
name|seton
argument_list|(
operator|&
name|warn
argument_list|)
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"?unexpected file parameter\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
case|case
name|XYFLOW
case|:
comment|/* Flow control */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|flotab
argument_list|,
name|nflo
argument_list|,
literal|""
argument_list|,
literal|"xon/xoff"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|flow
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYHAND
case|:
comment|/* Handshake */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|hshtab
argument_list|,
name|nhsh
argument_list|,
literal|""
argument_list|,
literal|"none"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|turn
operator|=
operator|(
name|y
operator|>
literal|0127
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|turnch
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYMODM
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|mdmtab
argument_list|,
name|nmdm
argument_list|,
literal|"type of modem, direct means none"
argument_list|,
literal|"direct"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|z
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|mdmtyp
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYPARI
case|:
comment|/* Parity */
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|partab
argument_list|,
name|npar
argument_list|,
literal|""
argument_list|,
literal|"none"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* If parity not none, then we also want 8th-bit prefixing */
if|if
condition|(
name|parity
operator|=
name|y
condition|)
name|ebqflg
operator|=
literal|1
expr_stmt|;
else|else
name|ebqflg
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XYPROM
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Program's command prompt"
argument_list|,
literal|"C-Kermit>"
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\42'
condition|)
block|{
comment|/* Quoted string? */
name|x
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Yes, strip quotes. */
if|if
condition|(
operator|*
operator|(
name|s
operator|+
name|x
operator|)
operator|==
literal|'\42'
condition|)
comment|/* This allows leading or trailing */
operator|*
operator|(
name|s
operator|+
name|x
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* blanks. */
name|s
operator|++
expr_stmt|;
block|}
name|cmsetp
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* SET SEND/RECEIVE... */
case|case
name|XYRECV
case|:
case|case
name|XYSEND
case|:
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"Parameter for inbound packets"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"Parameter for outbound packets"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|srtab
argument_list|,
name|nsrtab
argument_list|,
name|line
argument_list|,
literal|""
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|XYEOL
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Decimal ASCII code for packet terminator"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setcc
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|eol
operator|=
name|z
expr_stmt|;
else|else
name|seol
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
case|case
name|XYLEN
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Maximum number of characters in a packet"
argument_list|,
literal|"90"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
block|{
comment|/* Receive... */
name|rpsiz
operator|=
name|z
expr_stmt|;
comment|/*   Just set it. */
block|}
else|else
block|{
comment|/* Send... */
name|spsiz
operator|=
name|z
expr_stmt|;
comment|/*   Set it and flag that it was set */
name|spsizf
operator|=
literal|1
expr_stmt|;
comment|/*   to allow overriding Send-Init. */
block|}
return|return
operator|(
name|y
operator|)
return|;
case|case
name|XYMARK
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Decimal ASCII code for packet-start character"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setcc
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|stchr
operator|=
name|z
expr_stmt|;
else|else
name|mystch
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
case|case
name|XYNPAD
case|:
comment|/* Padding */
name|y
operator|=
name|cmnum
argument_list|(
literal|"How many padding characters for inbound packets"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|mypadn
operator|=
name|z
expr_stmt|;
else|else
name|npad
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
case|case
name|XYPADC
case|:
comment|/* Pad character */
name|y
operator|=
name|cmnum
argument_list|(
literal|"Decimal ASCII code for inbound pad character"
argument_list|,
literal|"0"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setcc
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
name|mypadc
operator|=
name|z
expr_stmt|;
else|else
name|padch
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
case|case
name|XYTIMO
case|:
name|y
operator|=
name|cmnum
argument_list|(
literal|"Interpacket timeout interval"
argument_list|,
literal|"5"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|setnum
argument_list|(
operator|&
name|z
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|xx
operator|==
name|XYRECV
condition|)
block|{
name|timef
operator|=
literal|1
expr_stmt|;
name|timint
operator|=
name|z
expr_stmt|;
block|}
else|else
name|rtimo
operator|=
name|z
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
case|case
name|XYSPEE
case|:
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"\nSpeed setting can only be done on an external line\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"You must 'set line' before issuing this command\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lp
operator|=
name|line
expr_stmt|;
name|sprintf
argument_list|(
name|lp
argument_list|,
literal|"Baud rate for %s"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|y
operator|=
operator|(
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|y
operator|=
name|chkspd
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"?Unsupported line speed - %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|speed
operator|=
name|y
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %d baud\n"
argument_list|,
name|ttname
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|printf
argument_list|(
literal|"Not working yet - %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  C H K S P D  --  Check if argument is a valid baud rate  */
end_comment

begin_macro
name|chkspd
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|110
case|:
case|case
literal|150
case|:
case|case
literal|300
case|:
case|case
literal|600
case|:
case|case
literal|1200
case|:
case|case
literal|1800
case|:
case|case
literal|2400
case|:
case|case
literal|4800
case|:
case|case
literal|9600
case|:
return|return
operator|(
name|x
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  S E T O N  --  Parse on/off (default on), set parameter to result  */
end_comment

begin_macro
name|seton
argument_list|(
argument|prm
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|prm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"on"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
operator|*
name|prm
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  S E T N U M  --  Set parameter to result of cmnum() parse.  */
end_comment

begin_comment
comment|/*  Call with x - number from cnum parse, y - return code from cmnum */
end_comment

begin_macro
name|setnum
argument_list|(
argument|prm
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
modifier|*
name|prm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"setnum"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|>
literal|94
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Sorry, 94 is the maximum\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
operator|*
name|prm
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  S E T C C  --  Set parameter to an ASCII control character value.  */
end_comment

begin_macro
name|setcc
argument_list|(
argument|prm
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
modifier|*
name|prm
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|x
operator|>
literal|037
operator|)
operator|&&
operator|(
name|x
operator|!=
literal|0177
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Not in ASCII control range - %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
operator|*
name|prm
operator|=
name|x
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  D O R M T  --  Do a remote command  */
end_comment

begin_macro
name|dormt
argument_list|(
argument|xx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|sbuf
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
name|xx
operator|<
literal|0
condition|)
return|return
operator|(
name|xx
operator|)
return|;
switch|switch
condition|(
name|xx
condition|)
block|{
case|case
name|XZCWD
case|:
comment|/* CWD */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote directory name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"XZCWD: "
argument_list|,
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|*
name|sbuf
operator|=
name|NUL
expr_stmt|;
name|s2
operator|=
name|sbuf
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
name|NUL
condition|)
block|{
comment|/* If directory name given, */
comment|/* get password on separate line. */
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* From take file... */
operator|*
name|line
operator|=
name|NUL
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|sbuf
argument_list|,
literal|50
argument_list|,
name|tfile
index|[
name|tlevel
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|ermsg
argument_list|(
literal|"take file ends prematurely in 'remote cwd'"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|" pswd from take file"
argument_list|,
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* From terminal... */
name|printf
argument_list|(
literal|" Password: "
argument_list|)
expr_stmt|;
comment|/* get a password */
while|while
condition|(
operator|(
operator|(
name|x
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|NL
operator|)
operator|&&
operator|(
name|x
operator|!=
name|CR
operator|)
condition|)
block|{
comment|/* with no echo */
if|if
condition|(
operator|(
name|x
operator|&=
literal|0177
operator|)
operator|==
literal|'?'
condition|)
block|{
name|printf
argument_list|(
literal|"? Password of remote directory\n Password: "
argument_list|)
expr_stmt|;
name|s2
operator|=
name|sbuf
expr_stmt|;
operator|*
name|sbuf
operator|=
name|NUL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|ESC
condition|)
comment|/* Mini command line editor... */
name|putchar
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|BS
operator|||
name|x
operator|==
literal|0177
condition|)
name|s2
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|025
condition|)
block|{
name|s2
operator|=
name|sbuf
expr_stmt|;
operator|*
name|sbuf
operator|=
name|NUL
expr_stmt|;
block|}
else|else
operator|*
name|s2
operator|++
operator|=
name|x
expr_stmt|;
block|}
operator|*
name|s2
operator|=
name|NUL
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|s2
operator|=
name|sbuf
expr_stmt|;
block|}
else|else
name|s2
operator|=
literal|""
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|" password"
argument_list|,
name|s2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'C'
argument_list|,
name|s
argument_list|,
name|s2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XZDEL
case|:
comment|/* Delete */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name of remote file(s) to delete"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|sstate
operator|=
name|rfilop
argument_list|(
name|s
argument_list|,
literal|'E'
argument_list|)
operator|)
return|;
case|case
name|XZDIR
case|:
comment|/* Directory */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote directory or file specification"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|sstate
operator|=
name|setgen
argument_list|(
literal|'D'
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
operator|)
return|;
case|case
name|XZHLP
case|:
comment|/* Help */
if|if
condition|(
name|x
operator|=
operator|(
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
name|setgen
argument_list|(
literal|'H'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XZHOS
case|:
comment|/* Host */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Command for remote system"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|sstate
operator|=
literal|'c'
operator|)
return|;
case|case
name|XZPRI
case|:
comment|/* Print */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote file(s) to print on remote printer"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|sstate
operator|=
name|rfilop
argument_list|(
name|s
argument_list|,
literal|'S'
argument_list|)
operator|)
return|;
case|case
name|XZSPA
case|:
comment|/* Space */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Confirm, or remote directory name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|sstate
operator|=
name|setgen
argument_list|(
literal|'U'
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
operator|)
return|;
case|case
name|XZTYP
case|:
comment|/* Type */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote file specification"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|sstate
operator|=
name|rfilop
argument_list|(
name|s
argument_list|,
literal|'T'
argument_list|)
operator|)
return|;
case|case
name|XZWHO
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Remote user name, or carriage return"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|sstate
operator|=
name|setgen
argument_list|(
literal|'W'
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
operator|)
return|;
default|default:
if|if
condition|(
name|x
operator|=
operator|(
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|printf
argument_list|(
literal|"not working yet - %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  R F I L O P  --  Remote File Operation  */
end_comment

begin_macro
name|rfilop
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"?File specification required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"rfilop"
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|setgen
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  S C R E E N  --  Screen display function  */
end_comment

begin_comment
comment|/*  screen(f,c,n,s)       f - argument descriptor       c - a character or small integer       n - a long integer       s - a string.  Fill in this routine with the appropriate display update for the system.  This version is for a dumb tty. */
end_comment

begin_macro
name|screen
argument_list|(
argument|f
argument_list|,
argument|c
argument_list|,
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|p
init|=
literal|0
decl_stmt|;
comment|/* Screen position */
name|int
name|len
decl_stmt|;
comment|/* Length of string */
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* Output buffer */
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Length of string */
if|if
condition|(
operator|!
name|displa
operator|||
name|quiet
condition|)
return|return;
comment|/* No update if display flag off */
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|SCR_FN
case|:
comment|/* filename */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|conoc
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
operator|+
literal|1
expr_stmt|;
return|return;
case|case
name|SCR_AN
case|:
comment|/* as-name */
if|if
condition|(
name|p
operator|+
name|len
operator|>
literal|75
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conol
argument_list|(
literal|"=> "
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|+=
operator|(
name|len
operator|+
literal|3
operator|)
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return;
case|case
name|SCR_FS
case|:
comment|/* file-size */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|", Size: %ld"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|SCR_XD
case|:
comment|/* x-packet data */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|SCR_ST
case|:
comment|/* File status */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ST_OK
case|:
comment|/*  Transferred OK */
if|if
condition|(
operator|(
name|p
operator|+=
literal|5
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conoll
argument_list|(
literal|" [OK]"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
return|return;
case|case
name|ST_DISC
case|:
comment|/*  Discarded */
if|if
condition|(
operator|(
name|p
operator|+=
literal|12
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conoll
argument_list|(
literal|" [discarded]"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|12
expr_stmt|;
return|return;
case|case
name|ST_INT
case|:
comment|/*  Interrupted */
if|if
condition|(
operator|(
name|p
operator|+=
literal|14
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|conoll
argument_list|(
literal|" [interrupted]"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|14
expr_stmt|;
return|return;
case|case
name|ST_SKIP
case|:
comment|/*  Skipped */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
literal|"Skipping "
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|conoll
argument_list|(
literal|"*** screen() called with bad status ***"
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
case|case
name|SCR_PN
case|:
comment|/* Packet number */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %ld"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_PT
case|:
comment|/* Packet type or pseudotype */
if|if
condition|(
name|c
operator|==
literal|'Y'
condition|)
return|return;
comment|/* Don't bother with ACKs */
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
block|{
comment|/* Only show every 4th data packet */
if|if
condition|(
name|n
operator|%
literal|4
condition|)
return|return;
name|c
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|++
operator|>
literal|78
condition|)
block|{
comment|/* If near right margin, */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Start new line */
name|p
operator|=
literal|0
expr_stmt|;
comment|/* and reset counter. */
block|}
name|conoc
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Display the character. */
return|return;
case|case
name|SCR_TC
case|:
comment|/* transaction complete */
name|conoc
argument_list|(
name|BEL
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_EM
case|:
comment|/* Error message */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conoc
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
comment|/* +1	*/
case|case
name|SCR_WM
case|:
comment|/* Warning message */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|SCR_TU
case|:
comment|/* Undelimited text */
if|if
condition|(
operator|(
name|p
operator|+=
name|len
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
expr_stmt|;
block|}
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_TN
case|:
comment|/* Text delimited at beginning */
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|conol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
expr_stmt|;
return|return;
case|case
name|SCR_TZ
case|:
comment|/* Text delimited at end */
if|if
condition|(
operator|(
name|p
operator|+=
name|len
operator|)
operator|>
literal|78
condition|)
block|{
name|conoll
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|len
expr_stmt|;
block|}
name|conoll
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCR_QE
case|:
comment|/* Quantity equals */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %ld"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|conoll
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|conoll
argument_list|(
literal|"*** screen() called with bad object ***"
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  I N T M S G  --  Issue message about terminal interrupts  */
end_comment

begin_macro
name|intmsg
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|long
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|chstr
parameter_list|()
function_decl|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|displa
operator|)
operator|||
operator|(
name|quiet
operator|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|UXIII
operator|(
name|void
operator|)
name|conchk
argument_list|()
expr_stmt|;
comment|/* clear out pending escape-signals in ckxbsd.c */
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|UXIII
comment|/* we need to signal before kb input */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Type escape (%s) followed by:"
argument_list|,
name|chstr
argument_list|(
name|escape
argument_list|)
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"CTRL-F to cancel file,  CTRL-R to resend current packet"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"CTRL-B to cancel batch, CTRL-A for status report: "
argument_list|)
expr_stmt|;
block|}
else|else
name|screen
argument_list|(
name|SCR_TU
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  C H K I N T  --  Check for console interrupts  */
end_comment

begin_comment
comment|/*** should rework not to destroy typeahead ***/
end_comment

begin_macro
name|chkint
argument_list|()
end_macro

begin_block
block|{
name|int
name|ch
decl_stmt|,
name|cn
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|local
operator|)
operator|||
operator|(
name|quiet
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Only do this if local& not quiet */
name|cn
operator|=
name|conchk
argument_list|()
expr_stmt|;
comment|/* Any input waiting? */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"conchk"
argument_list|,
literal|""
argument_list|,
name|cn
argument_list|)
expr_stmt|;
while|while
condition|(
name|cn
operator|>
literal|0
condition|)
block|{
comment|/* Yes, read it. */
name|cn
operator|--
expr_stmt|;
comment|/* give read 5 seconds for interrupt character */
if|if
condition|(
operator|(
name|ch
operator|=
name|coninc
argument_list|(
literal|5
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|ch
operator|&
literal|0177
condition|)
block|{
case|case
literal|0001
case|:
comment|/* CTRL-A */
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"^A  Status report:"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|" file type: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary
condition|)
name|screen
argument_list|(
name|SCR_TZ
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
else|else
name|screen
argument_list|(
name|SCR_TZ
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|filcnt
argument_list|,
literal|" file number"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|ffc
argument_list|,
literal|" characters "
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|bctu
argument_list|,
literal|" block check"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|rptflg
argument_list|,
literal|" compression"
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_QE
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
name|ebqflg
argument_list|,
literal|" 8th-bit prefixing"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|0002
case|:
comment|/* CTRL-B */
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"^B - Cancelling Batch "
argument_list|)
expr_stmt|;
name|czseen
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|0006
case|:
comment|/* CTRL-F */
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"^F - Cancelling File "
argument_list|)
expr_stmt|;
name|cxseen
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|0022
case|:
comment|/* CTRL-R */
name|screen
argument_list|(
name|SCR_TN
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|"^R - Resending "
argument_list|)
expr_stmt|;
name|resend
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
comment|/* Anything else, just ignore */
name|screen
argument_list|(
name|SCR_TU
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|" [Ignored] "
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  D E B U G  --  Enter a record in the debugging log  */
end_comment

begin_comment
comment|/*  Call with a format, two strings, and a number:    f  - Format, a bit string in range 0-7.         If bit x is on, then argument number x is printed.    s1 - String, argument number 1.  If selected, printed as is.    s2 - String, argument number 2.  If selected, printed in brackets.    n  - Int, argument 3.  If selected, printed preceded by equals sign.     f=0 is special: print s1,s2, and interpret n as a char. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|debug
argument_list|(
argument|f
argument_list|,
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|s
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|sp
init|=
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|deblog
condition|)
return|return;
comment|/* If no debug log, don't */
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|F000
case|:
comment|/* 0, print both strings, */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s%s%c\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/*  and interpret n as a char */
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F001
case|:
comment|/* 1, "=n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"=%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F010
case|:
comment|/* 2, "[s2]" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s]\n"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|F011
case|:
comment|/* 3, "[s2]=n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s]=%d\n"
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F100
case|:
comment|/* 4, "s1" */
name|zsoutl
argument_list|(
name|ZDFILE
argument_list|,
name|s1
argument_list|)
expr_stmt|;
break|break;
case|case
name|F101
case|:
comment|/* 5, "s1=n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s=%d\n"
argument_list|,
name|s1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F110
case|:
comment|/* 6, "s1[s2]" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s[%s]\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F111
case|:
comment|/* 7, "s1[s2]=n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s[%s]=%d\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"\n?Invalid format for debug() - %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TLOG
end_ifdef

begin_comment
comment|/*  T L O G  --  Log a record in the transaction file  */
end_comment

begin_comment
comment|/*  Call with a format and 3 arguments: two strings and a number:    f  - Format, a bit string in range 0-7, bit x is on, arg #x is printed.    s1,s2 - String arguments 1 and 2.    n  - Int, argument 3. */
end_comment

begin_macro
name|tlog
argument_list|(
argument|f
argument_list|,
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|s
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|sp
init|=
name|s
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|tralog
condition|)
return|return;
comment|/* If no transaction log, don't */
switch|switch
condition|(
name|f
condition|)
block|{
case|case
name|F000
case|:
comment|/* 0 (special) "s1 n s2"  */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s %ld %s\n"
argument_list|,
name|s1
argument_list|,
name|n
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F001
case|:
comment|/* 1, " n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|" %ld\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F010
case|:
comment|/* 2, "[s2]" */
name|x
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s]\n"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|F011
case|:
comment|/* 3, "[s2] n" */
name|x
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"[%s] %ld\n"
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F100
case|:
comment|/* 4, "s1" */
name|zsoutl
argument_list|(
name|ZTFILE
argument_list|,
name|s1
argument_list|)
expr_stmt|;
break|break;
case|case
name|F101
case|:
comment|/* 5, "s1: n" */
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s: %ld\n"
argument_list|,
name|s1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F110
case|:
comment|/* 6, "s1 s2" */
name|x
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s %s\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|F111
case|:
comment|/* 7, "s1 s2: n" */
name|x
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
index|[
name|x
index|]
operator|==
literal|'\n'
condition|)
name|s2
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%s %s: %ld\n"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"\n?Invalid format for tlog() - %ld\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zsout
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

