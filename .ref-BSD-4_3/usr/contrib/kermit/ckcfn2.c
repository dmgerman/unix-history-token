begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  C K C F N 2  --  System-independent Kermit protocol support functions... */
end_comment

begin_comment
comment|/*  ...Part 2 (continued from ckcfns.c)  */
end_comment

begin_comment
comment|/*  Author: Frank da Cruz (SY.FDC@CU20B),  Columbia University Center for Computing Activities, January 1985.  Copyright (C) 1985, Trustees of Columbia University in the City of New York.  Permission is granted to any individual or institution to use, copy, or  redistribute this software so long as it is not sold for profit, provided this  copyright notice is retained.  */
end_comment

begin_comment
comment|/*  Note -- if you change this file, please amend the version number and date at  the top of ckcfns.c accordingly. */
end_comment

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|spsiz
decl_stmt|,
name|rpsiz
decl_stmt|,
name|timint
decl_stmt|,
name|npad
decl_stmt|,
name|chklen
decl_stmt|,
name|ebq
decl_stmt|,
name|ebqflg
decl_stmt|,
name|rpt
decl_stmt|,
name|rptq
decl_stmt|,
name|rptflg
decl_stmt|,
name|capas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pktnum
decl_stmt|,
name|prvpkt
decl_stmt|,
name|sndtyp
decl_stmt|,
name|bctr
decl_stmt|,
name|bctu
decl_stmt|,
name|size
decl_stmt|,
name|osize
decl_stmt|,
name|maxsize
decl_stmt|,
name|spktl
decl_stmt|,
name|nfils
decl_stmt|,
name|stdouf
decl_stmt|,
name|warn
decl_stmt|,
name|timef
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|parity
decl_stmt|,
name|speed
decl_stmt|,
name|turn
decl_stmt|,
name|turnch
decl_stmt|,
name|delay
decl_stmt|,
name|displa
decl_stmt|,
name|pktlog
decl_stmt|,
name|tralog
decl_stmt|,
name|seslog
decl_stmt|,
name|xflg
decl_stmt|,
name|mypadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|filcnt
decl_stmt|,
name|ffc
decl_stmt|,
name|flci
decl_stmt|,
name|flco
decl_stmt|,
name|tlci
decl_stmt|,
name|tlco
decl_stmt|,
name|tfc
decl_stmt|,
name|fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|deblog
decl_stmt|,
name|hcflg
decl_stmt|,
name|binary
decl_stmt|,
name|fncnv
decl_stmt|,
name|local
decl_stmt|,
name|server
decl_stmt|,
name|cxseen
decl_stmt|,
name|czseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|padch
decl_stmt|,
name|mypadc
decl_stmt|,
name|eol
decl_stmt|,
name|seol
decl_stmt|,
name|ctlq
decl_stmt|,
name|myctlq
decl_stmt|,
name|sstate
decl_stmt|,
modifier|*
name|hlptxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|filnam
index|[]
decl_stmt|,
name|sndpkt
index|[]
decl_stmt|,
name|recpkt
index|[]
decl_stmt|,
name|data
index|[]
decl_stmt|,
name|srvcmd
index|[]
decl_stmt|,
modifier|*
name|srvptr
decl_stmt|,
name|stchr
decl_stmt|,
name|mystch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
modifier|*
modifier|*
name|cmlist
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|CHAR
name|dopar
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  I N P U T  --  Attempt to read packet number 'pktnum'.  */
end_comment

begin_comment
comment|/*  This is the function that feeds input to Kermit's finite state machine.   If a special start state is in effect, that state is returned as if it were  the type of an incoming packet.  Otherwise:   . If the desired packet arrives within MAXTRY tries, return its type,    with its data stored in the global 'data' array.   . If the previous packet arrives again, resend the last packet and wait for    another to come in.   . If the desired packet does not arrive within MAXTRY tries, return indicating    that an error packet should be sent. */
end_comment

begin_macro
name|input
argument_list|()
end_macro

begin_block
block|{
name|int
name|len
decl_stmt|,
name|num
decl_stmt|,
name|type
decl_stmt|,
name|numtry
decl_stmt|;
if|if
condition|(
name|sstate
operator|!=
literal|0
condition|)
block|{
comment|/* If a start state is in effect, */
name|type
operator|=
name|sstate
expr_stmt|;
comment|/* return it like a packet type, */
name|sstate
operator|=
literal|0
expr_stmt|;
comment|/* and then nullify it. */
operator|*
name|data
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
else|else
name|type
operator|=
name|rpack
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|num
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Else, try to read a packet. */
comment|/* If it's the same packet we just sent, it's an echo.  Read another. */
if|if
condition|(
name|type
operator|==
name|sndtyp
condition|)
name|type
operator|=
name|rpack
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|num
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|chkint
argument_list|()
expr_stmt|;
comment|/* Check for console interrupts. */
comment|/*  If previous packet again, a timeout pseudopacket, or a bad packet, try again. */
for|for
control|(
name|numtry
operator|=
literal|0
init|;
operator|(
name|num
operator|==
name|prvpkt
operator|||
name|type
operator|==
literal|'T'
operator|||
name|type
operator|==
literal|'Q'
operator|||
name|type
operator|==
literal|'N'
operator|)
condition|;
name|numtry
operator|++
control|)
block|{
if|if
condition|(
name|numtry
operator|>
name|MAXTRY
condition|)
block|{
comment|/* If too many tries, give up */
name|strcpy
argument_list|(
name|data
argument_list|,
literal|"Timed out."
argument_list|)
expr_stmt|;
comment|/* and send a timeout error packet. */
return|return
operator|(
literal|'E'
operator|)
return|;
block|}
name|resend
argument_list|()
expr_stmt|;
comment|/* Else, send last packet again, */
if|if
condition|(
name|sstate
operator|!=
literal|0
condition|)
block|{
comment|/* If an interrupt routine has set */
name|type
operator|=
name|sstate
expr_stmt|;
comment|/* sstate behind our back, return */
name|sstate
operator|=
literal|0
expr_stmt|;
comment|/* that. */
operator|*
name|data
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
else|else
name|type
operator|=
name|rpack
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|num
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Else, try to read a packet. */
name|chkint
argument_list|()
expr_stmt|;
comment|/* Look again for interruptions. */
if|if
condition|(
name|type
operator|==
name|sndtyp
condition|)
name|type
operator|=
name|rpack
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|num
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Got what we want, clear input buffer. */
return|return
operator|(
name|type
operator|)
return|;
comment|/* Success, return packet type. */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  S P A C K  --  Construct and send a packet  */
end_comment

begin_macro
name|spack
argument_list|(
argument|type
argument_list|,
argument|num
argument_list|,
argument|len
argument_list|,
argument|dat
argument_list|)
end_macro

begin_decl_stmt
name|char
name|type
decl_stmt|,
modifier|*
name|dat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|,
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|dopar
argument_list|(
name|padch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npad
condition|;
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|j
control|)
comment|/* Do any requested padding */
empty_stmt|;
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|mystch
argument_list|)
expr_stmt|;
comment|/* Start packet with the start char */
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
name|len
operator|+
name|bctu
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put in the length */
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The packet number */
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|sndtyp
operator|=
name|type
argument_list|)
expr_stmt|;
comment|/* Packet type */
for|for
control|(
name|j
operator|=
name|len
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
operator|*
name|dat
operator|++
argument_list|)
expr_stmt|;
comment|/* Data */
name|sndpkt
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Mark end for block check */
switch|switch
condition|(
name|bctu
condition|)
block|{
case|case
literal|1
case|:
comment|/* Type 1 - 6 bit checksum */
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
name|chk1
argument_list|(
name|sndpkt
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Type 2 - 12 bit checksum*/
name|j
operator|=
name|chk2
argument_list|(
name|sndpkt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
operator|(
name|j
operator|&
literal|07700
operator|)
operator|>>
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
name|j
operator|&
literal|077
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Type 3 - 16 bit CRC-CCITT */
name|j
operator|=
name|chk3
argument_list|(
name|sndpkt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|j
operator|&
literal|0170000
argument_list|)
operator|)
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
operator|(
name|j
operator|&
literal|07700
operator|)
operator|>>
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|tochar
argument_list|(
name|j
operator|&
literal|077
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|j
operator|=
name|npad
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|padch
argument_list|)
expr_stmt|;
comment|/* Padding */
name|sndpkt
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|seol
argument_list|)
expr_stmt|;
comment|/* EOL character */
name|sndpkt
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* End of the packet */
name|ttol
argument_list|(
name|sndpkt
argument_list|,
name|spktl
operator|=
name|i
argument_list|)
expr_stmt|;
comment|/* Send the packet just built */
name|flco
operator|+=
name|spktl
expr_stmt|;
comment|/* Count the characters */
name|tlco
operator|+=
name|spktl
expr_stmt|;
if|if
condition|(
name|pktlog
condition|)
name|zsoutl
argument_list|(
name|ZPFILE
argument_list|,
name|sndpkt
argument_list|)
expr_stmt|;
comment|/* If logging packets, log it */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
name|type
argument_list|,
operator|(
name|long
operator|)
name|num
argument_list|,
name|sndpkt
argument_list|)
expr_stmt|;
comment|/* Update screen */
block|}
end_block

begin_comment
comment|/*  D O P A R  --  Add an appropriate parity bit to a character  */
end_comment

begin_function
name|CHAR
name|dopar
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|parity
condition|)
return|return
operator|(
name|ch
operator|)
return|;
else|else
name|ch
operator|&=
literal|0177
expr_stmt|;
switch|switch
condition|(
name|parity
condition|)
block|{
case|case
literal|'m'
case|:
return|return
operator|(
name|ch
operator||
literal|128
operator|)
return|;
comment|/* Mark */
case|case
literal|'s'
case|:
return|return
operator|(
name|ch
operator|&
literal|127
operator|)
return|;
comment|/* Space */
case|case
literal|'o'
case|:
comment|/* Odd (fall thru) */
case|case
literal|'e'
case|:
comment|/* Even */
name|a
operator|=
operator|(
name|ch
operator|&
literal|15
operator|)
operator|^
operator|(
operator|(
name|ch
operator|>>
literal|4
operator|)
operator|&
literal|15
operator|)
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|&
literal|3
operator|)
operator|^
operator|(
operator|(
name|a
operator|>>
literal|2
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|&
literal|1
operator|)
operator|^
operator|(
operator|(
name|a
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|parity
operator|==
literal|'o'
condition|)
name|a
operator|=
literal|1
operator|-
name|a
expr_stmt|;
comment|/* Switch sense for odd */
return|return
operator|(
name|ch
operator||
operator|(
name|a
operator|<<
literal|7
operator|)
operator|)
return|;
default|default:
return|return
operator|(
name|ch
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  C H K 1  --  Compute a type-1 Kermit 6-bit checksum.  */
end_comment

begin_macro
name|chk1
argument_list|(
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|chk
decl_stmt|;
name|chk
operator|=
name|chk2
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
operator|(
name|chk
operator|&
literal|0300
operator|)
operator|>>
literal|6
operator|)
operator|+
name|chk
operator|)
operator|&
literal|077
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  C H K 2  --  Compute the numeric sum of all the bytes in the packet.  */
end_comment

begin_macro
name|chk2
argument_list|(
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|chk
decl_stmt|;
name|int
name|p
decl_stmt|;
for|for
control|(
name|chk
operator|=
literal|0
init|;
operator|*
name|pkt
operator|!=
literal|'\0'
condition|;
operator|*
name|pkt
operator|++
control|)
block|{
name|p
operator|=
operator|(
name|parity
operator|)
condition|?
operator|*
name|pkt
operator|&
literal|0177
else|:
operator|*
name|pkt
expr_stmt|;
name|chk
operator|+=
name|p
expr_stmt|;
block|}
return|return
operator|(
name|chk
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  C H K 3  --  Compute a type-3 Kermit block check.  */
end_comment

begin_comment
comment|/*  Calculate the 16-bit CRC of a null-terminated string using a byte-oriented  tableless algorithm invented by Andy Lowry (Columbia University).  The  magic number 010201 is derived from the CRC-CCITT polynomial x^16+x^12+x^5+1.  Note - this function could be adapted for strings containing imbedded 0's  by including a length argument. */
end_comment

begin_macro
name|chk3
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|c
decl_stmt|,
name|q
decl_stmt|;
name|LONG
name|crc
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|parity
condition|)
name|c
operator|&=
literal|0177
expr_stmt|;
name|q
operator|=
operator|(
name|crc
operator|^
name|c
operator|)
operator|&
literal|017
expr_stmt|;
comment|/* Low-order nibble */
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|^
operator|(
name|q
operator|*
literal|010201
operator|)
expr_stmt|;
name|q
operator|=
operator|(
name|crc
operator|^
operator|(
name|c
operator|>>
literal|4
operator|)
operator|)
operator|&
literal|017
expr_stmt|;
comment|/* High order nibble */
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|^
operator|(
name|q
operator|*
literal|010201
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Functions for sending various kinds of packets */
end_comment

begin_macro
name|ack
argument_list|()
end_macro

begin_block
block|{
comment|/* Send an ordinary acknowledgment. */
name|spack
argument_list|(
literal|'Y'
argument_list|,
name|pktnum
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* No data. */
name|nxtpkt
argument_list|(
operator|&
name|pktnum
argument_list|)
expr_stmt|;
comment|/* Increment the packet number. */
block|}
end_block

begin_comment
comment|/* Note, only call this once! */
end_comment

begin_macro
name|ack1
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Send an ACK with data. */
name|spack
argument_list|(
literal|'Y'
argument_list|,
name|pktnum
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Send the packet. */
name|nxtpkt
argument_list|(
operator|&
name|pktnum
argument_list|)
expr_stmt|;
comment|/* Increment the packet number. */
block|}
end_block

begin_comment
comment|/* Only call this once! */
end_comment

begin_macro
name|nack
argument_list|()
end_macro

begin_block
block|{
comment|/* Negative acknowledgment. */
name|spack
argument_list|(
literal|'N'
argument_list|,
name|pktnum
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* NAK's never have data. */
block|}
end_block

begin_macro
name|resend
argument_list|()
end_macro

begin_block
block|{
comment|/* Send the old packet again. */
name|int
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|timint
operator|-
literal|2
condition|;
name|w
operator|++
control|)
block|{
comment|/* Be extra sure no stuff is */
name|ttflui
argument_list|()
expr_stmt|;
comment|/*  still coming in. */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttchk
argument_list|()
condition|)
name|ttinc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* be extra sure no stuff in SIII/V */
if|if
condition|(
operator|!
name|ttchk
argument_list|()
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|sndpkt
condition|)
name|ttol
argument_list|(
name|sndpkt
argument_list|,
name|spktl
argument_list|)
expr_stmt|;
comment|/* Resend if buffer not empty */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'%'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
name|sndpkt
argument_list|)
expr_stmt|;
comment|/* Display that resend occurred */
if|if
condition|(
name|pktlog
operator|&&
operator|*
name|sndpkt
condition|)
name|zsoutl
argument_list|(
name|ZPFILE
argument_list|,
name|sndpkt
argument_list|)
expr_stmt|;
comment|/* Log packet if desired */
block|}
end_block

begin_macro
name|errpkt
argument_list|(
argument|reason
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|reason
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Send an error packet. */
name|encstr
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|spack
argument_list|(
literal|'E'
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_TC
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|scmd
argument_list|(
argument|t
argument_list|,
argument|dat
argument_list|)
end_macro

begin_decl_stmt
name|char
name|t
decl_stmt|,
modifier|*
name|dat
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Send a packet of the given type */
name|encstr
argument_list|(
name|dat
argument_list|)
expr_stmt|;
comment|/* Encode the command string */
name|spack
argument_list|(
name|t
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|srinit
argument_list|()
end_macro

begin_block
block|{
comment|/* Send R (GET) packet */
name|encstr
argument_list|(
name|cmarg
argument_list|)
expr_stmt|;
comment|/* Encode the filename. */
name|spack
argument_list|(
literal|'R'
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Send the packet. */
block|}
end_block

begin_macro
name|nxtpkt
argument_list|(
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prvpkt
operator|=
operator|*
name|num
expr_stmt|;
comment|/* Save previous */
operator|*
name|num
operator|=
operator|(
operator|*
name|num
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
comment|/* Increment packet number mod 64 */
block|}
end_block

begin_macro
name|sigint
argument_list|()
end_macro

begin_block
block|{
comment|/* Terminal interrupt handler */
name|errpkt
argument_list|(
literal|"User typed ^C"
argument_list|)
expr_stmt|;
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
comment|/* Exit program */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* R P A C K  --  Read a Packet */
end_comment

begin_macro
name|rpack
argument_list|(
argument|l
argument_list|,
argument|n
argument_list|,
argument|dat
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|l
decl_stmt|,
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dat
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|done
decl_stmt|,
name|pstart
decl_stmt|,
name|pbl
decl_stmt|,
name|cccount
decl_stmt|,
name|tries
decl_stmt|,
name|gotsoh
decl_stmt|;
name|CHAR
name|chk
index|[
literal|4
index|]
decl_stmt|,
name|xchk
index|[
literal|4
index|]
decl_stmt|,
name|t
decl_stmt|,
name|type
decl_stmt|;
comment|/* Try 3 times to get a line that has a start-of-packet char in it. */
comment|/* This allows skipping of blank lines that some hosts might send.  */
for|for
control|(
name|gotsoh
operator|=
name|tries
operator|=
literal|0
init|;
operator|(
name|tries
operator|<
literal|3
operator|)
operator|&&
operator|(
name|gotsoh
operator|==
literal|0
operator|)
condition|;
name|tries
operator|++
control|)
block|{
name|j
operator|=
name|inlin
argument_list|()
expr_stmt|;
comment|/* Read a line */
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack: inlin fails"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'T'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'T'
operator|)
return|;
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"rpack: inlin ok, recpkt"
argument_list|,
name|recpkt
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|t
operator|=
name|recpkt
index|[
name|i
index|]
operator|)
operator|!=
name|stchr
operator|)
operator|&&
operator|(
name|i
operator|<
name|j
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Look for start of packet char */
name|gotsoh
operator|=
operator|(
name|t
operator|==
name|stchr
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|gotsoh
condition|)
name|i
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|'Q'
operator|)
return|;
comment|/* No SOH in 3 tries, fail. */
comment|/* Got something that starts out like a packet, now "parse" it. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"entering rpack with i"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack starting at i"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pstart
operator|=
name|i
expr_stmt|;
comment|/* remember where packet started */
comment|/* length */
if|if
condition|(
operator|(
name|t
operator|=
name|recpkt
index|[
name|i
operator|++
index|]
operator|)
operator|==
name|stchr
condition|)
continue|continue;
comment|/* Resynch if SOH */
if|if
condition|(
name|t
operator|==
literal|3
condition|)
name|cccount
operator|++
expr_stmt|;
comment|/* Count any control-C's */
if|if
condition|(
name|t
operator|==
name|eol
condition|)
return|return
operator|(
literal|'Q'
operator|)
return|;
operator|*
name|l
operator|=
name|unchar
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Packet length */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" pkt len"
argument_list|,
literal|""
argument_list|,
operator|*
name|l
argument_list|)
expr_stmt|;
comment|/* sequence number */
if|if
condition|(
operator|(
name|t
operator|=
name|recpkt
index|[
name|i
operator|++
index|]
operator|)
operator|==
name|stchr
condition|)
continue|continue;
if|if
condition|(
name|cccount
operator|&&
operator|(
name|t
operator|==
literal|3
operator|)
condition|)
block|{
name|conoll
argument_list|(
literal|"^C^C exit..."
argument_list|)
expr_stmt|;
name|doexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|eol
condition|)
return|return
operator|(
literal|'Q'
operator|)
return|;
operator|*
name|n
operator|=
name|unchar
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack: n"
argument_list|,
literal|""
argument_list|,
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* cont'd... */
comment|/* ...rpack(), cont'd */
comment|/* type */
if|if
condition|(
operator|(
name|type
operator|=
name|recpkt
index|[
name|i
operator|++
index|]
operator|)
operator|==
name|stchr
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|eol
condition|)
return|return
operator|(
literal|'Q'
operator|)
return|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack: type"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
literal|'S'
operator|)
operator|||
operator|(
name|type
operator|==
literal|'I'
operator|)
condition|)
name|pbl
operator|=
literal|1
expr_stmt|;
comment|/* Heuristics for  */
elseif|else
if|if
condition|(
name|type
operator|==
literal|'N'
condition|)
name|pbl
operator|=
operator|*
name|l
operator|-
literal|2
expr_stmt|;
comment|/* syncing block check type */
else|else
name|pbl
operator|=
name|bctu
expr_stmt|;
operator|*
name|l
operator|-=
operator|(
name|pbl
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* Now compute data length */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack: bctu"
argument_list|,
literal|""
argument_list|,
name|bctu
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" pbl"
argument_list|,
literal|""
argument_list|,
name|pbl
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" data length"
argument_list|,
literal|""
argument_list|,
operator|*
name|l
argument_list|)
expr_stmt|;
comment|/* data */
name|dat
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Return null string if no data */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|*
name|l
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|dat
index|[
name|j
index|]
operator|=
name|recpkt
index|[
name|i
index|]
operator|)
operator|==
name|stchr
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|dat
index|[
name|j
index|]
operator|==
name|eol
condition|)
return|return
operator|(
literal|'Q'
operator|)
return|;
name|dat
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get the block check */
name|debug
argument_list|(
name|F110
argument_list|,
literal|" packet chk"
argument_list|,
name|recpkt
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pbl
condition|;
name|j
operator|++
control|)
block|{
name|chk
index|[
name|j
index|]
operator|=
name|recpkt
index|[
name|i
index|]
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" chk[j]"
argument_list|,
literal|""
argument_list|,
name|chk
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
index|[
name|j
index|]
operator|==
name|stchr
condition|)
break|break;
if|if
condition|(
name|chk
index|[
name|j
index|]
operator|==
name|eol
condition|)
return|return
operator|(
literal|'Q'
operator|)
return|;
name|recpkt
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|chk
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" chk array, j"
argument_list|,
name|chk
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|pbl
condition|)
continue|continue;
comment|/* Block check right length? */
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Yes, done. */
block|}
comment|/* cont'd... */
comment|/* ...rpack(), cont'd */
comment|/* Got packet, now check the block check */
switch|switch
condition|(
name|pbl
condition|)
block|{
case|case
literal|1
case|:
name|xchk
index|[
literal|0
index|]
operator|=
name|tochar
argument_list|(
name|chk1
argument_list|(
operator|&
name|recpkt
index|[
name|pstart
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
index|[
literal|0
index|]
operator|!=
name|xchk
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|deblog
condition|)
block|{
name|debug
argument_list|(
name|F000
argument_list|,
literal|"rpack: chk"
argument_list|,
literal|""
argument_list|,
name|chk
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|" should be "
argument_list|,
literal|""
argument_list|,
name|xchk
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'Q'
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
name|recpkt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
case|case
literal|2
case|:
name|x
operator|=
name|chk2
argument_list|(
operator|&
name|recpkt
index|[
name|pstart
index|]
argument_list|)
expr_stmt|;
name|xchk
index|[
literal|0
index|]
operator|=
name|tochar
argument_list|(
operator|(
name|x
operator|&
literal|07700
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|xchk
index|[
literal|1
index|]
operator|=
name|tochar
argument_list|(
name|x
operator|&
literal|077
argument_list|)
expr_stmt|;
if|if
condition|(
name|deblog
condition|)
block|{
name|debug
argument_list|(
name|F000
argument_list|,
literal|" xchk[0]"
argument_list|,
literal|"="
argument_list|,
name|xchk
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|" xchk[1]"
argument_list|,
literal|"="
argument_list|,
name|xchk
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xchk
index|[
literal|0
index|]
operator|!=
name|chk
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|xchk
index|[
literal|1
index|]
operator|!=
name|chk
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|" bct2's don't compare"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'Q'
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
name|recpkt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
case|case
literal|3
case|:
name|x
operator|=
name|chk3
argument_list|(
operator|&
name|recpkt
index|[
name|pstart
index|]
argument_list|)
expr_stmt|;
name|xchk
index|[
literal|0
index|]
operator|=
name|tochar
argument_list|(
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|x
operator|&
literal|0170000
argument_list|)
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|xchk
index|[
literal|1
index|]
operator|=
name|tochar
argument_list|(
operator|(
name|x
operator|&
literal|07700
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|xchk
index|[
literal|2
index|]
operator|=
name|tochar
argument_list|(
name|x
operator|&
literal|077
argument_list|)
expr_stmt|;
if|if
condition|(
name|deblog
condition|)
block|{
name|debug
argument_list|(
name|F000
argument_list|,
literal|" xchk[0]"
argument_list|,
literal|"="
argument_list|,
name|xchk
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|" xchk[1]"
argument_list|,
literal|"="
argument_list|,
name|xchk
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|" xchk[2]"
argument_list|,
literal|"="
argument_list|,
name|xchk
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xchk
index|[
literal|0
index|]
operator|!=
name|chk
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|xchk
index|[
literal|1
index|]
operator|!=
name|chk
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|xchk
index|[
literal|2
index|]
operator|!=
name|chk
index|[
literal|2
index|]
operator|)
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|" bct3's don't compare"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'Q'
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
name|recpkt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
block|}
comment|/* Good packet, return its type */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
name|type
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|n
argument_list|)
argument_list|,
name|recpkt
argument_list|)
expr_stmt|;
comment|/* Update screen */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  I N C H R  --  Input character from communication line, with timeout  */
end_comment

begin_macro
name|inchr
argument_list|(
argument|timo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|timo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ttinc
argument_list|(
name|timo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"inchr ttinc"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Get a character */
if|if
condition|(
name|parity
condition|)
name|c
operator|=
name|c
operator|&
literal|0177
expr_stmt|;
comment|/* If parity on, discard parity bit. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" after parity"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  I N L I N  -- Input a line (up to break char) from communication line  */
end_comment

begin_comment
comment|/*  Returns number of chars input on success, -1 on failure.  */
end_comment

begin_comment
comment|/*  Number of chars guaranteed to be within RBUFL.  */
end_comment

begin_macro
name|inlin
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|maxt
decl_stmt|;
name|CHAR
name|e
decl_stmt|;
name|maxt
operator|=
operator|(
name|speed
operator|>=
literal|110
operator|)
condition|?
operator|(
name|MAXTRY
operator|*
literal|9600
operator|/
name|speed
operator|)
else|:
name|MAXTRY
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"inlin: speed"
argument_list|,
literal|""
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" maxt"
argument_list|,
literal|""
argument_list|,
name|maxt
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
name|turn
operator|)
condition|?
name|turnch
else|:
name|eol
expr_stmt|;
name|i
operator|=
name|j
operator|=
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parity
condition|)
block|{
while|while
condition|(
operator|(
name|j
operator|!=
name|e
operator|)
operator|&&
operator|(
name|i
operator|<
name|RBUFL
operator|)
operator|&&
operator|(
name|k
operator|<
name|maxt
operator|)
condition|)
block|{
name|j
operator|=
name|inchr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Get char, 1 second timeout */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"inlin inchr"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|k
operator|++
expr_stmt|;
comment|/* Timed out, count. */
else|else
block|{
if|if
condition|(
name|j
condition|)
name|recpkt
index|[
name|i
operator|++
index|]
operator|=
name|j
expr_stmt|;
comment|/* Got one, save it, */
name|k
operator|=
literal|0
expr_stmt|;
comment|/* and reset timeout counter. */
block|}
block|}
block|}
else|else
block|{
name|i
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|RBUFL
argument_list|,
name|timint
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Get them all at once */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|k
operator|=
literal|1
expr_stmt|;
block|}
name|recpkt
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate near end of packet */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"inlin"
argument_list|,
name|recpkt
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Debug report... */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" timeouts"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* No characters, return. */
if|if
condition|(
name|pktlog
condition|)
name|zsoutl
argument_list|(
name|ZPFILE
argument_list|,
name|recpkt
argument_list|)
expr_stmt|;
comment|/* Log any we got, if logging. */
if|if
condition|(
name|k
operator|>
name|maxt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* If too many tries, give up. */
name|tlci
operator|+=
name|i
expr_stmt|;
comment|/* All OK, Count the characters. */
name|flci
operator|+=
name|i
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

end_unit

