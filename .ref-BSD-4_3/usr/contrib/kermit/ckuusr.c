begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|char
modifier|*
name|userv
init|=
literal|"User Interface 4C(052), 2 Aug 85"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  C K U U S R --  "User Interface" for Unix Kermit (Part 1)  */
end_comment

begin_comment
comment|/*  Author: Frank da Cruz (SY.FDC@CU20B),  Columbia University Center for Computing Activities, January 1985.  Copyright (C) 1985, Trustees of Columbia University in the City of New York.  Permission is granted to any individual or institution to use, copy, or  redistribute this software so long as it is not sold for profit, provided this  copyright notice is retained.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  The ckuser module contains the terminal input and output functions for Unix  Kermit.  It includes a simple Unix-style command line parser as well as  an interactive prompting keyword command parser.  It depends on the existence  of Unix facilities like fopen, fgets, feof, (f)printf, argv/argc, etc.  Other  functions that are likely to vary among Unix implementations -- like setting  terminal modes or interrupts -- are invoked via calls to functions that are  defined in the system-dependent modules, ck?[ft]io.c.   The command line parser processes any arguments found on the command line,  as passed to main() via argv/argc.  The interactive parser uses the facilities  of the cmd package (developed for this program, but usable by any program).   Any command parser may be substituted for this one.  The only requirements  for the Kermit command parser are these:   1. Set parameters via global variables like duplex, speed, ttname, etc.     See ckmain.c for the declarations and descriptions of these variables.   2. If a command can be executed without the use of Kermit protocol, then     execute the command directly and set the variable sstate to 0. Examples     include 'set' commands, local directory listings, the 'connect' command.   3. If a command requires the Kermit protocol, set the following variables:      sstate                             string data       'x' (enter server mode)            (none)       'r' (send a 'get' command)         cmarg, cmarg2       'v' (enter receive mode)           cmarg2       'g' (send a generic command)       cmarg       's' (send files)                   nfils, cmarg& cmarg2 OR cmlist       'c' (send a remote host command)   cmarg      cmlist is an array of pointers to strings.     cmarg, cmarg2 are pointers to strings.     nfils is an integer.          cmarg can be a filename string (possibly wild), or        a pointer to a prefabricated generic command string, or        a pointer to a host command string.     cmarg2 is the name to send a single file under, or        the name under which to store an incoming file; must not be wild.     cmlist is a list of nonwild filenames, such as passed via argv.     nfils is an integer, interpreted as follows:       -1: argument string is in cmarg, and should be expanded internally.        0: stdin.>0: number of files to send, from cmlist.   The screen() function is used to update the screen during file transfer.  The tlog() function maintains a transaction log.  The debug() function maintains a debugging log.  The intmsg() and chkint() functions provide the user i/o for interrupting    file transfers. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Includes */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckucmd.h"
end_include

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_define
define|#
directive|define
name|KERMRC
value|"kermit.ini"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KERMRC
value|".kermrc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* External Kermit Variables, see ckmain.c for description. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size
decl_stmt|,
name|spsiz
decl_stmt|,
name|rpsiz
decl_stmt|,
name|npad
decl_stmt|,
name|timint
decl_stmt|,
name|rtimo
decl_stmt|,
name|speed
decl_stmt|,
name|local
decl_stmt|,
name|server
decl_stmt|,
name|displa
decl_stmt|,
name|binary
decl_stmt|,
name|fncnv
decl_stmt|,
name|delay
decl_stmt|,
name|parity
decl_stmt|,
name|deblog
decl_stmt|,
name|escape
decl_stmt|,
name|xargc
decl_stmt|,
name|flow
decl_stmt|,
name|turn
decl_stmt|,
name|duplex
decl_stmt|,
name|cxseen
decl_stmt|,
name|czseen
decl_stmt|,
name|nfils
decl_stmt|,
name|ckxech
decl_stmt|,
name|pktlog
decl_stmt|,
name|seslog
decl_stmt|,
name|tralog
decl_stmt|,
name|stdouf
decl_stmt|,
name|turnch
decl_stmt|,
name|chklen
decl_stmt|,
name|bctr
decl_stmt|,
name|bctu
decl_stmt|,
name|dfloc
decl_stmt|,
name|mdmtyp
decl_stmt|,
name|keep
decl_stmt|,
name|rptflg
decl_stmt|,
name|rptq
decl_stmt|,
name|ebqflg
decl_stmt|,
name|ebq
decl_stmt|,
name|warn
decl_stmt|,
name|quiet
decl_stmt|,
name|cnflg
decl_stmt|,
name|timef
decl_stmt|,
name|spsizf
decl_stmt|,
name|mypadn
decl_stmt|,
name|tsecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|filcnt
decl_stmt|,
name|tlci
decl_stmt|,
name|tlco
decl_stmt|,
name|ffc
decl_stmt|,
name|tfc
decl_stmt|,
name|fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|versio
decl_stmt|,
modifier|*
name|protv
decl_stmt|,
modifier|*
name|ckxv
decl_stmt|,
modifier|*
name|ckzv
decl_stmt|,
modifier|*
name|fnsv
decl_stmt|,
modifier|*
name|connv
decl_stmt|,
modifier|*
name|dftty
decl_stmt|,
modifier|*
name|cmdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dialv
decl_stmt|,
modifier|*
name|loginv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ckxsys
decl_stmt|,
modifier|*
name|ckzsys
decl_stmt|,
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
modifier|*
modifier|*
name|xargv
decl_stmt|,
modifier|*
modifier|*
name|cmlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|mystch
decl_stmt|,
name|stchr
decl_stmt|,
name|sstate
decl_stmt|,
name|mypadc
decl_stmt|,
name|padch
decl_stmt|,
name|eol
decl_stmt|,
name|seol
decl_stmt|,
name|ctlq
decl_stmt|,
name|filnam
index|[]
decl_stmt|,
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|DIRCMD
decl_stmt|,
modifier|*
name|PWDCMD
decl_stmt|,
name|cmerrp
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations from cmd package */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|cmdbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffer */
end_comment

begin_comment
comment|/* Declarations from ck?fio.c module */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|SPACMD
decl_stmt|,
modifier|*
name|zhome
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Space command, home directory. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|backgrd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kermit executing in background */
end_comment

begin_comment
comment|/* The background flag is set by ckutio.c (via conint() ) to note whether */
end_comment

begin_comment
comment|/* this kermit is executing in background ('&' on shell command line).    */
end_comment

begin_comment
comment|/* Variables and symbols local to this module */
end_comment

begin_decl_stmt
name|char
name|line
index|[
name|CMDBL
operator|+
literal|10
index|]
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_decl_stmt
name|char
name|debfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging log file name */
end_comment

begin_decl_stmt
name|char
name|pktfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet log file name */
end_comment

begin_decl_stmt
name|char
name|sesfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Session log file name */
end_comment

begin_decl_stmt
name|char
name|trafil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transaction log file name */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|,
comment|/* General purpose int */
name|cflg
decl_stmt|,
comment|/* Command-line connect cmd given */
name|action
decl_stmt|,
comment|/* Action selected on command line*/
name|repars
decl_stmt|,
comment|/* Reparse needed */
name|tlevel
decl_stmt|,
comment|/* Take command level */
name|cwdf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CWD has been done */
end_comment

begin_define
define|#
directive|define
name|MAXTAKE
value|20
end_define

begin_comment
comment|/* Maximum nesting of TAKE files */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|tfile
index|[
name|MAXTAKE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File pointers for TAKE command */
end_comment

begin_decl_stmt
name|char
modifier|*
name|homdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to home directory string */
end_comment

begin_decl_stmt
name|char
name|cmdstr
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  C M D L I N  --  Get arguments from command line  */
end_comment

begin_comment
comment|/*  Simple Unix-style command line parser, conforming with 'A Proposed Command  Syntax Standard for Unix Systems', Hemenway& Armitage, Unix/World, Vol.1,  No.3, 1984. */
end_comment

begin_macro
name|cmdlin
argument_list|()
end_macro

begin_block
block|{
name|char
name|x
decl_stmt|;
comment|/* Local general-purpose int */
name|cmarg
operator|=
literal|""
expr_stmt|;
comment|/* Initialize globals */
name|cmarg2
operator|=
literal|""
expr_stmt|;
name|action
operator|=
name|cflg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|xargc
operator|>
literal|0
condition|)
block|{
comment|/* Go through command line words */
name|xargv
operator|++
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"xargv"
argument_list|,
operator|*
name|xargv
argument_list|,
name|xargc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
condition|)
block|{
comment|/* Got an option (begins with dash) */
name|x
operator|=
operator|*
operator|(
operator|*
name|xargv
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Get the option letter */
name|x
operator|=
name|doarg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Go handle the option */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|exit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No dash where expected */
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|BAD_EXIT
argument_list|)
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"action"
argument_list|,
literal|""
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
if|if
condition|(
operator|(
name|action
operator|==
literal|'g'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'r'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'c'
operator|)
operator|||
operator|(
name|cflg
operator|!=
literal|0
operator|)
condition|)
name|fatal
argument_list|(
literal|"-l and -b required"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmarg2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|action
operator|!=
literal|'s'
operator|)
operator|&&
operator|(
name|action
operator|!=
literal|'r'
operator|)
operator|&&
operator|(
name|action
operator|!=
literal|'v'
operator|)
condition|)
name|fatal
argument_list|(
literal|"-a without -s, -r, or -g"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|action
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|stdouf
operator|)
operator|&&
operator|(
operator|!
name|local
operator|)
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"unredirected -k can only be used in local mode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|action
operator|==
literal|'s'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'v'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'r'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'x'
operator|)
condition|)
block|{
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stdouf
condition|)
name|displa
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|quiet
condition|)
name|displa
operator|=
literal|0
expr_stmt|;
comment|/* No display if quiet requested */
if|if
condition|(
name|cflg
condition|)
block|{
name|conect
argument_list|()
expr_stmt|;
comment|/* Connect if requested */
if|if
condition|(
name|action
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cnflg
condition|)
name|conect
argument_list|()
expr_stmt|;
comment|/* And again if requested */
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
comment|/* Then exit indicating success */
block|}
block|}
if|if
condition|(
name|displa
condition|)
name|concb
argument_list|(
name|escape
argument_list|)
expr_stmt|;
comment|/* (for console "interrupts") */
return|return
operator|(
name|action
operator|)
return|;
comment|/* Then do any requested protocol */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  D O A R G  --  Do a command-line argument.  */
end_comment

begin_macro
name|doarg
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|char
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|z
decl_stmt|;
name|char
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
operator|*
name|xargv
operator|+
literal|1
expr_stmt|;
comment|/* Pointer for bundled args */
while|while
condition|(
name|x
condition|)
block|{
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|'x'
case|:
comment|/* server */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|action
operator|=
literal|'x'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|action
operator|=
name|setgen
argument_list|(
literal|'F'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* receive */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|action
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* receive to stdout */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|stdouf
operator|=
literal|1
expr_stmt|;
name|action
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* send */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -s"
argument_list|)
expr_stmt|;
name|z
operator|=
name|nfils
operator|=
literal|0
expr_stmt|;
comment|/* Initialize file counter, flag */
name|cmlist
operator|=
name|xargv
operator|+
literal|1
expr_stmt|;
comment|/* Remember this pointer */
while|while
condition|(
operator|--
name|xargc
operator|>
literal|0
condition|)
block|{
comment|/* Traverse the list */
operator|*
name|xargv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
condition|)
block|{
comment|/* Check for sending stdin */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|xargv
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|z
operator|++
expr_stmt|;
block|}
name|nfils
operator|++
expr_stmt|;
comment|/* Bump file counter */
block|}
name|xargc
operator|++
operator|,
operator|*
name|xargv
operator|--
expr_stmt|;
comment|/* Adjust argv/argc */
if|if
condition|(
name|nfils
operator|<
literal|1
condition|)
name|fatal
argument_list|(
literal|"missing filename for -s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|>
literal|1
condition|)
name|fatal
argument_list|(
literal|"-s: too many -'s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|nfils
operator|==
literal|1
condition|)
name|nfils
operator|=
literal|0
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"invalid mixture of filenames and '-' in -s"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfils
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"sending from terminal not allowed"
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
operator|*
name|xargv
argument_list|,
literal|""
argument_list|,
name|nfils
argument_list|)
expr_stmt|;
name|action
operator|=
literal|'s'
expr_stmt|;
break|break;
comment|/* cont'd... */
comment|/* ...doarg(), cont'd */
case|case
literal|'g'
case|:
comment|/* get */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -g"
argument_list|)
expr_stmt|;
operator|*
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing filename for -g"
argument_list|)
expr_stmt|;
name|cmarg
operator|=
operator|*
name|xargv
expr_stmt|;
name|action
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* connect before */
name|cflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* connect after */
name|cnflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* help */
name|usage
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'a'
case|:
comment|/* "as" */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -a"
argument_list|)
expr_stmt|;
operator|*
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing name in -a"
argument_list|)
expr_stmt|;
name|cmarg2
operator|=
operator|*
name|xargv
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* set line */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -l"
argument_list|)
expr_stmt|;
operator|*
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"communication line device name missing"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ttname
argument_list|,
operator|*
name|xargv
argument_list|)
expr_stmt|;
comment|/*  if (strcmp(ttname,dftty) == 0) local = dfloc; else local = 1;  */
name|local
operator|=
operator|(
name|strcmp
argument_list|(
name|ttname
argument_list|,
name|CTTNAM
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* (better than old way) */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"local"
argument_list|,
literal|""
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|ttopen
argument_list|(
name|ttname
argument_list|,
operator|&
name|local
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* set baud */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling"
argument_list|)
expr_stmt|;
operator|*
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing baud"
argument_list|)
expr_stmt|;
name|z
operator|=
name|atoi
argument_list|(
operator|*
name|xargv
argument_list|)
expr_stmt|;
comment|/* Convert to number */
if|if
condition|(
name|chkspd
argument_list|(
name|z
argument_list|)
operator|>
operator|-
literal|1
condition|)
name|speed
operator|=
name|z
expr_stmt|;
comment|/* Check it */
else|else
name|fatal
argument_list|(
literal|"unsupported baud rate"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Treat files as binary */
name|binary
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* cont'd... */
comment|/* ...doarg(), cont'd */
case|case
literal|'w'
case|:
comment|/* File warning */
name|warn
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Quiet */
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* debug */
name|debopn
argument_list|(
literal|"debug.log"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* set parity */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling"
argument_list|)
expr_stmt|;
operator|*
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing parity"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
operator|=
operator|*
operator|*
name|xargv
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'o'
case|:
case|case
literal|'m'
case|:
case|case
literal|'s'
case|:
name|parity
operator|=
name|x
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|parity
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid parity"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|turn
operator|=
literal|1
expr_stmt|;
comment|/* Line turnaround handshake */
name|turnch
operator|=
name|XON
expr_stmt|;
comment|/* XON is turnaround character */
name|duplex
operator|=
literal|1
expr_stmt|;
comment|/* Half duplex */
name|flow
operator|=
literal|0
expr_stmt|;
comment|/* No flow control */
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid argument, type 'kermit -h' for help"
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
operator|*
operator|++
name|xp
expr_stmt|;
comment|/* See if options are bundled */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Misc */
end_comment

begin_macro
name|fatal
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Fatal error message */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nFatal: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Fatal:"
argument_list|,
name|msg
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
name|doexit
argument_list|(
name|BAD_EXIT
argument_list|)
expr_stmt|;
comment|/* Exit indicating failure */
block|}
end_block

begin_macro
name|ermsg
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Print error message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n%s - %s\n"
argument_list|,
name|cmerrp
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Error -"
argument_list|,
name|msg
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Interactive command parser */
end_comment

begin_comment
comment|/* Top-Level Keyword Table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|cmdtab
index|[]
init|=
block|{
literal|"!"
block|,
name|XXSHE
block|,
literal|0
block|,
literal|"%"
block|,
name|XXCOM
block|,
name|CM_INV
block|,
literal|"bye"
block|,
name|XXBYE
block|,
literal|0
block|,
literal|"c"
block|,
name|XXCON
block|,
name|CM_INV
block|,
literal|"close"
block|,
name|XXCLO
block|,
literal|0
block|,
literal|"connect"
block|,
name|XXCON
block|,
literal|0
block|,
literal|"cwd"
block|,
name|XXCWD
block|,
literal|0
block|,
literal|"dial"
block|,
name|XXDIAL
block|,
literal|0
block|,
literal|"directory"
block|,
name|XXDIR
block|,
literal|0
block|,
literal|"echo"
block|,
name|XXECH
block|,
literal|0
block|,
literal|"exit"
block|,
name|XXEXI
block|,
literal|0
block|,
literal|"finish"
block|,
name|XXFIN
block|,
literal|0
block|,
literal|"get"
block|,
name|XXGET
block|,
literal|0
block|,
literal|"help"
block|,
name|XXHLP
block|,
literal|0
block|,
literal|"log"
block|,
name|XXLOG
block|,
literal|0
block|,
literal|"quit"
block|,
name|XXQUI
block|,
literal|0
block|,
literal|"r"
block|,
name|XXREC
block|,
name|CM_INV
block|,
literal|"receive"
block|,
name|XXREC
block|,
literal|0
block|,
literal|"remote"
block|,
name|XXREM
block|,
literal|0
block|,
literal|"s"
block|,
name|XXSEN
block|,
name|CM_INV
block|,
literal|"script"
block|,
name|XXLOGI
block|,
literal|0
block|,
literal|"send"
block|,
name|XXSEN
block|,
literal|0
block|,
literal|"server"
block|,
name|XXSER
block|,
literal|0
block|,
literal|"set"
block|,
name|XXSET
block|,
literal|0
block|,
literal|"show"
block|,
name|XXSHO
block|,
literal|0
block|,
literal|"space"
block|,
name|XXSPA
block|,
literal|0
block|,
literal|"statistics"
block|,
name|XXSTA
block|,
literal|0
block|,
literal|"take"
block|,
name|XXTAK
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncmd
init|=
operator|(
sizeof|sizeof
argument_list|(
name|cmdtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Parameter keyword table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|prmtab
index|[]
init|=
block|{
literal|"baud"
block|,
name|XYSPEE
block|,
name|CM_INV
block|,
literal|"block-check"
block|,
name|XYCHKT
block|,
literal|0
block|,
literal|"delay"
block|,
name|XYDELA
block|,
literal|0
block|,
literal|"duplex"
block|,
name|XYDUPL
block|,
literal|0
block|,
literal|"end-of-packet"
block|,
name|XYEOL
block|,
name|CM_INV
block|,
comment|/* moved to send/receive */
literal|"escape-character"
block|,
name|XYESC
block|,
literal|0
block|,
literal|"file"
block|,
name|XYFILE
block|,
literal|0
block|,
literal|"flow-control"
block|,
name|XYFLOW
block|,
literal|0
block|,
literal|"handshake"
block|,
name|XYHAND
block|,
literal|0
block|,
literal|"incomplete"
block|,
name|XYIFD
block|,
literal|0
block|,
literal|"line"
block|,
name|XYLINE
block|,
literal|0
block|,
literal|"modem-dialer"
block|,
name|XYMODM
block|,
literal|0
block|,
literal|"packet-length"
block|,
name|XYLEN
block|,
name|CM_INV
block|,
comment|/* moved to send/receive */
literal|"pad-character"
block|,
name|XYPADC
block|,
name|CM_INV
block|,
comment|/* moved to send/receive */
literal|"padding"
block|,
name|XYNPAD
block|,
name|CM_INV
block|,
comment|/* moved to send/receive */
literal|"parity"
block|,
name|XYPARI
block|,
literal|0
block|,
literal|"prompt"
block|,
name|XYPROM
block|,
literal|0
block|,
literal|"receive"
block|,
name|XYRECV
block|,
literal|0
block|,
literal|"send"
block|,
name|XYSEND
block|,
literal|0
block|,
literal|"speed"
block|,
name|XYSPEE
block|,
literal|0
block|,
literal|"start-of-packet"
block|,
name|XYMARK
block|,
name|CM_INV
block|,
comment|/* moved to send/receive */
literal|"timeout"
block|,
name|XYTIMO
block|,
name|CM_INV
comment|/* moved to send/receive */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nprm
init|=
operator|(
sizeof|sizeof
argument_list|(
name|prmtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many parameters */
end_comment

begin_comment
comment|/* Remote Command Table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|remcmd
index|[]
init|=
block|{
literal|"cwd"
block|,
name|XZCWD
block|,
literal|0
block|,
literal|"delete"
block|,
name|XZDEL
block|,
literal|0
block|,
literal|"directory"
block|,
name|XZDIR
block|,
literal|0
block|,
literal|"help"
block|,
name|XZHLP
block|,
literal|0
block|,
literal|"host"
block|,
name|XZHOS
block|,
literal|0
block|,
literal|"space"
block|,
name|XZSPA
block|,
literal|0
block|,
literal|"type"
block|,
name|XZTYP
block|,
literal|0
block|,
literal|"who"
block|,
name|XZWHO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nrmt
init|=
operator|(
sizeof|sizeof
argument_list|(
name|remcmd
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|logtab
index|[]
init|=
block|{
literal|"debugging"
block|,
name|LOGD
block|,
literal|0
block|,
literal|"packets"
block|,
name|LOGP
block|,
literal|0
block|,
literal|"session"
block|,
name|LOGS
block|,
literal|0
block|,
literal|"transactions"
block|,
name|LOGT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlog
init|=
operator|(
sizeof|sizeof
argument_list|(
name|logtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Show command arguments */
end_comment

begin_define
define|#
directive|define
name|SHPAR
value|0
end_define

begin_comment
comment|/* Parameters */
end_comment

begin_define
define|#
directive|define
name|SHVER
value|1
end_define

begin_comment
comment|/* Versions */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|shotab
index|[]
init|=
block|{
literal|"parameters"
block|,
name|SHPAR
block|,
literal|0
block|,
literal|"versions"
block|,
name|SHVER
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  C M D I N I  --  Initialize the interactive command parser  */
end_comment

begin_macro
name|cmdini
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s,%s\nType ? for help\n"
argument_list|,
name|versio
argument_list|,
name|ckxsys
argument_list|)
expr_stmt|;
name|cmsetp
argument_list|(
literal|"C-Kermit>"
argument_list|)
expr_stmt|;
comment|/* Set default prompt. */
name|tlevel
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Take file level */
comment|/* Look for init file in home or current directory. */
name|homdir
operator|=
name|zhome
argument_list|()
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
name|lp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|homdir
condition|)
block|{
name|strcpy
argument_list|(
name|lp
argument_list|,
name|homdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|strcat
argument_list|(
name|lp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|lp
argument_list|,
name|KERMRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfile
index|[
literal|0
index|]
operator|=
name|fopen
argument_list|(
name|line
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tlevel
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"init file"
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|homdir
operator|&&
operator|(
name|tlevel
operator|<
literal|0
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|lp
argument_list|,
name|KERMRC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfile
index|[
literal|0
index|]
operator|=
name|fopen
argument_list|(
name|line
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tlevel
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"init file"
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"no init file"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|congm
argument_list|()
expr_stmt|;
comment|/* Get console tty modes */
block|}
end_block

begin_comment
comment|/*  T R A P  --  Terminal interrupt handler */
end_comment

begin_macro
name|trap
argument_list|()
end_macro

begin_block
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"terminal interrupt..."
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
comment|/* Exit indicating success */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  P A R S E R  --  Top-level interactive command parser.  */
end_comment

begin_macro
name|parser
argument_list|()
end_macro

begin_block
block|{
name|int
name|xx
decl_stmt|,
name|cbn
decl_stmt|;
name|char
modifier|*
name|cbp
decl_stmt|;
name|concb
argument_list|(
name|escape
argument_list|)
expr_stmt|;
comment|/* Put console in cbreak mode. */
name|conint
argument_list|(
name|trap
argument_list|)
expr_stmt|;
comment|/* Turn on console terminal interrupts. */
comment|/*  sstate becomes nonzero when a command has been parsed that requires some  action from the protocol module.  Any non-protocol actions, such as local  directory listing or terminal emulation, are invoked directly from below. */
if|if
condition|(
name|local
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*** Temporary kludge ***/
name|sstate
operator|=
literal|0
expr_stmt|;
comment|/* Start with no start state. */
while|while
condition|(
name|sstate
operator|==
literal|0
condition|)
block|{
comment|/* Parse cmds until action requested */
while|while
condition|(
operator|(
name|tlevel
operator|>
operator|-
literal|1
operator|)
operator|&&
name|feof
argument_list|(
name|tfile
index|[
name|tlevel
index|]
argument_list|)
condition|)
block|{
comment|/* If end of take */
name|fclose
argument_list|(
name|tfile
index|[
name|tlevel
index|]
argument_list|)
expr_stmt|;
comment|/* file, close it */
name|tlevel
operator|--
expr_stmt|;
comment|/* and forget about it. */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
comment|/* and clear the cmd buffer. */
block|}
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* If in take file */
name|cbp
operator|=
name|cmdbuf
expr_stmt|;
comment|/* Get the next line. */
name|cbn
operator|=
name|CMDBL
expr_stmt|;
comment|/* Loop to get next command line and all continuation lines from take file. */
name|again
label|:
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|cbn
argument_list|,
name|tfile
index|[
name|tlevel
index|]
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|lp
operator|=
name|line
expr_stmt|;
comment|/* Got one, copy it. */
while|while
condition|(
operator|*
name|cbp
operator|++
operator|=
operator|*
name|lp
operator|++
condition|)
if|if
condition|(
operator|--
name|cbn
operator|<
literal|1
condition|)
name|fatal
argument_list|(
literal|"Command too long for internal buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cbp
operator|-
literal|3
operator|)
operator|==
literal|'\\'
condition|)
block|{
comment|/* Continued on next line? */
name|cbp
operator|-=
literal|3
expr_stmt|;
comment|/* If so, back up pointer, */
goto|goto
name|again
goto|;
comment|/* go back, get next line. */
block|}
name|stripq
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
comment|/* Strip any quotes from cmd buffer. */
block|}
else|else
block|{
comment|/* No take file, get typein. */
name|prompt
argument_list|()
expr_stmt|;
comment|/* Issue interactive prompt. */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
block|}
name|repars
operator|=
literal|1
expr_stmt|;
name|displa
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|repars
condition|)
block|{
name|cmres
argument_list|()
expr_stmt|;
comment|/* Reset buffer pointers. */
name|xx
operator|=
name|cmkey
argument_list|(
name|cmdtab
argument_list|,
name|ncmd
argument_list|,
literal|"Command"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"top-level cmkey"
argument_list|,
literal|""
argument_list|,
name|xx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|docmd
argument_list|(
name|xx
argument_list|)
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
comment|/* ...exit successfully */
case|case
operator|-
literal|1
case|:
comment|/* Reparse needed */
name|repars
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
operator|-
literal|2
case|:
comment|/* Invalid command given */
if|if
condition|(
name|backgrd
condition|)
comment|/* if in background, terminate */
name|fatal
argument_list|(
literal|"Kermit command error in background execution"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* If in take file, quit */
name|ermsg
argument_list|(
literal|"Kermit command error: take file terminated."
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tfile
index|[
name|tlevel
index|]
argument_list|)
expr_stmt|;
name|tlevel
operator|--
expr_stmt|;
block|}
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
comment|/* (fall thru) */
case|case
operator|-
literal|3
case|:
comment|/* Empty command OK at top level */
default|default:
comment|/* Anything else (fall thru) */
name|repars
operator|=
literal|0
expr_stmt|;
comment|/* No reparse, get new command. */
continue|continue;
block|}
block|}
block|}
comment|/* Got an action command; disable terminal interrupts and return start state */
if|if
condition|(
operator|!
name|local
condition|)
name|connoi
argument_list|()
expr_stmt|;
comment|/* Interrupts off only if remote */
return|return
operator|(
name|sstate
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  D O E X I T  --  Exit from the program.  */
end_comment

begin_macro
name|doexit
argument_list|(
argument|exitstat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|exitstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ttclos
argument_list|()
expr_stmt|;
comment|/* Close external line, if any */
if|if
condition|(
name|local
condition|)
block|{
name|strcpy
argument_list|(
name|ttname
argument_list|,
name|dftty
argument_list|)
expr_stmt|;
comment|/* Restore default tty */
name|local
operator|=
name|dfloc
expr_stmt|;
comment|/* And default remote/local status */
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|conres
argument_list|()
expr_stmt|;
comment|/* Restore console terminal. */
if|if
condition|(
operator|!
name|quiet
condition|)
name|connoi
argument_list|()
expr_stmt|;
comment|/* Turn off console interrupt traps. */
if|if
condition|(
name|deblog
condition|)
block|{
comment|/* Close any open logs. */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"Debug Log Closed"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|debfil
operator|=
literal|'\0'
expr_stmt|;
name|deblog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZDFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pktlog
condition|)
block|{
operator|*
name|pktfil
operator|=
literal|'\0'
expr_stmt|;
name|pktlog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZPFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seslog
condition|)
block|{
operator|*
name|sesfil
operator|=
literal|'\0'
expr_stmt|;
name|seslog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZSFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tralog
condition|)
block|{
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Transaction Log Closed"
argument_list|,
literal|""
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
operator|*
name|trafil
operator|=
literal|'\0'
expr_stmt|;
name|tralog
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZTFILE
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
comment|/* Exit from the program. */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  B L D L E N  --  Make length-encoded copy of string  */
end_comment

begin_function
name|char
modifier|*
name|bldlen
parameter_list|(
name|str
parameter_list|,
name|dest
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|tochar
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dest
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|+
name|len
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  S E T G E N  --  Construct a generic command  */
end_comment

begin_macro
name|setgen
argument_list|(
argument|type
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|)
end_macro

begin_decl_stmt
name|char
name|type
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|upstr
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|cmdstr
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|type
expr_stmt|;
operator|*
name|cp
operator|=
name|NUL
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|!=
name|NUL
condition|)
block|{
name|upstr
operator|=
name|bldlen
argument_list|(
name|arg1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg2
operator|!=
name|NUL
condition|)
block|{
name|upstr
operator|=
name|bldlen
argument_list|(
name|arg2
argument_list|,
name|upstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg3
operator|!=
name|NUL
condition|)
name|bldlen
argument_list|(
name|arg3
argument_list|,
name|upstr
argument_list|)
expr_stmt|;
block|}
block|}
name|cmarg
operator|=
name|cmdstr
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"setgen"
argument_list|,
name|cmarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'g'
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  D O C M D  --  Do a command  */
end_comment

begin_comment
comment|/*  Returns:    -2: user typed an illegal command    -1: reparse needed     0: parse was successful (even tho command may have failed). */
end_comment

begin_macro
name|docmd
argument_list|(
argument|cx
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|cx
condition|)
block|{
case|case
operator|-
literal|4
case|:
comment|/* EOF */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
case|case
operator|-
literal|3
case|:
comment|/* Null command */
return|return
operator|(
literal|0
operator|)
return|;
case|case
operator|-
literal|2
case|:
comment|/* Error */
case|case
operator|-
literal|1
case|:
comment|/* Reparse needed */
return|return
operator|(
name|cx
operator|)
return|;
case|case
name|XXBYE
case|:
comment|/* bye */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"You have to 'set line' first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sstate
operator|=
name|setgen
argument_list|(
literal|'L'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXCOM
case|:
comment|/* comment */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Text of comment line"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXCON
case|:
comment|/* connect */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|doconect
argument_list|()
operator|)
return|;
case|case
name|XXCWD
case|:
if|if
condition|(
name|cmtxt
argument_list|(
literal|"Name of local directory, or carriage return"
argument_list|,
name|homdir
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|chdir
argument_list|(
name|s
argument_list|)
condition|)
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cwdf
operator|=
literal|1
expr_stmt|;
name|system
argument_list|(
name|PWDCMD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXCLO
case|:
name|x
operator|=
name|cmkey
argument_list|(
name|logtab
argument_list|,
name|nlog
argument_list|,
literal|"Which log to close"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must tell which log\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|LOGD
case|:
if|if
condition|(
name|deblog
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Debugging log wasn't open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|debfil
operator|=
literal|'\0'
expr_stmt|;
name|deblog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|zclose
argument_list|(
name|ZDFILE
argument_list|)
operator|)
return|;
case|case
name|LOGP
case|:
if|if
condition|(
name|pktlog
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Packet log wasn't open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|pktfil
operator|=
literal|'\0'
expr_stmt|;
name|pktlog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|zclose
argument_list|(
name|ZPFILE
argument_list|)
operator|)
return|;
case|case
name|LOGS
case|:
if|if
condition|(
name|seslog
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Session log wasn't open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|sesfil
operator|=
literal|'\0'
expr_stmt|;
name|seslog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|zclose
argument_list|(
name|ZSFILE
argument_list|)
operator|)
return|;
case|case
name|LOGT
case|:
if|if
condition|(
name|tralog
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Transaction log wasn't open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|trafil
operator|=
literal|'\0'
expr_stmt|;
name|tralog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|zclose
argument_list|(
name|ZTFILE
argument_list|)
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"\n?Unexpected log designator - %ld\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|XXDIAL
case|:
comment|/* dial number */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Number to be dialed"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|dial
argument_list|(
name|s
argument_list|)
operator|)
return|;
case|case
name|XXDIR
case|:
comment|/* directory */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Directory/file specification"
argument_list|,
literal|"."
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|lp
operator|=
name|line
expr_stmt|;
name|sprintf
argument_list|(
name|lp
argument_list|,
literal|"%s %s"
argument_list|,
name|DIRCMD
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXECH
case|:
comment|/* echo */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Material to be echoed"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
operator|*
name|s
operator|)
operator|==
literal|0134
condition|)
block|{
comment|/* Convert octal escapes */
name|s
operator|++
expr_stmt|;
comment|/* up to 3 digits */
for|for
control|(
name|x
operator|=
name|y
operator|=
literal|0
init|;
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
operator|&&
name|y
operator|<
literal|3
condition|;
name|s
operator|++
operator|,
name|y
operator|++
control|)
block|{
name|x
operator|=
name|x
operator|*
literal|8
operator|+
operator|(
name|int
operator|)
operator|*
name|s
operator|-
literal|48
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
block|}
name|putchar
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXQUI
case|:
comment|/* quit, exit */
case|case
name|XXEXI
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|>
operator|-
literal|1
condition|)
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|x
operator|)
return|;
case|case
name|XXFIN
case|:
comment|/* finish */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"You have to 'set line' first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sstate
operator|=
name|setgen
argument_list|(
literal|'F'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXGET
case|:
comment|/* get */
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"\nYou have to 'set line' first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name of remote file(s), or carriage return"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|==
operator|-
literal|2
operator|)
operator|||
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* If foreign file name omitted, get foreign and local names separately */
if|if
condition|(
operator|*
name|cmarg
operator|==
name|NUL
condition|)
block|{
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Input is from take file */
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|100
argument_list|,
name|tfile
index|[
name|tlevel
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"take file ends prematurely in 'get'"
argument_list|)
expr_stmt|;
name|stripq
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|cmarg
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|cmdbuf
argument_list|,
name|CMDBL
argument_list|,
name|tfile
index|[
name|tlevel
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"take file ends prematurely in 'get'"
argument_list|)
expr_stmt|;
name|stripq
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cmdbuf
operator|==
name|NUL
condition|)
name|cmarg2
operator|=
name|line
expr_stmt|;
else|else
name|cmarg2
operator|=
name|cmdbuf
expr_stmt|;
block|}
else|else
block|{
comment|/* Input is from terminal */
name|char
name|psave
index|[
literal|40
index|]
decl_stmt|;
comment|/* Save old prompt */
name|cmsavp
argument_list|(
name|psave
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|cmsetp
argument_list|(
literal|" Remote file specification: "
argument_list|)
expr_stmt|;
comment|/* Make new one */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
name|x
operator|=
operator|-
literal|1
expr_stmt|;
name|prompt
argument_list|()
expr_stmt|;
while|while
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Prompt till they answer */
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name of remote file(s)"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" cmtxt"
argument_list|,
name|cmarg
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cmarg
operator|==
name|NUL
condition|)
block|{
comment|/* If user types a bare CR, */
name|printf
argument_list|(
literal|"(cancelled)\n"
argument_list|)
expr_stmt|;
comment|/* Forget about this. */
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore old prompt, */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* and return. */
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|cmarg
argument_list|)
expr_stmt|;
comment|/* Make a safe copy */
name|cmarg
operator|=
name|line
expr_stmt|;
name|cmsetp
argument_list|(
literal|" Local name to store it under: "
argument_list|)
expr_stmt|;
comment|/* New prompt */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
name|x
operator|=
operator|-
literal|1
expr_stmt|;
name|prompt
argument_list|()
expr_stmt|;
comment|/* Prompt */
while|while
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Again, parse till answered */
name|x
operator|=
name|cmofi
argument_list|(
literal|"Local file name"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|2
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
comment|/* If bare CR, */
name|printf
argument_list|(
literal|"(cancelled)\n"
argument_list|)
expr_stmt|;
comment|/* escape from this... */
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* restore old prompt, */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* and return. */
block|}
block|}
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore old prompt. */
if|if
condition|(
operator|(
name|x
operator|==
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
name|sstate
operator|=
literal|'r'
expr_stmt|;
comment|/* All ok, set start state. */
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXHLP
case|:
comment|/* Help */
name|x
operator|=
name|cmkey
argument_list|(
name|cmdtab
argument_list|,
name|ncmd
argument_list|,
literal|"C-Kermit command"
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dohlp
argument_list|(
name|x
argument_list|)
operator|)
return|;
case|case
name|XXLOG
case|:
comment|/* Log */
name|x
operator|=
name|cmkey
argument_list|(
name|logtab
argument_list|,
name|nlog
argument_list|,
literal|"What to log"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must specify what is to be logged\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|dolog
argument_list|(
name|x
argument_list|)
operator|)
return|;
case|case
name|XXLOGI
case|:
comment|/* Send script remote system */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Text of login script"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|login
argument_list|(
name|s
argument_list|)
operator|)
return|;
comment|/* Return 0=completed, -2=failed */
case|case
name|XXREC
case|:
comment|/* Receive */
name|cmarg2
operator|=
literal|""
expr_stmt|;
name|x
operator|=
name|cmofi
argument_list|(
literal|"Name under which to store the file, or CR"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|x
operator|==
operator|-
literal|2
operator|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"cmofi cmarg2"
argument_list|,
name|cmarg2
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
literal|'v'
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXREM
case|:
comment|/* Remote */
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"\nYou have to 'set line' first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|x
operator|=
name|cmkey
argument_list|(
name|remcmd
argument_list|,
name|nrmt
argument_list|,
literal|"Remote Kermit server command"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must specify a command for the remote server\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|dormt
argument_list|(
name|x
argument_list|)
operator|)
return|;
case|case
name|XXSEN
case|:
comment|/* Send */
name|cmarg
operator|=
name|cmarg2
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File(s) to send"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?A file specification is required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
name|nfils
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Files come from internal list. */
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Save copy of string just parsed. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"Send: wild"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|cmarg2
operator|=
literal|'\0'
expr_stmt|;
comment|/* Initialize send-as name */
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name to send it with"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg2
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
name|cmarg
operator|=
name|line
expr_stmt|;
comment|/* File to send */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Sending:"
argument_list|,
name|cmarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cmarg2
operator|!=
literal|'\0'
condition|)
name|debug
argument_list|(
name|F110
argument_list|,
literal|" as:"
argument_list|,
name|cmarg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sstate
operator|=
literal|'s'
expr_stmt|;
comment|/* Set start state */
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXSER
case|:
comment|/* Server */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|sstate
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXSET
case|:
comment|/* Set */
name|x
operator|=
name|cmkey
argument_list|(
name|prmtab
argument_list|,
name|nprm
argument_list|,
literal|"Parameter"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?You must specify a parameter to set\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
return|return
operator|(
name|doprm
argument_list|(
name|x
argument_list|)
operator|)
return|;
comment|/* XXSHE code by H. Fischer; copyright rights assigned to Columbia Univ */
comment|/*  Adapted to use getpwuid to find login shell because many systems do not  have SHELL in environment, and to use direct calling of shell rather  than intermediate system() call. -- H. Fischer */
case|case
name|XXSHE
case|:
comment|/* Local shell command */
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|cmtxt
argument_list|(
literal|"Unix shell command to execute"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|conres
argument_list|()
expr_stmt|;
comment|/* Make console normal  */
ifdef|#
directive|ifdef
name|MSDOS
name|zxcmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|vax11c
name|system
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Best we can do for VMS? */
else|#
directive|else
comment|/* All Unix systems... */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Make child */
name|char
modifier|*
name|shpath
decl_stmt|,
modifier|*
name|shname
decl_stmt|,
modifier|*
name|shptr
decl_stmt|;
comment|/* For finding desired shell */
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
specifier|extern
name|int
name|getuid
parameter_list|()
function_decl|;
name|char
modifier|*
name|defShel
init|=
literal|"/bin/sh"
decl_stmt|;
comment|/* Default */
name|p
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Get login data */
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|NULL
operator|||
operator|!
operator|*
operator|(
name|p
operator|->
name|pw_shell
operator|)
condition|)
name|shpath
operator|=
name|defShel
expr_stmt|;
else|else
name|shpath
operator|=
name|p
operator|->
name|pw_shell
expr_stmt|;
name|shptr
operator|=
name|shname
operator|=
name|shpath
expr_stmt|;
while|while
condition|(
operator|*
name|shptr
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|*
name|shptr
operator|++
operator|==
literal|'/'
condition|)
name|shname
operator|=
name|shptr
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
comment|/* Interactive shell requested? */
name|execl
argument_list|(
name|shpath
argument_list|,
name|shname
argument_list|,
literal|"-i"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes, do that */
else|else
comment|/* Otherwise, */
name|execl
argument_list|(
name|shpath
argument_list|,
name|shname
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* exec the given command */
name|exit
argument_list|(
name|GOOD_EXIT
argument_list|)
expr_stmt|;
block|}
comment|/* Just punt if it didnt work */
else|else
block|{
comment|/* Parent */
name|int
name|wstat
decl_stmt|;
comment|/* Kermit must wait for child */
name|int
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Let the fork handle keyboard */
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* interrupts itself... */
while|while
condition|(
operator|(
operator|(
name|wstat
operator|=
name|wait
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|pid
operator|)
operator|&&
operator|(
name|wstat
operator|!=
operator|-
literal|1
operator|)
condition|)
comment|/* Wait for fork */
empty_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
comment|/* Restore interrupts */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|concb
argument_list|(
name|escape
argument_list|)
expr_stmt|;
comment|/* Console back in cbreak mode */
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|XXSHO
case|:
comment|/* Show */
name|x
operator|=
name|cmkey
argument_list|(
name|shotab
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
literal|"parameters"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|y
operator|=
operator|(
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|SHPAR
case|:
name|shopar
argument_list|()
expr_stmt|;
break|break;
case|case
name|SHVER
case|:
name|printf
argument_list|(
literal|"\nVersions:\n %s\n %s\n"
argument_list|,
name|versio
argument_list|,
name|protv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|fnsv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n %s\n %s for%s\n"
argument_list|,
name|cmdv
argument_list|,
name|userv
argument_list|,
name|ckxv
argument_list|,
name|ckxsys
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s for%s\n %s\n"
argument_list|,
name|ckzv
argument_list|,
name|ckzsys
argument_list|,
name|connv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n %s\n\n"
argument_list|,
name|dialv
argument_list|,
name|loginv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\nNothing to show...\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXSPA
case|:
comment|/* space */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|system
argument_list|(
name|SPACMD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXSTA
case|:
comment|/* statistics */
if|if
condition|(
operator|(
name|x
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|printf
argument_list|(
literal|"\nMost recent transaction --\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" files: %ld\n"
argument_list|,
name|filcnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" total file characters  : %ld\n"
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" communication line in  : %ld\n"
argument_list|,
name|tlci
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" communication line out : %ld\n"
argument_list|,
name|tlco
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" elapsed time           : %d sec\n"
argument_list|,
name|tsecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|filcnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tsecs
operator|>
literal|0
condition|)
block|{
name|long
name|lx
decl_stmt|;
name|lx
operator|=
operator|(
name|tfc
operator|/
name|tsecs
operator|)
operator|*
literal|10
expr_stmt|;
name|printf
argument_list|(
literal|" effective baud rate    : %ld\n"
argument_list|,
name|lx
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|0
condition|)
block|{
name|lx
operator|=
operator|(
name|lx
operator|*
literal|100
operator|)
operator|/
name|speed
expr_stmt|;
name|printf
argument_list|(
literal|" efficiency             : %ld %%\n"
argument_list|,
name|lx
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|" block check type used  : %d\n"
argument_list|,
name|bctu
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" compression            : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptflg
condition|)
name|printf
argument_list|(
literal|"yes [%c]\n"
argument_list|,
name|rptq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 8th bit prefixing      : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebqflg
condition|)
name|printf
argument_list|(
literal|"yes [%c]\n"
argument_list|,
name|ebq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXTAK
case|:
comment|/* take */
if|if
condition|(
name|tlevel
operator|>
name|MAXTAKE
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?Take files nested too deeply\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmifi
argument_list|(
literal|"C-Kermit command file"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|x
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?A file specification is required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Wildcards not allowed in command file name\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a safe copy of the string */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|tfile
index|[
operator|++
name|tlevel
index|]
operator|=
name|fopen
argument_list|(
name|line
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Failure to open"
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlevel
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"Not available - %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  S H O P A R  --  Show Parameters  */
end_comment

begin_macro
name|shopar
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|extern
name|struct
name|keytab
name|mdmtab
index|[]
decl_stmt|;
specifier|extern
name|int
name|nmdm
decl_stmt|;
name|puts
argument_list|(
literal|"\nCommunications Parameters:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Line: %s, speed: %d, mode: "
argument_list|,
name|ttname
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|printf
argument_list|(
literal|"local"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"remote"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmdm
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mdmtab
index|[
name|i
index|]
operator|.
name|val
operator|==
name|mdmtyp
condition|)
block|{
name|printf
argument_list|(
literal|", modem-dialer: %s"
argument_list|,
name|mdmtab
index|[
name|i
index|]
operator|.
name|kwd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"\n Parity: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|parity
condition|)
block|{
case|case
literal|'e'
case|:
name|printf
argument_list|(
literal|"even"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|printf
argument_list|(
literal|"odd"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|printf
argument_list|(
literal|"mark"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|printf
argument_list|(
literal|"space"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"invalid - %d"
argument_list|,
name|parity
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|", duplex: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplex
condition|)
name|printf
argument_list|(
literal|"half, "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"full, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flow: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"xon/xoff"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flow
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|flow
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", handshake: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|turn
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|turnch
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nProtocol Parameters:   Send    Receive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|timef
operator|||
name|spsizf
condition|)
name|printf
argument_list|(
literal|"    (* = override)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n Timeout:      %11d%9d"
argument_list|,
name|rtimo
argument_list|,
name|timint
argument_list|)
expr_stmt|;
if|if
condition|(
name|timef
condition|)
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n Padding:      %11d%9d\n"
argument_list|,
name|npad
argument_list|,
name|mypadn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Pad Character:%11d%9d\n"
argument_list|,
name|padch
argument_list|,
name|mypadc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Packet Start: %11d%9d\n"
argument_list|,
name|mystch
argument_list|,
name|stchr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Packet End:   %11d%9d\n"
argument_list|,
name|seol
argument_list|,
name|eol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Packet Length:%11d"
argument_list|,
name|spsiz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|spsizf
condition|?
literal|"*"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8d\n"
argument_list|,
name|rpsiz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nBlock Check Type: %d, Delay: %d\n"
argument_list|,
name|bctr
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebqflg
condition|)
name|printf
argument_list|(
literal|"8th-Bit Prefix:      '%c'\n"
argument_list|,
name|ebq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptflg
condition|)
name|printf
argument_list|(
literal|"Repeat-Count Prefix: '%c'\n"
argument_list|,
name|rptq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nFile parameters:\n File Names:   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fncnv
condition|)
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"converted"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"literal"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"   Debugging Log:    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|deblog
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|debfil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n File Type:    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary
condition|)
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Packet Log:       "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlog
condition|)
name|printf
argument_list|(
name|pktfil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n File Warning: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn
condition|)
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"on"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   Session Log:      "
argument_list|)
expr_stmt|;
if|if
condition|(
name|seslog
condition|)
name|printf
argument_list|(
name|sesfil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n File Display: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"off"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"on"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TLOG
name|printf
argument_list|(
literal|"   Transaction Log:  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tralog
condition|)
name|printf
argument_list|(
name|trafil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n\nIncomplete File Disposition: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
condition|)
name|printf
argument_list|(
literal|"keep"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"discard"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERMRC
name|printf
argument_list|(
literal|", Init file: %s"
argument_list|,
name|KERMRC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|puts
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  D O C O N E C T  --  Do the connect command  */
end_comment

begin_comment
comment|/*  Note, we don't call this directly from dial, because we need to give */
end_comment

begin_comment
comment|/*  the user a chance to change parameters (e.g. parity) after the */
end_comment

begin_comment
comment|/*  connection is made. */
end_comment

begin_macro
name|doconect
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|;
name|conres
argument_list|()
expr_stmt|;
comment|/* Put console back to normal */
name|x
operator|=
name|conect
argument_list|()
expr_stmt|;
comment|/* Connect */
name|concb
argument_list|(
name|escape
argument_list|)
expr_stmt|;
comment|/* Put console into cbreak mode, */
return|return
operator|(
name|x
operator|)
return|;
comment|/* for more command parsing. */
block|}
end_block

begin_comment
comment|/*  D O L O G  --  Do the log command  */
end_comment

begin_macro
name|dolog
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|y
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|LOGD
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of debugging log file"
argument_list|,
literal|"debug.log"
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|y
operator|=
operator|-
literal|2
expr_stmt|;
name|s
operator|=
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"- Sorry, debug log not available\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LOGP
case|:
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of packet log file"
argument_list|,
literal|"packet.log"
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOGS
case|:
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of session log file"
argument_list|,
literal|"session.log"
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOGT
case|:
ifdef|#
directive|ifdef
name|TLOG
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of transaction log file"
argument_list|,
literal|"transact.log"
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|y
operator|=
operator|-
literal|2
expr_stmt|;
name|s
operator|=
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"- Sorry, transaction log not available\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|printf
argument_list|(
literal|"\n?Unexpected log designator - %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* cont'd... */
comment|/* ...dolog, cont'd */
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|LOGD
case|:
return|return
operator|(
name|deblog
operator|=
name|debopn
argument_list|(
name|s
argument_list|)
operator|)
return|;
case|case
name|LOGP
case|:
name|zclose
argument_list|(
name|ZPFILE
argument_list|)
expr_stmt|;
name|y
operator|=
name|zopeno
argument_list|(
name|ZPFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|pktfil
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|pktfil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|pktlog
operator|=
name|y
operator|)
return|;
case|case
name|LOGS
case|:
name|zclose
argument_list|(
name|ZSFILE
argument_list|)
expr_stmt|;
name|y
operator|=
name|zopeno
argument_list|(
name|ZSFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|sesfil
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|sesfil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|seslog
operator|=
name|y
operator|)
return|;
case|case
name|LOGT
case|:
name|zclose
argument_list|(
name|ZTFILE
argument_list|)
expr_stmt|;
name|tralog
operator|=
name|zopeno
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tralog
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|trafil
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Transaction Log:"
argument_list|,
name|versio
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
name|ckxsys
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ztime
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|trafil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|tralog
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  D E B O P N  --  Open a debugging file  */
end_comment

begin_macro
name|debopn
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|char
modifier|*
name|tp
decl_stmt|;
name|zclose
argument_list|(
name|ZDFILE
argument_list|)
expr_stmt|;
name|deblog
operator|=
name|zopeno
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|deblog
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|debfil
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Debug Log "
argument_list|,
name|versio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F100
argument_list|,
name|ckxsys
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ztime
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F100
argument_list|,
name|tp
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|debfil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|deblog
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_block

end_unit

