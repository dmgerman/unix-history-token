begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* String search routines for GNU Emacs.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_decl_stmt
name|unsigned
name|char
name|downcase_table
index|[
literal|0400
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* folds upper to lower case */
end_comment

begin_comment
comment|/* We compile regexps into this buffer and then use it for searching. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|searchbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|search_fastmap
index|[
literal|0400
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last regexp we compiled */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_regexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Every call to re_match, etc., must pass&search_regs as the regs argument  unless you can show it is unnecessary (i.e., if re_match is certainly going  to be called again before region-around-match can be called).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_registers
name|search_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error condition signalled when regexp compile_pattern fails */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qinvalid_regexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compile a regexp and signal a Lisp error if anything goes wrong.  */
end_comment

begin_macro
name|compile_pattern
argument_list|(
argument|pattern
argument_list|,
argument|bufp
argument_list|,
argument|translate
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|translate
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|Lisp_Object
name|dummy
decl_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|pattern
argument_list|,
name|last_regexp
argument_list|)
operator|&&
name|translate
operator|==
name|bufp
operator|->
name|translate
condition|)
return|return;
name|last_regexp
operator|=
name|Qnil
expr_stmt|;
name|bufp
operator|->
name|translate
operator|=
name|translate
expr_stmt|;
name|val
operator|=
name|re_compile_pattern
argument_list|(
name|XSTRING
argument_list|(
name|pattern
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|pattern
argument_list|)
operator|->
name|size
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|dummy
operator|=
name|build_string
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Fcons
argument_list|(
name|dummy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last_regexp
operator|=
name|pattern
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* Error condition used for failing searches */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qsearch_failed
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|signal_failure
parameter_list|(
name|arg
parameter_list|)
name|Lisp_Object
name|arg
decl_stmt|;
block|{
name|Fsignal
argument_list|(
name|Qsearch_failed
argument_list|,
name|Fcons
argument_list|(
name|arg
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"looking-at"
argument_list|,
argument|Flooking_at
argument_list|,
argument|Slooking_at
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"t if text after point matches regular expression PAT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|)
name|Lisp_Object
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compile_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|searchbuf
argument_list|,
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|case_fold_search
argument_list|)
condition|?
operator|(
name|char
operator|*
operator|)
name|downcase_table
else|:
literal|0
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
comment|/* Do a pending quit right away, to avoid paradoxical behavior */
comment|/* Get pointers and sizes of the two strings      that make up the visible portion of the buffer. */
name|p1
operator|=
name|bf_p1
operator|+
name|bf_head_clip
expr_stmt|;
name|s1
operator|=
name|bf_s1
operator|-
operator|(
name|bf_head_clip
operator|-
literal|1
operator|)
expr_stmt|;
name|p2
operator|=
name|bf_p2
operator|+
name|bf_s1
operator|+
literal|1
expr_stmt|;
name|s2
operator|=
name|bf_s2
operator|-
name|bf_tail_clip
expr_stmt|;
if|if
condition|(
name|s1
operator|<
literal|0
condition|)
block|{
name|p2
operator|-=
name|s1
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|<
literal|0
condition|)
block|{
name|s1
operator|+=
name|s2
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
name|val
operator|=
operator|(
literal|0
operator|<=
name|re_match_2
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|,
name|point
operator|-
name|FirstCharacter
argument_list|,
operator|&
name|search_regs
argument_list|,
name|NumCharacters
operator|+
literal|1
operator|-
name|FirstCharacter
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|+=
name|FirstCharacter
operator|-
literal|1
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|+=
name|FirstCharacter
operator|-
literal|1
expr_stmt|;
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"string-match"
argument_list|,
argument|Fstring_match
argument_list|,
argument|Sstring_match
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Return index of start of first match for REGEXP in STRING, or nil.\n\ If third arg START is non-nil, start search at that index in STRING.\n\ For index of first char beyond the match, do (match-end 0).\n\ match-end and match-beginning also give indices of substrings\n\ matched by parenthesis constructs in the pattern."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|regexp
operator|,
name|string
operator|,
name|start
operator|)
name|Lisp_Object
name|regexp
operator|,
name|string
operator|,
name|start
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|regexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|start
argument_list|)
condition|)
name|s
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER
argument_list|(
name|start
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
name|compile_pattern
argument_list|(
name|regexp
argument_list|,
operator|&
name|searchbuf
argument_list|,
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|case_fold_search
argument_list|)
condition|?
operator|(
name|char
operator|*
operator|)
name|downcase_table
else|:
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|re_search
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|,
name|s
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|-
name|s
argument_list|,
operator|&
name|search_regs
argument_list|)
expr_stmt|;
comment|/* Correct for propensity of match-beginning and match-end      to add 1 to each of these (which is correct for buffer positions      since they are origin-1, but not for indices in strings).  */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|RE_NREGS
condition|;
name|s
operator|++
control|)
block|{
name|search_regs
operator|.
name|start
index|[
name|s
index|]
operator|--
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|s
index|]
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
return|return
name|make_number
argument_list|(
name|val
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"scan-buffer"
argument_list|,
argument|Fscan_buffer
argument_list|,
argument|Sscan_buffer
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Scan from character number FROM for COUNT occurrences of character C.\n\ Returns the character number of the position after the character found.\n\ If not found, returns char number of beginning or end of buffer.\n\ Note that this does -not- take take  case-fold-search  into consideration."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|from
operator|,
name|count
operator|,
name|c
operator|)
name|Lisp_Object
name|from
operator|,
name|count
operator|,
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|c
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|ScanBf
argument_list|(
name|XINT
argument_list|(
name|c
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|from
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|ScanBf
argument_list|(
name|target
argument_list|,
name|pos
argument_list|,
name|cnt
argument_list|)
specifier|register
name|int
name|target
operator|,
name|pos
operator|,
name|cnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|end
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|end
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|==
name|target
operator|&&
operator|!
operator|--
name|cnt
condition|)
return|return
name|pos
operator|+
literal|1
return|;
name|pos
operator|++
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
name|end
operator|=
name|FirstCharacter
expr_stmt|;
do|do
name|pos
operator|--
expr_stmt|;
do|while
condition|(
name|pos
operator|>=
name|end
operator|&&
operator|(
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|!=
name|target
operator|||
operator|++
name|cnt
operator|)
condition|)
do|;
block|}
return|return
name|pos
operator|+
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"skip-chars-forward"
argument_list|,
argument|Fskip_chars_forward
argument_list|,
argument|Sskip_chars_forward
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Move point forward, stopping before a char not in CHARS, or at position LIM.\n\ CHARS is like the inside of a [...] in a regular expression\n\ except that ] is never special and \\ quotes ^, - or \\.\n\ Thus, with arg \"a-zA-Z\", this skips letters stopping before first nonletter.\n\ With arg \"^a-zA-Z\", skips nonletters stopping before first letter."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|lim
operator|)
name|Lisp_Object
name|string
operator|,
name|lim
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|skip_chars
argument_list|(
literal|1
argument_list|,
name|string
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"skip-chars-backward"
argument_list|,
argument|Fskip_chars_backward
argument_list|,
argument|Sskip_chars_backward
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Move point backward, stopping after a char not in CHARS, or at position LIM.\n\ See skip-chars-forward for details."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|lim
operator|)
name|Lisp_Object
name|string
operator|,
name|lim
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|skip_chars
argument_list|(
literal|0
argument_list|,
name|string
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|skip_chars
argument_list|(
argument|forwardp
argument_list|,
argument|string
argument_list|,
argument|lim
argument_list|)
end_macro

begin_decl_stmt
name|int
name|forwardp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|string
decl_stmt|,
name|lim
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|fastmap
index|[
literal|0400
index|]
decl_stmt|;
name|int
name|negate
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|lim
argument_list|)
condition|)
name|XSETINT
argument_list|(
name|lim
argument_list|,
name|forwardp
condition|?
name|NumCharacters
operator|+
literal|1
else|:
name|FirstCharacter
argument_list|)
expr_stmt|;
else|else
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|lim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
expr_stmt|;
name|bzero
argument_list|(
name|fastmap
argument_list|,
sizeof|sizeof
name|fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|pend
operator|&&
operator|*
name|p
operator|==
literal|'^'
condition|)
block|{
name|negate
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Find the characters specified and set their elements of fastmap.  */
while|while
condition|(
name|p
operator|!=
name|pend
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|pend
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
while|while
condition|(
name|c
operator|<=
operator|*
name|p
condition|)
block|{
name|fastmap
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
else|else
name|fastmap
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If ^ was the first character, complement the fastmap. */
if|if
condition|(
name|negate
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|fastmap
condition|;
name|i
operator|++
control|)
name|fastmap
index|[
name|i
index|]
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|forwardp
condition|)
block|{
while|while
condition|(
name|point
operator|<
name|XINT
argument_list|(
name|lim
argument_list|)
operator|&&
name|fastmap
index|[
name|CharAt
argument_list|(
name|point
argument_list|)
index|]
condition|)
name|PointRight
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|point
operator|>
name|XINT
argument_list|(
name|lim
argument_list|)
operator|&&
name|fastmap
index|[
name|CharAt
argument_list|(
name|point
operator|-
literal|1
argument_list|)
index|]
condition|)
name|PointLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Subroutines of Lisp buffer search functions. */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|search_command
parameter_list|(
name|string
parameter_list|,
name|bound
parameter_list|,
name|noerror
parameter_list|,
name|count
parameter_list|,
name|direction
parameter_list|,
name|RE
parameter_list|)
name|Lisp_Object
name|string
decl_stmt|,
name|bound
decl_stmt|,
name|noerror
decl_stmt|,
name|count
decl_stmt|;
name|int
name|direction
decl_stmt|;
name|int
name|RE
decl_stmt|;
block|{
specifier|register
name|int
name|np
decl_stmt|;
name|int
name|lim
decl_stmt|;
name|int
name|n
init|=
name|direction
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|count
argument_list|)
condition|)
block|{
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|n
operator|*=
name|XINT
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bound
argument_list|)
condition|)
name|lim
operator|=
name|n
operator|>
literal|0
condition|?
name|NumCharacters
operator|+
literal|1
else|:
name|FirstCharacter
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|bound
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lim
operator|=
name|XINT
argument_list|(
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|?
name|lim
operator|<
name|point
else|:
name|lim
operator|>
name|point
condition|)
name|error
argument_list|(
literal|"Invalid search bound (wrong side of point)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|lim
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lim
operator|<
name|FirstCharacter
condition|)
name|lim
operator|=
name|FirstCharacter
expr_stmt|;
block|}
name|np
operator|=
name|search_buffer
argument_list|(
name|string
argument_list|,
name|point
argument_list|,
name|lim
argument_list|,
name|n
argument_list|,
name|RE
argument_list|,
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|case_fold_search
argument_list|)
condition|?
name|downcase_table
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|noerror
argument_list|)
condition|)
return|return
name|signal_failure
argument_list|(
name|string
argument_list|)
return|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|noerror
argument_list|,
name|Qt
argument_list|)
condition|)
name|SetPoint
argument_list|(
name|lim
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
else|else
name|SetPoint
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_function

begin_comment
comment|/* search for the n'th occurrence of `string' in the current buffer,    starting at position `from' and stopping at position `lim',    treating `pat' as a literal string if `RE' is false or as    a regular expression if `RE' is true.     If `n' is positive, searching is forward and `lim' must be greater than `from'.    If `n' is negative, searching is backward and `lim' must be less than `from'.     Returns 0 if `n' occurrences are not found,    or else the position at the beginning of the `n'th occurrence (if searching backward)    or the end (if searching forward).  */
end_comment

begin_macro
name|search_buffer
argument_list|(
argument|string
argument_list|,
argument|from
argument_list|,
argument|lim
argument_list|,
argument|n
argument_list|,
argument|RE
argument_list|,
argument|trt
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|lim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|RE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|trt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|pos
init|=
name|from
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pat
init|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Quit immediately if user types ^G, 			   because letting this function finish can take too long. */
name|QUIT
expr_stmt|;
comment|/* Do a pending quit right away, to avoid paradoxical behavior */
if|if
condition|(
name|RE
condition|)
block|{
name|compile_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|searchbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|trt
argument_list|)
expr_stmt|;
comment|/* Get pointers and sizes of the two strings 	 that make up the visible portion of the buffer. */
name|p1
operator|=
name|bf_p1
operator|+
name|bf_head_clip
expr_stmt|;
name|s1
operator|=
name|bf_s1
operator|-
operator|(
name|bf_head_clip
operator|-
literal|1
operator|)
expr_stmt|;
name|p2
operator|=
name|bf_p2
operator|+
name|bf_s1
operator|+
literal|1
expr_stmt|;
name|s2
operator|=
name|bf_s2
operator|-
name|bf_tail_clip
expr_stmt|;
if|if
condition|(
name|s1
operator|<
literal|0
condition|)
block|{
name|p2
operator|-=
name|s1
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|<
literal|0
condition|)
block|{
name|s1
operator|+=
name|s2
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|RE
condition|)
block|{
name|pos
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|trt
operator|&&
operator|!
operator|(
name|trt
operator|==
name|downcase_table
operator|&&
operator|!
name|isalpha
argument_list|(
name|pat
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|j
operator|=
name|trt
index|[
name|pat
index|[
literal|0
index|]
index|]
expr_stmt|;
while|while
condition|(
name|pos
operator|>=
name|lim
operator|&&
operator|(
name|j
operator|!=
name|trt
index|[
name|CharAt
argument_list|(
name|pos
argument_list|)
index|]
operator|||
name|bcmp_buffer_translated
argument_list|(
name|pat
argument_list|,
name|len
argument_list|,
name|pos
argument_list|,
name|trt
argument_list|)
operator|)
condition|)
name|pos
operator|--
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|pat
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|pos
operator|>=
name|lim
operator|&&
operator|(
name|j
operator|!=
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|||
name|bcmp_buffer_translated
argument_list|(
name|pat
argument_list|,
name|len
argument_list|,
name|pos
argument_list|,
name|trt
argument_list|)
operator|)
condition|)
name|pos
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
name|lim
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|=
name|pos
operator|-
literal|1
operator|+
name|len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|re_search_2
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|,
name|pos
operator|-
name|FirstCharacter
argument_list|,
name|lim
operator|-
name|pos
argument_list|,
operator|&
name|search_regs
argument_list|,
comment|/* Don't allow match past current point */
name|pos
operator|-
name|FirstCharacter
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|j
operator|=
name|FirstCharacter
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
block|}
comment|/* Set pos to the new position. */
name|pos
operator|=
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|n
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|RE
condition|)
block|{
name|lim
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|trt
operator|&&
operator|!
operator|(
name|trt
operator|==
name|downcase_table
operator|&&
operator|!
name|isalpha
argument_list|(
name|pat
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|j
operator|=
name|trt
index|[
name|pat
index|[
literal|0
index|]
index|]
expr_stmt|;
while|while
condition|(
name|pos
operator|<=
name|lim
operator|&&
operator|(
name|j
operator|!=
name|trt
index|[
name|CharAt
argument_list|(
name|pos
argument_list|)
index|]
operator|||
name|bcmp_buffer_translated
argument_list|(
name|pat
argument_list|,
name|len
argument_list|,
name|pos
argument_list|,
name|trt
argument_list|)
operator|)
condition|)
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|pat
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|pos
operator|<=
name|lim
operator|&&
operator|(
name|j
operator|!=
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|||
name|bcmp_buffer_translated
argument_list|(
name|pat
argument_list|,
name|len
argument_list|,
name|pos
argument_list|,
name|trt
argument_list|)
operator|)
condition|)
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
name|lim
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lim
operator|+=
name|len
expr_stmt|;
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|re_search_2
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|,
name|pos
operator|-
name|FirstCharacter
argument_list|,
name|lim
operator|-
name|pos
argument_list|,
operator|&
name|search_regs
argument_list|,
name|lim
operator|-
name|FirstCharacter
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|j
operator|=
name|FirstCharacter
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
block|}
name|pos
operator|=
literal|1
operator|+
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|n
operator|--
expr_stmt|;
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
name|pos
return|;
block|}
end_block

begin_comment
comment|/* Return nonzero unless the `len' characters in the buffer starting at position `pos'   match the `len' characters at `pat', with all characters going through the   translate table `trt' if `trt' is nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|bcmp_buffer_translated
parameter_list|(
name|pat
parameter_list|,
name|len
parameter_list|,
name|pos
parameter_list|,
name|trt
parameter_list|)
name|unsigned
name|char
modifier|*
name|pat
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|trt
decl_stmt|;
block|{
name|int
name|dist1
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|pos
operator|-
literal|1
operator|<
name|bf_s1
condition|)
block|{
name|p1
operator|=
name|pat
operator|,
name|p2
operator|=
operator|&
name|CharAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|dist1
operator|=
name|bf_s1
operator|-
operator|(
name|pos
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|dist1
operator|>
name|len
condition|)
name|dist1
operator|=
name|len
expr_stmt|;
name|i
operator|=
name|dist1
expr_stmt|;
if|if
condition|(
name|trt
condition|)
block|{
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|trt
index|[
operator|*
name|p1
operator|++
index|]
operator|!=
name|trt
index|[
operator|*
name|p2
operator|++
index|]
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|dist1
operator|<
name|len
condition|)
block|{
name|p1
operator|=
name|pat
operator|+
name|dist1
operator|,
name|p2
operator|=
operator|&
name|CharAt
argument_list|(
name|pos
operator|+
name|dist1
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
operator|-
name|dist1
expr_stmt|;
if|if
condition|(
name|trt
condition|)
block|{
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|trt
index|[
operator|*
name|p1
operator|++
index|]
operator|!=
name|trt
index|[
operator|*
name|p2
operator|++
index|]
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a string of words separated by word delimiters,   compute a regexp that matches those exact words   separated by arbitrary punctuation.  */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|wordify
parameter_list|(
name|string
parameter_list|)
name|Lisp_Object
name|string
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|o
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|punct_count
init|=
literal|0
decl_stmt|,
name|word_count
init|=
literal|0
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|!=
name|Sword
condition|)
block|{
name|punct_count
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|SYNTAX
argument_list|(
name|p
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
condition|)
name|word_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|SYNTAX
argument_list|(
name|p
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
condition|)
name|word_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|word_count
condition|)
return|return
name|build_string
argument_list|(
literal|""
argument_list|)
return|;
name|val
operator|=
name|make_string
argument_list|(
name|p
argument_list|,
name|len
operator|-
name|punct_count
operator|+
literal|5
operator|*
operator|(
name|word_count
operator|-
literal|1
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|o
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'b'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|==
name|Sword
condition|)
operator|*
name|o
operator|++
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|SYNTAX
argument_list|(
name|p
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
operator|&&
operator|--
name|word_count
condition|)
block|{
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'W'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'W'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'b'
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"search-backward"
argument_list|,
argument|Fsearch_backward
argument_list|,
argument|Ssearch_backward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sSearch backward: "
argument_list|,
literal|"Search backward from point for STRING.\n\ Set point to the beginning of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend before that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\  If not nil and not t, position at limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"search-forward"
argument_list|,
argument|Fsearch_forward
argument_list|,
argument|Ssearch_forward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sSearch: "
argument_list|,
literal|"Search forward from point for STRING.\n\ Set point to the end of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend after that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"word-search-backward"
argument_list|,
argument|Fword_search_backward
argument_list|,
argument|Sword_search_backward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sWord search backward: "
argument_list|,
literal|"Search backward from point for STRING, ignoring differences in punctuation.\n\ Set point to the beginning of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend before that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|wordify
argument_list|(
name|string
argument_list|)
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"word-search-forward"
argument_list|,
argument|Fword_search_forward
argument_list|,
argument|Sword_search_forward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sWord search: "
argument_list|,
literal|"Search forward from point for STRING, ignoring differences in punctuation.\n\ Set point to the end of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend after that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|wordify
argument_list|(
name|string
argument_list|)
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"re-search-backward"
argument_list|,
argument|Fre_search_backward
argument_list|,
argument|Sre_search_backward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sRE search backward: "
argument_list|,
literal|"Search backward from point for regular expression REGEXP.\n\ Set point to the beginning of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend before that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences.\n\ See also the functions match-beginning and match-end and replace-match."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"re-search-forward"
argument_list|,
argument|Fre_search_forward
argument_list|,
argument|Sre_search_forward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sRE search: "
argument_list|,
literal|"Search forward from point for regular expression REGEXP.\n\ Set point to the end of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend after that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences.\n\ See also the functions match-beginning and match-end and replace-match."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"replace-match"
argument_list|,
argument|Freplace_match
argument_list|,
argument|Sreplace_match
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Replace text matched by last search with NEWTEXT.\n\ If second arg FIXEDCASE is non-nil, do not alter case of replacement text.\n\ Otherwise convert to all caps or cap initials, like replaced text.\n\ If third arg LITERAL is non-nil, insert NEWTEXT literally.\n\ Otherwise treat \\ as special:\n\   \\& in NEWTEXT means substitute original matched text,\n\   \\<n> means substitute match for \\(...\\) number<n>,\n\   \\\\ means insert one \\.\n\ Leaves point at end of replacement text."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|fixedcase
operator|,
name|literal
operator|)
name|Lisp_Object
name|string
operator|,
name|fixedcase
operator|,
name|literal
expr_stmt|;
end_expr_stmt

begin_block
block|{
enum|enum
block|{
name|nochange
block|,
name|all_caps
block|,
name|cap_initial
block|}
name|case_action
init|=
name|nochange
enum|;
specifier|register
name|int
name|pos
decl_stmt|,
name|last
decl_stmt|;
name|int
name|some_multiletter_word
init|=
literal|0
decl_stmt|;
name|int
name|some_letter
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|prevc
decl_stmt|;
name|int
name|inslen
decl_stmt|;
if|if
condition|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|+
literal|1
operator|<
name|FirstCharacter
operator|||
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|>
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|||
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|>
name|NumCharacters
condition|)
name|args_out_of_range
argument_list|(
name|make_number
argument_list|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|fixedcase
argument_list|)
condition|)
block|{
comment|/* Decide how to casify by examining the matched text. */
name|last
operator|=
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
name|prevc
operator|=
literal|'\n'
expr_stmt|;
name|case_action
operator|=
name|all_caps
expr_stmt|;
comment|/* some_multiletter_word is set nonzero if any original word 	 is more than one letter long. */
name|some_multiletter_word
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|+
literal|1
init|;
name|pos
operator|<=
name|last
condition|;
name|pos
operator|++
control|)
block|{
name|c
operator|=
name|CharAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
block|{
comment|/* Cannot be all caps if any original char is lower case */
name|case_action
operator|=
name|cap_initial
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|prevc
argument_list|)
operator|!=
name|Sword
condition|)
block|{
comment|/* Cannot even be cap initials 		     if some original initial is lower case */
name|case_action
operator|=
name|nochange
expr_stmt|;
break|break;
block|}
else|else
name|some_multiletter_word
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
block|{
name|some_letter
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|some_multiletter_word
operator|&&
name|SYNTAX
argument_list|(
name|prevc
argument_list|)
operator|==
name|Sword
condition|)
name|some_multiletter_word
operator|=
literal|1
expr_stmt|;
block|}
name|prevc
operator|=
name|c
expr_stmt|;
block|}
comment|/* Do not make new text all caps 	 if the original text contained only single letter words. */
if|if
condition|(
name|case_action
operator|==
name|all_caps
operator|&&
operator|!
name|some_multiletter_word
condition|)
name|case_action
operator|=
name|cap_initial
expr_stmt|;
if|if
condition|(
operator|!
name|some_letter
condition|)
name|case_action
operator|=
name|nochange
expr_stmt|;
block|}
name|SetPoint
argument_list|(
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|literal
argument_list|)
condition|)
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
condition|;
name|pos
operator|++
control|)
block|{
name|c
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
index|[
operator|++
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|place
argument_list|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'1'
operator|&&
name|c
operator|<=
name|RE_NREGS
operator|+
literal|'0'
condition|)
name|place
argument_list|(
name|search_regs
operator|.
name|start
index|[
name|c
operator|-
literal|'0'
index|]
operator|+
literal|1
argument_list|,
name|search_regs
operator|.
name|end
index|[
name|c
operator|-
literal|'0'
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|insert_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|insert_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|inslen
operator|=
name|point
operator|-
operator|(
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|del_range
argument_list|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_action
operator|==
name|all_caps
condition|)
name|Fupcase_region
argument_list|(
name|make_number
argument_list|(
name|point
operator|-
name|inslen
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|case_action
operator|==
name|cap_initial
condition|)
block|{
comment|/* Fcapitalize_region won't do; must not downcase anything.  */
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|point
operator|-
name|inslen
init|;
name|pos
operator|<
name|point
condition|;
name|pos
operator|++
control|)
block|{
name|c
operator|=
name|CharAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last
operator|&&
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|=
name|c
operator|^
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
name|last
operator|=
name|SYNTAX
argument_list|(
name|c
argument_list|)
operator|==
name|Sword
expr_stmt|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|place
argument_list|(
argument|l1
argument_list|,
argument|l2
argument_list|)
name|int
name|l1
operator|,
name|l2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|l1
operator|<
name|FirstCharacter
condition|)
name|l1
operator|=
name|FirstCharacter
expr_stmt|;
if|if
condition|(
name|l1
operator|>=
name|NumCharacters
condition|)
name|l1
operator|=
name|NumCharacters
expr_stmt|;
if|if
condition|(
name|l2
operator|<
name|l1
condition|)
name|l2
operator|=
name|l1
expr_stmt|;
if|if
condition|(
name|l2
operator|>=
name|NumCharacters
condition|)
name|l2
operator|=
name|NumCharacters
expr_stmt|;
name|GapTo
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
operator|&
name|CharAt
argument_list|(
name|l1
argument_list|)
argument_list|,
name|l2
operator|-
name|l1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"match-beginning"
argument_list|,
argument|Fmatch_beginning
argument_list|,
argument|Smatch_beginning
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the character number of start of text matched by last regexp searched for.\n\ ARG, a number, specifies which parenthesized expression in the last regexp.\n\ Zero means the entire text matched by the whole regexp."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|num
operator|)
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|XINT
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|RE_NREGS
condition|)
name|error
argument_list|(
literal|"Out-of-bounds argument"
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|search_regs
operator|.
name|start
index|[
name|n
index|]
operator|+
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"match-end"
argument_list|,
argument|Fmatch_end
argument_list|,
argument|Smatch_end
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the character number of end of text matched by last regexp searched for.\n\ ARG, a number, specifies which parenthesized expression in the last regexp.\n\ Zero means the entire text matched by the whole regexp."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|num
operator|)
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|XINT
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|RE_NREGS
condition|)
name|error
argument_list|(
literal|"Out-of-bounds argument"
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|search_regs
operator|.
name|end
index|[
name|n
index|]
operator|+
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"match-data"
argument_list|,
argument|Fmatch_data
argument_list|,
argument|Smatch_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return list containing all info on what the last search matched.\n\ Element 2N is (match-beginning N); element 2N + 1 is (match-end N).\n\ All are represented as markers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|data
index|[
literal|2
operator|*
name|RE_NREGS
index|]
block|;
name|int
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|data
index|[
literal|2
operator|*
name|i
index|]
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|Flist
argument_list|(
literal|2
operator|*
name|RE_NREGS
argument_list|,
name|data
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   DEFUN
operator|(
literal|"store-match-data"
operator|,
name|Fstore_match_data
operator|,
name|Sstore_match_data
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Set internal data on last search match from elements of LIST.\n\ LIST should have been created by calling match-data previously."
operator|)
operator|(
name|list
operator|)
specifier|register
name|Lisp_Object
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Lisp_Object
name|marker
decl_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|list
argument_list|)
condition|)
name|list
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|marker
operator|=
name|Fcar
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|=
name|marker_position
argument_list|(
name|marker
argument_list|)
operator|-
literal|1
expr_stmt|;
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|marker
operator|=
name|Fcar
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|=
name|marker_position
argument_list|(
name|marker
argument_list|)
operator|-
literal|1
expr_stmt|;
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Quote a string to inactivate reg-expr chars */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"regexp-quote"
argument_list|,
argument|Fregexp_quote
argument_list|,
argument|Sregexp_quote
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a regexp string which matches exactly STRING and nothing else."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|Lisp_Object
name|ostr
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* Increment `size' for the escapes we will need to insert */
for|for
control|(
name|cp
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|,
name|end
operator|=
name|cp
operator|+
name|size
init|;
name|cp
operator|!=
name|end
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'['
operator|||
operator|*
name|cp
operator|==
literal|']'
operator|||
operator|*
name|cp
operator|==
literal|'*'
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'?'
operator|||
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'^'
operator|||
operator|*
name|cp
operator|==
literal|'$'
condition|)
name|size
operator|++
expr_stmt|;
name|ostr
operator|=
name|Fmake_string
argument_list|(
name|make_number
argument_list|(
name|size
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy the data into the new string, inserting escapes. */
name|p
operator|=
name|XSTRING
argument_list|(
name|ostr
argument_list|)
operator|->
name|data
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
init|;
name|cp
operator|!=
name|end
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'['
operator|||
operator|*
name|cp
operator|==
literal|']'
operator|||
operator|*
name|cp
operator|==
literal|'*'
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'?'
operator|||
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'^'
operator|||
operator|*
name|cp
operator|==
literal|'$'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
block|}
return|return
name|ostr
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_search
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0400
condition|;
name|i
operator|++
control|)
name|downcase_table
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|>=
literal|'A'
operator|&&
name|i
operator|<=
literal|'Z'
operator|)
condition|?
name|i
operator|+
literal|040
else|:
name|i
expr_stmt|;
name|searchbuf
operator|.
name|allocated
operator|=
literal|100
expr_stmt|;
name|searchbuf
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|searchbuf
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|searchbuf
operator|.
name|fastmap
operator|=
name|search_fastmap
expr_stmt|;
name|Qsearch_failed
operator|=
name|intern
argument_list|(
literal|"search-failed"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsearch_failed
argument_list|)
expr_stmt|;
name|Qinvalid_regexp
operator|=
name|intern
argument_list|(
literal|"invalid-regexp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qinvalid_regexp
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qsearch_failed
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qsearch_failed
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qsearch_failed
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Search failed"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Invalid regexp"
argument_list|)
argument_list|)
expr_stmt|;
name|last_regexp
operator|=
name|Qnil
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|last_regexp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstring_match
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slooking_at
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscan_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sskip_chars_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sskip_chars_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssearch_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssearch_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sword_search_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sword_search_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sre_search_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sre_search_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sreplace_match
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smatch_beginning
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smatch_end
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smatch_data
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstore_match_data
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sregexp_quote
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

