begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Keyboard macros.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_decl_stmt
name|int
name|defining_kbd_macro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kbd_macro_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kbd_macro_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|kbd_macro_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kbd_macro_bufsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vlast_kbd_macro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vexecuting_macro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|executing_macro_index
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|Fexecute_kbd_macro
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"start-kbd-macro"
argument_list|,
argument|Fstart_kbd_macro
argument_list|,
argument|Sstart_kbd_macro
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Record subsequent keyboard input, defining a keyboard macro.\n\ The commands are recorded even as they are executed.\n\ Use \\[end-kbd-macro] to finish recording and make the macro available.\n\ Use \\[name-last-kbd-macro] to give it a permanent name.\n\ Non-nil arg (prefix arg) means append to last macro defined;\n\  This begins by re-executing that macro as if you typed it again."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|append
operator|)
name|Lisp_Object
name|append
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|defining_kbd_macro
condition|)
name|error
argument_list|(
literal|"Already defining kbd macro!"
argument_list|)
expr_stmt|;
else|else
block|{
name|defining_kbd_macro
operator|++
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|append
argument_list|)
condition|)
block|{
name|kbd_macro_ptr
operator|=
name|kbd_macro_buffer
expr_stmt|;
name|kbd_macro_end
operator|=
name|kbd_macro_buffer
expr_stmt|;
name|message
argument_list|(
literal|"Defining kbd macro..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"Appending to kbd macro..."
argument_list|)
expr_stmt|;
name|kbd_macro_ptr
operator|=
name|kbd_macro_end
expr_stmt|;
name|Fexecute_kbd_macro
argument_list|(
name|Vlast_kbd_macro
argument_list|,
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"end-kbd-macro"
argument_list|,
argument|Fend_kbd_macro
argument_list|,
argument|Send_kbd_macro
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Finish defining a keyboard macro.\n\ The definition was started by \\[start-kbd-macro].\n\ The macro is now available for use via \\[call-last-kbd-macro],\n\ or it can be given a name with \\[name-last-kbd-macro] and then invoked\n\ under that name.\n\ With numeric arg, repeat macro now that many times,\n\ counting the definition just completed as the first repetition."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|defining_kbd_macro
condition|)
name|error
argument_list|(
literal|"Not defining kbd macro."
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|defining_kbd_macro
condition|)
block|{
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
name|Vlast_kbd_macro
operator|=
name|make_string
argument_list|(
name|kbd_macro_buffer
argument_list|,
name|kbd_macro_end
operator|-
name|kbd_macro_buffer
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"Keyboard macro defined"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
name|Fexecute_kbd_macro
argument_list|(
name|Vlast_kbd_macro
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|--
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|>
literal|0
condition|)
name|Fexecute_kbd_macro
argument_list|(
name|Vlast_kbd_macro
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Store character c into kbd macro being defined */
end_comment

begin_macro
name|store_kbd_macro_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|defining_kbd_macro
condition|)
block|{
if|if
condition|(
name|kbd_macro_ptr
operator|-
name|kbd_macro_buffer
operator|==
name|kbd_macro_bufsize
condition|)
block|{
specifier|register
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|kbd_macro_buffer
argument_list|,
name|kbd_macro_bufsize
operator|*=
literal|2
argument_list|)
decl_stmt|;
name|kbd_macro_ptr
operator|+=
name|new
operator|-
name|kbd_macro_buffer
expr_stmt|;
name|kbd_macro_end
operator|=
name|new
operator|+
name|kbd_macro_bufsize
expr_stmt|;
name|kbd_macro_buffer
operator|=
name|new
expr_stmt|;
block|}
operator|*
name|kbd_macro_ptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Declare that all chars stored so far in the kbd macro being defined  really belong to it.  This is done in between editor commands.  */
end_comment

begin_macro
name|finalize_kbd_macro_chars
argument_list|()
end_macro

begin_block
block|{
name|kbd_macro_end
operator|=
name|kbd_macro_ptr
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"call-last-kbd-macro"
argument_list|,
argument|Fcall_last_kbd_macro
argument_list|,
argument|Scall_last_kbd_macro
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Call the last keyboard macro that you defined with \\[start-kbd-macro].\n\ To make a macro permanent so you can call it even after\n\ defining others, use \\[name-last-kbd-macro]."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prefix
operator|)
name|Lisp_Object
name|prefix
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|defining_kbd_macro
condition|)
name|error
argument_list|(
literal|"Can't execute anonymous macro while defining one"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|Vlast_kbd_macro
argument_list|)
condition|)
name|error
argument_list|(
literal|"No kbd macro has been defined"
argument_list|)
expr_stmt|;
else|else
name|Fexecute_kbd_macro
argument_list|(
name|Vlast_kbd_macro
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
specifier|static
name|Lisp_Object
name|pop_kbd_macro
parameter_list|(
name|info
parameter_list|)
name|Lisp_Object
name|info
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|Vexecuting_macro
operator|=
name|Fcar
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|executing_macro_index
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"execute-kbd-macro"
argument_list|,
argument|Fexecute_kbd_macro
argument_list|,
argument|Sexecute_kbd_macro
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Execute MACRO as string of editor command characters.\n\ If MACRO is a symbol, its function definition is used.\n\ COUNT is a repeat count, or nil for once, or 0 for infinite loop."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|macro
operator|,
name|prefixarg
operator|)
name|Lisp_Object
name|macro
operator|,
name|prefixarg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|final
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|int
name|repeat
init|=
literal|1
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|prefixarg
argument_list|)
condition|)
name|prefixarg
operator|=
name|Fprefix_numeric_value
argument_list|(
name|prefixarg
argument_list|)
operator|,
name|repeat
operator|=
name|XINT
argument_list|(
name|prefixarg
argument_list|)
expr_stmt|;
name|final
operator|=
name|macro
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|final
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|EQ
argument_list|(
name|final
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|final
operator|=
name|XSYMBOL
argument_list|(
name|final
argument_list|)
operator|->
name|function
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|final
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|tem
argument_list|)
operator|=
name|executing_macro_index
expr_stmt|;
name|tem
operator|=
name|Fcons
argument_list|(
name|Vexecuting_macro
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|pop_kbd_macro
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|GCPRO1
argument_list|(
name|final
argument_list|)
expr_stmt|;
do|do
block|{
name|Vexecuting_macro
operator|=
name|final
expr_stmt|;
name|executing_macro_index
operator|=
literal|0
expr_stmt|;
name|command_loop_1
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|repeat
operator|&&
name|XTYPE
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|==
name|Lisp_String
condition|)
do|;
name|UNGCPRO
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"name-last-kbd-macro"
argument_list|,
argument|Fname_last_kbd_macro
argument_list|,
argument|Sname_last_kbd_macro
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"SName last kbd macro: "
argument_list|,
literal|"Assign a name to the last keyboard macro defined.\n\ One arg, a symbol, which is the name to define.\n\ The symbol's function definition becomes the keyboard macro string.\n\ Such a \"function\" cannot be called from Lisp, but it is a valid command\n\ definition for the editor command loop."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sym
operator|)
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|defining_kbd_macro
condition|)
name|error
argument_list|(
literal|"Not allowed to name a keyboard macro while defining one"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Vlast_kbd_macro
argument_list|)
condition|)
name|error
argument_list|(
literal|"No keyboard macro defined"
argument_list|)
expr_stmt|;
name|Ffset
argument_list|(
name|sym
argument_list|,
name|Vlast_kbd_macro
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_block

begin_macro
name|init_macros
argument_list|()
end_macro

begin_block
block|{
name|Vlast_kbd_macro
operator|=
name|Qnil
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
name|Vexecuting_macro
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

begin_macro
name|syms_of_macros
argument_list|()
end_macro

begin_block
block|{
name|kbd_macro_bufsize
operator|=
literal|100
expr_stmt|;
name|kbd_macro_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|kbd_macro_bufsize
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstart_kbd_macro
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Send_kbd_macro
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scall_last_kbd_macro
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexecute_kbd_macro
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sname_last_kbd_macro
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"defining-kbd-macro"
argument_list|,
operator|&
name|defining_kbd_macro
argument_list|,
literal|"Non-nil means store keyboard input into kbd macro being defined."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"executing-macro"
argument_list|,
operator|&
name|Vexecuting_macro
argument_list|,
literal|"Currently executing keyboard macro (a string); nil if none executing."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"executing-kbd-macro"
argument_list|,
operator|&
name|Vexecuting_macro
argument_list|,
literal|"Currently executing keyboard macro (a string); nil if none executing."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"last-kbd-macro"
argument_list|,
operator|&
name|Vlast_kbd_macro
argument_list|,
literal|"Last kbd macro defined, as a string; nil if none defined."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_macros
argument_list|()
end_macro

begin_block
block|{
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
operator|(
literal|'e'
operator|)
argument_list|,
literal|"call-last-kbd-macro"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
operator|(
literal|'('
operator|)
argument_list|,
literal|"start-kbd-macro"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
operator|(
literal|')'
operator|)
argument_list|,
literal|"end-kbd-macro"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

