begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Markers: examining, setting and killing.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_comment
comment|/* Operations on markers. */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"marker-buffer"
argument_list|,
argument|Fmarker_buffer
argument_list|,
argument|Smarker_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer that MARKER points into, or nil if none.\n\ Returns nil if MARKER points into a dead buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|marker
operator|)
name|Lisp_Object
name|marker
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|buf
decl_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
block|{
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
argument_list|)
expr_stmt|;
comment|/* Return marker's buffer only if it is not dead.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|name
argument_list|)
condition|)
return|return
name|buf
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"marker-position"
argument_list|,
argument|Fmarker_position
argument_list|,
argument|Smarker_position
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the position MARKER points at, as a character number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|marker
operator|)
name|Lisp_Object
name|marker
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|buffer_text
modifier|*
name|text
decl_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
block|{
name|buf
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
expr_stmt|;
name|i
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|bufpos
expr_stmt|;
name|text
operator|=
operator|(
name|buf
operator|==
name|bf_cur
operator|)
condition|?
operator|&
name|bf_text
else|:
operator|&
name|buf
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|gap
operator|+
literal|1
condition|)
name|i
operator|-=
name|text
operator|->
name|gap
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|text
operator|->
name|size1
operator|+
literal|1
condition|)
name|i
operator|=
name|text
operator|->
name|size1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|size2
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|XFASTINT
argument_list|(
name|pos
argument_list|)
operator|=
name|i
expr_stmt|;
return|return
name|pos
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-marker"
argument_list|,
argument|Fset_marker
argument_list|,
argument|Sset_marker
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Position MARKER before character number NUMBER in BUFFER.\n\ BUFFER defaults to the current buffer.\n\ If NUMBER is nil, makes marker point nowhere.\n\ Then it no longer slows down editing in any buffer.\n\ Returns MARKER."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|marker
operator|,
name|pos
operator|,
name|buffer
operator|)
name|Lisp_Object
name|marker
operator|,
name|pos
operator|,
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|charno
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|buffer_text
modifier|*
name|text
decl_stmt|;
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
decl_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
return|return
name|marker
return|;
block|}
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|b
operator|=
name|bf_cur
expr_stmt|;
else|else
block|{
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|charno
operator|=
name|XINT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|m
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf_cur
operator|==
name|b
condition|)
name|text
operator|=
operator|&
name|bf_text
expr_stmt|;
else|else
name|text
operator|=
operator|&
name|b
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|charno
operator|<
name|text
operator|->
name|head_clip
condition|)
name|charno
operator|=
name|text
operator|->
name|head_clip
expr_stmt|;
if|if
condition|(
name|charno
operator|>
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|size2
operator|+
literal|1
operator|-
name|text
operator|->
name|tail_clip
condition|)
name|charno
operator|=
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|size2
operator|+
literal|1
operator|-
name|text
operator|->
name|tail_clip
expr_stmt|;
if|if
condition|(
name|charno
operator|>
name|text
operator|->
name|size1
operator|+
literal|1
condition|)
name|charno
operator|+=
name|text
operator|->
name|gap
expr_stmt|;
name|m
operator|->
name|bufpos
operator|=
name|charno
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|buffer
operator|!=
name|b
condition|)
block|{
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|m
operator|->
name|chain
operator|=
name|b
operator|->
name|markers
expr_stmt|;
name|b
operator|->
name|markers
operator|=
name|marker
expr_stmt|;
name|m
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
block|}
return|return
name|marker
return|;
block|}
end_block

begin_comment
comment|/* This is called during garbage collection,  so we must be careful to ignore and preserve mark bits,  including those in chain fields of markers.  */
end_comment

begin_macro
name|unchain_marker
argument_list|(
argument|marker
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|marker
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
specifier|register
name|int
name|omark
decl_stmt|;
if|if
condition|(
operator|!
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
return|return;
name|tail
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
operator|->
name|markers
expr_stmt|;
name|prev
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|!=
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
condition|)
block|{
name|next
operator|=
name|XMARKER
argument_list|(
name|tail
argument_list|)
operator|->
name|chain
expr_stmt|;
name|XUNMARK
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|==
name|XMARKER
argument_list|(
name|tail
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|prev
argument_list|)
condition|)
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
operator|->
name|markers
operator|=
name|next
expr_stmt|;
else|else
block|{
name|omark
operator|=
name|XMARKBIT
argument_list|(
name|XMARKER
argument_list|(
name|prev
argument_list|)
operator|->
name|chain
argument_list|)
expr_stmt|;
name|XMARKER
argument_list|(
name|prev
argument_list|)
operator|->
name|chain
operator|=
name|next
expr_stmt|;
name|XSETMARKBIT
argument_list|(
name|XMARKER
argument_list|(
name|prev
argument_list|)
operator|->
name|chain
argument_list|,
name|omark
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
name|prev
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|next
expr_stmt|;
block|}
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|marker_position
argument_list|(
argument|marker
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|marker
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
init|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|buf
init|=
name|m
operator|->
name|buffer
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|m
operator|->
name|bufpos
decl_stmt|;
specifier|register
name|struct
name|buffer_text
modifier|*
name|text
init|=
operator|(
name|buf
operator|==
name|bf_cur
operator|)
condition|?
operator|&
name|bf_text
else|:
operator|&
name|buf
operator|->
name|text
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|error
argument_list|(
literal|"Marker does not point anywhere"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|gap
operator|+
literal|1
condition|)
name|i
operator|-=
name|text
operator|->
name|gap
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|text
operator|->
name|size1
operator|+
literal|1
condition|)
name|i
operator|=
name|text
operator|->
name|size1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|size2
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"copy-marker"
argument_list|,
argument|Fcopy_marker
argument_list|,
argument|Scopy_marker
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a new marker pointing at the same place as MARKER.\n\ If argument is a number, makes a new marker pointing\n\ at that position in the current buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|marker
operator|)
name|Lisp_Object
name|marker
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|new
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Int
operator|||
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Marker
condition|)
block|{
name|new
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|new
argument_list|,
name|marker
argument_list|,
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Marker
condition|?
name|Fmarker_buffer
argument_list|(
name|marker
argument_list|)
else|:
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
name|marker
operator|=
name|wrong_type_argument
argument_list|(
name|Qinteger_or_marker_p
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_marker
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Smarker_position
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smarker_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_marker
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Sset_marker
argument_list|,
literal|"move-marker"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scopy_marker
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

