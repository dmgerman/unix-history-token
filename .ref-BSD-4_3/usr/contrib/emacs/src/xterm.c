begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* X Communication module for terminals which understand the X protocol.    Copyright (C) 1985 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* Written by Yakim Martillo.  */
end_comment

begin_comment
comment|/*  *	$Source: /u1/third_party/gnuemacs.v17/src/RCS/xterm.c,v $  *	$Author: rlk $  *	$Locker:  $  *	$Header: xterm.c,v 1.13 86/02/17 12:24:48 rlk Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_TrmXTERM_c
init|=
literal|"$Header: xterm.c,v 1.13 86/02/17 12:24:48 rlk Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* This includes sys/types.h, and that somehow loses    if this is not done before the other system files.  */
end_comment

begin_include
include|#
directive|include
file|"xterm.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"sink.h"
end_include

begin_include
include|#
directive|include
file|"sinkmask.h"
end_include

begin_comment
comment|/*#include<X/Xproto.h>	*/
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|sigunblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (0)
end_define

begin_define
define|#
directive|define
name|sigblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (1<< ((sig) - 1))
end_define

begin_decl_stmt
name|XREPBUFFER
name|Xxrepbuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pixelwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pixelheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PendingExposure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PendingIconExposure
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXICID
value|80
end_define

begin_decl_stmt
name|char
name|iconidentity
index|[
name|MAXICID
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ICONTAG
value|"emacs@"
end_define

begin_define
define|#
directive|define
name|METABIT
value|0x80
end_define

begin_decl_stmt
name|Window
name|XXIconWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bitmap
name|XXIconMask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|XXcurrentfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|default_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|informflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|display_line
modifier|*
name|DesiredScreen
index|[]
decl_stmt|,
modifier|*
name|PhysScreen
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXdebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_garbaged
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXxoffset
decl_stmt|,
name|XXyoffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|IconWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|WindowMapped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CurHL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flexlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line affect by dellines or */
end_comment

begin_comment
comment|/* inslines functions */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|VisibleX
decl_stmt|,
name|VisibleY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* genuine location of cursor on screen */
end_comment

begin_comment
comment|/* if it is there */
end_comment

begin_decl_stmt
specifier|static
name|int
name|SavedX
decl_stmt|,
name|SavedY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where the cursor was before update */
end_comment

begin_comment
comment|/* started */
end_comment

begin_decl_stmt
name|int
name|bitblt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to track bit blt events */
end_comment

begin_decl_stmt
name|int
name|CursorExists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* during updates cursor is turned off */
end_comment

begin_decl_stmt
specifier|static
name|int
name|InUpdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* many of functions here may be invoked */
end_comment

begin_comment
comment|/* even if no update in progress, when */
end_comment

begin_comment
comment|/* no update is in progress the action */
end_comment

begin_comment
comment|/* can be slightly different */
end_comment

begin_decl_stmt
name|char
name|MouseCursor
index|[
literal|33
index|]
init|=
literal|"\000\000\002\000\006\000\016\000\036\000\076\000\ \176\000\376\000\376\001\076\000\066\000\142\000\140\000\300\000\300\000\000\ \000"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|MouseMask
index|[
literal|33
index|]
init|=
literal|"\003\000\007\000\017\000\037\000\077\000\177\000\ \377\000\377\001\377\003\377\003\177\000\367\000\363\000\340\001\340\001\ \300\000"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Display
modifier|*
name|XXdisplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FontInfo
modifier|*
name|fontinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
name|XXwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cursor
name|EmacsCursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fore_color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables to store colors */
end_comment

begin_decl_stmt
name|char
modifier|*
name|back_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|brdr_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|curs_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mous_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|back
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mous
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WindowInfo
name|windowinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WindowInfo
name|rootwindowinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XEvent
name|XXEvent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* as X messages are read in they are */
end_comment

begin_comment
comment|/* stored here */
end_comment

begin_decl_stmt
specifier|static
name|XREPBUFFER
name|XXqueue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for storing up ExposeRegion */
end_comment

begin_comment
comment|/* replies, so that the SIGIO inter- */
end_comment

begin_comment
comment|/* rupt serving routines do almost */
end_comment

begin_comment
comment|/* no writes to the X socket */
end_comment

begin_comment
comment|/*int CurHL;			/* Current Highlighting actually being */
end_comment

begin_comment
comment|/* being used for bold font right now*/
end_comment

begin_decl_stmt
name|int
name|XXborder
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Display
modifier|*
name|XOpenDisplay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Window
name|XCreateWindow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Cursor
name|XDefineCursor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Cursor
name|XCreateCursor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FontInfo
modifier|*
name|XOpenFont
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* HLmode -- Changes the GX function for output strings.  Could be used to  * change font.  Check an XText library function call.   */
end_comment

begin_expr_stmt
specifier|static
name|HLmode
argument_list|(
argument|new
argument_list|)
name|int
name|new
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CurHL
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_comment
comment|/* External interface to control of standout mode.    Call this when about to modify line at position VPOS    and not change whether it is highlighted.  */
end_comment

begin_macro
name|XTreassert_line_highlight
argument_list|(
argument|highlight
argument_list|,
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|highlight
decl_stmt|,
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HLmode
argument_list|(
name|highlight
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Call this when about to modify line at position VPOS    and change whether it is highlighted.  */
end_comment

begin_expr_stmt
specifier|static
name|XTchange_line_highlight
argument_list|(
argument|new_highlight
argument_list|,
argument|vpos
argument_list|,
argument|first_unused_hpos
argument_list|)
name|int
name|new_highlight
operator|,
name|vpos
operator|,
name|first_unused_hpos
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|HLmode
argument_list|(
name|new_highlight
argument_list|)
expr_stmt|;
name|XTtopos
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XTclear_end_of_line
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Used for starting or restarting (after suspension) the X window.  Puts the  * cursor in a known place, update does not begin with this routine but only  * with a call to DoDsp.  The mouse cursor is warped into the window and then  * the cursor is turned on.  */
end_comment

begin_expr_stmt
specifier|static
name|XTset_terminal_modes
argument_list|()
block|{
name|int
name|stuffpending
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTset_terminal_modes\n"
argument_list|)
block|;
endif|#
directive|endif
name|InUpdate
operator|=
literal|0
block|;
name|stuffpending
operator|=
literal|0
block|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
block|}
name|XTclear_screen
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|stuffpending
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|stuffpending
condition|)
name|kill
argument_list|(
name|XXpid
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/* XTtopos moves the cursor to the correct location and checks whether an update  * is in progress in order to toggle it on.  */
end_comment

begin_expr_stmt
unit|static
name|XTtopos
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
specifier|register
name|int
name|row
operator|,
name|col
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTtopos\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cursX
operator|=
name|col
expr_stmt|;
name|cursY
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|InUpdate
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
return|return;
comment|/* Generally, XTtopos will be invoked */
comment|/* when InUpdate with !CursorExists */
comment|/* so that wasteful XFlush is not called */
block|}
if|if
condition|(
operator|(
name|row
operator|==
name|VisibleY
operator|)
operator|&&
operator|(
name|col
operator|==
name|VisibleX
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|XFlush
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|VisibleX
operator|=
name|col
expr_stmt|;
name|VisibleY
operator|=
name|row
expr_stmt|;
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Used to get the terminal back to a known state after resets.  Usually  * used when restarting suspended or waiting emacs  */
end_comment

begin_expr_stmt
specifier|static
name|cleanup
argument_list|()
block|{
name|inverse_video
operator|=
literal|0
block|;
name|HLmode
argument_list|(
literal|0
argument_list|)
block|; }
comment|/* wipes out numcols columns starting a current column on the current line */
specifier|static
name|XTclear_end_of_line
argument_list|(
name|first_blank
argument_list|)
specifier|register
name|int
name|first_blank
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|numcols
decl_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTclear_end_of_line\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cursY
operator|<
literal|0
operator|||
name|cursY
operator|>=
name|screen_height
condition|)
return|return;
if|if
condition|(
name|first_blank
operator|>=
name|screen_width
condition|)
return|return;
if|if
condition|(
name|first_blank
operator|<
literal|0
condition|)
name|first_blank
operator|=
literal|0
expr_stmt|;
name|numcols
operator|=
name|screen_width
operator|-
name|first_blank
expr_stmt|;
if|if
condition|(
name|cursY
operator|==
name|VisibleY
operator|&&
name|VisibleX
operator|>=
name|first_blank
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|first_blank
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|cursY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|fontinfo
operator|->
name|width
operator|*
name|numcols
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|XTtopos
argument_list|(
name|cursY
argument_list|,
name|first_blank
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTreset_terminal_modes
argument_list|()
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTreset_terminal_modes\n"
argument_list|)
block|;
endif|#
directive|endif
name|XTclear_screen
argument_list|()
block|; }
specifier|static
name|XTclear_screen
argument_list|()
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTclear_screen\n"
argument_list|)
block|;
endif|#
directive|endif
name|HLmode
argument_list|(
literal|0
argument_list|)
block|;
name|CursorExists
operator|=
literal|0
block|;
name|cursX
operator|=
literal|0
block|;
name|cursY
operator|=
literal|0
block|;
name|SavedX
operator|=
literal|0
block|;
name|SavedY
operator|=
literal|0
block|;
name|VisibleX
operator|=
literal|0
block|;
name|VisibleY
operator|=
literal|0
block|;
name|XClear
argument_list|(
name|XXwindow
argument_list|)
block|;
name|CursorToggle
argument_list|()
block|;
if|if
condition|(
operator|!
name|InUpdate
condition|)
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/* used by dumprectangle which is usually invoked upon ExposeRegion  * events which come from bit blt's or moving an obscuring opaque window  */
end_comment

begin_expr_stmt
specifier|static
name|dumpchars
argument_list|(
name|ActiveScreen
argument_list|,
name|numcols
argument_list|,
name|tempX
argument_list|,
name|tempY
argument_list|,
name|tempHL
argument_list|)
specifier|register
expr|struct
name|display_line
operator|*
operator|*
name|ActiveScreen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|numcols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|tempX
decl_stmt|,
name|tempY
decl_stmt|,
name|tempHL
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|numcols
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
operator|(
name|numcols
operator|-
literal|1
operator|)
operator|+
name|tempX
operator|)
operator|>
name|screen_width
condition|)
block|{
name|numcols
operator|=
operator|(
name|screen_width
operator|-
name|tempX
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tempX
operator|<
literal|0
operator|)
operator|||
operator|(
name|tempX
operator|>=
name|screen_width
operator|)
operator|||
operator|(
name|tempY
operator|<
literal|0
operator|)
operator|||
operator|(
name|tempY
operator|>=
name|screen_height
operator|)
condition|)
block|{
return|return;
block|}
name|XText
argument_list|(
name|XXwindow
argument_list|,
operator|(
name|tempX
operator|*
name|fontinfo
operator|->
name|width
operator|)
argument_list|,
operator|(
name|tempY
operator|*
name|fontinfo
operator|->
name|height
operator|)
argument_list|,
operator|&
name|ActiveScreen
index|[
name|tempY
operator|+
literal|1
index|]
operator|->
name|body
index|[
name|tempX
index|]
argument_list|,
name|numcols
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
operator|(
name|tempHL
condition|?
name|back
else|:
name|fore
operator|)
argument_list|,
operator|(
name|tempHL
condition|?
name|fore
else|:
name|back
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* When a line has been changed this function is called.  X is so fast  * that the actual sequence is ignore.  Rather, the new version of the  * line is simply output if this function is invoked while in UpDate.  * Sometimes writechars can be invoked when not in update if text is to  * be output at the end of the line.  In this case the whole line is not  * output.  Simply the new text at the current cursor position given  * by VisibleX,Y.  The cursor is moved to the end of the new text.  */
end_comment

begin_expr_stmt
specifier|static
name|writechars
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
specifier|register
name|char
operator|*
name|start
operator|,
operator|*
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|temp_length
decl_stmt|;
if|if
condition|(
operator|(
name|cursY
operator|<
literal|0
operator|)
operator|||
operator|(
name|cursY
operator|>=
name|screen_height
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|InUpdate
condition|)
block|{
if|if
condition|(
name|DesiredScreen
operator|&&
name|DesiredScreen
index|[
name|cursY
operator|+
literal|1
index|]
condition|)
block|{
name|temp_length
operator|=
name|DesiredScreen
index|[
name|cursY
operator|+
literal|1
index|]
operator|->
name|length
expr_stmt|;
block|}
else|else
name|temp_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp_length
operator|>
literal|0
condition|)
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
operator|(
name|cursY
operator|*
name|fontinfo
operator|->
name|height
operator|)
argument_list|,
operator|&
name|DesiredScreen
index|[
name|cursY
operator|+
literal|1
index|]
operator|->
name|body
index|[
literal|0
index|]
argument_list|,
name|temp_length
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
operator|(
name|CurHL
condition|?
name|back
else|:
name|fore
operator|)
argument_list|,
operator|(
name|CurHL
condition|?
name|fore
else|:
name|back
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_length
operator|<
name|screen_width
condition|)
block|{
name|XTclear_end_of_line
argument_list|(
name|temp_length
argument_list|)
expr_stmt|;
block|}
name|XTtopos
argument_list|(
name|cursY
argument_list|,
name|temp_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XTclear_end_of_line
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XTtopos
argument_list|(
name|cursY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|VisibleX
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleX
operator|>=
name|screen_width
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|VisibleY
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleY
operator|>=
name|screen_height
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
name|VisibleX
operator|)
operator|>=
name|screen_width
condition|)
block|{
name|end
operator|=
name|start
operator|+
operator|(
name|screen_width
operator|-
operator|(
name|VisibleX
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|>=
name|start
condition|)
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
operator|(
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
operator|)
argument_list|,
operator|(
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
operator|)
argument_list|,
name|start
argument_list|,
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
operator|(
name|CurHL
condition|?
name|back
else|:
name|fore
operator|)
argument_list|,
operator|(
name|CurHL
condition|?
name|fore
else|:
name|back
operator|)
argument_list|)
expr_stmt|;
name|VisibleX
operator|=
name|VisibleX
operator|+
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|XTwrite_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTwrite_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|writechars
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The following routine is for the deaf or for the pervert who prefers   * that his terminal flashes at him rather than beep at him.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flashedback
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|XTflash
argument_list|()
block|{   struct
name|itimerval
name|itimer
block|;
specifier|extern
name|int
name|flashback
argument_list|()
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTflash\n"
argument_list|)
block|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|flashback
argument_list|)
block|;
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
block|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|+=
literal|250000
block|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
block|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
block|;
name|flashedback
operator|=
literal|0
block|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
literal|0
argument_list|)
block|;
name|XPixFill
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|WhitePixel
argument_list|,
name|ClipModeClipped
argument_list|,
name|GXinvert
argument_list|,
name|AllPlanes
argument_list|)
block|;
name|XFlush
argument_list|()
block|;
while|while
condition|(
operator|!
name|flashedback
condition|)
name|pause
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|flashback
argument_list|()
block|{
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
block|;
name|XPixFill
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|WhitePixel
argument_list|,
name|ClipModeClipped
argument_list|,
name|GXinvert
argument_list|,
name|AllPlanes
argument_list|)
block|;
name|XFlush
argument_list|()
block|;
name|flashedback
operator|=
literal|1
block|; }
comment|/* A kludge to get a bell */
specifier|static
name|XTfeep
argument_list|()
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTfeep\n"
argument_list|)
block|;
endif|#
directive|endif
name|XFeep
argument_list|(
literal|0
argument_list|)
block|; }
comment|/* Artificially creating a cursor is hard, the actual position on the  * screen (either where it is or last was) is tracked with VisibleX,Y.  * Gnu Emacs code tends to assume a cursor exists in hardward at cursX,Y  * and that output text will appear there.  During updates, the cursor is  * supposed to be blinked out and will only reappear after the update   * finishes.  */
name|CursorToggle
argument_list|()
block|{
specifier|register
expr|struct
name|display_line
operator|*
operator|*
name|ActiveScreen
block|;
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|VisibleX
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleX
operator|>=
name|screen_width
operator|)
operator|||
operator|(
name|VisibleY
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleY
operator|>=
name|screen_height
operator|)
condition|)
block|{
comment|/* Current Cursor position trash */
comment|/* Not much can be done */
name|XFlush
argument_list|()
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* Currently the return values are not */
comment|/* used, but I could anticipate using */
comment|/* them in the future. */
block|}
end_if

begin_comment
comment|/*  if(InUpdate&& DesiredScreen)       ActiveScreen = DesiredScreen;       else*/
end_comment

begin_expr_stmt
name|ActiveScreen
operator|=
name|PhysScreen
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ActiveScreen
operator|&&
name|ActiveScreen
index|[
name|VisibleY
operator|+
literal|1
index|]
operator|&&
operator|(
name|VisibleX
operator|<
name|ActiveScreen
index|[
name|VisibleY
operator|+
literal|1
index|]
operator|->
name|length
operator|)
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
operator|&
name|ActiveScreen
index|[
name|VisibleY
operator|+
literal|1
index|]
operator|->
name|body
index|[
name|VisibleX
index|]
argument_list|,
literal|1
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
name|fore
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
operator|&
name|ActiveScreen
index|[
name|VisibleY
operator|+
literal|1
index|]
operator|->
name|body
index|[
name|VisibleX
index|]
argument_list|,
literal|1
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
name|back
argument_list|,
name|curs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CursorExists
condition|)
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|curs
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|CursorExists
operator|=
operator|!
name|CursorExists
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Cursor has either been blinked in */
end_comment

begin_comment
comment|/* or out */
end_comment

begin_if
if|if
condition|(
operator|!
name|InUpdate
condition|)
block|{
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_if

begin_return
return|return
literal|1
return|;
end_return

begin_comment
unit|}
comment|/* This routine is used by routines which are called to paint regions */
end_comment

begin_comment
comment|/* designated by ExposeRegion events.  If the cursor may be in the exposed */
end_comment

begin_comment
comment|/* region, this routine makes sure it is gone so that dumprectangle can */
end_comment

begin_comment
comment|/* toggle it back into existance if dumprectangle is invoked when not in */
end_comment

begin_comment
comment|/* the midst of a screen update. */
end_comment

begin_macro
unit|static
name|ClearCursor
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|VisibleX
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleX
operator|>=
name|screen_width
operator|)
operator|||
operator|(
name|VisibleY
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleY
operator|>=
name|screen_height
operator|)
condition|)
block|{
comment|/* Current Cursor position trash */
comment|/* Not much can be done */
name|CursorExists
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTupdate_begin
argument_list|()
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTupdate_begin\n"
argument_list|)
block|;
endif|#
directive|endif
name|InUpdate
operator|=
literal|1
block|;
if|if
condition|(
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|SavedX
operator|=
name|cursX
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The initial"hardware" cursor position is */
end_comment

begin_comment
comment|/*  saved because that is where gnu emacs */
end_comment

begin_comment
comment|/*  expects the cursor to be at the end of*/
end_comment

begin_comment
comment|/* the update */
end_comment

begin_expr_stmt
name|SavedY
operator|=
name|cursY
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dumpqueue
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   static
name|XTupdate_end
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTupdate_end\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|InUpdate
operator|=
literal|0
expr_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
name|XTtopos
argument_list|(
name|SavedY
argument_list|,
name|SavedX
argument_list|)
expr_stmt|;
comment|/* XTtopos invokes cursor toggle */
block|}
end_block

begin_comment
comment|/* Used for expose region and expose copy events.  Have to get the text  * back into the newly blank areas.  */
end_comment

begin_expr_stmt
name|dumprectangle
argument_list|(
name|top
argument_list|,
name|left
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
specifier|register
name|int
name|top
operator|,
name|left
operator|,
name|rows
operator|,
name|cols
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|display_line
modifier|*
modifier|*
name|ActiveScreen
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|localX
decl_stmt|,
name|localY
decl_stmt|,
name|localHL
decl_stmt|;
name|rows
operator|+=
name|top
expr_stmt|;
name|cols
operator|+=
name|left
expr_stmt|;
name|top
operator|/=
name|fontinfo
operator|->
name|height
expr_stmt|;
comment|/* Get row and col containing up and */
comment|/* left borders of exposed region -- */
comment|/* round down here*/
name|left
operator|/=
name|fontinfo
operator|->
name|width
expr_stmt|;
name|rows
operator|+=
operator|(
name|fontinfo
operator|->
name|height
operator|-
literal|1
operator|)
expr_stmt|;
name|cols
operator|+=
operator|(
name|fontinfo
operator|->
name|width
operator|-
literal|1
operator|)
expr_stmt|;
name|rows
operator|/=
name|fontinfo
operator|->
name|height
expr_stmt|;
comment|/* Get row and col containing bottom and */
comment|/* right borders -- round up here */
name|rows
operator|-=
name|top
expr_stmt|;
name|cols
operator|/=
name|fontinfo
operator|->
name|width
expr_stmt|;
name|cols
operator|-=
name|left
expr_stmt|;
if|if
condition|(
name|rows
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|cols
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|top
operator|>
operator|(
name|screen_height
operator|-
literal|1
operator|)
condition|)
return|return;
if|if
condition|(
name|left
operator|>
operator|(
name|screen_width
operator|-
literal|1
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|VisibleX
operator|>=
name|left
operator|)
operator|&&
operator|(
name|VisibleX
operator|<
operator|(
name|left
operator|+
name|cols
operator|)
operator|)
operator|&&
operator|(
name|VisibleY
operator|>=
name|top
operator|)
operator|&&
operator|(
name|VisibleY
operator|<
operator|(
name|top
operator|+
name|rows
operator|)
operator|)
condition|)
block|{
name|ClearCursor
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|InUpdate
operator|&&
name|DesiredScreen
condition|)
name|ActiveScreen
operator|=
name|PhysScreen
expr_stmt|;
elseif|else
if|if
condition|(
name|PhysScreen
condition|)
name|ActiveScreen
operator|=
name|PhysScreen
expr_stmt|;
comment|/* When cue is dumped in update this */
else|else
return|return;
comment|/* should perhaps be DesiredScreen */
comment|/* but PhysScreen is guaranteed to contain*/
comment|/* date which was good for every line on */
comment|/* screen. For desired screen only for */
comment|/* lines which are changing.  Emacs does */
comment|/* not consider a line within a newly */
comment|/* exposed region necessarily to have */
comment|/* been changed.  Emacs knows nothing */
comment|/* about ExposeRegion events.*/
for|for
control|(
name|localY
operator|=
name|top
operator|,
name|index
operator|=
literal|0
init|;
operator|(
name|index
operator|<
name|rows
operator|)
operator|&&
operator|(
name|localY
operator|<
name|screen_height
operator|)
condition|;
operator|++
name|index
operator|,
operator|++
name|localY
control|)
block|{
if|if
condition|(
operator|(
name|localY
operator|<
literal|0
operator|)
operator|||
operator|(
name|localY
operator|>=
name|screen_height
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ActiveScreen
index|[
name|localY
operator|+
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|left
operator|+
literal|1
operator|)
operator|>
name|ActiveScreen
index|[
name|localY
operator|+
literal|1
index|]
operator|->
name|length
condition|)
continue|continue;
name|localX
operator|=
name|left
expr_stmt|;
name|localHL
operator|=
name|ActiveScreen
index|[
name|localY
operator|+
literal|1
index|]
operator|->
name|highlighted
expr_stmt|;
name|dumpchars
argument_list|(
name|ActiveScreen
argument_list|,
name|min
argument_list|(
name|cols
argument_list|,
name|ActiveScreen
index|[
name|localY
operator|+
literal|1
index|]
operator|->
name|length
operator|-
name|localX
argument_list|)
argument_list|,
name|localX
argument_list|,
name|localY
argument_list|,
name|localHL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|InUpdate
operator|&&
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
comment|/* Routine usually called */
comment|/* when not in update */
block|}
end_block

begin_comment
comment|/* What sections of the window will be modified from the UpdateDisplay  * routine is totally under software control.  Any line with Y coordinate  * greater than flexlines will not change during an update.  This is really  * used only during dellines and inslines routines (scraplines and stufflines)  */
end_comment

begin_expr_stmt
specifier|static
name|XTset_terminal_window
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTset_terminal_window\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|<=
literal|0
operator|)
operator|||
operator|(
name|n
operator|>
name|screen_height
operator|)
condition|)
name|flexlines
operator|=
name|screen_height
expr_stmt|;
else|else
name|flexlines
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|XTins_del_lines
argument_list|(
argument|vpos
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vpos
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTins_del_lines\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XTtopos
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|stufflines
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|scraplines
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTinsert_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTinsert_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|writechars
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTdelete_chars
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|msg
init|=
literal|"***Delete Chars Called Outside of Update!!!***"
decl_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTdelete_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|writechars
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|strlen
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|stufflines
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|topregion
decl_stmt|,
name|bottomregion
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|,
name|newtop
decl_stmt|;
if|if
condition|(
name|cursY
operator|>=
name|flexlines
condition|)
return|return;
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|bitblt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
name|topregion
operator|=
name|cursY
expr_stmt|;
name|bottomregion
operator|=
name|flexlines
operator|-
operator|(
name|n
operator|+
literal|1
operator|)
expr_stmt|;
name|newtop
operator|=
name|cursY
operator|+
name|n
expr_stmt|;
name|length
operator|=
operator|(
name|bottomregion
operator|-
name|topregion
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|newtop
operator|<=
name|flexlines
operator|)
condition|)
block|{
comment|/* Should already have cleared */
comment|/* queue of events associated */
comment|/* with old bitblts */
name|XMoveArea
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
name|topregion
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
literal|0
argument_list|,
name|newtop
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|length
operator|*
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|WindowMapped
condition|)
name|bitblt
operator|=
literal|1
expr_stmt|;
name|request_sigio
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
while|while
condition|(
name|bitblt
condition|)
block|{
name|kill
argument_list|(
name|XXpid
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
block|}
name|unrequest_sigio
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
name|newtop
operator|=
name|min
argument_list|(
name|newtop
argument_list|,
operator|(
name|flexlines
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|newtop
operator|-
name|topregion
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
name|topregion
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|n
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
comment|/*  if (!InUpdate) CursorToggle (); */
block|}
end_block

begin_expr_stmt
specifier|static
name|scraplines
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|bitblt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cursY
operator|>=
name|flexlines
condition|)
return|return;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cursY
operator|+
name|n
operator|)
operator|>=
name|flexlines
condition|)
block|{
if|if
condition|(
name|flexlines
operator|>=
operator|(
name|cursY
operator|+
literal|1
operator|)
condition|)
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
name|cursY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
operator|(
name|flexlines
operator|-
name|cursY
operator|)
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|XMoveArea
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
operator|(
name|cursY
operator|+
name|n
operator|)
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
literal|0
argument_list|,
name|cursY
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
operator|(
name|flexlines
operator|-
operator|(
name|cursY
operator|+
name|n
operator|)
operator|)
operator|*
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|WindowMapped
condition|)
name|bitblt
operator|=
literal|1
expr_stmt|;
name|request_sigio
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
while|while
condition|(
name|bitblt
condition|)
block|{
name|kill
argument_list|(
name|XXpid
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
block|}
name|unrequest_sigio
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
operator|(
name|flexlines
operator|-
name|n
operator|)
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|n
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
comment|/* if (!InUpdate) CursorToggle (); */
block|}
end_block

begin_comment
comment|/* Substitutes for standard read routine.  Under X not interested in individual  * bytes but rather individual packets.  */
end_comment

begin_expr_stmt
name|XTread_socket
argument_list|(
name|sd
argument_list|,
name|bufp
argument_list|,
name|numchars
argument_list|)
specifier|register
name|int
name|sd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|numchars
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|;
name|int
name|stuffpending
decl_stmt|;
name|int
name|temp_width
decl_stmt|,
name|temp_height
decl_stmt|;
comment|/*  typedef struct reply {XEvent event; struct reply *next} Reply;     Reply *replies = NULL;*/
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numchars
operator|<=
literal|0
condition|)
block|{
comment|/* To keep from overflowing read buffer */
name|numchars
operator|=
literal|1
expr_stmt|;
operator|--
name|bufp
expr_stmt|;
block|}
while|while
condition|(
name|bitblt
operator|||
name|XPending
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/* while there are more events*/
name|XNextEvent
argument_list|(
operator|&
name|XXEvent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XXEvent
operator|.
name|type
condition|)
block|{
comment|/*	case X_Reply: 	{ 	extern char *malloc(); 	Reply *reply = (Reply *) malloc (sizeof (Reply)); 	reply->next = replies; 	reply->event = XXEvent; 	replies = reply; 	break; 	}*/
default|default:
break|break;
case|case
name|ExposeWindow
case|:
if|if
condition|(
operator|(
operator|(
name|XExposeEvent
operator|*
operator|)
operator|&
name|XXEvent
operator|)
operator|->
name|window
operator|==
name|XXIconWindow
condition|)
block|{
name|PendingIconExposure
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|PendingExposure
operator|=
literal|1
expr_stmt|;
comment|/* No reason to repeat */
comment|/* this if several */
comment|/* ExposeWindow events */
comment|/* come in quick succes-*/
comment|/* ion */
break|break;
case|case
name|ExposeRegion
case|:
if|if
condition|(
name|PendingExposure
condition|)
block|{
comment|/* Don't bother with */
comment|/* region events when */
comment|/* full window event */
comment|/* is pending */
break|break;
block|}
name|loadxrepbuffer
argument_list|(
operator|&
name|XXEvent
argument_list|,
operator|&
name|XXqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXqueue
operator|.
name|rindex
operator|==
name|XXqueue
operator|.
name|windex
condition|)
block|{
name|PendingExposure
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|XXqueue
operator|.
name|rindex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|rindex
operator|<
literal|0
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|<
literal|0
operator|)
condition|)
block|{
name|PendingExposure
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ExposeCopy
case|:
comment|/* For ExposeCopy sync */
comment|/* will block all outgoing */
comment|/* requests until this is */
comment|/* decremented */
if|if
condition|(
name|WindowMapped
condition|)
name|bitblt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KeyPressed
case|:
if|if
condition|(
name|Input
argument_list|(
operator|(
operator|(
name|XKeyPressedEvent
operator|*
operator|)
operator|&
name|XXEvent
operator|)
operator|->
name|detail
argument_list|,
name|bufp
argument_list|)
condition|)
block|{
operator|++
name|bufp
expr_stmt|;
operator|++
name|count
expr_stmt|;
operator|--
name|numchars
expr_stmt|;
block|}
break|break;
case|case
name|ButtonPressed
case|:
switch|switch
condition|(
name|spacecheck
argument_list|(
name|Xxrepbuffer
operator|.
name|mindex
argument_list|,
name|Xxrepbuffer
operator|.
name|rindex
argument_list|,
name|Xxrepbuffer
operator|.
name|windex
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|loadxrepbuffer
argument_list|(
operator|&
name|XXEvent
argument_list|,
operator|&
name|Xxrepbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|informflag
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
operator|(
name|char
operator|)
literal|003
expr_stmt|;
comment|/* C-c */
operator|++
name|count
expr_stmt|;
operator|--
name|numchars
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
operator|(
name|char
operator|)
literal|'\r'
expr_stmt|;
comment|/* C-m */
operator|++
name|count
expr_stmt|;
operator|--
name|numchars
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
break|break;
case|case
operator|-
literal|2
case|:
default|default:
name|fixxrepbuffer
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
comment|/*  while (replies) {     Reply *reply = replies;     XPutBackEvent (&reply->event);     replies = reply->next;     free (reply);     }*/
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CursorExists
condition|)
name|xfixscreen
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_comment
comment|/* refresh bitmap kitchen sink icon */
end_comment

begin_macro
name|refreshicon
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|XXIconWindow
condition|)
name|XBitmapBitsPut
argument_list|(
name|XXIconWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sink_width
argument_list|,
name|sink_height
argument_list|,
name|sink_bits
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|,
name|XXIconMask
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XBitmapIcon
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|IconWindow
condition|)
block|{
name|XSetIconWindow
argument_list|(
name|XXwindow
argument_list|,
name|XXIconWindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
name|IconWindow
operator|=
operator|!
name|IconWindow
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|XTextIcon
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|IconWindow
condition|)
block|{
name|XClearIconWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
name|IconWindow
operator|=
operator|!
name|IconWindow
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Interpreting incoming keycodes. Should have table modifiable as needed  * from elisp.  */
end_comment

begin_comment
comment|/* Exit gracefully from gnuemacs, doing an autosave and giving a status.  */
end_comment

begin_macro
name|XExitGracefully
argument_list|()
end_macro

begin_block
block|{
name|XAutoSave
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|70
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|xfixscreen
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|temp_width
decl_stmt|,
name|temp_height
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
specifier|register
name|int
name|temp_x
decl_stmt|,
name|temp_y
decl_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
name|func
operator|=
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Check that the connection is in fact open.  This works by doing a nop */
comment|/* (well, almost) write operation.  If there is an XIOerror or a */
comment|/* SIGPIPE, exit gracefully.  This fixes the loop-on-logout bug.*/
name|XIOErrorHandler
argument_list|(
name|XExitGracefully
argument_list|)
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|XIOErrorHandler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PendingIconExposure
condition|)
block|{
name|refreshicon
argument_list|()
expr_stmt|;
name|PendingIconExposure
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|PendingExposure
condition|)
block|{
name|PendingExposure
operator|=
literal|0
expr_stmt|;
name|ClearCursor
argument_list|()
expr_stmt|;
name|XXqueue
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
name|XXqueue
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
name|XQueryWindow
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|windowinfo
argument_list|)
expr_stmt|;
comment|/* Dangerous to do */
comment|/* writes here but */
comment|/* otherwise would */
comment|/* have to alter */
comment|/* gnu emacs display */
comment|/* routines to query */
comment|/* when screen garbaged */
name|temp_width
operator|=
operator|(
name|windowinfo
operator|.
name|width
operator|/
name|fontinfo
operator|->
name|width
operator|)
expr_stmt|;
name|temp_height
operator|=
operator|(
name|windowinfo
operator|.
name|height
operator|/
name|fontinfo
operator|->
name|height
operator|)
expr_stmt|;
if|if
condition|(
name|temp_width
operator|!=
name|screen_width
operator|||
name|temp_height
operator|!=
name|screen_height
condition|)
name|change_screen_size
argument_list|(
name|temp_height
argument_list|,
name|temp_width
argument_list|)
expr_stmt|;
name|temp_x
operator|=
name|windowinfo
operator|.
name|x
expr_stmt|;
name|temp_y
operator|=
name|windowinfo
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|temp_x
operator|!=
name|XXxoffset
operator|||
name|temp_y
operator|!=
name|XXyoffset
condition|)
name|XSetOffset
argument_list|(
name|temp_x
argument_list|,
name|temp_y
argument_list|)
expr_stmt|;
name|dumprectangle
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|InUpdate
condition|)
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|XXpid
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|Input
argument_list|(
name|keycode
argument_list|,
name|buffer
argument_list|)
specifier|register
name|int
name|keycode
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|c
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
specifier|extern
name|KeyMapEntry
name|StdMap
index|[]
decl_stmt|;
name|offset
operator|=
name|KeyState
argument_list|(
name|keycode
argument_list|)
expr_stmt|;
comment|/* set SHIFT, CONTROL, META */
name|c
operator|=
name|StdMap
index|[
name|keycode
operator|&
name|ValueMask
index|]
index|[
name|offset
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|keycode
operator|&
name|ShiftLockMask
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'z'
operator|)
condition|)
block|{
name|c
operator|+=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
block|}
name|keycode
operator|&=
name|ValueMask
expr_stmt|;
comment|/* no longer need shift bits for anything */
if|if
condition|(
operator|!
operator|(
name|c
operator|&
operator|~
literal|377
operator|)
condition|)
block|{
operator|*
name|buffer
operator|=
name|c
expr_stmt|;
return|return
literal|1
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
comment|/*    case '\007':       kill(XXpid, SIGINT);       break;*/
case|case
name|KEYPAD
case|:
case|case
name|CURSOR
case|:
switch|switch
condition|(
name|keycode
operator|&
name|ValueMask
condition|)
block|{
case|case
literal|0247
case|:
comment|/* left-arrow maps to C-B */
name|c
operator|=
literal|002
operator||
operator|(
operator|(
name|keycode
operator|&
name|MetaMask
operator|)
condition|?
name|METABIT
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0250
case|:
comment|/* right-arrow maps to C-F */
name|c
operator|=
literal|006
operator||
operator|(
operator|(
name|keycode
operator|&
name|MetaMask
operator|)
condition|?
name|METABIT
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0252
case|:
comment|/* up-arrow maps to C-P */
name|c
operator|=
literal|020
operator||
operator|(
operator|(
name|keycode
operator|&
name|MetaMask
operator|)
condition|?
name|METABIT
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0251
case|:
comment|/* down-arrow maps to C-N */
name|c
operator|=
literal|016
operator||
operator|(
operator|(
name|keycode
operator|&
name|MetaMask
operator|)
condition|?
name|METABIT
else|:
literal|0
operator|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|PFX
case|:
case|case
operator|(
name|short
operator|)
operator|-
literal|1
case|:
case|case
name|SHFT
case|:
case|case
name|CNTL
case|:
case|case
name|SYMBOL
case|:
case|case
name|LOCK
case|:
case|case
name|FUNC1
case|:
case|case
name|FUNC2
case|:
case|case
name|FUNC3
case|:
case|case
name|FUNC4
case|:
case|case
name|FUNC5
case|:
case|case
name|FUNC6
case|:
case|case
name|FUNC7
case|:
case|case
name|FUNC8
case|:
case|case
name|FUNC9
case|:
case|case
name|FUNC10
case|:
case|case
name|FUNC11
case|:
case|case
name|FUNC12
case|:
case|case
name|FUNC13
case|:
case|case
name|FUNC14
case|:
case|case
name|FUNC15
case|:
case|case
name|FUNC16
case|:
case|case
name|FUNC17
case|:
case|case
name|FUNC18
case|:
case|case
name|FUNC19
case|:
case|case
name|FUNC20
case|:
case|case
name|E1
case|:
case|case
name|E2
case|:
case|case
name|E3
case|:
case|case
name|E4
case|:
case|case
name|E5
case|:
case|case
name|E6
case|:
return|return
literal|0
return|;
default|default:
operator|*
name|buffer
operator|=
name|c
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_macro
name|x_term_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|vardisplay
decl_stmt|;
specifier|register
name|char
modifier|*
name|colonpointer
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
specifier|register
name|int
name|scratchindex
decl_stmt|;
extern|extern XTinterrupt_signal (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|vardisplay
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|vardisplay
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DISPLAY environment variable must be set\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|200
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XXdisplay
operator|=
name|XOpenDisplay
argument_list|(
name|vardisplay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XXdisplay
operator|==
operator|(
name|Display
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No X.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|99
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|dup2
argument_list|(
name|dpyno
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|close
argument_list|(
name|dpyno
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dpyno
argument_list|()
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Looks a little strange? */
end_comment

begin_comment
comment|/* check the def of the */
end_comment

begin_comment
comment|/* macro, it is a genuine */
end_comment

begin_comment
comment|/* lvalue */
end_comment

begin_expr_stmt
name|Xxrepbuffer
operator|.
name|mindex
operator|=
name|XREPBUFSIZE
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Xxrepbuffer
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Xxrepbuffer
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXqueue
operator|.
name|mindex
operator|=
name|XREPBUFSIZE
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXqueue
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXqueue
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|WindowMapped
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|baud_rate
operator|=
literal|9600
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|min_padding_speed
operator|=
literal|10000
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|must_write_spaces
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|informflag
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MetaFlag
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|visible_bell
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|interrupt_input
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|inverse_video
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bitblt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PendingExposure
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IconWindow
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fix_screen_hook
operator|=
name|xfixscreen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_screen_hook
operator|=
name|XTclear_screen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_end_of_line_hook
operator|=
name|XTclear_end_of_line
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ins_del_lines_hook
operator|=
name|XTins_del_lines
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|change_line_highlight_hook
operator|=
name|XTchange_line_highlight
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|insert_chars_hook
operator|=
name|XTinsert_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|write_chars_hook
operator|=
name|XTwrite_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|delete_chars_hook
operator|=
name|XTdelete_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ring_bell_hook
operator|=
name|XTfeep
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reset_terminal_modes_hook
operator|=
name|XTreset_terminal_modes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|set_terminal_modes_hook
operator|=
name|XTset_terminal_modes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|update_begin_hook
operator|=
name|XTupdate_begin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|update_end_hook
operator|=
name|XTupdate_end
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|set_terminal_window_hook
operator|=
name|XTset_terminal_window
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|read_socket_hook
operator|=
name|XTread_socket
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|topos_hook
operator|=
name|XTtopos
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* raw_topos_hook = XTraw_topos;  */
end_comment

begin_expr_stmt
name|reassert_line_highlight_hook
operator|=
name|XTreassert_line_highlight
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|scroll_region_ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we'll scroll partial screens */
end_comment

begin_expr_stmt
name|char_ins_del_ok
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* just as fast to write the line */
end_comment

begin_expr_stmt
name|line_ins_del_ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we'll just blt 'em */
end_comment

begin_expr_stmt
name|fast_clear_end_of_line
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* X does this well */
end_comment

begin_expr_stmt
name|memory_below_screen
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we don't remember what scrolls  				   off the bottom */
end_comment

begin_expr_stmt
name|dont_calculate_costs
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fore
operator|=
name|BlackPixel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|back
operator|=
name|WhitePixel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|brdr
operator|=
name|BlackPixel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mous
operator|=
name|BlackPixel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curs
operator|=
name|BlackPixel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fore_color
operator|=
literal|"black"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|back_color
operator|=
literal|"white"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|brdr_color
operator|=
literal|"black"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mous_color
operator|=
literal|"black"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curs_color
operator|=
literal|"black"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXcurrentfont
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"vtsingle"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|default_window
operator|=
literal|"=80x24+1+1"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|XTread_socket
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|XExitGracefully
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XXcurrentfont
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failure.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|150
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|strcpy
argument_list|(
operator|&
name|XXcurrentfont
index|[
literal|0
index|]
argument_list|,
literal|"vtsingle"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XQueryWindow
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|rootwindowinfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strncpy
argument_list|(
name|iconidentity
argument_list|,
name|ICONTAG
argument_list|,
name|MAXICID
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXborder
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|screen_width
operator|=
literal|80
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|screen_height
operator|=
literal|66
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXxoffset
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXyoffset
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXdebug
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fontinfo
operator|=
name|XOpenFont
argument_list|(
operator|&
name|XXcurrentfont
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fontinfo
operator|==
operator|(
name|FontInfo
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No font\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|98
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|pixelwidth
operator|=
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pixelheight
operator|=
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXwindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
name|XXxoffset
comment|/* Absolute horizontal offset */
argument_list|,
name|XXyoffset
comment|/* Absolute Vertical offset */
argument_list|,
name|pixelwidth
argument_list|,
name|pixelheight
argument_list|,
name|XXborder
argument_list|,
name|BlackPixmap
argument_list|,
name|WhitePixmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|XXwindow
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to create window.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|97
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XXIconWindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sink_width
argument_list|,
name|sink_height
argument_list|,
literal|2
argument_list|,
name|WhitePixmap
argument_list|,
operator|(
name|Pixmap
operator|)
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|XXIconWindow
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to create icon window.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|97
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXIconMask
operator|=
name|XStoreBitmap
argument_list|(
name|sink_mask_width
argument_list|,
name|sink_mask_height
argument_list|,
name|sink_mask_bits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
name|fontinfo
operator|->
name|width
operator|*
literal|10
argument_list|,
name|fontinfo
operator|->
name|height
operator|*
literal|5
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|gethostname
argument_list|(
operator|&
name|iconidentity
index|[
sizeof|sizeof
argument_list|(
name|ICONTAG
argument_list|)
operator|-
literal|1
index|]
argument_list|,
operator|(
name|MAXICID
operator|-
literal|1
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|ICONTAG
argument_list|)
argument_list|)
condition|)
block|{
name|iconidentity
index|[
sizeof|sizeof
argument_list|(
name|ICONTAG
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XStoreName
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|iconidentity
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EmacsCursor
operator|=
name|XCreateCursor
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|MouseCursor
argument_list|,
name|MouseMask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|EmacsCursor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Dirty kluge so maybe things will work right */
end_comment

begin_expr_stmt
name|XBitmapIcon
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XTextIcon
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flexlines
operator|=
name|screen_height
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|initialized
condition|)
name|XPopUpWindow
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|setxterm
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Process all queued ExposeRegion events. */
end_comment

begin_macro
unit|static
name|dumpqueue
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|XExposeRegionEvent
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|XXqueue
operator|.
name|rindex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|rindex
operator|<
literal|0
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|<
literal|0
operator|)
condition|)
block|{
name|PendingExposure
operator|=
literal|1
expr_stmt|;
block|}
else|else
while|while
condition|(
name|XXqueue
operator|.
name|rindex
operator|!=
name|XXqueue
operator|.
name|windex
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|unloadxrepbuffer
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|XXqueue
argument_list|)
expr_stmt|;
name|dumprectangle
argument_list|(
name|r
operator|.
name|y
argument_list|,
name|r
operator|.
name|x
argument_list|,
name|r
operator|.
name|height
argument_list|,
name|r
operator|.
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|XSetFlash
argument_list|()
end_macro

begin_block
block|{
name|ring_bell_hook
operator|=
name|XTflash
expr_stmt|;
block|}
end_block

begin_macro
name|XSetFeep
argument_list|()
end_macro

begin_block
block|{
name|ring_bell_hook
operator|=
name|XTfeep
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|XNewFont
argument_list|(
name|newname
argument_list|)
specifier|register
name|char
operator|*
name|newname
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|FontInfo
modifier|*
name|temp
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|func
operator|=
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
if|if
condition|(
name|XXdebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Request id is %d\n"
argument_list|,
name|XXdisplay
operator|->
name|request
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XOpenFont
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
operator|(
name|FontInfo
operator|*
operator|)
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|QLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|kill
argument_list|(
name|XXpid
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|XCloseFont
argument_list|(
name|fontinfo
argument_list|)
expr_stmt|;
name|fontinfo
operator|=
name|temp
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
name|fontinfo
operator|->
name|width
operator|*
literal|10
argument_list|,
name|fontinfo
operator|->
name|height
operator|*
literal|5
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
name|XSetWindowSize
argument_list|(
name|screen_height
argument_list|,
name|screen_width
argument_list|)
expr_stmt|;
if|if
condition|(
name|QLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|kill
argument_list|(
name|XXpid
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|XFlipColor
argument_list|()
end_macro

begin_block
block|{
name|Pixmap
name|temp
decl_stmt|;
name|int
name|tempcolor
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|Cursor
name|temp_curs
decl_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|func
operator|=
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XMakeTile
argument_list|(
name|fore
argument_list|)
expr_stmt|;
name|XChangeBackground
argument_list|(
name|XXwindow
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XMakeTile
argument_list|(
name|back
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXborder
condition|)
name|XChangeBorder
argument_list|(
name|XXwindow
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|brdr
operator|=
name|back
expr_stmt|;
name|brdr_color
operator|=
name|back_color
expr_stmt|;
name|tempcolor
operator|=
name|fore
expr_stmt|;
name|fore
operator|=
name|back
expr_stmt|;
name|back
operator|=
name|tempcolor
expr_stmt|;
name|tempname
operator|=
name|fore_color
expr_stmt|;
name|fore_color
operator|=
name|back_color
expr_stmt|;
name|back_color
operator|=
name|tempname
expr_stmt|;
comment|/*  XPixFill (XXwindow, 0, 0, screen_width * fontinfo->width, 	    screen_height * fontinfo->height, back, ClipModeClipped, 	    GXcopy, AllPlanes);   dumprectangle(0, 0, screen_height * fontinfo->height,   screen_width * fontinfo -> width);*/
name|XRedrawDisplay
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs
operator|==
name|WhitePixel
condition|)
block|{
name|curs
operator|=
name|BlackPixel
expr_stmt|;
name|curs_color
operator|=
literal|"black"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curs
operator|==
name|BlackPixel
condition|)
block|{
name|curs
operator|=
name|WhitePixel
expr_stmt|;
name|curs_color
operator|=
literal|"white"
expr_stmt|;
block|}
if|if
condition|(
name|mous
operator|==
name|WhitePixel
condition|)
block|{
name|mous
operator|=
name|BlackPixel
expr_stmt|;
name|mous_color
operator|=
literal|"black"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mous
operator|==
name|BlackPixel
condition|)
block|{
name|mous
operator|=
name|WhitePixel
expr_stmt|;
name|mous_color
operator|=
literal|"white"
expr_stmt|;
block|}
name|temp_curs
operator|=
name|XCreateCursor
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|MouseCursor
argument_list|,
name|MouseMask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mous
argument_list|,
name|back
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|XUndefineCursor
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|temp_curs
argument_list|)
expr_stmt|;
name|XFreeCursor
argument_list|(
name|EmacsCursor
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|temp_curs
argument_list|,
operator|&
name|EmacsCursor
argument_list|,
sizeof|sizeof
argument_list|(
name|Cursor
argument_list|)
argument_list|)
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|XSetOffset
argument_list|(
name|xoff
argument_list|,
name|yoff
argument_list|)
specifier|register
name|int
name|xoff
operator|,
name|yoff
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|xoff
operator|<
literal|0
condition|)
block|{
name|XXxoffset
operator|=
name|rootwindowinfo
operator|.
name|width
operator|+
operator|(
operator|++
name|xoff
operator|)
operator|-
name|pixelwidth
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|XXxoffset
operator|=
name|xoff
expr_stmt|;
block|}
if|if
condition|(
name|yoff
operator|<
literal|0
condition|)
block|{
name|XXyoffset
operator|=
name|rootwindowinfo
operator|.
name|height
operator|+
operator|(
operator|++
name|yoff
operator|)
operator|-
name|pixelheight
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|XXyoffset
operator|=
name|yoff
expr_stmt|;
block|}
name|XMoveWindow
argument_list|(
name|XXwindow
argument_list|,
name|XXxoffset
argument_list|,
name|XXyoffset
argument_list|)
expr_stmt|;
comment|/* XWarpMouse (XXwindow, pixelwidth>> 1, pixelheight>> 1); */
block|}
end_block

begin_expr_stmt
name|XSetWindowSize
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|)
specifier|register
name|int
name|rows
operator|,
name|cols
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|rows
operator|<
literal|5
condition|)
name|rows
operator|=
literal|66
expr_stmt|;
if|if
condition|(
name|cols
operator|<
literal|5
condition|)
name|cols
operator|=
literal|80
expr_stmt|;
name|pixelwidth
operator|=
name|cols
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|1
expr_stmt|;
name|pixelheight
operator|=
name|rows
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|1
expr_stmt|;
name|XChangeWindow
argument_list|(
name|XXwindow
argument_list|,
name|pixelwidth
argument_list|,
name|pixelheight
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|change_screen_size
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|PendingExposure
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|XPopUpWindow
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|WindowMapped
condition|)
return|return;
if|if
condition|(
operator|!
name|x_edges_specified
condition|)
name|Fx_rubber_band
argument_list|()
expr_stmt|;
name|bitblt
operator|=
literal|0
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
name|WindowMapped
operator|=
literal|1
expr_stmt|;
name|XMapWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|dumprectangle
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|KeyPressed
operator||
name|ExposeWindow
operator||
name|ButtonPressed
operator||
name|ExposeRegion
operator||
name|ExposeCopy
argument_list|)
expr_stmt|;
comment|/*	XWarpMouse(XXwindow, pixelwidth>> 1, pixelheight>> 1);*/
name|XTtopos
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  XRedrawDisplay();*/
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|spacecheck
argument_list|(
name|mindex
argument_list|,
name|rindex
argument_list|,
name|windex
argument_list|,
name|minfreespace
argument_list|)
specifier|register
name|int
name|mindex
operator|,
name|rindex
operator|,
name|windex
operator|,
name|minfreespace
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|rindex
operator|>
name|mindex
operator|)
operator|||
operator|(
name|windex
operator|>
name|mindex
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal Mouse Buffer Error.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d = mindex, %d = rindex, %d = windex\n"
argument_list|,
name|mindex
argument_list|,
name|rindex
argument_list|,
name|windex
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|windex
operator|>=
name|rindex
condition|)
block|{
if|if
condition|(
operator|(
name|mindex
operator|-
operator|(
name|windex
operator|-
name|rindex
operator|)
operator|)
operator|>
name|minfreespace
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|rindex
operator|-
name|windex
operator|)
operator|-
literal|1
operator|)
operator|>
name|minfreespace
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_expr_stmt
name|loadxrepbuffer
argument_list|(
name|p_xrep
argument_list|,
name|p_buffer
argument_list|)
specifier|register
name|XEvent
operator|*
name|p_xrep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XREPBUFFER
modifier|*
name|p_buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p_buffer
operator|->
name|xrep
index|[
name|p_buffer
operator|->
name|windex
index|]
operator|=
operator|*
name|p_xrep
expr_stmt|;
if|if
condition|(
name|p_buffer
operator|->
name|windex
operator|==
name|p_buffer
operator|->
name|mindex
condition|)
name|p_buffer
operator|->
name|windex
operator|=
literal|0
expr_stmt|;
else|else
name|p_buffer
operator|->
name|windex
operator|++
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|unloadxrepbuffer
argument_list|(
name|p_xrep
argument_list|,
name|p_buffer
argument_list|)
specifier|register
name|XEvent
operator|*
name|p_xrep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XREPBUFFER
modifier|*
name|p_buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p_buffer
operator|->
name|windex
operator|==
name|p_buffer
operator|->
name|rindex
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|p_xrep
operator|=
name|p_buffer
operator|->
name|xrep
index|[
name|p_buffer
operator|->
name|rindex
index|]
expr_stmt|;
if|if
condition|(
name|p_buffer
operator|->
name|rindex
operator|==
name|p_buffer
operator|->
name|mindex
condition|)
name|p_buffer
operator|->
name|rindex
operator|=
literal|0
expr_stmt|;
else|else
name|p_buffer
operator|->
name|rindex
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|fixxrepbuffer
argument_list|()
end_macro

begin_block
block|{
name|Xxrepbuffer
operator|.
name|mindex
operator|=
name|XREPBUFSIZE
operator|-
literal|1
expr_stmt|;
name|Xxrepbuffer
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
name|Xxrepbuffer
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

