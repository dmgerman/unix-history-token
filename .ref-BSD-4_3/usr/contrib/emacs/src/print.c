begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lisp object printing and output streams.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not standalone */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vstandard_output
decl_stmt|,
name|Qstandard_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Avoid actual stack overflow in print.  */
end_comment

begin_decl_stmt
name|int
name|print_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum length of list to print in full; noninteger means    effectively infinity */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprint_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print newline before next minibuffer message.    Defined in xdisp.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|noninteractive_need_newline
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Low level output routines for charaters and strings */
end_comment

begin_comment
comment|/* Lisp functions to do output using a stream  must have the stream in a variable called printcharfun  and must start with PRINTPREPARE and end with PRINTFINISH.  Use PRINTCHAR to output one character,  or call strout to output a block of characters.  Also, each one must have the declarations    struct buffer *old = bf_cur;    int old_point = -1, start_point;    Lisp_Object original; */
end_comment

begin_define
define|#
directive|define
name|PRINTPREPARE
define|\
value|original = printcharfun; \    if (NULL (printcharfun)) printcharfun = Qt; \    if (XTYPE (printcharfun) == Lisp_Buffer) \      { if (XBUFFER (printcharfun) != bf_cur) SetBfp (XBUFFER (printcharfun)); \        printcharfun = Qnil;}\    if (XTYPE (printcharfun) == Lisp_Marker) \      { if (XMARKER (original)->buffer != bf_cur) \          SetBfp (XMARKER (original)->buffer); \        old_point = point; \        SetPoint (marker_position (printcharfun)); \        start_point = point; \        printcharfun = Qnil;}
end_define

begin_define
define|#
directive|define
name|PRINTFINISH
define|\
value|if (XTYPE (original) == Lisp_Marker) \      Fset_marker (original, make_number (point), Qnil); \    if (old_point>= 0) \      SetPoint ((old_point>= start_point ? point - start_point : 0) + old_point); \    if (old != bf_cur) \      SetBfp (old)
end_define

begin_define
define|#
directive|define
name|PRINTCHAR
parameter_list|(
name|ch
parameter_list|)
value|printchar (ch, printcharfun)
end_define

begin_comment
comment|/* Buffer for output destined for minibuffer */
end_comment

begin_decl_stmt
specifier|static
name|char
name|printbuf
index|[
name|MScreenWidth
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first unused element of above */
end_comment

begin_decl_stmt
specifier|static
name|int
name|printbufidx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printchar
parameter_list|(
name|ch
parameter_list|,
name|fun
parameter_list|)
name|unsigned
name|char
name|ch
decl_stmt|;
name|Lisp_Object
name|fun
decl_stmt|;
block|{
name|Lisp_Object
name|ch1
decl_stmt|;
ifndef|#
directive|ifndef
name|standalone
if|if
condition|(
name|EQ
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|InsCStr
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|fun
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
if|if
condition|(
name|noninteractive
condition|)
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|noninteractive_need_newline
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|minibuf_message
operator|!=
name|printbuf
condition|)
name|minibuf_message
operator|=
name|printbuf
operator|,
name|printbufidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|printbufidx
operator|<
sizeof|sizeof
name|printbuf
operator|-
literal|1
condition|)
name|printbuf
index|[
name|printbufidx
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|printbuf
index|[
name|printbufidx
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* not standalone */
name|XFASTINT
argument_list|(
name|ch1
argument_list|)
operator|=
name|ch
expr_stmt|;
name|call1
argument_list|(
name|fun
argument_list|,
name|ch1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strout
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|printcharfun
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|Lisp_Object
name|printcharfun
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|printcharfun
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
name|InsCStr
argument_list|(
name|ptr
argument_list|,
name|size
operator|>=
literal|0
condition|?
name|size
else|:
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|printcharfun
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
name|i
operator|=
name|size
operator|>=
literal|0
condition|?
name|size
else|:
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|noninteractive
condition|)
block|{
name|fwrite
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|noninteractive_need_newline
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|minibuf_message
operator|!=
name|printbuf
condition|)
name|minibuf_message
operator|=
name|printbuf
operator|,
name|printbufidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
sizeof|sizeof
name|printbuf
operator|-
name|printbufidx
operator|-
literal|1
condition|)
name|i
operator|=
sizeof|sizeof
name|printbuf
operator|-
name|printbufidx
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|&
name|printbuf
index|[
name|printbufidx
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printbufidx
operator|+=
name|i
expr_stmt|;
name|printbuf
index|[
name|printbufidx
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|>=
literal|0
condition|)
while|while
condition|(
name|i
operator|<
name|size
condition|)
name|PRINTCHAR
argument_list|(
name|ptr
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|ptr
index|[
name|i
index|]
condition|)
name|PRINTCHAR
argument_list|(
name|ptr
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"write-char"
argument_list|,
argument|Fwrite_char
argument_list|,
argument|Swrite_char
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output character CHAR to stream STREAM.\n\ STREAM defaults to the value of standard-output (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|ch
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|ch
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|PRINTCHAR
argument_list|(
name|XINT
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|ch
return|;
block|}
end_block

begin_macro
name|write_string
argument_list|(
argument|data
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|Lisp_Object
name|printcharfun
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|strout
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
block|}
end_block

begin_macro
name|write_string_1
argument_list|(
argument|data
argument_list|,
argument|size
argument_list|,
argument|printcharfun
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|printcharfun
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|strout
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_macro
name|temp_output_buffer_setup
argument_list|(
argument|bufname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bufname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|Lisp_Object
name|buf
decl_stmt|;
name|Fset_buffer
argument_list|(
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
name|bufname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|bf_cur
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Qstandard_output
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|Lisp_Object
name|internal_with_output_to_temp_buffer
argument_list|(
name|bufname
argument_list|,
name|function
argument_list|,
name|args
argument_list|)
name|char
modifier|*
name|bufname
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Lisp_Object
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|buf
decl_stmt|,
name|val
decl_stmt|;
name|temp_output_buffer_setup
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Vstandard_output
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|function
call|)
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|temp_output_buffer_show
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"with-output-to-temp-buffer"
argument_list|,
argument|Fwith_output_to_temp_buffer
argument_list|,
argument|Swith_output_to_temp_buffer
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Binding  standard-output  to buffer named BUFNAME, execute BODY then display the buffer.\n\ The buffer is cleared out initially, and marked as unmodified when done.\n\ All output done by BODY is inserted in that buffer by default.\n\ It is displayed in another window, but not selected.\n\ The value of the last form in BODY is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|Lisp_Object
name|name
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|buf
decl_stmt|,
name|val
decl_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|name
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
name|temp_output_buffer_setup
argument_list|(
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Vstandard_output
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|temp_output_buffer_show
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not standalone */
end_comment

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|print
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"terpri"
argument_list|,
argument|Fterpri
argument_list|,
argument|Sterpri
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Output a newline to STREAM (or value of standard-output)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|printcharfun
operator|)
name|Lisp_Object
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"prin1"
argument_list|,
argument|Fprin1
argument_list|,
argument|Sprin1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output the printed representation of OBJECT, any Lisp object.\n\ Quoting characters are used, to make output that  read  can handle\n\ whenever this is possible.\n\ Output stream is STREAM, or value of standard-output (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|obj
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_comment
comment|/* a buffer which is used to hold output being built by prin1-to-string */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprin1_to_string_buffer
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"prin1-to-string"
argument_list|,
argument|Fprin1_to_string
argument_list|,
argument|Sprin1_to_string
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a string containing the printed representation of OBJECT,\n\ any Lisp object.  Quoting characters are used, to make output that  read\n\ can handle whenever this is possible."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|,
name|printcharfun
decl_stmt|;
name|printcharfun
operator|=
name|Vprin1_to_string_buffer
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make Vprin1_to_string_buffer be the default buffer after PRINTFINSH */
name|PRINTFINISH
expr_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|Vprin1_to_string_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"princ"
argument_list|,
argument|Fprinc
argument_list|,
argument|Sprinc
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output the printed representation of OBJECT, any Lisp object.\n\ No quoting characters are used; no delimiters are printed around\n\ the contents of strings.\n\ Output stream is STREAM, or value of standard-output (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|obj
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"print"
argument_list|,
argument|Fprint
argument_list|,
argument|Sprint
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Output the printed representation of OBJECT, with newline before and\n\ space after.  Quoting characters are used, to make output that  read\n\ can handle whenever this is possible.\n\ Output stream is STREAM, or value of  standard-output  (which see)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|,
name|printcharfun
operator|)
name|Lisp_Object
name|obj
operator|,
name|printcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|int
name|old_point
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start_point
decl_stmt|;
name|Lisp_Object
name|original
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printcharfun
argument_list|)
condition|)
name|printcharfun
operator|=
name|Vstandard_output
expr_stmt|;
name|PRINTPREPARE
expr_stmt|;
name|print_depth
operator|=
literal|0
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|PRINTFINISH
expr_stmt|;
return|return
name|obj
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print
parameter_list|(
name|obj
parameter_list|,
name|printcharfun
parameter_list|,
name|escapeflag
parameter_list|)
specifier|register
name|Lisp_Object
name|obj
decl_stmt|;
name|Lisp_Object
name|printcharfun
decl_stmt|;
name|int
name|escapeflag
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|QUIT
expr_stmt|;
name|print_depth
operator|++
expr_stmt|;
if|if
condition|(
name|print_depth
operator|>
literal|200
condition|)
name|error
argument_list|(
literal|"Apparently circular structure being printed"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_Int
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|XINT
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_String
case|:
if|if
condition|(
operator|!
name|escapeflag
condition|)
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|size
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
name|PRINTCHAR
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|QUIT
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|PRINTCHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Lisp_Symbol
case|:
block|{
specifier|register
name|int
name|confusing
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
operator|->
name|name
operator|->
name|data
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
operator|->
name|name
operator|->
name|size
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|end
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|end
condition|)
name|confusing
operator|=
literal|0
expr_stmt|;
else|else
block|{
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
name|confusing
operator|=
operator|(
name|end
operator|==
name|p
operator|)
expr_stmt|;
block|}
name|p
operator|=
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
operator|->
name|name
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|QUIT
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|escapeflag
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'`'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|<=
literal|040
operator|||
name|confusing
condition|)
name|PRINTCHAR
argument_list|(
literal|'\\'
argument_list|)
operator|,
name|confusing
operator|=
literal|0
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Lisp_Cons
case|:
name|PRINTCHAR
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|max
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|Vprint_length
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|max
operator|=
name|XINT
argument_list|(
name|Vprint_length
argument_list|)
expr_stmt|;
while|while
condition|(
name|LISTP
argument_list|(
name|obj
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|++
condition|)
name|PRINTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|&&
name|i
operator|>
name|max
condition|)
block|{
name|strout
argument_list|(
literal|"..."
argument_list|,
literal|3
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
block|}
name|print
argument_list|(
name|Fcar
argument_list|(
name|obj
argument_list|)
argument_list|,
name|printcharfun
argument_list|,
name|escapeflag
argument_list|)
expr_stmt|;
name|obj
operator|=
name|Fcdr
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|obj
argument_list|)
operator|&&
operator|!
name|LISTP
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|strout
argument_list|(
literal|" . "
argument_list|,
literal|3
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|obj
argument_list|,
name|printcharfun
argument_list|,
name|escapeflag
argument_list|)
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Vector
case|:
name|PRINTCHAR
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|PRINTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|print
argument_list|(
name|tem
argument_list|,
name|printcharfun
argument_list|,
name|escapeflag
argument_list|)
expr_stmt|;
block|}
block|}
name|PRINTCHAR
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|standalone
case|case
name|Lisp_Buffer
case|:
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|strout
argument_list|(
literal|"#<killed buffer>"
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|escapeflag
condition|)
block|{
name|strout
argument_list|(
literal|"#<buffer "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
else|else
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Process
case|:
if|if
condition|(
name|escapeflag
condition|)
block|{
name|strout
argument_list|(
literal|"#<process "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XPROCESS
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
else|else
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XPROCESS
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Window
case|:
name|strout
argument_list|(
literal|"#<window "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|obj
argument_list|)
operator|->
name|sequence_number
argument_list|)
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
block|{
name|strout
argument_list|(
literal|" on "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Marker
case|:
name|strout
argument_list|(
literal|"#<marker "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XMARKER
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
operator|)
condition|)
name|strout
argument_list|(
literal|"in no buffer"
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"at %d"
argument_list|,
name|marker_position
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
literal|" in "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSTRING
argument_list|(
name|XMARKER
argument_list|(
name|obj
argument_list|)
operator|->
name|buffer
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
block|}
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* standalone */
case|case
name|Lisp_Subr
case|:
name|strout
argument_list|(
literal|"#<subr "
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|strout
argument_list|(
name|XSUBR
argument_list|(
name|obj
argument_list|)
operator|->
name|symbol_name
argument_list|,
operator|-
literal|1
argument_list|,
name|printcharfun
argument_list|)
expr_stmt|;
name|PRINTCHAR
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
block|}
name|print_depth
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|syms_of_print
parameter_list|()
block|{
name|DefLispVar
argument_list|(
literal|"standard-output"
argument_list|,
operator|&
name|Vstandard_output
argument_list|,
literal|"Function print uses by default for outputting a character.\n\ This may be any function of one argument.\n\ It may also be a buffer (output is inserted before point)\n\ or a marker (output is inserted and the marker is advanced)\n\ or the symbol t (output appears in the minibuffer line)."
argument_list|)
expr_stmt|;
name|Vstandard_output
operator|=
name|Qt
expr_stmt|;
name|Qstandard_output
operator|=
name|intern
argument_list|(
literal|"standard-output"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qstandard_output
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"print-length"
argument_list|,
operator|&
name|Vprint_length
argument_list|,
literal|"Maximum length of list to print before abbreviating.\ `nil' means no limit."
argument_list|)
expr_stmt|;
name|Vprint_length
operator|=
name|Qnil
expr_stmt|;
comment|/* prin1_to_string_buffer initialized in init_buffer_once in buffer.c */
name|staticpro
argument_list|(
operator|&
name|Vprin1_to_string_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprin1
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprin1_to_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprinc
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprint
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sterpri
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swrite_char
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|standalone
name|defsubr
argument_list|(
operator|&
name|Swith_output_to_temp_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not standalone */
block|}
end_function

end_unit

