begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lisp parsing and input streams.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|X_OK
end_ifndef

begin_define
define|#
directive|define
name|X_OK
value|01
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Lisp_Object
name|Qread_char
decl_stmt|,
name|Qget_file_char
decl_stmt|,
name|Qstandard_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qvariable_documentation
decl_stmt|,
name|Vvalues
decl_stmt|,
name|Vstandard_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff inside of load */
end_comment

begin_decl_stmt
name|int
name|load_in_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Search path for files to be loaded. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vload_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File for get_file_char to read from.  Use by load */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When nonzero, read conses in pure space */
end_comment

begin_decl_stmt
specifier|static
name|int
name|read_pure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For use within read-from-string (this reader is non-reentrant!!) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|read_from_string_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_from_string_limit
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Handle unreading and rereading of characters.  Write READCHAR to read a character, UNREAD(c) to unread c to be read again. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unrch
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|readcharfun
parameter_list|)
name|Lisp_Object
name|readcharfun
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|struct
name|buffer_text
modifier|*
name|inbuffer
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|mpos
decl_stmt|;
if|if
condition|(
name|unrch
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|unrch
expr_stmt|;
name|unrch
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|readcharfun
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
block|{
if|if
condition|(
name|XBUFFER
argument_list|(
name|readcharfun
argument_list|)
operator|==
name|bf_cur
condition|)
name|inbuffer
operator|=
operator|&
name|bf_text
expr_stmt|;
else|else
name|inbuffer
operator|=
operator|&
name|XBUFFER
argument_list|(
name|readcharfun
argument_list|)
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|inbuffer
operator|->
name|pointloc
operator|>
name|inbuffer
operator|->
name|size1
operator|+
name|inbuffer
operator|->
name|size2
operator|-
name|inbuffer
operator|->
name|tail_clip
condition|)
return|return
operator|-
literal|1
return|;
name|c
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|inbuffer
operator|->
name|pointloc
operator|>
name|inbuffer
operator|->
name|size1
condition|?
name|inbuffer
operator|->
name|p2
else|:
name|inbuffer
operator|->
name|p1
operator|)
index|[
name|inbuffer
operator|->
name|pointloc
index|]
expr_stmt|;
name|inbuffer
operator|->
name|pointloc
operator|++
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|readcharfun
argument_list|)
operator|==
name|Lisp_Marker
condition|)
block|{
if|if
condition|(
name|XMARKER
argument_list|(
name|readcharfun
argument_list|)
operator|->
name|buffer
operator|==
name|bf_cur
condition|)
name|inbuffer
operator|=
operator|&
name|bf_text
expr_stmt|;
else|else
name|inbuffer
operator|=
operator|&
name|XMARKER
argument_list|(
name|readcharfun
argument_list|)
operator|->
name|buffer
operator|->
name|text
expr_stmt|;
name|mpos
operator|=
name|marker_position
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpos
operator|>
name|inbuffer
operator|->
name|size1
operator|+
name|inbuffer
operator|->
name|size2
operator|-
name|inbuffer
operator|->
name|tail_clip
condition|)
return|return
operator|-
literal|1
return|;
name|c
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|mpos
operator|>
name|inbuffer
operator|->
name|size1
condition|?
name|inbuffer
operator|->
name|p2
else|:
name|inbuffer
operator|->
name|p1
operator|)
index|[
name|mpos
index|]
expr_stmt|;
if|if
condition|(
name|mpos
operator|!=
name|inbuffer
operator|->
name|size1
operator|+
literal|1
condition|)
name|XMARKER
argument_list|(
name|readcharfun
argument_list|)
operator|->
name|bufpos
operator|++
expr_stmt|;
else|else
name|Fset_marker
argument_list|(
name|readcharfun
argument_list|,
name|make_number
argument_list|(
name|mpos
operator|+
literal|1
argument_list|)
argument_list|,
name|Fmarker_buffer
argument_list|(
name|readcharfun
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|readcharfun
argument_list|,
name|Qget_file_char
argument_list|)
condition|)
return|return
name|getc
argument_list|(
name|instream
argument_list|)
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|readcharfun
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
operator|(
name|read_from_string_index
operator|<
name|read_from_string_limit
operator|)
condition|?
name|XSTRING
argument_list|(
name|readcharfun
argument_list|)
operator|->
name|data
index|[
name|read_from_string_index
operator|++
index|]
else|:
operator|-
literal|1
return|;
name|tem
operator|=
name|Fapply
argument_list|(
name|readcharfun
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|XINT
argument_list|(
name|tem
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|READCHAR
value|readchar(readcharfun)
end_define

begin_define
define|#
directive|define
name|UNREAD
parameter_list|(
name|c
parameter_list|)
value|(unrch = c)
end_define

begin_decl_stmt
specifier|static
name|Lisp_Object
name|read0
argument_list|()
decl_stmt|,
name|read1
argument_list|()
decl_stmt|,
name|read_list
argument_list|()
decl_stmt|,
name|read_vector
argument_list|()
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* get a character from the tty */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"read-char"
argument_list|,
argument|Fread_char
argument_list|,
argument|Sread_char
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Read a character from the command input (keyboard or macro).\n\ It is returned as a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|val
block|;
ifndef|#
directive|ifndef
name|standalone
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|get_char
argument_list|(
literal|0
argument_list|)
argument_list|)
block|;
else|#
directive|else
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|getchar
argument_list|()
argument_list|)
block|;
endif|#
directive|endif
return|return
name|val
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"get-file-char"
argument_list|,
argument|Fget_file_char
argument_list|,
argument|Sget_file_char
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Don't use this yourself."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|val
block|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|getc
argument_list|(
name|instream
argument_list|)
argument_list|)
block|;
return|return
name|val
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_function_decl
name|void
name|readevalloop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|load_unwind
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"load"
argument_list|,
argument|Fload
argument_list|,
argument|Sload
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|"sLoad file: "
argument_list|,
literal|"Execute a file of Lisp code named FILE.\n\ First tries FILE with .elc appended, then tries with .el,\n\  then tries FILE unmodified.  Searches directories in  load-path.\n\ If optional second arg MISSING-OK is non-nil,\n\  report no error if FILE doesn't exist.\n\ Print messages at start and end of loading unless\n\  optional third arg NOMESSAGE is non-nil.\n\ Return t if file exists."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|,
name|missing_ok
operator|,
name|nomessage
operator|)
name|Lisp_Object
name|str
operator|,
name|missing_ok
operator|,
name|nomessage
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|register
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|Lisp_Object
name|lispstream
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
name|Fsubstitute_in_file_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Avoid weird lossage with null string as arg,      since it would try to load a directory as a Lisp file */
if|if
condition|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|fd
operator|=
name|openp
argument_list|(
name|Vload_path
argument_list|,
name|str
argument_list|,
literal|".elc"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|fd
operator|=
name|openp
argument_list|(
name|Vload_path
argument_list|,
name|str
argument_list|,
literal|".el"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|fd
operator|=
name|openp
argument_list|(
name|Vload_path
argument_list|,
name|str
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
if|if
condition|(
name|NULL
argument_list|(
name|missing_ok
argument_list|)
condition|)
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qfile_error
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|"Cannot open load file"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|str
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|Qnil
return|;
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Failure to create stdio stream for %s"
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|XSET
argument_list|(
name|lispstream
argument_list|,
name|Lisp_Internal_Stream
argument_list|,
operator|(
name|int
operator|)
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|nomessage
argument_list|)
condition|)
name|message
argument_list|(
literal|"Loading %s..."
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|GCPRO1
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|load_unwind
argument_list|,
name|lispstream
argument_list|)
expr_stmt|;
name|load_in_progress
operator|=
literal|1
expr_stmt|;
name|readevalloop
argument_list|(
name|Qget_file_char
argument_list|,
name|stream
argument_list|,
name|Feval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
operator|!
name|noninteractive
operator|&&
name|NULL
argument_list|(
name|nomessage
argument_list|)
condition|)
name|message
argument_list|(
literal|"Loading %s...done"
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_comment
comment|/* exec_only nonzero means don't open the files,    just look for one that is executable;    returns 1 on success, having stored a string into *storeptr  */
end_comment

begin_function
name|int
name|openp
parameter_list|(
name|path
parameter_list|,
name|str
parameter_list|,
name|suffix
parameter_list|,
name|storeptr
parameter_list|,
name|exec_only
parameter_list|)
name|Lisp_Object
name|path
decl_stmt|,
name|str
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|Lisp_Object
modifier|*
name|storeptr
decl_stmt|;
name|int
name|exec_only
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|fn_size
init|=
literal|100
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|fn
init|=
name|buf
decl_stmt|;
name|int
name|absolute
init|=
literal|0
decl_stmt|;
name|int
name|want_size
decl_stmt|;
specifier|register
name|Lisp_Object
name|filename
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|storeptr
condition|)
operator|*
name|storeptr
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|*
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|==
literal|'~'
operator|||
operator|*
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|==
literal|'/'
condition|)
name|absolute
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|path
argument_list|)
condition|;
name|path
operator|=
name|Fcdr
argument_list|(
name|path
argument_list|)
control|)
block|{
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|str
argument_list|,
name|Fcar
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|want_size
operator|=
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|size
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fn_size
operator|<
name|want_size
condition|)
name|fn
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|fn_size
operator|=
literal|100
operator|+
name|want_size
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fn
argument_list|,
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|fn
index|[
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|fn
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_only
condition|)
block|{
if|if
condition|(
operator|!
name|access
argument_list|(
name|fn
argument_list|,
name|X_OK
argument_list|)
operator|&&
name|stat
argument_list|(
name|fn
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
if|if
condition|(
name|storeptr
condition|)
operator|*
name|storeptr
operator|=
name|build_string
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
name|fd
operator|=
name|open
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|storeptr
condition|)
operator|*
name|storeptr
operator|=
name|build_string
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
block|}
if|if
condition|(
name|absolute
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|load_unwind
parameter_list|(
name|stream
parameter_list|)
comment|/* used as unwind-protect function in load */
name|Lisp_Object
name|stream
decl_stmt|;
block|{
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|XSTRING
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|load_in_progress
operator|=
literal|0
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|unreadpure
parameter_list|()
comment|/* Used as unwind-protect function in readevalloop */
block|{
name|read_pure
operator|=
literal|0
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_decl_stmt
name|void
name|readevalloop
argument_list|(
name|readcharfun
argument_list|,
name|stream
argument_list|,
name|evalfun
argument_list|,
name|printflag
argument_list|)
name|Lisp_Object
name|readcharfun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
function_decl|(
modifier|*
name|evalfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|printflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|xunrch
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|specbind
argument_list|(
name|Qstandard_input
argument_list|,
name|readcharfun
argument_list|)
expr_stmt|;
name|unrch
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|instream
operator|=
name|stream
expr_stmt|;
name|c
operator|=
name|READCHAR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|READCHAR
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\f'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
operator|&&
name|c
operator|==
literal|'('
condition|)
block|{
name|record_unwind_protect
argument_list|(
name|unreadpure
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_list
argument_list|(
operator|-
literal|1
argument_list|,
name|readcharfun
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNREAD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|val
operator|=
name|read0
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
block|}
name|xunrch
operator|=
name|unrch
expr_stmt|;
name|unrch
operator|=
operator|-
literal|1
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|evalfun
call|)
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|printflag
condition|)
block|{
name|Vvalues
operator|=
name|Fcons
argument_list|(
name|val
argument_list|,
name|Vvalues
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|Vstandard_output
argument_list|,
name|Qt
argument_list|)
condition|)
name|Fprin1
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
name|Fprint
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
name|unrch
operator|=
name|xunrch
expr_stmt|;
block|}
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_macro
name|DEFUN
argument_list|(
literal|"eval-current-buffer"
argument_list|,
argument|Feval_current_buffer
argument_list|,
argument|Seval_current_buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Execute the current buffer as Lisp code.\n\ Programs can pass argument PRINTFLAG which controls printing of output:\n\ nil means discard it; anything else is stream for print."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|printflag
operator|)
name|Lisp_Object
name|printflag
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printflag
argument_list|)
condition|)
name|tem
operator|=
name|Qsymbolp
expr_stmt|;
else|else
name|tem
operator|=
name|printflag
expr_stmt|;
name|specbind
argument_list|(
name|Qstandard_output
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|save_excursion_restore
argument_list|,
name|save_excursion_save
argument_list|()
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|FirstCharacter
argument_list|)
expr_stmt|;
name|readevalloop
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Feval
argument_list|,
operator|!
name|NULL
argument_list|(
name|printflag
argument_list|)
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"eval-region"
argument_list|,
argument|Feval_region
argument_list|,
argument|Seval_region
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"r"
argument_list|,
literal|"Execute the region as Lisp code.\n\ When called from programs, expects two arguments,\n\ giving starting and ending indices in the current buffer\n\ of the text to be executed.\n\ Programs can pass third argument PRINTFLAG which controls printing of output:\n\ nil means discard it; anything else is stream for print."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|,
name|printflag
operator|)
name|Lisp_Object
name|b
operator|,
name|e
operator|,
name|printflag
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printflag
argument_list|)
condition|)
name|tem
operator|=
name|Qsymbolp
expr_stmt|;
else|else
name|tem
operator|=
name|printflag
expr_stmt|;
name|specbind
argument_list|(
name|Qstandard_output
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|printflag
argument_list|)
condition|)
name|record_unwind_protect
argument_list|(
name|save_excursion_restore
argument_list|,
name|save_excursion_save
argument_list|()
argument_list|)
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|save_restriction_restore
argument_list|,
name|save_restriction_save
argument_list|()
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|XINT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|Fnarrow_to_region
argument_list|(
name|make_number
argument_list|(
name|FirstCharacter
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|readevalloop
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Feval
argument_list|,
operator|!
name|NULL
argument_list|(
name|printflag
argument_list|)
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|standalone
end_endif

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"read"
argument_list|,
argument|Fread
argument_list|,
argument|Sread
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Read one Lisp expression as text from STREAM, return as Lisp object.\n\ If STREAM is nil, use the value of standard-input (which see).\n\ STREAM or standard-input may be:\n\  a buffer (read from point and advance it)\n\  a marker (read from where it points and advance it)\n\  a function (call it with no arguments for each character)\n\  a string (takes text from string, starting at the beginning)\n\  t (read text line using minibuffer and use it)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|readcharfun
operator|)
name|Lisp_Object
name|readcharfun
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|Lisp_Object
name|Fread_minibuffer
parameter_list|()
function_decl|;
name|unrch
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allow buffering-back only within a read. */
if|if
condition|(
name|NULL
argument_list|(
name|readcharfun
argument_list|)
condition|)
name|readcharfun
operator|=
name|Vstandard_input
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|readcharfun
argument_list|,
name|Qt
argument_list|)
condition|)
name|readcharfun
operator|=
name|Qread_char
expr_stmt|;
ifndef|#
directive|ifndef
name|standalone
if|if
condition|(
name|EQ
argument_list|(
name|readcharfun
argument_list|,
name|Qread_char
argument_list|)
condition|)
return|return
name|Fread_minibuffer
argument_list|(
name|build_string
argument_list|(
literal|"Lisp expression: "
argument_list|)
argument_list|,
name|Qnil
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|XTYPE
argument_list|(
name|readcharfun
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Fcar
argument_list|(
name|Fread_from_string
argument_list|(
name|readcharfun
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
return|return
name|read0
argument_list|(
name|readcharfun
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-from-string"
argument_list|,
argument|Fread_from_string
argument_list|,
argument|Sread_from_string
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Read one Lisp expression which is represented as text by STRING.\n\ Returns a cons: (OBJECT-READ . FINAL-STRING-INDEX).\n\ START and END optionally delimit a substring of STRING from which to read;\n\  they default to 0 and (length STRING) respectively."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|start
operator|,
name|end
operator|)
name|Lisp_Object
name|string
operator|,
name|start
operator|,
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|startval
decl_stmt|,
name|endval
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|end
argument_list|)
condition|)
name|endval
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER
argument_list|(
name|end
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|endval
operator|=
name|XINT
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|endval
operator|<
literal|0
operator|||
name|endval
operator|>
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
condition|)
name|args_out_of_range
argument_list|(
name|string
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|start
argument_list|)
condition|)
name|startval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|startval
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|startval
operator|<
literal|0
operator|||
name|startval
operator|>
name|endval
condition|)
name|args_out_of_range
argument_list|(
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
name|read_from_string_index
operator|=
name|startval
expr_stmt|;
name|read_from_string_limit
operator|=
name|endval
expr_stmt|;
name|unrch
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allow buffering-back only within a read. */
name|tem
operator|=
name|read0
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|tem
argument_list|,
name|make_number
argument_list|(
name|read_from_string_index
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Use this for recursive reads, in contexts where internal tokens are not allowed. */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|read0
parameter_list|(
name|readcharfun
parameter_list|)
name|Lisp_Object
name|readcharfun
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|char
name|c
decl_stmt|;
name|val
operator|=
name|read1
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|val
argument_list|)
operator|==
name|Lisp_Internal
condition|)
block|{
name|c
operator|=
name|XINT
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|Fsignal
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Fcons
argument_list|(
name|make_string
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|read_buffer_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_buffer
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Lisp_Object
name|read1
parameter_list|(
name|readcharfun
parameter_list|)
specifier|register
name|Lisp_Object
name|readcharfun
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|retry
label|:
name|c
operator|=
name|READCHAR
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
name|Fsignal
argument_list|(
name|Qend_of_file
argument_list|,
name|Qnil
argument_list|)
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
return|return
name|read_list
argument_list|(
literal|0
argument_list|,
name|readcharfun
argument_list|)
return|;
case|case
literal|'['
case|:
return|return
name|read_vector
argument_list|(
name|readcharfun
argument_list|)
return|;
case|case
literal|')'
case|:
case|case
literal|']'
case|:
case|case
literal|'.'
case|:
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Internal
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
case|case
literal|'#'
case|:
return|return
name|Fsignal
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Fcons
argument_list|(
name|make_string
argument_list|(
literal|"#"
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
case|case
literal|';'
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|READCHAR
operator|)
operator|>=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'\''
case|:
block|{
return|return
name|Fcons
argument_list|(
name|Qquote
argument_list|,
name|Fcons
argument_list|(
name|read0
argument_list|(
name|readcharfun
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|'?'
case|:
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|READCHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|==
literal|'\\'
condition|)
name|XSETINT
argument_list|(
name|val
argument_list|,
name|read_escape
argument_list|(
name|readcharfun
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
case|case
literal|'\"'
case|:
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|read_buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|read_buffer
operator|+
name|read_buffer_size
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|cancel
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|READCHAR
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|c
operator|!=
literal|'\"'
operator|||
operator|(
name|c
operator|=
name|READCHAR
operator|)
operator|==
literal|'\"'
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|read_buffer
argument_list|,
name|read_buffer_size
operator|*=
literal|2
argument_list|)
decl_stmt|;
name|p
operator|+=
name|new
operator|-
name|read_buffer
expr_stmt|;
name|read_buffer
operator|+=
name|new
operator|-
name|read_buffer
expr_stmt|;
name|end
operator|=
name|read_buffer
operator|+
name|read_buffer_size
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|read_escape
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
comment|/* c is -1 if \ newline has just been seen */
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|read_buffer
condition|)
name|cancel
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|UNREAD
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* If purifying, and string starts with \ newline, 	   return zero instead.  This is for doc strings 	   that we are really going to find in etc/DOC.nn.nn  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
operator|&&
name|NULL
argument_list|(
name|Vdoc_file_name
argument_list|)
operator|&&
name|cancel
condition|)
return|return
name|make_number
argument_list|(
literal|0
argument_list|)
return|;
if|if
condition|(
name|read_pure
condition|)
return|return
name|make_pure_string
argument_list|(
name|read_buffer
argument_list|,
name|p
operator|-
name|read_buffer
argument_list|)
return|;
else|else
return|return
name|make_string
argument_list|(
name|read_buffer
argument_list|,
name|p
operator|-
name|read_buffer
argument_list|)
return|;
block|}
default|default:
if|if
condition|(
name|c
operator|<=
literal|040
condition|)
goto|goto
name|retry
goto|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|read_buffer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|end
init|=
name|read_buffer
operator|+
name|read_buffer_size
decl_stmt|;
while|while
condition|(
name|c
operator|>
literal|040
operator|&&
operator|!
operator|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'#'
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
specifier|register
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|read_buffer
argument_list|,
name|read_buffer_size
operator|*=
literal|2
argument_list|)
decl_stmt|;
name|p
operator|+=
name|new
operator|-
name|read_buffer
expr_stmt|;
name|read_buffer
operator|+=
name|new
operator|-
name|read_buffer
expr_stmt|;
name|end
operator|=
name|read_buffer
operator|+
name|read_buffer_size
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|READCHAR
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|READCHAR
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|read_buffer
argument_list|,
name|read_buffer_size
operator|*=
literal|2
argument_list|)
decl_stmt|;
name|p
operator|+=
name|new
operator|-
name|read_buffer
expr_stmt|;
name|read_buffer
operator|+=
name|new
operator|-
name|read_buffer
expr_stmt|;
name|end
operator|=
name|read_buffer
operator|+
name|read_buffer_size
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|UNREAD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Is it an integer? */
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|p1
operator|=
name|read_buffer
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|==
literal|'+'
operator|||
operator|*
name|p1
operator|==
literal|'-'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|p
condition|)
block|{
while|while
condition|(
name|p1
operator|!=
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p1
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
condition|)
comment|/* It is. */
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|atoi
argument_list|(
name|read_buffer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
block|}
return|return
name|intern
argument_list|(
name|read_buffer
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|Lisp_Object
name|read_vector
parameter_list|(
name|readcharfun
parameter_list|)
name|Lisp_Object
name|readcharfun
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|,
name|vector
decl_stmt|;
specifier|register
name|struct
name|Lisp_Cons
modifier|*
name|otem
decl_stmt|;
name|Lisp_Object
name|len
decl_stmt|;
name|tem
operator|=
name|read_list
argument_list|(
literal|1
argument_list|,
name|readcharfun
argument_list|)
expr_stmt|;
name|len
operator|=
name|Flength
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|vector
operator|=
operator|(
name|read_pure
condition|?
name|make_pure_vector
argument_list|(
name|XINT
argument_list|(
name|len
argument_list|)
argument_list|)
else|:
name|Fmake_vector
argument_list|(
name|len
argument_list|,
name|Qnil
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|size
expr_stmt|;
name|ptr
operator|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ptr
index|[
name|i
index|]
operator|=
name|read_pure
condition|?
name|Fpurecopy
argument_list|(
name|Fcar
argument_list|(
name|tem
argument_list|)
argument_list|)
else|:
name|Fcar
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|otem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|free_cons
argument_list|(
name|otem
argument_list|)
expr_stmt|;
block|}
return|return
name|vector
return|;
block|}
end_function

begin_comment
comment|/* flag = 1 means check for ] to terminate rather than ) and .    flag = -1 means check for starting with defun     and make structure pure.  */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|read_list
parameter_list|(
name|flag
parameter_list|,
name|readcharfun
parameter_list|)
name|int
name|flag
decl_stmt|;
specifier|register
name|Lisp_Object
name|readcharfun
decl_stmt|;
block|{
comment|/* -1 means check next element for defun,      0 means don't check,      1 means already checked and found defun. */
name|int
name|defunflag
init|=
name|flag
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
specifier|register
name|Lisp_Object
name|elt
decl_stmt|,
name|val
decl_stmt|,
name|tail
decl_stmt|,
name|tem
decl_stmt|;
name|val
operator|=
name|Qnil
expr_stmt|;
name|tail
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|elt
operator|=
name|read1
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Internal
condition|)
block|{
if|if
condition|(
name|flag
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|XINT
argument_list|(
name|elt
argument_list|)
operator|==
literal|']'
condition|)
return|return
name|val
return|;
return|return
name|Fsignal
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Fcons
argument_list|(
name|make_string
argument_list|(
literal|") or . in a vector"
argument_list|,
literal|18
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|XINT
argument_list|(
name|elt
argument_list|)
operator|==
literal|')'
condition|)
return|return
name|val
return|;
if|if
condition|(
name|XINT
argument_list|(
name|elt
argument_list|)
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
operator|=
name|read0
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|read0
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
name|elt
operator|=
name|read1
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Internal
operator|&&
name|XINT
argument_list|(
name|elt
argument_list|)
operator|==
literal|')'
condition|)
return|return
name|val
return|;
return|return
name|Fsignal
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Fcons
argument_list|(
name|make_string
argument_list|(
literal|". in wrong context"
argument_list|,
literal|18
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Fsignal
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Fcons
argument_list|(
name|make_string
argument_list|(
literal|"] in a vector"
argument_list|,
literal|13
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
name|tem
operator|=
operator|(
name|read_pure
operator|&&
name|flag
operator|<=
literal|0
condition|?
name|pure_cons
argument_list|(
name|elt
argument_list|,
name|Qnil
argument_list|)
else|:
name|Fcons
argument_list|(
name|elt
argument_list|,
name|Qnil
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
operator|=
name|tem
expr_stmt|;
else|else
name|val
operator|=
name|tem
expr_stmt|;
name|tail
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|defunflag
operator|<
literal|0
condition|)
name|defunflag
operator|=
name|EQ
argument_list|(
name|elt
argument_list|,
name|Qdefun
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defunflag
operator|>
literal|0
condition|)
name|read_pure
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|read_escape
parameter_list|(
name|readcharfun
parameter_list|)
name|Lisp_Object
name|readcharfun
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|READCHAR
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
literal|'\a'
return|;
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'e'
case|:
return|return
literal|033
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'v'
case|:
return|return
literal|'\v'
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'M'
case|:
name|c
operator|=
name|READCHAR
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'-'
condition|)
name|error
argument_list|(
literal|"Invalid escape character syntax"
argument_list|)
expr_stmt|;
name|c
operator|=
name|READCHAR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|read_escape
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
return|return
name|c
operator||
literal|0200
return|;
case|case
literal|'C'
case|:
name|c
operator|=
name|READCHAR
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'-'
condition|)
name|error
argument_list|(
literal|"Invalid escape character syntax"
argument_list|)
expr_stmt|;
case|case
literal|'^'
case|:
name|c
operator|=
name|READCHAR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|read_escape
argument_list|(
name|readcharfun
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
return|return
literal|0177
return|;
return|return
operator|(
name|c
operator|&
literal|0200
operator|)
operator||
operator|(
name|c
operator|&
literal|037
operator|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
specifier|register
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|READCHAR
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|*=
literal|8
expr_stmt|;
name|i
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|UNREAD
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
default|default:
return|return
name|c
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|Lisp_Object
name|Vobarray
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|initial_obarray
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CHECK_OBARRAY assumes the variable `tem' is available */
end_comment

begin_define
define|#
directive|define
name|CHECK_OBARRAY
parameter_list|(
name|obarray
parameter_list|)
define|\
value|if (XTYPE (obarray) != Lisp_Vector) \     { tem = obarray; obarray = initial_obarray; \       wrong_type_argument (Qvectorp, tem); }
end_define

begin_function_decl
specifier|static
name|int
name|hash_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|oblookup
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Lisp_Object
name|intern
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|CHECK_OBARRAY
argument_list|(
name|Vobarray
argument_list|)
expr_stmt|;
name|tem
operator|=
name|oblookup
argument_list|(
name|Vobarray
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
return|return
name|tem
return|;
return|return
name|Fintern
argument_list|(
operator|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|?
name|make_pure_string
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
else|:
name|make_string
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
operator|)
argument_list|,
name|Vobarray
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"intern"
argument_list|,
argument|Fintern
argument_list|,
argument|Sintern
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the symbol whose name is STRING.\n\ A second optional argument specifies the obarray to use;\n\ it defaults to the value of  obarray."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|,
name|obarray
operator|)
name|Lisp_Object
name|str
operator|,
name|obarray
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|,
name|sym
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|obarray
argument_list|)
condition|)
block|{
name|CHECK_OBARRAY
argument_list|(
name|Vobarray
argument_list|)
expr_stmt|;
name|obarray
operator|=
name|Vobarray
expr_stmt|;
block|}
else|else
name|CHECK_VECTOR
argument_list|(
name|obarray
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|oblookup
argument_list|(
name|obarray
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|!=
name|Lisp_Int
condition|)
return|return
name|tem
return|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|str
operator|=
name|Fpurecopy
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|sym
operator|=
name|Fmake_symbol
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|XVECTOR
argument_list|(
name|obarray
argument_list|)
operator|->
name|contents
index|[
name|XINT
argument_list|(
name|tem
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
operator|*
name|ptr
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|next
operator|=
name|XSYMBOL
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
else|else
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|ptr
operator|=
name|sym
expr_stmt|;
return|return
name|sym
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"intern-soft"
argument_list|,
argument|Fintern_soft
argument_list|,
argument|Sintern_soft
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the symbol whose name is STRING, or nil if none exists yet.\n\ A second optional argument specifies the obarray to use;\n\ it defaults to the value of  obarray."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|,
name|obarray
operator|)
name|Lisp_Object
name|str
operator|,
name|obarray
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|obarray
argument_list|)
condition|)
block|{
name|CHECK_OBARRAY
argument_list|(
name|Vobarray
argument_list|)
expr_stmt|;
name|obarray
operator|=
name|Vobarray
expr_stmt|;
block|}
else|else
name|CHECK_VECTOR
argument_list|(
name|obarray
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|oblookup
argument_list|(
name|obarray
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|!=
name|Lisp_Int
condition|)
return|return
name|tem
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|oblookup
parameter_list|(
name|obarray
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|Lisp_Object
name|obarray
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|,
name|obsize
decl_stmt|;
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
name|Lisp_Object
name|bucket
decl_stmt|,
name|tem
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|obarray
argument_list|)
operator|!=
name|Lisp_Vector
operator|||
operator|!
operator|(
name|obsize
operator|=
name|XVECTOR
argument_list|(
name|obarray
argument_list|)
operator|->
name|size
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid obarray"
argument_list|)
expr_stmt|;
name|hash
operator|=
name|hash_string
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
operator|%
name|obsize
expr_stmt|;
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|obarray
argument_list|)
operator|->
name|contents
index|[
name|hash
index|]
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|bucket
init|;
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
condition|;
name|XSETSYMBOL
argument_list|(
name|tail
argument_list|,
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|->
name|next
argument_list|)
control|)
block|{
if|if
condition|(
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|->
name|name
operator|->
name|size
operator|!=
name|size
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
condition|)
continue|continue;
return|return
name|tail
return|;
block|}
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Int
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hash_string
parameter_list|(
name|ptr
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|len
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0140
condition|)
name|c
operator|-=
literal|40
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
name|hash
operator|<<
literal|3
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|28
operator|)
operator|+
name|c
operator|)
expr_stmt|;
block|}
return|return
name|hash
operator|&
literal|07777777777
return|;
block|}
end_function

begin_decl_stmt
name|void
name|map_obarray
argument_list|(
name|obarray
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|)
name|Lisp_Object
name|obarray
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Lisp_Object
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
name|CHECK_VECTOR
argument_list|(
name|obarray
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XVECTOR
argument_list|(
name|obarray
argument_list|)
operator|->
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
for|for
control|(
name|tail
operator|=
name|XVECTOR
argument_list|(
name|obarray
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
init|;
name|XTYPE
argument_list|(
name|tail
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
condition|;
name|XSETSYMBOL
argument_list|(
name|tail
argument_list|,
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|->
name|next
argument_list|)
control|)
call|(
modifier|*
name|fn
call|)
argument_list|(
name|tail
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mapatoms_1
argument_list|(
argument|sym
argument_list|,
argument|function
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|sym
decl_stmt|,
name|function
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|call1
argument_list|(
name|function
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"mapatoms"
argument_list|,
argument|Fmapatoms
argument_list|,
argument|Smapatoms
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Call FUNCTION on every symbol in OBARRAY.\n\ OBARRAY defaults to the value of  obarray."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|function
operator|,
name|obarray
operator|)
name|Lisp_Object
name|function
operator|,
name|obarray
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|obarray
argument_list|)
condition|)
block|{
name|CHECK_OBARRAY
argument_list|(
name|Vobarray
argument_list|)
expr_stmt|;
name|obarray
operator|=
name|Vobarray
expr_stmt|;
block|}
else|else
name|CHECK_VECTOR
argument_list|(
name|obarray
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|map_obarray
argument_list|(
name|obarray
argument_list|,
name|mapatoms_1
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_define
define|#
directive|define
name|OBARRAY_SIZE
value|511
end_define

begin_function
name|void
name|init_obarray
parameter_list|()
block|{
name|Lisp_Object
name|oblength
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|Lisp_Object
modifier|*
name|tem
decl_stmt|;
name|XFASTINT
argument_list|(
name|oblength
argument_list|)
operator|=
name|OBARRAY_SIZE
expr_stmt|;
name|Qnil
operator|=
name|Fmake_symbol
argument_list|(
name|make_pure_string
argument_list|(
literal|"nil"
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|Vobarray
operator|=
name|Fmake_vector
argument_list|(
name|oblength
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initial_obarray
operator|=
name|Vobarray
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vobarray
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|initial_obarray
argument_list|)
expr_stmt|;
comment|/* Intern nil in the obarray */
comment|/* These locals are to kludge around a pyramid compiler bug. */
name|hash
operator|=
name|hash_string
argument_list|(
literal|"nil"
argument_list|,
literal|3
argument_list|)
operator|%
name|OBARRAY_SIZE
expr_stmt|;
name|tem
operator|=
operator|&
name|XVECTOR
argument_list|(
name|Vobarray
argument_list|)
operator|->
name|contents
index|[
name|hash
index|]
expr_stmt|;
operator|*
name|tem
operator|=
name|Qnil
expr_stmt|;
name|Qunbound
operator|=
name|Fmake_symbol
argument_list|(
name|make_pure_string
argument_list|(
literal|"unbound"
argument_list|,
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
operator|->
name|function
operator|=
name|Qunbound
expr_stmt|;
name|XSYMBOL
argument_list|(
name|Qunbound
argument_list|)
operator|->
name|value
operator|=
name|Qunbound
expr_stmt|;
name|XSYMBOL
argument_list|(
name|Qunbound
argument_list|)
operator|->
name|function
operator|=
name|Qunbound
expr_stmt|;
name|Qt
operator|=
name|intern
argument_list|(
literal|"t"
argument_list|)
expr_stmt|;
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
operator|->
name|value
operator|=
name|Qnil
expr_stmt|;
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
operator|->
name|plist
operator|=
name|Qnil
expr_stmt|;
name|XSYMBOL
argument_list|(
name|Qt
argument_list|)
operator|->
name|value
operator|=
name|Qt
expr_stmt|;
name|Qvariable_documentation
operator|=
name|intern
argument_list|(
literal|"variable-documentation"
argument_list|)
expr_stmt|;
name|read_buffer_size
operator|=
literal|100
expr_stmt|;
name|read_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|read_buffer_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|defsubr
parameter_list|(
name|sname
parameter_list|)
name|struct
name|Lisp_Subr
modifier|*
name|sname
decl_stmt|;
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|intern
argument_list|(
name|sname
operator|->
name|symbol_name
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|Lisp_Subr
argument_list|,
name|sname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|defalias
parameter_list|(
name|sname
parameter_list|,
name|string
parameter_list|)
name|struct
name|Lisp_Subr
modifier|*
name|sname
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|intern
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|Lisp_Subr
argument_list|,
name|sname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define an "integer variable"; a symbol whose value is forwarded  to a C variable of type int.  Sample call is DefIntVar ("indent-tabs-mode",&indent_tabs_mode, "Documentation");  */
end_comment

begin_function
name|void
name|DefIntVar
parameter_list|(
name|namestring
parameter_list|,
name|address
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
modifier|*
name|address
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|;
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|intern
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Lisp_Intfwd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|sym
argument_list|,
name|Qvariable_documentation
argument_list|,
name|make_pure_string
argument_list|(
name|doc
argument_list|,
name|strlen
argument_list|(
name|doc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar but define a variable whose value is T if address contains 1,  NIL if address contains 0 */
end_comment

begin_function
name|void
name|DefBoolVar
parameter_list|(
name|namestring
parameter_list|,
name|address
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
modifier|*
name|address
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|;
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|intern
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Lisp_Boolfwd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|sym
argument_list|,
name|Qvariable_documentation
argument_list|,
name|make_pure_string
argument_list|(
name|doc
argument_list|,
name|strlen
argument_list|(
name|doc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar but define a variable whose value is the Lisp Object stored at address. */
end_comment

begin_function
name|void
name|DefLispVar
parameter_list|(
name|namestring
parameter_list|,
name|address
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|namestring
decl_stmt|;
name|Lisp_Object
modifier|*
name|address
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|;
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|intern
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Lisp_Objfwd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|sym
argument_list|,
name|Qvariable_documentation
argument_list|,
name|make_pure_string
argument_list|(
name|doc
argument_list|,
name|strlen
argument_list|(
name|doc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_comment
comment|/* Similar but define a variable whose value is the Lisp Object stored in  the current buffer.  address is the address of the slot in the buffer that is current now. */
end_comment

begin_function
name|void
name|DefBufferLispVar
parameter_list|(
name|namestring
parameter_list|,
name|address
parameter_list|,
name|doc
parameter_list|)
name|char
modifier|*
name|namestring
decl_stmt|;
name|Lisp_Object
modifier|*
name|address
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|;
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|intern
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Lisp_Buffer_Objfwd
argument_list|,
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|address
operator|-
operator|(
name|char
operator|*
operator|)
name|bf_cur
operator|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|sym
argument_list|,
name|Qvariable_documentation
argument_list|,
name|make_pure_string
argument_list|(
name|doc
argument_list|,
name|strlen
argument_list|(
name|doc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|standalone
end_endif

begin_escape
end_escape

begin_macro
name|init_read
argument_list|()
end_macro

begin_block
block|{
name|Vvalues
operator|=
name|Qnil
expr_stmt|;
name|Vload_path
operator|=
name|decode_env_path
argument_list|(
literal|"EMACSLOADPATH"
argument_list|,
name|PATH_LOADSEARCH
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CANNOT_DUMP
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|Vload_path
operator|=
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|"../lisp"
argument_list|)
argument_list|,
name|Vload_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not CANNOT_DUMP */
block|}
end_block

begin_function
name|void
name|syms_of_read
parameter_list|()
block|{
name|defsubr
argument_list|(
operator|&
name|Sread
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_from_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sintern
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sintern_soft
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sload
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seval_current_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seval_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_file_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smapatoms
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"obarray"
argument_list|,
operator|&
name|Vobarray
argument_list|,
literal|"Symbol table for use by  intern  and  read.\n\ It is a vector whose length ought to be prime for best results.\n\ Each element is a list of all interned symbols whose names hash in that bucket."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"values"
argument_list|,
operator|&
name|Vvalues
argument_list|,
literal|"List of values of all expressions which were read, evaluated and printed.\n\ Order is reverse chronological."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"standard-input"
argument_list|,
operator|&
name|Vstandard_input
argument_list|,
literal|"Stream for read to get input from.\n\ See documentation of read for possible values."
argument_list|)
expr_stmt|;
name|Vstandard_input
operator|=
name|Qt
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"load-path"
argument_list|,
operator|&
name|Vload_path
argument_list|,
literal|"*List of directories to search for files to load.\n\ Each element is a string (directory name) or nil (try default directory).\n\ Initialized based on EMACSLOADPATH environment variable, if any,\n\ otherwise to default specified in by file paths.h when emacs was built."
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"load-in-progress"
argument_list|,
operator|&
name|load_in_progress
argument_list|,
literal|"Non-nil iff inside of  load."
argument_list|)
expr_stmt|;
name|Qstandard_input
operator|=
name|intern
argument_list|(
literal|"standard-input"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qstandard_input
argument_list|)
expr_stmt|;
name|Qread_char
operator|=
name|intern
argument_list|(
literal|"read-char"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qread_char
argument_list|)
expr_stmt|;
name|Qget_file_char
operator|=
name|intern
argument_list|(
literal|"get-file-char"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qget_file_char
argument_list|)
expr_stmt|;
name|unrch
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

end_unit

