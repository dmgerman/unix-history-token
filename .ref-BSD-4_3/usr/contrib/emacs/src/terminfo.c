begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interface from Emacs to terminfo.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* This is to avoid need to conditionalize interface to termcap.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
name|char
name|UP
decl_stmt|,
name|BC
decl_stmt|,
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
end_ifdef

begin_macro
name|tparam
argument_list|(
argument|string
argument_list|,
argument|outstring
argument_list|,
argument|arg0
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|,
argument|arg6
argument_list|,
argument|arg7
argument_list|,
argument|arg8
argument_list|,
argument|arg9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|,
name|arg5
decl_stmt|,
name|arg6
decl_stmt|,
name|arg7
decl_stmt|,
name|arg8
decl_stmt|,
name|arg9
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|argp
index|[
literal|10
index|]
decl_stmt|;
name|argp
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
name|argp
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|argp
index|[
literal|3
index|]
operator|=
name|arg3
expr_stmt|;
name|argp
index|[
literal|4
index|]
operator|=
name|arg4
expr_stmt|;
name|argp
index|[
literal|5
index|]
operator|=
name|arg5
expr_stmt|;
name|argp
index|[
literal|6
index|]
operator|=
name|arg6
expr_stmt|;
name|argp
index|[
literal|7
index|]
operator|=
name|arg7
expr_stmt|;
name|argp
index|[
literal|8
index|]
operator|=
name|arg8
expr_stmt|;
name|argp
index|[
literal|9
index|]
operator|=
name|arg9
expr_stmt|;
name|tparam1
argument_list|(
name|string
argument_list|,
name|outstring
argument_list|,
operator|&
name|argp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no NO_ARG_ARRAY */
end_comment

begin_macro
name|tparam
argument_list|(
argument|string
argument_list|,
argument|outstring
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tparam1
argument_list|(
name|string
argument_list|,
name|outstring
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no NO_ARG_ARRAY */
end_comment

begin_define
define|#
directive|define
name|todigit
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_comment
comment|/* Virtual TERMINFO machine */
end_comment

begin_define
define|#
directive|define
name|TO_REG
parameter_list|(
name|c
parameter_list|)
value|(((int) c) - ((int) 'a'))
end_define

begin_define
define|#
directive|define
name|REG
parameter_list|(
name|c
parameter_list|)
value|the_registers[TO_REG (c)]
end_define

begin_define
define|#
directive|define
name|PUSH
parameter_list|(
name|x
parameter_list|)
value|*--sp = ((int) x);
end_define

begin_define
define|#
directive|define
name|POP
parameter_list|()
value|*sp++
end_define

begin_define
define|#
directive|define
name|UN_OP
parameter_list|(
name|op
parameter_list|)
define|\
value|*sp = op (*sp);			\ continue
end_define

begin_define
define|#
directive|define
name|BIN_OP
parameter_list|(
name|op
parameter_list|)
define|\
value|sp[1] = ((sp[0]) op (sp[1]));	\ sp += 1;			\ continue
end_define

begin_define
define|#
directive|define
name|SEND
parameter_list|(
name|c
parameter_list|)
define|\
value|*outstring++ = ((char) c);	\ continue
end_define

begin_define
define|#
directive|define
name|SSEND
parameter_list|(
name|f
parameter_list|)
define|\
value|sprintf (outstring, f, POP ());	\ while (*outstring++ != '\0') ;	\ outstring -= 1;			\ continue
end_define

begin_expr_stmt
name|tparam1
argument_list|(
name|string
argument_list|,
name|outstring
argument_list|,
name|argp
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|outstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|the_registers
index|[
name|TO_REG
argument_list|(
literal|'z'
argument_list|)
index|]
decl_stmt|;
name|long
name|the_stack
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|long
modifier|*
name|sp
init|=
operator|&
name|the_stack
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|string
operator|++
condition|)
block|{
case|case
literal|'%'
case|:
name|SEND
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
name|SSEND
argument_list|(
literal|"%d"
argument_list|)
expr_stmt|;
case|case
literal|'2'
case|:
name|string
operator|+=
literal|1
expr_stmt|;
name|SSEND
argument_list|(
literal|"%2d"
argument_list|)
expr_stmt|;
case|case
literal|'3'
case|:
name|string
operator|+=
literal|1
expr_stmt|;
name|SSEND
argument_list|(
literal|"%3d"
argument_list|)
expr_stmt|;
case|case
literal|'0'
case|:
name|c
operator|=
operator|*
name|string
expr_stmt|;
name|string
operator|+=
literal|2
expr_stmt|;
name|SSEND
argument_list|(
operator|(
name|c
operator|==
literal|'2'
operator|)
condition|?
literal|"%02d"
else|:
literal|"%03d"
argument_list|)
expr_stmt|;
case|case
literal|'c'
case|:
name|SEND
argument_list|(
operator|(
operator|(
name|char
operator|)
name|POP
argument_list|()
operator|)
argument_list|)
expr_stmt|;
case|case
literal|'s'
case|:
name|SSEND
argument_list|(
literal|"%s"
argument_list|)
expr_stmt|;
case|case
literal|'p'
case|:
name|PUSH
argument_list|(
name|argp
index|[
operator|(
name|todigit
argument_list|(
operator|*
name|string
operator|++
argument_list|)
operator|)
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
name|REG
argument_list|(
operator|*
name|string
operator|++
argument_list|)
operator|=
name|POP
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
name|PUSH
argument_list|(
name|REG
argument_list|(
operator|*
name|string
operator|++
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
name|PUSH
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
name|string
operator|+=
literal|2
expr_stmt|;
continue|continue;
case|case
literal|'{'
case|:
block|{
name|int
name|temp
decl_stmt|;
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|temp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|string
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
continue|continue;
block|}
case|case
literal|'+'
case|:
name|BIN_OP
argument_list|(
operator|+
argument_list|)
expr_stmt|;
case|case
literal|'-'
case|:
name|BIN_OP
argument_list|(
operator|-
argument_list|)
expr_stmt|;
case|case
literal|'*'
case|:
name|BIN_OP
argument_list|(
operator|*
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
name|BIN_OP
argument_list|(
operator|/
argument_list|)
expr_stmt|;
case|case
literal|'m'
case|:
name|BIN_OP
argument_list|(
operator|%
argument_list|)
expr_stmt|;
case|case
literal|'&'
case|:
name|BIN_OP
argument_list|(
operator|&
argument_list|)
expr_stmt|;
case|case
literal|'|'
case|:
name|BIN_OP
argument_list|(
operator||
argument_list|)
expr_stmt|;
case|case
literal|'^'
case|:
name|BIN_OP
argument_list|(
operator|^
argument_list|)
expr_stmt|;
case|case
literal|'='
case|:
name|BIN_OP
argument_list|(
operator|=
argument_list|)
expr_stmt|;
case|case
literal|'<'
case|:
name|BIN_OP
argument_list|(
operator|<
argument_list|)
expr_stmt|;
case|case
literal|'>'
case|:
name|BIN_OP
argument_list|(
operator|<
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|UN_OP
argument_list|(
operator|!
argument_list|)
expr_stmt|;
case|case
literal|'~'
case|:
name|UN_OP
argument_list|(
operator|~
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
name|argp
index|[
literal|0
index|]
operator|+=
literal|1
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'?'
case|:
case|case
literal|'t'
case|:
case|case
literal|'e'
case|:
case|case
literal|';'
case|:
default|default:
continue|continue;
block|}
comment|/* switch for % */
default|default:
name|SEND
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* outer switch  */
operator|*
name|outstring
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* tparam1 */
end_comment

end_unit

