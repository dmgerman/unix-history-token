begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simple built-in editing commands.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_decl_stmt
name|Lisp_Object
name|Qkill_forward_chars
decl_stmt|,
name|Qkill_backward_chars
decl_stmt|,
name|Vblink_paren_hook
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"forward-char"
argument_list|,
argument|Fforward_char
argument_list|,
argument|Sforward_char
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Move point right ARG characters (left if ARG negative).\n\ On reaching end of buffer, stop and signal error."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|n
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|point
operator|+
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|FirstCharacter
condition|)
block|{
name|SetPoint
argument_list|(
name|FirstCharacter
argument_list|)
expr_stmt|;
name|Fsignal
argument_list|(
name|Qbeginning_of_buffer
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
block|{
name|SetPoint
argument_list|(
name|NumCharacters
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Fsignal
argument_list|(
name|Qend_of_buffer
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"backward-char"
argument_list|,
argument|Fbackward_char
argument_list|,
argument|Sbackward_char
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Move point left ARG characters (right if ARG negative).\n\ On reaching end of buffer, stop and signal error."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|n
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|n
argument_list|,
operator|-
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Fforward_char
argument_list|(
name|n
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"forward-line"
argument_list|,
argument|Fforward_line
argument_list|,
argument|Sforward_line
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Move point forward past ARG newlines.\n\ If ARG is zero, position after previous newline.\n\ If ARG is negative, position after -ARG'th newline before that one.\n\ If scan reaches end of buffer, stop there without error;\n\  value is count of lines left to move."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|pos
init|=
name|point
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|,
name|stop
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
name|count
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|stop
operator|=
name|FirstCharacter
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
while|while
condition|(
name|pos
operator|>
name|stop
operator|&&
name|CharAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pos
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|<
literal|0
operator|&&
name|pos
operator|>
name|stop
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|pos
operator|--
expr_stmt|;
comment|/* In this loop, pos is one less than the position of scan. */
while|while
condition|(
operator|--
name|pos
operator|>=
name|stop
operator|&&
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|stop
operator|=
name|NumCharacters
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|stop
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|pos
operator|--
expr_stmt|;
comment|/* In this loop, pos is one less than the position of scan. */
while|while
condition|(
operator|++
name|pos
operator|<
name|stop
operator|&&
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|count
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"beginning-of-line"
argument_list|,
argument|Fbeginning_of_line
argument_list|,
argument|Sbeginning_of_line
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Move point to beginning of current line.\n\ With argument ARG not nil or 1, move forward ARG - 1 lines first.\n\ If scan reaches end of buffer, stop there without error."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|n
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Fforward_line
argument_list|(
name|make_number
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"end-of-line"
argument_list|,
argument|Fend_of_line
argument_list|,
argument|Send_of_line
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Move point to end of current line.\n\ With argument ARG not nil or 1, move forward ARG - 1 lines first.\n\ If scan reaches end of buffer, stop there without error."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|pos
decl_stmt|;
specifier|register
name|int
name|stop
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|n
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|n
argument_list|)
operator|!=
literal|1
condition|)
name|Fforward_line
argument_list|(
name|make_number
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|point
expr_stmt|;
name|stop
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|stop
operator|&&
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pos
operator|++
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-char"
argument_list|,
argument|Fdelete_char
argument_list|,
argument|Sdelete_char
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"p\nP"
argument_list|,
literal|"Delete the following ARG characters (previous, with negative arg).\n\ Optional second arg KILLFLAG non-nil means kill instead (save in kill ring).\n\ Interactively, ARG is the prefix arg, and kill if ARG was explicitly specd."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|killflag
operator|)
name|Lisp_Object
name|n
operator|,
name|killflag
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|killflag
argument_list|)
condition|)
block|{
if|if
condition|(
name|XINT
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|point
operator|+
name|XINT
argument_list|(
name|n
argument_list|)
operator|<
name|FirstCharacter
condition|)
name|Fsignal
argument_list|(
name|Qbeginning_of_buffer
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
name|del_range
argument_list|(
name|point
operator|+
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
name|point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|point
operator|+
name|XINT
argument_list|(
name|n
argument_list|)
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qend_of_buffer
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
name|del_range
argument_list|(
name|point
argument_list|,
name|point
operator|+
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|call1
argument_list|(
name|Qkill_forward_chars
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-backward-char"
argument_list|,
argument|Fdelete_backward_char
argument_list|,
argument|Sdelete_backward_char
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"p\nP"
argument_list|,
literal|"Delete the previous ARG characters (following, with negative ARG).\n\ Optional second arg KILLFLAG non-nil means kill instead (save in kill ring).\n\ Interactively, ARG is the prefix arg, and kill if ARG was explicitly specd."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|killflag
operator|)
name|Lisp_Object
name|n
operator|,
name|killflag
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|Fdelete_char
argument_list|(
name|make_number
argument_list|(
operator|-
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|killflag
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"self-insert-command"
argument_list|,
argument|Fself_insert_command
argument_list|,
argument|Sself_insert_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Insert this character."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|&&
name|last_command_char
operator|==
literal|' '
operator|&&
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|auto_fill_hook
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
operator|&&
name|current_column
argument_list|()
operator|>
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|fill_column
argument_list|)
condition|)
name|Fapply
argument_list|(
name|bf_cur
operator|->
name|auto_fill_hook
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
while|while
condition|(
name|XINT
argument_list|(
name|arg
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SelfInsert
argument_list|(
name|last_command_char
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|--
expr_stmt|;
comment|/* Ok since old and new vals both nonneg */
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"newline"
argument_list|,
argument|Fnewline
argument_list|,
argument|Snewline
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Insert a newline.  With arg, insert that many newlines.\n\ In Auto Fill mode, can break the preceding line if no numeric arg."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg1
operator|)
name|Lisp_Object
name|arg1
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|flag
decl_stmt|;
name|Lisp_Object
name|arg
decl_stmt|;
name|arg
operator|=
name|Fprefix_numeric_value
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|)
name|Fsignal
argument_list|(
name|Qbuffer_read_only
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|auto_fill_hook
argument_list|)
operator|&&
name|current_column
argument_list|()
operator|>
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|fill_column
argument_list|)
condition|)
name|Fapply
argument_list|(
name|bf_cur
operator|->
name|auto_fill_hook
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|flag
operator|=
name|point
operator|>
name|FirstCharacter
operator|&&
name|CharAt
argument_list|(
name|point
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|PointLeft
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|XINT
argument_list|(
name|arg
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SelfInsert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|--
expr_stmt|;
comment|/* Ok since old and new vals both nonneg */
block|}
if|if
condition|(
name|flag
condition|)
name|PointRight
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|SelfInsert
argument_list|(
argument|c1
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|Lisp_Object
name|Fexpand_abbrev
parameter_list|()
function_decl|;
name|int
name|hairy
init|=
literal|0
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|enum
name|syntaxcode
name|synt
decl_stmt|;
specifier|register
name|int
name|c
init|=
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|overwrite_mode
argument_list|)
operator|&&
name|point
operator|<=
name|NumCharacters
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|CharAt
argument_list|(
name|point
argument_list|)
operator|!=
literal|'\n'
operator|&&
operator|(
name|CharAt
argument_list|(
name|point
argument_list|)
operator|!=
literal|'\t'
operator|||
name|XINT
argument_list|(
name|bf_cur
operator|->
name|tab_width
argument_list|)
operator|<=
literal|0
operator|||
operator|!
operator|(
operator|(
name|current_column
argument_list|()
operator|+
literal|1
operator|)
operator|%
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|tab_width
argument_list|)
operator|)
operator|)
condition|)
block|{
name|del_range
argument_list|(
name|point
argument_list|,
name|point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hairy
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|abbrev_mode
argument_list|)
operator|&&
name|SYNTAX
argument_list|(
name|c
argument_list|)
operator|!=
name|Sword
operator|&&
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
operator|&&
name|point
operator|>
name|FirstCharacter
operator|&&
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|point
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|Sword
condition|)
block|{
name|tem
operator|=
name|Fexpand_abbrev
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|hairy
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|)
operator|&&
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|auto_fill_hook
argument_list|)
operator|&&
name|current_column
argument_list|()
operator|>
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|fill_column
argument_list|)
condition|)
block|{
name|InsCStr
argument_list|(
operator|&
name|c1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fapply
argument_list|(
name|bf_cur
operator|->
name|auto_fill_hook
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|hairy
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|InsCStr
argument_list|(
operator|&
name|c1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|synt
operator|=
name|SYNTAX
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|synt
operator|==
name|Sclose
operator|||
name|synt
operator|==
name|Smath
operator|)
operator|&&
operator|!
name|NULL
argument_list|(
name|Vblink_paren_hook
argument_list|)
operator|&&
name|INTERACTIVE
condition|)
block|{
name|Fapply
argument_list|(
name|Vblink_paren_hook
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|hairy
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|hairy
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* module initialization */
end_comment

begin_macro
name|syms_of_cmds
argument_list|()
end_macro

begin_block
block|{
name|Qkill_backward_chars
operator|=
name|intern
argument_list|(
literal|"kill-backward-chars"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qkill_backward_chars
argument_list|)
expr_stmt|;
name|Qkill_forward_chars
operator|=
name|intern
argument_list|(
literal|"kill-forward-chars"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qkill_forward_chars
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"blink-paren-hook"
argument_list|,
operator|&
name|Vblink_paren_hook
argument_list|,
literal|"Function called, if non-nil, whenever a char with closeparen syntax is self-inserted."
argument_list|)
expr_stmt|;
name|Vblink_paren_hook
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sforward_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbackward_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sforward_line
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbeginning_of_line
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Send_of_line
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_backward_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sself_insert_command
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snewline
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_cmds
argument_list|()
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'M'
argument_list|)
argument_list|,
literal|"newline"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'I'
argument_list|)
argument_list|,
literal|"self-insert-command"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|040
init|;
name|n
operator|<
literal|0177
condition|;
name|n
operator|++
control|)
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|n
argument_list|,
literal|"self-insert-command"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'A'
argument_list|)
argument_list|,
literal|"beginning-of-line"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'B'
argument_list|)
argument_list|,
literal|"backward-char"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'D'
argument_list|)
argument_list|,
literal|"delete-char"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'E'
argument_list|)
argument_list|,
literal|"end-of-line"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'F'
argument_list|)
argument_list|,
literal|"forward-char"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
literal|0177
argument_list|,
literal|"delete-backward-char"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

