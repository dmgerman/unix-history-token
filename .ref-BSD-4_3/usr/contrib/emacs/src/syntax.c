begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Emacs routines to deal with syntax tables; also word and list parsing.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_decl_stmt
name|Lisp_Object
name|Qsyntax_table_p
decl_stmt|,
name|Vstandard_syntax_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There is an alist of syntax tables: names (strings) vs obarrays. */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"syntax-table-p"
argument_list|,
argument|Fsyntax_table_p
argument_list|,
argument|Ssyntax_table_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if ARG is a syntax table.\n\ Any vector of 256 elements will do."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Vector
operator|&&
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|size
operator|==
literal|0400
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|check_syntax_table
parameter_list|(
name|obj
parameter_list|)
name|Lisp_Object
name|obj
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
while|while
condition|(
name|tem
operator|=
name|Fsyntax_table_p
argument_list|(
name|obj
argument_list|)
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|obj
operator|=
name|wrong_type_argument
argument_list|(
name|Qsyntax_table_p
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"syntax-table"
argument_list|,
argument|Fsyntax_table
argument_list|,
argument|Ssyntax_table
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the current syntax table.\n\ This is the one specified by the current buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|vector
block|;
name|XSET
argument_list|(
name|vector
argument_list|,
name|Lisp_Vector
argument_list|,
name|bf_cur
operator|->
name|syntax_table_v
argument_list|)
block|;
return|return
name|vector
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"standard-syntax-table"
argument_list|,
argument|Fstandard_syntax_table
argument_list|,
argument|Sstandard_syntax_table
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the standard syntax table.\n\ This is the one used for new buffers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Vstandard_syntax_table
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"copy-syntax-table"
argument_list|,
argument|Fcopy_syntax_table
argument_list|,
argument|Scopy_syntax_table
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Construct a new syntax table and return it.\n\ It is a copy of the TABLE, which defaults to the standard syntax table."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|table
operator|)
name|Lisp_Object
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|size
decl_stmt|,
name|val
decl_stmt|;
name|XFASTINT
argument_list|(
name|size
argument_list|)
operator|=
literal|0400
expr_stmt|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|Fmake_vector
argument_list|(
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|table
argument_list|)
condition|)
name|table
operator|=
name|check_syntax_table
argument_list|(
name|table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|Vstandard_syntax_table
argument_list|)
condition|)
comment|/* Can only be null during initialization */
return|return
name|val
return|;
else|else
name|table
operator|=
name|Vstandard_syntax_table
expr_stmt|;
name|bcopy
argument_list|(
name|XVECTOR
argument_list|(
name|table
argument_list|)
operator|->
name|contents
argument_list|,
name|XVECTOR
argument_list|(
name|val
argument_list|)
operator|->
name|contents
argument_list|,
literal|0400
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-syntax-table"
argument_list|,
argument|Fset_syntax_table
argument_list|,
argument|Sset_syntax_table
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Select a new syntax table for the current buffer.\n\ One argument, a syntax table."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|table
operator|)
name|Lisp_Object
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|table
operator|=
name|check_syntax_table
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|syntax_table_v
operator|=
name|XVECTOR
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|table
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Convert a letter which signifies a syntax code  into the code it signifies.  This is used by modify-syntax-entry, and other things. */
end_comment

begin_decl_stmt
name|char
name|syntax_spec_code
index|[
literal|0400
index|]
init|=
block|{
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Swhitespace
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Sstring
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Smath
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Squote
block|,
operator|(
name|char
operator|)
name|Sopen
block|,
operator|(
name|char
operator|)
name|Sclose
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Swhitespace
block|,
operator|(
name|char
operator|)
name|Spunct
block|,
operator|(
name|char
operator|)
name|Scharquote
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Scomment
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Sendcomment
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
comment|/* @, A, ... */
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Sword
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Sescape
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Ssymbol
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
comment|/* `, a, ... */
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
operator|(
name|char
operator|)
name|Sword
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|,
literal|0377
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by syntax code, give the letter that describes it. */
end_comment

begin_decl_stmt
name|char
name|syntax_code_spec
index|[
literal|13
index|]
init|=
block|{
literal|' '
block|,
literal|'.'
block|,
literal|'w'
block|,
literal|'_'
block|,
literal|'('
block|,
literal|')'
block|,
literal|'\''
block|,
literal|'\"'
block|,
literal|'$'
block|,
literal|'\\'
block|,
literal|'/'
block|,
literal|'<'
block|,
literal|'>'
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"char-syntax"
argument_list|,
argument|Fchar_syntax
argument_list|,
argument|Schar_syntax
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the syntax code of CHAR, described by a character.\n\ For example, if CHAR is a word constituent, ?w is returned.\n\ The characters that correspond to various syntax codes\n\ are listed in the documentation of  modify-syntax-entry."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|ch
operator|)
name|Lisp_Object
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|syntax_code_spec
index|[
operator|(
name|int
operator|)
name|SYNTAX
argument_list|(
name|XINT
argument_list|(
name|ch
argument_list|)
argument_list|)
index|]
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"modify-syntax-entry"
argument_list|,
argument|Fmodify_syntax_entry
argument_list|,
argument|Smodify_syntax_entry
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
comment|/* I really don't know why this is interactive      help-form should at least be made useful whilst reading the second arg    */
literal|"cSet syntax for character: \nsSet syntax for %s to: "
argument_list|,
literal|0
comment|/* See auxdoc.c */
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|c
operator|,
name|newentry
operator|,
name|syntax_table
operator|)
name|Lisp_Object
name|c
operator|,
name|newentry
operator|,
name|syntax_table
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
name|match
decl_stmt|;
specifier|register
name|enum
name|syntaxcode
name|code
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newentry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|syntax_table
argument_list|)
condition|)
name|XSET
argument_list|(
name|syntax_table
argument_list|,
name|Lisp_Vector
argument_list|,
name|bf_cur
operator|->
name|syntax_table_v
argument_list|)
expr_stmt|;
else|else
name|syntax_table
operator|=
name|check_syntax_table
argument_list|(
name|syntax_table
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|newentry
argument_list|)
operator|->
name|data
expr_stmt|;
name|code
operator|=
operator|(
expr|enum
name|syntaxcode
operator|)
name|syntax_spec_code
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|code
operator|&
literal|0377
operator|)
operator|==
literal|0377
condition|)
name|error
argument_list|(
literal|"invalid syntax description letter: %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|match
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|match
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|' '
condition|)
name|match
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
operator|(
name|match
operator|<<
literal|8
operator|)
operator|+
operator|(
name|int
operator|)
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'1'
case|:
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator||=
literal|1
operator|<<
literal|16
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator||=
literal|1
operator|<<
literal|17
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator||=
literal|1
operator|<<
literal|18
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator||=
literal|1
operator|<<
literal|19
expr_stmt|;
break|break;
block|}
name|XVECTOR
argument_list|(
name|syntax_table
argument_list|)
operator|->
name|contents
index|[
name|XINT
argument_list|(
name|c
argument_list|)
index|]
operator|=
name|val
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Dump syntax table to buffer in human-readable format */
end_comment

begin_macro
name|describe_syntax
argument_list|(
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|enum
name|syntaxcode
name|code
decl_stmt|;
name|char
name|desc
decl_stmt|,
name|match
decl_stmt|,
name|start1
decl_stmt|,
name|start2
decl_stmt|,
name|end1
decl_stmt|,
name|end2
decl_stmt|;
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|value
argument_list|)
operator|!=
name|Lisp_Int
condition|)
block|{
name|InsStr
argument_list|(
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
operator|(
expr|enum
name|syntaxcode
operator|)
operator|(
name|XINT
argument_list|(
name|value
argument_list|)
operator|&
literal|0377
operator|)
expr_stmt|;
name|match
operator|=
operator|(
name|XINT
argument_list|(
name|value
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
name|start1
operator|=
operator|(
name|XINT
argument_list|(
name|value
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|1
expr_stmt|;
name|start2
operator|=
operator|(
name|XINT
argument_list|(
name|value
argument_list|)
operator|>>
literal|17
operator|)
operator|&
literal|1
expr_stmt|;
name|end1
operator|=
operator|(
name|XINT
argument_list|(
name|value
argument_list|)
operator|>>
literal|18
operator|)
operator|&
literal|1
expr_stmt|;
name|end2
operator|=
operator|(
name|XINT
argument_list|(
name|value
argument_list|)
operator|>>
literal|19
operator|)
operator|&
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|<
literal|0
operator|||
operator|(
name|int
operator|)
name|code
operator|>=
operator|(
name|int
operator|)
name|Smax
condition|)
block|{
name|InsStr
argument_list|(
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|desc
operator|=
name|syntax_code_spec
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|desc
operator|,
name|str
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|InsCStr
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|match
condition|?
name|match
else|:
literal|' '
expr_stmt|;
name|InsCStr
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start1
condition|)
name|InsCStr
argument_list|(
literal|"1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start2
condition|)
name|InsCStr
argument_list|(
literal|"2"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|end1
condition|)
name|InsCStr
argument_list|(
literal|"3"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|end2
condition|)
name|InsCStr
argument_list|(
literal|"4"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\twhich means: "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
endif|#
directive|endif
block|{
case|case
name|Swhitespace
case|:
name|InsStr
argument_list|(
literal|"whitespace"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Spunct
case|:
name|InsStr
argument_list|(
literal|"punctuation"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sword
case|:
name|InsStr
argument_list|(
literal|"word"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Ssymbol
case|:
name|InsStr
argument_list|(
literal|"symbol"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sopen
case|:
name|InsStr
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sclose
case|:
name|InsStr
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Squote
case|:
name|InsStr
argument_list|(
literal|"quote"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sstring
case|:
name|InsStr
argument_list|(
literal|"string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Smath
case|:
name|InsStr
argument_list|(
literal|"math"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sescape
case|:
name|InsStr
argument_list|(
literal|"escape"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Scharquote
case|:
name|InsStr
argument_list|(
literal|"charquote"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Scomment
case|:
name|InsStr
argument_list|(
literal|"comment"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sendcomment
case|:
name|InsStr
argument_list|(
literal|"endcomment"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|InsStr
argument_list|(
literal|"invalid"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|match
condition|)
block|{
name|InsStr
argument_list|(
literal|", matches "
argument_list|)
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|match
operator|,
name|str
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|InsCStr
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start1
condition|)
name|InsStr
argument_list|(
literal|",\n\t  is the first character of a comment-start sequence"
argument_list|)
expr_stmt|;
if|if
condition|(
name|start2
condition|)
name|InsStr
argument_list|(
literal|",\n\t  is the second character of a comment-start sequence"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end1
condition|)
name|InsStr
argument_list|(
literal|",\n\t  is the first character of a comment-end sequence"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end2
condition|)
name|InsStr
argument_list|(
literal|",\n\t  is the second character of a comment-end sequence"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Lisp_Object
name|describe_syntax_1
parameter_list|(
name|vector
parameter_list|)
name|Lisp_Object
name|vector
decl_stmt|;
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
argument_list|)
expr_stmt|;
name|describe_vector
argument_list|(
name|vector
argument_list|,
name|Qnil
argument_list|,
name|describe_syntax
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"describe-syntax"
argument_list|,
argument|Fdescribe_syntax
argument_list|,
argument|Sdescribe_syntax
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Describe the syntax specifications in the syntax table.\n\ The descriptions are inserted in a buffer, which is selected so you can see it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|vector
block|;
name|XSET
argument_list|(
name|vector
argument_list|,
name|Lisp_Vector
argument_list|,
name|bf_cur
operator|->
name|syntax_table_v
argument_list|)
block|;
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Help*"
argument_list|,
name|describe_syntax_1
argument_list|,
name|vector
argument_list|)
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the position across `count' words from `from'.    If that many words cannot be found before the end of the buffer, return 0.    `count' negative means scan backward and stop at word beginning.  */
end_comment

begin_expr_stmt
name|scan_words
argument_list|(
name|from
argument_list|,
name|count
argument_list|)
specifier|register
name|int
name|from
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|beg
init|=
name|FirstCharacter
decl_stmt|;
specifier|register
name|int
name|end
init|=
name|NumCharacters
operator|+
literal|1
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|end
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
name|Sword
condition|)
break|break;
name|from
operator|++
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|end
condition|)
break|break;
if|if
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
operator|!=
name|Sword
condition|)
break|break;
name|from
operator|++
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|<
literal|0
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|beg
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|Sword
condition|)
break|break;
name|from
operator|--
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|beg
condition|)
break|break;
if|if
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|Sword
condition|)
break|break;
name|from
operator|--
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
name|from
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"forward-word"
argument_list|,
argument|Fforward_word
argument_list|,
argument|Sforward_word
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Move point forward ARG words (backward if ARG is negative).\n\ Normally returns t.\n\ If an edge of the buffer is reached, point is left there\n\ and nil is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|count
operator|)
name|Lisp_Object
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|=
name|scan_words
argument_list|(
name|point
argument_list|,
name|XINT
argument_list|(
name|count
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SetPoint
argument_list|(
name|XINT
argument_list|(
name|count
argument_list|)
operator|>
literal|0
condition|?
name|NumCharacters
operator|+
literal|1
else|:
name|FirstCharacter
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
name|SetPoint
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|int
name|parse_sexp_ignore_comments
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|scan_lists
parameter_list|(
name|from
parameter_list|,
name|count
parameter_list|,
name|depth
parameter_list|,
name|sexpflag
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|;
name|int
name|count
decl_stmt|,
name|depth
decl_stmt|,
name|sexpflag
decl_stmt|;
block|{
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|stop
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|stringterm
decl_stmt|;
name|int
name|quoted
decl_stmt|;
name|int
name|mathexit
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|syntaxcode
name|code
decl_stmt|;
name|int
name|min_depth
init|=
name|depth
decl_stmt|;
comment|/* Err out if depth gets less than this. */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|min_depth
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|stop
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|stop
condition|)
block|{
name|c
operator|=
name|CharAt
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|code
operator|=
name|SYNTAX
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|stop
operator|&&
name|SYNTAX_COMSTART_FIRST
argument_list|(
name|c
argument_list|)
operator|&&
name|SYNTAX_COMSTART_SECOND
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
name|parse_sexp_ignore_comments
condition|)
name|code
operator|=
name|Scomment
operator|,
name|from
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
endif|#
directive|endif
block|{
case|case
name|Sescape
case|:
case|case
name|Scharquote
case|:
if|if
condition|(
name|from
operator|==
name|stop
condition|)
goto|goto
name|lose
goto|;
name|from
operator|++
expr_stmt|;
comment|/* treat following character as a word constituent */
case|case
name|Sword
case|:
case|case
name|Ssymbol
case|:
if|if
condition|(
name|depth
operator|||
operator|!
name|sexpflag
condition|)
break|break;
comment|/* This word counts as a sexp; return at end of it. */
while|while
condition|(
name|from
operator|<
name|stop
condition|)
block|{
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Scharquote
case|:
case|case
name|Sescape
case|:
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|stop
condition|)
goto|goto
name|lose
goto|;
break|break;
case|case
name|Sword
case|:
case|case
name|Ssymbol
case|:
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|from
operator|++
expr_stmt|;
block|}
goto|goto
name|done
goto|;
case|case
name|Scomment
case|:
if|if
condition|(
operator|!
name|parse_sexp_ignore_comments
condition|)
break|break;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|stop
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|c
operator|=
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
name|Sendcomment
condition|)
break|break;
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|stop
operator|&&
name|SYNTAX_COMEND_FIRST
argument_list|(
name|c
argument_list|)
operator|&&
name|SYNTAX_COMEND_SECOND
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|from
operator|++
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|Smath
case|:
if|if
condition|(
operator|!
name|sexpflag
condition|)
break|break;
if|if
condition|(
name|from
operator|!=
name|stop
operator|&&
name|c
operator|==
name|CharAt
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|mathexit
condition|)
goto|goto
name|close1
goto|;
name|mathexit
operator|=
literal|1
expr_stmt|;
case|case
name|Sopen
case|:
if|if
condition|(
operator|!
operator|++
name|depth
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|Sclose
case|:
name|close1
label|:
if|if
condition|(
operator|!
operator|--
name|depth
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|depth
operator|<
name|min_depth
condition|)
name|error
argument_list|(
literal|"Containing expression ends prematurely"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sstring
case|:
name|stringterm
operator|=
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|>=
name|stop
condition|)
goto|goto
name|lose
goto|;
if|if
condition|(
name|CharAt
argument_list|(
name|from
argument_list|)
operator|==
name|stringterm
condition|)
break|break;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Scharquote
case|:
case|case
name|Sescape
case|:
name|from
operator|++
expr_stmt|;
block|}
name|from
operator|++
expr_stmt|;
block|}
name|from
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|depth
operator|&&
name|sexpflag
condition|)
goto|goto
name|done
goto|;
break|break;
block|}
block|}
comment|/* Reached end of buffer.  Error if within object, return nil if between */
if|if
condition|(
name|depth
condition|)
goto|goto
name|lose
goto|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
name|Qnil
return|;
comment|/* End of object reached */
name|done
label|:
name|count
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|stop
operator|=
name|FirstCharacter
expr_stmt|;
while|while
condition|(
name|from
operator|>
name|stop
condition|)
block|{
name|from
operator|--
expr_stmt|;
if|if
condition|(
name|quoted
operator|=
name|char_quoted
argument_list|(
name|from
argument_list|)
condition|)
name|from
operator|--
expr_stmt|;
name|c
operator|=
name|CharAt
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|code
operator|=
name|SYNTAX
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|>
name|stop
operator|&&
name|SYNTAX_COMEND_SECOND
argument_list|(
name|c
argument_list|)
operator|&&
name|SYNTAX_COMEND_FIRST
argument_list|(
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|char_quoted
argument_list|(
name|from
operator|-
literal|1
argument_list|)
operator|&&
name|parse_sexp_ignore_comments
condition|)
name|code
operator|=
name|Sendcomment
operator|,
name|from
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|quoted
condition|?
name|Sword
else|:
name|code
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|quoted
condition|?
name|Sword
else|:
name|code
condition|)
endif|#
directive|endif
block|{
case|case
name|Sword
case|:
case|case
name|Ssymbol
case|:
if|if
condition|(
name|depth
operator|||
operator|!
name|sexpflag
condition|)
break|break;
comment|/* This word counts as a sexp; count object finished after passing it. */
while|while
condition|(
name|from
operator|>
name|stop
condition|)
block|{
if|if
condition|(
name|quoted
operator|=
name|char_quoted
argument_list|(
name|from
operator|-
literal|1
argument_list|)
condition|)
name|from
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|quoted
operator|||
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|Sword
operator|||
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|Ssymbol
operator|)
condition|)
goto|goto
name|done2
goto|;
name|from
operator|--
expr_stmt|;
block|}
goto|goto
name|done2
goto|;
case|case
name|Smath
case|:
if|if
condition|(
operator|!
name|sexpflag
condition|)
break|break;
if|if
condition|(
name|from
operator|!=
name|stop
operator|&&
name|c
operator|==
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
condition|)
name|from
operator|--
expr_stmt|;
if|if
condition|(
name|mathexit
condition|)
goto|goto
name|open2
goto|;
name|mathexit
operator|=
literal|1
expr_stmt|;
case|case
name|Sclose
case|:
if|if
condition|(
operator|!
operator|++
name|depth
condition|)
goto|goto
name|done2
goto|;
break|break;
case|case
name|Sopen
case|:
name|open2
label|:
if|if
condition|(
operator|!
operator|--
name|depth
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|depth
operator|<
name|min_depth
condition|)
name|error
argument_list|(
literal|"Containing expression ends prematurely"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sendcomment
case|:
if|if
condition|(
operator|!
name|parse_sexp_ignore_comments
condition|)
break|break;
if|if
condition|(
name|from
operator|!=
name|stop
condition|)
name|from
operator|--
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|SYNTAX
argument_list|(
name|c
operator|=
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
name|Scomment
condition|)
break|break;
if|if
condition|(
name|from
operator|==
name|stop
condition|)
goto|goto
name|done
goto|;
name|from
operator|--
expr_stmt|;
if|if
condition|(
name|SYNTAX_COMSTART_SECOND
argument_list|(
name|c
argument_list|)
operator|&&
name|SYNTAX_COMSTART_FIRST
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
operator|&&
operator|!
name|char_quoted
argument_list|(
name|from
argument_list|)
condition|)
break|break;
block|}
break|break;
case|case
name|Sstring
case|:
name|stringterm
operator|=
name|CharAt
argument_list|(
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|stop
condition|)
goto|goto
name|lose
goto|;
if|if
condition|(
operator|!
name|char_quoted
argument_list|(
name|from
operator|-
literal|1
argument_list|)
operator|&&
name|stringterm
operator|==
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
condition|)
break|break;
name|from
operator|--
expr_stmt|;
block|}
name|from
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|depth
operator|&&
name|sexpflag
condition|)
goto|goto
name|done2
goto|;
break|break;
block|}
block|}
comment|/* Reached start of buffer.  Error if within object, return nil if between */
if|if
condition|(
name|depth
condition|)
goto|goto
name|lose
goto|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
name|Qnil
return|;
name|done2
label|:
name|count
operator|++
expr_stmt|;
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|from
expr_stmt|;
return|return
name|val
return|;
name|lose
label|:
name|error
argument_list|(
literal|"Unbalanced parentheses"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_expr_stmt
name|char_quoted
argument_list|(
name|pos
argument_list|)
specifier|register
name|int
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|enum
name|syntaxcode
name|code
decl_stmt|;
specifier|register
name|int
name|beg
init|=
name|FirstCharacter
decl_stmt|;
specifier|register
name|int
name|quoted
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pos
operator|>
name|beg
operator|&&
operator|(
operator|(
name|code
operator|=
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|Scharquote
operator|||
name|code
operator|==
name|Sescape
operator|)
condition|)
name|pos
operator|--
operator|,
name|quoted
operator|=
operator|!
name|quoted
expr_stmt|;
return|return
name|quoted
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"scan-lists"
argument_list|,
argument|Fscan_lists
argument_list|,
argument|Sscan_lists
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Scan from character number FROM by COUNT lists.\n\ Returns the character number of the position thus found.\n\ \n\ If DEPTH is nonzero, paren depth begins counting from that value,\n\ only places where the depth in parentheses becomes zero\n\ are candidates for stopping; COUNT such places are counted.\n\ Thus, a positive value for DEPTH means go out levels.\n\ \n\ Comments are ignored if parse-sexp-ignore-comments is non-nil.\n\ \n\ If the beginning or end of (the visible part of) the buffer is reached\n\ and the depth is wrong, an error is signaled.\n\ If the depth is right but the count is not used up, nil is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|from
operator|,
name|count
operator|,
name|depth
operator|)
name|Lisp_Object
name|from
operator|,
name|count
operator|,
name|depth
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|depth
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|scan_lists
argument_list|(
name|XINT
argument_list|(
name|from
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|count
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|depth
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"scan-sexps"
argument_list|,
argument|Fscan_sexps
argument_list|,
argument|Sscan_sexps
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Scan from character number FROM by COUNT balanced expressions.\n\ Returns the character number of the position thus found.\n\ \n\ Comments are ignored if parse-sexp-ignore-comments is non-nil.\n\ \n\ If the beginning or end of (the visible part of) the buffer is reached\n\ in the middle of a parenthetical grouping, an error is signaled.\n\ If the beginning or end is reached between groupings but before count is used up,\n\ nil is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|from
operator|,
name|count
operator|)
name|Lisp_Object
name|from
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|scan_lists
argument_list|(
name|XINT
argument_list|(
name|from
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|count
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"backward-prefix-chars"
argument_list|,
argument|Fbackward_prefix_chars
argument_list|,
argument|Sbackward_prefix_chars
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Move point backward over any number of chars with syntax \"prefix\"."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|int
name|beg
operator|=
name|FirstCharacter
block|;
name|int
name|pos
operator|=
name|point
block|;
while|while
condition|(
name|pos
operator|>
name|beg
operator|&&
operator|!
name|char_quoted
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|&&
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
argument_list|)
operator|==
name|Squote
condition|)
name|pos
operator|--
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_macro
unit|struct
name|lisp_parse_state
end_macro

begin_block
block|{
name|int
name|depth
decl_stmt|;
comment|/* Depth at end of parsing */
name|int
name|instring
decl_stmt|;
comment|/* -1 if not within string, else desired terminator. */
name|int
name|incomment
decl_stmt|;
comment|/* Nonzero if within a comment at end of parsing */
name|int
name|quoted
decl_stmt|;
comment|/* Nonzero if just after an escape char at end of parsing */
name|int
name|thislevelstart
decl_stmt|;
comment|/* Char number of most recent start-of-expression at current level */
name|int
name|prevlevelstart
decl_stmt|;
comment|/* Char number of start of containing expression */
name|int
name|location
decl_stmt|;
comment|/* Char number at which parsing stopped. */
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Parse forward from `from' to `end', assuming that `from' is the start of a function, and return a description of the state of the parse at `end'. */
end_comment

begin_decl_stmt
name|struct
name|lisp_parse_state
name|val_scan_sexps_forward
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|lisp_parse_state
modifier|*
name|scan_sexps_forward
parameter_list|(
name|from
parameter_list|,
name|end
parameter_list|,
name|targetdepth
parameter_list|,
name|stopbefore
parameter_list|,
name|oldstate
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|;
name|int
name|end
decl_stmt|,
name|targetdepth
decl_stmt|,
name|stopbefore
decl_stmt|;
name|Lisp_Object
name|oldstate
decl_stmt|;
block|{
name|struct
name|lisp_parse_state
name|state
decl_stmt|;
specifier|register
name|enum
name|syntaxcode
name|code
decl_stmt|;
struct|struct
name|level
block|{
name|int
name|last
decl_stmt|,
name|prev
decl_stmt|;
block|}
struct|;
name|struct
name|level
name|levelstart
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|struct
name|level
modifier|*
name|curlevel
init|=
name|levelstart
decl_stmt|;
name|struct
name|level
modifier|*
name|endlevel
init|=
name|levelstart
operator|+
literal|100
decl_stmt|;
name|char
name|prev
decl_stmt|;
specifier|register
name|int
name|depth
decl_stmt|;
comment|/* Paren depth of current scanning location. 			   level - levelstart equals this except 			   when the depth becomes negative.  */
name|int
name|start_quoted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means starting after a char quote */
name|Lisp_Object
name|tem
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|oldstate
argument_list|)
condition|)
block|{
name|depth
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|instring
operator|=
operator|-
literal|1
expr_stmt|;
name|state
operator|.
name|incomment
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|Fcar
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|depth
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
else|else
name|depth
operator|=
literal|0
expr_stmt|;
name|oldstate
operator|=
name|Fcdr
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|oldstate
operator|=
name|Fcdr
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|oldstate
operator|=
name|Fcdr
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|state
operator|.
name|instring
operator|=
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|?
name|XINT
argument_list|(
name|tem
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
name|oldstate
operator|=
name|Fcdr
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|state
operator|.
name|incomment
operator|=
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|oldstate
operator|=
name|Fcdr
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|start_quoted
operator|=
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|quoted
operator|=
literal|0
expr_stmt|;
name|curlevel
operator|->
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Enter the loop at a place appropriate for initial state. */
if|if
condition|(
name|state
operator|.
name|incomment
condition|)
goto|goto
name|startincomment
goto|;
if|if
condition|(
name|state
operator|.
name|instring
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|start_quoted
condition|)
goto|goto
name|startquotedinstring
goto|;
goto|goto
name|startinstring
goto|;
block|}
if|if
condition|(
name|start_quoted
condition|)
goto|goto
name|startquoted
goto|;
while|while
condition|(
name|from
operator|<
name|end
condition|)
block|{
name|code
operator|=
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|end
operator|&&
name|SYNTAX_COMSTART_FIRST
argument_list|(
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
argument_list|)
operator|&&
name|SYNTAX_COMSTART_SECOND
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
name|code
operator|=
name|Scomment
operator|,
name|from
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
endif|#
directive|endif
block|{
case|case
name|Sescape
case|:
case|case
name|Scharquote
case|:
if|if
condition|(
name|stopbefore
condition|)
goto|goto
name|stop
goto|;
comment|/* this arg means stop at sexp start */
name|curlevel
operator|->
name|last
operator|=
name|from
operator|-
literal|1
expr_stmt|;
name|startquoted
label|:
if|if
condition|(
name|from
operator|==
name|end
condition|)
goto|goto
name|endquoted
goto|;
name|from
operator|++
expr_stmt|;
goto|goto
name|symstarted
goto|;
comment|/* treat following character as a word constituent */
case|case
name|Sword
case|:
case|case
name|Ssymbol
case|:
if|if
condition|(
name|stopbefore
condition|)
goto|goto
name|stop
goto|;
comment|/* this arg means stop at sexp start */
name|curlevel
operator|->
name|last
operator|=
name|from
operator|-
literal|1
expr_stmt|;
name|symstarted
label|:
while|while
condition|(
name|from
operator|<
name|end
condition|)
block|{
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Scharquote
case|:
case|case
name|Sescape
case|:
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|end
condition|)
goto|goto
name|endquoted
goto|;
break|break;
case|case
name|Sword
case|:
case|case
name|Ssymbol
case|:
break|break;
default|default:
goto|goto
name|symdone
goto|;
block|}
name|from
operator|++
expr_stmt|;
block|}
name|symdone
label|:
name|curlevel
operator|->
name|prev
operator|=
name|curlevel
operator|->
name|last
expr_stmt|;
break|break;
case|case
name|Scomment
case|:
name|state
operator|.
name|incomment
operator|=
literal|1
expr_stmt|;
name|startincomment
label|:
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|==
name|end
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|prev
operator|=
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
operator|==
name|Sendcomment
condition|)
break|break;
name|from
operator|++
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|end
operator|&&
name|SYNTAX_COMEND_FIRST
argument_list|(
name|prev
argument_list|)
operator|&&
name|SYNTAX_COMEND_SECOND
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
block|{
name|from
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|state
operator|.
name|incomment
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Sopen
case|:
if|if
condition|(
name|stopbefore
condition|)
goto|goto
name|stop
goto|;
comment|/* this arg means stop at sexp start */
name|depth
operator|++
expr_stmt|;
comment|/* curlevel++->last ran into compiler bug on Apollo */
name|curlevel
operator|->
name|last
operator|=
name|from
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|curlevel
operator|==
name|endlevel
condition|)
name|error
argument_list|(
literal|"Nesting too deep for parser"
argument_list|)
expr_stmt|;
name|curlevel
operator|->
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
name|curlevel
operator|->
name|last
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|targetdepth
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|Sclose
case|:
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|curlevel
operator|!=
name|levelstart
condition|)
name|curlevel
operator|--
expr_stmt|;
name|curlevel
operator|->
name|prev
operator|=
name|curlevel
operator|->
name|last
expr_stmt|;
if|if
condition|(
operator|!
operator|++
name|targetdepth
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|Sstring
case|:
if|if
condition|(
name|stopbefore
condition|)
goto|goto
name|stop
goto|;
comment|/* this arg means stop at sexp start */
name|curlevel
operator|->
name|last
operator|=
name|from
operator|-
literal|1
expr_stmt|;
name|state
operator|.
name|instring
operator|=
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
expr_stmt|;
name|startinstring
label|:
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|from
operator|>=
name|end
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|CharAt
argument_list|(
name|from
argument_list|)
operator|==
name|state
operator|.
name|instring
condition|)
break|break;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|SYNTAX
argument_list|(
name|CharAt
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Scharquote
case|:
case|case
name|Sescape
case|:
name|from
operator|++
expr_stmt|;
name|startquotedinstring
label|:
if|if
condition|(
name|from
operator|>=
name|end
condition|)
goto|goto
name|endquoted
goto|;
block|}
name|from
operator|++
expr_stmt|;
block|}
name|state
operator|.
name|instring
operator|=
operator|-
literal|1
expr_stmt|;
name|curlevel
operator|->
name|prev
operator|=
name|curlevel
operator|->
name|last
expr_stmt|;
name|from
operator|++
expr_stmt|;
break|break;
case|case
name|Smath
case|:
break|break;
block|}
block|}
goto|goto
name|done
goto|;
name|stop
label|:
comment|/* Here if stopping before start of sexp. */
name|from
operator|--
expr_stmt|;
comment|/* We have just fetched the char that starts it; */
goto|goto
name|done
goto|;
comment|/* but return the position before it. */
name|endquoted
label|:
name|state
operator|.
name|quoted
operator|=
literal|1
expr_stmt|;
name|done
label|:
name|state
operator|.
name|depth
operator|=
name|depth
expr_stmt|;
name|state
operator|.
name|thislevelstart
operator|=
name|curlevel
operator|->
name|prev
expr_stmt|;
name|state
operator|.
name|prevlevelstart
operator|=
operator|(
name|curlevel
operator|==
name|levelstart
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|curlevel
operator|-
literal|1
operator|)
operator|->
name|last
expr_stmt|;
name|state
operator|.
name|location
operator|=
name|from
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|val_scan_sexps_forward
operator|=
name|state
expr_stmt|;
return|return
operator|&
name|val_scan_sexps_forward
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"parse-partial-sexp"
argument_list|,
argument|Fparse_partial_sexp
argument_list|,
argument|Sparse_partial_sexp
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|0
comment|/* See auxdoc.c */
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|from
operator|,
name|to
operator|,
name|targetdepth
operator|,
name|stopbefore
operator|,
name|oldstate
operator|)
name|Lisp_Object
name|from
operator|,
name|to
operator|,
name|targetdepth
operator|,
name|stopbefore
operator|,
name|oldstate
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|lisp_parse_state
name|state
decl_stmt|;
name|int
name|target
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|targetdepth
argument_list|)
condition|)
block|{
name|CHECK_NUMBER
argument_list|(
name|targetdepth
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|target
operator|=
name|XINT
argument_list|(
name|targetdepth
argument_list|)
expr_stmt|;
block|}
else|else
name|target
operator|=
operator|-
literal|100000
expr_stmt|;
comment|/* We won't reach this depth */
name|validate_region
argument_list|(
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
name|state
operator|=
operator|*
name|scan_sexps_forward
argument_list|(
name|XINT
argument_list|(
name|from
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|to
argument_list|)
argument_list|,
name|target
argument_list|,
operator|!
name|NULL
argument_list|(
name|stopbefore
argument_list|)
argument_list|,
name|oldstate
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|state
operator|.
name|location
argument_list|)
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|state
operator|.
name|depth
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|state
operator|.
name|prevlevelstart
operator|<
literal|0
condition|?
name|Qnil
else|:
name|make_number
argument_list|(
name|state
operator|.
name|prevlevelstart
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|state
operator|.
name|thislevelstart
operator|<
literal|0
condition|?
name|Qnil
else|:
name|make_number
argument_list|(
name|state
operator|.
name|thislevelstart
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|state
operator|.
name|instring
operator|>=
literal|0
condition|?
name|make_number
argument_list|(
name|state
operator|.
name|instring
argument_list|)
else|:
name|Qnil
argument_list|,
name|Fcons
argument_list|(
name|state
operator|.
name|incomment
condition|?
name|Qt
else|:
name|Qnil
argument_list|,
name|Fcons
argument_list|(
name|state
operator|.
name|quoted
condition|?
name|Qt
else|:
name|Qnil
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_syntax_once
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|v
decl_stmt|;
comment|/* Set this now, so first buffer creation can refer to it. */
comment|/* Make it nil before calling copy-syntax-table     so that copy-syntax-table will know not to try to copy from garbage */
name|Vstandard_syntax_table
operator|=
name|Qnil
expr_stmt|;
name|Vstandard_syntax_table
operator|=
name|Fcopy_syntax_table
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
name|v
operator|=
name|XVECTOR
argument_list|(
name|Vstandard_syntax_table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
name|i
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
name|i
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
name|i
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'$'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'%'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'('
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sopen
operator|+
operator|(
literal|')'
operator|<<
literal|8
operator|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|')'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sclose
operator|+
operator|(
literal|'('
operator|<<
literal|8
operator|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'['
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sopen
operator|+
operator|(
literal|']'
operator|<<
literal|8
operator|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|']'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sclose
operator|+
operator|(
literal|'['
operator|<<
literal|8
operator|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'{'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sopen
operator|+
operator|(
literal|'}'
operator|<<
literal|8
operator|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'}'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sclose
operator|+
operator|(
literal|'{'
operator|<<
literal|8
operator|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'"'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sstring
expr_stmt|;
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|'\\'
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Sescape
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|"_-+*/&|<>="
index|[
name|i
index|]
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Ssymbol
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|XFASTINT
argument_list|(
name|v
operator|->
name|contents
index|[
literal|".,;:?!#@~^'`"
index|[
name|i
index|]
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
name|Spunct
expr_stmt|;
block|}
end_block

begin_macro
name|syms_of_syntax
argument_list|()
end_macro

begin_block
block|{
name|Qsyntax_table_p
operator|=
name|intern
argument_list|(
literal|"syntax-table-p"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsyntax_table_p
argument_list|)
expr_stmt|;
comment|/* Mustn't let user clobber this!   DefLispVar ("standard-syntax-table",&Vstandard_syntax_table,     "The syntax table used by buffers that don't specify another.");  */
name|staticpro
argument_list|(
operator|&
name|Vstandard_syntax_table
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"parse-sexp-ignore-comments"
argument_list|,
operator|&
name|parse_sexp_ignore_comments
argument_list|,
literal|"Non-nil means forward-sexp, etc., should treat comments as whitespace.\n\ Non-nil works only when the comment terminator is something like *\/,\n\ and appears only when it ends a comment.\n\ If comments are terminated by newlines,\n\ you must make this variable nil."
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssyntax_table_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssyntax_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstandard_syntax_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scopy_syntax_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_syntax_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Schar_syntax
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smodify_syntax_entry
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdescribe_syntax
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sforward_word
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscan_lists
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscan_sexps
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbackward_prefix_chars
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sparse_partial_sexp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

