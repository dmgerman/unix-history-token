begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Keyboard input; editor command loop.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* Allow config.h to undefine symbols found here.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* Get FIONREAD, if it is available.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_comment
comment|/* Following definition copied from eval.c */
end_comment

begin_struct
struct|struct
name|backtrace
block|{
name|struct
name|backtrace
modifier|*
name|next
decl_stmt|;
name|Lisp_Object
modifier|*
name|function
decl_stmt|;
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
comment|/* Points to vector of args. */
name|int
name|nargs
decl_stmt|;
comment|/* length of vector */
comment|/* if nargs is UNEVALLED, args points to slot holding list of unevalled args */
name|char
name|evalargs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Non-nil disable property on a command means  do not execute it; call disabled-command-hook's value instead. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qdisabled
decl_stmt|,
name|Vdisabled_command_hook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|recent_keys_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index for storing next element into recent_keys */
end_comment

begin_decl_stmt
name|int
name|total_keys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of elements stored into recent_keys */
end_comment

begin_decl_stmt
name|char
name|recent_keys
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds last 100 keystrokes */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|backtrace
modifier|*
name|backtrace_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|getcjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for longjmp to where kbd input is being done. */
end_comment

begin_decl_stmt
name|int
name|waiting_for_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True while doing kbd input */
end_comment

begin_decl_stmt
specifier|static
name|int
name|echoing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True while inside EchoKeys.  Delays C-g throwing. */
end_comment

begin_decl_stmt
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means C-G should cause immediate error-signal. */
end_comment

begin_decl_stmt
name|int
name|help_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character to recognize as the help char.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vhelp_form
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Form to execute when help char is typed.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|Lisp_Vector
modifier|*
name|CurrentGlobalMap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of times get_char has returned.  */
end_comment

begin_decl_stmt
name|int
name|num_input_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last input character read as a command.  */
end_comment

begin_decl_stmt
name|int
name|last_command_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last input character read for any purpose.  */
end_comment

begin_decl_stmt
name|int
name|last_input_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If not -1, a character to be read as the next command input */
end_comment

begin_decl_stmt
name|int
name|unread_command_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Char to use as prefix when a meta character is typed in.  This is bound on entry to minibuffer in case Esc is changed there.  */
end_comment

begin_decl_stmt
name|int
name|meta_prefix_char
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|auto_save_interval
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The number of keystrokes between 				   auto-saves. */
end_comment

begin_expr_stmt
specifier|static
name|Keystrokes
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The number of keystrokes since the last 				   auto-save. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous command, represented by a Lisp object. 				   Does not include prefix commands and arg setting commands */
end_comment

begin_decl_stmt
name|Lisp_Object
name|this_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a command sets this, 				   the value goes into previous-command for the next command. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qself_insert_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qforward_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qbackward_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read_key_sequence stores here the command definition of the  key sequence that it reads */
end_comment

begin_decl_stmt
name|Lisp_Object
name|read_key_sequence_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Form to evaluate (if non-nil) when Emacs is started */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vtop_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User-supplied string to translate input characters through */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vkeyboard_translate_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dribble
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File in which we write all commands we read */
end_comment

begin_comment
comment|/* Nonzero if input is available */
end_comment

begin_decl_stmt
name|int
name|input_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if should obey 0200 bit in input chars as "Meta" */
end_comment

begin_decl_stmt
name|int
name|MetaFlag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for pre-read keyboard input */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|kbd_buffer
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters available in kbd_buffer.  */
end_comment

begin_decl_stmt
name|int
name|kbd_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to next available character in kbd_buffer.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|kbd_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address (if not 0) of word to zero out  if a SIGIO interrupt happens */
end_comment

begin_decl_stmt
name|long
modifier|*
name|input_available_clear_word
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use SIGIO interrupts; zero means use CBREAK mode.    Default is 1 if INTERRUPT_INPUT is defined.  */
end_comment

begin_decl_stmt
name|int
name|interrupt_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero means use ^S/^Q for flow control.  */
end_comment

begin_decl_stmt
name|int
name|flow_control
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_1
end_ifndef

begin_define
define|#
directive|define
name|sigfree
parameter_list|()
value|sigsetmask (0)
end_define

begin_define
define|#
directive|define
name|sigholdx
parameter_list|(
name|sig
parameter_list|)
value|sigsetmask (1<< ((sig) - 1))
end_define

begin_define
define|#
directive|define
name|sigblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (1<< ((sig) - 1))
end_define

begin_define
define|#
directive|define
name|sigunblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (0)
end_define

begin_define
define|#
directive|define
name|sigpausex
parameter_list|(
name|sig
parameter_list|)
value|sigpause (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD4_1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_define
define|#
directive|define
name|SIGIO
value|SIGTINT
end_define

begin_comment
comment|/* sigfree and sigholdx are in sysdep.c */
end_comment

begin_define
define|#
directive|define
name|sigblockx
parameter_list|(
name|sig
parameter_list|)
value|sighold (sig)
end_define

begin_define
define|#
directive|define
name|sigunblockx
parameter_list|(
name|sig
parameter_list|)
value|sigrelse (sig)
end_define

begin_define
define|#
directive|define
name|sigpausex
parameter_list|(
name|sig
parameter_list|)
value|sigpause (sig)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_1 */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|KeyBuf
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for keys from get_char () */
end_comment

begin_expr_stmt
specifier|static
name|NextK
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Next index into KeyBuf */
end_comment

begin_expr_stmt
specifier|static
name|echo_keystrokes
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* True iff we are to echo keystrokes */
end_comment

begin_expr_stmt
specifier|static
name|Echo1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Stuff for final echo */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|keys_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to display in front of echoed keystrokes, or 0 */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(a):(b))
end_define

begin_decl_stmt
specifier|static
name|char
name|echobuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EchoThem
argument_list|(
name|notfinal
argument_list|)
specifier|register
name|notfinal
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|char
modifier|*
name|push_key_description
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
operator|(
name|keys_prompt
operator|||
operator|(
name|echo_keystrokes
operator|&&
name|NextK
operator|)
operator|)
condition|)
comment|/* (!(echo_keystrokes&& (NextK || keys_prompt)) */
return|return;
name|echoing
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|echobuf
expr_stmt|;
if|if
condition|(
name|keys_prompt
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|keys_prompt
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NextK
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|push_key_description
argument_list|(
name|KeyBuf
index|[
name|i
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|KeyBuf
index|[
literal|0
index|]
operator|==
name|help_char
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"(Type ? for further options) "
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|notfinal
operator|&&
name|NextK
operator|&&
operator|!
operator|(
name|NextK
operator|==
literal|1
operator|&&
name|KeyBuf
index|[
literal|0
index|]
operator|==
name|help_char
operator|)
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|minibuf_message
operator|=
name|echobuf
expr_stmt|;
if|if
condition|(
name|notfinal
condition|)
name|Echo1
operator|++
expr_stmt|;
comment|/* set echoed-flag */
if|if
condition|(
name|notfinal
operator|>=
literal|0
condition|)
name|DoDsp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|echoing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|waiting_for_input
operator|&&
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
name|quit_throw_to_get_char
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|Lisp_Object
name|recursive_edit_unwind
argument_list|()
decl_stmt|,
name|command_loop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|cmd_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|top_level_1
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"recursive-edit"
argument_list|,
argument|Frecursive_edit
argument_list|,
argument|Srecursive_edit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Invoke the editor command loop recursively.\n\ Do (throw 'exit nil) within the command loop to make this function return,\n\ or (throw 'exit t) to make this function signal an error.\n\ This function is called by the editor initialization\n\ to begin editing."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|int
name|count
operator|=
name|specpdl_ptr
operator|-
name|specpdl
block|;
name|Lisp_Object
name|val
block|;
name|RecurseDepth
operator|++
block|;
name|RedoModes
operator|++
block|;
name|record_unwind_protect
argument_list|(
name|recursive_edit_unwind
argument_list|,
operator|(
name|RecurseDepth
operator|&&
name|bf_cur
operator|!=
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
operator|)
condition|?
name|Fcurrent_buffer
argument_list|()
else|:
name|Qnil
argument_list|)
block|;
if|if
condition|(
operator|!
name|RecurseDepth
condition|)
name|internal_condition_case
argument_list|(
name|top_level_1
argument_list|,
name|Qerror
argument_list|,
name|cmd_error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
literal|1
condition|)
block|{
name|val
operator|=
name|internal_condition_case
argument_list|(
name|command_loop
argument_list|,
name|Qerror
argument_list|,
name|cmd_error
argument_list|)
expr_stmt|;
comment|/* Value is number if returned due to cmd_error. 	 In that case, just loop around.  */
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
break|break;
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qt
argument_list|)
condition|)
name|Fsignal
argument_list|(
name|Qquit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_macro
unit|}  Lisp_Object
name|recursive_edit_unwind
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|Fset_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|RecurseDepth
operator|--
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|cmd_error
parameter_list|(
name|data
parameter_list|)
name|Lisp_Object
name|data
decl_stmt|;
block|{
name|Lisp_Object
name|errmsg
decl_stmt|,
name|tail
decl_stmt|,
name|errname
decl_stmt|,
name|file_error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qt
expr_stmt|;
name|Vstandard_input
operator|=
name|Qt
expr_stmt|;
name|Vstandard_output
operator|=
name|Qt
expr_stmt|;
name|Vexecuting_macro
operator|=
name|Qnil
expr_stmt|;
name|minibuf_message
operator|=
literal|0
expr_stmt|;
name|Fdiscard_input
argument_list|()
expr_stmt|;
name|Ding
argument_list|()
expr_stmt|;
name|errname
operator|=
name|Fcar
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|errname
argument_list|,
name|Qerror
argument_list|)
condition|)
block|{
name|data
operator|=
name|Fcdr
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|data
argument_list|)
condition|)
name|data
operator|=
name|Qnil
expr_stmt|;
name|errmsg
operator|=
name|Fcar
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|file_error
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
block|{
name|errmsg
operator|=
name|Fget
argument_list|(
name|errname
argument_list|,
name|Qerror_message
argument_list|)
expr_stmt|;
name|file_error
operator|=
name|Fmemq
argument_list|(
name|Qfile_error
argument_list|,
name|Fget
argument_list|(
name|errname
argument_list|,
name|Qerror_conditions
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print an error message including the data items.      This is done by printing it into a scratch buffer      and then making a copy of the text in the buffer. */
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|data
argument_list|)
condition|)
name|data
operator|=
name|Qnil
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* For file-error, make error message by concatenating      all the data items.  They are all strings.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|file_error
argument_list|)
condition|)
name|errmsg
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
operator|,
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|errmsg
argument_list|)
operator|==
name|Lisp_String
condition|)
name|Fprinc
argument_list|(
name|errmsg
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
else|else
name|write_string_1
argument_list|(
literal|"peculiar error"
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|LISTP
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|write_string_1
argument_list|(
name|i
condition|?
literal|", "
else|:
literal|": "
argument_list|,
literal|2
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|file_error
argument_list|)
condition|)
name|Fprinc
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
else|else
name|Fprin1
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
block|}
comment|/* In -batch mode, force out the error message and newlines after it */
if|if
condition|(
name|noninteractive
condition|)
name|message
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qnil
expr_stmt|;
return|return
name|make_number
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|debugger
parameter_list|(
name|sig
parameter_list|,
name|data
parameter_list|)
name|Lisp_Object
name|sig
decl_stmt|,
name|data
decl_stmt|;
block|{
name|Fterpri
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|Fget
argument_list|(
name|sig
argument_list|,
name|Qerror_message
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|data
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Fterpri
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|Lisp_Object
name|command_loop_1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Entry to editor-command-loop.    This level has the catches for exiting/returning to editor command loop.    It returns nil to exit recursive edit, t to abort it.  */
end_comment

begin_function
name|Lisp_Object
name|command_loop
parameter_list|()
block|{
if|if
condition|(
name|RecurseDepth
condition|)
block|{
return|return
name|internal_catch
argument_list|(
name|Qexit
argument_list|,
name|command_loop_1
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|internal_catch
argument_list|(
name|Qtop_level
argument_list|,
name|command_loop_1
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|top_level_1
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|Lisp_Object
name|top_level_1
parameter_list|()
block|{
comment|/* On entry to the outer level, run the startup file */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vtop_level
argument_list|)
condition|)
name|Feval
argument_list|(
name|Vtop_level
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|message
argument_list|(
literal|"Bare impure Emacs (standard Lisp code not loaded)"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"Bare Emacs (standard Lisp code not loaded)"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"top-level"
argument_list|,
argument|Ftop_level
argument_list|,
argument|Stop_level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Exit all recursive editing levels."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Fthrow
argument_list|(
name|Qtop_level
argument_list|,
name|Qnil
argument_list|)
block|; }
name|DEFUN
argument_list|(
literal|"exit-recursive-edit"
argument_list|,
argument|Fexit_recursive_edit
argument_list|,
argument|Sexit_recursive_edit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Exit from the innermost recursive edit or minibuffer."
argument_list|)
operator|(
operator|)
block|{
if|if
condition|(
name|RecurseDepth
condition|)
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No recursive edit is in progress"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"abort-recursive-edit"
operator|,
name|Fabort_recursive_edit
operator|,
name|Sabort_recursive_edit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Abort the command that requested this recursive edit or minibuffer input."
operator|)
operator|(
operator|)
block|{
if|if
condition|(
name|RecurseDepth
condition|)
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No recursive edit is in progress"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* This is the actual command reading loop,  sans error-handling encapsulation */
end_comment

begin_expr_stmt
unit|Lisp_Object
name|Fcommand_execute
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
name|Lisp_Object
name|command_loop_1
parameter_list|()
block|{
name|Lisp_Object
name|cmd
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|int
name|nonundocount
decl_stmt|;
name|char
name|keybuf
index|[
literal|30
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Vprefix_arg
operator|=
name|Qnil
expr_stmt|;
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|Echo1
operator|=
literal|0
expr_stmt|;
name|NextK
operator|=
literal|0
expr_stmt|;
name|Vstandard_input
operator|=
name|Qt
expr_stmt|;
name|Vstandard_output
operator|=
name|Qt
expr_stmt|;
name|last_command
operator|=
name|Qt
expr_stmt|;
name|nonundocount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Cause a garbage collection now */
comment|/* Since we can free the most stuff here.  */
endif|#
directive|endif
comment|/* C_ALLOCA */
comment|/* Install chars successfully executed in kbd macro */
if|if
condition|(
name|defining_kbd_macro
condition|)
name|finalize_kbd_macro_chars
argument_list|()
expr_stmt|;
comment|/* Make sure current window's buffer is selected.  */
if|if
condition|(
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
operator|!=
name|bf_cur
condition|)
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If minibuffer on and echo area in use, 	 wait 2 sec and redraw minibufer.  */
if|if
condition|(
name|MinibufDepth
operator|&&
name|minibuf_message
condition|)
block|{
name|Fsit_for
argument_list|(
name|make_number
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|minibuf_message
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
block|{
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|unread_command_char
operator|=
name|Ctl
argument_list|(
literal|'g'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read next key sequence; i gets its length.  */
name|i
operator|=
name|read_key_sequence
argument_list|(
name|keybuf
argument_list|,
sizeof|sizeof
name|keybuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
comment|/* End of file -- happens only in */
return|return
name|Qnil
return|;
comment|/* a kbd macro, at the end */
name|last_command_char
operator|=
name|keybuf
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|cmd
operator|=
name|read_key_sequence_cmd
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
block|{
name|Vexecuting_macro
operator|=
name|Qt
expr_stmt|;
name|QUIT
expr_stmt|;
comment|/* Make some noise. */
comment|/* Will return since macro now empty. */
block|}
block|}
if|if
condition|(
name|NULL
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|Ding
argument_list|()
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
name|Vprefix_arg
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
block|{
name|this_command
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Vprefix_arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|cmd
argument_list|,
name|Qforward_char
argument_list|)
operator|&&
name|point
operator|<=
name|NumCharacters
condition|)
block|{
name|lose
operator|=
name|CharAt
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|point
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lose
operator|>=
literal|' '
operator|&&
name|lose
operator|<
literal|0177
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|>=
name|bf_modified
operator|)
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_point
argument_list|)
operator|==
name|point
operator|)
operator|&&
operator|!
name|windows_or_buffers_changed
operator|&&
operator|!
name|detect_input_pending
argument_list|()
operator|&&
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
name|direct_output_forward_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|directly_done
goto|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|cmd
argument_list|,
name|Qbackward_char
argument_list|)
operator|&&
name|point
operator|>
name|FirstCharacter
condition|)
block|{
name|SetPoint
argument_list|(
name|point
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lose
operator|=
name|CharAt
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|lose
operator|>=
literal|' '
operator|&&
name|lose
operator|<
literal|0177
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|>=
name|bf_modified
operator|)
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_point
argument_list|)
operator|==
name|point
operator|)
operator|&&
operator|!
name|windows_or_buffers_changed
operator|&&
operator|!
name|detect_input_pending
argument_list|()
operator|&&
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
name|direct_output_forward_char
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|directly_done
goto|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|cmd
argument_list|,
name|Qself_insert_command
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|nonundocount
operator|||
name|nonundocount
operator|>=
literal|20
condition|)
block|{
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|nonundocount
operator|=
literal|0
expr_stmt|;
block|}
name|nonundocount
operator|++
expr_stmt|;
block|}
name|lose
operator|=
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|<
name|bf_modified
operator|)
operator|||
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_point
argument_list|)
operator|!=
name|point
operator|)
operator|||
name|bf_modified
operator|<=
name|bf_cur
operator|->
name|save_modified
operator|||
name|windows_or_buffers_changed
operator|||
name|detect_input_pending
argument_list|()
operator|||
operator|!
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|SelfInsert
argument_list|(
name|last_command_char
argument_list|)
condition|)
block|{
name|lose
operator|=
literal|1
expr_stmt|;
name|nonundocount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lose
operator|&&
operator|(
name|point
operator|==
name|NumCharacters
operator|+
literal|1
operator|||
name|CharAt
argument_list|(
name|point
argument_list|)
operator|==
literal|'\n'
operator|)
operator|&&
name|last_command_char
operator|>=
literal|' '
operator|&&
name|last_command_char
operator|<
literal|0177
condition|)
name|direct_output_for_insert
argument_list|(
name|last_command_char
argument_list|)
expr_stmt|;
goto|goto
name|directly_done
goto|;
block|}
block|}
comment|/* Here for a command that isn't executed directly */
name|nonundocount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Vprefix_arg
argument_list|)
operator|&&
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|Fcommand_execute
argument_list|(
name|cmd
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|directly_done
label|:
empty_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|Vprefix_arg
argument_list|)
condition|)
block|{
name|last_command
operator|=
name|this_command
expr_stmt|;
name|NextK
operator|=
literal|0
expr_stmt|;
name|Echo1
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Input of single characters from keyboard */
end_comment

begin_function_decl
name|Lisp_Object
name|print_help
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|echo_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|echo_now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alarm interrupt calls this and requests echoing at earliest safe time. */
end_comment

begin_macro
name|request_echo
argument_list|()
end_macro

begin_block
block|{
comment|/* Note: no need to reestablish handler on USG systems      because it is established, if approriate, each time an alarm is requested.  */
if|#
directive|if
name|defined
argument_list|(
name|BSD4_1
argument_list|)
operator|&&
name|defined
argument_list|(
name|subprocesses
argument_list|)
specifier|extern
name|int
name|select_alarmed
decl_stmt|;
if|if
condition|(
name|select_alarmed
operator|==
literal|0
condition|)
block|{
name|select_alarmed
operator|=
literal|1
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_1
name|sigisheld
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|echo_now
condition|)
name|EchoThem
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|echo_flag
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
name|sigunhold
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* read a character from the keyboard; call the redisplay if needed */
end_comment

begin_comment
comment|/* commandflag nonzero means auto-saving may be considered */
end_comment

begin_macro
name|get_char
argument_list|(
argument|commandflag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|commandflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|alarmtime
operator|=
name|echo_keystrokes
expr_stmt|;
name|int
name|count
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
extern|extern request_echo (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
operator|(
name|c
operator|=
name|unread_command_char
operator|)
operator|>=
literal|0
condition|)
block|{
name|unread_command_char
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|reread
goto|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|!=
name|Lisp_String
operator|||
name|XSTRING
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|->
name|size
operator|<=
name|executing_macro_index
condition|)
return|return
operator|-
literal|1
return|;
name|QUIT
expr_stmt|;
name|c
operator|=
name|XSTRING
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|->
name|data
index|[
name|executing_macro_index
operator|++
index|]
expr_stmt|;
goto|goto
name|from_macro
goto|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|input_pending
operator|&&
operator|!
name|detect_input_pending
argument_list|()
condition|)
block|{
name|DoDsp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_save_interval
operator|>
literal|0
operator|&&
name|commandflag
operator|&&
name|Keystrokes
operator|>
name|auto_save_interval
operator|&&
name|Keystrokes
operator|>
literal|20
condition|)
block|{
name|Fdo_auto_save
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
name|Keystrokes
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|Keystrokes
operator|++
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_setjmp
argument_list|(
name|getcjmp
argument_list|)
condition|)
block|{
name|c
operator|=
name|Ctl
argument_list|(
literal|'g'
argument_list|)
expr_stmt|;
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|input_available_clear_word
operator|=
literal|0
expr_stmt|;
goto|goto
name|non_reread
goto|;
block|}
end_if

begin_comment
comment|/* If echoing already, we will echo without delay, so need no interrupt */
end_comment

begin_comment
comment|/* If no keys accumulated yet, need no interrupt. */
end_comment

begin_comment
comment|/* If minibuffer active, do not echo keystrokes. */
end_comment

begin_if
if|if
condition|(
name|Echo1
operator|||
operator|!
name|NextK
operator|||
name|MinibufDepth
condition|)
name|alarmtime
operator|=
literal|0
expr_stmt|;
end_if

begin_comment
comment|/* Message turns off echoing unless more keystrokes turn it on again. */
end_comment

begin_if
if|if
condition|(
name|minibuf_message
operator|&&
name|minibuf_message
operator|!=
name|echobuf
condition|)
name|alarmtime
operator|=
literal|0
operator|,
name|Echo1
operator|=
literal|0
operator|,
name|NextK
operator|=
literal|0
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|Echo1
condition|)
comment|/* If already echoing, put a dash at the end now */
name|EchoThem
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Else start echoing if user waits more than `alarmtime' seconds. */
end_comment

begin_if
if|if
condition|(
name|alarmtime
operator|>
literal|0
condition|)
block|{
comment|/* This interrupt either calls EchoThem right away 	 or sets echo_flag, which causes EchoThem to be called 	 by set_waiting_for_input's next invocation.  */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|request_echo
argument_list|)
expr_stmt|;
name|echo_flag
operator|=
literal|0
expr_stmt|;
name|echo_now
operator|=
literal|0
expr_stmt|;
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|alarmtime
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* This should be impossible, but I suspect it happens.  */
end_comment

begin_if
if|if
condition|(
name|getcjmp
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_expr_stmt
name|c
operator|=
name|kbd_buffer_get_char
argument_list|()
expr_stmt|;
end_expr_stmt

begin_label
name|non_reread
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* Cause immediate crash if anyone tries to throw back to this frame      beyond here.  */
end_comment

begin_expr_stmt
name|getcjmp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Cancel alarm if it was set and has not already gone off. */
end_comment

begin_if
if|if
condition|(
name|alarmtime
operator|>
literal|0
condition|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|minibuf_message
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
end_if

begin_expr_stmt
name|c
operator|&=
name|MetaFlag
condition|?
literal|0377
else|:
literal|0177
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|Vkeyboard_translate_table
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|Vkeyboard_translate_table
argument_list|)
operator|->
name|size
operator|>
name|c
condition|)
name|c
operator|=
name|XSTRING
argument_list|(
name|Vkeyboard_translate_table
argument_list|)
operator|->
name|data
index|[
name|c
index|]
expr_stmt|;
end_if

begin_expr_stmt
name|total_keys
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|recent_keys
index|[
name|recent_keys_index
index|]
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|recent_keys_index
operator|=
operator|(
name|recent_keys_index
operator|+
literal|1
operator|)
operator|%
sizeof|sizeof
name|recent_keys
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dribble
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|dribble
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|dribble
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|store_kbd_macro_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|from_macro
label|:
end_label

begin_if
if|if
condition|(
name|NextK
operator|<
sizeof|sizeof
name|KeyBuf
condition|)
name|KeyBuf
index|[
name|NextK
operator|++
index|]
operator|=
name|c
expr_stmt|;
end_if

begin_comment
comment|/* If already echoing, echo right away. */
end_comment

begin_if
if|if
condition|(
name|Echo1
condition|)
name|EchoThem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_label
name|reread
label|:
end_label

begin_comment
comment|/* If the first character of a command is being reread,      store it in case a pause follows and it must be echoed later.      This has no effect on a non-reread character      since NextK is not zero here for them.  */
end_comment

begin_if
if|if
condition|(
name|NextK
operator|==
literal|0
condition|)
name|KeyBuf
index|[
name|NextK
operator|++
index|]
operator|=
name|c
expr_stmt|;
end_if

begin_expr_stmt
name|last_input_char
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|num_input_chars
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Process the help character specially if enabled */
end_comment

begin_if
if|if
condition|(
name|c
operator|==
name|help_char
operator|&&
operator|!
name|NULL
argument_list|(
name|Vhelp_form
argument_list|)
condition|)
block|{
name|count
operator|=
name|specpdl_ptr
operator|-
name|specpdl
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|save_window_restore
argument_list|,
name|save_window_save
argument_list|()
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Feval
argument_list|(
name|Vhelp_form
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Help*"
argument_list|,
name|print_help
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|NextK
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|get_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove the help from the screen */
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|DoDsp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|040
condition|)
block|{
name|NextK
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|get_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|c
return|;
end_return

begin_macro
unit|}  Lisp_Object
name|print_help
argument_list|(
argument|object
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|object
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Fprinc
argument_list|(
name|object
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Low level keyboard input.  Read characters into kbd_buffer  from which they are obtained by kbd_buffer_get_char.  */
end_comment

begin_macro
name|kbd_buffer_get_char
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|nread
decl_stmt|;
if|if
condition|(
name|noninteractive
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
comment|/* In batch mode, die at input eof */
name|Fkill_emacs
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/* Either ordinary input buffer or C-g buffered means we can return.  */
while|while
condition|(
operator|!
name|kbd_count
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
name|quit_throw_to_get_char
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIO
name|gobble_input
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SIGIO */
if|if
condition|(
operator|!
name|kbd_count
condition|)
block|{
ifdef|#
directive|ifdef
name|subprocesses
name|wait_reading_process_input
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|SIGIO
if|if
condition|(
name|interrupt_input
condition|)
block|{
name|sigblockx
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|set_waiting_for_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|kbd_count
condition|)
name|sigpausex
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|clear_waiting_for_input
argument_list|()
expr_stmt|;
name|sigunblockx
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|interrupt_input
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not SIGIO */
endif|#
directive|endif
comment|/* subprocesses */
if|if
condition|(
operator|!
name|interrupt_input
operator|&&
operator|!
name|kbd_count
condition|)
block|{
name|read_avail_input
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|input_pending
operator|=
operator|--
name|kbd_count
operator|>
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|kbd_ptr
expr_stmt|;
comment|/* *kbd_ptr++ would have a timing error. */
name|kbd_ptr
operator|++
expr_stmt|;
comment|/* See kbd_buffer_store_char. */
return|return
name|c
operator|&
literal|0377
return|;
comment|/* Clean up if sign was extended. */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Store into *addr the number of terminal input chars available.    Equivalent to ioctl (0, FIONREAD, addr) but works    even if FIONREAD does not exist.  */
end_comment

begin_macro
name|get_input_pending
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|FIONREAD
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
name|addr
argument_list|)
operator|<
literal|0
condition|)
operator|*
name|addr
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* no FIONREAD */
name|read_avail_input
argument_list|()
expr_stmt|;
operator|*
name|addr
operator|=
name|kbd_count
expr_stmt|;
endif|#
directive|endif
comment|/* no FIONREAD */
block|}
end_block

begin_comment
comment|/* Read any terminal input already buffered up by the system    into the kbd_buffer, assuming the buffer is currently empty.  */
end_comment

begin_macro
name|read_avail_input
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|FIONREAD
name|int
name|nread
decl_stmt|;
name|get_input_pending
argument_list|(
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|>
sizeof|sizeof
name|kbd_buffer
condition|)
name|nread
operator|=
sizeof|sizeof
name|kbd_buffer
expr_stmt|;
if|if
condition|(
operator|!
name|nread
condition|)
name|nread
operator|=
literal|1
expr_stmt|;
name|set_waiting_for_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kbd_count
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|kbd_buffer
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|clear_waiting_for_input
argument_list|()
expr_stmt|;
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
else|#
directive|else
comment|/* no FIONREAD */
ifdef|#
directive|ifdef
name|USG
comment|/* Assume this is only done when the buffer is empty.      It's stupid to call this function without checking kbd_count.  */
if|if
condition|(
name|kbd_count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
name|kbd_count
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|kbd_buffer
argument_list|,
sizeof|sizeof
name|kbd_buffer
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not USG */
name|you
name|lose
endif|#
directive|endif
comment|/* not USG */
endif|#
directive|endif
comment|/* no FIONREAD */
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_comment
comment|/* for entire page */
end_comment

begin_macro
name|gobble_input
argument_list|()
end_macro

begin_block
block|{
name|int
name|nread
decl_stmt|;
if|if
condition|(
name|interrupt_input
condition|)
block|{
name|get_input_pending
argument_list|(
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
condition|)
block|{
name|sigholdx
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|input_available_signal
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|sigfree
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Set this for debugging, to have a way to get out */
end_comment

begin_decl_stmt
name|int
name|stop_character
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store a character obtained at interrupt level into kbd_buffer, fifo */
end_comment

begin_macro
name|kbd_buffer_store_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|MetaFlag
condition|)
name|c
operator|&=
literal|0177
expr_stmt|;
else|else
name|c
operator|&=
literal|0377
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|07
condition|)
block|{
name|interrupt_signal
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|&&
name|c
operator|==
name|stop_character
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
comment|/* Support possible in later USG versions */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fake_suspend
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not SIGTSTP */
return|return;
block|}
if|if
condition|(
name|kbd_ptr
operator|!=
name|kbd_buffer
condition|)
block|{
name|bcopy
argument_list|(
name|kbd_ptr
argument_list|,
name|kbd_buffer
argument_list|,
name|kbd_count
argument_list|)
expr_stmt|;
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
block|}
if|if
condition|(
name|kbd_count
operator|<
sizeof|sizeof
name|kbd_buffer
condition|)
block|{
name|kbd_buffer
index|[
name|kbd_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|input_available_signal
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
specifier|extern
name|int
name|select_alarmed
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USG
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
name|signal
argument_list|(
name|signo
argument_list|,
name|input_available_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
ifdef|#
directive|ifdef
name|BSD4_1
name|sigisheld
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|input_available_clear_word
condition|)
operator|*
name|input_available_clear_word
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|get_input_pending
argument_list|(
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|BSD4_1
name|select_alarmed
operator|=
literal|1
expr_stmt|;
comment|/* Force the select emulator back to life */
endif|#
directive|endif
if|if
condition|(
name|read_socket_hook
condition|)
block|{
name|nread
operator|=
call|(
modifier|*
name|read_socket_hook
call|)
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nread
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|nread
operator|>
sizeof|sizeof
name|buf
condition|)
name|nread
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|nread
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nread
condition|;
name|i
operator|++
control|)
block|{
name|kbd_buffer_store_char
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Don't look at input that follows a C-g too closely. 	     This reduces lossage due to autorepeat on C-g.  */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
name|Ctl
argument_list|(
literal|'G'
argument_list|)
condition|)
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|BSD4_1
name|sigfree
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGIO */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Read a sequence of keys that ends with a non prefix character,  and store them in keybuf, a buffer of size bufsize.  Prompt with `prompt'.  Echo starting immediately unless `prompt' is 0.  Return the length of the key sequence stored. */
end_comment

begin_function
name|int
name|read_key_sequence
parameter_list|(
name|keybuf
parameter_list|,
name|bufsize
parameter_list|,
name|prompt
parameter_list|)
name|char
modifier|*
name|keybuf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|Lisp_Object
name|nextlocal
decl_stmt|,
name|nextglobal
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|nextc
decl_stmt|;
name|Lisp_Object
name|local
decl_stmt|,
name|global
decl_stmt|;
name|keys_prompt
operator|=
name|prompt
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
name|NextK
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prompt
operator|&&
name|INTERACTIVE
condition|)
name|EchoThem
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nextlocal
operator|=
name|bf_cur
operator|->
name|keymap
expr_stmt|;
name|XSET
argument_list|(
name|nextglobal
argument_list|,
name|Lisp_Vector
argument_list|,
name|CurrentGlobalMap
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|nextc
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|nextlocal
argument_list|)
operator|||
operator|!
name|NULL
argument_list|(
name|nextglobal
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|bufsize
condition|)
name|error
argument_list|(
literal|"key sequence too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextc
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|nextc
expr_stmt|;
name|nextc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|c
operator|=
name|get_char
argument_list|(
operator|!
name|prompt
argument_list|)
expr_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|>=
literal|0200
condition|)
block|{
name|nextc
operator|=
name|c
operator|&
literal|0177
expr_stmt|;
name|c
operator|=
name|meta_prefix_char
expr_stmt|;
block|}
name|keybuf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|global
operator|=
operator|!
name|NULL
argument_list|(
name|nextglobal
argument_list|)
condition|?
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|nextglobal
argument_list|,
name|c
argument_list|)
argument_list|)
else|:
name|Qnil
expr_stmt|;
name|local
operator|=
operator|!
name|NULL
argument_list|(
name|nextlocal
argument_list|)
condition|?
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|nextlocal
argument_list|,
name|c
argument_list|)
argument_list|)
else|:
name|Qnil
expr_stmt|;
name|nextlocal
operator|=
name|Qnil
expr_stmt|;
name|nextglobal
operator|=
name|Qnil
expr_stmt|;
name|read_key_sequence_cmd
operator|=
operator|!
name|NULL
argument_list|(
name|local
argument_list|)
condition|?
name|local
else|:
name|global
expr_stmt|;
comment|/* trace symbols to their function definitions */
while|while
condition|(
name|XTYPE
argument_list|(
name|global
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|NULL
argument_list|(
name|global
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|global
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|global
operator|=
name|XSYMBOL
argument_list|(
name|global
argument_list|)
operator|->
name|function
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|local
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|NULL
argument_list|(
name|local
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|local
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|local
operator|=
name|XSYMBOL
argument_list|(
name|local
argument_list|)
operator|->
name|function
expr_stmt|;
comment|/* Are the definitions prefix characters? */
if|if
condition|(
name|XTYPE
argument_list|(
name|local
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|LISTP
argument_list|(
name|local
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|local
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
operator|||
comment|/* If nextc is set, we are processing a prefix char 	     that represents a meta-bit. 	     Let a global prefix definition override a local non-prefix. 	     This is for minibuffers that redefine Escape for completion. 	     A real Escape gets completion, but Meta bits get ESC-prefix.  */
operator|(
operator|(
name|NULL
argument_list|(
name|local
argument_list|)
operator|||
name|nextc
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|XTYPE
argument_list|(
name|global
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|LISTP
argument_list|(
name|global
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|global
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|local
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|LISTP
argument_list|(
name|local
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|local
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
condition|)
name|nextlocal
operator|=
name|local
expr_stmt|;
else|else
name|nextlocal
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|global
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|LISTP
argument_list|(
name|global
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|global
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
condition|)
name|nextglobal
operator|=
name|global
expr_stmt|;
else|else
name|nextglobal
operator|=
name|Qnil
expr_stmt|;
block|}
block|}
name|keys_prompt
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"read-key-sequence"
argument_list|,
argument|Fread_key_sequence
argument_list|,
argument|Sread_key_sequence
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Read a sequence of keystrokes and return as a string.\n\ The sequence is sufficient to specify a non-prefix command\n\ starting from the current local and global keymaps.\n\ A C-g typed while in this function is treated like\n\ any other character, and quit-flag is not set.\n\ One arg, PROMPT, a prompt string or  nil, meaning do not prompt specially."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|keybuf
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|prompt
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
name|i
operator|=
name|read_key_sequence
argument_list|(
name|keybuf
argument_list|,
sizeof|sizeof
name|keybuf
argument_list|,
operator|(
name|NULL
argument_list|(
name|prompt
argument_list|)
operator|)
condition|?
literal|0
else|:
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
name|keybuf
argument_list|,
name|i
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"command-execute"
argument_list|,
argument|Fcommand_execute
argument_list|,
argument|Scommand_execute
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Execute CMD as an editor command.\n\ CMD must be a symbol with a function definition;\n\ also, it must satisfy the commandp predicate."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|cmd
operator|,
name|record
operator|)
name|Lisp_Object
name|cmd
operator|,
name|record
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|final
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|prefixarg
decl_stmt|;
name|struct
name|backtrace
name|backtrace
decl_stmt|;
name|prefixarg
operator|=
name|Vprefix_arg
operator|,
name|Vprefix_arg
operator|=
name|Qnil
expr_stmt|;
name|Vcurrent_prefix_arg
operator|=
name|prefixarg
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|cmd
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|tem
operator|=
name|Fget
argument_list|(
name|cmd
argument_list|,
name|Qdisabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Fapply
argument_list|(
name|Vdisabled_command_hook
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|final
operator|=
name|cmd
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|final
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|Qunbound
argument_list|,
name|XSYMBOL
argument_list|(
name|final
argument_list|)
operator|->
name|function
argument_list|)
condition|)
name|Fsymbol_function
argument_list|(
name|final
argument_list|)
expr_stmt|;
comment|/* Get an error! */
name|final
operator|=
name|XSYMBOL
argument_list|(
name|final
argument_list|)
operator|->
name|function
expr_stmt|;
block|}
if|if
condition|(
name|LISTP
argument_list|(
name|final
argument_list|)
operator|&&
operator|(
name|tem
operator|=
name|Fcar
argument_list|(
name|final
argument_list|)
operator|,
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qautoload
argument_list|)
operator|)
condition|)
name|do_autoload
argument_list|(
name|final
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|LISTP
argument_list|(
name|final
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|final
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
name|backtrace
operator|.
name|next
operator|=
name|backtrace_list
expr_stmt|;
name|backtrace_list
operator|=
operator|&
name|backtrace
expr_stmt|;
name|backtrace
operator|.
name|function
operator|=
operator|&
name|Qcall_interactively
expr_stmt|;
name|backtrace
operator|.
name|args
operator|=
operator|&
name|cmd
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
literal|1
expr_stmt|;
name|backtrace
operator|.
name|evalargs
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|Fcall_interactively
argument_list|(
name|cmd
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|backtrace_list
operator|=
name|backtrace
operator|.
name|next
expr_stmt|;
return|return
name|tem
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|final
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
return|return
name|Fexecute_kbd_macro
argument_list|(
name|final
argument_list|,
name|prefixarg
argument_list|)
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|detect_input_pending
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|input_pending
condition|)
block|{
if|if
condition|(
name|kbd_count
condition|)
name|input_pending
operator|=
name|kbd_count
expr_stmt|;
else|else
name|get_input_pending
argument_list|(
operator|&
name|input_pending
argument_list|)
expr_stmt|;
block|}
return|return
name|input_pending
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"input-pending-p"
argument_list|,
argument|Finput_pending_p
argument_list|,
argument|Sinput_pending_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"T if command input is currently available with no waiting.\n\ Actually, the value is NIL only if we can be sure that no input is available."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|unread_command_char
operator|>=
literal|0
condition|)
return|return
name|Qt
return|;
end_expr_stmt

begin_return
return|return
name|detect_input_pending
argument_list|()
condition|?
name|Qt
else|:
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"recent-keys"
operator|,
name|Frecent_keys
operator|,
name|Srecent_keys
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return string of last 100 chars read from terminal."
operator|)
operator|(
operator|)
block|{
name|Lisp_Object
name|val
block|;
if|if
condition|(
name|total_keys
operator|<
sizeof|sizeof
name|recent_keys
condition|)
return|return
name|make_string
argument_list|(
name|recent_keys
argument_list|,
name|total_keys
argument_list|)
return|;
name|val
operator|=
name|make_string
argument_list|(
name|recent_keys
argument_list|,
sizeof|sizeof
name|recent_keys
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bcopy
argument_list|(
name|recent_keys
operator|+
name|recent_keys_index
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|,
sizeof|sizeof
name|recent_keys
operator|-
name|recent_keys_index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bcopy
argument_list|(
name|recent_keys
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
operator|+
sizeof|sizeof
name|recent_keys
operator|-
name|recent_keys_index
argument_list|,
name|recent_keys_index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|val
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"this-command-keys"
operator|,
name|Fthis_command_keys
operator|,
name|Sthis_command_keys
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return string of the keystrokes that invoked this command."
operator|)
operator|(
operator|)
block|{
return|return
name|make_string
argument_list|(
name|KeyBuf
argument_list|,
name|NextK
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"recursion-depth"
argument_list|,
argument|Frecursion_depth
argument_list|,
argument|Srecursion_depth
argument_list|,
literal|"Return the current depth in recursive edits."
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|RecurseDepth
argument_list|)
end_macro

begin_macro
name|DEFUN
argument_list|(
literal|"open-dribble-file"
argument_list|,
argument|Fopen_dribble_file
argument_list|,
argument|Sopen_dribble_file
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"FOpen dribble file: "
argument_list|,
literal|"Start writing all keyboard characters to FILE."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|file
operator|=
name|Fexpand_file_name
argument_list|(
name|file
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|dribble
operator|=
name|fopen
argument_list|(
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"discard-input"
argument_list|,
argument|Fdiscard_input
argument_list|,
argument|Sdiscard_input
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Discard the contents of the terminal input buffer.\n\ Also flush any kbd macro definition in progress."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|defining_kbd_macro
operator|=
literal|0
block|;
name|RedoModes
operator|++
block|;
name|unread_command_char
operator|=
operator|-
literal|1
block|;
name|discard_tty_input
argument_list|()
block|;
name|kbd_count
operator|=
literal|0
block|;
name|input_pending
operator|=
literal|0
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"suspend-emacs"
argument_list|,
argument|Fsuspend_emacs
argument_list|,
argument|Ssuspend_emacs
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Stop Emacs and return to superior process.  You can resume.\n\ If optional arg STUFFSTRING is non-nil, its characters are stuffed\n\ to be read as terminal input by Emacs's superior shell."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|stuffstring
operator|)
name|Lisp_Object
name|stuffstring
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
comment|/* Support possible in later USG versions */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|stuffstring
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
name|stuffstring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|stuff_buffered_input
argument_list|(
name|stuffstring
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|init_sys_modes
argument_list|()
expr_stmt|;
else|#
directive|else
name|fake_suspend
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|Qnil
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|SIGTSTP
end_ifndef

begin_comment
comment|/* On a system where suspending is not implemented,    instead fork a subshell and let it talk directly to the terminal    while we wait.  */
end_comment

begin_macro
name|fake_suspend
argument_list|()
end_macro

begin_block
block|{
name|int
name|pid
init|=
name|fork
argument_list|()
decl_stmt|;
name|int
name|spid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|sh
decl_stmt|;
name|int
function_decl|(
modifier|*
name|interrupt
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|quit
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|term
function_decl|)
parameter_list|()
function_decl|;
name|unsigned
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Can't spawn subshell"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|sh
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
literal|0
condition|)
name|sh
operator|=
literal|"sh"
expr_stmt|;
comment|/* Use our buffer's default directory for the subshell.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|temp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|data
argument_list|,
name|temp
argument_list|,
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|i
operator|=
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|temp
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp
index|[
name|i
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|temp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|chdir
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|execlp
argument_list|(
name|sh
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
literal|"Can't execute subshell"
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|interrupt
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|quit
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|term
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|wait_for_termination
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|init_sys_modes
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no SIGTSTP */
end_comment

begin_comment
comment|/* If STUFFSTRING is a string, stuff its contents as pending terminal input.    Then in any case stuff anthing Emacs has read ahead and not used.  */
end_comment

begin_macro
name|stuff_buffered_input
argument_list|(
argument|stuffstring
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|stuffstring
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
comment|/* stuff_char works only in BSD, versions 4.2 and up.  */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|~
name|defined
argument_list|(
name|BSD4_1
argument_list|)
if|if
condition|(
name|XTYPE
argument_list|(
name|stuffstring
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|p
operator|=
name|XSTRING
argument_list|(
name|stuffstring
argument_list|)
operator|->
name|data
expr_stmt|;
name|count
operator|=
name|XSTRING
argument_list|(
name|stuffstring
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|stuff_char
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|stuff_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Anything we have read ahead, put back for the shell to read.  */
while|while
condition|(
name|kbd_count
condition|)
block|{
name|stuff_char
argument_list|(
operator|*
name|kbd_ptr
operator|++
argument_list|)
expr_stmt|;
name|kbd_count
operator|--
expr_stmt|;
block|}
name|input_pending
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BSD and not BSD4_1 */
block|}
end_block

begin_escape
end_escape

begin_macro
name|set_waiting_for_input
argument_list|(
argument|word_to_clear
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|word_to_clear
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|input_available_clear_word
operator|=
name|word_to_clear
expr_stmt|;
comment|/* Tell interrupt_signal to throw back to get_char,  */
name|waiting_for_input
operator|=
literal|1
expr_stmt|;
comment|/* If interrupt_signal was called before and buffered a C-g,      make it run again now, to avoid timing error.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
name|quit_throw_to_get_char
argument_list|()
expr_stmt|;
comment|/* Tell alarm signal to echo right away */
name|echo_now
operator|=
literal|1
expr_stmt|;
comment|/* If alarm has gone off already, echo now.  */
if|if
condition|(
name|echo_flag
condition|)
block|{
name|EchoThem
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|echo_flag
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|clear_waiting_for_input
argument_list|()
end_macro

begin_block
block|{
comment|/* Tell interrupt_signal not to throw back to get_char,  */
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|echo_now
operator|=
literal|0
expr_stmt|;
name|input_available_clear_word
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This routine is called at interrupt level in response to C-G.  If interrupt_input, this is the handler for SIGINT.  Otherwise, it is called from kbd_buffer_store_char,  in handling SIGIO or SIGTINT.   If `waiting_for_input' is non zero, then unless `echoing' is nonzero,  immediately throw back to get_char.   Otherwise it sets the Lisp variable  quit-flag  not-nil.  This causes  eval  to throw, when it gets a chance.  If  quit-flag  is already non-nil, it stops the job right away.  */
end_comment

begin_macro
name|interrupt_signal
argument_list|()
end_macro

begin_block
block|{
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|USG
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
name|Echo1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|sigfree
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
comment|/* Support possible in later USG versions */
comment|/*  * On systems which can suspend the current process and return to the original  * shell, this command causes the user to end up back at the shell.  * The "Auto-save" and "Abort" questions are not asked until  * the user elects to return to emacs, at which point he can save the current  * job and either dump core or continue.  */
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Perhaps should really fork an inferior shell? 	 But that would not provide any way to get back 	 to the original shell, ever.  */
name|printf
argument_list|(
literal|"No support for stopping a process in this Unix version;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"you can continue or abort.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not SIGTSTP */
name|printf
argument_list|(
literal|"Auto-save? (y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&
operator|~
literal|040
operator|)
operator|==
literal|'Y'
condition|)
name|Fdo_auto_save
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Abort (and dump core)? (y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&
operator|~
literal|040
operator|)
operator|==
literal|'Y'
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Continuing...\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|init_sys_modes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* If executing a function that wants to be interrupted out of 	     and the user has not deferred quitting by binding `inhibit-quit' 	     then quit right away.  */
if|if
condition|(
name|immediate_quit
operator|&&
name|NULL
argument_list|(
name|Vinhibit_quit
argument_list|)
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|sigfree
argument_list|()
expr_stmt|;
name|Fsignal
argument_list|(
name|Qquit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Else request quit when it's safe */
name|Vquit_flag
operator|=
name|Qt
expr_stmt|;
block|}
if|if
condition|(
name|waiting_for_input
operator|&&
operator|!
name|echoing
condition|)
name|quit_throw_to_get_char
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Handle a C-g by making get_char return C-g.  */
end_comment

begin_macro
name|quit_throw_to_get_char
argument_list|()
end_macro

begin_block
block|{
name|sigfree
argument_list|()
expr_stmt|;
comment|/* Prevent another signal from doing this before we finish.  */
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|input_pending
operator|=
literal|0
expr_stmt|;
name|unread_command_char
operator|=
operator|-
literal|1
expr_stmt|;
name|_longjmp
argument_list|(
name|getcjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"set-input-mode"
argument_list|,
argument|Fset_input_mode
argument_list|,
argument|Sset_input_mode
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set mode of reading keyboard input.\n\ First arg non-nil means use input interrupts; nil means use CBREAK mode.\n\ Second arg non-nil means use ^S/^Q flow control\n\  (no effect except in CBREAK mode)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|interrupt
operator|,
name|flow
operator|)
name|Lisp_Object
name|interrupt
operator|,
name|flow
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|reset_sys_modes
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIO
name|interrupt_input
operator|=
operator|!
name|NULL
argument_list|(
name|interrupt
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not SIGIO */
name|interrupt_input
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not SIGIO */
name|flow_control
operator|=
operator|!
name|NULL
argument_list|(
name|flow
argument_list|)
expr_stmt|;
name|init_sys_modes
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_keyboard
argument_list|()
end_macro

begin_block
block|{
name|RecurseDepth
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Correct, before outermost invocation of editor loop */
name|keys_prompt
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|unread_command_char
operator|=
operator|-
literal|1
expr_stmt|;
name|recent_keys_index
operator|=
literal|0
expr_stmt|;
name|total_keys
operator|=
literal|0
expr_stmt|;
name|kbd_count
operator|=
literal|0
expr_stmt|;
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
name|input_pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|noninteractive
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
comment|/* On USG systems, C-g is set up for both SIGINT and SIGQUIT 	 and we can't tell which one it will give us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
block|}
ifdef|#
directive|ifdef
name|SIGIO
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|input_available_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGIO
comment|/* Use interrupt input by default, if it works and noninterrupt input    has deficiencies.  */
ifdef|#
directive|ifdef
name|INTERRUPT_INPUT
name|interrupt_input
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|interrupt_input
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sigfree
argument_list|()
expr_stmt|;
name|dribble
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|syms_of_keyboard
argument_list|()
end_macro

begin_block
block|{
name|Qself_insert_command
operator|=
name|intern
argument_list|(
literal|"self-insert-command"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qself_insert_command
argument_list|)
expr_stmt|;
name|Qforward_char
operator|=
name|intern
argument_list|(
literal|"forward-char"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qforward_char
argument_list|)
expr_stmt|;
name|Qbackward_char
operator|=
name|intern
argument_list|(
literal|"backward-char"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qbackward_char
argument_list|)
expr_stmt|;
name|Qtop_level
operator|=
name|intern
argument_list|(
literal|"top-level"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qtop_level
argument_list|)
expr_stmt|;
name|Qdisabled
operator|=
name|intern
argument_list|(
literal|"disabled"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qdisabled
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_key_sequence
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecursive_edit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinput_pending_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scommand_execute
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecent_keys
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sthis_command_keys
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssuspend_emacs
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sabort_recursive_edit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexit_recursive_edit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecursion_depth
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Stop_level
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdiscard_input
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sopen_dribble_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_input_mode
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"disabled-command-hook"
argument_list|,
operator|&
name|Vdisabled_command_hook
argument_list|,
literal|"Value is called instead of any command that is disabled\n\ \(has a non-nil  disabled  property)."
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"meta-flag"
argument_list|,
operator|&
name|MetaFlag
argument_list|,
literal|"*Non-nil means treat 0200 bit in terminal input as Meta bit."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"last-command-char"
argument_list|,
operator|&
name|last_command_char
argument_list|,
literal|"Last terminal input character that was part of a command, as an integer."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"last-input-char"
argument_list|,
operator|&
name|last_input_char
argument_list|,
literal|"Last terminal input character, as an integer."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"unread-command-char"
argument_list|,
operator|&
name|unread_command_char
argument_list|,
literal|"Character to be read as next input from command input stream, or -1 if none."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"meta-prefix-char"
argument_list|,
operator|&
name|meta_prefix_char
argument_list|,
literal|"Meta-prefix character code.  Meta-foo as command input\n\ turns into this character followed by foo."
argument_list|)
expr_stmt|;
name|meta_prefix_char
operator|=
literal|033
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"last-command"
argument_list|,
operator|&
name|last_command
argument_list|,
literal|"The last command executed.  Normally a symbol with a function definition,\n\ but can be whatever was found in the keymap, or whatever that command left in this-command."
argument_list|)
expr_stmt|;
name|last_command
operator|=
name|Qnil
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"this-command"
argument_list|,
operator|&
name|this_command
argument_list|,
literal|"The command now being executed.\n\ The command can set this variable; whatever is put here\n\ will be in  last-command  during the following command."
argument_list|)
expr_stmt|;
name|this_command
operator|=
name|Qnil
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"auto-save-interval"
argument_list|,
operator|&
name|auto_save_interval
argument_list|,
literal|"*Number of keyboard input characters between auto-saves."
argument_list|)
expr_stmt|;
name|auto_save_interval
operator|=
literal|300
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"echo-keystrokes"
argument_list|,
operator|&
name|echo_keystrokes
argument_list|,
literal|"*Nonzero means echo unfinished commands after this many seconds of pause."
argument_list|)
expr_stmt|;
name|echo_keystrokes
operator|=
literal|1
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"help-char"
argument_list|,
operator|&
name|help_char
argument_list|,
literal|"Character to recognize as meaning Help.\n\ When it is read, do (eval help-form), and display result if it's a string.\n\ If help-form's value is nil, this char can be read normally."
argument_list|)
expr_stmt|;
name|help_char
operator|=
name|Ctl
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"help-form"
argument_list|,
operator|&
name|Vhelp_form
argument_list|,
literal|"Form to execute when character help-char is read.\n\ If the form returns a string, that string is displayed.\n\ If help-form is nil, the help char is not recognized."
argument_list|)
expr_stmt|;
name|Vhelp_form
operator|=
name|Qnil
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"top-level"
argument_list|,
operator|&
name|Vtop_level
argument_list|,
literal|"Form to evaluate when Emacs starts up.\n\ Useful to set before you dump a modified Emacs."
argument_list|)
expr_stmt|;
name|Vtop_level
operator|=
name|Qnil
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"keyboard-translate-table"
argument_list|,
operator|&
name|Vkeyboard_translate_table
argument_list|,
literal|"String used as translate table for keyboard input, or nil.\n\ Each character is looked up in this string and the contents used instead.\n\ If string is of length N, character codes N and up are untranslated."
argument_list|)
expr_stmt|;
name|Vkeyboard_translate_table
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_keyboard
argument_list|()
end_macro

begin_block
block|{
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'Z'
argument_list|)
argument_list|,
literal|"suspend-emacs"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
name|Ctl
argument_list|(
literal|'Z'
argument_list|)
argument_list|,
literal|"suspend-emacs"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
name|Ctl
argument_list|(
literal|'C'
argument_list|)
argument_list|,
literal|"exit-recursive-edit"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|']'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

