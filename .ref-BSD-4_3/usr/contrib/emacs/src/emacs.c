begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fully extensible Emacs, running on Unix, intended for GNU.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDWR
end_ifndef

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PRIO_PROCESS
value|0
end_define

begin_comment
comment|/* Command line args from shell, as list of strings */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vcommand_line_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero after Emacs has started up the first time.   Prevents reinitialization of the Lisp world and keymaps   on subsequent starts.  */
end_comment

begin_decl_stmt
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable whose value is symbol giving operating system type */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vsystem_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means running Emacs without interactive terminal.  */
end_comment

begin_decl_stmt
name|int
name|noninteractive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of Lisp variable `noninteractive'.    Normally same as C variable `noninteractive'    but nothing terrible happens if user sets this one.  */
end_comment

begin_decl_stmt
name|int
name|noninteractive1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Signal code for the fatal signal that was received */
end_comment

begin_decl_stmt
name|int
name|fatal_error_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if handling a fatal error already */
end_comment

begin_decl_stmt
name|int
name|fatal_error_in_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle bus errors, illegal instruction, etc. */
end_comment

begin_macro
name|fatal_error_signal
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD
name|int
name|tpgrp
decl_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|fatal_error_code
operator|=
name|sig
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* If fatal error occurs in code below, avoid infinite recursion.  */
if|if
condition|(
name|fatal_error_in_progress
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|fatal_error_code
argument_list|)
expr_stmt|;
name|fatal_error_in_progress
operator|=
literal|1
expr_stmt|;
comment|/* If we are controlling the terminal, reset terminal modes */
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|tpgrp
argument_list|)
operator|==
literal|0
operator|&&
name|tpgrp
operator|==
name|getpgrp
argument_list|(
literal|0
argument_list|)
condition|)
endif|#
directive|endif
comment|/* BSD */
block|{
name|reset_sys_modes
argument_list|()
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGTERM
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal error."
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up */
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Fdo_auto_save
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|unlock_all_files
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
comment|/* Signal the same code; this time it will really be fatal.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|fatal_error_code
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Code for dealing with Lisp access to the Unix command line */
end_comment

begin_expr_stmt
specifier|static
name|init_cmdargs
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|,
argument|skip_args
argument_list|)
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skip_args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|Vcommand_line_args
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|i
operator|=
name|argc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|i
operator|>
name|skip_args
condition|)
name|Vcommand_line_args
operator|=
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|,
name|Vcommand_line_args
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|{
name|int
name|skip_args
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APOLLO
comment|/* Reserve memory space for sbrk to get */
name|set_sbrk_size
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APOLLO */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGXCPU
name|signal
argument_list|(
name|SIGXCPU
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|fatal_error_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGXFSZ
ifdef|#
directive|ifdef
name|HIGHPRI
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|HIGHPRI
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|HIGHPRI
comment|/* Handle the -t switch, which specifies filename to use as terminal */
if|if
condition|(
literal|2
operator|<
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-t"
argument_list|)
condition|)
block|{
name|skip_args
operator|=
literal|2
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|open
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|O_RDWR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using %s\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the -batch switch, which means don't do interactive display.  */
name|noninteractive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-batch"
argument_list|)
condition|)
block|{
name|skip_args
operator|=
literal|1
expr_stmt|;
name|noninteractive
operator|=
literal|1
expr_stmt|;
block|}
name|noninteractive1
operator|=
name|noninteractive
expr_stmt|;
comment|/* Perform basic initializations (not merely interning symbols) */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|init_alloc_once
argument_list|()
expr_stmt|;
name|init_obarray
argument_list|()
expr_stmt|;
name|init_eval_once
argument_list|()
expr_stmt|;
name|init_syntax_once
argument_list|()
expr_stmt|;
comment|/* Create standard syntax table.  */
comment|/* Must be done before init_buffer */
name|init_buffer_once
argument_list|()
expr_stmt|;
comment|/* Create buffer table and some buffers */
name|init_minibuf_once
argument_list|()
expr_stmt|;
comment|/* Create list of minibuffers */
comment|/* Must precede init_window_once */
name|init_window_once
argument_list|()
expr_stmt|;
comment|/* Init the window system */
block|}
name|init_alloc
argument_list|()
expr_stmt|;
name|init_eval
argument_list|()
expr_stmt|;
name|init_data
argument_list|()
expr_stmt|;
name|init_read
argument_list|()
expr_stmt|;
name|init_cmdargs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|skip_args
argument_list|)
expr_stmt|;
comment|/* Create list Vcommand_line_args */
name|init_buffer
argument_list|()
expr_stmt|;
comment|/* Init default directory of main buffer */
if|if
condition|(
operator|!
name|noninteractive
condition|)
name|init_display
argument_list|()
expr_stmt|;
comment|/* Determine terminal type.  init_sys_modes uses results */
name|init_keyboard
argument_list|()
expr_stmt|;
comment|/* This too must precede init_sys_modes */
name|init_sys_modes
argument_list|()
expr_stmt|;
comment|/* Init system terminal modes (RAW or CBREAK, etc.) */
name|init_xdisp
argument_list|()
expr_stmt|;
name|init_macros
argument_list|()
expr_stmt|;
name|init_editfns
argument_list|()
expr_stmt|;
name|init_callproc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|subprocesses
name|init_process
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|subprocesses
comment|/* Intern the names of all standard functions and variables; define standard keys */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
comment|/* The basic levels of Lisp must come first */
comment|/* And data must come first of all 	 for the sake of symbols like error-message */
name|syms_of_data
argument_list|()
expr_stmt|;
name|syms_of_alloc
argument_list|()
expr_stmt|;
name|syms_of_read
argument_list|()
expr_stmt|;
name|syms_of_print
argument_list|()
expr_stmt|;
name|syms_of_eval
argument_list|()
expr_stmt|;
name|syms_of_fns
argument_list|()
expr_stmt|;
name|syms_of_abbrev
argument_list|()
expr_stmt|;
name|syms_of_buffer
argument_list|()
expr_stmt|;
name|syms_of_bytecode
argument_list|()
expr_stmt|;
name|syms_of_callint
argument_list|()
expr_stmt|;
name|syms_of_casefiddle
argument_list|()
expr_stmt|;
name|syms_of_callproc
argument_list|()
expr_stmt|;
name|syms_of_cmds
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DIR_LIBRARY
name|syms_of_dired
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_DIR_LIBRARY */
name|syms_of_display
argument_list|()
expr_stmt|;
name|syms_of_doc
argument_list|()
expr_stmt|;
name|syms_of_editfns
argument_list|()
expr_stmt|;
name|syms_of_emacs
argument_list|()
expr_stmt|;
name|syms_of_fileio
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|syms_of_filelock
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|syms_of_indent
argument_list|()
expr_stmt|;
name|syms_of_keyboard
argument_list|()
expr_stmt|;
name|syms_of_keymap
argument_list|()
expr_stmt|;
name|syms_of_macros
argument_list|()
expr_stmt|;
name|syms_of_marker
argument_list|()
expr_stmt|;
name|syms_of_minibuf
argument_list|()
expr_stmt|;
name|syms_of_mocklisp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|subprocesses
name|syms_of_process
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
name|syms_of_search
argument_list|()
expr_stmt|;
name|syms_of_syntax
argument_list|()
expr_stmt|;
name|syms_of_undo
argument_list|()
expr_stmt|;
name|syms_of_window
argument_list|()
expr_stmt|;
name|syms_of_xdisp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
name|syms_of_xfns
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_X_WINDOWS */
name|keys_of_casefiddle
argument_list|()
expr_stmt|;
name|keys_of_cmds
argument_list|()
expr_stmt|;
name|keys_of_buffer
argument_list|()
expr_stmt|;
name|keys_of_keyboard
argument_list|()
expr_stmt|;
name|keys_of_keymap
argument_list|()
expr_stmt|;
name|keys_of_macros
argument_list|()
expr_stmt|;
name|keys_of_minibuf
argument_list|()
expr_stmt|;
name|keys_of_window
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
comment|/* Handle -l loadup-and-dump, args passed by Makefile. */
if|if
condition|(
name|argc
operator|>
literal|2
operator|+
name|skip_args
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
operator|+
name|skip_args
index|]
argument_list|,
literal|"-l"
argument_list|)
condition|)
name|Vtop_level
operator|=
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"load"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|argv
index|[
literal|2
operator|+
name|skip_args
index|]
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_DUMP
comment|/* Unless next switch is -nl, load "loadup.el" first thing.  */
if|if
condition|(
operator|!
operator|(
name|argc
operator|>
literal|1
operator|+
name|skip_args
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
operator|+
name|skip_args
index|]
argument_list|,
literal|"-nl"
argument_list|)
operator|)
condition|)
name|Vtop_level
operator|=
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"load"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|"loadup.el"
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CANNOT_DUMP */
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
comment|/* Enter editor command loop.  This never returns.  */
name|Frecursive_edit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"kill-emacs"
argument_list|,
argument|Fkill_emacs
argument_list|,
argument|Skill_emacs
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Exit the Emacs job and kill it.  ARG means no query.\n\ If emacs is running noninteractively and ARG is an integer,\n\ return ARG as the exit program code."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|answer
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|arg
operator|=
name|Qt
expr_stmt|;
if|if
condition|(
operator|!
name|noninteractive
operator|&&
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|ModExist
argument_list|()
operator|)
operator|&&
operator|(
name|answer
operator|=
name|Fyes_or_no_p
argument_list|(
name|format1
argument_list|(
literal|"%d modified buffer%s exist%s, do you really want to exit? "
argument_list|,
name|i
argument_list|,
name|i
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|i
operator|==
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
argument_list|)
operator|,
name|NULL
argument_list|(
name|answer
argument_list|)
operator|)
condition|)
return|return
name|Qnil
return|;
ifdef|#
directive|ifdef
name|subprocesses
if|if
condition|(
name|count_active_processes
argument_list|()
operator|&&
operator|(
name|answer
operator|=
name|Fyes_or_no_p
argument_list|(
name|format1
argument_list|(
literal|"Subprocesses are executing; kill them and exit? "
argument_list|)
argument_list|)
operator|,
name|NULL
argument_list|(
name|answer
argument_list|)
operator|)
condition|)
return|return
name|Qnil
return|;
endif|#
directive|endif
comment|/* subprocesses */
block|}
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
name|Fdo_auto_save
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|unlock_all_files
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|stuff_buffered_input
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|XTYPE
argument_list|(
name|arg
argument_list|)
operator|==
name|Lisp_Int
operator|)
condition|?
name|XINT
argument_list|(
name|arg
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_comment
comment|/* Nothing like this can be implemented on an Apollo.    What a loss!  */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"dump-emacs"
argument_list|,
argument|Fdump_emacs
argument_list|,
argument|Sdump_emacs
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Dump current state of Emacs into executable file FILENAME.\n\ Take symbols from SYMFILE (presumably the file you executed to run Emacs)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|intoname
operator|,
name|symname
operator|)
name|Lisp_Object
name|intoname
operator|,
name|symname
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|a_name
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|my_edata
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
extern|extern _start (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|CHECK_STRING
argument_list|(
name|intoname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intoname
operator|=
name|Fexpand_file_name
argument_list|(
name|intoname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|symname
argument_list|)
condition|)
block|{
name|CHECK_STRING
argument_list|(
name|symname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|symname
argument_list|)
operator|->
name|size
condition|)
block|{
name|symname
operator|=
name|Fexpand_file_name
argument_list|(
name|symname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|a_name
operator|=
name|XSTRING
argument_list|(
name|symname
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|tem
operator|=
name|Vpurify_flag
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Vpurify_flag
operator|=
name|Qnil
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|malloc_init
argument_list|(
operator|&
name|my_edata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tell malloc where start of impure now is */
end_comment

begin_expr_stmt
name|unexec
argument_list|(
name|XSTRING
argument_list|(
name|intoname
argument_list|)
operator|->
name|data
argument_list|,
name|a_name
argument_list|,
operator|&
name|my_edata
argument_list|,
literal|0
argument_list|,
name|_start
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Vpurify_flag
operator|=
name|tem
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_DUMP */
end_comment

begin_escape
end_escape

begin_macro
unit|Lisp_Object
name|decode_env_path
argument_list|(
argument|evarname
argument_list|,
argument|defalt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|evarname
decl_stmt|,
modifier|*
name|defalt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|Lisp_Object
name|lpath
decl_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
name|evarname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
name|defalt
expr_stmt|;
name|lpath
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|path
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|lpath
operator|=
name|Fcons
argument_list|(
name|p
operator|-
name|path
condition|?
name|make_string
argument_list|(
name|path
argument_list|,
name|p
operator|-
name|path
argument_list|)
else|:
name|Qnil
argument_list|,
name|lpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|path
operator|=
name|p
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
return|return
name|Fnreverse
argument_list|(
name|lpath
argument_list|)
return|;
block|}
end_block

begin_macro
name|syms_of_emacs
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|CANNOT_DUMP
name|defsubr
argument_list|(
operator|&
name|Sdump_emacs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not CANNOT_DUMP */
name|defsubr
argument_list|(
operator|&
name|Skill_emacs
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"command-line-args"
argument_list|,
operator|&
name|Vcommand_line_args
argument_list|,
literal|"Args passed by shell to Emacs, as a list of strings."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"system-type"
argument_list|,
operator|&
name|Vsystem_type
argument_list|,
literal|"Symbol indicating type of operating system you are using."
argument_list|)
expr_stmt|;
name|Vsystem_type
operator|=
name|intern
argument_list|(
name|SYSTEM_TYPE
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"noninteractive"
argument_list|,
operator|&
name|noninteractive1
argument_list|,
literal|"Non-nil means Emacs is running without interactive terminal."
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

