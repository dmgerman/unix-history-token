begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Call a Lisp function interactively.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|Lisp_Vector
modifier|*
name|CurrentGlobalMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|num_input_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vprefix_arg
decl_stmt|,
name|Vcurrent_prefix_arg
decl_stmt|,
name|Qminus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qcall_interactively
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vcommand_history
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Lisp_Object
name|ml_apply
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|Lisp_Object
name|Fread_buffer
argument_list|()
decl_stmt|,
name|Fread_key_sequence
argument_list|()
decl_stmt|,
name|Fread_file_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"interactive"
argument_list|,
argument|Finteractive
argument_list|,
argument|Sinteractive
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|0
comment|/* See auxdoc.c */
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Quotify EXP: if EXP is constant, return it.    If EXP is not constant, return (quote EXP).  */
end_comment

begin_function
name|Lisp_Object
name|quotify_arg
parameter_list|(
name|exp
parameter_list|)
specifier|register
name|Lisp_Object
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|exp
argument_list|)
operator|!=
name|Lisp_Int
operator|&&
name|XTYPE
argument_list|(
name|exp
argument_list|)
operator|!=
name|Lisp_String
operator|&&
operator|!
name|NULL
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|exp
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Fcons
argument_list|(
name|Qquote
argument_list|,
name|Fcons
argument_list|(
name|exp
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Modify EXP by quotifying each element (except the first).  */
end_comment

begin_function
name|Lisp_Object
name|quotify_args
parameter_list|(
name|exp
parameter_list|)
name|Lisp_Object
name|exp
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
specifier|register
name|struct
name|Lisp_Cons
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|exp
init|;
name|LISTP
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|ptr
operator|->
name|cdr
control|)
block|{
name|ptr
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|car
operator|=
name|quotify_arg
argument_list|(
name|ptr
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|callint_argfuns
index|[]
init|=
block|{
literal|""
block|,
literal|"point"
block|,
literal|"mark"
block|,
literal|"region-beginning"
block|,
literal|"region-end"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|argfuns
value|callint_argfuns
end_define

begin_macro
name|DEFUN
argument_list|(
literal|"call-interactively"
argument_list|,
argument|Fcall_interactively
argument_list|,
argument|Scall_interactively
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Call FUNCTION, reading args from the terminal,\n\ if the interactive calling specs of FUNCTION request one.\n\ \n\ The function contains a specification of how to do the argument reading.\n\ In the case of user-defined functions, this is specified by placing a call to\n\ the function  interactive  at the top level of the function body.  See  interactive."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|function
operator|,
name|record
operator|)
name|Lisp_Object
name|function
operator|,
name|record
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
modifier|*
name|args
decl_stmt|,
modifier|*
name|visargs
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|argstrings
decl_stmt|;
name|Lisp_Object
name|fun
decl_stmt|;
name|Lisp_Object
name|funcar
decl_stmt|;
name|Lisp_Object
name|specs
decl_stmt|;
name|Lisp_Object
name|teml
decl_stmt|;
name|Lisp_Object
name|prefix_arg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tem
decl_stmt|;
name|int
modifier|*
name|varies
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|count
decl_stmt|,
name|foo
decl_stmt|;
name|char
name|prompt
index|[
literal|100
index|]
decl_stmt|;
name|char
name|prompt1
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|tem1
decl_stmt|;
name|int
name|arg_from_tty
init|=
literal|0
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|,
name|gcpro4
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
comment|/* Save this now, since use ofminibuffer will clobber it. */
name|prefix_arg
operator|=
name|Vcurrent_prefix_arg
expr_stmt|;
name|retry
label|:
name|fun
operator|=
name|function
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|EQ
argument_list|(
name|fun
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|fun
operator|=
name|XSYMBOL
argument_list|(
name|fun
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
name|string
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|prompt
expr_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
block|{
name|lose
label|:
name|function
operator|=
name|wrong_type_argument
argument_list|(
name|Qcommandp
argument_list|,
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|string
operator|==
literal|1
condition|)
return|return
name|Fapply
argument_list|(
name|function
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|fun
argument_list|)
condition|)
goto|goto
name|lose
goto|;
elseif|else
if|if
condition|(
name|funcar
operator|=
name|Fcar
argument_list|(
name|fun
argument_list|)
operator|,
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qautoload
argument_list|)
condition|)
block|{
name|GCPRO2
argument_list|(
name|function
argument_list|,
name|prefix_arg
argument_list|)
expr_stmt|;
name|do_autoload
argument_list|(
name|fun
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qlambda
argument_list|)
condition|)
block|{
name|specs
operator|=
name|Fassq
argument_list|(
name|Qinteractive
argument_list|,
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|specs
argument_list|)
condition|)
goto|goto
name|lose
goto|;
name|specs
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|specs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|specs
argument_list|)
operator|==
name|Lisp_String
condition|)
name|string
operator|=
name|XSTRING
argument_list|(
name|specs
argument_list|)
operator|->
name|data
expr_stmt|;
else|else
block|{
name|i
operator|=
name|num_input_chars
expr_stmt|;
name|specs
operator|=
name|Feval
argument_list|(
name|specs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|num_input_chars
operator|||
operator|!
name|NULL
argument_list|(
name|record
argument_list|)
condition|)
name|Vcommand_history
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|function
argument_list|,
name|quotify_args
argument_list|(
name|Fcopy_sequence
argument_list|(
name|specs
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|Vcommand_history
argument_list|)
expr_stmt|;
return|return
name|Fapply
argument_list|(
name|function
argument_list|,
name|specs
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qmocklisp
argument_list|)
condition|)
return|return
name|ml_apply
argument_list|(
name|fun
argument_list|,
name|Qinteractive
argument_list|)
return|;
else|else
goto|goto
name|lose
goto|;
comment|/* Here if function specifies a string to control parsing the defaults */
comment|/* First character '*' means barf if buffer read-only */
if|if
condition|(
operator|*
name|string
operator|==
literal|'*'
condition|)
block|{
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|)
name|Fbarf_if_buffer_read_only
argument_list|()
expr_stmt|;
block|}
name|tem
operator|=
name|string
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|*
name|tem
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|tem
operator|==
literal|'r'
condition|)
name|j
operator|++
expr_stmt|;
name|tem
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
name|tem
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|++
expr_stmt|;
else|else
name|tem
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|count
operator|=
name|j
expr_stmt|;
name|args
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|visargs
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|argstrings
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|varies
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|count
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|=
name|Qnil
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|Qnil
expr_stmt|;
name|varies
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|GCPRO4
argument_list|(
name|prefix_arg
argument_list|,
name|function
argument_list|,
operator|*
name|args
argument_list|,
operator|*
name|visargs
argument_list|)
expr_stmt|;
name|gcpro3
operator|.
name|nvars
operator|=
operator|(
name|count
operator|+
literal|1
operator|)
expr_stmt|;
name|gcpro4
operator|.
name|nvars
operator|=
operator|(
name|count
operator|+
literal|1
operator|)
expr_stmt|;
name|tem
operator|=
name|string
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|tem
condition|;
name|i
operator|++
control|)
block|{
name|strncpy
argument_list|(
name|prompt1
argument_list|,
name|tem
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|prompt1
operator|-
literal|1
argument_list|)
expr_stmt|;
name|prompt1
index|[
sizeof|sizeof
name|prompt1
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tem1
operator|=
name|index
argument_list|(
name|prompt1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem1
condition|)
operator|*
name|tem1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|argstrings
index|[
name|j
index|]
operator|=
name|XSTRING
argument_list|(
name|visargs
index|[
name|j
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
name|doprnt
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|prompt1
argument_list|,
name|argstrings
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|tem
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Symbol defined as a function */
name|visargs
index|[
name|i
index|]
operator|=
name|Fcompleting_read
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Vobarray
argument_list|,
name|Qfboundp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
comment|/* Passing args[i] directly stimulates compiler bug */
name|teml
operator|=
name|visargs
index|[
name|i
index|]
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|Fintern
argument_list|(
name|teml
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Name of existing buffer */
name|args
index|[
name|i
index|]
operator|=
name|Fcurrent_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|=
name|Fother_buffer
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|Fread_buffer
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Name of buffer, possibly nonexistent */
name|args
index|[
name|i
index|]
operator|=
name|Fread_buffer
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Fother_buffer
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Character */
name|message1
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|Fread_char
argument_list|()
expr_stmt|;
comment|/* Passing args[i] directly stimulates compiler bug */
name|teml
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|Fchar_to_string
argument_list|(
name|teml
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Command: symbol with interactive function */
name|visargs
index|[
name|i
index|]
operator|=
name|Fcompleting_read
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Vobarray
argument_list|,
name|Qcommandp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
comment|/* Passing args[i] directly stimulates compiler bug */
name|teml
operator|=
name|visargs
index|[
name|i
index|]
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|Fintern
argument_list|(
name|teml
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Value of point.  Does not do I/O.  */
name|XFASTINT
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|=
name|point
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|build_string
argument_list|(
literal|"point"
argument_list|)
expr_stmt|;
name|varies
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Directory name. */
name|args
index|[
name|i
index|]
operator|=
name|Fread_file_name
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Qnil
argument_list|,
name|bf_cur
operator|->
name|directory
argument_list|,
name|Qlambda
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Existing file name. */
name|args
index|[
name|i
index|]
operator|=
name|Fread_file_name
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|,
name|Qlambda
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Possibly nonexistent file name. */
name|args
index|[
name|i
index|]
operator|=
name|Fread_file_name
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Key sequence (string) */
name|args
index|[
name|i
index|]
operator|=
name|Fread_key_sequence
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
name|teml
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|Fkey_description
argument_list|(
name|teml
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Value of mark.  Does not do I/O.  */
if|if
condition|(
name|NULL
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
condition|)
name|error
argument_list|(
literal|"The mark is not set now"
argument_list|)
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|build_string
argument_list|(
literal|"the mark"
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|=
name|marker_position
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
expr_stmt|;
name|varies
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Read number from minibuffer.  */
do|do
name|args
index|[
name|i
index|]
operator|=
name|Fread_minibuffer
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
do|while
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|!=
name|Lisp_Int
condition|)
do|;
name|visargs
index|[
name|i
index|]
operator|=
name|last_minibuf_string
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Prefix arg in raw form.  Does no I/O.  */
name|args
index|[
name|i
index|]
operator|=
name|prefix_arg
expr_stmt|;
name|XFASTINT
argument_list|(
name|visargs
index|[
name|i
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
literal|""
expr_stmt|;
name|varies
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Prefix arg converted to number.  No I/O. */
name|args
index|[
name|i
index|]
operator|=
name|Fprefix_numeric_value
argument_list|(
name|prefix_arg
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|visargs
index|[
name|i
index|]
argument_list|)
operator|=
operator|(
name|int
operator|)
literal|""
expr_stmt|;
name|varies
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Region, point and mark as 2 args. */
if|if
condition|(
name|NULL
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
condition|)
name|error
argument_list|(
literal|"The mark is not set now"
argument_list|)
expr_stmt|;
name|foo
operator|=
name|marker_position
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|build_string
argument_list|(
literal|"point"
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|=
name|point
operator|<
name|foo
condition|?
name|point
else|:
name|foo
expr_stmt|;
name|varies
index|[
name|i
index|]
operator|=
literal|3
expr_stmt|;
name|visargs
index|[
operator|++
name|i
index|]
operator|=
name|build_string
argument_list|(
literal|"the mark"
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|=
name|point
operator|>
name|foo
condition|?
name|point
else|:
name|foo
expr_stmt|;
name|varies
index|[
name|i
index|]
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* String read via minibuffer.  */
name|args
index|[
name|i
index|]
operator|=
name|Fread_string
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Any symbol.  */
name|visargs
index|[
name|i
index|]
operator|=
name|read_minibuf_string
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|Qnil
argument_list|,
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Passing args[i] directly stimulates compiler bug */
name|teml
operator|=
name|visargs
index|[
name|i
index|]
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|Fintern
argument_list|(
name|teml
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Variable name: symbol that is 				   user-variable-p. */
name|args
index|[
name|i
index|]
operator|=
name|Fread_variable
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|last_minibuf_string
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Lisp expression read but not evaluated */
name|args
index|[
name|i
index|]
operator|=
name|Fread_minibuffer
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|last_minibuf_string
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Lisp expression read and evaluated */
name|args
index|[
name|i
index|]
operator|=
name|Feval_minibuffer
argument_list|(
name|build_string
argument_list|(
name|prompt
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|visargs
index|[
name|i
index|]
operator|=
name|last_minibuf_string
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid control letter in interactive calling string"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|varies
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|arg_from_tty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|visargs
index|[
name|i
index|]
argument_list|)
condition|)
name|visargs
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|tem
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
name|tem
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|++
expr_stmt|;
else|else
name|tem
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
name|QUIT
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|function
expr_stmt|;
if|if
condition|(
name|arg_from_tty
operator|||
operator|!
name|NULL
argument_list|(
name|record
argument_list|)
condition|)
block|{
name|visargs
index|[
literal|0
index|]
operator|=
name|function
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|varies
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|visargs
index|[
name|i
index|]
operator|=
name|Fcons
argument_list|(
name|intern
argument_list|(
name|argfuns
index|[
name|varies
index|[
name|i
index|]
index|]
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
name|visargs
index|[
name|i
index|]
operator|=
name|quotify_arg
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Vcommand_history
operator|=
name|Fcons
argument_list|(
name|Flist
argument_list|(
name|count
operator|+
literal|1
argument_list|,
name|visargs
argument_list|)
argument_list|,
name|Vcommand_history
argument_list|)
expr_stmt|;
block|}
return|return
name|Ffuncall
argument_list|(
name|count
operator|+
literal|1
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"prefix-numeric-value"
argument_list|,
argument|Fprefix_numeric_value
argument_list|,
argument|Sprefix_numeric_value
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return numeric meaning of raw prefix argument.\n\ A raw prefix argument is what you get from (interactive \"P\")."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|raw
operator|)
name|Lisp_Object
name|raw
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|raw
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|raw
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XSETINT
argument_list|(
name|val
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LISTP
argument_list|(
name|raw
argument_list|)
condition|)
name|val
operator|=
name|XCONS
argument_list|(
name|raw
argument_list|)
operator|->
name|car
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|raw
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|val
operator|=
name|raw
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|syms_of_callint
argument_list|()
end_macro

begin_block
block|{
name|Qminus
operator|=
name|intern
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qminus
argument_list|)
expr_stmt|;
name|Qcall_interactively
operator|=
name|intern
argument_list|(
literal|"call-interactively"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qcall_interactively
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"prefix-arg"
argument_list|,
operator|&
name|Vprefix_arg
argument_list|,
literal|"The value of the prefix argument for the next editing command.\n\ It may be a number, or the symbol - for just a minus sign as arg,\n\ or a list whose car is a number for just one or more C-U's\n\ or nil if no argument has been specified.\n\ \n\ You cannot examine this variable to find the argument for this command\n\ since it has been set to nil by the time you can look.\n\ Instead, you should use the variable current-prefix-arg, although\n\ normally commands can get this prefix argument with (interactive \"P\")."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"current-prefix-arg"
argument_list|,
operator|&
name|Vcurrent_prefix_arg
argument_list|,
literal|"The value of the prefix argument for this editing command.\n\ It may be a number, or the symbol - for just a minus sign as arg,\n\ or a list whose car is a number for just one or more C-U's\n\ or nil if no argument has been specified.\n\ This is what (interactive \"P\") returns."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"command-history"
argument_list|,
operator|&
name|Vcommand_history
argument_list|,
literal|"List of recent commands that read arguments from terminal.\n\ Each command is represented as a form to evaluate."
argument_list|)
expr_stmt|;
name|Vcommand_history
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinteractive
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scall_interactively
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprefix_numeric_value
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

