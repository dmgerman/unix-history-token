begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Display generation from window structure and buffer text.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|interrupt_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print newline before next minibuffer message.  */
end_comment

begin_decl_stmt
name|int
name|noninteractive_need_newline
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|CURRENT_END_POS
parameter_list|(
name|w
parameter_list|)
define|\
value|(XFASTINT (w->window_end_pos)< 0 \    ? -1 - XFASTINT(w->window_end_pos) \    : XFASTINT(w->window_end_pos))
end_define

begin_comment
comment|/* The buffer position of the first character appearing  entirely or partially on the current screen line.  Or zero, which disables the optimization for the current screen line. */
end_comment

begin_decl_stmt
name|int
name|this_line_bufpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters past the end of this line,    including the terminating newline */
end_comment

begin_decl_stmt
name|int
name|this_line_endpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The vertical position of this screen line. */
end_comment

begin_decl_stmt
name|int
name|this_line_vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hpos value for start of display on this screen line.  Usually zero, but negative if first character really began on previous line */
end_comment

begin_decl_stmt
name|int
name|this_line_hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer that this_line variables are describing. */
end_comment

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|this_line_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of minibuf_message when it was last acted on.   If this is nonzero, there is a message on the screen   in the minibuffer and it should be erased as soon   as it is no longer requested to appear. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prev_minibuf_message
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means truncate lines in all windows less wide than the screen */
end_comment

begin_decl_stmt
name|int
name|truncate_partial_width_windows
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vglobal_mode_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vglobal_minor_modes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of lines to try scrolling a   window by when point leaves the window; if   it is<=0 then point is centered in the window */
end_comment

begin_decl_stmt
name|int
name|scroll_step
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if try_window_id has made blank lines at window bottom  since the last redisplay that paused */
end_comment

begin_decl_stmt
name|int
name|blank_end_of_window
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of windows showing the buffer of the selected window.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|buffer_shared
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display_text_line sets these to the screen position (origin 0) of point,   whether the window is selected or not.  Set one to -1 first to determine whether point was found afterwards.  */
end_comment

begin_decl_stmt
name|int
name|point_vpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|point_hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug_end_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|default_ctl_arrow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means display ctl chars */
end_comment

begin_comment
comment|/* with uparrow in mode lines, etc */
end_comment

begin_decl_stmt
name|int
name|mode_line_inverse_video
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means display mode line highlighted */
end_comment

begin_function_decl
name|struct
name|position
modifier|*
name|display_text_line
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|minibuf_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prompt to display in front of the minibuffer contents */
end_comment

begin_comment
comment|/* Width in columns of current minibuffer prompt.  */
end_comment

begin_decl_stmt
name|int
name|minibuf_prompt_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|minibuf_message
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to display instead of minibuffer contents 			   This is what the functions error and message make, 			   and command echoing uses it as well. 			   It overrides the minibuf_prompt as well as the buffer.  */
end_comment

begin_decl_stmt
name|int
name|RecurseDepth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth in recursive edits */
end_comment

begin_decl_stmt
name|int
name|MinibufDepth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth in minibuffer invocations */
end_comment

begin_decl_stmt
name|int
name|RedoModes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true iff we should redraw the mode lines 			   on the next redisplay */
end_comment

begin_comment
comment|/* Minimum value of bf_s1 since last redisplay that finished.  Valid for current buffer unless Cant1WinOpt is nonzero. */
end_comment

begin_decl_stmt
name|int
name|beg_unchanged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Minimum value of bf_s2 since last redisplay that finished.  Valid for current buffer unless Cant1WinOpt is nonzero. */
end_comment

begin_decl_stmt
name|int
name|end_unchanged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bf_modified as of last redisplay that finished;  if it matches bf_modified, beg_unchanged and end_unchanged  contain no useful information */
end_comment

begin_decl_stmt
name|int
name|unchanged_modified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if head_clip or tail_clip of current buffer has changed  since last redisplay that finished */
end_comment

begin_decl_stmt
name|int
name|clip_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if window sizes or contents have changed  since last redisplay that finished */
end_comment

begin_decl_stmt
name|int
name|windows_or_buffers_changed
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"redraw-display"
argument_list|,
argument|Fredraw_display
argument_list|,
argument|Sredraw_display
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Clear the screen and output again what is supposed to appear on it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Some bug zeros some core */
name|set_terminal_modes
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_screen
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_screen_records
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_comment
comment|/* Some bug zeros some core */
end_comment

begin_expr_stmt
name|windows_or_buffers_changed
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Mark all windows as INaccurate,      so that every window will have its redisplay done.  */
end_comment

begin_expr_stmt
name|mark_window_display_accurate
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_comment
comment|/* Some bug zeros some core */
end_comment

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_decl_stmt
unit|static
name|char
name|message_buf
index|[
name|MScreenWidth
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dump an informative message to the minibuf */
end_comment

begin_comment
comment|/* VARARGS 1 */
end_comment

begin_macro
name|message
argument_list|(
argument|m
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
block|{
if|if
condition|(
name|noninteractive_need_newline
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|m
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTERACTIVE
condition|)
block|{
name|doprnt
argument_list|(
name|message_buf
argument_list|,
sizeof|sizeof
name|message_buf
operator|-
literal|1
argument_list|,
name|m
argument_list|,
operator|&
name|a1
argument_list|)
expr_stmt|;
name|minibuf_message
operator|=
name|message_buf
expr_stmt|;
name|display_minibuf_message
argument_list|()
expr_stmt|;
name|update_screen
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Specify m, a string, as a message in the minibuf.  */
end_comment

begin_macro
name|message1
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
block|{
if|if
condition|(
name|noninteractive_need_newline
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTERACTIVE
condition|)
block|{
name|minibuf_message
operator|=
name|m
expr_stmt|;
name|display_minibuf_message
argument_list|()
expr_stmt|;
name|update_screen
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|display_minibuf_message
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|vpos
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|line
decl_stmt|;
if|if
condition|(
name|screen_garbaged
condition|)
block|{
name|Fredraw_display
argument_list|()
expr_stmt|;
name|screen_garbaged
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|minibuf_message
operator|||
operator|!
name|MinibufDepth
condition|)
block|{
name|vpos
operator|=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|top
argument_list|)
expr_stmt|;
name|line
operator|=
name|get_display_line
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|display_string
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
argument_list|,
name|line
argument_list|,
name|minibuf_message
condition|?
name|minibuf_message
else|:
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If desired cursor location is on this line, put it at end of text */
if|if
condition|(
name|cursY
operator|==
name|vpos
condition|)
name|cursX
operator|=
name|line
operator|->
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|windows_or_buffers_changed
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
name|prev_minibuf_message
operator|=
name|minibuf_message
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Do a screen update, taking possible shortcuts into account.  This is the main external entry point for redisplay */
end_comment

begin_macro
name|DoDsp
argument_list|(
argument|SaveMiniBuf
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|pause
decl_stmt|;
name|int
name|inhibit_hairy_id
init|=
literal|0
decl_stmt|;
name|int
name|must_finish
init|=
literal|0
decl_stmt|;
name|int
name|all_windows
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|tlbufpos
decl_stmt|,
name|tlendpos
decl_stmt|;
name|struct
name|position
name|pos
decl_stmt|;
specifier|extern
name|int
name|input_pending
decl_stmt|;
if|if
condition|(
name|noninteractive
condition|)
return|return;
if|if
condition|(
name|screen_garbaged
condition|)
block|{
name|Fredraw_display
argument_list|()
expr_stmt|;
name|screen_garbaged
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|minibuf_message
operator|||
operator|(
name|prev_minibuf_message
operator|&&
operator|!
name|SaveMiniBuf
operator|)
condition|)
block|{
name|display_minibuf_message
argument_list|()
expr_stmt|;
name|must_finish
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|clip_changed
operator|||
name|windows_or_buffers_changed
condition|)
name|RedoModes
operator|++
expr_stmt|;
comment|/* Detect case that we need to write a star in the mode line.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|<
name|bf_modified
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|<=
name|bf_cur
operator|->
name|save_modified
condition|)
block|{
name|w
operator|->
name|redo_mode_line
operator|=
name|Qt
expr_stmt|;
if|if
condition|(
name|buffer_shared
operator|>
literal|1
condition|)
name|RedoModes
operator|++
expr_stmt|;
block|}
name|all_windows
operator|=
name|RedoModes
operator|||
name|buffer_shared
operator|>
literal|1
expr_stmt|;
name|tlbufpos
operator|=
name|this_line_bufpos
expr_stmt|;
name|tlendpos
operator|=
name|this_line_endpos
expr_stmt|;
if|if
condition|(
operator|!
name|all_windows
operator|&&
name|tlbufpos
operator|>
literal|0
operator|&&
name|NULL
argument_list|(
name|w
operator|->
name|redo_mode_line
argument_list|)
comment|/* Point must be on the line that we have info recorded about */
operator|&&
name|point
operator|>=
name|tlbufpos
operator|&&
name|point
operator|<=
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|tlendpos
comment|/* All text outside that line, including its final newline, 	 must be unchanged */
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|>=
name|bf_modified
operator|||
operator|(
name|beg_unchanged
operator|>=
name|tlbufpos
operator|-
literal|1
operator|&&
name|bf_s1
operator|>=
name|tlbufpos
operator|-
literal|1
operator|&&
name|end_unchanged
operator|>=
name|tlendpos
operator|&&
name|bf_s2
operator|>=
name|tlendpos
operator|)
operator|)
comment|/* Make sure recorded data applies to current buffer, etc */
operator|&&
name|NULL
argument_list|(
name|w
operator|->
name|force_start
argument_list|)
operator|&&
name|bf_cur
operator|==
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|&&
name|this_line_buffer
operator|==
name|bf_cur
condition|)
block|{
if|if
condition|(
name|tlbufpos
operator|>
name|FirstCharacter
operator|&&
name|CharAt
argument_list|(
name|tlbufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|&&
operator|(
name|tlbufpos
operator|==
name|NumCharacters
operator|+
literal|1
operator|||
name|CharAt
argument_list|(
name|tlbufpos
argument_list|)
operator|==
literal|'\n'
operator|)
condition|)
comment|/* Former continuation line has disappeared by becoming empty */
empty_stmt|;
elseif|else
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|<
name|bf_modified
operator|||
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
block|{
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
name|display_text_line
argument_list|(
name|w
argument_list|,
name|tlbufpos
argument_list|,
name|this_line_vpos
argument_list|,
name|this_line_hpos
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|tlbufpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If line contains point, is not continued, 		 and ends at same distance from eob as before, we win */
if|if
condition|(
name|point_vpos
operator|>=
literal|0
operator|&&
name|this_line_bufpos
operator|&&
name|this_line_endpos
operator|==
name|tlendpos
condition|)
block|{
name|cursX
operator|=
name|point_hpos
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|!=
name|screen_width
condition|)
name|preserve_other_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt_input
condition|)
name|unrequest_sigio
argument_list|()
expr_stmt|;
goto|goto
name|update
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|point
operator|==
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|must_finish
condition|)
return|return;
goto|goto
name|update
goto|;
block|}
else|else
block|{
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|tlbufpos
argument_list|,
literal|0
argument_list|,
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
argument_list|,
name|point
argument_list|,
literal|2
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
argument_list|,
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|vpos
operator|<
literal|1
condition|)
block|{
name|cursX
operator|=
name|max
argument_list|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
argument_list|,
name|pos
operator|.
name|hpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt_input
condition|)
name|unrequest_sigio
argument_list|()
expr_stmt|;
goto|goto
name|update
goto|;
block|}
block|}
comment|/* Text changed drastically or point moved off of line */
name|cancel_line
argument_list|(
name|this_line_vpos
argument_list|)
expr_stmt|;
block|}
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|interrupt_input
condition|)
name|unrequest_sigio
argument_list|()
expr_stmt|;
if|if
condition|(
name|all_windows
condition|)
name|redisplay_all_windows
argument_list|()
expr_stmt|;
else|else
block|{
name|inhibit_hairy_id
operator|=
name|redisplay_window
argument_list|(
name|selected_window
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|!=
name|screen_width
condition|)
name|preserve_other_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|update
label|:
name|pause
operator|=
name|update_screen
argument_list|(
literal|0
argument_list|,
name|inhibit_hairy_id
argument_list|)
expr_stmt|;
comment|/* If screen does not match, prevent doing single-line-update next time */
if|if
condition|(
name|pause
condition|)
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
comment|/* Now text on screen agrees with windows, so      put info into the windows for partial redisplay to follow */
if|if
condition|(
operator|!
name|pause
condition|)
block|{
specifier|register
name|struct
name|buffer_text
modifier|*
name|t
init|=
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|==
name|bf_cur
condition|?
operator|&
name|bf_text
else|:
operator|&
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|text
decl_stmt|;
name|blank_end_of_window
operator|=
literal|0
expr_stmt|;
name|clip_changed
operator|=
literal|0
expr_stmt|;
name|unchanged_modified
operator|=
name|t
operator|->
name|modified
expr_stmt|;
name|beg_unchanged
operator|=
name|t
operator|->
name|size1
operator|,
name|end_unchanged
operator|=
name|t
operator|->
name|size2
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
operator|=
name|t
operator|->
name|pointloc
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_x
argument_list|)
operator|=
name|cursX
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_y
argument_list|)
operator|=
name|cursY
expr_stmt|;
if|if
condition|(
name|all_windows
condition|)
name|mark_window_display_accurate
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|->
name|redo_mode_line
operator|=
name|Qnil
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
name|t
operator|->
name|modified
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|<
literal|0
condition|)
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
operator|-
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
expr_stmt|;
block|}
name|RedoModes
operator|=
literal|0
expr_stmt|;
name|windows_or_buffers_changed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start SIGIO interrupts coming again.      Having them off during the code above      makes it less likely one will discard output,      but not impossible, since there might be stuff      in the system buffer here.      But it is much hairier to try to do anything about that.  */
if|if
condition|(
name|interrupt_input
condition|)
name|request_sigio
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|mark_window_display_accurate
argument_list|(
argument|window
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
decl_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|window
argument_list|)
condition|;
name|window
operator|=
name|w
operator|->
name|next
control|)
block|{
name|w
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
operator|!
name|flag
condition|?
literal|0
else|:
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|==
name|bf_cur
condition|?
name|bf_modified
else|:
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|text
operator|.
name|modified
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|<
literal|0
condition|)
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
operator|-
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
expr_stmt|;
name|w
operator|->
name|redo_mode_line
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
condition|)
name|mark_window_display_accurate
argument_list|(
name|w
operator|->
name|vchild
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
condition|)
name|mark_window_display_accurate
argument_list|(
name|w
operator|->
name|hchild
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|int
name|do_id
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do full redisplay of one or all windows.   This does not include updating the screen;   just generating lines to pass to update_screen.  */
end_comment

begin_comment
comment|/* Entry point to redisplay all windows */
end_comment

begin_macro
name|redisplay_all_windows
argument_list|()
end_macro

begin_block
block|{
name|buffer_shared
operator|=
literal|0
expr_stmt|;
name|redisplay_windows
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|redisplay_windows
argument_list|(
argument|window
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|window
argument_list|)
condition|;
name|window
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|next
control|)
name|redisplay_window
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|redisplay_window
argument_list|(
argument|window
argument_list|,
argument|just_this_one
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|just_this_one
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|int
name|height
decl_stmt|;
specifier|register
name|int
name|lpoint
init|=
name|point
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|int
name|width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
decl_stmt|;
specifier|register
name|int
name|startp
init|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
decl_stmt|;
specifier|register
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|struct
name|position
name|pos
decl_stmt|;
name|int
name|inhibit_hairy_id
init|=
literal|0
decl_stmt|;
name|int
name|opoint
decl_stmt|;
name|int
name|tem
decl_stmt|;
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Some bug zeros some core */
comment|/* If this is a combination window, do its children; that's all.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
condition|)
block|{
name|redisplay_windows
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
condition|)
block|{
name|redisplay_windows
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|RedoModes
condition|)
name|w
operator|->
name|redo_mode_line
operator|=
name|Qt
expr_stmt|;
comment|/* Otherwise set up data on this window; select its buffer and point value */
name|height
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
condition|)
name|height
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|minibuf_message
condition|)
return|return
literal|0
return|;
name|SetBfx
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|opoint
operator|=
name|point
expr_stmt|;
if|if
condition|(
operator|!
name|just_this_one
operator|&&
name|bf_cur
operator|==
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
name|buffer_shared
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
block|{
name|SetPoint
argument_list|(
name|marker_position
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|FirstCharacter
condition|)
name|point
operator|=
name|FirstCharacter
expr_stmt|;
elseif|else
if|if
condition|(
name|point
operator|>
name|NumCharacters
condition|)
name|point
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Handle case where place to start displaying has been specified */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|force_start
argument_list|)
condition|)
block|{
name|w
operator|->
name|redo_mode_line
operator|=
name|Qt
expr_stmt|;
name|w
operator|->
name|force_start
operator|=
name|Qnil
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|try_window
argument_list|(
name|window
argument_list|,
name|startp
argument_list|)
condition|)
block|{
comment|/* If point does not appear, move point so it does appear */
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|startp
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|startp
operator|==
literal|1
operator|)
condition|?
name|minibuf_prompt_width
else|:
literal|0
operator|)
operator|+
operator|(
name|hscroll
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
operator|)
argument_list|,
name|NumCharacters
operator|+
literal|1
argument_list|,
name|height
operator|/
literal|2
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|startp
argument_list|)
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
operator|.
name|bufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
condition|)
name|Fset_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
name|lpoint
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
block|{
name|cursX
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|pos
operator|.
name|hpos
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|cursY
operator|=
name|pos
operator|.
name|vpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
comment|/* Handle case where text has not changed, only point,      and it has not moved off the screen */
comment|/* This code is not used for minibuffer for the sake of      the case of redisplaying to replace an echo area message;      since in that case the minibuffer contents per se are usually unchanged.      This code is of no real use in the minibuffer since      the handling of tlbufpos, etc., in DoDsp handles the same cases.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|>=
name|bf_modified
operator|&&
name|point
operator|>=
name|startp
operator|&&
operator|!
name|clip_changed
operator|&&
operator|(
name|just_this_one
operator|||
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|==
name|screen_width
operator|)
operator|&&
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
block|{
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|startp
argument_list|,
literal|0
argument_list|,
operator|(
name|hscroll
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
operator|)
argument_list|,
name|point
argument_list|,
name|height
operator|+
literal|1
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|startp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|vpos
operator|<
name|height
condition|)
block|{
comment|/* Ok, point is still on screen */
if|if
condition|(
name|w
operator|==
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
condition|)
block|{
comment|/* These variables are supposed to be origin 1 */
name|cursX
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|pos
operator|.
name|hpos
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|cursY
operator|=
name|pos
operator|.
name|vpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
comment|/* This doesn't do the trick, because if a window to the right of  this one must be redisplayed, this does nothing because there  is nothing in DesiredScreen yet, and then the other window is  redisplayed, making likes that are empty in this window's columns. 	  if (XFASTINT (w->width) != screen_width) 	    preserve_my_columns (w); */
goto|goto
name|done
goto|;
block|}
comment|/* Don't bother trying redisplay with same start; 	we already know it will lose */
block|}
elseif|else
if|if
condition|(
name|just_this_one
operator|&&
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|point
operator|>=
name|startp
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|>=
literal|0
operator|&&
name|do_id
operator|&&
operator|!
name|clip_changed
operator|&&
operator|!
name|blank_end_of_window
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|==
name|screen_width
operator|&&
operator|(
name|tem
operator|=
name|try_window_id
argument_list|(
name|selected_window
argument_list|)
operator|)
operator|&&
name|tem
operator|!=
operator|-
literal|2
condition|)
block|{
comment|/* tem> 0 means success.  tem == -1 means choose new start. 	 tem == -2 means try again with same start, 	  and nothing but whitespace follows the changed stuff. 	 tem == 0 means try again with same start.  */
if|if
condition|(
name|tem
operator|>
literal|0
condition|)
block|{
comment|/*       inhibit_hairy_id = 1;   */
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|startp
operator|>=
name|FirstCharacter
operator|&&
name|startp
operator|<=
name|NumCharacters
operator|+
literal|1
comment|/* Avoid starting display at end of buffer! */
operator|&&
operator|(
name|startp
operator|<=
name|NumCharacters
operator|||
name|startp
operator|==
name|FirstCharacter
operator|||
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|>=
name|bf_modified
operator|)
operator|)
condition|)
block|{
comment|/* Try to redisplay starting at same place as before */
comment|/* If point has not moved off screen, accept the results */
if|if
condition|(
name|try_window
argument_list|(
name|window
argument_list|,
name|startp
argument_list|)
condition|)
goto|goto
name|done
goto|;
else|else
name|cancel_my_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|redo_mode_line
operator|=
name|Qt
expr_stmt|;
comment|/* Try to scroll by specified few lines */
if|if
condition|(
name|scroll_step
operator|&&
operator|!
name|clip_changed
condition|)
block|{
if|if
condition|(
name|point
operator|>
name|startp
condition|)
block|{
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|CURRENT_END_POS
argument_list|(
name|w
argument_list|)
argument_list|,
name|scroll_step
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|vpos
operator|>=
name|height
condition|)
goto|goto
name|scroll_fail
goto|;
block|}
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|startp
argument_list|,
name|point
operator|<
name|startp
condition|?
operator|-
name|scroll_step
else|:
name|scroll_step
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|>=
name|pos
operator|.
name|bufpos
condition|)
block|{
if|if
condition|(
name|try_window
argument_list|(
name|window
argument_list|,
name|pos
operator|.
name|bufpos
argument_list|)
condition|)
goto|goto
name|done
goto|;
else|else
name|cancel_my_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|scroll_fail
label|:
empty_stmt|;
block|}
comment|/* Finally, just choose place to start which centers point */
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|point
argument_list|,
operator|-
name|height
operator|/
literal|2
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|try_window
argument_list|(
name|window
argument_list|,
name|pos
operator|.
name|bufpos
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* If window not full width, must redo its mode line      if the window to its side is being redone */
if|if
condition|(
operator|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|redo_mode_line
argument_list|)
operator|||
operator|(
operator|!
name|just_this_one
operator|&&
name|width
operator|<
name|screen_width
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
name|display_mode_line
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
name|SetBfx
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|lpoint
argument_list|)
expr_stmt|;
return|return
name|inhibit_hairy_id
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Do full redisplay on one window,   starting at position `pos',   and return nonzero if point appears in the displayed text */
end_comment

begin_macro
name|try_window
argument_list|(
argument|window
argument_list|,
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|height
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|-
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|vpos
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
decl_stmt|;
specifier|register
name|int
name|last_text_vpos
init|=
name|vpos
decl_stmt|;
name|int
name|tab_offset
init|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|struct
name|position
name|val
decl_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|pos
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|height
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|display_text_line
argument_list|(
name|w
argument_list|,
name|pos
argument_list|,
name|vpos
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|tab_offset
argument_list|)
expr_stmt|;
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
condition|)
name|tab_offset
operator|=
literal|0
expr_stmt|;
name|vpos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|val
operator|.
name|bufpos
condition|)
name|last_text_vpos
comment|/* Next line, unless prev line ended in end of buffer with no cr */
operator|=
name|vpos
operator|-
operator|(
name|val
operator|.
name|vpos
operator|&&
name|CharAt
argument_list|(
name|val
operator|.
name|bufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|)
expr_stmt|;
name|pos
operator|=
name|val
operator|.
name|bufpos
expr_stmt|;
block|}
comment|/* If last line is continued in middle of character,      include the split character in the text considered on the screen */
if|if
condition|(
name|val
operator|.
name|hpos
operator|<
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
condition|)
name|pos
operator|++
expr_stmt|;
comment|/* Make this -1 minus what it really should be, so that it is negative.      That serves as a signal that it is not really valid.      When screen updating is through,      change this to its correct positive value */
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
operator|-
literal|1
operator|-
operator|(
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|pos
operator|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|=
name|last_text_vpos
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
expr_stmt|;
return|return
name|point_vpos
operator|>=
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Try to redisplay when buffer is modified locally,  computing insert/delete line to preserve text outside  the bounds of the changes.  Return 1 if successful, 0 if if cannot tell what to do,  or -1 to tell caller to find a new window start,  or -2 to tell caller that we did nothing because only whitespace  appears below the changed part of the screen.  */
end_comment

begin_macro
name|try_window_id
argument_list|(
argument|window
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pos
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|height
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|-
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
decl_stmt|;
name|int
name|top
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
decl_stmt|;
name|int
name|start
init|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
decl_stmt|;
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|int
name|lmargin
init|=
name|hscroll
operator|>
literal|0
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
decl_stmt|;
specifier|register
name|int
name|vpos
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|last_text_vpos
init|=
literal|0
decl_stmt|;
name|int
name|stop_vpos
decl_stmt|;
name|struct
name|position
name|val
decl_stmt|,
name|bp
decl_stmt|,
name|ep
decl_stmt|,
name|xp
decl_stmt|,
name|pp
decl_stmt|;
name|int
name|scroll_amount
init|=
literal|0
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|int
name|tab_offset
decl_stmt|,
name|epto
decl_stmt|;
if|if
condition|(
name|bf_s1
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|bf_s1
expr_stmt|;
if|if
condition|(
name|bf_s2
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|bf_s2
expr_stmt|;
if|if
condition|(
name|beg_unchanged
operator|+
literal|1
operator|<
name|start
condition|)
return|return
literal|0
return|;
comment|/* Give up if changes go above top of window */
comment|/* Find position before which nothing is changed.  */
name|bp
operator|=
operator|*
name|compute_motion
argument_list|(
name|start
argument_list|,
literal|0
argument_list|,
name|lmargin
argument_list|,
name|beg_unchanged
operator|+
literal|1
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|.
name|vpos
operator|>=
name|height
condition|)
return|return
name|point
operator|<
name|bp
operator|.
name|bufpos
operator|&&
operator|!
name|bp
operator|.
name|contin
return|;
name|vpos
operator|=
name|bp
operator|.
name|vpos
expr_stmt|;
comment|/* Find beginning of that screen line.  Must display from there.  */
name|bp
operator|=
operator|*
name|vmotion
argument_list|(
name|bp
operator|.
name|bufpos
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|pos
operator|=
name|bp
operator|.
name|bufpos
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|lmargin
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|start
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If about to start displaying at the beginning of a continuation line,      really start with previous screen line, in case it was not      continued when last redisplayed */
if|if
condition|(
name|bp
operator|.
name|contin
operator|&&
name|bp
operator|.
name|bufpos
operator|-
literal|1
operator|==
name|beg_unchanged
operator|&&
name|vpos
operator|>
literal|0
condition|)
block|{
name|bp
operator|=
operator|*
name|vmotion
argument_list|(
name|bp
operator|.
name|bufpos
argument_list|,
operator|-
literal|1
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
operator|--
name|vpos
expr_stmt|;
name|pos
operator|=
name|bp
operator|.
name|bufpos
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|.
name|contin
operator|&&
name|bp
operator|.
name|hpos
operator|!=
name|lmargin
condition|)
block|{
name|val
operator|.
name|hpos
operator|=
name|bp
operator|.
name|prevhpos
operator|-
name|width
operator|+
name|lmargin
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
name|bp
operator|.
name|vpos
operator|=
name|vpos
expr_stmt|;
comment|/* Find first newline after which no more is changed */
name|ep
operator|=
operator|*
name|compute_motion
argument_list|(
name|pos
argument_list|,
name|vpos
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|max
argument_list|(
name|end_unchanged
argument_list|,
name|bf_tail_clip
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|bp
operator|.
name|bufpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If changes reach past the text available on the screen,      just display rest of screen.  */
if|if
condition|(
name|ep
operator|.
name|bufpos
operator|>
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
condition|)
name|stop_vpos
operator|=
name|height
expr_stmt|;
else|else
name|stop_vpos
operator|=
name|ep
operator|.
name|vpos
expr_stmt|;
comment|/* If no newline before ep, the line ep is on includes some changes      that must be displayed.  Make sure we don't stop before it.  */
comment|/* Also, if changes reach all the way until ep.bufpos,      it is possible that something was deleted after the      newline before it, so the following line must be redrawn. */
if|if
condition|(
name|stop_vpos
operator|==
name|ep
operator|.
name|vpos
operator|&&
operator|(
name|ep
operator|.
name|bufpos
operator|==
name|FirstCharacter
operator|||
name|CharAt
argument_list|(
name|ep
operator|.
name|bufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|||
name|ep
operator|.
name|bufpos
operator|==
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|end_unchanged
operator|)
condition|)
name|stop_vpos
operator|=
name|ep
operator|.
name|vpos
operator|+
literal|1
expr_stmt|;
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If changes do not reach to bottom of window,      figure out how much to scroll the rest of the window */
if|if
condition|(
name|stop_vpos
operator|<
name|height
condition|)
block|{
comment|/* Now determine how far up or down the rest of the window has moved */
name|epto
operator|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|ep
operator|.
name|bufpos
argument_list|)
expr_stmt|;
name|xp
operator|=
operator|*
name|compute_motion
argument_list|(
name|ep
operator|.
name|bufpos
argument_list|,
name|ep
operator|.
name|vpos
argument_list|,
name|ep
operator|.
name|hpos
argument_list|,
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
argument_list|,
literal|10000
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|epto
argument_list|)
expr_stmt|;
name|scroll_amount
operator|=
name|xp
operator|.
name|vpos
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
expr_stmt|;
comment|/* Is everything on screen below the changes whitespace? 	 If so, no scrolling is really necessary.  */
for|for
control|(
name|i
operator|=
name|ep
operator|.
name|bufpos
init|;
name|i
operator|<
name|xp
operator|.
name|bufpos
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|CharAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|' '
operator|&&
name|tem
operator|!=
literal|'\n'
operator|&&
name|tem
operator|!=
literal|'\t'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|xp
operator|.
name|bufpos
condition|)
return|return
operator|-
literal|2
return|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|+=
name|scroll_amount
expr_stmt|;
comment|/* Before doing any scrolling, verify that point will be on screen. */
if|if
condition|(
name|point
operator|>
name|ep
operator|.
name|bufpos
operator|&&
operator|!
operator|(
name|point
operator|<=
name|xp
operator|.
name|bufpos
operator|&&
name|xp
operator|.
name|bufpos
operator|<
name|height
operator|)
condition|)
block|{
if|if
condition|(
name|point
operator|<=
name|xp
operator|.
name|bufpos
condition|)
block|{
name|pp
operator|=
operator|*
name|compute_motion
argument_list|(
name|ep
operator|.
name|bufpos
argument_list|,
name|ep
operator|.
name|vpos
argument_list|,
name|ep
operator|.
name|hpos
argument_list|,
name|point
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|epto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|=
operator|*
name|compute_motion
argument_list|(
name|xp
operator|.
name|bufpos
argument_list|,
name|xp
operator|.
name|vpos
argument_list|,
name|xp
operator|.
name|hpos
argument_list|,
name|point
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|xp
operator|.
name|bufpos
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|.
name|bufpos
operator|<
name|point
operator|||
name|pp
operator|.
name|vpos
operator|==
name|height
condition|)
return|return
literal|0
return|;
name|point_vpos
operator|=
name|pp
operator|.
name|vpos
operator|+
name|top
expr_stmt|;
name|point_hpos
operator|=
name|pp
operator|.
name|hpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop_vpos
operator|-
name|scroll_amount
operator|>=
name|height
operator|||
name|ep
operator|.
name|bufpos
operator|==
name|xp
operator|.
name|bufpos
condition|)
block|{
if|if
condition|(
name|scroll_amount
operator|<
literal|0
condition|)
name|stop_vpos
operator|-=
name|scroll_amount
expr_stmt|;
name|scroll_amount
operator|=
literal|0
expr_stmt|;
comment|/* In this path, we have altered window_end_vpos 	     and not left it negative. 	     We must make sure that, in case display is preempted 	     before the screen changes to reflect what we do here, 	     further updates will not come to try_window_id 	     and assume the screen and window_end_vpos match.  */
name|blank_end_of_window
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scroll_amount
condition|)
block|{}
elseif|else
if|if
condition|(
name|bp
operator|.
name|bufpos
operator|==
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|end_unchanged
condition|)
block|{
comment|/* If pure deletion, scroll up as many lines as possible. 	     In common case of killing a line, this can save the 	     following line from being overwritten by scrolling 	     and therefore having to be redrawn.  */
name|tem
operator|=
name|scroll_screen_lines
argument_list|(
name|bp
operator|.
name|vpos
operator|+
name|top
operator|-
name|scroll_amount
argument_list|,
name|top
operator|+
name|height
operator|-
name|max
argument_list|(
literal|0
argument_list|,
name|scroll_amount
argument_list|)
argument_list|,
name|scroll_amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|stop_vpos
operator|=
name|height
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scroll_amount
condition|)
block|{
name|tem
operator|=
name|scroll_screen_lines
argument_list|(
name|ep
operator|.
name|vpos
operator|+
name|top
operator|-
name|scroll_amount
argument_list|,
name|top
operator|+
name|height
operator|-
name|max
argument_list|(
literal|0
argument_list|,
name|scroll_amount
argument_list|)
argument_list|,
name|scroll_amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|stop_vpos
operator|=
name|height
expr_stmt|;
block|}
block|}
comment|/* In any case, do not display past bottom of window */
if|if
condition|(
name|stop_vpos
operator|>=
name|height
condition|)
block|{
name|stop_vpos
operator|=
name|height
expr_stmt|;
name|scroll_amount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Handle case where pos is before w->start --      can happen if part of line had been clipped and is not clipped now */
if|if
condition|(
name|vpos
operator|==
literal|0
operator|&&
name|pos
operator|<
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
condition|)
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|pos
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
comment|/* Redisplay the lines where the text was changed */
name|last_text_vpos
operator|=
name|vpos
expr_stmt|;
name|tab_offset
operator|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|hpos
operator|<
literal|0
condition|)
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|vpos
operator|<
name|stop_vpos
condition|)
block|{
name|val
operator|=
operator|*
name|display_text_line
argument_list|(
name|w
argument_list|,
name|pos
argument_list|,
name|top
operator|+
name|vpos
operator|++
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|tab_offset
argument_list|)
expr_stmt|;
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
condition|)
name|tab_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|val
operator|.
name|bufpos
condition|)
name|last_text_vpos
comment|/* Next line, unless prev line ended in end of buffer with no cr */
operator|=
name|vpos
operator|-
operator|(
name|val
operator|.
name|vpos
operator|&&
name|CharAt
argument_list|(
name|val
operator|.
name|bufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|)
expr_stmt|;
name|pos
operator|=
name|val
operator|.
name|bufpos
expr_stmt|;
block|}
comment|/* There are two cases:      1) we have displayed down to the bottom of the window      2) we have scrolled lines below stop_vpos by scroll_amount  */
if|if
condition|(
name|vpos
operator|==
name|height
condition|)
block|{
comment|/* If last line is continued in middle of character, 	 include the split character in the text considered on the screen */
if|if
condition|(
name|val
operator|.
name|hpos
operator|<
name|lmargin
condition|)
name|val
operator|.
name|bufpos
operator|++
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|=
name|last_text_vpos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
operator|-
literal|1
operator|-
operator|(
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|val
operator|.
name|bufpos
operator|)
expr_stmt|;
block|}
comment|/* If scrolling made blank lines at window bottom,      redisplay to fill those lines */
if|if
condition|(
name|scroll_amount
operator|<
literal|0
condition|)
block|{
name|vpos
operator|=
name|xp
operator|.
name|vpos
expr_stmt|;
name|pos
operator|=
name|xp
operator|.
name|bufpos
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|lmargin
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NumCharacters
operator|+
literal|1
condition|)
name|vpos
operator|=
name|height
operator|+
name|scroll_amount
expr_stmt|;
elseif|else
if|if
condition|(
name|xp
operator|.
name|contin
operator|&&
name|xp
operator|.
name|hpos
operator|!=
name|lmargin
condition|)
block|{
name|val
operator|.
name|hpos
operator|=
name|xp
operator|.
name|prevhpos
operator|-
name|width
operator|+
name|lmargin
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
name|blank_end_of_window
operator|=
literal|1
expr_stmt|;
name|tab_offset
operator|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|hpos
operator|<
literal|0
condition|)
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|vpos
operator|<
name|height
condition|)
block|{
name|val
operator|=
operator|*
name|display_text_line
argument_list|(
name|w
argument_list|,
name|pos
argument_list|,
name|top
operator|+
name|vpos
operator|++
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|tab_offset
argument_list|)
expr_stmt|;
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
condition|)
name|tab_offset
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|val
operator|.
name|bufpos
expr_stmt|;
block|}
comment|/* Here is a case where display_line_text sets point_vpos wrong. 	 Make it be fixed up, below.  */
if|if
condition|(
name|xp
operator|.
name|bufpos
operator|==
name|NumCharacters
operator|+
literal|1
operator|&&
name|xp
operator|.
name|bufpos
operator|==
name|point
condition|)
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Attempt to adjust end-of-text positions to new bottom line */
if|if
condition|(
name|scroll_amount
condition|)
block|{
name|delta
operator|=
name|height
operator|-
name|xp
operator|.
name|vpos
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
operator|||
operator|(
name|delta
operator|>
literal|0
operator|&&
name|xp
operator|.
name|bufpos
operator|<=
name|NumCharacters
operator|)
operator|||
operator|(
name|delta
operator|==
literal|0
operator|&&
name|xp
operator|.
name|hpos
operator|)
condition|)
block|{
name|val
operator|=
operator|*
name|vmotion
argument_list|(
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
argument_list|,
name|delta
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|val
operator|.
name|bufpos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|+=
name|val
operator|.
name|vpos
expr_stmt|;
block|}
block|}
comment|/* If point was not in a line that was displayed, find it */
if|if
condition|(
name|point_vpos
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|compute_motion
argument_list|(
name|start
argument_list|,
literal|0
argument_list|,
name|lmargin
argument_list|,
name|point
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Admit failure if point is off screen now */
if|if
condition|(
name|val
operator|.
name|vpos
operator|>=
name|height
condition|)
block|{
for|for
control|(
name|vpos
operator|=
literal|0
init|;
name|vpos
operator|<
name|height
condition|;
name|vpos
operator|++
control|)
name|cancel_line
argument_list|(
name|vpos
operator|+
name|top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|point_vpos
operator|=
name|val
operator|.
name|vpos
operator|+
name|top
expr_stmt|;
name|point_hpos
operator|=
name|val
operator|.
name|hpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
name|cursX
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|point_hpos
argument_list|)
expr_stmt|;
name|cursY
operator|=
name|point_vpos
expr_stmt|;
if|if
condition|(
name|debug_end_pos
condition|)
block|{
name|val
operator|=
operator|*
name|compute_motion
argument_list|(
name|start
argument_list|,
literal|0
argument_list|,
name|lmargin
argument_list|,
name|NumCharacters
operator|+
literal|1
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
operator|!=
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
else|:
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|)
operator|!=
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|val
operator|.
name|bufpos
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Display one line of window w, starting at position `start' in w's buffer.  Display starting at horizontal position `hpos',   which is normally zero or negative.   A negative value causes output up to hpos = 0 to be discarded.   This is done for negative hscroll, or when this is a continuation line   and the continuation occurred in the middle of a multi-column character.   `taboffset' is an offset for ostensible hpos, used in tab stop calculations.   Display on position `vpos' on the screen.  (origin 0).   Returns a `struct position' giving character to start next line with  and where to display it, including a zero or negative hpos.  The vpos field is not really a vpos; it is 1 unless the line is continued */
end_comment

begin_decl_stmt
name|struct
name|position
name|val_display_text_line
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|position
modifier|*
name|display_text_line
parameter_list|(
name|w
parameter_list|,
name|start
parameter_list|,
name|vpos
parameter_list|,
name|hpos
parameter_list|,
name|taboffset
parameter_list|)
name|struct
name|window
modifier|*
name|w
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|vpos
decl_stmt|;
name|int
name|hpos
decl_stmt|;
name|int
name|taboffset
decl_stmt|;
block|{
specifier|register
name|int
name|pos
init|=
name|start
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|end
decl_stmt|;
specifier|register
name|int
name|pause
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
specifier|register
name|char
modifier|*
name|startp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1prev
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|line
decl_stmt|;
name|int
name|tab_width
init|=
name|XFASTINT
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|tab_width
argument_list|)
decl_stmt|;
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
decl_stmt|;
name|struct
name|position
name|val
decl_stmt|;
name|int
name|lastpos
decl_stmt|;
name|int
name|invis
decl_stmt|;
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|int
name|truncate
init|=
name|hscroll
operator|||
operator|(
name|truncate_partial_width_windows
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|<
name|screen_width
operator|)
operator|||
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|truncate_lines
argument_list|)
decl_stmt|;
name|int
name|selective
init|=
name|XTYPE
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
operator|==
name|Lisp_Int
condition|?
name|XINT
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
else|:
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|hpos
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|line
operator|=
name|get_display_line
argument_list|(
name|vpos
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
condition|)
name|tab_width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|&&
name|start
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|minibuf_prompt
condition|)
name|hpos
operator|=
name|display_string
argument_list|(
name|w
argument_list|,
name|line
argument_list|,
name|minibuf_prompt
argument_list|,
name|hpos
argument_list|,
operator|!
name|truncate
condition|?
literal|'\\'
else|:
literal|'$'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minibuf_prompt_width
operator|=
name|hpos
expr_stmt|;
block|}
name|p1
operator|=
name|line
operator|->
name|body
operator|+
name|hpos
expr_stmt|;
name|end
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
name|startp
operator|=
name|line
operator|->
name|body
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|endp
operator|=
name|startp
operator|+
name|width
expr_stmt|;
comment|/* Loop generating characters.    Stop at end of buffer, before newline,    or if reach or pass continuation column.  */
name|pause
operator|=
name|pos
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|endp
condition|)
block|{
name|p1prev
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|pause
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|end
condition|)
break|break;
if|if
condition|(
name|pos
operator|==
name|point
operator|&&
name|point_vpos
operator|<
literal|0
condition|)
block|{
name|point_vpos
operator|=
name|vpos
expr_stmt|;
name|point_hpos
operator|=
name|p1
operator|-
name|startp
expr_stmt|;
block|}
name|pause
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|point
operator|&&
name|point
operator|<
name|pause
condition|)
name|pause
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|pos
operator|<=
name|bf_s1
operator|&&
name|bf_s1
operator|+
literal|1
operator|<
name|pause
condition|)
name|pause
operator|=
name|bf_s1
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|&
name|CharAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
name|c
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|invis
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
operator|&&
name|selective
operator|>
literal|0
operator|&&
name|position_indentation
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|>=
name|selective
condition|)
block|{
name|invis
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CharAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
name|pos
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|invis
condition|)
block|{
name|p1
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|p1
operator|-
name|startp
operator|>
name|width
condition|)
name|p1
operator|=
name|endp
expr_stmt|;
name|strncpy
argument_list|(
name|p1prev
argument_list|,
literal|" ..."
argument_list|,
name|p1
operator|-
name|p1prev
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
do|do
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
literal|' '
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|p1
operator|-
name|startp
operator|+
name|taboffset
operator|+
name|hscroll
operator|-
operator|(
name|hscroll
operator|>
literal|0
operator|)
operator|)
operator|%
name|tab_width
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|Ctl
argument_list|(
literal|'M'
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
condition|)
block|{
name|pos
operator|=
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CharAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
name|pos
operator|--
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0200
operator|&&
name|ctl_arrow
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
literal|'^'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
name|c
operator|^
literal|0100
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
literal|'\\'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
operator|(
name|c
operator|>>
literal|3
operator|)
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
name|c
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
name|val
operator|.
name|hpos
operator|=
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|hpos
condition|)
block|{
name|val
operator|.
name|hpos
operator|++
expr_stmt|;
comment|/* If line not empty, insert truncation-at-left marker */
if|if
condition|(
name|pos
operator|!=
name|start
condition|)
block|{
operator|*
name|startp
operator|=
literal|'$'
expr_stmt|;
if|if
condition|(
name|p1
operator|<=
name|startp
condition|)
name|p1
operator|=
name|startp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|length
operator|<=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
condition|)
name|line
operator|->
name|length
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|val
operator|.
name|vpos
operator|=
literal|1
expr_stmt|;
comment|/* Handle continuation in middle of a character */
comment|/* by backing up over it */
if|if
condition|(
name|p1
operator|>
name|endp
condition|)
block|{
comment|/* Start the next line with that same character */
name|pos
operator|--
expr_stmt|;
comment|/* but at a negative hpos, to skip the columns output on this line.  */
name|val
operator|.
name|hpos
operator|+=
name|p1prev
operator|-
name|endp
expr_stmt|;
comment|/* Keep in this line everything up to the continuation column.  */
name|p1
operator|=
name|endp
expr_stmt|;
block|}
comment|/* Finish deciding which character to start the next line on,      and what hpos to start it at.      Also set `lastpos' to the last position which counts as "on this line"      for cursor-positioning.  */
name|lastpos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|NumCharacters
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|==
literal|'\n'
condition|)
comment|/* If stopped due to a newline, start next line after it */
name|pos
operator|++
expr_stmt|;
else|else
comment|/* Stopped due to right margin of window */
block|{
if|if
condition|(
name|truncate
condition|)
block|{
operator|*
name|p1
operator|++
operator|=
literal|'$'
expr_stmt|;
comment|/* Truncating => start next line after next newline, 		 and point is on this line if it is before the newline, 		 and skip none of first char of next line */
name|pos
operator|=
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
expr_stmt|;
name|lastpos
operator|=
name|pos
operator|-
operator|(
name|CharAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p1
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|val
operator|.
name|vpos
operator|=
literal|0
expr_stmt|;
name|lastpos
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|start
operator|<=
name|point
operator|&&
name|point
operator|<=
name|lastpos
operator|&&
name|point_vpos
operator|<
literal|0
condition|)
block|{
name|point_vpos
operator|=
name|vpos
expr_stmt|;
name|point_hpos
operator|=
name|p1
operator|-
name|startp
expr_stmt|;
block|}
if|if
condition|(
name|point_vpos
operator|==
name|vpos
condition|)
block|{
if|if
condition|(
name|point_hpos
operator|<
literal|0
condition|)
name|point_hpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|point_hpos
operator|>
name|width
condition|)
name|point_hpos
operator|=
name|width
expr_stmt|;
name|point_hpos
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
condition|)
block|{
name|cursY
operator|=
name|point_vpos
expr_stmt|;
name|cursX
operator|=
name|point_hpos
expr_stmt|;
comment|/* Line is not continued and did not start in middle of character */
if|if
condition|(
name|hpos
operator|==
operator|(
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
operator|)
operator|&&
name|val
operator|.
name|vpos
condition|)
block|{
name|this_line_bufpos
operator|=
name|start
expr_stmt|;
name|this_line_buffer
operator|=
name|bf_cur
expr_stmt|;
name|this_line_vpos
operator|=
name|vpos
expr_stmt|;
name|this_line_hpos
operator|=
name|hpos
expr_stmt|;
name|this_line_endpos
operator|=
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|lastpos
expr_stmt|;
block|}
else|else
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
condition|)
block|{
name|endp
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|<
name|startp
condition|)
name|p1
operator|=
name|startp
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|endp
condition|)
operator|*
name|p1
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|p1
operator|++
operator|=
literal|'|'
expr_stmt|;
block|}
name|line
operator|->
name|length
operator|=
name|max
argument_list|(
name|line
operator|->
name|length
argument_list|,
name|p1
operator|-
name|line
operator|->
name|body
argument_list|)
expr_stmt|;
name|line
operator|->
name|body
index|[
name|line
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|bufpos
operator|=
name|pos
expr_stmt|;
name|val_display_text_line
operator|=
name|val
expr_stmt|;
return|return
operator|&
name|val_display_text_line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display the mode line for window w */
end_comment

begin_macro
name|display_mode_line
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|vpos
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|-
literal|1
decl_stmt|;
name|struct
name|display_line
modifier|*
name|line
init|=
name|get_display_line
argument_list|(
name|vpos
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|mode_line_format
argument_list|)
operator|->
name|data
decl_stmt|;
name|display_string
argument_list|(
name|w
argument_list|,
name|line
argument_list|,
name|s
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make the mode line inverse video if the entire line      is made of mode lines.      I.e. if this window is full width,      or if it is the child of a full width window      (which implies that that window is split side-by-side      and the rest of this line is mode lines of the sibling windows).  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|==
name|screen_width
operator|||
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|width
argument_list|)
operator|==
name|screen_width
condition|)
name|line
operator|->
name|highlighted
operator|=
name|mode_line_inverse_video
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|fmodetrunc_buf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|fmodetrunc
parameter_list|(
name|str
parameter_list|,
name|width
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|buf
init|=
name|fmodetrunc_buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
specifier|register
name|long
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|&&
name|width
operator|<
name|len
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|str
operator|+
name|len
operator|-
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
while|while
condition|(
operator|*
name|bp
condition|)
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'/'
condition|)
block|{
name|bp
operator|--
expr_stmt|;
operator|*
operator|--
name|bp
operator|=
literal|'$'
expr_stmt|;
return|return
name|bp
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|char
name|decode_mode_spec_buf
index|[
name|MScreenWidth
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|decode_mode_spec
parameter_list|(
name|w
parameter_list|,
name|string
parameter_list|,
name|data_ptr
parameter_list|,
name|len_ptr
parameter_list|,
name|max_ptr
parameter_list|)
name|struct
name|window
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
modifier|*
name|data_ptr
decl_stmt|;
name|int
modifier|*
name|len_ptr
decl_stmt|;
name|int
modifier|*
name|max_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|width
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|Lisp_Object
name|lstr
decl_stmt|,
name|proc
decl_stmt|,
name|list
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|total
decl_stmt|;
name|char
modifier|*
name|tbuf
init|=
name|decode_mode_spec_buf
decl_stmt|;
define|#
directive|define
name|tbufsize
value|(sizeof decode_mode_spec_buf)
name|lstr
operator|=
name|Qnil
operator|,
name|str
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|string
operator|++
argument_list|)
condition|)
name|width
operator|=
name|width
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|lstr
operator|=
name|bf_cur
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|width
operator|&&
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|size
operator|>
name|width
condition|)
name|width
operator|=
name|min
argument_list|(
literal|2
operator|*
name|width
argument_list|,
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|&&
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|size
operator|>
name|width
condition|)
block|{
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|width
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|data
argument_list|,
name|str
argument_list|,
name|width
operator|-
literal|3
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"..."
argument_list|,
name|str
operator|+
name|width
operator|-
literal|3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|lstr
operator|=
name|Qnil
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|NULL
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
condition|)
name|str
operator|=
literal|"[none]"
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
operator|==
name|Lisp_String
condition|)
name|str
operator|=
name|fmodetrunc
argument_list|(
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|lstr
operator|=
name|bf_cur
operator|->
name|mode_name
expr_stmt|;
name|total
operator|=
name|min
argument_list|(
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|size
argument_list|,
name|tbufsize
operator|-
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|<
literal|0
condition|)
name|total
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|data
argument_list|,
name|tbuf
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|list
operator|=
name|bf_cur
operator|->
name|minor_modes
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|list
argument_list|)
operator|&&
operator|!
name|len
condition|)
block|{
name|list
operator|=
name|Vglobal_minor_modes
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|total
operator|<
name|tbufsize
operator|-
literal|30
operator|&&
name|LISTP
argument_list|(
name|list
argument_list|)
operator|)
condition|)
break|break;
name|lstr
operator|=
name|XCONS
argument_list|(
name|list
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|lstr
argument_list|)
condition|)
goto|goto
name|foo
goto|;
name|lstr
operator|=
name|XCONS
argument_list|(
name|lstr
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|lstr
argument_list|)
operator|!=
name|Lisp_String
condition|)
goto|goto
name|foo
goto|;
name|tbuf
index|[
name|total
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|pos
operator|=
name|min
argument_list|(
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|size
argument_list|,
name|tbufsize
operator|-
literal|30
operator|-
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|data
argument_list|,
name|tbuf
operator|+
name|total
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|total
operator|+=
name|pos
expr_stmt|;
name|foo
label|:
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|tbuf
expr_stmt|;
name|tbuf
index|[
name|total
index|]
operator|=
literal|0
expr_stmt|;
comment|/*    if (bf_cur->abbrev_mode) 	strcat (tbuf, " Abbrev"); */
if|if
condition|(
name|bf_head_clip
operator|>
literal|1
operator|||
name|bf_tail_clip
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|tbuf
argument_list|,
literal|" Narrow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|defining_kbd_macro
condition|)
name|strcat
argument_list|(
name|tbuf
argument_list|,
literal|" Def"
argument_list|)
expr_stmt|;
name|lstr
operator|=
name|Qnil
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|lstr
operator|=
name|Vglobal_mode_string
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|str
operator|=
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|?
literal|"%"
else|:
name|bf_modified
operator|>
name|bf_cur
operator|->
name|save_modified
condition|?
literal|"*"
else|:
literal|"-"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* status of process */
ifdef|#
directive|ifdef
name|subprocesses
name|proc
operator|=
name|Fget_buffer_process
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
name|str
operator|=
literal|"no process"
expr_stmt|;
else|else
name|lstr
operator|=
name|Fsymbol_name
argument_list|(
name|Fprocess_status
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|str
operator|=
literal|"no process"
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
break|break;
case|case
literal|'p'
case|:
name|pos
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
expr_stmt|;
name|total
operator|=
name|NumCharacters
operator|+
literal|1
operator|-
name|FirstCharacter
expr_stmt|;
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
else|:
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|)
operator|<=
name|bf_tail_clip
condition|)
block|{
if|if
condition|(
name|pos
operator|<=
name|FirstCharacter
condition|)
name|str
operator|=
literal|"All"
expr_stmt|;
else|else
name|str
operator|=
literal|"Bottom"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|<=
name|FirstCharacter
condition|)
name|str
operator|=
literal|"Top"
expr_stmt|;
else|else
block|{
name|total
operator|=
operator|(
operator|(
name|pos
operator|-
name|FirstCharacter
operator|)
operator|*
literal|100
operator|+
name|total
operator|-
literal|1
operator|)
operator|/
name|total
expr_stmt|;
comment|/* We can't normally display a 3-digit number, 	     so get us a 2-digit number that is close.  */
if|if
condition|(
name|total
operator|==
literal|100
condition|)
name|total
operator|=
literal|99
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%2d%%"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|str
operator|=
name|tbuf
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
name|str
operator|=
literal|"[[[[[[[[[["
operator|+
literal|10
operator|-
operator|(
name|RecurseDepth
operator|-
name|MinibufDepth
operator|)
expr_stmt|;
if|if
condition|(
name|RecurseDepth
operator|-
name|MinibufDepth
operator|>
literal|10
condition|)
name|str
operator|=
literal|"[[[... "
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|str
operator|=
literal|"]]]]]]]]]]"
operator|+
literal|10
operator|-
operator|(
name|RecurseDepth
operator|-
name|MinibufDepth
operator|)
expr_stmt|;
if|if
condition|(
name|RecurseDepth
operator|-
name|MinibufDepth
operator|>
literal|10
condition|)
name|str
operator|=
literal|" ...]]]"
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|str
operator|=
literal|"--------------------------------------------------------------------------------------------------------------------------------------------"
expr_stmt|;
block|}
comment|/* Report the chosen mode item to the caller */
if|if
condition|(
name|str
condition|)
operator|*
name|data_ptr
operator|=
name|str
operator|,
operator|*
name|len_ptr
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|lstr
argument_list|)
operator|==
name|Lisp_String
condition|)
operator|*
name|data_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|data
operator|,
operator|*
name|len_ptr
operator|=
name|XSTRING
argument_list|(
name|lstr
argument_list|)
operator|->
name|size
expr_stmt|;
else|else
operator|*
name|data_ptr
operator|=
literal|0
operator|,
operator|*
name|len_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Report specified truncation or padding */
operator|*
name|max_ptr
operator|=
name|width
expr_stmt|;
comment|/* Tell caller how much of mode line format was used up */
return|return
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display `string' on one line of window `w', starting at `hpos'.  Display on the display_line `line', which should have   been obtained by get_display_line (vpos, hpos)   or in some suitable manner.   `truncate' is character to display at end if truncated.  `modeline' nonzero means substitute for % constructs.   Returns ending hpos */
end_comment

begin_macro
name|display_string
argument_list|(
argument|w
argument_list|,
argument|line
argument_list|,
argument|string
argument_list|,
argument|hpos
argument_list|,
argument|truncate
argument_list|,
argument|modeline
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|display_line
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|truncate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|modeline
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
decl_stmt|;
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|int
name|tab_width
init|=
literal|8
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|modeeltstring
decl_stmt|;
name|int
name|modeeltleft
init|=
literal|0
decl_stmt|;
name|int
name|modeeltmax
init|=
literal|0
decl_stmt|;
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|line
operator|->
name|body
operator|+
name|hpos
expr_stmt|;
name|start
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|line
operator|->
name|body
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|width
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|modeeltmax
condition|)
block|{
name|modeeltmax
operator|--
expr_stmt|;
if|if
condition|(
name|modeeltleft
operator|--
operator|>
literal|0
condition|)
name|c
operator|=
operator|*
name|modeeltstring
operator|++
expr_stmt|;
else|else
name|c
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
name|modeline
condition|)
block|{
name|string
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|decode_mode_spec
argument_list|(
name|w
argument_list|,
name|string
argument_list|,
operator|&
name|modeeltstring
argument_list|,
operator|&
name|modeeltleft
argument_list|,
operator|&
name|modeeltmax
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|modeeltmax
condition|)
name|modeeltmax
operator|=
name|modeeltleft
expr_stmt|;
elseif|else
if|if
condition|(
name|modeeltleft
operator|>
name|modeeltmax
condition|)
name|modeeltleft
operator|=
name|modeeltmax
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
name|c
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
do|do
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
literal|' '
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|p1
operator|-
name|start
operator|+
name|hscroll
operator|-
operator|(
name|hscroll
operator|>
literal|0
operator|)
operator|)
operator|%
name|tab_width
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0200
operator|&&
name|default_ctl_arrow
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
literal|'^'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
name|c
operator|^
literal|0100
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
literal|'\\'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
operator|(
name|c
operator|>>
literal|3
operator|)
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
name|c
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
condition|)
block|{
name|p1
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|truncate
condition|)
operator|*
name|p1
operator|++
operator|=
name|truncate
expr_stmt|;
block|}
name|line
operator|->
name|length
operator|=
name|max
argument_list|(
name|line
operator|->
name|length
argument_list|,
name|p1
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|line
operator|->
name|body
argument_list|)
expr_stmt|;
name|line
operator|->
name|body
index|[
name|line
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p1
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|line
operator|->
name|body
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_xdisp
argument_list|()
end_macro

begin_block
block|{
name|DefLispVar
argument_list|(
literal|"global-mode-string"
argument_list|,
operator|&
name|Vglobal_mode_string
argument_list|,
literal|"String which mode line can display (if its format requests to)."
argument_list|)
expr_stmt|;
name|Vglobal_mode_string
operator|=
name|Qnil
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"global-minor-modes"
argument_list|,
operator|&
name|Vglobal_minor_modes
argument_list|,
literal|"Alist of minor modes that are not per buffer.\n\ Cdr of each element is a string to display in mode line."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"scroll-step"
argument_list|,
operator|&
name|scroll_step
argument_list|,
literal|"*The number of lines to try scrolling a window by when point moves out.\n\ If that fails to bring point back on screen, point is centered instead.\n\ If this is zero, point is always centered after it moves off screen."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"debug-end-pos"
argument_list|,
operator|&
name|debug_end_pos
argument_list|,
literal|"Don't ask"
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"truncate-partial-width-windows"
argument_list|,
operator|&
name|truncate_partial_width_windows
argument_list|,
literal|"*Non-nil means truncate lines in all windows less than full screen wide."
argument_list|)
expr_stmt|;
name|truncate_partial_width_windows
operator|=
literal|1
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"mode-line-inverse-video"
argument_list|,
operator|&
name|mode_line_inverse_video
argument_list|,
literal|"*Non-nil means use inverse video, or other suitable display mode, for the mode line."
argument_list|)
expr_stmt|;
name|mode_line_inverse_video
operator|=
literal|1
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sredraw_display
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* initialize the window system */
end_comment

begin_macro
name|init_xdisp
argument_list|()
end_macro

begin_block
block|{
name|Lisp_Object
name|root_window
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILER_REGISTER_BUG
specifier|register
endif|#
directive|endif
endif|COMPILER_REGISTER_BUG
name|struct
name|window
modifier|*
name|mini_w
decl_stmt|;
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
name|mini_w
operator|=
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
expr_stmt|;
name|root_window
operator|=
name|mini_w
operator|->
name|prev
expr_stmt|;
name|minibuf_message
operator|=
literal|0
expr_stmt|;
name|prev_minibuf_message
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|noninteractive
condition|)
block|{
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|root_window
argument_list|)
operator|->
name|top
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_window_height
argument_list|(
name|root_window
argument_list|,
name|screen_height
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|mini_w
operator|->
name|top
argument_list|)
operator|=
name|screen_height
operator|-
literal|1
expr_stmt|;
name|set_window_height
argument_list|(
name|minibuf_window
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|root_window
argument_list|)
operator|->
name|width
argument_list|)
operator|=
name|screen_width
expr_stmt|;
name|XFASTINT
argument_list|(
name|mini_w
operator|->
name|width
argument_list|)
operator|=
name|screen_width
expr_stmt|;
block|}
block|}
end_block

end_unit

