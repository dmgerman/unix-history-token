begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Execution of byte code produced by bytecomp.el.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_decl_stmt
name|Lisp_Object
name|Qbytecode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Byte codes: */
end_comment

begin_define
define|#
directive|define
name|Bvarref
value|010
end_define

begin_define
define|#
directive|define
name|Bvarset
value|020
end_define

begin_define
define|#
directive|define
name|Bvarbind
value|030
end_define

begin_define
define|#
directive|define
name|Bcall
value|040
end_define

begin_define
define|#
directive|define
name|Bunbind
value|050
end_define

begin_define
define|#
directive|define
name|Bnth
value|070
end_define

begin_define
define|#
directive|define
name|Bsymbolp
value|071
end_define

begin_define
define|#
directive|define
name|Bconsp
value|072
end_define

begin_define
define|#
directive|define
name|Bstringp
value|073
end_define

begin_define
define|#
directive|define
name|Blistp
value|074
end_define

begin_define
define|#
directive|define
name|Beq
value|075
end_define

begin_define
define|#
directive|define
name|Bmemq
value|076
end_define

begin_define
define|#
directive|define
name|Bnot
value|077
end_define

begin_define
define|#
directive|define
name|Bcar
value|0100
end_define

begin_define
define|#
directive|define
name|Bcdr
value|0101
end_define

begin_define
define|#
directive|define
name|Bcons
value|0102
end_define

begin_define
define|#
directive|define
name|Blist1
value|0103
end_define

begin_define
define|#
directive|define
name|Blist2
value|0104
end_define

begin_define
define|#
directive|define
name|Blist3
value|0105
end_define

begin_define
define|#
directive|define
name|Blist4
value|0106
end_define

begin_define
define|#
directive|define
name|Blength
value|0107
end_define

begin_define
define|#
directive|define
name|Baref
value|0110
end_define

begin_define
define|#
directive|define
name|Baset
value|0111
end_define

begin_define
define|#
directive|define
name|Bsymbol_value
value|0112
end_define

begin_define
define|#
directive|define
name|Bsymbol_function
value|0113
end_define

begin_define
define|#
directive|define
name|Bset
value|0114
end_define

begin_define
define|#
directive|define
name|Bfset
value|0115
end_define

begin_define
define|#
directive|define
name|Bget
value|0116
end_define

begin_define
define|#
directive|define
name|Bsubstring
value|0117
end_define

begin_define
define|#
directive|define
name|Bconcat2
value|0120
end_define

begin_define
define|#
directive|define
name|Bconcat3
value|0121
end_define

begin_define
define|#
directive|define
name|Bconcat4
value|0122
end_define

begin_define
define|#
directive|define
name|Bsub1
value|0123
end_define

begin_define
define|#
directive|define
name|Badd1
value|0124
end_define

begin_define
define|#
directive|define
name|Beqlsign
value|0125
end_define

begin_define
define|#
directive|define
name|Bgtr
value|0126
end_define

begin_define
define|#
directive|define
name|Blss
value|0127
end_define

begin_define
define|#
directive|define
name|Bleq
value|0130
end_define

begin_define
define|#
directive|define
name|Bgeq
value|0131
end_define

begin_define
define|#
directive|define
name|Bdiff
value|0132
end_define

begin_define
define|#
directive|define
name|Bnegate
value|0133
end_define

begin_define
define|#
directive|define
name|Bplus
value|0134
end_define

begin_define
define|#
directive|define
name|Bmax
value|0135
end_define

begin_define
define|#
directive|define
name|Bmin
value|0136
end_define

begin_define
define|#
directive|define
name|Bpoint
value|0140
end_define

begin_define
define|#
directive|define
name|Bmark
value|0141
end_define

begin_define
define|#
directive|define
name|Bgoto_char
value|0142
end_define

begin_define
define|#
directive|define
name|Binsert
value|0143
end_define

begin_define
define|#
directive|define
name|Bpoint_max
value|0144
end_define

begin_define
define|#
directive|define
name|Bpoint_min
value|0145
end_define

begin_define
define|#
directive|define
name|Bchar_after
value|0146
end_define

begin_define
define|#
directive|define
name|Bfollowing_char
value|0147
end_define

begin_define
define|#
directive|define
name|Bpreceding_char
value|0150
end_define

begin_define
define|#
directive|define
name|Bcurrent_column
value|0151
end_define

begin_define
define|#
directive|define
name|Bindent_to
value|0152
end_define

begin_define
define|#
directive|define
name|Bscan_buffer
value|0153
end_define

begin_define
define|#
directive|define
name|Beolp
value|0154
end_define

begin_define
define|#
directive|define
name|Beobp
value|0155
end_define

begin_define
define|#
directive|define
name|Bbolp
value|0156
end_define

begin_define
define|#
directive|define
name|Bbobp
value|0157
end_define

begin_define
define|#
directive|define
name|Bcurrent_buffer
value|0160
end_define

begin_define
define|#
directive|define
name|Bset_buffer
value|0161
end_define

begin_define
define|#
directive|define
name|Bread_char
value|0162
end_define

begin_define
define|#
directive|define
name|Bset_mark
value|0163
end_define

begin_define
define|#
directive|define
name|Binteractive_p
value|0164
end_define

begin_comment
comment|/* Needed since interactive-p takes unevalled args */
end_comment

begin_define
define|#
directive|define
name|Bconstant2
value|0201
end_define

begin_define
define|#
directive|define
name|Bgoto
value|0202
end_define

begin_define
define|#
directive|define
name|Bgotoifnil
value|0203
end_define

begin_define
define|#
directive|define
name|Bgotoifnonnil
value|0204
end_define

begin_define
define|#
directive|define
name|Bgotoifnilelsepop
value|0205
end_define

begin_define
define|#
directive|define
name|Bgotoifnonnilelsepop
value|0206
end_define

begin_define
define|#
directive|define
name|Breturn
value|0207
end_define

begin_define
define|#
directive|define
name|Bdiscard
value|0210
end_define

begin_define
define|#
directive|define
name|Bdup
value|0211
end_define

begin_define
define|#
directive|define
name|Bsave_excursion
value|0212
end_define

begin_define
define|#
directive|define
name|Bsave_window_excursion
value|0213
end_define

begin_define
define|#
directive|define
name|Bsave_restriction
value|0214
end_define

begin_define
define|#
directive|define
name|Bcatch
value|0215
end_define

begin_define
define|#
directive|define
name|Bunwind_protect
value|0216
end_define

begin_define
define|#
directive|define
name|Bcondition_case
value|0217
end_define

begin_define
define|#
directive|define
name|Btemp_output_buffer_setup
value|0220
end_define

begin_define
define|#
directive|define
name|Btemp_output_buffer_show
value|0221
end_define

begin_define
define|#
directive|define
name|Bconstant
value|0300
end_define

begin_define
define|#
directive|define
name|CONSTANTLIM
value|0100
end_define

begin_escape
end_escape

begin_comment
comment|/* Fetch the next byte from the bytecode stream */
end_comment

begin_define
define|#
directive|define
name|FETCH
value|((unsigned char *)XSTRING (bytestr)->data)[pc++]
end_define

begin_comment
comment|/* Fetch two bytes from the bytecode stream  and make a 16-bit number out of them */
end_comment

begin_define
define|#
directive|define
name|FETCH2
value|(op = FETCH, op + (FETCH<< 8))
end_define

begin_comment
comment|/* Push x onto the execution stack. */
end_comment

begin_define
define|#
directive|define
name|PUSH
parameter_list|(
name|x
parameter_list|)
value|(*++stackp = (x))
end_define

begin_comment
comment|/* Pop a value off the execution stack.  */
end_comment

begin_define
define|#
directive|define
name|POP
value|(*stackp--)
end_define

begin_comment
comment|/* Discard n values from the execution stack.  */
end_comment

begin_define
define|#
directive|define
name|DISCARD
parameter_list|(
name|n
parameter_list|)
value|(stackp -= (n))
end_define

begin_comment
comment|/* Get the value which is at the top of the execution stack, but don't pop it. */
end_comment

begin_define
define|#
directive|define
name|TOP
value|(*stackp)
end_define

begin_macro
name|DEFUN
argument_list|(
literal|"byte-code"
argument_list|,
argument|Fbyte_code
argument_list|,
argument|Sbyte_code
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bytestr
operator|,
name|vector
operator|,
name|maxdepth
operator|)
name|Lisp_Object
name|bytestr
operator|,
name|vector
operator|,
name|maxdepth
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|int
name|pc
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|op
decl_stmt|;
name|Lisp_Object
modifier|*
name|stack
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|stackp
decl_stmt|;
name|Lisp_Object
modifier|*
name|stacke
decl_stmt|;
specifier|register
name|Lisp_Object
name|v1
decl_stmt|,
name|v2
decl_stmt|;
name|Lisp_Object
modifier|*
name|vectorp
init|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|bytestr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|!=
name|Lisp_Vector
condition|)
name|vector
operator|=
name|wrong_type_argument
argument_list|(
name|Qvectorp
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|maxdepth
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stackp
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|XFASTINT
argument_list|(
name|maxdepth
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|stackp
argument_list|,
name|XFASTINT
argument_list|(
name|maxdepth
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|GCPRO3
argument_list|(
name|bytestr
argument_list|,
name|vector
argument_list|,
operator|*
name|stackp
argument_list|)
expr_stmt|;
name|gcpro3
operator|.
name|nvars
operator|=
name|XFASTINT
argument_list|(
name|maxdepth
argument_list|)
expr_stmt|;
operator|--
name|stackp
expr_stmt|;
name|stack
operator|=
name|stackp
expr_stmt|;
name|stacke
operator|=
name|stackp
operator|+
name|XFASTINT
argument_list|(
name|maxdepth
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|stackp
operator|>
name|stacke
condition|)
name|error
argument_list|(
literal|"Stack overflow in byte code (byte compiler bug!)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackp
operator|<
name|stack
condition|)
name|error
argument_list|(
literal|"Stack underflow in byte code (byte compiler bug!)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|=
name|FETCH
condition|)
block|{
case|case
name|Bvarref
case|:
case|case
name|Bvarref
operator|+
literal|1
case|:
case|case
name|Bvarref
operator|+
literal|2
case|:
case|case
name|Bvarref
operator|+
literal|3
case|:
case|case
name|Bvarref
operator|+
literal|4
case|:
case|case
name|Bvarref
operator|+
literal|5
case|:
name|PUSH
argument_list|(
name|Fsymbol_value
argument_list|(
name|vectorp
index|[
name|op
operator|-
name|Bvarref
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarref
operator|+
literal|6
case|:
name|PUSH
argument_list|(
name|Fsymbol_value
argument_list|(
name|vectorp
index|[
name|FETCH
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarref
operator|+
literal|7
case|:
name|PUSH
argument_list|(
name|Fsymbol_value
argument_list|(
name|vectorp
index|[
name|FETCH2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarset
case|:
case|case
name|Bvarset
operator|+
literal|1
case|:
case|case
name|Bvarset
operator|+
literal|2
case|:
case|case
name|Bvarset
operator|+
literal|3
case|:
case|case
name|Bvarset
operator|+
literal|4
case|:
case|case
name|Bvarset
operator|+
literal|5
case|:
name|Fset
argument_list|(
name|vectorp
index|[
name|op
operator|-
name|Bvarset
index|]
argument_list|,
name|POP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarset
operator|+
literal|6
case|:
name|Fset
argument_list|(
name|vectorp
index|[
name|FETCH
index|]
argument_list|,
name|POP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarset
operator|+
literal|7
case|:
name|Fset
argument_list|(
name|vectorp
index|[
name|FETCH2
index|]
argument_list|,
name|POP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarbind
case|:
case|case
name|Bvarbind
operator|+
literal|1
case|:
case|case
name|Bvarbind
operator|+
literal|2
case|:
case|case
name|Bvarbind
operator|+
literal|3
case|:
case|case
name|Bvarbind
operator|+
literal|4
case|:
case|case
name|Bvarbind
operator|+
literal|5
case|:
name|specbind
argument_list|(
name|vectorp
index|[
name|op
operator|-
name|Bvarbind
index|]
argument_list|,
name|POP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarbind
operator|+
literal|6
case|:
name|specbind
argument_list|(
name|vectorp
index|[
name|FETCH
index|]
argument_list|,
name|POP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bvarbind
operator|+
literal|7
case|:
name|specbind
argument_list|(
name|vectorp
index|[
name|FETCH2
index|]
argument_list|,
name|POP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bcall
case|:
case|case
name|Bcall
operator|+
literal|1
case|:
case|case
name|Bcall
operator|+
literal|2
case|:
case|case
name|Bcall
operator|+
literal|3
case|:
case|case
name|Bcall
operator|+
literal|4
case|:
case|case
name|Bcall
operator|+
literal|5
case|:
name|op
operator|-=
name|Bcall
expr_stmt|;
name|docall
label|:
name|DISCARD
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|gcpro3
operator|.
name|nvars
operator|=
operator|&
name|TOP
operator|-
name|stack
expr_stmt|;
name|TOP
operator|=
name|Ffuncall
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
name|gcpro3
operator|.
name|nvars
operator|=
name|XFASTINT
argument_list|(
name|maxdepth
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bcall
operator|+
literal|6
case|:
name|op
operator|=
name|FETCH
expr_stmt|;
goto|goto
name|docall
goto|;
case|case
name|Bcall
operator|+
literal|7
case|:
name|op
operator|=
name|FETCH2
expr_stmt|;
goto|goto
name|docall
goto|;
case|case
name|Bunbind
case|:
case|case
name|Bunbind
operator|+
literal|1
case|:
case|case
name|Bunbind
operator|+
literal|2
case|:
case|case
name|Bunbind
operator|+
literal|3
case|:
case|case
name|Bunbind
operator|+
literal|4
case|:
case|case
name|Bunbind
operator|+
literal|5
case|:
name|unbind_to
argument_list|(
name|specpdl_ptr
operator|-
name|specpdl
operator|-
operator|(
name|op
operator|-
name|Bunbind
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bunbind
operator|+
literal|6
case|:
name|unbind_to
argument_list|(
name|specpdl_ptr
operator|-
name|specpdl
operator|-
name|FETCH
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bunbind
operator|+
literal|7
case|:
name|unbind_to
argument_list|(
name|specpdl_ptr
operator|-
name|specpdl
operator|-
name|FETCH2
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bgoto
case|:
name|QUIT
expr_stmt|;
name|op
operator|=
name|FETCH2
expr_stmt|;
comment|/* pc = FETCH2 loses since FETCH2 contains pc++ */
name|pc
operator|=
name|op
expr_stmt|;
break|break;
case|case
name|Bgotoifnil
case|:
name|QUIT
expr_stmt|;
name|op
operator|=
name|FETCH2
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|POP
argument_list|)
condition|)
name|pc
operator|=
name|op
expr_stmt|;
break|break;
case|case
name|Bgotoifnonnil
case|:
name|QUIT
expr_stmt|;
name|op
operator|=
name|FETCH2
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|POP
argument_list|)
condition|)
name|pc
operator|=
name|op
expr_stmt|;
break|break;
case|case
name|Bgotoifnilelsepop
case|:
name|QUIT
expr_stmt|;
name|op
operator|=
name|FETCH2
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|TOP
argument_list|)
condition|)
name|pc
operator|=
name|op
expr_stmt|;
else|else
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bgotoifnonnilelsepop
case|:
name|QUIT
expr_stmt|;
name|op
operator|=
name|FETCH2
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|TOP
argument_list|)
condition|)
name|pc
operator|=
name|op
expr_stmt|;
else|else
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Breturn
case|:
name|v1
operator|=
name|POP
expr_stmt|;
goto|goto
name|exit
goto|;
case|case
name|Bdiscard
case|:
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bdup
case|:
name|v1
operator|=
name|TOP
expr_stmt|;
name|PUSH
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bconstant2
case|:
name|PUSH
argument_list|(
name|vectorp
index|[
name|FETCH2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bsave_excursion
case|:
name|record_unwind_protect
argument_list|(
name|save_excursion_restore
argument_list|,
name|save_excursion_save
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bsave_window_excursion
case|:
name|TOP
operator|=
name|Fsave_window_excursion
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bsave_restriction
case|:
name|record_unwind_protect
argument_list|(
name|save_restriction_restore
argument_list|,
name|save_restriction_save
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bcatch
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|internal_catch
argument_list|(
name|TOP
argument_list|,
name|Feval
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bunwind_protect
case|:
name|record_unwind_protect
argument_list|(
literal|0
argument_list|,
name|POP
argument_list|)
expr_stmt|;
operator|(
name|specpdl_ptr
operator|-
literal|1
operator|)
operator|->
name|symbol
operator|=
name|Qnil
expr_stmt|;
break|break;
case|case
name|Bcondition_case
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|v1
operator|=
name|Fcons
argument_list|(
name|POP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fcondition_case
argument_list|(
name|Fcons
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Btemp_output_buffer_setup
case|:
name|temp_output_buffer_setup
argument_list|(
name|XSTRING
argument_list|(
name|TOP
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Vstandard_output
expr_stmt|;
break|break;
case|case
name|Btemp_output_buffer_show
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|temp_output_buffer_show
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|v1
expr_stmt|;
break|break;
case|case
name|Bnth
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|v2
operator|=
name|TOP
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|v2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|XINT
argument_list|(
name|v2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|op
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|LISTP
argument_list|(
name|v1
argument_list|)
condition|)
name|v1
operator|=
name|XCONS
argument_list|(
name|v1
argument_list|)
operator|->
name|cdr
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|v1
argument_list|)
condition|)
block|{
name|v1
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|op
operator|++
expr_stmt|;
block|}
block|}
goto|goto
name|docar
goto|;
case|case
name|Bsymbolp
case|:
name|TOP
operator|=
name|XTYPE
argument_list|(
name|TOP
argument_list|)
operator|==
name|Lisp_Symbol
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
break|break;
case|case
name|Bconsp
case|:
name|TOP
operator|=
name|LISTP
argument_list|(
name|TOP
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
break|break;
case|case
name|Bstringp
case|:
name|TOP
operator|=
name|XTYPE
argument_list|(
name|TOP
argument_list|)
operator|==
name|Lisp_String
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
break|break;
case|case
name|Blistp
case|:
name|TOP
operator|=
name|LISTP
argument_list|(
name|TOP
argument_list|)
operator|||
name|NULL
argument_list|(
name|TOP
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
break|break;
case|case
name|Beq
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|EQ
argument_list|(
name|v1
argument_list|,
name|TOP
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
break|break;
case|case
name|Bmemq
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fmemq
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bnot
case|:
name|TOP
operator|=
name|NULL
argument_list|(
name|TOP
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
break|break;
case|case
name|Bcar
case|:
name|v1
operator|=
name|TOP
expr_stmt|;
name|docar
label|:
if|if
condition|(
name|LISTP
argument_list|(
name|v1
argument_list|)
condition|)
name|TOP
operator|=
name|XCONS
argument_list|(
name|v1
argument_list|)
operator|->
name|car
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|v1
argument_list|)
condition|)
name|TOP
operator|=
name|Qnil
expr_stmt|;
else|else
name|Fcar
argument_list|(
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|v1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bcdr
case|:
name|v1
operator|=
name|TOP
expr_stmt|;
if|if
condition|(
name|LISTP
argument_list|(
name|v1
argument_list|)
condition|)
name|TOP
operator|=
name|XCONS
argument_list|(
name|v1
argument_list|)
operator|->
name|cdr
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|v1
argument_list|)
condition|)
name|TOP
operator|=
name|Qnil
expr_stmt|;
else|else
name|Fcdr
argument_list|(
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|v1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bcons
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fcons
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Blist1
case|:
name|TOP
operator|=
name|Fcons
argument_list|(
name|TOP
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
name|Blist2
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fcons
argument_list|(
name|TOP
argument_list|,
name|Fcons
argument_list|(
name|v1
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Blist3
case|:
name|DISCARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Flist
argument_list|(
literal|3
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Blist4
case|:
name|DISCARD
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Flist
argument_list|(
literal|4
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Blength
case|:
name|TOP
operator|=
name|Flength
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Baref
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Faref
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Baset
case|:
name|v2
operator|=
name|POP
expr_stmt|;
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Faset
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bsymbol_value
case|:
name|TOP
operator|=
name|Fsymbol_value
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bsymbol_function
case|:
name|TOP
operator|=
name|Fsymbol_function
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bset
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fset
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bfset
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Ffset
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bget
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fget
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bsubstring
case|:
name|v2
operator|=
name|POP
expr_stmt|;
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fsubstring
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bconcat2
case|:
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fconcat
argument_list|(
literal|2
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bconcat3
case|:
name|DISCARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fconcat
argument_list|(
literal|3
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bconcat4
case|:
name|DISCARD
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fconcat
argument_list|(
literal|4
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bsub1
case|:
name|v1
operator|=
name|TOP
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|v1
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|XSETINT
argument_list|(
name|v1
argument_list|,
name|XINT
argument_list|(
name|v1
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|v1
expr_stmt|;
block|}
else|else
name|TOP
operator|=
name|Fsub1
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Badd1
case|:
name|v1
operator|=
name|TOP
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|v1
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|XSETINT
argument_list|(
name|v1
argument_list|,
name|XINT
argument_list|(
name|v1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|v1
expr_stmt|;
block|}
else|else
name|TOP
operator|=
name|Fadd1
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Beqlsign
case|:
name|v2
operator|=
name|POP
expr_stmt|;
name|v1
operator|=
name|TOP
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|v1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|v2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|XINT
argument_list|(
name|v1
argument_list|)
operator|==
name|XINT
argument_list|(
name|v2
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
break|break;
case|case
name|Bgtr
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fgtr
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Blss
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Flss
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bleq
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fleq
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bgeq
case|:
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fgeq
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bdiff
case|:
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fminus
argument_list|(
literal|2
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bnegate
case|:
name|v1
operator|=
name|TOP
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|v1
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|XSETINT
argument_list|(
name|v1
argument_list|,
operator|-
name|XINT
argument_list|(
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|v1
expr_stmt|;
block|}
else|else
name|TOP
operator|=
name|Fminus
argument_list|(
literal|1
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bplus
case|:
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fplus
argument_list|(
literal|2
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bmax
case|:
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fmax
argument_list|(
literal|2
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bmin
case|:
name|DISCARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TOP
operator|=
name|Fmin
argument_list|(
literal|2
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bpoint
case|:
name|XFASTINT
argument_list|(
name|v1
argument_list|)
operator|=
name|point
expr_stmt|;
name|PUSH
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bmark
case|:
name|PUSH
argument_list|(
name|Fmark
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bgoto_char
case|:
name|TOP
operator|=
name|Fgoto_char
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Binsert
case|:
name|TOP
operator|=
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bpoint_max
case|:
name|XFASTINT
argument_list|(
name|v1
argument_list|)
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
name|PUSH
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bpoint_min
case|:
name|XFASTINT
argument_list|(
name|v1
argument_list|)
operator|=
name|FirstCharacter
expr_stmt|;
name|PUSH
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bchar_after
case|:
name|TOP
operator|=
name|Fchar_after
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bfollowing_char
case|:
name|XFASTINT
argument_list|(
name|v1
argument_list|)
operator|=
name|point
operator|>
name|NumCharacters
condition|?
literal|0
else|:
name|CharAt
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bpreceding_char
case|:
name|XFASTINT
argument_list|(
name|v1
argument_list|)
operator|=
name|point
operator|<=
name|FirstCharacter
condition|?
literal|0
else|:
name|CharAt
argument_list|(
name|point
operator|-
literal|1
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bcurrent_column
case|:
name|XFASTINT
argument_list|(
name|v1
argument_list|)
operator|=
name|current_column
argument_list|()
expr_stmt|;
name|PUSH
argument_list|(
name|v1
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bindent_to
case|:
name|TOP
operator|=
name|Findent_to
argument_list|(
name|TOP
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bscan_buffer
case|:
name|v2
operator|=
name|POP
expr_stmt|;
name|v1
operator|=
name|POP
expr_stmt|;
name|TOP
operator|=
name|Fscan_buffer
argument_list|(
name|TOP
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
case|case
name|Beolp
case|:
name|PUSH
argument_list|(
name|Feolp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Beobp
case|:
name|PUSH
argument_list|(
name|Feobp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bbolp
case|:
name|PUSH
argument_list|(
name|Fbolp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bbobp
case|:
name|PUSH
argument_list|(
name|Fbobp
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bcurrent_buffer
case|:
name|PUSH
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bset_buffer
case|:
name|TOP
operator|=
name|Fset_buffer
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bread_char
case|:
name|PUSH
argument_list|(
name|Fread_char
argument_list|()
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
break|break;
case|case
name|Bset_mark
case|:
name|TOP
operator|=
name|Fset_mark
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|Binteractive_p
case|:
name|PUSH
argument_list|(
name|Finteractive_p
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|op
operator|-=
name|Bconstant
operator|)
operator|<
operator|(
name|unsigned
operator|)
name|CONSTANTLIM
condition|)
name|PUSH
argument_list|(
name|vectorp
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
label|:
name|UNGCPRO
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|v1
return|;
block|}
end_block

begin_macro
name|syms_of_bytecode
argument_list|()
end_macro

begin_block
block|{
name|Qbytecode
operator|=
name|intern
argument_list|(
literal|"byte-code"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qbytecode
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbyte_code
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

