begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1985 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/*   * unexec.c - Convert a running program into an a.out file.  *   * Author:	Spencer W. Thomas  * 		Computer Science Dept.  * 		University of Utah  * Date:	Tue Mar  2 1982  * Modified heavily since then.  *  * Synopsis:  *	unexec (new_name, a_name, data_start, bss_start, entry_address)  *	char *new_name, *a_name;  *	unsigned data_start, bss_start, entry_address;  *  * Takes a snapshot of the program and makes an a.out format file in the  * file named by the string argument new_name.  * If a_name is non-NULL, the symbol table will be taken from the given file.  *   * The boundaries within the a.out file may be adjusted with the data_start   * and bss_start arguments.  Either or both may be given as 0 for defaults.  *   * Data_start gives the boundary between the text segment and the data  * segment of the program.  The text segment can contain shared, read-only  * program code and literal data, while the data segment is always unshared  * and unprotected.  Data_start gives the lowest unprotected address.  Since  * the granularity of write-protection is on 1k page boundaries on the VAX, a  * given data_start value which is not on a page boundary is rounded down to  * the beginning of the page it is on.  The default when 0 is given leaves the  * number of protected pages the same as it was before.  *   * Bss_start indicates how much of the data segment is to be saved in the  * a.out file and restored when the program is executed.  It gives the lowest  * unsaved address, and is rounded up to a page boundary.  The default when 0  * is given assumes that the entire data segment is to be stored, including  * the previous data and bss as well as any additional storage allocated with  * break (2).  *  * The new file is set up to start at entry_address.  *  * If you make improvements I'd like to get them too.  * harpo!utah-cs!thomas, thomas@Utah-20  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|arg
parameter_list|)
value|perror (arg); return -1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|file
parameter_list|)
value|report_error (file, new)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_comment
comment|/* all rest of file!  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|makedev
end_ifndef

begin_comment
comment|/* Try to detect types.h already loaded */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_text
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of text */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_data
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of initialized data */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF
end_ifdef

begin_include
include|#
directive|include
file|<filehdr.h>
end_include

begin_include
include|#
directive|include
file|<aouthdr.h>
end_include

begin_include
include|#
directive|include
file|<scnhdr.h>
end_include

begin_include
include|#
directive|include
file|<syms.h>
end_include

begin_decl_stmt
specifier|static
name|long
name|block_copy_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Old executable start point */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filehdr
name|f_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File header */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|aouthdr
name|f_ohdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optional file header (a.out) */
end_comment

begin_decl_stmt
name|long
name|bias
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bias to add for growth */
end_comment

begin_decl_stmt
name|long
name|lnnoptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to line-number info within file */
end_comment

begin_define
define|#
directive|define
name|SYMS_START
value|block_copy_start
end_define

begin_decl_stmt
specifier|static
name|int
name|text_scnptr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not COFF */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_define
define|#
directive|define
name|SYMS_START
value|((long) N_SYMOFF (ohdr))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|hp9000s200
end_ifdef

begin_define
define|#
directive|define
name|MY_ID
value|HP9000S200_ID
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<model.h>
end_include

begin_define
define|#
directive|define
name|MY_ID
value|MYSYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not hp9000s200 */
end_comment

begin_decl_stmt
specifier|static
name|MAGIC
name|OLDMAGIC
init|=
block|{
name|MY_ID
block|,
name|SHARE_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MAGIC
name|NEWMAGIC
init|=
block|{
name|MY_ID
block|,
name|DEMAND_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_TXTOFF
parameter_list|(
name|x
parameter_list|)
value|TEXT_OFFSET(x)
end_define

begin_define
define|#
directive|define
name|N_SYMOFF
parameter_list|(
name|x
parameter_list|)
value|LESYM_OFFSET(x)
end_define

begin_decl_stmt
specifier|static
name|struct
name|exec
name|hdr
decl_stmt|,
name|ohdr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HPUX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|bhdr
name|hdr
decl_stmt|,
name|ohdr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|a_magic
value|fmagic
end_define

begin_define
define|#
directive|define
name|a_text
value|tsize
end_define

begin_define
define|#
directive|define
name|a_data
value|dsize
end_define

begin_define
define|#
directive|define
name|a_bss
value|bsize
end_define

begin_define
define|#
directive|define
name|a_syms
value|ssize
end_define

begin_define
define|#
directive|define
name|a_trsize
value|rtsize
end_define

begin_define
define|#
directive|define
name|a_drsize
value|rdsize
end_define

begin_define
define|#
directive|define
name|a_entry
value|entry
end_define

begin_define
define|#
directive|define
name|N_BADMAG
parameter_list|(
name|x
parameter_list|)
define|\
value|(((x).fmagic)!=OMAGIC&& ((x).fmagic)!=NMAGIC&&\      ((x).fmagic)!=FMAGIC&& ((x).fmagic)!=IMAGIC)
end_define

begin_define
define|#
directive|define
name|NEWMAGIC
value|FMAGIC
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|exec
name|hdr
decl_stmt|,
name|ohdr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEWMAGIC
value|ZMAGIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HPUX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not COFF */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pagemask
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD4_1
argument_list|)
operator|||
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|EXEC_PAGESIZE
end_ifdef

begin_define
define|#
directive|define
name|getpagesize
parameter_list|()
value|EXEC_PAGESIZE
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NBPG
end_ifdef

begin_define
define|#
directive|define
name|getpagesize
parameter_list|()
value|NBPG * CLSIZE
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CLSIZE
end_ifndef

begin_define
define|#
directive|define
name|CLSIZE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no CLSIZE */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no NBPG */
end_comment

begin_define
define|#
directive|define
name|getpagesize
parameter_list|()
value|NBPC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no NBPG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no EXEC_PAGESIZE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_1 or USG */
end_comment

begin_comment
comment|/* Correct an int which is the bit pattern of a pointer to a byte    into an int which is the number of a byte.    This is a no-op on ordinary machines, but not on all.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ADDR_CORRECT
end_ifndef

begin_comment
comment|/* Let m-*.h files override this definition */
end_comment

begin_define
define|#
directive|define
name|ADDR_CORRECT
parameter_list|(
name|x
parameter_list|)
value|((char *)(x) - (char*)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_expr_stmt
specifier|static
name|report_error
argument_list|(
argument|file
argument_list|,
argument|fd
argument_list|)
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Failure operating on %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_define
define|#
directive|define
name|ERROR0
parameter_list|(
name|msg
parameter_list|)
value|report_error_1 (new, msg, 0, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR1
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|)
value|report_error_1 (new, msg, x, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR2
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|report_error_1 (new, msg, x, y); return -1
end_define

begin_expr_stmt
specifier|static
name|report_error_1
argument_list|(
argument|fd
argument_list|,
argument|msg
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|emacs
name|error
argument_list|(
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * unexec  *  * driving logic.  */
end_comment

begin_macro
name|unexec
argument_list|(
argument|new_name
argument_list|,
argument|a_name
argument_list|,
argument|data_start
argument_list|,
argument|bss_start
argument_list|,
argument|entry_address
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|,
modifier|*
name|a_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|new
decl_stmt|,
name|a_out
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|a_name
operator|&&
operator|(
name|a_out
operator|=
name|open
argument_list|(
name|a_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new
operator|=
name|creat
argument_list|(
name|new_name
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|make_hdr
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|,
name|entry_address
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
operator|||
name|copy_text_and_data
argument_list|(
name|new
argument_list|)
operator|<
literal|0
operator|||
name|copy_sym
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
ifdef|#
directive|ifdef
name|COFF
operator|||
name|adjust_lnnoptrs
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
endif|#
directive|endif
condition|)
block|{
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* unlink (new_name);	    	/* Failed, unlink new a.out */
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|a_out
argument_list|)
expr_stmt|;
name|mark_x
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ****************************************************************  * make_hdr  *  * Make the header in the new a.out from the header in core.  * Modify the text and data sizes.  */
end_comment

begin_function
specifier|static
name|int
name|make_hdr
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|data_start
parameter_list|,
name|bss_start
parameter_list|,
name|entry_address
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
block|{
name|int
name|tem
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF
specifier|auto
type|struct
name|scnhdr
name|f_thdr
decl_stmt|;
comment|/* Text section header */
specifier|auto
type|struct
name|scnhdr
name|f_dhdr
decl_stmt|;
comment|/* Data section header */
specifier|auto
type|struct
name|scnhdr
name|f_bhdr
decl_stmt|;
comment|/* Bss section header */
specifier|auto
type|struct
name|scnhdr
name|scntemp
decl_stmt|;
comment|/* Temporary section header */
specifier|register
name|int
name|scns
decl_stmt|;
comment|/* Salvage as much info from the existing file as possible */
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_hdr
operator|.
name|f_opthdr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
expr_stmt|;
block|}
comment|/* Loop through section headers, copying them in */
for|for
control|(
name|scns
operator|=
name|f_hdr
operator|.
name|f_nscns
init|;
name|scns
operator|>
literal|0
condition|;
name|scns
operator|--
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|scntemp
argument_list|,
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|scntemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scntemp
operator|.
name|s_scnptr
operator|>
literal|0L
condition|)
block|{
name|block_copy_start
operator|+=
name|scntemp
operator|.
name|s_size
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f_thdr
operator|=
name|scntemp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f_dhdr
operator|=
name|scntemp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|scntemp
operator|.
name|s_name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f_bhdr
operator|=
name|scntemp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ERROR0
argument_list|(
literal|"can't build a COFF file from scratch yet"
argument_list|)
expr_stmt|;
block|}
name|pagemask
operator|=
name|getpagesize
argument_list|()
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_REMAP
name|data_start
operator|=
operator|(
name|int
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not NO_REMAP */
if|if
condition|(
operator|!
name|data_start
condition|)
name|data_start
operator|=
operator|(
name|int
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_REMAP */
name|data_start
operator|=
name|ADDR_CORRECT
argument_list|(
name|data_start
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|data_start
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* down to a page boundary */
name|f_hdr
operator|.
name|f_flags
operator||=
operator|(
name|F_RELFLG
operator||
name|F_EXEC
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXEC_MAGIC
name|f_ohdr
operator|.
name|magic
operator|=
name|EXEC_MAGIC
expr_stmt|;
endif|#
directive|endif
name|f_ohdr
operator|.
name|text_start
operator|=
operator|(
name|long
operator|)
name|start_of_text
argument_list|()
expr_stmt|;
name|f_ohdr
operator|.
name|tsize
operator|=
name|data_start
operator|-
name|f_ohdr
operator|.
name|text_start
expr_stmt|;
name|f_ohdr
operator|.
name|data_start
operator|=
name|data_start
expr_stmt|;
name|f_ohdr
operator|.
name|dsize
operator|=
operator|(
name|long
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|-
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|f_ohdr
operator|.
name|bsize
operator|=
literal|0
expr_stmt|;
name|f_thdr
operator|.
name|s_size
operator|=
name|f_ohdr
operator|.
name|tsize
expr_stmt|;
name|f_thdr
operator|.
name|s_scnptr
operator|=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
expr_stmt|;
name|f_thdr
operator|.
name|s_scnptr
operator|+=
operator|(
name|f_hdr
operator|.
name|f_nscns
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
operator|)
expr_stmt|;
name|lnnoptr
operator|=
name|f_thdr
operator|.
name|s_lnnoptr
expr_stmt|;
ifdef|#
directive|ifdef
name|UMAX
comment|/* Umax is bsd using coff; it has restrictions on alignment      of the sections in the file itself.  */
name|f_thdr
operator|.
name|s_scnptr
operator|=
operator|(
name|f_thdr
operator|.
name|s_scnptr
operator|+
name|pagemask
operator|)
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* round up */
endif|#
directive|endif
comment|/* UMAX */
name|text_scnptr
operator|=
name|f_thdr
operator|.
name|s_scnptr
expr_stmt|;
name|f_dhdr
operator|.
name|s_paddr
operator|=
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|f_dhdr
operator|.
name|s_vaddr
operator|=
name|f_ohdr
operator|.
name|data_start
expr_stmt|;
name|f_dhdr
operator|.
name|s_size
operator|=
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_dhdr
operator|.
name|s_scnptr
operator|=
name|f_thdr
operator|.
name|s_scnptr
operator|+
name|f_thdr
operator|.
name|s_size
expr_stmt|;
ifdef|#
directive|ifdef
name|UMAX
name|f_dhdr
operator|.
name|s_scnptr
operator|&=
operator|~
name|pagemask
expr_stmt|;
comment|/* round down to page boundary */
endif|#
directive|endif
comment|/* UMAX */
name|f_bhdr
operator|.
name|s_paddr
operator|=
name|f_ohdr
operator|.
name|data_start
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_bhdr
operator|.
name|s_vaddr
operator|=
name|f_ohdr
operator|.
name|data_start
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_bhdr
operator|.
name|s_size
operator|=
name|f_ohdr
operator|.
name|bsize
expr_stmt|;
name|f_bhdr
operator|.
name|s_scnptr
operator|=
literal|0L
expr_stmt|;
name|bias
operator|=
name|f_dhdr
operator|.
name|s_scnptr
operator|+
name|f_dhdr
operator|.
name|s_size
operator|-
name|block_copy_start
expr_stmt|;
if|if
condition|(
name|f_hdr
operator|.
name|f_symptr
operator|>
literal|0L
condition|)
block|{
name|f_hdr
operator|.
name|f_symptr
operator|+=
name|bias
expr_stmt|;
block|}
if|if
condition|(
name|f_thdr
operator|.
name|s_lnnoptr
operator|>
literal|0L
condition|)
block|{
name|f_thdr
operator|.
name|s_lnnoptr
operator|+=
name|bias
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_thdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_thdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_dhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_dhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_dhdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_bhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_bhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_bhdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* if not COFF */
comment|/* Get symbol table info from header of a.out file if given one. */
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|ohdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
operator|!=
sizeof|sizeof
name|hdr
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if N_BADMAG
condition|(
name|ohdr
condition|)
block|{
name|ERROR1
argument_list|(
literal|"invalid magic number in %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|celerity
name|hdr
operator|.
name|a_scovrfl
operator|=
name|ohdr
operator|.
name|a_scovrfl
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HPUX
name|hdr
operator|.
name|a_lesyms
operator|=
name|ohdr
operator|.
name|a_lesyms
expr_stmt|;
name|hdr
operator|.
name|a_sltsize
operator|=
name|ohdr
operator|.
name|a_sltsize
expr_stmt|;
name|hdr
operator|.
name|a_dnttsize
operator|=
name|ohdr
operator|.
name|a_dnttsize
expr_stmt|;
name|hdr
operator|.
name|a_vtsize
operator|=
name|ohdr
operator|.
name|a_vtsize
expr_stmt|;
else|#
directive|else
comment|/* not HPUX */
name|hdr
operator|.
name|a_syms
operator|=
name|ohdr
operator|.
name|a_syms
expr_stmt|;
endif|#
directive|endif
comment|/* not HPUX */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|celerity
name|hdr
operator|.
name|a_scovrfl
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HPUX
name|hdr
operator|.
name|a_lesyms
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_sltsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_dnttsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_vtsize
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* not HPUX */
name|hdr
operator|.
name|a_syms
operator|=
literal|0
expr_stmt|;
comment|/* No a.out, so no symbol info. */
endif|#
directive|endif
comment|/* not HPUX */
block|}
comment|/* Construct header from user structure. */
ifdef|#
directive|ifdef
name|HPUX
comment|/* (((MAGIC) ohdr.a_magic) == ((MAGIC) OLDMAGIC)) This does not work */
name|hdr
operator|.
name|a_magic
operator|=
operator|(
operator|(
name|ohdr
operator|.
name|a_magic
operator|.
name|file_type
operator|==
name|OLDMAGIC
operator|.
name|file_type
operator|)
condition|?
name|NEWMAGIC
else|:
name|ohdr
operator|.
name|a_magic
operator|)
expr_stmt|;
else|#
directive|else
comment|/* not HPUX */
comment|/* hdr.a_magic = NEWMAGIC; */
name|hdr
operator|.
name|a_magic
operator|=
name|ohdr
operator|.
name|a_magic
expr_stmt|;
endif|#
directive|endif
comment|/* not HPUX */
ifdef|#
directive|ifdef
name|sun3
name|hdr
operator|.
name|a_machtype
operator|=
name|ohdr
operator|.
name|a_machtype
expr_stmt|;
endif|#
directive|endif
comment|/* sun3 */
name|hdr
operator|.
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_entry
operator|=
name|entry_address
expr_stmt|;
name|pagemask
operator|=
name|getpagesize
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/* Adjust data/bss boundary. */
if|if
condition|(
name|bss_start
operator|!=
literal|0
condition|)
block|{
name|bss_start
operator|=
operator|(
name|ADDR_CORRECT
argument_list|(
name|bss_start
argument_list|)
operator|+
name|pagemask
operator|)
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* (Up) to page bdry. */
if|if
condition|(
name|bss_start
operator|>
name|ADDR_CORRECT
argument_list|(
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|ERROR1
argument_list|(
literal|"unexec: Specified bss_start (%u) is past end of program"
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bss_start
operator|=
name|ADDR_CORRECT
argument_list|(
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bss_start
operator|=
operator|(
name|bss_start
operator|+
name|pagemask
operator|)
operator|&
operator|~
name|pagemask
expr_stmt|;
block|}
comment|/* Adjust text/data boundary. */
ifdef|#
directive|ifdef
name|NO_REMAP
name|data_start
operator|=
operator|(
name|int
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not NO_REMAP */
if|if
condition|(
operator|!
name|data_start
condition|)
name|data_start
operator|=
operator|(
name|int
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_REMAP */
name|data_start
operator|=
name|ADDR_CORRECT
argument_list|(
name|data_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
name|data_start
operator|=
name|data_start
operator|&
operator|~
operator|(
name|SEGSIZ
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* (Down) to segment boundary. */
else|#
directive|else
name|data_start
operator|=
name|data_start
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* (Down) to page boundary. */
endif|#
directive|endif
if|if
condition|(
name|data_start
operator|>
name|bss_start
condition|)
comment|/* Can't have negative data size. */
block|{
name|ERROR2
argument_list|(
literal|"unexec: data_start (%u) can't be greater than bss_start (%u)"
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|ADDR_CORRECT
argument_list|(
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|a_bss
operator|=
name|tem
operator|-
name|bss_start
expr_stmt|;
if|if
condition|(
name|tem
operator|<
name|bss_start
condition|)
comment|/* Note a_bss is unsigned on some systems */
name|hdr
operator|.
name|a_bss
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|a_data
operator|=
name|bss_start
operator|-
name|data_start
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sequent
argument_list|)
name|hdr
operator|.
name|a_text
operator|=
name|data_start
operator|-
operator|(
name|long
operator|)
name|start_of_text
argument_list|()
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
name|N_ADDRADJ
argument_list|(
name|ohdr
argument_list|)
expr_stmt|;
else|#
directive|else
name|hdr
operator|.
name|a_text
operator|=
name|data_start
operator|-
operator|(
name|long
operator|)
name|start_of_text
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not sequent */
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
operator|!=
sizeof|sizeof
name|hdr
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not COFF */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * copy_text_and_data  *  * Copy the text and data segments from memory to the new a.out  */
end_comment

begin_function
specifier|static
name|int
name|copy_text_and_data
parameter_list|(
name|new
parameter_list|)
name|int
name|new
decl_stmt|;
block|{
specifier|register
name|int
name|nwrite
decl_stmt|,
name|ret
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|long
operator|)
name|text_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|f_ohdr
operator|.
name|text_start
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|f_ohdr
operator|.
name|tsize
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|end
condition|)
block|{
name|nwrite
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|nwrite
operator|>
name|end
operator|-
name|ptr
condition|)
name|nwrite
operator|=
name|end
operator|-
name|ptr
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwrite
operator|!=
name|ret
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unexec write failure: addr 0x%x, fileno %d, size 0x%x, wrote 0x%x, errno %d"
argument_list|,
name|ptr
argument_list|,
name|new
argument_list|,
name|nwrite
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
name|nwrite
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* if not COFF */
if|#
directive|if
name|defined
argument_list|(
name|sun3
argument_list|)
operator|||
name|defined
argument_list|(
name|sequent
argument_list|)
name|lseek
argument_list|(
name|new
argument_list|,
call|(
name|long
call|)
argument_list|(
name|N_TXTOFF
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|long
operator|)
name|N_TXTOFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|start_of_text
argument_list|()
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sequent
argument_list|)
name|end
operator|-=
operator|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
name|N_ADDRADJ
argument_list|(
name|hdr
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
operator|<
name|end
condition|;
control|)
block|{
name|nwrite
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|nwrite
operator|>
name|end
operator|-
name|ptr
condition|)
name|nwrite
operator|=
name|end
operator|-
name|ptr
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EFAULT
condition|)
block|{
comment|/* BZS - again, see above about N_TXTOFF on a SUN */
if|#
directive|if
name|defined
argument_list|(
name|sun3
argument_list|)
operator|||
name|defined
argument_list|(
name|sequent
argument_list|)
name|lseek
argument_list|(
name|new
argument_list|,
call|(
name|long
call|)
argument_list|(
name|N_TXTOFF
argument_list|(
name|hdr
argument_list|)
operator|+
name|i
operator|+
name|nwrite
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|lseek
argument_list|(
name|new
argument_list|,
call|(
name|long
call|)
argument_list|(
name|N_TXTOFF
argument_list|(
name|hdr
argument_list|)
operator|+
name|i
operator|+
name|nwrite
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|nwrite
operator|!=
name|ret
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unexec write failure: addr 0x%x, fileno %d, size 0x%x, wrote 0x%x, errno %d"
argument_list|,
name|ptr
argument_list|,
name|new
argument_list|,
name|nwrite
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|nwrite
expr_stmt|;
name|ptr
operator|+=
name|nwrite
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not COFF */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * copy_sym  *  * Copy the relocation information and symbol table from the a.out to the new  */
end_comment

begin_function
specifier|static
name|int
name|copy_sym
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|,
decl|*
name|new_name
decl_stmt|;
end_function

begin_block
block|{
name|char
name|page
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|a_out
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|COFF
if|if
condition|(
name|SYMS_START
operator|==
literal|0L
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* COFF */
ifdef|#
directive|ifdef
name|sun3
comment|/* BZS - I might be covering a sin with this */
name|lseek
argument_list|(
name|new
argument_list|,
name|N_SYMOFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COFF
if|if
condition|(
name|lnnoptr
condition|)
comment|/* if there is line number info */
name|lseek
argument_list|(
name|a_out
argument_list|,
name|lnnoptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start copying from there */
else|else
endif|#
directive|endif
comment|/* COFF */
name|lseek
argument_list|(
name|a_out
argument_list|,
name|SYMS_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Position a.out to symtab. */
endif|#
directive|endif
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|a_out
argument_list|,
name|page
argument_list|,
sizeof|sizeof
name|page
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|page
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * mark_x  *  * After succesfully building the new a.out, mark it executable  */
end_comment

begin_expr_stmt
specifier|static
name|mark_x
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|um
decl_stmt|;
name|int
name|new
init|=
literal|0
decl_stmt|;
comment|/* for PERROR */
name|um
operator|=
name|umask
argument_list|(
literal|777
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|sbuf
operator|.
name|st_mode
operator||=
literal|0111
operator|&
operator|~
name|um
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|name
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	If the COFF file contains a symbol table and a line number section,  *	then any auxiliary entries that have values for x_lnnoptr must  *	be adjusted by the amount that the line number section has moved  *	in the file (bias computed in make_hdr).  The #@$%&* designers of  *	the auxiliary entry structures used the absolute file offsets for  *	the line number entry rather than an offset from the start of the  *	line number section!  *  *	When I figure out how to scan through the symbol table and pick out  *	the auxiliary entries that need adjustment, this routine will  *	be fixed.  As it is now, all such entries are wrong and sdb  *	will complain.   Fred Fish, UniSoft Systems Inc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF
end_ifdef

begin_comment
comment|/* This function is probably very slow.  Instead of reopening the new    file for input and output it should copy from the old to the new    using the two descriptors already open (WRITEDESC and READDESC).    Instead of reading one small structure at a time it should use    a reasonable size buffer.  But I don't have time to work on such    things, so I am installing it as submitted to me.  -- RMS.  */
end_comment

begin_macro
name|adjust_lnnoptrs
argument_list|(
argument|writedesc
argument_list|,
argument|readdesc
argument_list|,
argument|new_name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|writedesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|readdesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
name|struct
name|syment
name|symentry
decl_stmt|;
name|struct
name|auxent
name|auxentry
decl_stmt|;
if|if
condition|(
operator|!
name|lnnoptr
operator|||
operator|!
name|f_hdr
operator|.
name|f_symptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|open
argument_list|(
name|new_name
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lseek
argument_list|(
name|new
argument_list|,
name|f_hdr
operator|.
name|f_symptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|nsyms
operator|=
literal|0
init|;
name|nsyms
operator|<
name|f_hdr
operator|.
name|f_nsyms
condition|;
name|nsyms
operator|++
control|)
block|{
name|read
argument_list|(
name|new
argument_list|,
operator|&
name|symentry
argument_list|,
name|SYMESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|symentry
operator|.
name|n_numaux
condition|)
block|{
name|read
argument_list|(
name|new
argument_list|,
operator|&
name|auxentry
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|symentry
operator|.
name|n_type
argument_list|)
condition|)
block|{
name|auxentry
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|+=
name|bias
expr_stmt|;
name|lseek
argument_list|(
name|new
argument_list|,
operator|-
name|AUXESZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|auxentry
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_DUMP */
end_comment

end_unit

