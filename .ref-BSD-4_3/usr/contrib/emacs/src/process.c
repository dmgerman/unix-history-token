begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Asynchronous subprocess control for GNU Emacs.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|subprocesses
end_ifdef

begin_comment
comment|/* The entire file is within this conditional */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* some typedefs are used in sys/file.h */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TIMEVAL */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HPUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ptyio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_comment
comment|/* Define SIGCHLD as an alias for SIGCLD.  There are many conditionals    testing SIGCHLD.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGCLD
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGCLD */
end_comment

begin_comment
comment|/* Define the structure that the wait system call stores.    On many systems, there is a structure defined for this.    But on vanilla-ish USG systems there is not.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STRIDE
argument_list|)
end_if

begin_define
define|#
directive|define
name|WAITTYPE
value|int
end_define

begin_define
define|#
directive|define
name|WIFSTOPPED
parameter_list|(
name|w
parameter_list|)
value|((w&0377) == 0177)
end_define

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|w
parameter_list|)
value|((w&0377) != 0177&& (w&~0377) == 0)
end_define

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|w
parameter_list|)
value|((w&0377) == 0)
end_define

begin_define
define|#
directive|define
name|WRETCODE
parameter_list|(
name|w
parameter_list|)
value|(w>> 8)
end_define

begin_define
define|#
directive|define
name|WSTOPSIG
parameter_list|(
name|w
parameter_list|)
value|(w>> 8)
end_define

begin_define
define|#
directive|define
name|WCOREDUMP
parameter_list|(
name|w
parameter_list|)
value|((w&0200) != 0)
end_define

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|w
parameter_list|)
value|(w& 0377)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD 4.1 */
end_comment

begin_define
define|#
directive|define
name|WAITTYPE
value|union wait
end_define

begin_define
define|#
directive|define
name|WRETCODE
parameter_list|(
name|w
parameter_list|)
value|w.w_retcode
end_define

begin_define
define|#
directive|define
name|WSTOPSIG
parameter_list|(
name|w
parameter_list|)
value|w.w_stopsig
end_define

begin_define
define|#
directive|define
name|WCOREDUMP
parameter_list|(
name|w
parameter_list|)
value|w.w_coredump
end_define

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|w
parameter_list|)
value|w.w_termsig
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern errno;
end_extern

begin_extern
extern|extern sys_nerr;
end_extern

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_1
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|sys_siglist
index|[]
init|=
block|{
literal|"bum signal!!"
block|,
literal|"hangup"
block|,
literal|"interrupt"
block|,
literal|"quit"
block|,
literal|"illegal instruction"
block|,
literal|"trace trap"
block|,
literal|"iot instruction"
block|,
literal|"emt instruction"
block|,
literal|"floating point exception"
block|,
literal|"kill"
block|,
literal|"bus error"
block|,
literal|"segmentation violation"
block|,
literal|"bad argument to system call"
block|,
literal|"write on a pipe with no one to read it"
block|,
literal|"alarm clock"
block|,
literal|"software termination signal from kill"
block|,
literal|"status signal"
block|,
literal|"sendable stop signal not from tty"
block|,
literal|"stop signal from tty"
block|,
literal|"continue a stopped process"
block|,
literal|"child status has changed"
block|,
literal|"background read attempted from control tty"
block|,
literal|"background write attempted from control tty"
block|,
literal|"input record available at control tty"
block|,
literal|"exceeded CPU time limit"
block|,
literal|"exceeded file size limit"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vipc
end_ifdef

begin_include
include|#
directive|include
file|"vipc.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|comm_server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|net_listen_address
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|vipc
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SKTPAIR
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SKTPAIR */
end_comment

begin_decl_stmt
name|int
name|child_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag when a child process has ceased 				   to be */
end_comment

begin_comment
comment|/* Mask of bits indicating the descriptors that we wait for input on */
end_comment

begin_decl_stmt
name|int
name|input_wait_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delete_exited_processes
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXDESC
value|32
end_define

begin_comment
comment|/* Indexed by descriptor, gives the process (if any) for that descriptor */
end_comment

begin_decl_stmt
name|Lisp_Object
name|chan_process
index|[
name|MAXDESC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alist of elements (NAME . PROCESS) */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprocess_alist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qprocessp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|get_process
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Buffered-ahead input char from process, indexed by channel.    -1 means empty (no char is buffered).    Used on sys V where the only way to tell if there is any    output from the process is to read at least one char.    Always -1 on systems that support FIONREAD.  */
end_comment

begin_decl_stmt
name|int
name|proc_buffered_char
index|[
name|MAXDESC
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTYS
end_ifdef

begin_comment
comment|/* Open an available pty, putting descriptor in *ptyv,   and return the file name of the pty.  Return 0 if none available.  */
end_comment

begin_decl_stmt
name|char
name|ptyname
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|pty
parameter_list|(
name|ptyv
parameter_list|)
name|int
modifier|*
name|ptyv
decl_stmt|;
block|{
name|struct
name|stat
name|stb
decl_stmt|;
specifier|register
name|c
operator|,
name|i
expr_stmt|;
for|for
control|(
name|c
operator|=
name|FIRST_PTY_LETTER
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|HPUX
name|sprintf
argument_list|(
name|ptyname
argument_list|,
literal|"/dev/ptym/pty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ptyname
argument_list|,
literal|"/dev/pty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HPUX */
if|if
condition|(
name|stat
argument_list|(
name|ptyname
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|ptyv
operator|=
name|open
argument_list|(
name|ptyname
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptyv
operator|>=
literal|0
condition|)
block|{
comment|/* check to make certain that both sides are available 	       this avoids a nasty yet stupid bug in rlogins */
name|int
name|x
decl_stmt|;
ifdef|#
directive|ifdef
name|HPUX
name|sprintf
argument_list|(
name|ptyname
argument_list|,
literal|"/dev/pty/tty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ptyname
argument_list|,
literal|"/dev/tty%c%x"
argument_list|,
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HPUX */
ifndef|#
directive|ifndef
name|UNIPLUS
name|x
operator|=
name|open
argument_list|(
name|ptyname
argument_list|,
name|O_RDWR
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
operator|*
name|ptyv
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|close
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not UNIPLUS */
comment|/* 		* If the following statement is included, 		* then a 0 length record is EOT, but no other 		* control characters can be sent down the pty 		* (e.g., ^S/^Q, ^O, etc.).  If it is not 		* included, then sending ^D down the pty-pipe 		* makes a pretty good EOF. 		*/
comment|/*	      ioctl( *ptyv, TIOCREMOTE,&on );	/* for EOT */
comment|/* this is said to be unecessary, and to be harmful in 4.3.  */
comment|/*	    ioctl (*ptyv, FIONBIO,&on);  */
return|return
name|ptyname
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PTYS */
end_comment

begin_escape
end_escape

begin_function
name|Lisp_Object
name|make_process
parameter_list|(
name|name
parameter_list|)
name|Lisp_Object
name|name
decl_stmt|;
block|{
name|Lisp_Object
name|val
decl_stmt|,
name|tem
decl_stmt|,
name|name1
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
name|char
name|suffix
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|val
operator|=
name|Fmake_vector
argument_list|(
name|make_number
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Process
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
operator|*
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
name|val
argument_list|,
name|Lisp_Process
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|outfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|mark
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
comment|/* If name is already in use, modify it until it is unused.  */
name|name1
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|Fget_process
argument_list|(
name|name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
break|break;
name|sprintf
argument_list|(
name|suffix
argument_list|,
literal|"<%d>"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name1
operator|=
name|concat2
argument_list|(
name|name
argument_list|,
name|build_string
argument_list|(
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|name1
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|Vprocess_alist
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|name
argument_list|,
name|val
argument_list|)
argument_list|,
name|Vprocess_alist
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_macro
name|remove_process
argument_list|(
argument|proc
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|pair
decl_stmt|;
name|pair
operator|=
name|Frassq
argument_list|(
name|proc
argument_list|,
name|Vprocess_alist
argument_list|)
expr_stmt|;
name|Vprocess_alist
operator|=
name|Fdelq
argument_list|(
name|pair
argument_list|,
name|Vprocess_alist
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|mark
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"processp"
argument_list|,
argument|Fprocessp
argument_list|,
argument|Sprocessp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if OBJECT is a process."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Process
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"get-process"
argument_list|,
argument|Fget_process
argument_list|,
argument|Sget_process
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the process named NAME, or nil if there is none."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|)
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|name
argument_list|)
operator|==
name|Lisp_Process
condition|)
return|return
name|name
return|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|Fcdr
argument_list|(
name|Fassoc
argument_list|(
name|name
argument_list|,
name|Vprocess_alist
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"get-buffer-process"
argument_list|,
argument|Fget_buffer_process
argument_list|,
argument|Sget_buffer_process
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the (or, a) process associated with BUFFER.\n\ BUFFER may be a buffer or the name of one."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|)
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|buf
decl_stmt|,
name|tail
decl_stmt|,
name|proc
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|Qnil
return|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|proc
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|proc
argument_list|)
operator|==
name|Lisp_Process
operator|&&
name|EQ
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
argument_list|,
name|buf
argument_list|)
condition|)
return|return
name|proc
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* This is how commands for the user decode process arguments */
end_comment

begin_function
name|Lisp_Object
name|get_process
parameter_list|(
name|name
parameter_list|)
name|Lisp_Object
name|name
decl_stmt|;
block|{
name|Lisp_Object
name|proc
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|name
argument_list|)
condition|)
name|proc
operator|=
name|Fget_buffer_process
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|proc
operator|=
name|Fget_process
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
name|proc
operator|=
name|Fget_buffer_process
argument_list|(
name|Fget_buffer
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
return|return
name|proc
return|;
if|if
condition|(
name|NULL
argument_list|(
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Current buffer has no process"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Process %s does not exist"
argument_list|,
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"delete-process"
argument_list|,
argument|Fdelete_process
argument_list|,
argument|Sdelete_process
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Delete PROCESS: kill it and forget about it immediately.\n\ PROCESS may be a process or the name of one, or a buffer name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|proc
operator|=
name|get_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|infd
argument_list|)
condition|)
name|Fkill_process
argument_list|(
name|proc
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"process-status"
argument_list|,
argument|Fprocess_status
argument_list|,
argument|Sprocess_status
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the status of PROCESS: a symbol, one of these:\n\ run  -- for a process that is running.\n\ stop -- for a process stopped but continuable.\n\ exit -- for a process that has exited.\n\ signal -- for a process that has got a fatal signal.\n\ command -- for a command channel opened to Emacs by another process.\n\ external -- for an i/o channel opened to Emacs by another process.\n\ nil -- if arg is a process name and no such process exists."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
name|proc
operator|=
name|Fget_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
return|return
name|proc
return|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
condition|)
block|{
case|case
name|RUNNING
case|:
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|childp
argument_list|)
condition|)
return|return
name|intern
argument_list|(
literal|"run"
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|command_channel_p
argument_list|)
condition|)
return|return
name|intern
argument_list|(
literal|"command"
argument_list|)
return|;
return|return
name|intern
argument_list|(
literal|"external"
argument_list|)
return|;
case|case
name|EXITED
case|:
return|return
name|intern
argument_list|(
literal|"exit"
argument_list|)
return|;
case|case
name|SIGNALED
case|:
return|return
name|intern
argument_list|(
literal|"signal"
argument_list|)
return|;
case|case
name|STOPPED
case|:
return|return
name|intern
argument_list|(
literal|"stop"
argument_list|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-id"
argument_list|,
argument|Fprocess_id
argument_list|,
argument|Sprocess_id
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the process id of PROCESS.\n\ This is the pid of the Unix process which PROCESS uses or talks to."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|pid
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-name"
argument_list|,
argument|Fprocess_name
argument_list|,
argument|Sprocess_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the name of PROCESS, as a string.\n\ This is the name of the program invoked in PROCESS,\n\ possibly modified to make it unique among process names."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-command"
argument_list|,
argument|Fprocess_command
argument_list|,
argument|Sprocess_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the command that was executed to start PROCESS.\n\ This is a list of strings, the first string being the program executed\n\ and the rest of the strings being the arguments given to it.\n\ For a non-child channel, this is nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-process-buffer"
argument_list|,
argument|Fset_process_buffer
argument_list|,
argument|Sset_process_buffer
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set buffer associated with PROCESS to BUFFER (a buffer, or nil)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|,
name|buffer
operator|)
name|Lisp_Object
name|proc
operator|,
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-buffer"
argument_list|,
argument|Fprocess_buffer
argument_list|,
argument|Sprocess_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer PROCESS is associated with.\n\ Output from PROCESS is inserted in this buffer\n\ unless PROCESS has a filter."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-mark"
argument_list|,
argument|Fprocess_mark
argument_list|,
argument|Sprocess_mark
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the marker for the end of the last output from PROCESS."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|mark
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-process-filter"
argument_list|,
argument|Fset_process_filter
argument_list|,
argument|Sset_process_filter
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Give PROCESS the filter function FILTER; nil means no filter.\n\ When a process has a filter, each time it does output\n\ the entire string of output is passed to the filter.\n\ The filter gets two arguments: the process and the string of output.\n\ If the process has a filter, its buffer is not used for output."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|,
name|filter
operator|)
name|Lisp_Object
name|proc
operator|,
name|filter
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
return|return
name|filter
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-filter"
argument_list|,
argument|Fprocess_filter
argument_list|,
argument|Sprocess_filter
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Returns the filter function of PROCESS; nil if none.\n\ See set-process-filter for more info on filter functions."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|filter
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-process-sentinel"
argument_list|,
argument|Fset_process_sentinel
argument_list|,
argument|Sset_process_sentinel
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Give PROCESS the sentinel SENTINEL; nil for none.\n\ The sentinel is called as a function when the process changes state.\n\ It gets two arguments: the process, and a string describing the change."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|,
name|sentinel
operator|)
name|Lisp_Object
name|proc
operator|,
name|sentinel
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|sentinel
operator|=
name|sentinel
expr_stmt|;
return|return
name|sentinel
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-sentinel"
argument_list|,
argument|Fprocess_sentinel
argument_list|,
argument|Sprocess_sentinel
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the sentinel of PROCESS; nil if none.\n\ See set-process-sentinel for more info on sentinels."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|sentinel
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-kill-without-query"
argument_list|,
argument|Fprocess_kill_without_query
argument_list|,
argument|Sprocess_kill_without_query
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Say no query needed if this process is running when Emacs is exited."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_PROCESS
argument_list|(
name|proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|kill_without_query
operator|=
name|Qt
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|list_processes_1
parameter_list|()
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|proc
decl_stmt|,
name|minspace
decl_stmt|,
name|tem
decl_stmt|,
name|tem1
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
name|char
name|tembuf
index|[
literal|10
index|]
decl_stmt|;
name|XFASTINT
argument_list|(
name|minspace
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
argument_list|)
expr_stmt|;
name|Fbuffer_flush_undo
argument_list|(
name|Vstandard_output
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|truncate_lines
operator|=
name|Qt
expr_stmt|;
name|write_string
argument_list|(
literal|"\ Proc         Status   Buffer         Command\n\ ----         ------   ------         -------\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|proc
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|childp
argument_list|)
condition|)
continue|continue;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|13
argument_list|)
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
name|state
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|RUNNING
case|:
name|write_string
argument_list|(
literal|"Run"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|STOPPED
case|:
name|write_string
argument_list|(
literal|"Stop"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXITED
case|:
name|write_string
argument_list|(
literal|"Exit"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|tembuf
argument_list|,
literal|" %d"
argument_list|,
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|tembuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGNALED
case|:
if|if
condition|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
operator|<
name|NSIG
condition|)
name|write_string
argument_list|(
name|sys_siglist
index|[
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|write_string
argument_list|(
literal|"Signal"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|22
argument_list|)
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
condition|)
name|InsStr
argument_list|(
literal|"(none)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|InsStr
argument_list|(
literal|"(Killed)"
argument_list|)
expr_stmt|;
else|else
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|37
argument_list|)
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
name|tem
operator|=
name|p
operator|->
name|command
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tem1
operator|=
name|Fcar
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|tem1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
break|break;
name|InsStr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|InsStr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"list-processes"
argument_list|,
argument|Flist_processes
argument_list|,
argument|Slist_processes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Display a list of all processes.\n\ \(Any processes listed as Exited or Signaled are actually eliminated\n\ after the listing is made.)"
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Process List*"
argument_list|,
name|list_processes_1
argument_list|,
name|Qnil
argument_list|)
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"start-process"
argument_list|,
argument|Fstart_process
argument_list|,
argument|Sstart_process
argument_list|,
literal|3
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Start a program in a subprocess.  Return the process object for it.\n\ First arg is name for process.  It is modified if nec to make it unique.\n\ Second arg is buffer to associate with the process (or buffer name).\n\  Process output goes at end of that buffer, unless you specify\n\  an output stream or filter function to handle the output.\n\ Third arg is program file name.  It is searched for as in the shell.\n\ Remaining arguments are strings to give program as arguments."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|buffer
decl_stmt|,
name|name
decl_stmt|,
name|program
decl_stmt|,
name|proc
decl_stmt|,
name|tem
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|name
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|program
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|program
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|new_argv
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|tem
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|new_argv
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
name|new_argv
index|[
name|i
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|program
argument_list|)
operator|->
name|data
expr_stmt|;
comment|/* If program file name is not absolute, search our path for it */
if|if
condition|(
name|new_argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|tem
operator|=
name|Qnil
expr_stmt|;
name|openp
argument_list|(
name|Vexec_path
argument_list|,
name|program
argument_list|,
literal|""
argument_list|,
operator|&
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|report_file_error
argument_list|(
literal|"Searching for program"
argument_list|,
name|Fcons
argument_list|(
name|program
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|buffer
operator|=
name|Fget_buffer_create
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|proc
operator|=
name|make_process
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|childp
operator|=
name|Qt
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|sentinel
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|filter
operator|=
name|Qnil
expr_stmt|;
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command
operator|=
name|Flist
argument_list|(
name|nargs
operator|-
literal|2
argument_list|,
name|args
operator|+
literal|2
argument_list|)
expr_stmt|;
name|create_process
argument_list|(
name|proc
argument_list|,
name|new_argv
argument_list|)
expr_stmt|;
return|return
name|proc
return|;
block|}
end_block

begin_macro
name|create_process_1
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|USG
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
name|signal
argument_list|(
name|signo
argument_list|,
name|create_process_1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
block|}
end_block

begin_macro
name|create_process
argument_list|(
argument|process
argument_list|,
argument|new_argv
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|process
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|,
name|inchannel
decl_stmt|,
name|outchannel
decl_stmt|,
name|forkin
decl_stmt|,
name|forkout
decl_stmt|;
name|int
name|sv
index|[
literal|2
index|]
decl_stmt|;
name|int
function_decl|(
modifier|*
name|sigchld
function_decl|)
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|HAVE_PTYS
name|char
modifier|*
name|ptyname
decl_stmt|;
name|ptyname
operator|=
name|pty
argument_list|(
operator|&
name|inchannel
argument_list|)
expr_stmt|;
name|outchannel
operator|=
name|inchannel
expr_stmt|;
if|if
condition|(
name|ptyname
condition|)
block|{
name|forkout
operator|=
name|forkin
operator|=
name|open
argument_list|(
name|ptyname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkin
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening pty"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_PTYS */
ifdef|#
directive|ifdef
name|SKTPAIR
block|{
if|if
condition|(
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening socketpair"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|outchannel
operator|=
name|inchannel
operator|=
name|sv
index|[
literal|0
index|]
expr_stmt|;
name|forkout
operator|=
name|forkin
operator|=
name|sv
index|[
literal|1
index|]
expr_stmt|;
block|}
else|#
directive|else
comment|/* not SKTPAIR */
block|{
name|pipe
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|inchannel
operator|=
name|sv
index|[
literal|0
index|]
expr_stmt|;
name|forkout
operator|=
name|sv
index|[
literal|1
index|]
expr_stmt|;
name|pipe
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|outchannel
operator|=
name|sv
index|[
literal|1
index|]
expr_stmt|;
name|forkin
operator|=
name|sv
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not SKTPAIR */
ifdef|#
directive|ifdef
name|FIOCLEX
name|ioctl
argument_list|(
name|inchannel
argument_list|,
name|FIOCLEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|outchannel
argument_list|,
name|FIOCLEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Stride people say it's a mystery why this is needed    as well as the O_NDELAY, but that it fails without this.  */
ifdef|#
directive|ifdef
name|STRIDE
block|{
name|int
name|one
init|=
literal|1
decl_stmt|;
name|ioctl
argument_list|(
name|inchannel
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NDELAY
name|fcntl
argument_list|(
name|inchannel
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chan_process
index|[
name|inchannel
index|]
operator|=
name|process
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|infd
argument_list|)
operator|=
name|inchannel
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|outfd
argument_list|)
operator|=
name|outchannel
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|flags
argument_list|)
operator|=
name|RUNNING
expr_stmt|;
name|input_wait_mask
operator||=
name|ChannelMask
argument_list|(
name|inchannel
argument_list|)
expr_stmt|;
comment|/* Delay interrupts until we have a chance to store      the new fork's pid in its process structure */
ifdef|#
directive|ifdef
name|SIGCHLD
ifdef|#
directive|ifdef
name|BSD4_1
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
name|sigsetmask
argument_list|(
literal|1
operator|<<
operator|(
name|SIGCHLD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ordinary USG */
name|sigchld
operator|=
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ordinary USG */
endif|#
directive|endif
comment|/* not BSD4_1 */
endif|#
directive|endif
comment|/* SIGCHLD */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|xforkin
init|=
name|forkin
decl_stmt|;
name|int
name|xforkout
init|=
name|forkout
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PTYS
ifdef|#
directive|ifdef
name|TIOCNOTTY
comment|/* In 4.3BSD, the TIOCSPGRP bug has been fixed, and now you 	 can do TIOCSPGRP only to the process's controlling tty. 	 We must make the pty terminal the controlling tty of the child.  */
if|if
condition|(
name|ptyname
condition|)
block|{
comment|/* I wonder: would just ioctl (0, TIOCNOTTY, 0) work here?  	     I can't test it since I don't have 4.3.  */
name|int
name|j
init|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ioctl
argument_list|(
name|j
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|j
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNIPLUS
comment|/* I wonder if close (open (ptyname, ...)) would work?  */
name|close
argument_list|(
name|xforkin
argument_list|)
expr_stmt|;
name|xforkout
operator|=
name|xforkin
operator|=
name|open
argument_list|(
name|ptyname
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xforkin
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not UNIPLUS */
block|}
endif|#
directive|endif
comment|/* TIOCNOTTY */
endif|#
directive|endif
comment|/* HAVE_PTYS */
name|child_setup
argument_list|(
name|xforkin
argument_list|,
name|xforkout
argument_list|,
name|xforkout
argument_list|,
name|new_argv
argument_list|)
expr_stmt|;
block|}
comment|/* If the subfork execv fails, and it exits,      this close hangs.  I don't know why.      So have an interrupt jar it loose.  */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|create_process_1
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|forkin
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkin
operator|!=
name|forkout
condition|)
name|close
argument_list|(
name|forkout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|remove_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Doing vfork"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|process
argument_list|)
operator|->
name|pid
argument_list|)
operator|=
name|pid
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
ifdef|#
directive|ifdef
name|BSD4_1
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|UNIPLUS
argument_list|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ordinary USG */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ordinary USG */
endif|#
directive|endif
comment|/* not BSD4_1 */
endif|#
directive|endif
comment|/* SIGCHLD */
block|}
end_block

begin_macro
name|deactivate_process
argument_list|(
argument|proc
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|inchannel
decl_stmt|,
name|outchannel
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
init|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
decl_stmt|;
name|inchannel
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
expr_stmt|;
name|outchannel
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|outfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inchannel
condition|)
block|{
comment|/* Beware SIGCHLD hereabouts. */
name|flush_pending_output
argument_list|(
name|inchannel
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inchannel
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchannel
operator|&&
name|outchannel
operator|!=
name|inchannel
condition|)
name|close
argument_list|(
name|outchannel
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|outfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|chan_process
index|[
name|inchannel
index|]
operator|=
name|Qnil
expr_stmt|;
name|input_wait_mask
operator|&=
operator|~
name|ChannelMask
argument_list|(
name|inchannel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"accept-process-output"
argument_list|,
argument|Faccept_process_output
argument_list|,
argument|Saccept_process_output
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Allow any pending output from subprocesses to be read by Emacs.\n\ It is read into the processs' buffers or given to their filter functions.\n\ Non-nil arg PROCESS means do not return until some output has been received\n\ from PROCESS."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|proc
operator|)
name|Lisp_Object
name|proc
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
name|wait_reading_process_input
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|proc
operator|=
name|get_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|wait_reading_process_input
argument_list|(
literal|0
argument_list|,
literal|10
operator|+
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|infd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Read and dispose of subprocess output  while waiting for timeout to elapse and/or keyboard input to be available.   time_limit is the timeout in seconds, or zero for no limit.  -1 means gobble data available immediately but don't wait for any.   read_kbd is 1 to return when input is available.  Negative means caller will actually read the input.  10 + I means wait until input received from channel I.   do_display means redisplay should be done to show  subprocess output that arrives.  */
end_comment

begin_macro
name|wait_reading_process_input
argument_list|(
argument|time_limit
argument_list|,
argument|read_kbd
argument_list|,
argument|do_display
argument_list|)
end_macro

begin_decl_stmt
name|int
name|time_limit
decl_stmt|,
name|read_kbd
decl_stmt|,
name|do_display
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|channel
decl_stmt|,
name|nfds
decl_stmt|,
name|m
decl_stmt|;
name|int
name|Available
init|=
literal|0
decl_stmt|;
name|int
name|Exception
decl_stmt|;
name|Lisp_Object
name|proc
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|struct
name|timeval
name|timeout
decl_stmt|,
name|end_time
decl_stmt|,
name|garbage
decl_stmt|;
else|#
directive|else
name|long
name|timeout
decl_stmt|,
name|end_time
decl_stmt|,
name|temp
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
name|int
name|Atemp
decl_stmt|;
name|int
name|wait_channel
init|=
literal|0
decl_stmt|;
extern|extern kbd_count;
if|if
condition|(
name|read_kbd
operator|>
literal|10
condition|)
block|{
name|wait_channel
operator|=
name|read_kbd
operator|-
literal|10
expr_stmt|;
name|read_kbd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Since we may need to wait several times,      compute the absolute time to return at.  */
if|if
condition|(
name|time_limit
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|gettimeofday
argument_list|(
operator|&
name|end_time
argument_list|,
operator|&
name|garbage
argument_list|)
expr_stmt|;
name|end_time
operator|.
name|tv_sec
operator|+=
name|time_limit
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|time
argument_list|(
operator|&
name|end_time
argument_list|)
expr_stmt|;
name|end_time
operator|+=
name|time_limit
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If calling from keyboard input, do not quit 	 since we want to return C-g as an input character. 	 Otherwise, do pending quit if requested.  */
if|if
condition|(
name|read_kbd
operator|>=
literal|0
condition|)
name|QUIT
expr_stmt|;
comment|/* If status of something has changed, and no input is available, 	 notify the user of the change right away */
if|if
condition|(
name|child_changed
operator|&&
name|do_display
condition|)
block|{
name|Atemp
operator|=
name|input_wait_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|timeout
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
if|if
condition|(
name|select
argument_list|(
name|MAXDESC
argument_list|,
operator|&
name|Atemp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
name|change_msgs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fix_screen_hook
condition|)
call|(
modifier|*
name|fix_screen_hook
call|)
argument_list|()
expr_stmt|;
comment|/* Compute time from now till when time limit is up */
comment|/* Exit if already run out */
if|if
condition|(
name|time_limit
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* -1 specified for timeout means 	     gobble output available now 	     but don't wait at all. */
name|time_limit
operator|=
operator|-
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|timeout
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
elseif|else
if|if
condition|(
name|time_limit
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|gettimeofday
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|garbage
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|end_time
operator|.
name|tv_sec
operator|-
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|end_time
operator|.
name|tv_usec
operator|-
name|timeout
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_usec
operator|<
literal|0
condition|)
name|timeout
operator|.
name|tv_usec
operator|+=
literal|1000000
operator|,
name|timeout
operator|.
name|tv_sec
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|<
literal|0
condition|)
break|break;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|time
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|end_time
operator|-
name|temp
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
break|break;
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
comment|/* If no real timeout, loop sleeping with a big timeout 	     so that input interrupt can wake us up by zeroing it  */
name|timeout
operator|.
name|tv_sec
operator|=
literal|100
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
name|timeout
operator|=
literal|100000
expr_stmt|;
comment|/* 100000 recognized by the select emulator */
endif|#
directive|endif
comment|/* not HAVE_TIMEVAL */
block|}
comment|/* Cause C-g and alarm signals to take immediate action, 	 and cause input available signals to zero out timeout */
if|if
condition|(
name|read_kbd
operator|<
literal|0
condition|)
name|set_waiting_for_input
argument_list|(
operator|&
name|timeout
argument_list|)
expr_stmt|;
comment|/* Wait till there is something to do */
name|Available
operator|=
name|Exception
operator|=
name|input_wait_mask
expr_stmt|;
if|if
condition|(
operator|!
name|read_kbd
condition|)
name|Available
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|read_kbd
operator|&&
name|kbd_count
condition|)
name|nfds
operator|=
literal|0
expr_stmt|;
else|else
name|nfds
operator|=
name|select
argument_list|(
name|MAXDESC
argument_list|,
operator|&
name|Available
argument_list|,
literal|0
argument_list|,
operator|&
name|Exception
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix_screen_hook
condition|)
call|(
modifier|*
name|fix_screen_hook
call|)
argument_list|()
expr_stmt|;
comment|/* Make C-g and alarm signals set flags again */
name|clear_waiting_for_input
argument_list|()
expr_stmt|;
if|if
condition|(
name|time_limit
operator|&&
name|nfds
operator|==
literal|0
condition|)
comment|/* timeout elapsed */
break|break;
if|if
condition|(
name|nfds
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
name|Available
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EBADF
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"select error: %s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Check for keyboard input */
comment|/* If there is any, return immediately 	 to give it higher priority than subprocesses */
if|if
condition|(
name|read_kbd
operator|&&
operator|(
name|kbd_count
operator|||
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|read_kbd
operator|&&
operator|(
name|Available
operator|&
name|ChannelMask
argument_list|(
literal|0
argument_list|)
operator|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|vipc
comment|/* Check for connection from other process */
if|if
condition|(
name|Available
operator|&
name|ChannelMask
argument_list|(
name|comm_server
argument_list|)
condition|)
block|{
name|Available
operator|&=
operator|~
operator|(
name|ChannelMask
argument_list|(
name|comm_server
argument_list|)
operator|)
expr_stmt|;
name|create_commchan
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|vipc
comment|/* Check for data from a process or a command channel */
for|for
control|(
name|channel
operator|=
literal|3
init|;
name|Available
operator|&&
name|channel
operator|<
name|MAXDESC
condition|;
name|channel
operator|++
control|)
block|{
name|m
operator|=
name|ChannelMask
argument_list|(
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&
name|Available
condition|)
block|{
name|Available
operator|&=
operator|~
name|m
expr_stmt|;
comment|/* If waiting for this channel, 		 arrange to return as soon as no more input 		 to be processed.  No more waiting.  */
if|if
condition|(
name|wait_channel
operator|==
name|channel
condition|)
block|{
name|wait_channel
operator|=
literal|0
expr_stmt|;
name|time_limit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|proc
operator|=
name|chan_process
index|[
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|proc
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|vipc
comment|/* It's a command channel */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
argument_list|)
condition|)
block|{
name|ProcessCommChan
argument_list|(
name|channel
argument_list|,
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
argument_list|)
condition|)
block|{
comment|/* It has ceased to be a command channel! */
name|int
name|bytes_available
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|channel
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|bytes_available
argument_list|)
operator|<
literal|0
condition|)
name|bytes_available
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes_available
condition|)
name|Available
operator||=
name|m
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
endif|vipc
comment|/* Read data from the process, starting with our 		 buffered-ahead character if we have one.  */
if|if
condition|(
name|read_process_output
argument_list|(
name|proc
argument_list|,
name|channel
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|do_display
condition|)
name|DoDsp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Preserve status of processes already terminated.  */
name|child_changed
operator|++
expr_stmt|;
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
comment|/*  * With pty:s, when the parent process of a pty exits we are notified,  * just as we would be with any of our other children.  After the process  * exits, select() will indicate that we can read the channel.  When we  * do this, read() returns 0.  Upon receiving this, we close the channel.  *  * For external channels, when the peer closes the connection, select()  * will indicate that we can read the channel.  When we do this, read()  * returns -1 with errno = ECONNRESET.  Since we never get notified of  * this via wait3(), we must explictly mark the process as having exited.  */
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
operator|)
operator|==
name|RUNNING
condition|)
block|{
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|flags
argument_list|)
operator|=
name|EXITED
operator||
name|CHANGED
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|reason
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end for */
block|}
comment|/* end while */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read pending output from the process channel,    starting with our buffered-ahead character if we have one.    Yield number of characters read.  */
end_comment

begin_macro
name|read_process_output
argument_list|(
argument|proc
argument_list|,
argument|channel
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|channel
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|total
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|proc_buffered_char
index|[
name|channel
index|]
operator|<
literal|0
condition|)
name|count
operator|=
name|read
argument_list|(
name|channel
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|proc_buffered_char
index|[
name|channel
index|]
expr_stmt|;
name|proc_buffered_char
index|[
name|channel
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
name|read
argument_list|(
name|channel
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
break|break;
name|total
operator|+=
name|count
expr_stmt|;
name|handle_process_output
argument_list|(
name|proc
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_block

begin_comment
comment|/*  * Output has been received from a process on "chan" and should be stuffed in  * the correct buffer.  */
end_comment

begin_macro
name|handle_process_output
argument_list|(
argument|proc
argument_list|,
argument|chars
argument_list|,
argument|nchars
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nchars
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|outstream
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
init|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
decl_stmt|;
specifier|register
name|int
name|opoint
decl_stmt|;
name|outstream
operator|=
name|p
operator|->
name|filter
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|outstream
argument_list|)
condition|)
block|{
name|call2
argument_list|(
name|outstream
argument_list|,
name|proc
argument_list|,
name|make_string
argument_list|(
name|chars
argument_list|,
name|nchars
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If no filter, write into buffer if it isn't dead.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
block|{
name|Fset_buffer
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|opoint
operator|=
name|point
expr_stmt|;
comment|/* Insert new output into buffer 	 at the current end-of-output marker, 	 thus preserving logical ordering of input and output.  */
if|if
condition|(
name|XMARKER
argument_list|(
name|p
operator|->
name|mark
argument_list|)
operator|->
name|buffer
condition|)
name|SetPoint
argument_list|(
name|marker_position
argument_list|(
name|p
operator|->
name|mark
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SetPoint
argument_list|(
name|NumCharacters
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|opoint
condition|)
name|opoint
operator|+=
name|nchars
expr_stmt|;
name|InsCStr
argument_list|(
name|chars
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|p
operator|->
name|mark
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* Old feature was, delete early chars in chunks if     buffer gets bigger that ProcessBufferSize.     This feature is flushed */
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Sending data to subprocess */
end_comment

begin_decl_stmt
name|jmp_buf
name|send_process_frame
decl_stmt|;
end_decl_stmt

begin_macro
name|send_process_trap
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD4_1
name|sigrelse
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
name|longjmp
argument_list|(
name|send_process_frame
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|send_process_1
argument_list|(
argument|proc
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Don't use register vars; longjmp can lose them.  */
name|int
name|rv
decl_stmt|;
name|unsigned
name|char
modifier|*
name|procname
init|=
name|XSTRING
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
operator|)
operator|!=
name|RUNNING
condition|)
name|error
argument_list|(
literal|"Process %s not running"
argument_list|,
name|procname
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|send_process_trap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|send_process_frame
argument_list|)
condition|)
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|write
argument_list|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|outfd
argument_list|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
break|break;
name|buf
operator|+=
name|rv
expr_stmt|;
name|len
operator|-=
name|rv
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|flags
argument_list|)
operator|=
name|EXITED
operator||
name|CHANGED
expr_stmt|;
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"SIGPIPE raised on process %s; closed it"
argument_list|,
name|procname
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"writing to process"
argument_list|,
name|Fcons
argument_list|(
name|proc
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*** Is it really safe for this to get an error ?  */
end_comment

begin_macro
name|send_process
argument_list|(
argument|proc
argument_list|,
argument|buf
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|vipc
struct|struct
block|{
name|int
name|checkword
decl_stmt|,
name|type
decl_stmt|,
name|datalen
decl_stmt|;
block|}
name|header
struct|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|command_channel_p
argument_list|)
condition|)
block|{
name|checkword
operator|=
name|UNIQUE_FROB
expr_stmt|;
name|type
operator|=
name|VIPC_MESG
expr_stmt|;
name|datalen
operator|=
name|count
expr_stmt|;
name|send_process_1
argument_list|(
name|proc
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
name|header
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|vipc
name|send_process_1
argument_list|(
name|proc
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"send-region"
argument_list|,
argument|Fsend_region
argument_list|,
argument|Ssend_region
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Send current contents of region as input to PROCESS.\n\ PROCESS may be a process name.\n\ Called from program, takes three arguments, PROCESS, START and END."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|start
operator|,
name|end
operator|)
name|Lisp_Object
name|process
operator|,
name|start
operator|,
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|validate_region
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|start
argument_list|)
operator|<
name|bf_s1
operator|&&
name|XINT
argument_list|(
name|end
argument_list|)
operator|>=
name|bf_s1
condition|)
name|GapTo
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|send_process
argument_list|(
name|proc
argument_list|,
operator|&
name|CharAt
argument_list|(
name|XINT
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|end
argument_list|)
operator|-
name|XINT
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"send-string"
argument_list|,
argument|Fsend_string
argument_list|,
argument|Ssend_string
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Send PROCESS the contents of STRING as input.\n\ PROCESS may be a process name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|string
operator|)
name|Lisp_Object
name|process
operator|,
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|send_process
argument_list|(
name|proc
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* send a signal number SIGNO to PROCESS.    CURRENT_GROUP means send to the process group that currently owns    the terminal being used to communicate with PROCESS.    This is used for various commands in shell mode.    If NOMSG is zero, insert signal-announcements into process's buffers    right away.  */
end_comment

begin_macro
name|sig_process
argument_list|(
argument|process
argument_list|,
argument|signo
argument_list|,
argument|current_group
argument_list|,
argument|nomsg
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|process
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|current_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nomsg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
name|int
name|gid
decl_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|childp
argument_list|)
condition|)
name|error
argument_list|(
literal|"Process %s is not a subprocess"
argument_list|,
name|XSTRING
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
condition|)
name|error
argument_list|(
literal|"Process %s is not active"
argument_list|,
name|XSTRING
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGPGRP
comment|/* Not sure about this! (fnf) */
comment|/* If we are using pgrps, get a pgrp number and make it negative.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_group
argument_list|)
condition|)
block|{
name|ioctl
argument_list|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|gid
argument_list|)
expr_stmt|;
name|gid
operator|=
operator|-
name|gid
expr_stmt|;
block|}
else|else
name|gid
operator|=
operator|-
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not using pgrps */
comment|/* Can't select pgrps on this system, so we know that      the child itself heads the pgrp.  */
name|gid
operator|=
operator|-
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not using pgrps */
switch|switch
condition|(
name|signo
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGCONT
case|case
name|SIGCONT
case|:
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|=
name|RUNNING
operator||
name|CHANGED
expr_stmt|;
name|child_changed
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIGINT
case|:
case|case
name|SIGQUIT
case|:
case|case
name|SIGKILL
case|:
name|flush_pending_output
argument_list|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* gid may be a pid, or minus a pgrp's number */
ifdef|#
directive|ifdef
name|BSD
comment|/* On bsd, [man says] kill does not accept a negative number to kill a pgrp.      Must do that differently.  */
name|killpg
argument_list|(
operator|-
name|gid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Not BSD.  */
name|kill
argument_list|(
name|gid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not BSD.  */
comment|/* Put notices in buffers now, since it is safe now.      Because of this, we know that a process we have just killed      will never need to use its buffer again.  */
if|if
condition|(
operator|!
name|nomsg
condition|)
name|change_msgs
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"interrupt-process"
argument_list|,
argument|Finterrupt_process
argument_list|,
argument|Sinterrupt_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Interrupt process PROCESS.  May be process or name of one.\n\ Nil or no arg means current buffer's process.\n\ Second arg CURRENT-GROUP non-nil means send signal to\n\ the current process-group of the process's controlling terminal\n\ rather than to the process's own process group.\n\ If the process is a shell, this means interrupt current subjob\n\ rather than the shell."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sig_process
argument_list|(
name|process
argument_list|,
name|SIGINT
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"kill-process"
argument_list|,
argument|Fkill_process
argument_list|,
argument|Skill_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Kill process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sig_process
argument_list|(
name|process
argument_list|,
name|SIGKILL
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"quit-process"
argument_list|,
argument|Fquit_process
argument_list|,
argument|Squit_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Send QUIT signal to process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|sig_process
argument_list|(
name|process
argument_list|,
name|SIGQUIT
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"stop-process"
argument_list|,
argument|Fstop_process
argument_list|,
argument|Sstop_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Stop process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|SIGTSTP
name|error
argument_list|(
literal|"no SIGTSTP support"
argument_list|)
expr_stmt|;
else|#
directive|else
name|sig_process
argument_list|(
name|process
argument_list|,
name|SIGTSTP
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"continue-process"
argument_list|,
argument|Fcontinue_process
argument_list|,
argument|Scontinue_process
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Continue process PROCESS.  May be process or name of one.\n\ See function interrupt-process for more details on usage."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|,
name|current_group
operator|)
name|Lisp_Object
name|process
operator|,
name|current_group
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGCONT
name|sig_process
argument_list|(
name|process
argument_list|,
name|SIGCONT
argument_list|,
name|current_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"no SIGCONT support"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|process
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"process-send-eof"
argument_list|,
argument|Fprocess_send_eof
argument_list|,
argument|Sprocess_send_eof
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make PROCESS see end-of-file in its input.\n\ Eof comes after any text already sent to it.\n\ Nil or no arg means current buffer's process."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|process
operator|)
name|Lisp_Object
name|process
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|proc
decl_stmt|;
name|proc
operator|=
name|get_process
argument_list|(
name|process
argument_list|)
expr_stmt|;
name|send_process
argument_list|(
name|proc
argument_list|,
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
end_block

begin_comment
comment|/* Kill all processes associated with `buffer'.  If `buffer' is nil, kill all processes  */
end_comment

begin_macro
name|kill_buffer_processes
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|proc
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
name|XGCTYPE
argument_list|(
name|tail
argument_list|)
operator|==
name|Lisp_Cons
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|proc
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|XGCTYPE
argument_list|(
name|proc
argument_list|)
operator|==
name|Lisp_Process
operator|&&
operator|(
name|NULL
argument_list|(
name|buffer
argument_list|)
operator|||
name|EQ
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|buffer
argument_list|,
name|buffer
argument_list|)
operator|)
condition|)
if|if
condition|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|infd
argument_list|)
condition|)
name|sig_process
argument_list|(
name|proc
argument_list|,
name|SIGKILL
argument_list|,
name|Qnil
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|count_active_processes
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|proc
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|proc
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
name|XFASTINT
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|RUNNING
operator|)
operator||
operator|(
literal|1
operator|<<
name|STOPPED
operator|)
operator|)
operator|)
operator|&&
name|NULL
argument_list|(
name|XPROCESS
argument_list|(
name|proc
argument_list|)
operator|->
name|kill_without_query
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* On receipt of a signal that a child status has changed,  loop asking about children with changed statuses until  the system says there are no more.    All we do is change the flags components;  we do not run sentinels or print notifications.  That is saved for the next time keyboard input is done,  in order to avoid timing errors.  */
end_comment

begin_comment
comment|/** WARNING: this can be called during garbage collection.  Therefore, it must not be fooled by the presence of mark bits in  Lisp objects.  */
end_comment

begin_comment
comment|/** USG WARNING:  Although it is not obvious from the documentation  in signal(2), on a USG system the SIGCLD handler MUST NOT call  signal() before executing at least one wait(), otherwise the handler  will be called again, resulting in an infinite loop.  The relevant  portion of the documentation reads "SIGCLD signals will be queued  and the signal-catching function will be continually reentered until  the queue is empty".  Invoking signal() causes the kernel to reexamine  the SIGCLD queue.   Fred Fish, UniSoft Systems Inc. */
end_comment

begin_macro
name|child_sig
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|WAITTYPE
name|w
decl_stmt|;
name|Lisp_Object
name|tail
decl_stmt|,
name|proc
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
specifier|extern
name|int
name|synch_process_pid
decl_stmt|;
specifier|extern
name|int
name|sigheld
decl_stmt|;
name|sigheld
operator||=
name|sigbit
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loop
label|:
ifdef|#
directive|ifdef
name|WNOHANG
ifndef|#
directive|ifndef
name|WUNTRACED
define|#
directive|define
name|WUNTRACED
value|0
endif|#
directive|endif
comment|/* no WUNTRACED */
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
ifdef|#
directive|ifdef
name|USG
name|signal
argument_list|(
name|signo
argument_list|,
name|child_sig
argument_list|)
expr_stmt|;
comment|/* WARNING - must come after wait3() */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_1
name|sigheld
operator|&=
operator|~
name|sigbit
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
else|#
directive|else
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no WNOHANG */
ifdef|#
directive|ifdef
name|BSD4_1
if|if
condition|(
name|synch_process_pid
operator|==
name|pid
condition|)
name|synch_process_pid
operator|=
literal|0
expr_stmt|;
comment|/* Zero it to show process has died. */
endif|#
directive|endif
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|!=
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|proc
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|childp
argument_list|)
operator|&&
name|XFASTINT
argument_list|(
name|p
operator|->
name|pid
argument_list|)
operator|==
name|pid
condition|)
break|break;
block|}
if|if
condition|(
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|USG
goto|goto
name|ignore
goto|;
else|#
directive|else
goto|goto
name|loop
goto|;
comment|/* We don't know who this is */
endif|#
directive|endif
name|child_changed
operator|++
expr_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|=
name|STOPPED
operator||
name|CHANGED
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
operator|=
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|=
name|EXITED
operator||
name|CHANGED
expr_stmt|;
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|w
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator||=
name|COREDUMPED
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
operator|=
name|WRETCODE
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|=
name|SIGNALED
operator||
name|CHANGED
expr_stmt|;
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|w
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator||=
name|COREDUMPED
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
operator|=
name|WTERMSIG
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|USG
goto|goto
name|loop
goto|;
else|#
directive|else
name|ignore
label|:
name|signal
argument_list|(
name|signo
argument_list|,
name|child_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not USG */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Find all process marked as "changed"   and notify the user in a suitable fashion   (either run the sentinel or output a message).   This is done while Emacs is waiting for keyboard input */
end_comment

begin_macro
name|change_msgs
argument_list|()
end_macro

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|proc
decl_stmt|,
name|buffer
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|char
name|line
index|[
literal|50
index|]
decl_stmt|;
name|int
name|opoint
decl_stmt|;
name|child_changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vprocess_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|proc
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|CHANGED
operator|)
condition|)
continue|continue;
comment|/* If process is still active, read any output that remains.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
condition|)
name|read_process_output
argument_list|(
name|proc
argument_list|,
name|XFASTINT
argument_list|(
name|p
operator|->
name|infd
argument_list|)
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&=
operator|~
name|CHANGED
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
operator|)
operator|==
name|SIGNALED
operator|||
operator|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
operator|)
operator|==
name|STOPPED
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s%s\n"
argument_list|,
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
operator|<
name|NSIG
condition|?
name|sys_siglist
index|[
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
index|]
else|:
literal|"unknown"
argument_list|,
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|COREDUMPED
condition|?
literal|" (core dumped)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|line
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|line
index|[
literal|0
index|]
operator|+=
literal|040
expr_stmt|;
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
operator|)
operator|==
name|SIGNALED
condition|)
if|if
condition|(
name|delete_exited_processes
condition|)
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
else|else
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|flags
argument_list|)
operator|&
name|PROC_STATUS
operator|)
operator|==
name|EXITED
condition|)
block|{
if|if
condition|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
condition|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"exited abnormally with code %d\n"
argument_list|,
name|XFASTINT
argument_list|(
name|p
operator|->
name|reason
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"finished\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_exited_processes
condition|)
name|remove_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
else|else
name|deactivate_process
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|sentinel
argument_list|)
condition|)
name|exec_sentinel
argument_list|(
name|proc
argument_list|,
name|build_string
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|&&
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
comment|/* Avoid error if buffer is deleted 	     (probably that's why the process is dead, too) */
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|Fset_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|opoint
operator|=
name|point
expr_stmt|;
name|SetPoint
argument_list|(
name|NumCharacters
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|opoint
condition|)
name|opoint
operator|=
operator|-
literal|1
expr_stmt|;
name|InsStr
argument_list|(
literal|"\nProcess "
argument_list|)
expr_stmt|;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|opoint
operator|>
literal|0
condition|)
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end for */
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
comment|/* in case buffers use %s in mode-line-format */
name|DoDsp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|exec_sentinel
argument_list|(
argument|proc
argument_list|,
argument|reason
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|proc
decl_stmt|,
name|reason
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|sentinel
decl_stmt|;
specifier|register
name|struct
name|Lisp_Process
modifier|*
name|p
init|=
name|XPROCESS
argument_list|(
name|proc
argument_list|)
decl_stmt|;
name|sentinel
operator|=
name|p
operator|->
name|sentinel
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|sentinel
argument_list|)
condition|)
return|return;
name|p
operator|->
name|sentinel
operator|=
name|Qnil
expr_stmt|;
name|call2
argument_list|(
name|sentinel
argument_list|,
name|proc
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|p
operator|->
name|sentinel
operator|=
name|sentinel
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_process
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|child_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|input_wait_mask
operator|=
name|ChannelMask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Vprocess_alist
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXDESC
condition|;
name|i
operator|++
control|)
block|{
name|chan_process
index|[
name|i
index|]
operator|=
name|Qnil
expr_stmt|;
name|proc_buffered_char
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|syms_of_process
argument_list|()
end_macro

begin_block
block|{
name|Qprocessp
operator|=
name|intern
argument_list|(
literal|"processp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qprocessp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vprocess_alist
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"delete-exited-processes"
argument_list|,
operator|&
name|delete_exited_processes
argument_list|,
literal|"*Non-nil means delete processes immediately when they exit.\n\ nil means don't delete them until list-processes is done."
argument_list|)
expr_stmt|;
name|delete_exited_processes
operator|=
literal|1
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocessp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_buffer_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_status
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_id
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_command
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_process_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_mark
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_process_filter
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_filter
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_process_sentinel
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_sentinel
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_kill_without_query
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slist_processes
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstart_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Saccept_process_output
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssend_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssend_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinterrupt_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skill_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Squit_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstop_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scontinue_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprocess_send_eof
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|subprocesses
end_endif

end_unit

