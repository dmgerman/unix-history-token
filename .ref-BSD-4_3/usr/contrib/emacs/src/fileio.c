begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File IO for GNU Emacs.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* Nonzero during writing of auto-save files */
end_comment

begin_decl_stmt
name|int
name|auto_saving
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means, when reading a filename in the minibuffer,  start out by inserting the default directory into the minibuffer. */
end_comment

begin_decl_stmt
name|int
name|insert_default_directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qfile_error
decl_stmt|,
name|Qfile_already_exists
decl_stmt|;
end_decl_stmt

begin_macro
name|report_file_error
argument_list|(
argument|string
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|errstring
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|errstring
operator|=
name|build_string
argument_list|(
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
name|errstring
operator|=
name|build_string
argument_list|(
literal|"undocumented error code"
argument_list|)
expr_stmt|;
comment|/* System error messages are capitalized.  Downcase the initial. */
if|if
condition|(
name|XSTRING
argument_list|(
name|errstring
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|XSTRING
argument_list|(
name|errstring
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|XSTRING
argument_list|(
name|errstring
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|+=
literal|040
expr_stmt|;
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qfile_error
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|string
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|errstring
argument_list|,
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-directory"
argument_list|,
argument|Ffile_name_directory
argument_list|,
argument|Sfile_name_directory
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the directory component in file name NAME.\n\ Return nil if NAME does not include a directory.\n\ Otherwise return a string ending in a slash."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|beg
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
expr_stmt|;
name|p
operator|=
name|beg
operator|+
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|beg
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|beg
condition|)
return|return
name|Qnil
return|;
return|return
name|make_string
argument_list|(
name|beg
argument_list|,
name|p
operator|-
name|beg
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-nondirectory"
argument_list|,
argument|Ffile_name_nondirectory
argument_list|,
argument|Sfile_name_nondirectory
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return file name NAME sans its directory.\n\ This is everything after the last slash in NAME, if NAME contains a slash."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|p
operator|=
name|beg
operator|+
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|beg
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
return|return
name|make_string
argument_list|(
name|p
argument_list|,
name|end
operator|-
name|p
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"make-temp-name"
argument_list|,
argument|Fmake_temp_name
argument_list|,
argument|Smake_temp_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Generate temporary name (string) starting with PREFIX (a string)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prefix
operator|)
name|Lisp_Object
name|prefix
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|concat2
argument_list|(
name|prefix
argument_list|,
name|build_string
argument_list|(
literal|"XXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"expand-file-name"
argument_list|,
argument|Fexpand_file_name
argument_list|,
argument|Sexpand_file_name
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Convert FILENAME to absolute, and canonicalize it.\n\ Second arg DEFAULT is directory to start with if FILENAME is relative\n\  (does not start with slash); if DEFAULT is nil or missing,\n\ the current buffer's value of default-directory is used.\n\ Filenames containing . or .. as components are simplified;\n\ initial ~ is expanded.  See also the function  substitute-in-file-name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|defalt
operator|)
name|Lisp_Object
name|name
operator|,
name|defalt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|nm
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|newdir
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|target
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm
operator|=
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
expr_stmt|;
comment|/* If nm is absolute, flush ...// and detect /./ and /../.      If no /./ or /../ we can return right away. */
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|=
name|nm
expr_stmt|;
name|lose
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of filename is meaningful on Apollo system */
operator|&&
name|nm
operator|!=
name|p
endif|#
directive|endif
comment|/* APOLLO */
condition|)
name|nm
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
name|nm
operator|=
name|p
operator|+
literal|1
operator|,
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lose
condition|)
block|{
if|if
condition|(
name|nm
operator|==
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
condition|)
return|return
name|name
return|;
return|return
name|build_string
argument_list|(
name|nm
argument_list|)
return|;
block|}
block|}
comment|/* Now determine directory to start with and put it in newdir */
name|newdir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
comment|/* prefix ~ */
if|if
condition|(
name|nm
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|nm
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* ~/filename */
block|{
if|if
condition|(
operator|!
operator|(
name|newdir
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
condition|)
name|newdir
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|""
expr_stmt|;
name|nm
operator|++
expr_stmt|;
block|}
else|else
comment|/* ~user/filename */
block|{
for|for
control|(
name|p
operator|=
name|nm
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|o
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|nm
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nm
argument_list|,
name|o
argument_list|,
name|p
operator|-
name|nm
argument_list|)
expr_stmt|;
name|o
index|[
name|p
operator|-
name|nm
index|]
operator|=
literal|0
expr_stmt|;
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
name|error
argument_list|(
literal|"\"%s\" isn't a registered user"
argument_list|,
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nm
operator|=
name|p
expr_stmt|;
name|newdir
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pw
operator|->
name|pw_dir
expr_stmt|;
block|}
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
operator|!
name|newdir
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|defalt
argument_list|)
condition|)
name|defalt
operator|=
name|bf_cur
operator|->
name|directory
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|defalt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newdir
operator|=
name|XSTRING
argument_list|(
name|defalt
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
comment|/* Now concatenate the directory and name to new space in thestack frame */
name|tlen
operator|=
operator|(
name|newdir
condition|?
name|strlen
argument_list|(
name|newdir
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|target
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newdir
condition|)
block|{
name|strcpy
argument_list|(
name|target
argument_list|,
name|newdir
argument_list|)
expr_stmt|;
comment|/* Make sure there is a slash to separate directory from following */
if|if
condition|(
name|target
index|[
name|strlen
argument_list|(
name|target
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|nm
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|nm
index|[
literal|0
index|]
condition|)
name|strcat
argument_list|(
name|target
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|target
argument_list|,
name|nm
argument_list|)
expr_stmt|;
comment|/* Now canonicalize by removing /. and /foo/.. if they appear */
name|p
operator|=
name|target
expr_stmt|;
name|o
operator|=
name|target
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
block|{
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"//"
argument_list|,
literal|2
argument_list|)
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of filename is meaningful in Apollo system */
operator|&&
name|o
operator|!=
name|target
endif|#
directive|endif
comment|/* APOLLO */
condition|)
block|{
name|o
operator|=
name|target
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"/.."
argument_list|,
literal|3
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
name|o
operator|!=
name|target
operator|&&
operator|*
operator|--
name|o
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|make_string
argument_list|(
name|target
argument_list|,
name|o
operator|-
name|target
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"substitute-in-file-name"
argument_list|,
argument|Fsubstitute_in_file_name
argument_list|,
argument|Ssubstitute_in_file_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Substitute environment variables referred to in STRING.\n\ A $ begins a request to substitute; the env variable name is\n\ the alphanumeric characters after the $, or else is surrounded by braces.\n\ If a ~ appears following a /, everything through that / is discarded."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|)
name|Lisp_Object
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|nm
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|o
decl_stmt|,
modifier|*
name|x
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xnm
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
expr_stmt|;
name|endp
operator|=
name|nm
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* If /~ or // appears, discard everything through first slash. */
for|for
control|(
name|p
operator|=
name|nm
init|;
name|p
operator|!=
name|endp
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
operator|||
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of file name is meaningful in Apollo system */
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
operator|-
literal|1
operator|!=
name|nm
operator|)
else|#
directive|else
comment|/* not APOLLO */
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
endif|#
directive|endif
comment|/* not APOLLO */
operator|)
operator|&&
name|p
operator|!=
name|nm
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|nm
operator|=
name|p
expr_stmt|;
name|total
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* See if any variables are substituted into the string      and find the total length of their values in `total' */
for|for
control|(
name|p
operator|=
name|nm
init|;
name|p
operator|!=
name|endp
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|endp
condition|)
goto|goto
name|badsubst
goto|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|o
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
goto|goto
name|missingclose
goto|;
name|s
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|o
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
block|}
comment|/* Copy out the variable name */
name|target
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|s
operator|-
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|target
argument_list|,
name|o
argument_list|,
name|s
operator|-
name|o
argument_list|)
expr_stmt|;
name|target
index|[
name|s
operator|-
name|o
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Get variable value */
name|o
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|getenv
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* The presence of this code makes vax 5.0 crash, for reasons yet unknown */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|USG
block|if (!o&& !strcmp (target, "USER")) 	  o = (unsigned char *) getenv ("LOGNAME");
endif|#
directive|endif
comment|/* USG */
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
operator|!
name|o
condition|)
goto|goto
name|badvar
goto|;
name|total
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|total
condition|)
return|return
name|string
return|;
comment|/* If substitution required, recopy the string and do it */
comment|/* Make space in stack frame for the new copy */
name|xnm
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|+
name|total
operator|+
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|xnm
expr_stmt|;
comment|/* Copy the rest of the name through, replacing $ constructs with values */
for|for
control|(
name|p
operator|=
name|nm
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|endp
condition|)
goto|goto
name|badsubst
goto|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|o
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
goto|goto
name|missingclose
goto|;
name|s
operator|=
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|o
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
block|}
comment|/* Copy out the variable name */
name|target
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|s
operator|-
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|target
argument_list|,
name|o
argument_list|,
name|s
operator|-
name|o
argument_list|)
expr_stmt|;
name|target
index|[
name|s
operator|-
name|o
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Get variable value */
name|o
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|getenv
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* The presence of this code makes vax 5.0 crash, for reasons yet unknown */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|USG
block|if (!o&& !strcmp (target, "USER")) 	  o = (unsigned char *) getenv ("LOGNAME");
endif|#
directive|endif
comment|/* USG */
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
operator|!
name|o
condition|)
goto|goto
name|badvar
goto|;
name|strcpy
argument_list|(
name|x
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|x
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|x
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|x
operator|=
literal|0
expr_stmt|;
comment|/* If /~ or // appears, discard everything through first slash. */
for|for
control|(
name|p
operator|=
name|xnm
init|;
name|p
operator|!=
name|x
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
operator|||
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of file name is meaningful in Apollo system */
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
operator|-
literal|1
operator|!=
name|xnm
operator|)
else|#
directive|else
comment|/* not APOLLO */
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
endif|#
directive|endif
comment|/* not APOLLO */
operator|)
operator|&&
name|p
operator|!=
name|nm
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|xnm
operator|=
name|p
expr_stmt|;
return|return
name|make_string
argument_list|(
name|xnm
argument_list|,
name|x
operator|-
name|xnm
argument_list|)
return|;
name|badsubst
label|:
name|error
argument_list|(
literal|"Bad format environment-variable substitution"
argument_list|)
expr_stmt|;
name|missingclose
label|:
name|error
argument_list|(
literal|"Missing \"}\" in environment-variable substitution"
argument_list|)
expr_stmt|;
name|badvar
label|:
name|error
argument_list|(
literal|"Substituting nonexistent environment variable %s"
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_escape
end_escape

begin_macro
name|barf_or_query_if_file_exists
argument_list|(
argument|absname
argument_list|,
argument|querystring
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|absname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|querystring
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|absname
argument_list|)
operator|->
name|data
argument_list|,
literal|4
argument_list|)
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
name|Finteractive_p
argument_list|()
operator|)
operator|||
operator|(
name|tem
operator|=
name|Fyes_or_no_p
argument_list|(
name|format1
argument_list|(
literal|"File %s already exists; %s anyway? "
argument_list|,
name|XSTRING
argument_list|(
name|absname
argument_list|)
operator|->
name|data
argument_list|,
name|querystring
argument_list|)
argument_list|)
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
name|Fsignal
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Fcons
argument_list|(
name|absname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"copy-file"
argument_list|,
argument|Fcopy_file
argument_list|,
argument|Scopy_file
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"fCopy file: \nFCopy %s to file: "
argument_list|,
literal|"Copy FILE to NEWNAME.  Both args strings.\n\ Signals a  file-already-exists  error if NEWNAME already exists,\n\ unless a third argument OK-IF-ALREADY-EXISTS is supplied and non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ifd
decl_stmt|,
name|ofd
decl_stmt|,
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"copy to it"
argument_list|)
expr_stmt|;
name|ifd
operator|=
name|open
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening input file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|ofd
operator|=
name|creat
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofd
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Opening output file"
argument_list|,
name|Fcons
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|ofd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|ifd
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD4_1
argument_list|)
name|fchmod
argument_list|(
name|ofd
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
else|#
directive|else
name|chmod
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-file"
argument_list|,
argument|Fdelete_file
argument_list|,
argument|Sdelete_file
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"fDelete file: "
argument_list|,
literal|"Delete specified file.  One argument, a file name string.\n\ If file has multiple names, it continues to exist with the other names."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|unlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|)
condition|)
name|report_file_error
argument_list|(
literal|"Removing old name"
argument_list|,
name|Flist
argument_list|(
literal|1
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"rename-file"
argument_list|,
argument|Frename_file
argument_list|,
argument|Srename_file
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"fRename file: \nFRename %s to file: "
argument_list|,
literal|"Rename FILE as NEWNAME.  Both args strings.\n\ If file has names other than FILE, it continues to have those names.\n\ Signals a  file-already-exists  error if NEWNAME already exists\n\ unless optional third argument OK-IF-ALREADY-EXISTS is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"rename to it"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD4_1
if|if
condition|(
literal|0
operator|>
name|rename
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
literal|0
operator|>
name|link
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
operator|||
literal|0
operator|>
name|unlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|)
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|errno
operator|==
name|EXDEV
condition|)
block|{
name|Fcopy_file
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|,
name|ok_if_already_exists
argument_list|)
expr_stmt|;
name|Fdelete_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
block|{
name|args
index|[
literal|0
index|]
operator|=
name|filename
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|newname
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Renaming"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|report_file_error
argument_list|(
literal|"Renaming"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"add-name-to-file"
argument_list|,
argument|Fadd_name_to_file
argument_list|,
argument|Sadd_name_to_file
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"fAdd name to file: \nFName to add to %s: "
argument_list|,
literal|"Give FILE additional name NEWNAME.  Both args strings.\n\ Signals a  file-already-exists  error if NEWNAME already exists\n\ unlesss optional third argument OK-IF-ALREADY-EXISTS is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"make it a new name"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|link
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|args
index|[
literal|0
index|]
operator|=
name|filename
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|newname
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Adding new name"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|report_file_error
argument_list|(
literal|"Adding new name"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFLNK
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"make-symbolic-link"
argument_list|,
argument|Fmake_symbolic_link
argument_list|,
argument|Smake_symbolic_link
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"FMake symbolic link to file: \nFMake symbolic link to file %s: "
argument_list|,
literal|"Make a symbolic link to FILENAME, named LINKNAME.  Both args strings.\n\ Signals a  file-already-exists  error if NEWNAME already exists\n\ unlesss optional third argument OK-IF-ALREADY-EXISTS is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"make it a link"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|symlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|args
index|[
literal|0
index|]
operator|=
name|filename
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|newname
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Making symbolic link"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|report_file_error
argument_list|(
literal|"Making symbolic link"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* S_IFLNK */
end_comment

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"file-exists-p"
argument_list|,
argument|Ffile_exists_p
argument_list|,
argument|Sfile_exists_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME exists and you can read it.\n\ Use file-attributes to check for existence not caring about readability."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
operator|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
literal|4
argument_list|)
operator|>=
literal|0
operator|)
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-writable-p"
argument_list|,
argument|Ffile_writable_p
argument_list|,
argument|Sfile_writable_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME can be written or created by you."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|,
name|dir
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
literal|2
argument_list|)
operator|>=
literal|0
operator|)
condition|?
name|Qt
else|:
name|Qnil
return|;
name|dir
operator|=
name|Ffile_name_directory
argument_list|(
name|abspath
argument_list|)
expr_stmt|;
return|return
operator|(
name|access
argument_list|(
operator|!
name|NULL
argument_list|(
name|dir
argument_list|)
condition|?
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
else|:
literal|""
argument_list|,
literal|2
argument_list|)
operator|>=
literal|0
condition|?
name|Qt
else|:
name|Qnil
operator|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-symlink-p"
argument_list|,
argument|Ffile_symlink_p
argument_list|,
argument|Sfile_symlink_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"If file FILENAME is the name of a symbolic link\n\ returns the name of the file to which it is linked.\n\ Otherwise returns NIL."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|int
name|valsize
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|100
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|valsize
operator|=
name|readlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|valsize
operator|<
name|bufsize
condition|)
break|break;
comment|/* Buffer was not long enough */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bufsize
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|valsize
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
name|val
operator|=
name|make_string
argument_list|(
name|buf
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|val
return|;
else|#
directive|else
comment|/* not S_IFLNK */
return|return
name|Qnil
return|;
endif|#
directive|endif
comment|/* not S_IFLNK */
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-directory-p"
argument_list|,
argument|Ffile_directory_p
argument_list|,
argument|Sfile_directory_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME is the name of a directory."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|abspath
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|bf_cur
operator|->
name|directory
argument_list|)
expr_stmt|;
comment|/* Remove final slash, if any (unless path is root).      stat behaves differently depending!  */
if|if
condition|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|>
literal|1
operator|&&
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
index|[
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|abspath
argument_list|,
name|filename
argument_list|)
condition|)
name|abspath
operator|=
name|Fcopy_sequence
argument_list|(
name|abspath
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
index|[
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
return|return
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-modes"
argument_list|,
argument|Ffile_modes
argument_list|,
argument|Sfile_modes
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return mode bits of FILE, as an integer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|bf_cur
operator|->
name|directory
argument_list|)
expr_stmt|;
comment|/* Remove final slash, if any (unless path is the root).      stat behaves differently depending!  */
if|if
condition|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|>
literal|1
operator|&&
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
index|[
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|abspath
argument_list|,
name|filename
argument_list|)
condition|)
name|abspath
operator|=
name|Fcopy_sequence
argument_list|(
name|abspath
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
index|[
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
return|return
name|make_number
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-file-modes"
argument_list|,
argument|Fset_file_modes
argument_list|,
argument|Sset_file_modes
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set mode bits of FILE to MODE (an integer).\n\ Only the 12 low bits of MODE are used."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|mode
operator|)
name|Lisp_Object
name|filename
operator|,
name|mode
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|bf_cur
operator|->
name|directory
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
name|XINT
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Doing chmod"
argument_list|,
name|Fcons
argument_list|(
name|abspath
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|close_file_unwind
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|close
argument_list|(
name|XFASTINT
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert-file-contents"
argument_list|,
argument|Finsert_file_contents
argument_list|,
argument|Sinsert_file_contents
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Insert contents of file FILENAME after point.\n\ Returns list of absolute pathname and length of data inserted.\n\ If second argument VISIT is non-nil, the buffer's\n\ visited filename and last save file modtime are set,\n\ and it is marked unmodified."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|visit
operator|)
name|Lisp_Object
name|filename
operator|,
name|visit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|)
name|Fbarf_if_buffer_read_only
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening input file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|close_file_unwind
argument_list|,
name|make_number
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
name|RecordInsert
argument_list|(
name|point
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|bf_modified
operator|++
expr_stmt|;
name|GapTo
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf_gap
operator|<
name|st
operator|.
name|st_size
condition|)
name|make_gap
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bf_p1
operator|+
name|bf_s1
operator|+
literal|1
argument_list|,
name|st
operator|.
name|st_size
operator|-
name|n
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bf_s1
operator|+=
name|i
expr_stmt|;
name|bf_gap
operator|-=
name|i
expr_stmt|;
name|bf_p2
operator|-=
name|i
expr_stmt|;
name|n
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
name|DoneIsDone
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Discard the unwind protect */
name|specpdl_ptr
operator|=
name|specpdl
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"IO error reading %s"
argument_list|,
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
block|{
name|bf_cur
operator|->
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|bf_cur
operator|->
name|save_modified
operator|=
name|bf_modified
expr_stmt|;
name|bf_cur
operator|->
name|auto_save_modified
operator|=
name|bf_modified
expr_stmt|;
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|save_length
argument_list|)
operator|=
name|NumCharacters
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
condition|)
name|unlock_file
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
expr_stmt|;
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|bf_cur
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
block|}
return|return
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|st
operator|.
name|st_size
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"write-region"
argument_list|,
argument|Fwrite_region
argument_list|,
argument|Swrite_region
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|"r\nFWrite region to file: "
argument_list|,
literal|"Write current region into specified file.\n\ When called from a program, takes three arguments:\n\ START, END and FILENAME.  START and END are buffer positions.\n\ Optional fourth argument APPEND if non-nil means\n\   append to existing file contents (if any).\n\ Optional fifth argument VISIT if t means\n\   set last-save-file-modtime of buffer to this file's modtime\n\   and mark buffer not modified.\n\ If VISIT is neither t nor nil, it means do not print\n\   the \"Wrote file\" message."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|start
operator|,
name|end
operator|,
name|filename
operator|,
name|append
operator|,
name|visit
operator|)
name|Lisp_Object
name|start
operator|,
name|end
operator|,
name|filename
operator|,
name|append
operator|,
name|visit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|fn
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
comment|/* Special kludge to simplify auto-saving */
if|if
condition|(
name|NULL
argument_list|(
name|start
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|start
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|end
argument_list|)
operator|=
literal|1
operator|+
name|bf_s1
operator|+
name|bf_s2
expr_stmt|;
block|}
else|else
name|validate_region
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|fn
operator|=
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|lock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|append
argument_list|)
condition|)
name|fd
operator|=
name|open
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|fd
operator|=
name|creat
argument_list|(
name|fn
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|report_file_error
argument_list|(
literal|"Opening output file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_unwind_protect
argument_list|(
name|close_file_unwind
argument_list|,
name|make_number
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|append
argument_list|)
condition|)
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|report_file_error
argument_list|(
literal|"Lseek error"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|failure
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|start
argument_list|)
operator|!=
name|XINT
argument_list|(
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|XINT
argument_list|(
name|start
argument_list|)
operator|-
literal|1
operator|<
name|bf_s1
condition|)
name|failure
operator|=
literal|0
operator|>
name|e_write
argument_list|(
name|fd
argument_list|,
operator|&
name|CharAt
argument_list|(
name|XINT
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|,
name|min
argument_list|(
name|bf_s1
operator|+
literal|1
argument_list|,
name|XINT
argument_list|(
name|end
argument_list|)
argument_list|)
operator|-
name|XINT
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|end
argument_list|)
operator|-
literal|1
operator|>
name|bf_s1
operator|&&
operator|!
name|failure
condition|)
block|{
name|tem
operator|=
name|max
argument_list|(
name|XINT
argument_list|(
name|start
argument_list|)
argument_list|,
name|bf_s1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|0
operator|>
name|e_write
argument_list|(
name|fd
argument_list|,
operator|&
name|CharAt
argument_list|(
name|tem
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|end
argument_list|)
operator|-
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Discard the unwind protect */
name|specpdl_ptr
operator|=
name|specpdl
operator|+
name|count
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
if|if
condition|(
name|failure
condition|)
name|error
argument_list|(
literal|"IO error writing %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|visit
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
name|bf_cur
operator|->
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|bf_cur
operator|->
name|save_modified
operator|=
name|bf_modified
expr_stmt|;
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|save_length
argument_list|)
operator|=
name|NumCharacters
expr_stmt|;
name|bf_cur
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|message
argument_list|(
literal|"Wrote %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|int
name|e_write
parameter_list|(
name|fd
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|write
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
operator|-
name|len
return|;
else|else
block|{
name|p
operator|=
name|buf
expr_stmt|;
name|end
operator|=
name|p
operator|+
sizeof|sizeof
name|buf
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|!=
sizeof|sizeof
name|buf
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|=
name|buf
expr_stmt|;
block|}
operator|*
name|p
operator|=
operator|*
name|addr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\015'
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|buf
condition|)
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
operator|!=
name|p
operator|-
name|buf
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"verify-visited-file-modtime"
argument_list|,
argument|Fverify_visited_file_modtime
argument_list|,
argument|Sverify_visited_file_modtime
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if last mod time of BUF's visited file matches what BUF records.\n\ This means that the file has not been changed since it was visited or saved."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buf
operator|)
name|Lisp_Object
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|b
init|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|b
operator|->
name|filename
argument_list|)
operator|!=
name|Lisp_String
condition|)
return|return
name|Qt
return|;
if|if
condition|(
operator|!
name|b
operator|->
name|modtime
condition|)
return|return
name|Qt
return|;
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|b
operator|->
name|filename
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|!=
name|b
operator|->
name|modtime
condition|)
return|return
name|Qnil
return|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"clear-visited-file-modtime"
argument_list|,
argument|Fclear_visited_file_modtime
argument_list|,
argument|Sclear_visited_file_modtime
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Clear out records of last mod time of visited file.\n\ Next attempt to save will certainly not complain of a discrepancy."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|bf_cur
operator|->
name|modtime
operator|=
literal|0
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_function
name|Lisp_Object
name|auto_save_error
parameter_list|()
block|{
return|return
name|Qnil
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|auto_save_1
parameter_list|()
block|{
return|return
name|Fwrite_region
argument_list|(
name|Qnil
argument_list|,
name|Qnil
argument_list|,
name|bf_cur
operator|->
name|auto_save_file_name
argument_list|,
name|Qnil
argument_list|,
name|Qlambda
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"do-auto-save"
argument_list|,
argument|Fdo_auto_save
argument_list|,
argument|Sdo_auto_save
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Auto-save all buffers that need it.\n\ This is all buffers that have auto-saving enabled\n\ and are changed since last auto-saved.\n\ Auto-saving writes the buffer into a file\n\ so that your editing is not lost if the system crashes.\n\ This file is not the file you visited; that changes only when you save.\n\n\ Non-nil argument means do not print any message."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nomsg
operator|)
name|Lisp_Object
name|nomsg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|;
name|int
name|auto_saved
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|omessage
init|=
name|minibuf_message
decl_stmt|;
extern|extern MinibufDepth;
name|auto_saving
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MinibufDepth
condition|)
name|nomsg
operator|=
name|Qt
expr_stmt|;
name|bf_cur
operator|->
name|text
operator|=
name|bf_text
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
name|XGCTYPE
argument_list|(
name|tail
argument_list|)
operator|==
name|Lisp_Cons
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|buf
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Check for auto save enabled 	 and file changed since last auto save 	 and file changed since last real save.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|b
operator|->
name|auto_save_file_name
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|b
operator|->
name|save_modified
operator|<
name|b
operator|->
name|text
operator|.
name|modified
operator|&&
name|b
operator|->
name|auto_save_modified
operator|<
name|b
operator|->
name|text
operator|.
name|modified
condition|)
block|{
if|if
condition|(
name|XFASTINT
argument_list|(
name|b
operator|->
name|save_length
argument_list|)
operator|*
literal|10
operator|>
operator|(
name|b
operator|->
name|text
operator|.
name|size1
operator|+
name|b
operator|->
name|text
operator|.
name|size2
operator|)
operator|*
literal|13
condition|)
block|{
comment|/* It has shrunk too much; don't chckpoint. */
comment|/*** Should report this to user somehow ***/
continue|continue;
block|}
name|SetBfp
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auto_saved
operator|&&
name|NULL
argument_list|(
name|nomsg
argument_list|)
condition|)
name|message1
argument_list|(
literal|"Auto-saving..."
argument_list|)
expr_stmt|;
name|internal_condition_case
argument_list|(
name|auto_save_1
argument_list|,
name|Qt
argument_list|,
name|auto_save_error
argument_list|)
expr_stmt|;
name|auto_saved
operator|++
expr_stmt|;
name|b
operator|->
name|auto_save_modified
operator|=
name|b
operator|->
name|text
operator|.
name|modified
expr_stmt|;
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|save_length
argument_list|)
operator|=
name|NumCharacters
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|auto_saved
operator|&&
name|NULL
argument_list|(
name|nomsg
argument_list|)
condition|)
name|message1
argument_list|(
name|omessage
condition|?
name|omessage
else|:
literal|"Auto-saving...done"
argument_list|)
expr_stmt|;
name|auto_saving
operator|=
literal|0
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-buffer-auto-saved"
argument_list|,
argument|Fset_buffer_auto_saved
argument_list|,
argument|Sset_buffer_auto_saved
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Mark current buffer as auto-saved with its current text.\n\ No auto-save file will be written until the buffer changes again."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|bf_cur
operator|->
name|auto_save_modified
operator|=
name|bf_modified
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"recent-auto-save-p"
argument_list|,
argument|Frecent_auto_save_p
argument_list|,
argument|Srecent_auto_save_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return t if buffer has been auto-saved since last read in or saved."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
operator|(
name|bf_cur
operator|->
name|save_modified
operator|<
name|bf_cur
operator|->
name|auto_save_modified
operator|)
operator|?
name|Qt
operator|:
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Reading and completing file names */
end_comment

begin_decl_stmt
specifier|extern
name|Lisp_Object
name|Ffile_name_completion
argument_list|()
decl_stmt|,
name|Ffile_name_all_completions
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"read-file-name-internal"
argument_list|,
argument|Fread_file_name_internal
argument_list|,
argument|Sread_file_name_internal
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Internal subroutine for read-file-name.  Do not call this."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|dir
operator|,
name|action
operator|)
name|Lisp_Object
name|string
operator|,
name|dir
operator|,
name|action
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* action is nil for complete, t for return list of completions,      lambda for verify final value */
end_comment

begin_block
block|{
name|Lisp_Object
name|name
decl_stmt|,
name|specdir
decl_stmt|,
name|realdir
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|string
expr_stmt|;
name|realdir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|action
argument_list|,
name|Qlambda
argument_list|)
condition|)
return|return
name|Qnil
return|;
block|}
else|else
block|{
name|string
operator|=
name|Fsubstitute_in_file_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|name
operator|=
name|Ffile_name_nondirectory
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|realdir
operator|=
name|Ffile_name_directory
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|realdir
argument_list|)
condition|)
name|realdir
operator|=
name|dir
expr_stmt|;
else|else
name|realdir
operator|=
name|Fexpand_file_name
argument_list|(
name|realdir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|action
argument_list|)
condition|)
block|{
name|specdir
operator|=
name|Ffile_name_directory
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|val
operator|=
name|Ffile_name_completion
argument_list|(
name|name
argument_list|,
name|realdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|val
argument_list|)
operator|==
name|Lisp_String
operator|&&
operator|!
name|NULL
argument_list|(
name|specdir
argument_list|)
condition|)
return|return
name|concat2
argument_list|(
name|specdir
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|action
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Ffile_name_all_completions
argument_list|(
name|name
argument_list|,
name|realdir
argument_list|)
return|;
comment|/* Only other case actually used is ACTION = lambda */
return|return
name|Ffile_exists_p
argument_list|(
name|string
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-file-name"
argument_list|,
argument|Fread_file_name
argument_list|,
argument|Sread_file_name
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Read file name, prompting with PROMPT and completing in directory DIR.\n\ Value is not expanded!  You must call expand-file-name yourself.\n\ Default name to DEFAULT if user enters a null string.\n\ Fourth arg MUSTMATCH non-nil means require existing file's name.\n\  Non-nil and non-t means also require confirmation after completion.\n\ DIR defaults to current buffer's directory default."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|dir
operator|,
name|defalt
operator|,
name|mustmatch
operator|)
name|Lisp_Object
name|prompt
operator|,
name|dir
operator|,
name|defalt
operator|,
name|mustmatch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|,
name|insdef
decl_stmt|,
name|tem
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
specifier|register
name|char
modifier|*
name|homedir
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|dir
argument_list|)
condition|)
name|dir
operator|=
name|bf_cur
operator|->
name|directory
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|defalt
argument_list|)
condition|)
name|defalt
operator|=
name|bf_cur
operator|->
name|filename
expr_stmt|;
comment|/* If dir starts with user's homedir, change that to ~. */
name|homedir
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|dir
argument_list|)
operator|==
name|Lisp_String
operator|&&
operator|!
name|strncmp
argument_list|(
name|homedir
argument_list|,
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
argument_list|,
name|strlen
argument_list|(
name|homedir
argument_list|)
argument_list|)
operator|&&
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
index|[
name|strlen
argument_list|(
name|homedir
argument_list|)
index|]
operator|==
literal|'/'
condition|)
block|{
name|dir
operator|=
name|make_string
argument_list|(
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
operator|+
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|-
literal|1
argument_list|,
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|size
operator|-
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'~'
expr_stmt|;
block|}
if|if
condition|(
name|insert_default_directory
condition|)
name|insdef
operator|=
name|dir
expr_stmt|;
else|else
name|insdef
operator|=
name|build_string
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|GCPRO2
argument_list|(
name|insdef
argument_list|,
name|defalt
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|intern
argument_list|(
literal|"read-file-name-internal"
argument_list|)
argument_list|,
name|dir
argument_list|,
name|mustmatch
argument_list|,
name|insert_default_directory
condition|?
name|insdef
else|:
name|Qnil
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"No file name specified"
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|val
argument_list|,
name|insdef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|defalt
argument_list|)
condition|)
return|return
name|defalt
return|;
return|return
name|Fsubstitute_in_file_name
argument_list|(
name|val
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_fileio
argument_list|()
end_macro

begin_block
block|{
name|Qfile_error
operator|=
name|intern
argument_list|(
literal|"file-error"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qfile_error
argument_list|)
expr_stmt|;
name|Qfile_already_exists
operator|=
name|intern
argument_list|(
literal|"file-already-exists"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qfile_already_exists
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_error
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qfile_error
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_error
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"File error"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Fcons
argument_list|(
name|Qfile_error
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"File already exists"
argument_list|)
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"insert-default-directory"
argument_list|,
operator|&
name|insert_default_directory
argument_list|,
literal|"*Non-nil means when reading a filename start with default dir in minibuffer."
argument_list|)
expr_stmt|;
name|insert_default_directory
operator|=
literal|1
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_directory
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_nondirectory
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_temp_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexpand_file_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubstitute_in_file_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scopy_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srename_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sadd_name_to_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_IFLNK
name|defsubr
argument_list|(
operator|&
name|Smake_symbolic_link
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* S_IFLNK */
name|defsubr
argument_list|(
operator|&
name|Sfile_exists_p
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Sfile_exists_p
argument_list|,
literal|"file-readable-p"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_writable_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_symlink_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_directory_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_modes
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_file_modes
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_file_contents
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swrite_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sverify_visited_file_modtime
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sclear_visited_file_modtime
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdo_auto_save
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_buffer_auto_saved
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecent_auto_save_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_file_name_internal
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_file_name
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

