begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Storage allocation and gc for GNU Emacs Lisp interpreter.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes of consing done since the last gc */
end_comment

begin_decl_stmt
name|int
name|consing_since_gc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes of consing since gc before another gc should be done. */
end_comment

begin_decl_stmt
name|int
name|gc_cons_threshold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero during gc */
end_comment

begin_decl_stmt
name|int
name|gc_in_progress
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|VIRT_ADDR_VARIES
end_ifndef

begin_comment
comment|/* Address below which pointers should not be traced */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|edata
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIRT_ADDR_VARIES */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VIRT_ADDR_VARIES
end_ifndef

begin_decl_stmt
specifier|extern
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
name|int
name|malloc_sbrk_used
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|VIRT_ADDR_VARIES
end_ifndef

begin_decl_stmt
specifier|extern
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
name|int
name|malloc_sbrk_unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-nil means defun should do purecopy on the function definition */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vpurify_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pure
index|[
name|PURESIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
init|=
block|{
literal|0
block|,}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force it into data space! */
end_comment

begin_define
define|#
directive|define
name|PUREBEG
value|(char *) pure
end_define

begin_comment
comment|/* Index in pure at which next pure object will be allocated. */
end_comment

begin_decl_stmt
name|int
name|pureptr
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|malloc_warning_1
parameter_list|(
name|str
parameter_list|)
name|Lisp_Object
name|str
decl_stmt|;
block|{
return|return
name|Fprinc
argument_list|(
name|str
argument_list|,
name|Vstandard_output
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* malloc calls this if it finds we are near exhausting storage */
end_comment

begin_macro
name|malloc_warning
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|build_string
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|internal_with_output_to_temp_buffer
argument_list|(
literal|" *Danger*"
argument_list|,
name|malloc_warning_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Called if malloc returns zero */
end_comment

begin_macro
name|memory_full
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Memory exhausted"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* like malloc and realloc but check for no memory left */
end_comment

begin_function
name|long
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|long
modifier|*
name|val
init|=
operator|(
name|long
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|memory_full
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|long
modifier|*
name|xrealloc
parameter_list|(
name|block
parameter_list|,
name|size
parameter_list|)
name|long
modifier|*
name|block
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|long
modifier|*
name|val
init|=
operator|(
name|long
operator|*
operator|)
name|realloc
argument_list|(
name|block
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|memory_full
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocation of cons cells */
end_comment

begin_comment
comment|/* We store cons cells inside of cons_blocks, allocating a new  cons_block with malloc whenever necessary.  Cons cells reclaimed by  GC are put on a free list to be reallocated before allocating  any new cons cells from the latest cons_block.   Each cons_block is just under 1020 bytes long,  since malloc really allocates in units of powers of two  and uses 4 bytes for its own overhead. */
end_comment

begin_define
define|#
directive|define
name|CONS_BLOCK_SIZE
define|\
value|((1020 - sizeof (struct cons_block *)) / sizeof (struct Lisp_Cons))
end_define

begin_struct
struct|struct
name|cons_block
block|{
name|struct
name|cons_block
modifier|*
name|next
decl_stmt|;
name|struct
name|Lisp_Cons
name|conses
index|[
name|CONS_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|cons_block
modifier|*
name|cons_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cons_block_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Lisp_Cons
modifier|*
name|cons_free_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_cons
parameter_list|()
block|{
name|cons_block
operator|=
operator|(
expr|struct
name|cons_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cons_block
argument_list|)
argument_list|)
expr_stmt|;
name|cons_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|cons_block
operator|->
name|conses
argument_list|,
sizeof|sizeof
name|cons_block
operator|->
name|conses
argument_list|)
expr_stmt|;
name|cons_block_index
operator|=
literal|0
expr_stmt|;
name|cons_free_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Explicitly free a cons cell.  */
end_comment

begin_macro
name|free_cons
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Lisp_Cons
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XSETCONS
argument_list|(
name|ptr
operator|->
name|car
argument_list|,
name|cons_free_list
argument_list|)
expr_stmt|;
name|cons_free_list
operator|=
name|ptr
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"cons"
argument_list|,
argument|Fcons
argument_list|,
argument|Scons
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Create a new cons, give it CAR and CDR as components, and return it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|car
operator|,
name|cdr
operator|)
name|Lisp_Object
name|car
operator|,
name|cdr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|cons_free_list
condition|)
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Cons
argument_list|,
name|cons_free_list
argument_list|)
expr_stmt|;
name|cons_free_list
operator|=
name|XCONS
argument_list|(
name|cons_free_list
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cons_block_index
operator|==
name|CONS_BLOCK_SIZE
condition|)
block|{
specifier|register
name|struct
name|cons_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|cons_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cons_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|cons_block
expr_stmt|;
name|cons_block
operator|=
name|new
expr_stmt|;
name|cons_block_index
operator|=
literal|0
expr_stmt|;
block|}
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Cons
argument_list|,
operator|&
name|cons_block
operator|->
name|conses
index|[
name|cons_block_index
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|XCONS
argument_list|(
name|val
argument_list|)
operator|->
name|car
operator|=
name|car
expr_stmt|;
name|XCONS
argument_list|(
name|val
argument_list|)
operator|->
name|cdr
operator|=
name|cdr
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Cons
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"list"
argument_list|,
argument|Flist
argument_list|,
argument|Slist
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created list whose elements are the arguments (any number)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|len
decl_stmt|,
name|val
decl_stmt|,
name|val_tail
decl_stmt|;
name|XFASTINT
argument_list|(
name|len
argument_list|)
operator|=
name|nargs
expr_stmt|;
name|val
operator|=
name|Fmake_list
argument_list|(
name|len
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|val_tail
operator|=
name|val
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|val_tail
argument_list|)
condition|)
block|{
name|XCONS
argument_list|(
name|val_tail
argument_list|)
operator|->
name|car
operator|=
operator|*
name|args
operator|++
expr_stmt|;
name|val_tail
operator|=
name|XCONS
argument_list|(
name|val_tail
argument_list|)
operator|->
name|cdr
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"make-list"
argument_list|,
argument|Fmake_list
argument_list|,
argument|Smake_list
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created list of length LENGTH, with each element being INIT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|length
operator|,
name|init
operator|)
name|Lisp_Object
name|length
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|length
argument_list|)
operator|!=
name|Lisp_Int
operator|||
name|XINT
argument_list|(
name|length
argument_list|)
operator|<
literal|0
condition|)
name|length
operator|=
name|wrong_type_argument
argument_list|(
name|Qnatnump
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|size
operator|=
name|XINT
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|val
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
name|val
operator|=
name|Fcons
argument_list|(
name|init
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Allocation of vectors */
end_comment

begin_decl_stmt
name|struct
name|Lisp_Vector
modifier|*
name|all_vectors
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"make-vector"
argument_list|,
argument|Fmake_vector
argument_list|,
argument|Smake_vector
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created vector of length LENGTH, with each element being INIT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|length
operator|,
name|init
operator|)
name|Lisp_Object
name|length
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|sizei
decl_stmt|,
name|index
decl_stmt|;
specifier|register
name|Lisp_Object
name|vector
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|length
argument_list|)
operator|!=
name|Lisp_Int
operator|||
name|XINT
argument_list|(
name|length
argument_list|)
operator|<
literal|0
condition|)
name|length
operator|=
name|wrong_type_argument
argument_list|(
name|Qnatnump
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sizei
operator|=
name|XINT
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|vector
argument_list|,
name|Lisp_Vector
argument_list|,
operator|(
expr|struct
name|Lisp_Vector
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|+
operator|(
name|sizei
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|+
operator|(
name|sizei
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XVECTOR
argument_list|(
name|vector
argument_list|)
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|size
operator|=
name|sizei
expr_stmt|;
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|next
operator|=
name|all_vectors
expr_stmt|;
name|all_vectors
operator|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|sizei
condition|;
name|index
operator|++
control|)
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
operator|=
name|init
expr_stmt|;
return|return
name|vector
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"vector"
argument_list|,
argument|Fvector
argument_list|,
argument|Svector
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created vector with our arguments (any number) as its elements."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|len
decl_stmt|,
name|val
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|p
decl_stmt|;
name|XFASTINT
argument_list|(
name|len
argument_list|)
operator|=
name|nargs
expr_stmt|;
name|val
operator|=
name|Fmake_vector
argument_list|(
name|len
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|p
operator|=
name|XVECTOR
argument_list|(
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nargs
condition|;
name|index
operator|++
control|)
name|p
operator|->
name|contents
index|[
name|index
index|]
operator|=
name|args
index|[
name|index
index|]
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Allocation of symbols.  Just like allocation of conses!   Each symbol_block is just under 1020 bytes long,  since malloc really allocates in units of powers of two  and uses 4 bytes for its own overhead. */
end_comment

begin_define
define|#
directive|define
name|SYMBOL_BLOCK_SIZE
define|\
value|((1020 - sizeof (struct symbol_block *)) / sizeof (struct Lisp_Symbol))
end_define

begin_struct
struct|struct
name|symbol_block
block|{
name|struct
name|symbol_block
modifier|*
name|next
decl_stmt|;
name|struct
name|Lisp_Symbol
name|symbols
index|[
name|SYMBOL_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|symbol_block
modifier|*
name|symbol_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symbol_block_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Lisp_Symbol
modifier|*
name|symbol_free_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_symbol
parameter_list|()
block|{
name|symbol_block
operator|=
operator|(
expr|struct
name|symbol_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_block
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|symbol_block
operator|->
name|symbols
argument_list|,
sizeof|sizeof
name|symbol_block
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|symbol_block_index
operator|=
literal|0
expr_stmt|;
name|symbol_free_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"make-symbol"
argument_list|,
argument|Fmake_symbol
argument_list|,
argument|Smake_symbol
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a newly allocated uninterned symbol whose name is NAME.\n\ Its value and function definition are void, and its property list is NIL."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_free_list
condition|)
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Symbol
argument_list|,
name|symbol_free_list
argument_list|)
expr_stmt|;
name|symbol_free_list
operator|=
name|XSYMBOL
argument_list|(
name|symbol_free_list
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|symbol_block_index
operator|==
name|SYMBOL_BLOCK_SIZE
condition|)
block|{
name|struct
name|symbol_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|symbol_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|symbol_block
expr_stmt|;
name|symbol_block
operator|=
name|new
expr_stmt|;
name|symbol_block_index
operator|=
literal|0
expr_stmt|;
block|}
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Symbol
argument_list|,
operator|&
name|symbol_block
operator|->
name|symbols
index|[
name|symbol_block_index
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|XSYMBOL
argument_list|(
name|val
argument_list|)
operator|->
name|name
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|XSYMBOL
argument_list|(
name|val
argument_list|)
operator|->
name|plist
operator|=
name|Qnil
expr_stmt|;
name|XSYMBOL
argument_list|(
name|val
argument_list|)
operator|->
name|value
operator|=
name|Qunbound
expr_stmt|;
name|XSYMBOL
argument_list|(
name|val
argument_list|)
operator|->
name|function
operator|=
name|Qunbound
expr_stmt|;
name|XSYMBOL
argument_list|(
name|val
argument_list|)
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Symbol
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Allocation of markers.  Works like allocation of conses. */
end_comment

begin_define
define|#
directive|define
name|MARKER_BLOCK_SIZE
define|\
value|((1020 - sizeof (struct marker_block *)) / sizeof (struct Lisp_Marker))
end_define

begin_struct
struct|struct
name|marker_block
block|{
name|struct
name|marker_block
modifier|*
name|next
decl_stmt|;
name|struct
name|Lisp_Marker
name|markers
index|[
name|MARKER_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|marker_block
modifier|*
name|marker_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|marker_block_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Lisp_Marker
modifier|*
name|marker_free_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_marker
parameter_list|()
block|{
name|marker_block
operator|=
operator|(
expr|struct
name|marker_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|marker_block
argument_list|)
argument_list|)
expr_stmt|;
name|marker_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|marker_block
operator|->
name|markers
argument_list|,
sizeof|sizeof
name|marker_block
operator|->
name|markers
argument_list|)
expr_stmt|;
name|marker_block_index
operator|=
literal|0
expr_stmt|;
name|marker_free_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"make-marker"
argument_list|,
argument|Fmake_marker
argument_list|,
argument|Smake_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a newly allocated marker which does not point at any place."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|val
block|;
if|if
condition|(
name|marker_free_list
condition|)
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Marker
argument_list|,
name|marker_free_list
argument_list|)
expr_stmt|;
name|marker_free_list
operator|=
name|XMARKER
argument_list|(
name|marker_free_list
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
if|if
condition|(
name|marker_block_index
operator|==
name|MARKER_BLOCK_SIZE
condition|)
block|{
name|struct
name|marker_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|marker_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|marker_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|marker_block
expr_stmt|;
name|marker_block
operator|=
name|new
expr_stmt|;
name|marker_block_index
operator|=
literal|0
expr_stmt|;
block|}
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Marker
argument_list|,
operator|&
name|marker_block
operator|->
name|markers
index|[
name|marker_block_index
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|XMARKER
argument_list|(
name|val
argument_list|)
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XMARKER
argument_list|(
name|val
argument_list|)
operator|->
name|bufpos
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XMARKER
argument_list|(
name|val
argument_list|)
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XMARKER
argument_list|(
name|val
argument_list|)
operator|->
name|chain
operator|=
name|Qnil
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Marker
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|val
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* Allocation of strings */
end_comment

begin_comment
comment|/* Strings reside inside of string_blocks.  The entire data of the string,  both the size and the contents, live in part of the `chars' component of a string_block.  The `pos' component is the index within `chars' of the first free byte */
end_comment

begin_comment
comment|/* String blocks contain this many bytes.   Power of 2, minus 4 for malloc overhead. */
end_comment

begin_define
define|#
directive|define
name|STRING_BLOCK_SIZE
value|(8188 - sizeof (struct string_block_head))
end_define

begin_comment
comment|/* A string bigger than this gets its own specially-made string block  if it doesn't fit in the current one. */
end_comment

begin_define
define|#
directive|define
name|STRING_BLOCK_OUTSIZE
value|1024
end_define

begin_macro
unit|struct
name|string_block_head
end_macro

begin_block
block|{
name|struct
name|string_block
modifier|*
name|next
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|string_block
block|{
name|struct
name|string_block
modifier|*
name|next
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|char
name|chars
index|[
name|STRING_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This points to the string block we are now allocating strings in  which is also the beginning of the chain of all string blocks ever made */
end_comment

begin_decl_stmt
name|struct
name|string_block
modifier|*
name|current_string_block
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_strings
parameter_list|()
block|{
name|current_string_block
operator|=
operator|(
expr|struct
name|string_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
argument_list|)
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
expr_stmt|;
name|current_string_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|current_string_block
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|Lisp_Object
name|make_zero_string
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"make-string"
argument_list|,
argument|Fmake_string
argument_list|,
argument|Smake_string
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created string of length LENGTH, with each element being INIT.\n\ Both LENGTH and INIT must be numbers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|length
operator|,
name|init
operator|)
name|Lisp_Object
name|length
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|length
argument_list|)
operator|!=
name|Lisp_Int
operator|||
name|XINT
argument_list|(
name|length
argument_list|)
operator|<
literal|0
condition|)
name|length
operator|=
name|wrong_type_argument
argument_list|(
name|Qnatnump
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|make_zero_string
argument_list|(
name|XINT
argument_list|(
name|length
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|init
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|make_string
parameter_list|(
name|contents
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|make_zero_string
argument_list|(
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|contents
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|build_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|make_string
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Lisp_Object
name|make_zero_string
parameter_list|(
name|length
parameter_list|,
name|init
parameter_list|)
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|init
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|fullsize
init|=
name|length
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Round `fullsize' up to multiple of size of int; also add one for terminating zero */
name|fullsize
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|fullsize
operator|&=
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fullsize
operator|<=
name|STRING_BLOCK_SIZE
operator|-
name|current_string_block
operator|->
name|pos
condition|)
comment|/* This string can fit in the current string block */
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_String
argument_list|,
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
name|current_string_block
operator|->
name|chars
operator|+
name|current_string_block
operator|->
name|pos
operator|)
argument_list|)
expr_stmt|;
name|current_string_block
operator|->
name|pos
operator|+=
name|fullsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullsize
operator|>
name|STRING_BLOCK_OUTSIZE
condition|)
comment|/* This string gets its own string block */
block|{
name|struct
name|string_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|string_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_block_head
argument_list|)
operator|+
name|fullsize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|string_block_head
argument_list|)
operator|+
name|fullsize
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|fullsize
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|current_string_block
operator|->
name|next
expr_stmt|;
name|current_string_block
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_String
argument_list|,
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
operator|(
expr|struct
name|string_block_head
operator|*
operator|)
name|new
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Make a new current string block and start it off with this string */
block|{
name|struct
name|string_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|string_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|current_string_block
expr_stmt|;
name|current_string_block
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|fullsize
expr_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_String
argument_list|,
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
name|current_string_block
operator|->
name|chars
argument_list|)
expr_stmt|;
block|}
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
operator|=
name|length
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
operator|*
name|p
operator|++
operator|=
name|init
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Must get an error if pure storage is full,  since if it cannot hold a large string  it may be able to hold conses that point to that string;  then the string is not protected from gc. */
end_comment

begin_function
name|Lisp_Object
name|make_pure_string
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|Lisp_Object
name|new
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|length
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|pureptr
operator|+
name|size
operator|>
name|PURESIZE
condition|)
name|error
argument_list|(
literal|"Pure Lisp storage exhausted"
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|new
argument_list|,
name|Lisp_String
argument_list|,
name|PUREBEG
operator|+
name|pureptr
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|new
argument_list|)
operator|->
name|size
operator|=
name|length
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|XSTRING
argument_list|(
name|new
argument_list|)
operator|->
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|new
argument_list|)
operator|->
name|data
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|pureptr
operator|+=
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|pure_cons
parameter_list|(
name|car
parameter_list|,
name|cdr
parameter_list|)
name|Lisp_Object
name|car
decl_stmt|,
name|cdr
decl_stmt|;
block|{
name|Lisp_Object
name|new
decl_stmt|;
if|if
condition|(
name|pureptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Cons
argument_list|)
operator|>
name|PURESIZE
condition|)
name|error
argument_list|(
literal|"Pure Lisp storage exhausted"
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|new
argument_list|,
name|Lisp_Cons
argument_list|,
name|PUREBEG
operator|+
name|pureptr
argument_list|)
expr_stmt|;
name|pureptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Cons
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|new
argument_list|)
operator|->
name|car
operator|=
name|Fpurecopy
argument_list|(
name|car
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|new
argument_list|)
operator|->
name|cdr
operator|=
name|Fpurecopy
argument_list|(
name|cdr
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|make_pure_vector
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
name|Lisp_Object
name|new
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
decl_stmt|;
if|if
condition|(
name|pureptr
operator|+
name|size
operator|>
name|PURESIZE
condition|)
name|error
argument_list|(
literal|"Pure Lisp storage exhausted"
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|new
argument_list|,
name|Lisp_Vector
argument_list|,
name|PUREBEG
operator|+
name|pureptr
argument_list|)
expr_stmt|;
name|pureptr
operator|+=
name|size
expr_stmt|;
name|XVECTOR
argument_list|(
name|new
argument_list|)
operator|->
name|size
operator|=
name|len
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"purecopy"
argument_list|,
argument|Fpurecopy
argument_list|,
argument|Spurecopy
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make a copy of OBJECT in pure storage.\n\ Recursively copies contents of vectors and cons cells.\n\ Does not copy symbols."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|new
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|VIRT_ADDR_VARIES
comment|/* Need not trace pointers to pure storage */
if|if
condition|(
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|edata
operator|&&
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|obj
return|;
else|#
directive|else
comment|/* VIRT_ADDR_VARIES */
if|if
condition|(
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|<
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pure
operator|+
name|PURESIZE
argument_list|)
operator|&&
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|pure
condition|)
return|return
name|obj
return|;
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_Marker
case|:
name|error
argument_list|(
literal|"Attempt to copy a marker to pure storage"
argument_list|)
expr_stmt|;
case|case
name|Lisp_Cons
case|:
return|return
name|pure_cons
argument_list|(
name|XCONS
argument_list|(
name|obj
argument_list|)
operator|->
name|car
argument_list|,
name|XCONS
argument_list|(
name|obj
argument_list|)
operator|->
name|cdr
argument_list|)
return|;
case|case
name|Lisp_String
case|:
return|return
name|make_pure_string
argument_list|(
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|size
argument_list|)
return|;
case|case
name|Lisp_Vector
case|:
name|new
operator|=
name|make_pure_vector
argument_list|(
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|XVECTOR
argument_list|(
name|new
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|Fpurecopy
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
default|default:
return|return
name|obj
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Recording what needs to be marked for gc.  */
end_comment

begin_decl_stmt
name|struct
name|gcpro
modifier|*
name|gcprolist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSTATICS
value|100
end_define

begin_decl_stmt
name|char
name|staticvec1
index|[
name|NSTATICS
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
operator|*
argument_list|)
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|staticidx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|staticvec
value|((Lisp_Object **) staticvec1)
end_define

begin_comment
comment|/* Put an entry in staticvec, pointing at the variable whose address is given */
end_comment

begin_function
name|void
name|staticpro
parameter_list|(
name|varaddress
parameter_list|)
name|Lisp_Object
modifier|*
name|varaddress
decl_stmt|;
block|{
name|staticvec
index|[
name|staticidx
operator|++
index|]
operator|=
name|varaddress
expr_stmt|;
if|if
condition|(
name|staticidx
operator|>=
name|NSTATICS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|catchtag
block|{
name|Lisp_Object
name|tag
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|struct
name|catchtag
modifier|*
name|next
decl_stmt|;
comment|/*    jmp_buf jmp;  /* We don't need this for GC purposes */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|catchtag
modifier|*
name|catchlist
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|backtrace
block|{
name|struct
name|backtrace
modifier|*
name|next
decl_stmt|;
name|Lisp_Object
modifier|*
name|function
decl_stmt|;
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
comment|/* Points to vector of args. */
name|int
name|nargs
decl_stmt|;
comment|/* length of vector */
comment|/* if nargs is UNEVALLED, args points to slot holding list of unevalled args */
name|char
name|evalargs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|backtrace
modifier|*
name|backtrace_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On vector, means it has been marked.  On string, means it has been copied.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|most_negative_fixnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On string, means do not copy it.  This is set in all copies, and perhaps will be used  to indicate strings that there is no need to copy.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dont_copy_flag
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|int
name|total_conses
decl_stmt|,
name|total_markers
decl_stmt|,
name|total_symbols
decl_stmt|,
name|total_string_size
decl_stmt|,
name|total_vector_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|total_free_conses
decl_stmt|,
name|total_free_markers
decl_stmt|,
name|total_free_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Garbage collection: mark and sweep, except copy strings. */
end_comment

begin_function_decl
specifier|static
name|Lisp_Object
name|mark_object
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|clear_marks
argument_list|()
decl_stmt|,
name|gc_sweep
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"garbage-collect"
argument_list|,
argument|Fgarbage_collect
argument_list|,
argument|Sgarbage_collect
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Reclaim storage for Lisp objects no longer needed.\n\ Returns info on amount of space in use:\n\  ((USED-CONSES . FREE-CONSES) (USED-SYMS . FREE-SYMS)\n\   (USED-MARKERS . FREE-MARKERS) USED-STRING-CHARS USED-VECTOR-SLOTS)\n\ Garbage collection happens automatically if you cons more than\n\ gc-cons-threshold  bytes of Lisp data since previous garbage collection."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{   struct
name|string_block
operator|*
name|old_string_block
block|;
specifier|register
expr|struct
name|gcpro
operator|*
name|tail
block|;
specifier|register
expr|struct
name|specbinding
operator|*
name|bind
block|;   struct
name|catchtag
operator|*
name|catch
block|;   struct
name|handler
operator|*
name|handler
block|;
specifier|register
expr|struct
name|backtrace
operator|*
name|backlist
block|;
specifier|register
name|Lisp_Object
name|tem
block|;
name|char
operator|*
name|omessage
operator|=
name|minibuf_message
block|;
specifier|register
name|int
name|i
block|;
if|if
condition|(
operator|!
name|noninteractive
condition|)
name|message1
argument_list|(
literal|"Garbage collecting..."
argument_list|)
expr_stmt|;
comment|/* Don't keep command history around forever */
name|tem
operator|=
name|Fnthcdr
argument_list|(
name|make_number
argument_list|(
literal|30
argument_list|)
argument_list|,
name|Vcommand_history
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|LISTP
argument_list|(
name|tem
argument_list|)
condition|)
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
operator|=
name|Qnil
expr_stmt|;
end_if

begin_expr_stmt
name|gc_in_progress
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_marks
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|old_string_block
operator|=
name|current_string_block
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|current_string_block
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|total_string_size
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_strings
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|tail
operator|=
name|gcprolist
init|;
name|tail
condition|;
name|tail
operator|=
name|tail
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tail
operator|->
name|nvars
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|tail
operator|->
name|var
index|[
name|i
index|]
expr_stmt|;
name|tail
operator|->
name|var
index|[
name|i
index|]
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|staticidx
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
operator|*
name|staticvec
index|[
name|i
index|]
expr_stmt|;
operator|*
name|staticvec
index|[
name|i
index|]
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|bind
operator|=
name|specpdl
init|;
name|bind
operator|!=
name|specpdl_ptr
condition|;
name|bind
operator|++
control|)
block|{
name|bind
operator|->
name|symbol
operator|=
name|mark_object
argument_list|(
name|bind
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|bind
operator|->
name|old_value
operator|=
name|mark_object
argument_list|(
name|bind
operator|->
name|old_value
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|catch
operator|=
name|catchlist
init|;
name|catch
condition|;
name|catch
operator|=
name|catch
operator|->
name|next
control|)
block|{
name|catch
operator|->
name|tag
operator|=
name|mark_object
argument_list|(
name|catch
operator|->
name|tag
argument_list|)
expr_stmt|;
name|catch
operator|->
name|val
operator|=
name|mark_object
argument_list|(
name|catch
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|handler
operator|=
name|handlerlist
init|;
name|handler
condition|;
name|handler
operator|=
name|handler
operator|->
name|next
control|)
block|{
name|handler
operator|->
name|handler
operator|=
name|mark_object
argument_list|(
name|handler
operator|->
name|handler
argument_list|)
expr_stmt|;
name|handler
operator|->
name|var
operator|=
name|mark_object
argument_list|(
name|handler
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|backlist
operator|=
name|backtrace_list
init|;
name|backlist
condition|;
name|backlist
operator|=
name|backlist
operator|->
name|next
control|)
block|{
name|tem
operator|=
operator|*
name|backlist
operator|->
name|function
expr_stmt|;
operator|*
name|backlist
operator|->
name|function
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlist
operator|->
name|nargs
operator|==
name|UNEVALLED
operator|||
name|backlist
operator|->
name|nargs
operator|==
name|MANY
condition|)
block|{
name|tem
operator|=
operator|*
name|backlist
operator|->
name|args
expr_stmt|;
operator|*
name|backlist
operator|->
name|args
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|backlist
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|backlist
operator|->
name|args
index|[
name|i
index|]
expr_stmt|;
name|backlist
operator|->
name|args
index|[
name|i
index|]
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
name|gc_sweep
argument_list|(
name|old_string_block
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_marks
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gc_in_progress
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|consing_since_gc
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|gc_cons_threshold
operator|<
literal|10000
condition|)
name|gc_cons_threshold
operator|=
literal|10000
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|omessage
condition|)
name|message1
argument_list|(
name|omessage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noninteractive
condition|)
name|message1
argument_list|(
literal|"Garbage collecting...done"
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_conses
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|total_free_conses
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_symbols
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|total_free_symbols
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_markers
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|total_free_markers
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_string_size
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_vector_size
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
end_return

begin_function
unit|}  static
name|void
name|clear_marks
parameter_list|()
block|{
comment|/* Clear marks on all strings */
block|{
specifier|register
name|struct
name|string_block
modifier|*
name|csb
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|;
for|for
control|(
name|csb
operator|=
name|current_string_block
init|;
name|csb
condition|;
name|csb
operator|=
name|csb
operator|->
name|next
control|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|csb
operator|->
name|pos
condition|)
block|{
specifier|register
name|struct
name|Lisp_String
modifier|*
name|nextstr
init|=
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|&
name|csb
operator|->
name|chars
index|[
name|pos
index|]
decl_stmt|;
specifier|register
name|int
name|fullsize
decl_stmt|;
name|nextstr
operator|->
name|size
operator|&=
operator|~
name|dont_copy_flag
expr_stmt|;
name|fullsize
operator|=
name|nextstr
operator|->
name|size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|fullsize
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|fullsize
operator|&=
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|pos
operator|+=
name|fullsize
expr_stmt|;
block|}
block|}
block|}
comment|/* Clear marks on all conses */
block|{
specifier|register
name|struct
name|cons_block
modifier|*
name|cblk
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|cons_block_index
decl_stmt|;
for|for
control|(
name|cblk
operator|=
name|cons_block
init|;
name|cblk
condition|;
name|cblk
operator|=
name|cblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
name|XUNMARK
argument_list|(
name|cblk
operator|->
name|conses
index|[
name|i
index|]
operator|.
name|car
argument_list|)
expr_stmt|;
name|lim
operator|=
name|CONS_BLOCK_SIZE
expr_stmt|;
block|}
block|}
comment|/* Clear marks on all symbols */
block|{
specifier|register
name|struct
name|symbol_block
modifier|*
name|sblk
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|symbol_block_index
decl_stmt|;
for|for
control|(
name|sblk
operator|=
name|symbol_block
init|;
name|sblk
condition|;
name|sblk
operator|=
name|sblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
name|XUNMARK
argument_list|(
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|plist
argument_list|)
expr_stmt|;
name|lim
operator|=
name|SYMBOL_BLOCK_SIZE
expr_stmt|;
block|}
block|}
comment|/* Clear marks on all markers */
block|{
specifier|register
name|struct
name|marker_block
modifier|*
name|sblk
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|marker_block_index
decl_stmt|;
for|for
control|(
name|sblk
operator|=
name|marker_block
init|;
name|sblk
condition|;
name|sblk
operator|=
name|sblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
name|XUNMARK
argument_list|(
name|sblk
operator|->
name|markers
index|[
name|i
index|]
operator|.
name|chain
argument_list|)
expr_stmt|;
name|lim
operator|=
name|MARKER_BLOCK_SIZE
expr_stmt|;
block|}
block|}
comment|/* Clear mark bits on all buffers */
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|nextb
init|=
name|all_buffers
decl_stmt|;
while|while
condition|(
name|nextb
condition|)
block|{
name|XUNMARK
argument_list|(
name|nextb
operator|->
name|name
argument_list|)
expr_stmt|;
name|nextb
operator|=
name|nextb
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark one Lisp object, and recursively mark all the objects it points to  if this is the first time it is being marked.  If the object is a string, it is copied (once, only) and the copy is returned.  The original string's `size' is set to a value in which 1<<31 is set    and the rest of which is the string address shifted right by one.  If the object is not a string, it is returned unchanged. */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|mark_object
parameter_list|(
name|obj
parameter_list|)
name|Lisp_Object
name|obj
decl_stmt|;
block|{
name|Lisp_Object
name|original
decl_stmt|;
name|original
operator|=
name|obj
expr_stmt|;
name|loop
label|:
ifndef|#
directive|ifndef
name|VIRT_ADDR_VARIES
comment|/* Need not trace pointers to pure storage */
if|if
condition|(
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|edata
operator|&&
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|original
return|;
else|#
directive|else
comment|/* VIRT_ADDR_VARIES */
if|if
condition|(
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|<
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pure
operator|+
name|PURESIZE
argument_list|)
operator|&&
name|XUINT
argument_list|(
name|obj
argument_list|)
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|pure
condition|)
return|return
name|original
return|;
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XGCTYPE
argument_list|(
name|obj
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XGCTYPE
argument_list|(
name|obj
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_String
case|:
block|{
specifier|register
name|struct
name|Lisp_String
modifier|*
name|ptr
init|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|size
operator|&
name|most_negative_fixnum
condition|)
block|{
name|XSETSTRING
argument_list|(
name|obj
argument_list|,
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
name|ptr
operator|->
name|size
operator|&
operator|~
name|most_negative_fixnum
operator|)
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
if|if
condition|(
name|ptr
operator|->
name|size
operator|&
name|dont_copy_flag
condition|)
return|return
name|obj
return|;
name|total_string_size
operator|+=
name|ptr
operator|->
name|size
expr_stmt|;
name|tem
operator|=
name|make_string
argument_list|(
name|ptr
operator|->
name|data
argument_list|,
name|ptr
operator|->
name|size
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|size
operator|=
name|most_negative_fixnum
operator||
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
operator||=
name|dont_copy_flag
expr_stmt|;
return|return
name|tem
return|;
block|}
case|case
name|Lisp_Vector
case|:
case|case
name|Lisp_Window
case|:
case|case
name|Lisp_Process
case|:
block|{
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|ptr
init|=
name|XVECTOR
argument_list|(
name|obj
argument_list|)
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|ptr
operator|->
name|size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|size
operator|&
name|most_negative_fixnum
condition|)
break|break;
comment|/* Already marked */
name|ptr
operator|->
name|size
operator||=
name|most_negative_fixnum
expr_stmt|;
comment|/* Else mark it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
comment|/* and then mark its elements */
block|{
name|tem
operator|=
name|ptr
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Lisp_Temp_Vector
case|:
block|{
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|ptr
init|=
name|XVECTOR
argument_list|(
name|obj
argument_list|)
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|ptr
operator|->
name|size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
comment|/* and then mark its elements */
block|{
name|tem
operator|=
name|ptr
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Lisp_Symbol
case|:
block|{
specifier|register
name|struct
name|Lisp_Symbol
modifier|*
name|ptr
init|=
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|struct
name|Lisp_Symbol
modifier|*
name|ptrx
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|XMARKBIT
argument_list|(
name|ptr
operator|->
name|plist
argument_list|)
condition|)
break|break;
name|XMARK
argument_list|(
name|ptr
operator|->
name|plist
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_String
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|tem
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|name
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|value
operator|=
name|mark_object
argument_list|(
name|ptr
operator|->
name|value
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|function
operator|=
name|mark_object
argument_list|(
name|ptr
operator|->
name|function
argument_list|)
expr_stmt|;
name|tem
operator|=
name|ptr
operator|->
name|plist
expr_stmt|;
name|XUNMARK
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|plist
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
name|ptr
operator|->
name|plist
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|ptrx
operator|=
name|ptr
expr_stmt|;
comment|/* Use pf ptrx avoids compiled bug on Sun */
name|XSETSYMBOL
argument_list|(
name|obj
argument_list|,
name|ptrx
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
break|break;
case|case
name|Lisp_Marker
case|:
name|XMARK
argument_list|(
name|XMARKER
argument_list|(
name|obj
argument_list|)
operator|->
name|chain
argument_list|)
expr_stmt|;
comment|/* DO NOT mark thru the marker's chain. 	 The buffer's markers chain does not preserve markers from gc; 	 instead, markers are removed from the chain when they are freed by gc. */
break|break;
case|case
name|Lisp_Cons
case|:
case|case
name|Lisp_Buffer_Local_Value
case|:
case|case
name|Lisp_Some_Buffer_Local_Value
case|:
block|{
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|struct
name|Lisp_Cons
modifier|*
name|ptr
init|=
name|XCONS
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|XMARKBIT
argument_list|(
name|ptr
operator|->
name|car
argument_list|)
condition|)
break|break;
name|tem
operator|=
name|ptr
operator|->
name|car
expr_stmt|;
name|XMARK
argument_list|(
name|ptr
operator|->
name|car
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|car
operator|=
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
name|ptr
operator|->
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|XGCTYPE
argument_list|(
name|ptr
operator|->
name|cdr
argument_list|)
operator|!=
name|Lisp_String
condition|)
block|{
name|obj
operator|=
name|ptr
operator|->
name|cdr
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|ptr
operator|->
name|cdr
operator|=
name|mark_object
argument_list|(
name|ptr
operator|->
name|cdr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Lisp_Objfwd
case|:
operator|*
name|XOBJFWD
argument_list|(
name|obj
argument_list|)
operator|=
name|mark_object
argument_list|(
operator|*
name|XOBJFWD
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Buffer
case|:
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|mark_buffer
argument_list|(
name|obj
argument_list|)
expr_stmt|;
break|break;
comment|/* Don't bother with Lisp_Buffer_Objfwd,        since all markable slots in current buffer marked anyway.  */
block|}
return|return
name|original
return|;
block|}
end_function

begin_comment
comment|/* Mark the pointers in a buffer structure.  */
end_comment

begin_macro
name|mark_buffer
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|buffer
init|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|number
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|number
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|name
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|name
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
name|buffer
operator|->
name|name
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|filename
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|directory
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|directory
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|save_length
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|save_length
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|auto_save_file_name
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|auto_save_file_name
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|read_only
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|read_only
argument_list|)
expr_stmt|;
comment|/* buffer->markers does not preserve from gc: scavenger removes marker from      the markers chain if it is freed.  See gc_sweep */
name|buffer
operator|->
name|mark
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|mark
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|major_mode
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|major_mode
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|mode_name
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|mode_name
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|mode_line_format
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|mode_line_format
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|keymap
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|keymap
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Vector
argument_list|,
name|buffer
operator|->
name|syntax_table_v
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|syntax_table_v
condition|)
name|mark_object
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|abbrev_table
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|abbrev_table
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|case_fold_search
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|case_fold_search
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|tab_width
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|tab_width
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|fill_column
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|fill_column
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|left_margin
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|left_margin
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|auto_fill_hook
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|auto_fill_hook
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|local_var_alist
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|truncate_lines
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|truncate_lines
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|ctl_arrow
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|ctl_arrow
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|selective_display
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|selective_display
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|minor_modes
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|minor_modes
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|overwrite_mode
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|overwrite_mode
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|abbrev_mode
operator|=
name|mark_object
argument_list|(
name|buffer
operator|->
name|abbrev_mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Find all structures not marked, and free them. */
end_comment

begin_function
specifier|static
name|void
name|gc_sweep
parameter_list|(
name|old_string_block
parameter_list|)
name|struct
name|string_block
modifier|*
name|old_string_block
decl_stmt|;
block|{
comment|/* Put all unmarked conses on free list */
block|{
specifier|register
name|struct
name|cons_block
modifier|*
name|cblk
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|cons_block_index
decl_stmt|;
specifier|register
name|int
name|num_free
init|=
literal|0
decl_stmt|,
name|num_used
init|=
literal|0
decl_stmt|;
name|cons_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cblk
operator|=
name|cons_block
init|;
name|cblk
condition|;
name|cblk
operator|=
name|cblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|cblk
operator|->
name|conses
index|[
name|i
index|]
operator|.
name|car
argument_list|)
condition|)
block|{
name|XSETCONS
argument_list|(
name|cblk
operator|->
name|conses
index|[
name|i
index|]
operator|.
name|car
argument_list|,
name|cons_free_list
argument_list|)
expr_stmt|;
name|num_free
operator|++
expr_stmt|;
name|cons_free_list
operator|=
operator|&
name|cblk
operator|->
name|conses
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|num_used
operator|++
expr_stmt|;
name|lim
operator|=
name|CONS_BLOCK_SIZE
expr_stmt|;
block|}
name|total_conses
operator|=
name|num_used
expr_stmt|;
name|total_free_conses
operator|=
name|num_free
expr_stmt|;
block|}
comment|/* Put all unmarked symbols on free list */
block|{
specifier|register
name|struct
name|symbol_block
modifier|*
name|sblk
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|symbol_block_index
decl_stmt|;
specifier|register
name|int
name|num_free
init|=
literal|0
decl_stmt|,
name|num_used
init|=
literal|0
decl_stmt|;
name|symbol_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sblk
operator|=
name|symbol_block
init|;
name|sblk
condition|;
name|sblk
operator|=
name|sblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|plist
argument_list|)
condition|)
block|{
name|XSETSYMBOL
argument_list|(
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|symbol_free_list
argument_list|)
expr_stmt|;
name|symbol_free_list
operator|=
operator|&
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
expr_stmt|;
name|num_free
operator|++
expr_stmt|;
block|}
else|else
name|num_used
operator|++
expr_stmt|;
name|lim
operator|=
name|SYMBOL_BLOCK_SIZE
expr_stmt|;
block|}
name|total_symbols
operator|=
name|num_used
expr_stmt|;
name|total_free_symbols
operator|=
name|num_free
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|standalone
comment|/* Put all unmarked markers on free list.      Dechain each one first from the buffer it points into. */
block|{
specifier|register
name|struct
name|marker_block
modifier|*
name|mblk
decl_stmt|;
name|struct
name|Lisp_Marker
modifier|*
name|tem1
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|marker_block_index
decl_stmt|;
specifier|register
name|int
name|num_free
init|=
literal|0
decl_stmt|,
name|num_used
init|=
literal|0
decl_stmt|;
name|marker_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mblk
operator|=
name|marker_block
init|;
name|mblk
condition|;
name|mblk
operator|=
name|mblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|mblk
operator|->
name|markers
index|[
name|i
index|]
operator|.
name|chain
argument_list|)
condition|)
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|tem1
operator|=
operator|&
name|mblk
operator|->
name|markers
index|[
name|i
index|]
expr_stmt|;
comment|/* tem1 avoids Sun compiler bug */
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Marker
argument_list|,
name|tem1
argument_list|)
expr_stmt|;
name|unchain_marker
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|XSETMARKER
argument_list|(
name|mblk
operator|->
name|markers
index|[
name|i
index|]
operator|.
name|chain
argument_list|,
name|marker_free_list
argument_list|)
expr_stmt|;
name|marker_free_list
operator|=
operator|&
name|mblk
operator|->
name|markers
index|[
name|i
index|]
expr_stmt|;
name|num_free
operator|++
expr_stmt|;
block|}
else|else
name|num_used
operator|++
expr_stmt|;
name|lim
operator|=
name|MARKER_BLOCK_SIZE
expr_stmt|;
block|}
name|total_markers
operator|=
name|num_used
expr_stmt|;
name|total_free_markers
operator|=
name|num_free
expr_stmt|;
block|}
comment|/* Free all unmarked buffers */
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|buffer
init|=
name|all_buffers
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buffer
condition|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|buffer
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
else|else
name|all_buffers
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
name|next
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|XUNMARK
argument_list|(
name|buffer
operator|->
name|name
argument_list|)
expr_stmt|;
name|prev
operator|=
name|buffer
operator|,
name|buffer
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|standalone
comment|/* Free all unmarked vectors */
block|{
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|vector
init|=
name|all_vectors
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|total_vector_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|vector
condition|)
if|if
condition|(
operator|!
operator|(
name|vector
operator|->
name|size
operator|&
name|most_negative_fixnum
operator|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|vector
operator|->
name|next
expr_stmt|;
else|else
name|all_vectors
operator|=
name|vector
operator|->
name|next
expr_stmt|;
name|next
operator|=
name|vector
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|vector
argument_list|)
expr_stmt|;
name|vector
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|vector
operator|->
name|size
operator|&=
operator|~
name|most_negative_fixnum
expr_stmt|;
name|total_vector_size
operator|+=
name|vector
operator|->
name|size
expr_stmt|;
name|prev
operator|=
name|vector
operator|,
name|vector
operator|=
name|vector
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Free all old string blocks, since all strings still used have been copied. */
block|{
specifier|register
name|struct
name|string_block
modifier|*
name|sblk
init|=
name|old_string_block
decl_stmt|;
while|while
condition|(
name|sblk
condition|)
block|{
name|struct
name|string_block
modifier|*
name|next
init|=
name|sblk
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|sblk
argument_list|)
expr_stmt|;
name|sblk
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialization */
end_comment

begin_macro
name|init_alloc_once
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
comment|/* Compute an int in which only the sign bit is set.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|x
operator|=
literal|1
init|;
operator|(
name|x
operator|<<=
literal|1
operator|)
operator|&
operator|~
literal|1
condition|;
name|i
operator|++
control|)
comment|/*empty loop*/
empty_stmt|;
name|most_negative_fixnum
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
name|dont_copy_flag
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
name|Vpurify_flag
operator|=
name|Qt
expr_stmt|;
name|pureptr
operator|=
literal|0
expr_stmt|;
name|all_vectors
operator|=
literal|0
expr_stmt|;
name|init_strings
argument_list|()
expr_stmt|;
name|init_cons
argument_list|()
expr_stmt|;
name|init_symbol
argument_list|()
expr_stmt|;
name|init_marker
argument_list|()
expr_stmt|;
name|gcprolist
operator|=
literal|0
expr_stmt|;
name|staticidx
operator|=
literal|0
expr_stmt|;
name|consing_since_gc
operator|=
literal|0
expr_stmt|;
name|gc_cons_threshold
operator|=
literal|100000
expr_stmt|;
ifdef|#
directive|ifdef
name|VIRT_ADDR_VARIES
name|malloc_sbrk_unused
operator|=
literal|1
operator|<<
literal|22
expr_stmt|;
comment|/* A large number */
name|malloc_sbrk_used
operator|=
literal|100000
expr_stmt|;
comment|/* as reasonable as any number */
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
block|}
end_block

begin_macro
name|init_alloc
argument_list|()
end_macro

begin_block
block|{
name|gcprolist
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|void
name|syms_of_alloc
parameter_list|()
block|{
name|DefIntVar
argument_list|(
literal|"gc-cons-threshold"
argument_list|,
operator|&
name|gc_cons_threshold
argument_list|,
literal|"*Number of bytes of consing between garbage collections."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"pure-bytes-used"
argument_list|,
operator|&
name|pureptr
argument_list|,
literal|"Number of bytes of sharable Lisp data allocated so far."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"data-bytes-used"
argument_list|,
operator|&
name|malloc_sbrk_used
argument_list|,
literal|"Number of bytes of unshared memory allocated in this session."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"data-bytes-free"
argument_list|,
operator|&
name|malloc_sbrk_unused
argument_list|,
literal|"Number of bytes of unshared memory remaining available in this session."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"purify-flag"
argument_list|,
operator|&
name|Vpurify_flag
argument_list|,
literal|"Non-nil means defun should purecopy the function definition."
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scons
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slist
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Svector
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_list
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_vector
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_symbol
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spurecopy
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgarbage_collect
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

