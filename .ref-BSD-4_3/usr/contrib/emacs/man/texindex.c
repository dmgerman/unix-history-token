begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Prepare Tex index dribble output into an actual index.    Copyright (C) Richard M. Stallman 1984     Permission is granted to anyone to make or distribute    verbatim copies of this program    provided that the copyright notice and this permission notice are preserved;    and provided that the recipient is not asked to waive or limit his right to    redistribute copies as permitted by this permission notice;    and provided that anyone possessing a machine-executable copy    is granted access to copy the source code, in machine-readable form,    in some reasonable manner.     Permission is granted to distribute derived works or enhanced versions of    this program under the above conditions with the additional condition    that the entire derivative or enhanced work    must be covered by a permission notice identical to this one.     Anything distributed as part of a package containing portions derived    from this program, which cannot in current practice perform its function    usefully in the absence of what was derived directly from this program,    is to be considered as forming, together with the latter,    a single work derived from this program,    which must be entirely covered by a permission notice identical to this one    in order for distribution of the package to be permitted.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|L_XTND
end_ifndef

begin_define
define|#
directive|define
name|L_XTND
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When sorting in core, this structure describes one line  and the position and length of its first keyfield.  */
end_comment

begin_struct
struct|struct
name|lineinfo
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* The actual text of the line */
union|union
block|{
comment|/* The start of the key (for textual comparison) */
name|char
modifier|*
name|text
decl_stmt|;
name|long
name|number
decl_stmt|;
comment|/* or the numeric value (for numeric comparison) */
block|}
name|key
union|;
name|long
name|keylen
decl_stmt|;
comment|/* Length of key field */
block|}
struct|;
end_struct

begin_comment
comment|/* This structure describes a field to use as a sort key */
end_comment

begin_struct
struct|struct
name|keyfield
block|{
name|int
name|startwords
decl_stmt|;
comment|/* # words to skip  */
name|int
name|startchars
decl_stmt|;
comment|/*  and # additional chars to skip, to start of field */
name|int
name|endwords
decl_stmt|;
comment|/* similar, from beg (or end) of line, to find end of field */
name|int
name|endchars
decl_stmt|;
name|char
name|ignore_blanks
decl_stmt|;
comment|/* Ignore spaces and tabs within the field */
name|char
name|fold_case
decl_stmt|;
comment|/* Convert upper case to lower before comparing */
name|char
name|reverse
decl_stmt|;
comment|/* Compare in reverse order */
name|char
name|numeric
decl_stmt|;
comment|/* Parse text as an integer and compare the integers */
name|char
name|positional
decl_stmt|;
comment|/* Sort according to position within the file */
name|char
name|braced
decl_stmt|;
comment|/* Count balanced-braced groupings as fields */
block|}
struct|;
end_struct

begin_comment
comment|/* Vector of keyfields to use */
end_comment

begin_decl_stmt
name|struct
name|keyfield
name|keyfields
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of keyfields stored in that vector.  */
end_comment

begin_decl_stmt
name|int
name|num_keyfields
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of input file names, terminated with a zero (null pointer) */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of corresponding output file names, or zero meaning default it */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|outfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of `infiles' */
end_comment

begin_decl_stmt
name|int
name|num_infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the array of pointers to lines being sorted */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|linearray
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The allocated length of `linearray'. */
end_comment

begin_decl_stmt
name|long
name|lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory to use for temporary files */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tempdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start of filename to use for temporary files.  It starts with a slash.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tempbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last temporary file.  */
end_comment

begin_decl_stmt
name|int
name|tempcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last temporary file already deleted.  Temporary files are deleted by `flush_tempfiles' in order of creation.  */
end_comment

begin_decl_stmt
name|int
name|last_deleted_tempcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During in-core sort, this points to the base of the data block  which contains all the lines of data.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|text_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Additional command switches */
end_comment

begin_decl_stmt
name|int
name|keep_tempfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do not delete tempfiles -- for debugging */
end_comment

begin_comment
comment|/* Forward declarations of functions in this file */
end_comment

begin_function_decl
name|void
name|decode_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sort_in_core
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sort_offline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
modifier|*
name|parsefile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_pos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_braced_pos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_braced_end
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|writelines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_full
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|readline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|merge_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|merge_direct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|maketempname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|flush_tempfiles
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tempcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_IN_CORE_SORT
value|500000
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tempcount
operator|=
literal|0
expr_stmt|;
name|last_deleted_tempcount
operator|=
literal|0
expr_stmt|;
comment|/* Describe the kind of sorting to do. */
comment|/* The first keyfield uses the first braced field and folds case */
name|keyfields
index|[
literal|0
index|]
operator|.
name|braced
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|0
index|]
operator|.
name|fold_case
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|0
index|]
operator|.
name|endwords
operator|=
operator|-
literal|1
expr_stmt|;
name|keyfields
index|[
literal|0
index|]
operator|.
name|endchars
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The second keyfield uses the second braced field, numerically */
name|keyfields
index|[
literal|1
index|]
operator|.
name|braced
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|numeric
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|startwords
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|endwords
operator|=
operator|-
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|endchars
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The third keyfield (which is ignored while discarding duplicates)      compares the whole line */
name|keyfields
index|[
literal|2
index|]
operator|.
name|endwords
operator|=
operator|-
literal|1
expr_stmt|;
name|keyfields
index|[
literal|2
index|]
operator|.
name|endchars
operator|=
operator|-
literal|1
expr_stmt|;
name|decode_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|tempbase
operator|=
name|mktemp
argument_list|(
name|concat
argument_list|(
literal|"/txiXXXXXX"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process input files completely, one by one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_infiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|desc
decl_stmt|;
name|long
name|ptr
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|desc
operator|=
name|open
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|L_XTND
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tell
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|outfiles
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|outfile
operator|=
name|concat
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
literal|"s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|<
name|MAX_IN_CORE_SORT
condition|)
comment|/* Sort a small amount of data */
name|sort_in_core
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
name|sort_offline
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|flush_tempfiles
argument_list|(
name|tempcount
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page decodes the command line arguments to set the parameter variables  and set up the vector of keyfields and the vector of input files */
end_comment

begin_function
name|void
name|decode_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
modifier|*
name|op
decl_stmt|;
comment|/* Store default values into parameter variables */
name|tempdir
operator|=
literal|"/tmp"
expr_stmt|;
name|keep_tempfiles
operator|=
literal|0
expr_stmt|;
comment|/* Allocate argc input files, which must be enough.  */
name|infiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|outfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|infiles
expr_stmt|;
name|op
operator|=
name|outfiles
expr_stmt|;
comment|/* First find all switches that control the default kind-of-sort */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tem
init|=
name|classify_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tem
operator|<=
literal|0
condition|)
block|{
operator|*
name|ip
operator|++
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tem
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"switch %s given with no argument following it"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-T"
argument_list|)
condition|)
name|tempdir
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-o"
argument_list|)
condition|)
operator|*
operator|(
name|op
operator|-
literal|1
operator|)
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|+=
name|tem
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'k'
case|:
name|keep_tempfiles
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid command switch %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|switchdone
label|:
empty_stmt|;
block|}
comment|/* Record number of keyfields, terminate list of filenames */
name|num_infiles
operator|=
name|ip
operator|-
name|infiles
expr_stmt|;
operator|*
name|ip
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 0 for an argument that is not a switch;  for a switch, return 1 plus the number of following arguments that the switch swallows. */
end_comment

begin_function
name|int
name|classify_arg
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-T"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-o"
argument_list|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a name for a temporary file */
end_comment

begin_function
name|char
modifier|*
name|maketempname
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|char
name|tempsuffix
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tempsuffix
argument_list|,
literal|"%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|concat
argument_list|(
name|tempdir
argument_list|,
name|tempbase
argument_list|,
name|tempsuffix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete all temporary files up to the specified count */
end_comment

begin_function
name|void
name|flush_tempfiles
parameter_list|(
name|to_count
parameter_list|)
name|int
name|to_count
decl_stmt|;
block|{
if|if
condition|(
name|keep_tempfiles
condition|)
return|return;
while|while
condition|(
name|last_deleted_tempcount
operator|<
name|to_count
condition|)
name|unlink
argument_list|(
name|maketempname
argument_list|(
operator|++
name|last_deleted_tempcount
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy an input file into a temporary file, and return the temporary file name */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_function
name|char
modifier|*
name|tempcopy
parameter_list|(
name|idesc
parameter_list|)
name|int
name|idesc
decl_stmt|;
block|{
name|char
modifier|*
name|outfile
init|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
decl_stmt|;
name|int
name|odesc
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|odesc
operator|=
name|open
argument_list|(
name|outfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|odesc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|nread
init|=
name|read
argument_list|(
name|idesc
argument_list|,
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|odesc
argument_list|,
name|buffer
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nread
condition|)
break|break;
block|}
name|close
argument_list|(
name|odesc
argument_list|)
expr_stmt|;
return|return
name|outfile
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two lines, provided as pointers to pointers to text,  according to the specified set of keyfields */
end_comment

begin_function
name|int
name|compare_full
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
name|char
modifier|*
modifier|*
name|line1
decl_stmt|,
decl|*
modifier|*
name|line2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Compare using the first keyfield;      if that does not distinguish the lines, try the second keyfield; and so on. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keyfields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|char
modifier|*
name|start1
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
operator|*
name|line1
argument_list|,
operator|&
name|length1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|start2
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
operator|*
name|line2
argument_list|,
operator|&
name|length2
argument_list|)
decl_stmt|;
name|int
name|tem
init|=
name|compare_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|start1
argument_list|,
name|length1
argument_list|,
operator|*
name|line1
operator|-
name|text_base
argument_list|,
name|start2
argument_list|,
name|length2
argument_list|,
operator|*
name|line2
operator|-
name|text_base
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
index|[
name|i
index|]
operator|.
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Lines match exactly */
block|}
end_block

begin_comment
comment|/* Compare two lines described by structures  in which the first keyfield is identified in advance.  For positional sorting, assumes that the order of the lines in core  reflects their nominal order.  */
end_comment

begin_function
name|int
name|compare_prepared
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
name|struct
name|lineinfo
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|char
modifier|*
name|text1
decl_stmt|,
modifier|*
name|text2
decl_stmt|;
comment|/* Compare using the first keyfield, which has been found for us already */
if|if
condition|(
name|keyfields
operator|->
name|positional
condition|)
block|{
if|if
condition|(
name|line1
operator|->
name|text
operator|-
name|text_base
operator|>
name|line2
operator|->
name|text
operator|-
name|text_base
condition|)
name|tem
operator|=
literal|1
expr_stmt|;
else|else
name|tem
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keyfields
operator|->
name|numeric
condition|)
name|tem
operator|=
name|line1
operator|->
name|key
operator|.
name|number
operator|-
name|line2
operator|->
name|key
operator|.
name|number
expr_stmt|;
else|else
name|tem
operator|=
name|compare_field
argument_list|(
name|keyfields
argument_list|,
name|line1
operator|->
name|key
operator|.
name|text
argument_list|,
name|line1
operator|->
name|keylen
argument_list|,
literal|0
argument_list|,
name|line2
operator|->
name|key
argument_list|,
name|line2
operator|->
name|keylen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
operator|->
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
name|text1
operator|=
name|line1
operator|->
name|text
expr_stmt|;
name|text2
operator|=
name|line2
operator|->
name|text
expr_stmt|;
comment|/* Compare using the second keyfield;      if that does not distinguish the lines, try the third keyfield; and so on. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_keyfields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|char
modifier|*
name|start1
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|text1
argument_list|,
operator|&
name|length1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|start2
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|text2
argument_list|,
operator|&
name|length2
argument_list|)
decl_stmt|;
name|int
name|tem
init|=
name|compare_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|start1
argument_list|,
name|length1
argument_list|,
name|text1
operator|-
name|text_base
argument_list|,
name|start2
argument_list|,
name|length2
argument_list|,
name|text2
operator|-
name|text_base
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
index|[
name|i
index|]
operator|.
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Lines match exactly */
block|}
end_block

begin_comment
comment|/* Like compare_full but more general.  You can pass any strings, and you can say how many keyfields to use.  `pos1' and `pos2' should indicate the nominal positional ordering of  the two lines in the input.  */
end_comment

begin_function
name|int
name|compare_general
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|,
name|pos1
parameter_list|,
name|pos2
parameter_list|,
name|use_keyfields
parameter_list|)
name|char
modifier|*
name|str1
decl_stmt|,
decl|*
name|str2
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|pos1
decl_stmt|,
name|pos2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_keyfields
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Compare using the first keyfield;      if that does not distinguish the lines, try the second keyfield; and so on. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|use_keyfields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|char
modifier|*
name|start1
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|str1
argument_list|,
operator|&
name|length1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|start2
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|str2
argument_list|,
operator|&
name|length2
argument_list|)
decl_stmt|;
name|int
name|tem
init|=
name|compare_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|start1
argument_list|,
name|length1
argument_list|,
name|pos1
argument_list|,
name|start2
argument_list|,
name|length2
argument_list|,
name|pos2
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
index|[
name|i
index|]
operator|.
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Lines match exactly */
block|}
end_block

begin_comment
comment|/* Find the start and length of a field in `str' according to `keyfield'.  A pointer to the starting character is returned, and the length  is stored into the int that `lengthptr' points to.  */
end_comment

begin_function
name|char
modifier|*
name|find_field
parameter_list|(
name|keyfield
parameter_list|,
name|str
parameter_list|,
name|lengthptr
parameter_list|)
name|struct
name|keyfield
modifier|*
name|keyfield
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|long
modifier|*
name|lengthptr
decl_stmt|;
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|keyfield
operator|->
name|braced
condition|)
name|fun
operator|=
name|find_braced_pos
expr_stmt|;
else|else
name|fun
operator|=
name|find_pos
expr_stmt|;
name|start
operator|=
call|(
modifier|*
name|fun
call|)
argument_list|(
name|str
argument_list|,
name|keyfield
operator|->
name|startwords
argument_list|,
name|keyfield
operator|->
name|startchars
argument_list|,
name|keyfield
operator|->
name|ignore_blanks
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfield
operator|->
name|endwords
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|keyfield
operator|->
name|braced
condition|)
name|end
operator|=
name|find_braced_end
argument_list|(
name|start
argument_list|)
expr_stmt|;
else|else
block|{
name|end
operator|=
name|start
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|&&
operator|*
name|end
operator|!=
literal|'\n'
condition|)
name|end
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|end
operator|=
call|(
modifier|*
name|fun
call|)
argument_list|(
name|str
argument_list|,
name|keyfield
operator|->
name|endwords
argument_list|,
name|keyfield
operator|->
name|endchars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|str
operator|<
name|start
operator|-
name|str
condition|)
name|end
operator|=
name|start
expr_stmt|;
block|}
operator|*
name|lengthptr
operator|=
name|end
operator|-
name|start
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Find a pointer to a specified place within `str',  skipping (from the beginning) `words' words and then `chars' chars.  If `ignore_blanks' is nonzero, we skip all blanks  after finding the specified word.  */
end_comment

begin_function
name|char
modifier|*
name|find_pos
parameter_list|(
name|str
parameter_list|,
name|words
parameter_list|,
name|chars
parameter_list|,
name|ignore_blanks
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|words
decl_stmt|,
name|chars
decl_stmt|;
name|int
name|ignore_blanks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
comment|/* Find next bunch of nonblanks and skip them. */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
operator|!
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
return|return
name|p
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Like find_pos but assumes that each field is surrounded by braces  and that braces within fields are balanced. */
end_comment

begin_function
name|char
modifier|*
name|find_braced_pos
parameter_list|(
name|str
parameter_list|,
name|words
parameter_list|,
name|chars
parameter_list|,
name|ignore_blanks
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|words
decl_stmt|,
name|chars
decl_stmt|;
name|int
name|ignore_blanks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bracelevel
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|bracelevel
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'{'
condition|)
return|return
name|p
operator|-
literal|1
return|;
while|while
condition|(
name|bracelevel
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|bracelevel
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|bracelevel
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* \ quotes braces and \ */
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
return|return
name|p
operator|-
literal|1
return|;
block|}
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'{'
condition|)
return|return
name|p
operator|-
literal|1
return|;
if|if
condition|(
name|ignore_blanks
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Find the end of the balanced-brace field which starts at `str'.   The position returned is just before the closing brace. */
end_comment

begin_function
name|char
modifier|*
name|find_braced_end
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|bracelevel
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
name|bracelevel
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|bracelevel
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|bracelevel
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|bracelevel
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
return|return
name|p
operator|-
literal|1
return|;
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare two fields (each specified as a start pointer and a character count)  according to `keyfield'.  The sign of the value reports the relation between the fields */
end_comment

begin_function
name|int
name|compare_field
parameter_list|(
name|keyfield
parameter_list|,
name|start1
parameter_list|,
name|length1
parameter_list|,
name|pos1
parameter_list|,
name|start2
parameter_list|,
name|length2
parameter_list|,
name|pos2
parameter_list|)
name|struct
name|keyfield
modifier|*
name|keyfield
decl_stmt|;
name|char
modifier|*
name|start1
decl_stmt|;
name|long
name|length1
decl_stmt|;
name|long
name|pos1
decl_stmt|;
name|char
modifier|*
name|start2
decl_stmt|;
name|long
name|length2
decl_stmt|;
name|long
name|pos2
decl_stmt|;
block|{
if|if
condition|(
name|keyfields
operator|->
name|positional
condition|)
block|{
if|if
condition|(
name|pos1
operator|>
name|pos2
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|keyfield
operator|->
name|numeric
condition|)
block|{
name|long
name|value
init|=
name|atol
argument_list|(
name|start1
argument_list|)
operator|-
name|atol
argument_list|(
name|start2
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|char
modifier|*
name|p1
init|=
name|start1
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|start2
decl_stmt|;
name|char
modifier|*
name|e1
init|=
name|start1
operator|+
name|length1
decl_stmt|;
name|char
modifier|*
name|e2
init|=
name|start2
operator|+
name|length2
decl_stmt|;
name|int
name|fold_case
init|=
name|keyfield
operator|->
name|fold_case
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|p1
operator|==
name|e1
condition|)
name|c1
operator|=
literal|0
expr_stmt|;
else|else
name|c1
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|e2
condition|)
name|c2
operator|=
literal|0
expr_stmt|;
else|else
name|c2
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
comment|/* Ignore case of both if desired */
if|if
condition|(
name|fold_case
condition|)
block|{
if|if
condition|(
name|c1
operator|>=
literal|'A'
operator|&&
name|c1
operator|<=
literal|'Z'
condition|)
name|c1
operator|=
name|c1
operator|+
literal|040
expr_stmt|;
if|if
condition|(
name|c2
operator|>=
literal|'A'
operator|&&
name|c2
operator|<=
literal|'Z'
condition|)
name|c2
operator|=
name|c2
operator|+
literal|040
expr_stmt|;
block|}
comment|/* Actually compare */
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
name|c1
operator|-
name|c2
return|;
if|if
condition|(
operator|!
name|c1
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A `struct linebuffer' is a structure which holds a line of text.  `readline' reads a line from a stream into a linebuffer  and works regardless of the length of the line.  */
end_comment

begin_struct
struct|struct
name|linebuffer
block|{
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize a linebuffer for use */
end_comment

begin_function
name|void
name|initbuffer
parameter_list|(
name|linebuffer
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
block|{
name|linebuffer
operator|->
name|size
operator|=
literal|200
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a line of text from `stream' into `linebuffer'.  Return the length of the line.  */
end_comment

begin_function
name|long
name|readline
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|linebuffer
operator|->
name|size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|linebuffer
operator|->
name|size
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|end
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sort the input files together when they are too big to sort in core */
end_comment

begin_function
name|void
name|sort_offline
parameter_list|(
name|infile
parameter_list|,
name|nfiles
parameter_list|,
name|total
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
name|infile
decl_stmt|;
name|long
name|total
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
name|int
name|ntemps
init|=
literal|2
operator|*
operator|(
name|total
operator|+
name|MAX_IN_CORE_SORT
operator|-
literal|1
operator|)
operator|/
name|MAX_IN_CORE_SORT
decl_stmt|;
comment|/* More than enough */
name|char
modifier|*
modifier|*
name|tempfiles
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|ntemps
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|istream
init|=
name|fopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|linebuffer
name|lb
decl_stmt|;
name|long
name|linelength
decl_stmt|;
name|initbuffer
argument_list|(
operator|&
name|lb
argument_list|)
expr_stmt|;
comment|/* Read in one line of input data.  */
name|linelength
operator|=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|istream
argument_list|)
expr_stmt|;
comment|/* Split up the input into `ntemps' temporary files, or maybe fewer,     and put the new files' names into `tempfiles' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntemps
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|outname
init|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|ostream
init|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
name|long
name|tempsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ostream
condition|)
name|pfatal_with_name
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|tempfiles
index|[
name|i
index|]
operator|=
name|outname
expr_stmt|;
comment|/* Copy lines into this temp file as long as it does not make file "too big" 	or until there are no more lines.  */
while|while
condition|(
name|tempsize
operator|+
name|linelength
operator|+
literal|1
operator|<=
name|MAX_IN_CORE_SORT
condition|)
block|{
name|tempsize
operator|+=
name|linelength
operator|+
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|lb
operator|.
name|buffer
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
comment|/* Read another line of input data.  */
name|linelength
operator|=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|istream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linelength
operator|&&
name|feof
argument_list|(
name|istream
argument_list|)
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|istream
argument_list|)
condition|)
break|break;
block|}
name|free
argument_list|(
name|lb
operator|.
name|buffer
argument_list|)
expr_stmt|;
comment|/* Record number of temp files we actually needed.  */
name|ntemps
operator|=
name|i
expr_stmt|;
comment|/* Sort each tempfile into another tempfile.     Delete the first set of tempfiles and put the names of the second into `tempfiles' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntemps
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|newtemp
init|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
decl_stmt|;
name|sort_in_core
argument_list|(
operator|&
name|tempfiles
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|MAX_IN_CORE_SORT
argument_list|,
name|newtemp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keep_tempfiles
condition|)
name|unlink
argument_list|(
name|tempfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tempfiles
index|[
name|i
index|]
operator|=
name|newtemp
expr_stmt|;
block|}
comment|/* Merge the tempfiles together and indexify */
name|merge_files
argument_list|(
name|tempfiles
argument_list|,
name|ntemps
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sort `infile', whose size is `total',  assuming that is small enough to be done in-core,  then indexify it and send the output to `outfile' (or to stdout).  */
end_comment

begin_function
name|void
name|sort_in_core
parameter_list|(
name|infile
parameter_list|,
name|total
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
name|infile
decl_stmt|;
name|long
name|total
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|nextline
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|total
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|file_data
decl_stmt|;
name|long
name|file_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|ostream
init|=
name|stdout
decl_stmt|;
name|struct
name|lineinfo
modifier|*
name|lineinfo
decl_stmt|;
comment|/* Read the contents of the file into the moby array `data' */
name|int
name|desc
init|=
name|open
argument_list|(
name|infile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"failure reopening %s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|file_size
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|data
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|file_data
operator|=
name|data
expr_stmt|;
name|data
index|[
name|file_size
index|]
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/* Sort routines want to know this address */
name|text_base
operator|=
name|data
expr_stmt|;
comment|/* Create the array of pointers to lines, with a default size frequently enough.  */
name|lines
operator|=
name|total
operator|/
literal|50
expr_stmt|;
if|if
condition|(
operator|!
name|lines
condition|)
name|lines
operator|=
literal|2
expr_stmt|;
name|linearray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|lines
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `nextline' points to the next free slot in this array.      `lines' is the allocated size.  */
name|nextline
operator|=
name|linearray
expr_stmt|;
comment|/* Parse the input file's data, and make entries for the lines.  */
name|nextline
operator|=
name|parsefile
argument_list|(
name|infile
argument_list|,
name|nextline
argument_list|,
name|file_data
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
comment|/* Sort the lines */
comment|/* If we have enough space, find the first keyfield of each line in advance.     Make a `struct lineinfo' for each line, which records the keyfield     as well as the line, and sort them.  */
name|lineinfo
operator|=
operator|(
expr|struct
name|lineinfo
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nextline
operator|-
name|linearray
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lineinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineinfo
condition|)
block|{
name|struct
name|lineinfo
modifier|*
name|lp
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|lineinfo
operator|,
name|p
operator|=
name|linearray
init|;
name|p
operator|!=
name|nextline
condition|;
name|lp
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|lp
operator|->
name|text
operator|=
operator|*
name|p
expr_stmt|;
name|lp
operator|->
name|key
operator|.
name|text
operator|=
name|find_field
argument_list|(
name|keyfields
argument_list|,
operator|*
name|p
argument_list|,
operator|&
name|lp
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfields
operator|->
name|numeric
condition|)
name|lp
operator|->
name|key
operator|.
name|number
operator|=
name|atol
argument_list|(
name|lp
operator|->
name|key
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|lineinfo
argument_list|,
name|nextline
operator|-
name|linearray
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lineinfo
argument_list|)
argument_list|,
name|compare_prepared
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|lineinfo
operator|,
name|p
operator|=
name|linearray
init|;
name|p
operator|!=
name|nextline
condition|;
name|lp
operator|++
operator|,
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|lp
operator|->
name|text
expr_stmt|;
name|free
argument_list|(
name|lineinfo
argument_list|)
expr_stmt|;
block|}
else|else
name|qsort
argument_list|(
name|linearray
argument_list|,
name|nextline
operator|-
name|linearray
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_full
argument_list|)
expr_stmt|;
comment|/* Open the output file */
if|if
condition|(
name|outfile
condition|)
block|{
name|ostream
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ostream
condition|)
name|pfatal_with_name
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
name|writelines
argument_list|(
name|linearray
argument_list|,
name|nextline
operator|-
name|linearray
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linearray
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse an input string in core into lines.  `data' is the input string, and `size' is its length.  Data goes in `linearray' starting at `nextline'.  The value returned is the first entry in `linearray' still unused.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|parsefile
parameter_list|(
name|filename
parameter_list|,
name|nextline
parameter_list|,
name|data
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
modifier|*
name|nextline
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
modifier|*
name|line
init|=
name|nextline
decl_stmt|;
name|p
operator|=
name|data
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|size
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
operator|*
name|line
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|end
condition|)
name|p
operator|++
expr_stmt|;
comment|/* This feature will be installed later.  */
comment|/*      if (discard_empty_lines&& p == *line + 1) continue;  */
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|linearray
operator|+
name|lines
condition|)
block|{
name|char
modifier|*
modifier|*
name|old
init|=
name|linearray
decl_stmt|;
name|linearray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|linearray
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|lines
operator|*=
literal|4
operator|)
argument_list|)
expr_stmt|;
name|line
operator|+=
name|linearray
operator|-
name|old
expr_stmt|;
block|}
block|}
return|return
name|line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indexification is a filter applied to the sorted lines  as they are being written to the output file.  Multiple entries for the same name, with different page numbers,  get combined into a single entry with multiple page numbers.  The first braced field, which is used for sorting, is discarded.  However, its first character is examined, folded to lower case,  and if it is different from that in the previous line fed to us  a \initial line is written with one argument, the new initial.   If an entry has four braced fields, then the second and third  constitute primary and secondary names.  In this case, each change of primary name  generates a \primary line which contains only the primary name,  and in between these are \secondary lines which contain  just a secondary name and page numbers. */
end_comment

begin_comment
comment|/* The last primary name we wrote a \primary entry for.  If only one level of indexing is being done, this is the last name seen */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lastprimary
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastprimarylength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of storage allocated for lastprimary */
end_comment

begin_comment
comment|/* Similar, for the secondary name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lastsecondary
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastsecondarylength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero if we are not in the middle of writing an entry.  One if we have written the beginning of an entry but have not   yet written any page numbers into it.  Greater than one if we have written the beginning of an entry   plus at least one page number. */
end_comment

begin_decl_stmt
name|int
name|pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The initial (for sorting purposes) of the last primary entry written.  When this changes, a \initial {c} line is written */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lastinitial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastinitiallength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we need a string of length 1 for the value of lastinitial,    store it here.  */
end_comment

begin_decl_stmt
name|char
name|lastinitial1
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize static storage for writing an index */
end_comment

begin_function
name|void
name|init_index
parameter_list|()
block|{
name|pending
operator|=
literal|0
expr_stmt|;
name|lastinitial
operator|=
name|lastinitial1
expr_stmt|;
name|lastinitial1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|lastinitial1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|lastinitiallength
operator|=
literal|0
expr_stmt|;
name|lastprimarylength
operator|=
literal|100
expr_stmt|;
name|lastprimary
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|lastprimarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|lastprimary
argument_list|,
name|lastprimarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lastsecondarylength
operator|=
literal|100
expr_stmt|;
name|lastsecondary
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|lastsecondarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|lastsecondary
argument_list|,
name|lastsecondarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indexify.  Merge entries for the same name,  insert headers for each initial character, etc.  */
end_comment

begin_macro
name|indexify
argument_list|(
argument|line
argument_list|,
argument|ostream
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ostream
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|primary
decl_stmt|,
modifier|*
name|secondary
decl_stmt|,
modifier|*
name|pagenumber
decl_stmt|;
name|int
name|primarylength
decl_stmt|,
name|secondarylength
decl_stmt|,
name|pagelength
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|int
name|nosecondary
decl_stmt|;
name|int
name|initiallength
decl_stmt|;
name|char
modifier|*
name|initial
decl_stmt|;
name|char
name|initial1
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* First, analyze the parts of the entry fed to us this time */
name|p
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|initial
operator|=
name|p
expr_stmt|;
comment|/* Get length of inner pair of braces starting at p, 	 including that inner pair of braces.  */
name|initiallength
operator|=
name|find_braced_end
argument_list|(
name|p
operator|+
literal|1
argument_list|)
operator|+
literal|1
operator|-
name|p
expr_stmt|;
block|}
else|else
block|{
name|initial
operator|=
name|initial1
expr_stmt|;
name|initial1
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|initial1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|initiallength
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|initial1
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|initial1
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
name|initial1
index|[
literal|0
index|]
operator|-=
literal|040
expr_stmt|;
block|}
name|pagenumber
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pagelength
operator|=
name|find_braced_end
argument_list|(
name|pagenumber
argument_list|)
operator|-
name|pagenumber
expr_stmt|;
if|if
condition|(
name|pagelength
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|primary
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|primarylength
operator|=
name|find_braced_end
argument_list|(
name|primary
argument_list|)
operator|-
name|primary
expr_stmt|;
name|secondary
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nosecondary
operator|=
operator|!
operator|*
name|secondary
expr_stmt|;
if|if
condition|(
operator|!
name|nosecondary
condition|)
name|secondarylength
operator|=
name|find_braced_end
argument_list|(
name|secondary
argument_list|)
operator|-
name|secondary
expr_stmt|;
comment|/* If the primary is different from before, make a new primary entry */
if|if
condition|(
name|strncmp
argument_list|(
name|primary
argument_list|,
name|lastprimary
argument_list|,
name|primarylength
argument_list|)
condition|)
block|{
comment|/* Close off current secondary entry first, if one is open */
if|if
condition|(
name|pending
condition|)
block|{
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this primary has a different initial, include an entry for the initial */
if|if
condition|(
name|initiallength
operator|!=
name|lastinitiallength
operator|||
name|strcmp
argument_list|(
name|initial
argument_list|,
name|lastinitial
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|ostream
argument_list|,
literal|"\\initial {"
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|initial
argument_list|,
literal|1
argument_list|,
name|initiallength
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ostream
argument_list|,
literal|"}\n"
argument_list|,
name|initial
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial
operator|==
name|initial1
condition|)
block|{
name|lastinitial
operator|=
name|lastinitial1
expr_stmt|;
operator|*
name|lastinitial1
operator|=
operator|*
name|initial1
expr_stmt|;
block|}
else|else
block|{
name|lastinitial
operator|=
name|initial
expr_stmt|;
block|}
name|lastinitiallength
operator|=
name|initiallength
expr_stmt|;
block|}
comment|/* Make the entry for the primary.  */
if|if
condition|(
name|nosecondary
condition|)
name|fputs
argument_list|(
literal|"\\entry {"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\\primary {"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|primary
argument_list|,
name|primarylength
argument_list|,
literal|1
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
if|if
condition|(
name|nosecondary
condition|)
block|{
name|fputs
argument_list|(
literal|"}{"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
comment|/* Record name of most recent primary */
if|if
condition|(
name|lastprimarylength
operator|<
name|primarylength
condition|)
block|{
name|lastprimarylength
operator|=
name|primarylength
operator|+
literal|100
expr_stmt|;
name|lastprimary
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|lastprimary
argument_list|,
literal|1
operator|+
name|lastprimarylength
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|lastprimary
argument_list|,
name|primary
argument_list|,
name|primarylength
argument_list|)
expr_stmt|;
name|lastprimary
index|[
name|primarylength
index|]
operator|=
literal|0
expr_stmt|;
comment|/* There is no current secondary within this primary, now */
name|lastsecondary
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Should not have an entry with no subtopic following one with a subtopic */
if|if
condition|(
name|nosecondary
operator|&&
operator|*
name|lastsecondary
condition|)
name|error
argument_list|(
literal|"entry %s follows an entry with a secondary name"
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Start a new secondary entry if necessary */
if|if
condition|(
operator|!
name|nosecondary
operator|&&
name|strncmp
argument_list|(
name|secondary
argument_list|,
name|lastsecondary
argument_list|,
name|secondarylength
argument_list|)
condition|)
block|{
if|if
condition|(
name|pending
condition|)
block|{
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Write the entry for the secondary.  */
name|fputs
argument_list|(
literal|"\\secondary {"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|secondary
argument_list|,
name|secondarylength
argument_list|,
literal|1
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"}{"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|1
expr_stmt|;
comment|/* Record name of most recent secondary */
if|if
condition|(
name|lastsecondarylength
operator|<
name|secondarylength
condition|)
block|{
name|lastsecondarylength
operator|=
name|secondarylength
operator|+
literal|100
expr_stmt|;
name|lastsecondary
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|lastsecondary
argument_list|,
literal|1
operator|+
name|lastsecondarylength
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|lastsecondary
argument_list|,
name|secondary
argument_list|,
name|secondarylength
argument_list|)
expr_stmt|;
name|lastsecondary
index|[
name|secondarylength
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Here to add one more page number to the current entry */
if|if
condition|(
name|pending
operator|++
operator|!=
literal|1
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
comment|/* Punctuate first, if this is not the first */
name|fwrite
argument_list|(
name|pagenumber
argument_list|,
name|pagelength
argument_list|,
literal|1
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Close out any unfinished output entry */
end_comment

begin_function
name|void
name|finish_index
parameter_list|(
name|ostream
parameter_list|)
name|FILE
modifier|*
name|ostream
decl_stmt|;
block|{
if|if
condition|(
name|pending
condition|)
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lastprimary
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lastsecondary
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the lines in the sorted order.  Each line is copied out of the input file it was found in. */
end_comment

begin_function
name|void
name|writelines
parameter_list|(
name|linearray
parameter_list|,
name|nlines
parameter_list|,
name|ostream
parameter_list|)
name|char
modifier|*
modifier|*
name|linearray
decl_stmt|;
name|int
name|nlines
decl_stmt|;
name|FILE
modifier|*
name|ostream
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|stop_line
init|=
name|linearray
operator|+
name|nlines
decl_stmt|;
name|char
modifier|*
modifier|*
name|next_line
decl_stmt|;
name|init_index
argument_list|()
expr_stmt|;
comment|/* Output the text of the lines, and free the buffer space */
for|for
control|(
name|next_line
operator|=
name|linearray
init|;
name|next_line
operator|!=
name|stop_line
condition|;
name|next_line
operator|++
control|)
block|{
comment|/* If -u was specified, output the line only if distinct from previous one.  */
if|if
condition|(
name|next_line
operator|==
name|linearray
comment|/* Compare previous line with this one, using only the explicitly specd keyfields */
operator|||
name|compare_general
argument_list|(
operator|*
operator|(
name|next_line
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|next_line
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
name|num_keyfields
operator|-
literal|1
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|next_line
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
name|indexify
argument_list|(
operator|*
name|next_line
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_index
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assume (and optionally verify) that each input file is sorted;  merge them and output the result.  Returns nonzero if any input file fails to be sorted.   This is the high-level interface that can handle an unlimited number of files.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DIRECT_MERGE
value|10
end_define

begin_function
name|int
name|merge_files
parameter_list|(
name|infiles
parameter_list|,
name|nfiles
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
modifier|*
name|infiles
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|tempfiles
decl_stmt|;
name|int
name|ntemps
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|start_tempcount
init|=
name|tempcount
decl_stmt|;
if|if
condition|(
name|nfiles
operator|<=
name|MAX_DIRECT_MERGE
condition|)
return|return
name|merge_direct
argument_list|(
name|infiles
argument_list|,
name|nfiles
argument_list|,
name|outfile
argument_list|)
return|;
comment|/* Merge groups of MAX_DIRECT_MERGE input files at a time,      making a temporary file to hold each group's result.  */
name|ntemps
operator|=
operator|(
name|nfiles
operator|+
name|MAX_DIRECT_MERGE
operator|-
literal|1
operator|)
operator|/
name|MAX_DIRECT_MERGE
expr_stmt|;
name|tempfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|ntemps
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntemps
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nf
init|=
name|MAX_DIRECT_MERGE
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|ntemps
condition|)
name|nf
operator|=
name|nfiles
operator|-
name|i
operator|*
name|MAX_DIRECT_MERGE
expr_stmt|;
name|tempfiles
index|[
name|i
index|]
operator|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
expr_stmt|;
name|value
operator||=
name|merge_direct
argument_list|(
operator|&
name|infiles
index|[
name|i
operator|*
name|MAX_DIRECT_MERGE
index|]
argument_list|,
name|nf
argument_list|,
name|tempfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* All temporary files that existed before are no longer needed      since their contents have been merged into our new tempfiles.      So delete them.  */
name|flush_tempfiles
argument_list|(
name|start_tempcount
argument_list|)
expr_stmt|;
comment|/* Now merge the temporary files we created.  */
name|merge_files
argument_list|(
name|tempfiles
argument_list|,
name|ntemps
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempfiles
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assume (and optionally verify) that each input file is sorted;  merge them and output the result.  Returns nonzero if any input file fails to be sorted.   This version of merging will not work if the number of  input files gets too high.  Higher level functions  use it only with a bounded number of input files.  */
end_comment

begin_function
name|int
name|merge_direct
parameter_list|(
name|infiles
parameter_list|,
name|nfiles
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
modifier|*
name|infiles
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|ip
init|=
name|infiles
decl_stmt|;
name|struct
name|linebuffer
modifier|*
name|lb1
decl_stmt|,
modifier|*
name|lb2
decl_stmt|;
name|struct
name|linebuffer
modifier|*
modifier|*
name|thisline
decl_stmt|,
modifier|*
modifier|*
name|prevline
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|streams
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nleft
decl_stmt|;
name|int
name|lossage
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|file_lossage
decl_stmt|;
name|struct
name|linebuffer
modifier|*
name|prev_out
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|ostream
init|=
name|stdout
decl_stmt|;
if|if
condition|(
name|outfile
condition|)
name|ostream
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ostream
condition|)
name|pfatal_with_name
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|init_index
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|outfile
condition|)
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* For each file, make two line buffers.      Also, for each file, there is an element of `thisline'      which points at any time to one of the file's two buffers,      and an element of `prevline' which points to the other buffer.      `thisline' is supposed to point to the next available line from the file,      while `prevline' holds the last file line used,      which is remembered so that we can verify that the file is properly sorted. */
comment|/* lb1 and lb2 contain one buffer each per file */
name|lb1
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
argument_list|)
argument_list|)
expr_stmt|;
name|lb2
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* thisline[i] points to the linebuffer holding the next available line in file i,      or is zero if there are no lines left in that file.  */
name|thisline
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prevline[i] points to the linebuffer holding the last used line from file i.      This is just for verifying that file i is properly sorted.  */
name|prevline
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* streams[i] holds the input stream for file i.  */
name|streams
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* file_lossage[i] is nonzero if we already know file i is not properly sorted.  */
name|file_lossage
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize all that storage */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|initbuffer
argument_list|(
operator|&
name|lb1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|initbuffer
argument_list|(
operator|&
name|lb2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|thisline
index|[
name|i
index|]
operator|=
operator|&
name|lb1
index|[
name|i
index|]
expr_stmt|;
name|prevline
index|[
name|i
index|]
operator|=
operator|&
name|lb2
index|[
name|i
index|]
expr_stmt|;
name|file_lossage
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|streams
index|[
name|i
index|]
operator|=
name|fopen
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|streams
index|[
name|i
index|]
condition|)
name|pfatal_with_name
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|readline
argument_list|(
name|thisline
index|[
name|i
index|]
argument_list|,
name|streams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Keep count of number of files not at eof */
name|nleft
operator|=
name|nfiles
expr_stmt|;
while|while
condition|(
name|nleft
condition|)
block|{
name|struct
name|linebuffer
modifier|*
name|best
init|=
literal|0
decl_stmt|;
name|struct
name|linebuffer
modifier|*
name|exch
decl_stmt|;
name|int
name|bestfile
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Look at the next avail line of each file; choose the least one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|thisline
index|[
name|i
index|]
operator|&&
operator|(
operator|!
name|best
operator|||
literal|0
operator|<
name|compare_general
argument_list|(
name|best
operator|->
name|buffer
argument_list|,
name|thisline
index|[
name|i
index|]
operator|->
name|buffer
argument_list|,
operator|(
name|long
operator|)
name|bestfile
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
name|num_keyfields
argument_list|)
operator|)
condition|)
block|{
name|best
operator|=
name|thisline
index|[
name|i
index|]
expr_stmt|;
name|bestfile
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Output that line, unless it matches the previous one and we don't want duplicates */
if|if
condition|(
operator|!
operator|(
name|prev_out
operator|&&
operator|!
name|compare_general
argument_list|(
name|prev_out
operator|->
name|buffer
argument_list|,
name|best
operator|->
name|buffer
argument_list|,
literal|0L
argument_list|,
literal|1L
argument_list|,
name|num_keyfields
operator|-
literal|1
argument_list|)
operator|)
condition|)
name|indexify
argument_list|(
name|best
operator|->
name|buffer
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|prev_out
operator|=
name|best
expr_stmt|;
comment|/* Now make the line the previous of its file, and fetch a new line from that file */
name|exch
operator|=
name|prevline
index|[
name|bestfile
index|]
expr_stmt|;
name|prevline
index|[
name|bestfile
index|]
operator|=
name|thisline
index|[
name|bestfile
index|]
expr_stmt|;
name|thisline
index|[
name|bestfile
index|]
operator|=
name|exch
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If the file has no more, mark it empty */
if|if
condition|(
name|feof
argument_list|(
name|streams
index|[
name|bestfile
index|]
argument_list|)
condition|)
block|{
name|thisline
index|[
name|bestfile
index|]
operator|=
literal|0
expr_stmt|;
name|nleft
operator|--
expr_stmt|;
comment|/* Update the number of files still not empty */
break|break;
block|}
name|readline
argument_list|(
name|thisline
index|[
name|bestfile
index|]
argument_list|,
name|streams
index|[
name|bestfile
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisline
index|[
name|bestfile
index|]
operator|->
name|buffer
index|[
literal|0
index|]
operator|||
operator|!
name|feof
argument_list|(
name|streams
index|[
name|bestfile
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
name|finish_index
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
comment|/* Free all storage and close all input streams */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|fclose
argument_list|(
name|streams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb1
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb2
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|file_lossage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thisline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prevline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
return|return
name|lossage
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_macro
name|fatal
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"texi: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|perror_with_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|" for %s"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pfatal_with_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|" for %s"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

