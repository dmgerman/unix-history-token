begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tags file maker to go with GNUmacs    Copyright (C) 1984 Richard M. Stallman and Ken Arnold  This program is distributed in the hope that it will be useful, but without any warranty.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.     Permission is granted to anyone to distribute verbatim copies    of this program's source code as received, in any medium, provided that    the copyright notice, the nonwarraty notice above    and this permission notice are preserved,    and that the distributor grants the recipient all rights    for further redistribution as permitted by this notice,    and informs him of these rights.     Permission is granted to distribute modified versions of this    program's source code, or of portions of it, under the above    conditions, plus the conditions that all changed files carry    prominent notices stating who last changed them and that the    derived material, including anything packaged together with it and    conceptually functioning as a modification of it rather than an    application of it, is in its entirety subject to a permission    notice identical to this one.     Permission is granted to distribute this program (verbatim or    as modified) in compiled or executable form, provided verbatim    redistribution is permitted as stated above for source code, and     A.  it is accompanied by the corresponding machine-readable       source code, under the above conditions, or     B.  it is accompanied by a written offer, with no time limit,       to distribute the corresponding machine-readable source code,       under the above conditions, to any one, in return for reimbursement       of the cost of distribution.   Verbatim redistribution of the       written offer must be permitted.  Or,     C.  it is distributed by someone who received only the       compiled or executable form, and is accompanied by a copy of the       written offer of source code which he received along with it.     Permission is granted to distribute this program (verbatim or as modified)    in executable form as part of a larger system provided that the source    code for this program, including any modifications used,    is also distributed or offered as stated in the preceding paragraph.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Define the symbol ETAGS to make the program "etags",  which makes emacs-style tag tables by default.  Define CTAGS to make the program "ctags" compatible with the usual one.  Default is ETAGS.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTAGS
end_ifndef

begin_define
define|#
directive|define
name|ETAGS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_define
define|#
directive|define
name|logical
value|char
end_define

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|arg
parameter_list|)
value|(_wht[arg])
end_define

begin_comment
comment|/* T if char is white		*/
end_comment

begin_define
define|#
directive|define
name|begtoken
parameter_list|(
name|arg
parameter_list|)
value|(_btk[arg])
end_define

begin_comment
comment|/* T if char can start token	*/
end_comment

begin_define
define|#
directive|define
name|intoken
parameter_list|(
name|arg
parameter_list|)
value|(_itk[arg])
end_define

begin_comment
comment|/* T if char can be in token	*/
end_comment

begin_define
define|#
directive|define
name|endtoken
parameter_list|(
name|arg
parameter_list|)
value|(_etk[arg])
end_define

begin_comment
comment|/* T if char ends tokens	*/
end_comment

begin_define
define|#
directive|define
name|isgood
parameter_list|(
name|arg
parameter_list|)
value|(_gd[arg])
end_define

begin_comment
comment|/* T if char can be after ')'	*/
end_comment

begin_define
define|#
directive|define
name|max
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
value|(I1> I2 ? I1 : I2)
end_define

begin_struct
struct|struct
name|nd_st
block|{
comment|/* sorting structure			*/
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* function or type name	*/
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name			*/
name|logical
name|f
decl_stmt|;
comment|/* use pattern or line no	*/
name|int
name|lno
decl_stmt|;
comment|/* line number tag is on	*/
name|long
name|cno
decl_stmt|;
comment|/* character number line starts on */
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* search pattern		*/
name|logical
name|been_warned
decl_stmt|;
comment|/* set if noticed dup		*/
name|struct
name|nd_st
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* left and right sons		*/
block|}
struct|;
end_struct

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|struct
name|nd_st
name|NODE
typedef|;
end_typedef

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tokens found so far on line starting with # (including #) */
end_comment

begin_decl_stmt
name|logical
name|gotone
decl_stmt|,
comment|/* found a func already on line	*/
comment|/* boolean "func" (see init)	*/
name|_wht
index|[
literal|0177
index|]
decl_stmt|,
name|_etk
index|[
literal|0177
index|]
decl_stmt|,
name|_itk
index|[
literal|0177
index|]
decl_stmt|,
name|_btk
index|[
literal|0177
index|]
decl_stmt|,
name|_gd
index|[
literal|0177
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* typedefs are recognized using a simple finite automata, 	 * tydef is its state variable. 	 */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|none
block|,
name|begin
block|,
name|middle
block|,
name|end
block|}
name|TYST
typedef|;
end_typedef

begin_decl_stmt
name|TYST
name|tydef
init|=
name|none
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|searchar
init|=
literal|'/'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use /.../ searches 		*/
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current line */
end_comment

begin_decl_stmt
name|long
name|charno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current character number */
end_comment

begin_decl_stmt
name|long
name|linecharno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character number of start of line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|curfile
decl_stmt|,
comment|/* current input file name		*/
modifier|*
name|outfile
init|=
literal|"tags"
decl_stmt|,
comment|/* output file				*/
modifier|*
name|white
init|=
literal|" \f\t\n"
decl_stmt|,
comment|/* white chars				*/
modifier|*
name|endtk
init|=
literal|" \t\n\"'#()[]{}=-+%*/&|^~!<>;,.:?"
decl_stmt|,
comment|/* token ending chars			*/
modifier|*
name|begtk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
decl_stmt|,
comment|/* token starting chars			*/
modifier|*
name|intk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|,
comment|/* valid in-token chars			*/
modifier|*
name|notgd
init|=
literal|",;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-valid after-function chars	*/
end_comment

begin_decl_stmt
name|int
name|file_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file number			*/
end_comment

begin_decl_stmt
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a: append to tags */
end_comment

begin_decl_stmt
name|int
name|tflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t: create tags for typedefs */
end_comment

begin_decl_stmt
name|int
name|uflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -u: update tags */
end_comment

begin_decl_stmt
name|int
name|wflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w: suppress warnings */
end_comment

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -v: create vgrind style index output */
end_comment

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -x: create cxref style output */
end_comment

begin_decl_stmt
name|int
name|eflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -e: emacs style output */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|inf
decl_stmt|,
comment|/* ioptr for current input file		*/
modifier|*
name|outf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioptr for tags file			*/
end_comment

begin_decl_stmt
name|NODE
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the head of the sorted binary tree	*/
end_comment

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|initbuffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|readline
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* A `struct linebuffer' is a structure which holds a line of text.  `readline' reads a line from a stream into a linebuffer  and works regardless of the length of the line.  */
end_comment

begin_struct
struct|struct
name|linebuffer
block|{
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|linebuffer
name|lb
decl_stmt|,
name|lb1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ETAGS
name|eflag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ac
operator|>
literal|1
operator|&&
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|eflag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'B'
case|:
name|searchar
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|searchar
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|aflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|eflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vflag
operator|++
expr_stmt|;
name|xflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|<=
literal|1
condition|)
block|{
name|usage
label|:
name|printf
argument_list|(
literal|"Usage: ctags [-BFaetuwvx] file ...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eflag
condition|)
name|outfile
operator|=
literal|"TAGS"
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
comment|/* set up boolean "functions"		*/
name|initbuffer
argument_list|(
operator|&
name|lb
argument_list|)
expr_stmt|;
name|initbuffer
argument_list|(
operator|&
name|lb1
argument_list|)
expr_stmt|;
comment|/*    * loop through files finding functions    */
if|if
condition|(
name|eflag
condition|)
block|{
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|aflag
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outf
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|file_num
operator|=
literal|1
init|;
name|file_num
operator|<
name|ac
condition|;
name|file_num
operator|++
control|)
block|{
name|find_entries
argument_list|(
name|av
index|[
name|file_num
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\f\n%s,%d\n"
argument_list|,
name|av
index|[
name|file_num
index|]
argument_list|,
name|total_size_of_entries
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eflag
condition|)
block|{
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xflag
condition|)
block|{
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"mv %s OTAGS;fgrep -v '\t%s\t' OTAGS>%s;rm OTAGS"
argument_list|,
name|outfile
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|aflag
operator|++
expr_stmt|;
block|}
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|aflag
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"sort %s -o %s"
argument_list|,
name|outfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine sets up the boolean psuedo-functions which work  * by seting boolean flags dependent upon the corresponding character  * Every char which is NOT in that string is not a white char.  Therefore,  * all of the array "_wht" is set to FALSE, and then the elements  * subscripted by the chars in "white" are set to TRUE.  Thus "_wht"  * of a char is TRUE if it is the string "white", else FALSE.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0177
condition|;
name|i
operator|++
control|)
block|{
name|_wht
index|[
name|i
index|]
operator|=
name|_etk
index|[
name|i
index|]
operator|=
name|_itk
index|[
name|i
index|]
operator|=
name|_btk
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|_gd
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|white
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_wht
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|endtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_etk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|intk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_itk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|begtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_btk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|notgd
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_gd
index|[
operator|*
name|sp
index|]
operator|=
name|FALSE
expr_stmt|;
name|_wht
index|[
literal|0
index|]
operator|=
name|_wht
index|[
literal|'\n'
index|]
expr_stmt|;
name|_etk
index|[
literal|0
index|]
operator|=
name|_etk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_btk
index|[
literal|0
index|]
operator|=
name|_btk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_itk
index|[
literal|0
index|]
operator|=
name|_itk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_gd
index|[
literal|0
index|]
operator|=
name|_gd
index|[
literal|'\n'
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine opens the specified file and calls the function  * which finds the function and type definitions.  */
end_comment

begin_macro
name|find_entries
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|curfile
operator|=
name|savestr
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* .l or .el or .lisp implies lisp source code */
if|if
condition|(
name|cp
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"l"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"el"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"lisp"
argument_list|)
operator|)
condition|)
block|{
name|L_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if not a .c or .h or .y file, try fortran */
if|if
condition|(
name|cp
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|'c'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'h'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'y'
operator|)
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|PF_funcs
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
name|rewind
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* no fortran tags found, try C */
block|}
name|C_entries
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Record a tag on the current line.   name is the tag name,   f is nonzero to use a pattern, zero to use line number instead. */
end_comment

begin_macro
name|pfnote
argument_list|(
argument|name
argument_list|,
argument|f
argument_list|,
argument|linestart
argument_list|,
argument|linelen
argument_list|,
argument|lno
argument_list|,
argument|cno
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|logical
name|f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* f == TRUE when function */
end_comment

begin_decl_stmt
name|char
modifier|*
name|linestart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|fp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|altname
decl_stmt|;
name|char
name|tem
index|[
literal|51
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ctags: too many entries to sort\n"
argument_list|)
expr_stmt|;
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Change name "main" to M<thisfilename>. */
if|if
condition|(
operator|!
name|eflag
operator|&&
operator|!
name|xflag
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|rindex
argument_list|(
name|curfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
name|fp
operator|=
name|curfile
expr_stmt|;
else|else
name|fp
operator|++
expr_stmt|;
name|altname
operator|=
name|concat
argument_list|(
literal|"M"
argument_list|,
name|fp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fp
operator|=
name|rindex
argument_list|(
name|altname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
name|fp
index|[
literal|2
index|]
operator|==
literal|0
condition|)
operator|*
name|fp
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|altname
expr_stmt|;
block|}
name|np
operator|->
name|entry
operator|=
name|savestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|file
operator|=
name|curfile
expr_stmt|;
name|np
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|np
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|np
operator|->
name|cno
operator|=
name|cno
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|np
operator|->
name|right
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
name|linestart
index|[
name|linelen
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xflag
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|tem
argument_list|,
name|strlen
argument_list|(
name|linestart
argument_list|)
operator|<
literal|50
condition|?
literal|"%s$"
else|:
literal|"%.50s"
argument_list|,
name|linestart
argument_list|)
expr_stmt|;
name|linestart
operator|=
name|tem
expr_stmt|;
block|}
name|np
operator|->
name|pat
operator|=
name|savestr
argument_list|(
name|linestart
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|np
expr_stmt|;
else|else
name|add_node
argument_list|(
name|np
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|free_tree
argument_list|(
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|node
condition|)
block|{
name|free_tree
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|add_node
argument_list|(
argument|node
argument_list|,
argument|cur_node
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|,
modifier|*
name|cur_node
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|strcmp
argument_list|(
name|node
operator|->
name|entry
argument_list|,
name|cur_node
operator|->
name|entry
argument_list|)
expr_stmt|;
comment|/* If this tag name matches an existing one, then      unless -e was given, do not add the node, but maybe print a warning */
if|if
condition|(
operator|!
name|eflag
operator|&&
operator|!
name|dif
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|file
operator|==
name|cur_node
operator|->
name|file
condition|)
block|{
if|if
condition|(
operator|!
name|wflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate entry in file %s, line %d: %s\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|lineno
argument_list|,
name|node
operator|->
name|entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Second entry ignored\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|cur_node
operator|->
name|been_warned
condition|)
if|if
condition|(
operator|!
name|wflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate entry in files %s and %s: %s (Warning only)\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|cur_node
operator|->
name|file
argument_list|,
name|node
operator|->
name|entry
argument_list|)
expr_stmt|;
name|cur_node
operator|->
name|been_warned
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/* Actually add the node */
if|if
condition|(
name|dif
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cur_node
operator|->
name|left
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|left
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|left
operator|=
name|node
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_node
operator|->
name|right
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|right
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|right
operator|=
name|node
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|put_entries
argument_list|(
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|reg
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
comment|/* Output subentries that precede this one */
name|put_entries
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* Output this entry */
if|if
condition|(
name|eflag
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s%c%d,%d\n"
argument_list|,
name|node
operator|->
name|pat
argument_list|,
literal|0177
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xflag
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\t%s\t"
argument_list|,
name|node
operator|->
name|entry
argument_list|,
name|node
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|f
condition|)
block|{
comment|/* a function */
name|putc
argument_list|(
name|searchar
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'^'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|node
operator|->
name|pat
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
operator|||
operator|*
name|sp
operator|==
name|searchar
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|sp
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|searchar
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* a typedef; text pattern inadequate */
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%d"
argument_list|,
name|node
operator|->
name|lno
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s %d\n"
argument_list|,
name|node
operator|->
name|entry
argument_list|,
name|node
operator|->
name|file
argument_list|,
operator|(
name|node
operator|->
name|lno
operator|+
literal|63
operator|)
operator|/
literal|64
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-16s%4d %-16s %s\n"
argument_list|,
name|node
operator|->
name|entry
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|node
operator|->
name|pat
argument_list|)
expr_stmt|;
comment|/* Output subentries that follow this one */
name|put_entries
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return total number of characters that put_entries will output for  the nodes in the subtree of the specified node.  Works only if eflag is set, but called only in that case.  */
end_comment

begin_macro
name|total_size_of_entries
argument_list|(
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|reg
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|int
name|total
init|=
literal|0
decl_stmt|;
name|reg
name|long
name|num
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Count subentries that precede this one */
name|total
operator|=
name|total_size_of_entries
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* Count subentries that follow this one */
name|total
operator|+=
name|total_size_of_entries
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
comment|/* Count this entry */
name|total
operator|+=
name|strlen
argument_list|(
name|node
operator|->
name|pat
argument_list|)
operator|+
literal|3
expr_stmt|;
name|num
operator|=
name|node
operator|->
name|lno
expr_stmt|;
while|while
condition|(
name|num
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|num
operator|/=
literal|10
expr_stmt|;
block|}
name|num
operator|=
name|node
operator|->
name|cno
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
name|total
operator|++
expr_stmt|;
while|while
condition|(
name|num
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|num
operator|/=
literal|10
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * This routine finds functions and typedefs in C syntax and adds them  * to the list.  */
end_comment

begin_define
define|#
directive|define
name|CNL_SAVE_NUMBER
define|\
value|{ \   linecharno = charno; lineno++; \   charno += 1 + readline (&lb, inf); \   lp = lb.buffer; \ }
end_define

begin_define
define|#
directive|define
name|CNL
define|\
value|{ \   CNL_SAVE_NUMBER; \   number = 0; \ }
end_define

begin_macro
name|C_entries
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|token
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|logical
name|incomm
decl_stmt|,
name|inquote
decl_stmt|,
name|inchar
decl_stmt|,
name|midtoken
decl_stmt|;
name|int
name|level
decl_stmt|;
name|char
name|tok
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|gotone
operator|=
name|midtoken
operator|=
name|inquote
operator|=
name|inchar
operator|=
name|incomm
operator|=
name|FALSE
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|CNL
expr_stmt|;
name|gotone
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|CNL_SAVE_NUMBER
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incomm
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|==
literal|'*'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|CNL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|incomm
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inquote
condition|)
block|{
comment|/* 	  * Too dumb to know about \" not being magic, but 	  * they usually occur in pairs anyway. 	  */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|inquote
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inchar
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inchar
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|inquote
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
name|inchar
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|'*'
condition|)
block|{
name|lp
operator|++
expr_stmt|;
name|incomm
operator|=
name|TRUE
expr_stmt|;
block|}
continue|continue;
case|case
literal|'#'
case|:
if|if
condition|(
name|lp
operator|==
name|lb
operator|.
name|buffer
operator|+
literal|1
condition|)
name|number
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'{'
case|:
if|if
condition|(
name|tydef
operator|==
name|begin
condition|)
block|{
name|tydef
operator|=
name|middle
expr_stmt|;
block|}
name|level
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'}'
case|:
if|if
condition|(
name|lp
operator|==
name|lb
operator|.
name|buffer
operator|+
literal|1
condition|)
name|level
operator|=
literal|0
expr_stmt|;
comment|/* reset */
else|else
name|level
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|level
operator|&&
name|tydef
operator|==
name|middle
condition|)
block|{
name|tydef
operator|=
name|end
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|level
operator|&&
operator|!
name|inquote
operator|&&
operator|!
name|incomm
operator|&&
name|gotone
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|midtoken
condition|)
block|{
if|if
condition|(
name|endtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|lb
operator|.
name|buffer
decl_stmt|;
name|int
name|endpos
init|=
name|lp
operator|-
name|lb
operator|.
name|buffer
decl_stmt|;
name|char
modifier|*
name|lp1
init|=
name|lp
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|long
name|linestart
init|=
name|linecharno
decl_stmt|;
name|int
name|tem
init|=
name|consider_token
argument_list|(
operator|&
name|lp1
argument_list|,
name|token
argument_list|,
operator|&
name|f
argument_list|)
decl_stmt|;
name|lp
operator|=
name|lp1
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|linestart
operator|!=
name|linecharno
condition|)
block|{
name|getline
argument_list|(
name|linestart
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tok
argument_list|,
name|token
operator|+
operator|(
name|lb1
operator|.
name|buffer
operator|-
name|buf
operator|)
argument_list|,
name|tp
operator|-
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tok
index|[
name|tp
operator|-
name|token
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|f
argument_list|,
name|lb1
operator|.
name|buffer
argument_list|,
name|endpos
argument_list|,
name|line
argument_list|,
name|linestart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|tok
argument_list|,
name|token
argument_list|,
name|tp
operator|-
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tok
index|[
name|tp
operator|-
name|token
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|f
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|endpos
argument_list|,
name|line
argument_list|,
name|linestart
argument_list|)
expr_stmt|;
block|}
name|gotone
operator|=
name|f
expr_stmt|;
comment|/* function */
block|}
name|midtoken
operator|=
name|FALSE
expr_stmt|;
name|token
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
name|tp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|token
operator|=
name|tp
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
name|midtoken
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|';'
operator|&&
name|tydef
operator|==
name|end
condition|)
comment|/* clean with typedefs */
name|tydef
operator|=
name|none
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This routine  checks to see if the current token is  * at the start of a function, or corresponds to a typedef  * It updates the input line * so that the '(' will be  * in it when it returns.  */
end_comment

begin_macro
name|consider_token
argument_list|(
argument|lpp
argument_list|,
argument|token
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|lpp
decl_stmt|,
modifier|*
name|token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|lp
init|=
operator|*
name|lpp
decl_stmt|;
name|reg
name|char
name|c
decl_stmt|;
specifier|static
name|logical
name|next_token_is_func
decl_stmt|;
name|logical
name|firsttok
decl_stmt|;
comment|/* T if have seen first token in ()'s */
name|int
name|bad
decl_stmt|,
name|win
decl_stmt|;
operator|*
name|f
operator|=
literal|1
expr_stmt|;
comment|/* a function */
name|c
operator|=
name|lp
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|number
condition|)
block|{
comment|/* space is not allowed in macro defs	*/
while|while
condition|(
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
break|break;
name|CNL
expr_stmt|;
block|}
block|}
comment|/* the following tries to make it so that a #define a b(c)	*/
comment|/* doesn't count as a define of b.				*/
block|}
else|else
block|{
name|number
operator|++
expr_stmt|;
if|if
condition|(
name|number
operator|>=
literal|4
operator|||
operator|(
name|number
operator|==
literal|2
operator|&&
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"define"
argument_list|,
literal|6
argument_list|)
operator|)
condition|)
block|{
name|gotone
operator|=
name|TRUE
expr_stmt|;
name|badone
label|:
name|bad
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
comment|/* check for the typedef cases		*/
if|if
condition|(
name|tflag
operator|&&
operator|!
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"typedef"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|tydef
operator|=
name|begin
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|begin
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"struct"
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"union"
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"enum"
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|begin
condition|)
block|{
name|tydef
operator|=
name|end
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|end
condition|)
block|{
operator|*
name|f
operator|=
literal|0
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Detect GNUmacs's function-defining macros. */
if|if
condition|(
operator|!
name|number
operator|&&
operator|!
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"DEF"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|next_token_is_func
operator|=
literal|1
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|next_token_is_func
condition|)
block|{
name|next_token_is_func
operator|=
literal|0
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
goto|goto
name|badone
goto|;
name|firsttok
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
break|break;
name|CNL
expr_stmt|;
block|}
comment|/* 	* This line used to confuse ctags: 	*	int	(*oldhup)(); 	* This fixes it. A nonwhite char before the first 	* token, other than a / (in case of a comment in there) 	* makes this not a declaration. 	*/
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'/'
condition|)
name|firsttok
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|firsttok
condition|)
goto|goto
name|badone
goto|;
block|}
while|while
condition|(
name|iswhite
argument_list|(
name|c
operator|=
operator|*
name|lp
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
name|CNL
expr_stmt|;
block|}
name|win
operator|=
name|isgood
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ret
label|:
operator|*
name|lpp
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
return|return
operator|!
name|bad
operator|&&
name|win
return|;
block|}
end_block

begin_macro
name|getline
argument_list|(
argument|atchar
argument_list|)
end_macro

begin_decl_stmt
name|long
name|atchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|saveftell
init|=
name|ftell
argument_list|(
name|inf
argument_list|)
decl_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|atchar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readline
argument_list|(
operator|&
name|lb1
argument_list|,
name|inf
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|saveftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Fortran parsing */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pfcnt
decl_stmt|;
end_decl_stmt

begin_macro
name|PF_funcs
argument_list|(
argument|fi
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|'%'
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Ratfor escape to fortran */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"integer"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"real"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"logical"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"complex"
argument_list|)
operator|||
name|tail
argument_list|(
literal|"character"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tail
argument_list|(
literal|"precision"
argument_list|)
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"function"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"subroutine"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"program"
argument_list|)
condition|)
block|{
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tail
argument_list|(
literal|"procedure"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|pfcnt
operator|)
return|;
block|}
end_block

begin_macro
name|tail
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|&
operator|~
literal|' '
operator|)
operator|==
operator|(
operator|(
operator|*
operator|(
name|dbp
operator|+
name|len
operator|)
operator|)
operator|&
operator|~
literal|' '
operator|)
condition|)
name|cp
operator|++
operator|,
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|dbp
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|takeprec
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|!=
literal|'*'
condition|)
return|return;
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
block|{
operator|--
name|dbp
expr_stmt|;
comment|/* force failure */
return|return;
block|}
do|do
name|dbp
operator|++
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
do|;
block|}
end_block

begin_macro
name|getit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
operator|||
operator|!
name|isalpha
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * lisp tag functions  * just look for (def or (DEF  */
end_comment

begin_macro
name|L_funcs
argument_list|(
argument|fi
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|L_getit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|L_getit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Initialize a linebuffer for use */
end_comment

begin_function
name|void
name|initbuffer
parameter_list|(
name|linebuffer
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
block|{
name|linebuffer
operator|->
name|size
operator|=
literal|200
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a line of text from `stream' into `linebuffer'.  Return the length of the line.  */
end_comment

begin_function
name|long
name|readline
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|pend
init|=
name|p
operator|+
name|linebuffer
operator|->
name|size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|linebuffer
operator|->
name|size
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|pend
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the ptr in sp at which the character c last  * appears; NULL if not found  *  * Identical to v7 rindex, included for portability.  */
end_comment

begin_function
name|char
modifier|*
name|rindex
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|sp
operator|++
condition|)
do|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_macro
name|fatal
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|CTAGS
name|printf
argument_list|(
literal|"ctags: "
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"etags: "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

