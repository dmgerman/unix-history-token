begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * ifuncs - functions used by inews.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)ifuncs.c	2.51	3/19/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_define
define|#
directive|define
name|AFSIZ
value|4000
end_define

begin_comment
comment|/* size of text in the active file for initial malloc */
end_comment

begin_comment
comment|/*  * Transmit this article to all interested systems.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|u370
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|srec
name|srec
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* u370 */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|h
decl_stmt|,
name|hh
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_define
define|#
directive|define
name|MAXMCAST
value|20
end_define

begin_define
define|#
directive|define
name|MAXMCS
value|10
end_define

begin_struct
struct|struct
name|multicast
block|{
name|char
name|mc_name
index|[
name|SBUFLEN
index|]
decl_stmt|;
comment|/* "multi-cast" name */
name|short
name|mc_syscnt
decl_stmt|;
name|char
name|mc_tosys
index|[
name|MAXMCAST
index|]
index|[
name|SBUFLEN
index|]
decl_stmt|;
block|}
name|mcast
index|[
name|MAXMCS
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|mccount
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTICAST */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBM
end_ifndef

begin_function_decl
name|char
modifier|*
name|histfile
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DBM */
end_comment

begin_macro
name|broadcast
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|hptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
ifndef|#
directive|ifndef
name|u370
name|struct
name|srec
name|srec
decl_stmt|;
endif|#
directive|endif
name|char
name|sentbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|int
name|nsent
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sentsys
decl_stmt|;
comment|/* h is a local copy of the header we can scribble on */
name|fp
operator|=
name|xfopen
argument_list|(
name|ARTICLE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot reread article"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sentbuf
argument_list|,
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|sentbuf
argument_list|,
literal|" sent to "
argument_list|)
expr_stmt|;
name|sentsys
operator|=
name|index
argument_list|(
name|sentbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nsent
operator|=
literal|0
expr_stmt|;
comment|/* break path into list of systems. */
name|sptr
operator|=
name|hptr
operator|=
name|h
operator|.
name|path
expr_stmt|;
while|while
condition|(
operator|(
name|hptr
operator|=
name|strpbrk
argument_list|(
name|hptr
argument_list|,
name|NETCHRS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|hptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sptr
operator|=
name|hptr
expr_stmt|;
block|}
operator|*
name|sptr
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|mccount
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MULTICAST */
comment|/* loop once per system. */
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
operator|&
name|srec
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HIDDENNET
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|LOCALSYSNAME
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* HIDDENNET */
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|FULLSYSNAME
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sptr
operator|=
name|srec
operator|.
name|s_nosend
condition|)
block|{
while|while
condition|(
operator|*
name|sptr
condition|)
block|{
while|while
condition|(
operator|*
name|sptr
operator|&&
operator|*
name|sptr
operator|!=
literal|','
condition|)
name|sptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|==
literal|','
condition|)
operator|*
name|sptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
operator|++
name|sptr
operator|=
literal|'\0'
expr_stmt|;
block|}
name|hptr
operator|=
name|h
operator|.
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|hptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|hptr
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|contin
goto|;
if|if
condition|(
name|sptr
operator|=
name|srec
operator|.
name|s_nosend
condition|)
block|{
while|while
condition|(
operator|*
name|sptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|sptr
argument_list|,
name|hptr
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|contin
goto|;
while|while
condition|(
operator|*
name|sptr
operator|++
condition|)
empty_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|hptr
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|h
operator|.
name|nbuf
argument_list|,
name|srec
operator|.
name|s_nbuf
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|h
operator|.
name|distribution
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|ngmatch
argument_list|(
name|h
operator|.
name|distribution
argument_list|,
name|srec
operator|.
name|s_nbuf
argument_list|)
operator|&&
operator|!
name|ngmatch
argument_list|(
name|srec
operator|.
name|s_nbuf
argument_list|,
name|h
operator|.
name|distribution
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nsent
condition|)
block|{
name|hptr
operator|=
name|sentsys
expr_stmt|;
while|while
condition|(
operator|(
name|sptr
operator|=
name|index
argument_list|(
name|hptr
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|sptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hptr
argument_list|,
name|srec
operator|.
name|s_name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|sptr
operator|=
literal|','
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
operator|*
name|sptr
operator|++
operator|=
literal|','
expr_stmt|;
for|for
control|(
name|hptr
operator|=
name|sptr
init|;
name|isspace
argument_list|(
operator|*
name|hptr
argument_list|)
condition|;
name|hptr
operator|++
control|)
empty_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|hptr
argument_list|,
name|srec
operator|.
name|s_name
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
comment|/* now we've found a system to send this article to */
ifdef|#
directive|ifdef
name|MULTICAST
if|if
condition|(
name|index
argument_list|(
name|srec
operator|.
name|s_flags
argument_list|,
literal|'M'
argument_list|)
condition|)
block|{
comment|/* do a "multi-cast" transmit */
specifier|register
name|struct
name|multicast
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|srec
operator|.
name|s_name
argument_list|)
operator|>=
name|SBUFLEN
operator|||
name|strlen
argument_list|(
name|srec
operator|.
name|s_xmit
argument_list|)
operator|>=
name|SBUFLEN
condition|)
name|xerror
argument_list|(
literal|"system name too long for multicast"
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|mcast
init|;
name|m
operator|<
operator|&
name|mcast
index|[
name|mccount
index|]
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|srec
operator|.
name|s_xmit
argument_list|,
name|m
operator|->
name|mc_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|>=
operator|&
name|mcast
index|[
name|MAXMCS
index|]
condition|)
name|xerror
argument_list|(
literal|"Too many multicasts"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
operator|&
name|mcast
index|[
name|mccount
index|]
condition|)
block|{
name|mccount
operator|++
expr_stmt|;
name|m
operator|->
name|mc_syscnt
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|m
operator|->
name|mc_name
argument_list|,
name|srec
operator|.
name|s_xmit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|mc_syscnt
operator|>=
name|MAXMCAST
condition|)
name|xerror
argument_list|(
literal|"Too many systems for multicast"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|m
operator|->
name|mc_tosys
index|[
name|m
operator|->
name|mc_syscnt
operator|++
index|]
argument_list|,
name|srec
operator|.
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|multicast
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|yptr
decl_stmt|;
name|char
modifier|*
name|sysptrs
index|[
name|MAXMCAST
index|]
decl_stmt|;
name|int
name|mc
decl_stmt|;
name|mc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|mcast
init|;
name|m
operator|<
operator|&
name|mcast
index|[
name|mccount
index|]
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|mc_name
argument_list|,
name|srec
operator|.
name|s_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yptr
operator|=
name|sysptrs
expr_stmt|;
while|while
condition|(
name|mc
operator|<
name|m
operator|->
name|mc_syscnt
condition|)
operator|*
name|yptr
operator|++
operator|=
name|m
operator|->
name|mc_tosys
index|[
name|mc
operator|++
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|xfopen
argument_list|(
name|ARTICLE
argument_list|,
literal|"r"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sysptrs
argument_list|,
name|mc
argument_list|)
condition|)
continue|continue;
block|}
else|#
directive|else
comment|/* !MULTICAST */
if|if
condition|(
operator|!
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|xfopen
argument_list|(
name|ARTICLE
argument_list|,
literal|"r"
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* !MULTICAST */
if|if
condition|(
name|nsent
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|sentbuf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|sentbuf
argument_list|,
name|srec
operator|.
name|s_name
argument_list|)
expr_stmt|;
name|nsent
operator|++
expr_stmt|;
name|contin
label|:
empty_stmt|;
block|}
if|if
condition|(
name|nsent
condition|)
name|log
argument_list|(
name|sentbuf
argument_list|)
expr_stmt|;
name|s_close
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Transmit file to system.  */
end_comment

begin_define
define|#
directive|define
name|PROC
value|0004
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MULTICAST
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MULTICAST */
end_comment

begin_expr_stmt
name|transmit
argument_list|(
name|sp
argument_list|,
name|ifp
argument_list|,
name|maynotify
argument_list|,
name|sysnames
argument_list|,
name|mc
argument_list|)
specifier|register
expr|struct
name|srec
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maynotify
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|sysnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|ofp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|TRANS
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|20
index|]
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
specifier|extern
name|char
name|firstbufname
index|[]
decl_stmt|;
comment|/* A:	afmt: the other machine runs an A news, so we xmit in A format */
name|int
name|afmt
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'A'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* B:	use B format (this is the default - don't use this letter elsewise). */
comment|/* F:	append name to file */
name|int
name|appfile
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'F'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* L:	local: don't send the article unless it was generated locally */
name|int
name|local
init|=
operator|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'L'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* H:	interpolate history line into command, use existing file */
name|int
name|history
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'H'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* M:	multi-cast: this is taken care of above, but don't reuse flag */
ifdef|#
directive|ifdef
name|MULTICAST
comment|/* O:	multi-cast only, don't send article if not multicast hosts */
name|int
name|multisend
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'O'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
endif|#
directive|endif
comment|/* MULTICAST */
comment|/* N:	notify: don't send the article, just tell him we have it */
name|int
name|notify
init|=
name|maynotify
operator|&&
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* S:	noshell: don't fork a shell to execute the xmit command */
name|int
name|noshell
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'S'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* U:	useexist: use the -c option to uux to use the existing copy */
name|int
name|useexist
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'U'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|local
operator|&&
name|mode
operator|==
name|PROC
condition|)
block|{
name|local
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
name|local
operator|=
name|local
operator|*
literal|10
operator|+
operator|*
name|ptr
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|h
operator|.
name|path
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
operator|&&
name|local
operator|>=
literal|0
condition|;
name|local
operator|--
control|)
while|while
condition|(
operator|*
name|ptr
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|local
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Transmitting to '%s'\n"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
ifdef|#
directive|ifdef
name|MULTICAST
if|if
condition|(
name|multisend
operator|&&
name|mc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* MULTICAST */
if|if
condition|(
operator|!
name|appfile
operator|&&
operator|!
name|useexist
operator|&&
operator|!
name|history
condition|)
block|{
if|if
condition|(
operator|!
name|hread
argument_list|(
operator|&
name|hh
argument_list|,
name|ifp
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"Bad header, not transmitting %s re %s to %s"
argument_list|,
name|hh
operator|.
name|ident
argument_list|,
name|hh
operator|.
name|title
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|hh
operator|.
name|nbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article not subscribed to by %s\n"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|TRANS
argument_list|,
literal|"%s/trXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notify
condition|)
block|{
name|char
name|oldid
index|[
literal|50
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hh
operator|.
name|title
argument_list|,
literal|"ihave %s %s"
argument_list|,
name|hh
operator|.
name|ident
argument_list|,
name|FULLSYSNAME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hh
operator|.
name|nbuf
argument_list|,
literal|"to.%s.ctl"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oldid
argument_list|,
name|hh
operator|.
name|ident
argument_list|)
expr_stmt|;
name|getident
argument_list|(
operator|&
name|hh
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"tell %s about %s, notif. id %s"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|oldid
argument_list|,
name|hh
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|appfile
condition|)
block|{
if|if
condition|(
name|firstbufname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|extern
name|char
name|histline
index|[]
decl_stmt|;
name|localize
argument_list|(
literal|"junk"
argument_list|)
expr_stmt|;
name|savehist
argument_list|(
name|histline
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"No file name to xmit from"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|s_xmit
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|sp
operator|->
name|s_xmit
argument_list|,
literal|"%s/%s"
argument_list|,
name|BATCHDIR
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IHCC
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|TRANS
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|BATCHDIR
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|fopen
argument_list|(
name|TRANS
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !IHCC */
name|ofp
operator|=
name|fopen
argument_list|(
name|sp
operator|->
name|s_xmit
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !IHCC */
if|if
condition|(
name|ofp
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot append to %s"
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s"
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|mc
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|sysnames
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MULTICAST */
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s\n"
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !MULTICAST */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|useexist
condition|)
block|{
if|if
condition|(
name|firstbufname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"No file name to xmit from"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|->
name|s_xmit
operator|==
literal|'\0'
condition|)
ifdef|#
directive|ifdef
name|UXMIT
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|UXMIT
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
else|#
directive|else
name|xerror
argument_list|(
literal|"UXMIT not defined for U flag"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
ifdef|#
directive|ifdef
name|MULTICAST
name|makeargs
argument_list|(
name|bfr
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|firstbufname
argument_list|,
name|sysnames
argument_list|,
name|mc
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|history
condition|)
block|{
specifier|extern
name|char
name|histline
index|[]
decl_stmt|;
if|if
condition|(
operator|*
name|sp
operator|->
name|s_xmit
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"no xmit command with H flag"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|makeargs
argument_list|(
name|bfr
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|histline
argument_list|,
name|sysnames
argument_list|,
name|mc
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|histline
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ofp
operator|=
name|xfopen
argument_list|(
name|mktemp
argument_list|(
name|TRANS
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|afmt
condition|)
block|{
ifdef|#
directive|ifdef
name|OLD
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"A%s\n%s\n%s!%s\n%s\n%s\n"
argument_list|,
name|oident
argument_list|(
name|hh
operator|.
name|ident
argument_list|)
argument_list|,
name|hh
operator|.
name|nbuf
argument_list|,
name|FULLSYSNAME
argument_list|,
name|hh
operator|.
name|path
argument_list|,
name|hh
operator|.
name|subdate
argument_list|,
name|hh
operator|.
name|title
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !OLD */
name|logerr
argument_list|(
literal|"Must have OLD defined to use A flag for xmit"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* !OLD */
block|}
else|else
name|hwrite
argument_list|(
operator|&
name|hh
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|notify
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ofp
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"write failed on transmit"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|->
name|s_xmit
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|DFTXMIT
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|TRANS
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|MULTICAST
name|makeargs
argument_list|(
name|bfr
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|TRANS
argument_list|,
name|sysnames
argument_list|,
name|mc
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MULTICAST */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|TRANS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !MULTICAST */
block|}
comment|/* At this point, the command to be executed is in bfr. */
if|if
condition|(
name|noshell
condition|)
block|{
if|if
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
name|fwait
argument_list|(
name|pid
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
name|TRANS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|bfr
expr_stmt|;
for|for
control|(
name|pid
operator|=
literal|0
init|;
name|pid
operator|<
literal|19
condition|;
name|pid
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|argv
index|[
name|pid
index|]
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
break|break;
block|}
name|argv
index|[
operator|++
name|pid
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"Can't execv %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|history
operator|&&
name|sp
operator|->
name|s_xmit
index|[
literal|0
index|]
operator|&&
operator|!
name|index
argument_list|(
name|bfr
argument_list|,
literal|'<'
argument_list|)
condition|)
block|{
name|char
name|newcmd
index|[
name|LBUFLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newcmd
argument_list|,
literal|"(%s)<%s"
argument_list|,
name|bfr
argument_list|,
name|useexist
condition|?
name|firstbufname
else|:
name|TRANS
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|newcmd
argument_list|)
expr_stmt|;
block|}
else|else
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|appfile
operator|&&
operator|!
name|useexist
operator|&&
operator|!
name|history
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|TRANS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_macro
name|makeargs
argument_list|(
argument|buf
argument_list|,
argument|cmd
argument_list|,
argument|arg2
argument_list|,
argument|sysargs
argument_list|,
argument|sac
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|sysargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|cmd
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|ac
operator|=
literal|0
expr_stmt|;
specifier|register
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
do|do
block|{
if|if
condition|(
name|q
operator|=
name|index
argument_list|(
name|q
argument_list|,
literal|' '
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|p
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
switch|switch
condition|(
operator|++
name|ac
condition|)
block|{
case|case
literal|1
case|:
while|while
condition|(
operator|--
name|sac
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
operator|*
name|sysargs
operator|++
argument_list|)
expr_stmt|;
name|b
operator|=
name|index
argument_list|(
name|b
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|b
operator|=
name|index
argument_list|(
name|b
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|' '
expr_stmt|;
name|xerror
argument_list|(
literal|"badly formed command: %s"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|strcpy
argument_list|(
name|b
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|b
operator|=
name|index
argument_list|(
name|b
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
condition|)
block|{
operator|*
name|q
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|q
operator|!=
name|NULL
condition|)
do|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTICAST */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|dptr
decl_stmt|;
name|int
name|dsize
decl_stmt|;
block|}
name|datum
typedef|;
end_typedef

begin_comment
comment|/*  * Return TRUE if we have seen this file before, else FALSE.  */
end_comment

begin_macro
name|history
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DBM
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|datum
name|fetch
parameter_list|()
function_decl|;
else|#
directive|else
comment|/* !DBM */
specifier|register
name|FILE
modifier|*
name|hfp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
comment|/* !DBM */
name|char
name|lcident
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|extern
name|char
name|histline
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history(%s)\n"
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Make the article ID case insensitive. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lcident
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|lcase
argument_list|(
name|lcident
argument_list|)
expr_stmt|;
name|idlock
argument_list|(
name|lcident
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
name|initdbm
argument_list|(
name|ARTFILE
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|dptr
operator|=
name|lcident
expr_stmt|;
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|lhs
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|=
name|fetch
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|dptr
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|#
directive|else
comment|/* !DBM */
name|hfp
operator|=
name|xfopen
argument_list|(
name|histfile
argument_list|(
name|lcident
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|hfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* can happen if nulls in file */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|lcase
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfr
argument_list|,
name|lcident
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
name|idunlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history returns true\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|TRUE
return|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DBM */
name|histline
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addhist
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|addhist
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history returns false\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_block

begin_decl_stmt
name|char
name|histline
index|[
name|PATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|addhist
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|histline
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|savehist
argument_list|(
argument|hline
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|hline
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|hfp
decl_stmt|;
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|long
name|fpos
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|hfp
operator|=
name|xfopen
argument_list|(
name|ARTFILE
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fpos
operator|=
name|ftell
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfp
argument_list|,
literal|"%s\n"
argument_list|,
name|hline
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
comment|/* We assume that history has already been called, calling dbminit. */
name|p
operator|=
name|index
argument_list|(
name|hline
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|lcase
argument_list|(
name|hline
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|dptr
operator|=
name|hline
expr_stmt|;
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|lhs
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fpos
expr_stmt|;
name|rhs
operator|.
name|dsize
operator|=
sizeof|sizeof
name|fpos
expr_stmt|;
name|store
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DBM */
comment|/* also append to proper history subfile */
name|hfp
operator|=
name|xfopen
argument_list|(
name|histfile
argument_list|(
name|hline
argument_list|)
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfp
argument_list|,
literal|"%s\n"
argument_list|,
name|hline
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DBM */
name|idunlock
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Save partial news.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|newssave
argument_list|(
argument|fd
argument_list|,
argument|dummy
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dummy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|tofd
decl_stmt|,
modifier|*
name|fromfd
decl_stmt|;
name|char
name|sfname
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|time_t
name|tim
decl_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
name|fromfd
operator|=
name|xfopen
argument_list|(
name|INFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|fromfd
operator|=
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|savmask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sfname
argument_list|,
literal|"%s/%s"
argument_list|,
name|userhome
argument_list|,
name|PARTIAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tofd
operator|=
name|fopen
argument_list|(
name|sfname
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot save partial news in %s"
argument_list|,
name|sfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|tim
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tofd
argument_list|,
literal|"----- News saved at %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|tim
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fromfd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|tofd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"News saved in %s\n"
argument_list|,
name|sfname
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handle dates in header.  */
end_comment

begin_macro
name|dates
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|time_t
name|edt
decl_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|subdate
condition|)
block|{
if|if
condition|(
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
operator|<
literal|0
condition|)
block|{
name|xerror
argument_list|(
literal|"Cannot parse submittal date '%s'"
argument_list|,
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|edt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
name|arpadate
argument_list|(
operator|&
name|edt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|char
name|lockname
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|idlock
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tempname
index|[
literal|80
index|]
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|int
name|fd
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lockname
argument_list|,
literal|"/tmp/%s.l.1"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|lockname
argument_list|,
literal|0444
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
comment|/* !VMS */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tempname
argument_list|,
literal|"/tmp/LTMP.XXXXXX"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lockname
argument_list|,
literal|"/tmp/L%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOURTEENMAX
name|lockname
index|[
literal|5
comment|/* /tmp/ */
operator|+
literal|14
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|creat
argument_list|(
name|tempname
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|xerror
argument_list|(
literal|"Cannot creat %s: errno %d"
argument_list|,
name|tempname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
argument_list|(
name|tempname
argument_list|,
name|lockname
argument_list|)
condition|)
block|{
endif|#
directive|endif
comment|/* !VMS */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|i
operator|=
name|stat
argument_list|(
name|lockname
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|xerror
argument_list|(
literal|"Directory permission problem in /tmp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf
operator|.
name|st_mtime
operator|+
literal|10
operator|*
literal|60
operator|<
name|now
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
name|logerr
argument_list|(
literal|"Article %s locked up"
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
name|log
argument_list|(
literal|"waiting on lock for %s"
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|60
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
block|}
name|idunlock
argument_list|()
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
block|}
comment|/*  * Put a unique name into header.ident.  */
name|getident
argument_list|(
argument|hp
argument_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
block|{
name|long
name|seqn
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|SEQFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|seqn
operator|=
name|atol
argument_list|(
name|bfr
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SEQFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|fp
operator|=
name|xfopen
argument_list|(
name|SEQFILE
argument_list|,
literal|"r+w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%ld\n"
argument_list|,
name|seqn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HIDDENNET
if|if
condition|(
name|strcmp
argument_list|(
name|LOCALSYSNAME
argument_list|,
name|FULLSYSNAME
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"<%ld@%s.%s%s>"
argument_list|,
name|seqn
argument_list|,
name|LOCALSYSNAME
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* !HIDDENNET */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"<%ld@%s%s>"
argument_list|,
name|seqn
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
block|}
comment|/*  * Check that header.nbuf contains only valid newsgroup names;  * exit with error if not valid.  *  */
name|ngfcheck
argument_list|(
argument|isproc
argument_list|)
name|int
name|isproc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|os1
decl_stmt|;
name|int
name|ngroups
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|ngsize
init|=
name|AFSIZ
decl_stmt|;
name|char
name|tbuf
index|[
name|BUFLEN
index|]
decl_stmt|,
modifier|*
name|ngcheck
decl_stmt|;
name|f
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ngcheck
operator|=
name|malloc
argument_list|(
name|ngsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngcheck
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Can't malloc the active file"
argument_list|)
expr_stmt|;
name|s1
operator|=
name|ngcheck
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|os1
operator|=
name|s1
expr_stmt|;
for|for
control|(
name|s2
operator|=
name|bfr
init|;
operator|*
name|s2
operator|!=
literal|'\0'
operator|&&
operator|*
name|s2
operator|!=
literal|' '
condition|;
control|)
block|{
if|if
condition|(
name|s1
operator|>=
operator|&
name|ngcheck
index|[
name|ngsize
operator|-
literal|2
index|]
condition|)
block|{
name|unsigned
name|int
name|offs
init|=
name|s1
operator|-
name|ngcheck
decl_stmt|;
name|ngsize
operator|+=
name|LBUFLEN
expr_stmt|;
name|ngcheck
operator|=
name|realloc
argument_list|(
name|ngcheck
argument_list|,
name|ngsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngcheck
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Can't realloc active file"
argument_list|)
expr_stmt|;
name|s1
operator|=
name|ngcheck
operator|+
name|offs
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isproc
condition|)
comment|/* don't check to see if can post to this group */
continue|continue;
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'\0'
operator|&&
operator|*
name|s2
operator|!=
literal|' '
condition|)
empty_stmt|;
comment|/* skip max article number */
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'\0'
operator|&&
operator|*
name|s2
operator|!=
literal|' '
condition|)
empty_stmt|;
comment|/* skip min article number */
if|if
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'\0'
operator|&&
operator|*
name|s2
operator|==
literal|'n'
condition|)
name|s1
operator|=
name|os1
expr_stmt|;
comment|/* can't post to this group */
block|}
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|s1
operator|=
name|header
operator|.
name|nbuf
expr_stmt|;
name|s2
operator|=
name|nbuf
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|==
name|NGDELIM
operator|||
operator|*
name|s1
operator|==
literal|' '
condition|)
name|s1
operator|++
expr_stmt|;
comment|/* skip leading junk */
do|do
block|{
comment|/* there shouldn't be blanks, but give the jerk a break */
if|if
condition|(
operator|*
name|s1
operator|==
name|NGDELIM
operator|||
operator|*
name|s1
operator|==
literal|' '
condition|)
block|{
operator|*
name|s2
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s1
operator|==
name|NGDELIM
operator|||
operator|*
name|s1
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/* remove extra commas */
if|if
condition|(
operator|*
name|s1
operator|!=
literal|'\0'
condition|)
name|ngroups
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s1
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|s2
index|[
operator|-
literal|1
index|]
operator|==
name|NGDELIM
condition|)
comment|/* strip trailing commas */
name|s2
operator|--
expr_stmt|;
operator|*
name|s2
operator|=
literal|'\0'
expr_stmt|;
name|s1
operator|=
name|nbuf
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|!=
literal|'\0'
condition|)
block|{
comment|/* for each newsgroup in header */
name|s2
operator|=
name|ngcheck
expr_stmt|;
while|while
condition|(
operator|*
name|s2
operator|!=
literal|'\0'
condition|)
block|{
comment|/* for each newsgroup in active file */
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|==
literal|0
condition|)
break|break;
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|s2
operator|==
literal|'\0'
condition|)
block|{
comment|/* not found. remove it */
if|if
condition|(
operator|!
name|isproc
condition|)
block|{
name|logerr
argument_list|(
literal|"Invalid news group '%s'"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|newssave
argument_list|(
name|stdin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* See if it's in our alias list */
name|f
operator|=
name|xfopen
argument_list|(
name|ALIASES
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%s %s"
argument_list|,
name|tbuf
argument_list|,
name|bfr
argument_list|)
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|s1
argument_list|,
name|tbuf
argument_list|)
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|tbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|logerr
argument_list|(
literal|"Aliased newsgroup '%s' to '%s'"
argument_list|,
name|s1
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|os1
operator|=
name|s1
expr_stmt|;
name|s1
operator|=
name|nbuf
expr_stmt|;
name|s2
operator|=
name|tbuf
expr_stmt|;
while|while
condition|(
name|s1
operator|<
name|os1
condition|)
comment|/* copy left part */
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
name|s1
operator|=
name|bfr
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|!=
literal|'\0'
condition|)
comment|/* copy alias */
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
operator|*
name|s2
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|s1
operator|=
name|os1
expr_stmt|;
name|os1
operator|=
name|nbuf
operator|+
operator|(
name|s2
operator|-
name|tbuf
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'\0'
condition|)
comment|/* skip old group */
empty_stmt|;
comment|/* copy right part */
name|tbufcpy
argument_list|(
name|s2
argument_list|,
name|s1
argument_list|)
expr_stmt|;
comment|/* copy back to original buffer */
name|tbufcpy
argument_list|(
name|nbuf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|s1
operator|=
name|os1
expr_stmt|;
block|}
else|else
block|{
name|logerr
argument_list|(
literal|"Unknown newsgroup '%s' removed"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|s1
expr_stmt|;
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'\0'
condition|)
comment|/* skip the bad one */
empty_stmt|;
name|tbufcpy
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's in our active file */
name|os1
operator|=
name|s1
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
comment|/* check for local only distribution on incoming 			   newsgroups. This might occur if someone posted to 			   general,net.unix */
if|if
condition|(
name|isproc
operator|&&
name|ngroups
operator|>
literal|1
operator|&&
name|index
argument_list|(
name|os1
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
operator|&&
name|index
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|logerr
argument_list|(
literal|"Local group '%s' removed"
argument_list|,
name|os1
argument_list|)
expr_stmt|;
name|tbufcpy
argument_list|(
name|os1
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|s1
operator|=
name|os1
expr_stmt|;
block|}
block|}
block|}
comment|/*  remove any duplicates */
name|os1
operator|=
name|s1
operator|=
name|nbuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
condition|)
break|break;
name|s2
operator|=
name|s1
expr_stmt|;
while|while
condition|(
operator|*
name|s2
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|os1
argument_list|,
name|s2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|logerr
argument_list|(
literal|"Duplicate '%s' removed"
argument_list|,
name|os1
argument_list|)
expr_stmt|;
name|os1
operator|=
name|s2
expr_stmt|;
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'\0'
condition|)
comment|/* skip it */
empty_stmt|;
name|tbufcpy
argument_list|(
name|os1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
name|os1
operator|=
name|s1
expr_stmt|;
name|s1
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|s1
operator|=
name|header
operator|.
name|nbuf
expr_stmt|;
name|s2
operator|=
name|nbuf
expr_stmt|;
do|do
block|{
while|while
condition|(
operator|*
name|s2
operator|!=
literal|'\0'
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
name|NGDELIM
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|s2
operator|!=
literal|'\0'
condition|)
do|;
operator|*
operator|--
name|s1
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|ngcheck
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
name|ngcheck
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|tbufcpy
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
block|{
do|do
block|{
while|while
condition|(
operator|*
name|s2
operator|!=
literal|'\0'
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|s2
operator|!=
literal|'\0'
condition|)
do|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*  * Figure out who posted the article (which is locally entered).  * The results are placed in the header structure hp.  */
name|gensender
argument_list|(
argument|hp
argument_list|,
argument|logname
argument_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|logname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|fullname
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|;
name|fn
operator|=
name|getenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|userhome
argument_list|,
literal|".name"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|buf
index|[
literal|0
index|]
operator|>=
literal|'A'
condition|)
block|{
name|fn
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fn
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|<
literal|' '
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
name|fn
operator|=
name|fullname
argument_list|(
name|logname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|path
argument_list|,
literal|"%s"
argument_list|,
name|logname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|"%s@%s%s (%s)"
argument_list|,
name|logname
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/*  * Trap interrupts.  */
name|onsig
argument_list|(
argument|n
argument_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|int
name|numsigs
init|=
literal|0
decl_stmt|;
comment|/* 	 * Most UNIX systems reset caught signals to SIG_DFL. 	 * This bad design requires that the trap be set again here. 	 * Unfortunately, if the signal recurs before the trap is set, 	 * the program will die, possibly leaving the lock in place. 	 */
if|if
condition|(
operator|++
name|numsigs
operator|>
literal|100
condition|)
block|{
name|logerr
argument_list|(
literal|"inews ran away looping on signal %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|n
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|SigTrap
operator|=
name|n
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BATCH
comment|/*  * If the stdin begins with "#", we assume we have been fed a batched  * shell script which looks like this:  *	#! rnews 1234  *	article with 1234 chars  *	#! rnews 4321  *	article with 4321 chars  *  * In this case we just exec the unbatcher and let it unpack and call us back.  *  * Note that there is a potential security hole here.  If the batcher is  * /bin/sh, someone could ship you arbitrary stuff to run as shell commands.  * The main protection you have is that the effective uid will be news, not  * uucp and not the super user.  (That, plus the fact that BATCH is set to  * "unbatch" as the system is distributed.)  If you want to run a batched link  * and you are security conscious, do not use /bin/sh as the unbatcher.  * the thing to do is to change BATCH in your localize.sh file from /bin/sh  * to some restricted shell which can only run rnews.  */
name|checkbatch
argument_list|()
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|char
name|unbatcher
index|[
name|BUFLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|unbatcher
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
name|BATCH
argument_list|)
expr_stmt|;
name|reset_stdin
argument_list|()
expr_stmt|;
name|execl
argument_list|(
name|unbatcher
argument_list|,
literal|"news-unpack"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"Unable to exec shell to unpack news."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * We've already done a read on stdin, and we want to seek back to the  * beginning.  We want the real file descriptor (beyond buffers) to  * reflect the true beginning.  Do whatever is necessary.  */
name|reset_stdin
argument_list|()
block|{
specifier|register
name|FILE
modifier|*
name|ofd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|ofdname
decl_stmt|;
name|long
name|lseek
parameter_list|()
function_decl|;
comment|/* First try to seek back - if so, it's a cheap way back. */
if|if
condition|(
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
operator|==
literal|0L
condition|)
return|return;
comment|/* Can't seek, so have to copy input to a file and use that. */
name|ofdname
operator|=
literal|"/tmp/inewsXXXXXX"
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|ofdname
argument_list|)
expr_stmt|;
name|ofd
operator|=
name|fopen
argument_list|(
name|ofdname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ofd
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"write failed on temp file %s"
argument_list|,
name|ofdname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
comment|/* Now for a few lower level hacks to reopen stdin and make 	 * absolutely sure that the right fd's are done for the exec. 	 */
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure stdin is really closed. */
operator|(
name|void
operator|)
name|open
argument_list|(
name|ofdname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* should return zero */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ofdname
argument_list|)
expr_stmt|;
comment|/* to avoid cleaning it up later. */
block|}
endif|#
directive|endif
comment|/* BATCH */
comment|/*  *	Exit and cleanup.  */
name|xxit
argument_list|(
argument|status
argument_list|)
name|int
name|status
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|INFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ARTICLE
argument_list|)
expr_stmt|;
while|while
condition|(
name|lockcount
operator|>
literal|0
condition|)
name|unlock
argument_list|()
expr_stmt|;
name|idunlock
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|rwaccess
argument_list|(
argument|fname
argument_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|exists
argument_list|(
argument|fname
argument_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|int
name|lockcount
init|=
literal|0
decl_stmt|;
comment|/* no. of times we've called lock */
ifdef|#
directive|ifdef
name|VMS
define|#
directive|define
name|SUBLOCK
value|"/tmp/netnews.lck.1"
comment|/*  * Newsystem locking.  * These routines are different for VMS because we can not  * effectively simulate links, and VMS supports multiple  * version numbers of files  */
name|lock
argument_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|lockcount
operator|++
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|DEADTIME
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|SUBLOCK
argument_list|,
literal|0444
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SUBLOCK
argument_list|)
expr_stmt|;
name|logerr
argument_list|(
literal|"News system locked up"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
operator|-
literal|3
condition|)
name|xerror
argument_list|(
literal|"Unable to unlock news system"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock
argument_list|()
block|{
if|if
condition|(
operator|--
name|lockcount
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|SUBLOCK
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !VMS */
comment|/*  * Newsystem locking.  */
ifdef|#
directive|ifdef
name|BSD4_2
include|#
directive|include
file|<sys/file.h>
specifier|static
name|int
name|LockFd
init|=
operator|-
literal|1
decl_stmt|;
name|lock
argument_list|()
block|{
name|LockFd
operator|=
name|open
argument_list|(
name|SUBFILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This will sleep until the other program releases the lock */
comment|/* We may need to alarm out of this, but I don't think so */
operator|(
name|void
operator|)
name|flock
argument_list|(
name|LockFd
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
block|}
name|unlock
argument_list|()
block|{
operator|(
name|void
operator|)
name|flock
argument_list|(
name|LockFd
argument_list|,
name|LOCK_UN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|LockFd
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !BSD4_2 */
comment|/* Why doesn't USG unix have file locking????? */
name|lock
argument_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|lockcount
operator|++
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|DEADTIME
expr_stmt|;
while|while
condition|(
name|link
argument_list|(
name|SUBFILE
argument_list|,
name|LOCKFILE
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
break|break;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|xerror
argument_list|(
literal|"News system locked up"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|unlock
argument_list|()
block|{
if|if
condition|(
operator|--
name|lockcount
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|LOCKFILE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !BSD4_2 */
endif|#
directive|endif
comment|/* !VMS */
comment|/*  * Generate the name of the person responsible for posting this article,  * in order to check that two articles were posted by the same person.  */
name|char
modifier|*
name|senderof
parameter_list|(
name|hp
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|tailpath
parameter_list|()
function_decl|;
if|if
condition|(
name|hp
operator|->
name|sender
index|[
literal|0
index|]
condition|)
name|tp
operator|=
name|hp
operator|->
name|sender
expr_stmt|;
elseif|else
if|if
condition|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
condition|)
name|tp
operator|=
name|hp
operator|->
name|from
expr_stmt|;
else|else
name|tp
operator|=
name|tailpath
argument_list|(
name|hp
argument_list|)
expr_stmt|;
comment|/* Remove full name */
name|q
operator|=
name|index
argument_list|(
name|tp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|tp
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|q
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_block

end_unit

