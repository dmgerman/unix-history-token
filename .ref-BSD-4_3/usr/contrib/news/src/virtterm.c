begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Virtual terminal handler  *  Written by Kenneth Almquist, AGS Computers  (HO 4C601, X7105).  *  Modified by Stephen Hemminger, to use TERMCAP (without curses)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)virtterm.c	1.10	1/17/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USG */
end_comment

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USG */
end_comment

begin_comment
comment|/*  * These values for MAXPLEN and MAXLLEN are used to dimension arrays  * that hold strings of relative cursor motions.  The actual arrays that  * are used to hold screen images are malloc'd.  */
end_comment

begin_define
define|#
directive|define
name|MAXPLEN
value|90
end_define

begin_define
define|#
directive|define
name|MAXLLEN
value|160
end_define

begin_define
define|#
directive|define
name|BOTLINE
value|(ROWS - 1)
end_define

begin_define
define|#
directive|define
name|DIRTY
value|01
end_define

begin_comment
comment|/* terminal escape sequences from termcap */
end_comment

begin_define
define|#
directive|define
name|HO
value|_tstr[0]
end_define

begin_comment
comment|/* home */
end_comment

begin_define
define|#
directive|define
name|CL
value|_tstr[1]
end_define

begin_comment
comment|/* clear screen */
end_comment

begin_define
define|#
directive|define
name|CD
value|_tstr[2]
end_define

begin_comment
comment|/* clear to end of screen */
end_comment

begin_define
define|#
directive|define
name|CE
value|_tstr[3]
end_define

begin_comment
comment|/* clear to end of line */
end_comment

begin_define
define|#
directive|define
name|xUP
value|_tstr[4]
end_define

begin_comment
comment|/* up one line */
end_comment

begin_define
define|#
directive|define
name|DO
value|_tstr[5]
end_define

begin_comment
comment|/* down one line */
end_comment

begin_define
define|#
directive|define
name|US
value|_tstr[6]
end_define

begin_comment
comment|/* underline */
end_comment

begin_define
define|#
directive|define
name|UE
value|_tstr[7]
end_define

begin_comment
comment|/* underline end */
end_comment

begin_define
define|#
directive|define
name|BT
value|_tstr[8]
end_define

begin_comment
comment|/* backtab */
end_comment

begin_define
define|#
directive|define
name|xBC
value|_tstr[9]
end_define

begin_comment
comment|/* backspace */
end_comment

begin_define
define|#
directive|define
name|AL
value|_tstr[10]
end_define

begin_comment
comment|/* insert line */
end_comment

begin_define
define|#
directive|define
name|DL
value|_tstr[11]
end_define

begin_comment
comment|/* delete line */
end_comment

begin_define
define|#
directive|define
name|CM
value|_tstr[12]
end_define

begin_comment
comment|/* cursor move */
end_comment

begin_define
define|#
directive|define
name|CH
value|_tstr[13]
end_define

begin_comment
comment|/* cursor horizontal move */
end_comment

begin_define
define|#
directive|define
name|CV
value|_tstr[14]
end_define

begin_comment
comment|/* cursor vertical move */
end_comment

begin_define
define|#
directive|define
name|CS
value|_tstr[15]
end_define

begin_comment
comment|/* scrolling region */
end_comment

begin_define
define|#
directive|define
name|SF
value|_tstr[16]
end_define

begin_comment
comment|/* scroll forwards */
end_comment

begin_define
define|#
directive|define
name|SR
value|_tstr[17]
end_define

begin_comment
comment|/* scroll backwards */
end_comment

begin_define
define|#
directive|define
name|TI
value|_tstr[18]
end_define

begin_comment
comment|/* start cursor mode */
end_comment

begin_define
define|#
directive|define
name|TE
value|_tstr[19]
end_define

begin_comment
comment|/* end cursor mode */
end_comment

begin_define
define|#
directive|define
name|TA
value|_tstr[20]
end_define

begin_comment
comment|/* tab char (if not \t) */
end_comment

begin_define
define|#
directive|define
name|CR
value|_tstr[21]
end_define

begin_comment
comment|/* carriage return (if not \r) */
end_comment

begin_define
define|#
directive|define
name|xPC
value|_tstr[22]
end_define

begin_comment
comment|/* for reading pad character */
end_comment

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pad character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external variables for tgoto */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sname
index|[]
init|=
literal|"hoclcdceupdousuebtbcaldlcmchcvcssfsrtitetacrpc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_tstr
index|[
literal|23
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|HOlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of HO string */
end_comment

begin_comment
comment|/* terminal flags */
end_comment

begin_define
define|#
directive|define
name|BS
value|_tflg[0]
end_define

begin_comment
comment|/* can backspace */
end_comment

begin_define
define|#
directive|define
name|AM
value|_tflg[1]
end_define

begin_comment
comment|/* has auto margins */
end_comment

begin_define
define|#
directive|define
name|XN
value|_tflg[2]
end_define

begin_comment
comment|/* no newline after wrap */
end_comment

begin_define
define|#
directive|define
name|RET
value|!_tflg[3]
end_define

begin_comment
comment|/* has carriage return */
end_comment

begin_define
define|#
directive|define
name|NS
value|_tflg[4]
end_define

begin_comment
comment|/* has SF (scroll forward) */
end_comment

begin_define
define|#
directive|define
name|PT
value|_tflg[5]
end_define

begin_comment
comment|/* has tabs */
end_comment

begin_define
define|#
directive|define
name|XT
value|_tflg[6]
end_define

begin_comment
comment|/* tabs are destructive */
end_comment

begin_decl_stmt
name|int
name|GT
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tab stops on terminal are set */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bname
index|[]
init|=
literal|"bsamxnncnsptxt"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|_tflg
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|tgetstr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ULINE
value|0200
end_define

begin_comment
comment|/* Constants accessable by user */
end_comment

begin_decl_stmt
name|int
name|hasscroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scrolling type, 0 == no scrolling */
end_comment

begin_decl_stmt
name|int
name|ROWS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines on screen */
end_comment

begin_decl_stmt
name|int
name|COLS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of screen */
end_comment

begin_struct
struct|struct
name|line
block|{
name|char
name|len
decl_stmt|;
name|char
name|flags
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|;
comment|/* pointer to actual line text, NO NULL @ end */
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|_row
decl_stmt|,
name|_col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_srow
decl_stmt|,
name|_scol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|line
modifier|*
name|_virt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what we want the screen to look like */
end_comment

begin_decl_stmt
name|struct
name|line
modifier|*
name|_actual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What it actually looks like */
end_comment

begin_decl_stmt
name|int
name|_uline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_junked
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_curjunked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_dir
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_shifttop
decl_stmt|,
name|_shiftbot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_scratched
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|vputc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Tell refresh to shift lines in region upwards count lines.  Count  * may be negative.  The virtual image is not shifted; this may change  * later.  The variable _scratched is set to supress all attempts to  * shift.  */
end_comment

begin_macro
name|ushift
argument_list|(
argument|top
argument_list|,
argument|bot
argument_list|,
argument|count
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|_scratched
condition|)
return|return;
if|if
condition|(
name|_shift
operator|!=
literal|0
operator|&&
operator|(
name|_shifttop
operator|!=
name|top
operator|||
name|_shiftbot
operator|!=
name|bot
operator|)
condition|)
block|{
name|_scratched
operator|++
expr_stmt|;
return|return;
block|}
name|_shifttop
operator|=
name|top
expr_stmt|;
name|_shiftbot
operator|=
name|bot
expr_stmt|;
name|_shift
operator|+=
name|count
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate a beep on the terminal  */
end_comment

begin_macro
name|beep
argument_list|()
end_macro

begin_block
block|{
name|vputc
argument_list|(
literal|'\7'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Move to one line below the bottom of the screen.  */
end_comment

begin_macro
name|botscreen
argument_list|()
end_macro

begin_block
block|{
name|_amove
argument_list|(
name|BOTLINE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|move
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|row
operator|<
literal|0
operator|||
name|row
operator|>=
name|ROWS
operator|||
name|col
operator|<
literal|0
operator|||
name|col
operator|>=
name|COLS
condition|)
return|return;
name|_row
operator|=
name|row
expr_stmt|;
name|_col
operator|=
name|col
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Output string at specified location.  */
end_comment

begin_macro
name|mvaddstr
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|,
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|addstr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|line
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|col
init|=
name|_col
decl_stmt|;
name|lp
operator|=
operator|&
name|_virt
index|[
name|_row
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|len
operator|<
name|col
condition|)
block|{
name|p
operator|=
operator|&
name|lp
operator|->
name|l
index|[
name|lp
operator|->
name|len
index|]
expr_stmt|;
while|while
condition|(
name|lp
operator|->
name|len
operator|<
name|col
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|lp
operator|->
name|len
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|lp
operator|->
name|len
operator|=
name|col
expr_stmt|;
name|lp
operator|->
name|flags
operator||=
name|DIRTY
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|_row
operator|>=
name|ROWS
condition|)
name|_row
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
operator|&
name|_virt
index|[
name|_row
index|]
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|->
name|l
index|[
name|col
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|lp
operator|->
name|flags
operator||=
name|DIRTY
expr_stmt|;
if|if
condition|(
operator|++
name|col
operator|>=
name|COLS
condition|)
block|{
name|lp
operator|->
name|len
operator|=
name|COLS
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|_row
operator|>=
name|ROWS
condition|)
name|_row
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
operator|&
name|_virt
index|[
name|_row
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lp
operator|->
name|len
operator|<=
name|col
condition|)
name|lp
operator|->
name|len
operator|=
name|col
expr_stmt|;
name|_col
operator|=
name|col
expr_stmt|;
block|}
end_block

begin_macro
name|addch
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|line
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|lp
operator|=
operator|&
name|_virt
index|[
name|_row
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|len
operator|<
name|_col
condition|)
block|{
name|p
operator|=
operator|&
name|lp
operator|->
name|l
index|[
name|lp
operator|->
name|len
index|]
expr_stmt|;
while|while
condition|(
name|lp
operator|->
name|len
operator|<
name|_col
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|lp
operator|->
name|len
operator|++
expr_stmt|;
block|}
block|}
name|lp
operator|->
name|l
index|[
name|_col
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|len
operator|==
name|_col
condition|)
name|lp
operator|->
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|_col
operator|>=
name|COLS
condition|)
block|{
name|_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|_row
operator|>=
name|ROWS
condition|)
name|_row
operator|=
literal|0
expr_stmt|;
block|}
name|lp
operator|->
name|flags
operator||=
name|DIRTY
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear an entire line.  */
end_comment

begin_macro
name|clrline
argument_list|(
argument|row
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|line
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
operator|&
name|_virt
index|[
name|row
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|lp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|flags
operator||=
name|DIRTY
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|erase
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
name|i
operator|++
control|)
block|{
name|_virt
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|_virt
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|DIRTY
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|refresh
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|checkin
argument_list|()
condition|)
return|return;
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|_junked
condition|)
block|{
name|_sclear
argument_list|()
expr_stmt|;
name|_junked
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|_scratched
condition|)
block|{
if|if
condition|(
name|_shift
operator|>
literal|0
condition|)
block|{
name|_ushift
argument_list|(
name|_shifttop
argument_list|,
name|_shiftbot
argument_list|,
name|_shift
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_shift
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|_dshift
argument_list|(
name|_shifttop
argument_list|,
name|_shiftbot
argument_list|,
operator|-
name|_shift
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|_dir
expr_stmt|;
block|}
block|}
name|_dir
operator|=
name|i
expr_stmt|;
name|_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|checkin
argument_list|()
condition|)
return|return;
name|_fixlines
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|_dir
operator|>
literal|0
condition|?
literal|0
else|:
name|BOTLINE
init|;
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|ROWS
condition|;
name|i
operator|+=
name|_dir
control|)
block|{
if|if
condition|(
operator|(
name|_virt
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|DIRTY
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|_ckclrlin
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* decide whether to do a clear line */
comment|/* probably should consider cd too  */
name|len
operator|=
name|_virt
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|<
name|len
condition|)
name|len
operator|=
name|_actual
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|p
operator|=
name|_virt
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
name|q
operator|=
name|_actual
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|q
condition|)
block|{
comment|/* Inline test for speed */
if|if
condition|(
name|i
operator|!=
name|_srow
operator|||
name|j
operator|!=
name|_scol
operator|||
name|_curjunked
condition|)
name|_amove
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|_aputc
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|_virt
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|>
name|len
condition|)
block|{
name|_clrtoeol
argument_list|(
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
comment|/* Inline test for speed */
if|if
condition|(
name|i
operator|!=
name|_srow
operator|||
name|j
operator|!=
name|_scol
operator|||
name|_curjunked
condition|)
name|_amove
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|_aputc
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|checkin
argument_list|()
condition|)
return|return;
block|}
name|_dir
operator|=
literal|1
expr_stmt|;
name|_amove
argument_list|(
name|_row
argument_list|,
name|_col
argument_list|)
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
comment|/* flush output buffer */
name|_scratched
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|_dshift
argument_list|(
argument|top
argument_list|,
argument|bot
argument_list|,
argument|count
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|bot
operator|-
name|top
operator|||
name|hasscroll
operator|<
literal|4
condition|)
block|{
comment|/* must have CS or AL/DL */
name|_scratched
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
name|bot
operator|-
name|count
init|;
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|==
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|i
operator|==
name|top
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|top
init|;
name|i
operator|<=
name|bot
condition|;
name|i
operator|++
control|)
name|_virt
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|DIRTY
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bot
init|;
name|i
operator|>=
name|top
operator|+
name|count
condition|;
name|i
operator|--
control|)
block|{
comment|/* FIXME, this should be done by recirculating the pointers */
specifier|register
name|j
expr_stmt|;
name|j
operator|=
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|=
name|_actual
index|[
name|i
operator|-
name|count
index|]
operator|.
name|len
expr_stmt|;
name|_actual
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|_actual
index|[
name|i
operator|-
name|count
index|]
operator|.
name|flags
expr_stmt|;
name|strncpy
argument_list|(
name|_actual
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|_actual
index|[
name|i
operator|-
name|count
index|]
operator|.
name|l
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
name|top
condition|;
name|i
operator|--
control|)
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hasscroll
operator|!=
literal|5
condition|)
block|{
comment|/* can we define scrolling region, and scroll back */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bot
argument_list|,
name|top
argument_list|)
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
comment|/* define scroll region */
name|_curjunked
operator|=
literal|1
expr_stmt|;
name|_amove
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|tputs
argument_list|(
name|SR
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
comment|/* scroll back */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|BOTLINE
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|_curjunked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|_amove
argument_list|(
name|bot
operator|-
name|count
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CD
operator|&&
name|bot
operator|==
name|BOTLINE
condition|)
name|tputs
argument_list|(
name|CD
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|tputs
argument_list|(
name|DL
argument_list|,
name|ROWS
operator|-
name|_srow
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
block|}
name|_amove
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|tputs
argument_list|(
name|AL
argument_list|,
name|ROWS
operator|-
name|_srow
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|_ushift
argument_list|(
argument|top
argument_list|,
argument|bot
argument_list|,
argument|count
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|bot
operator|-
name|top
operator|||
name|hasscroll
operator|==
literal|0
condition|)
block|{
name|_scratched
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|top
operator|+
name|count
init|;
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|==
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|bot
condition|)
return|return;
if|if
condition|(
name|hasscroll
operator|==
literal|1
operator|||
name|hasscroll
operator|==
literal|3
condition|)
block|{
comment|/* we cheat and shift the entire screen */
comment|/* be sure we are shifting more lines into than out of position */
if|if
condition|(
operator|(
name|bot
operator|-
name|top
operator|+
literal|1
operator|)
operator|-
name|count
operator|<=
name|ROWS
operator|-
operator|(
name|bot
operator|-
name|top
operator|+
literal|1
operator|)
condition|)
return|return;
name|top
operator|=
literal|0
operator|,
name|bot
operator|=
name|BOTLINE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|top
init|;
name|i
operator|<=
name|bot
condition|;
name|i
operator|++
control|)
name|_virt
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|DIRTY
expr_stmt|;
for|for
control|(
name|i
operator|=
name|top
init|;
name|i
operator|<=
name|bot
operator|-
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* FIXME, this should be done by recirculating the pointers */
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|=
name|_actual
index|[
name|i
operator|+
name|count
index|]
operator|.
name|len
expr_stmt|;
name|_actual
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|_actual
index|[
name|i
operator|+
name|count
index|]
operator|.
name|flags
expr_stmt|;
name|strncpy
argument_list|(
name|_actual
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|_actual
index|[
name|i
operator|+
name|count
index|]
operator|.
name|l
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<=
name|bot
condition|;
name|i
operator|++
control|)
for|for
control|(
init|;
name|i
operator|<=
name|bot
condition|;
name|i
operator|++
control|)
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hasscroll
operator|!=
literal|5
condition|)
block|{
if|if
condition|(
name|top
operator|!=
literal|0
operator|||
name|bot
operator|!=
name|BOTLINE
condition|)
block|{
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bot
argument_list|,
name|top
argument_list|)
argument_list|,
literal|0
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|_curjunked
operator|=
literal|1
expr_stmt|;
block|}
name|_amove
argument_list|(
name|bot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* move to bottom */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SF
condition|)
comment|/* scroll forward */
name|tputs
argument_list|(
name|SF
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
else|else
name|vputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|!=
literal|0
operator|||
name|bot
operator|!=
name|BOTLINE
condition|)
block|{
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|BOTLINE
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|_curjunked
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|_amove
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|tputs
argument_list|(
name|DL
argument_list|,
name|ROWS
operator|-
name|_srow
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bot
operator|<
name|BOTLINE
condition|)
block|{
name|_amove
argument_list|(
name|bot
operator|-
name|count
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|tputs
argument_list|(
name|AL
argument_list|,
name|ROWS
operator|-
name|_srow
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|_sclear
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|line
modifier|*
name|lp
decl_stmt|;
name|tputs
argument_list|(
name|CL
argument_list|,
literal|0
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|_srow
operator|=
name|_scol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|_actual
init|;
name|lp
operator|<
operator|&
name|_actual
index|[
name|ROWS
index|]
condition|;
name|lp
operator|++
control|)
block|{
name|lp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|lp
operator|=
name|_virt
init|;
name|lp
operator|<
operator|&
name|_virt
index|[
name|ROWS
index|]
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|len
operator|!=
literal|0
condition|)
name|lp
operator|->
name|flags
operator||=
name|DIRTY
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|_clrtoeol
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|line
modifier|*
name|lp
init|=
operator|&
name|_actual
index|[
name|row
index|]
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|CE
operator|&&
name|lp
operator|->
name|len
operator|>
name|col
operator|+
literal|1
condition|)
block|{
name|_amove
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|col
init|;
name|i
operator|<
name|lp
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|l
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
block|{
name|_amove
argument_list|(
name|row
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|_aputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lp
operator|->
name|len
operator|=
name|col
expr_stmt|;
block|}
end_block

begin_macro
name|_fixlines
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|line
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
name|i
operator|++
control|)
block|{
name|lp
operator|=
operator|&
name|_virt
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|flags
operator|&
name|DIRTY
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|lp
operator|->
name|l
index|[
name|lp
operator|->
name|len
index|]
init|;
operator|--
name|p
operator|>=
name|lp
operator|->
name|l
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|;
control|)
empty_stmt|;
name|lp
operator|->
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|lp
operator|->
name|l
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|len
operator|==
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|strncmp
argument_list|(
name|lp
operator|->
name|l
argument_list|,
name|_actual
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|lp
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
name|lp
operator|->
name|flags
operator|&=
operator|~
name|DIRTY
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Consider clearing the line before overwriting it.  * We always clear a line if it has underlined characters in it  * because these can cause problems.  Otherwise decide whether  * that will decrease the number of characters to change.  This  * routine could probably be simplified with no great loss.  */
end_comment

begin_macro
name|_ckclrlin
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|int
name|eval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|first
decl_stmt|;
specifier|register
name|struct
name|line
modifier|*
name|vp
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|CE
condition|)
return|return;
name|ap
operator|=
operator|&
name|_actual
index|[
name|i
index|]
expr_stmt|;
name|vp
operator|=
operator|&
name|_virt
index|[
name|i
index|]
expr_stmt|;
name|len
operator|=
name|ap
operator|->
name|len
expr_stmt|;
name|eval
operator|=
operator|-
name|strlen
argument_list|(
name|CE
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|vp
operator|->
name|len
condition|)
block|{
name|len
operator|=
name|vp
operator|->
name|len
expr_stmt|;
name|eval
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
operator|&&
name|vp
operator|->
name|l
index|[
name|j
index|]
operator|==
name|ap
operator|->
name|l
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|len
condition|)
return|return;
name|first
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|l
index|[
name|j
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|l
index|[
name|j
index|]
operator|!=
literal|' '
condition|)
block|{
while|while
condition|(
operator|++
name|j
operator|<
name|len
operator|&&
name|vp
operator|->
name|l
index|[
name|j
index|]
operator|==
literal|' '
operator|&&
name|ap
operator|->
name|l
index|[
name|j
index|]
operator|!=
literal|' '
condition|)
block|{
name|eval
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|len
condition|)
name|eval
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|vp
operator|->
name|l
index|[
name|j
index|]
operator|==
name|ap
operator|->
name|l
index|[
name|j
index|]
condition|)
block|{
while|while
condition|(
operator|++
name|j
operator|<
name|len
operator|&&
name|vp
operator|->
name|l
index|[
name|j
index|]
operator|==
name|ap
operator|->
name|l
index|[
name|j
index|]
condition|)
block|{
name|eval
operator|--
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|US
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ap
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|l
index|[
name|j
index|]
operator|&
name|ULINE
condition|)
block|{
name|eval
operator|=
literal|999
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|j
condition|)
name|first
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|j
operator|=
name|first
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|vp
operator|->
name|l
index|[
name|j
index|]
operator|!=
literal|' '
condition|)
break|break;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eval
operator|>
literal|0
condition|)
block|{
name|_amove
argument_list|(
name|i
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|=
name|first
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Move routine  * 	first compute direct cursor address string and cost  *	then relative motion string and cost,  *	then home then relative and cost  *	choose smallest and do it.  *  *	The plod stuff is to build the strings (with padding) then decide  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|plodstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current location in relmove string */
end_comment

begin_macro
name|plodput
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
operator|*
name|plodstr
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/* FIXME: speedup 1-char horiz moves:  print the char that's there. */
end_comment

begin_comment
comment|/* FIXME: avoid funniness if cm works. */
end_comment

begin_comment
comment|/* FIXME: Avoid setul(0) if cursor motion OK in standout (XM?) */
end_comment

begin_macro
name|_amove
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|)
end_macro

begin_block
block|{
name|char
name|direct
index|[
literal|20
index|]
decl_stmt|;
name|char
name|rel
index|[
name|MAXPLEN
operator|*
literal|10
operator|+
name|MAXLLEN
operator|*
literal|10
index|]
decl_stmt|;
comment|/* longest move is full screen */
name|char
name|ho
index|[
name|MAXPLEN
operator|*
literal|10
operator|+
name|MAXLLEN
operator|*
literal|10
index|]
decl_stmt|;
name|int
name|cost
decl_stmt|,
name|newcost
decl_stmt|;
specifier|register
name|char
modifier|*
name|movstr
decl_stmt|;
if|if
condition|(
name|row
operator|==
name|_srow
operator|&&
name|col
operator|==
name|_scol
operator|&&
name|_curjunked
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|_uline
condition|)
name|_setul
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Inline test for speed */
name|cost
operator|=
literal|999
expr_stmt|;
if|if
condition|(
name|CM
condition|)
block|{
name|plodstr
operator|=
name|direct
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
argument_list|,
literal|0
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
name|cost
operator|=
name|plodstr
operator|-
name|direct
expr_stmt|;
name|movstr
operator|=
name|direct
expr_stmt|;
block|}
if|if
condition|(
name|_curjunked
operator|==
literal|0
condition|)
block|{
name|plodstr
operator|=
name|rel
expr_stmt|;
if|if
condition|(
name|_vmove
argument_list|(
name|_srow
argument_list|,
name|row
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|plodstr
operator|-
name|rel
operator|)
operator|<
name|cost
comment|/* after vmove */
operator|&&
name|_hmove
argument_list|(
name|_scol
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|newcost
operator|=
name|plodstr
operator|-
name|rel
operator|)
operator|<
name|cost
condition|)
block|{
comment|/* after both */
name|cost
operator|=
name|newcost
expr_stmt|;
name|movstr
operator|=
name|rel
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cost
operator|>
name|HOlen
condition|)
block|{
comment|/* is it worth calculating */
name|plodstr
operator|=
name|ho
expr_stmt|;
name|tputs
argument_list|(
name|HO
argument_list|,
literal|0
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
if|if
condition|(
name|_vmove
argument_list|(
literal|0
argument_list|,
name|row
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|plodstr
operator|-
name|ho
operator|)
operator|<
name|cost
comment|/* after ho, vmove */
operator|&&
name|_hmove
argument_list|(
literal|0
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|newcost
operator|=
name|plodstr
operator|-
name|ho
operator|)
operator|<
name|cost
condition|)
block|{
comment|/* after all three */
name|cost
operator|=
name|newcost
expr_stmt|;
name|movstr
operator|=
name|ho
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cost
operator|<
literal|999
condition|)
while|while
condition|(
operator|--
name|cost
operator|>=
literal|0
condition|)
name|vputc
argument_list|(
operator|*
name|movstr
operator|++
argument_list|)
expr_stmt|;
name|_srow
operator|=
name|row
expr_stmt|;
name|_scol
operator|=
name|col
expr_stmt|;
name|_curjunked
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|_vmove
argument_list|(
argument|orow
argument_list|,
argument|nrow
argument_list|)
end_macro

begin_block
block|{
name|char
name|direct
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|saveplod
init|=
name|plodstr
decl_stmt|;
if|if
condition|(
name|CV
condition|)
block|{
name|plodstr
operator|=
name|direct
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CV
argument_list|,
name|nrow
argument_list|,
name|nrow
argument_list|)
argument_list|,
literal|0
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
operator|*
name|plodstr
operator|=
literal|'\0'
expr_stmt|;
name|plodstr
operator|=
name|saveplod
expr_stmt|;
block|}
if|if
condition|(
name|orow
operator|>
name|nrow
condition|)
block|{
comment|/* cursor up */
if|if
condition|(
operator|!
name|UP
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|orow
operator|>
name|nrow
condition|)
block|{
name|tputs
argument_list|(
name|UP
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
name|orow
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
name|orow
operator|<
name|nrow
condition|)
block|{
comment|/* cursor down */
if|if
condition|(
name|DO
condition|)
name|tputs
argument_list|(
name|DO
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
else|else
operator|*
name|plodstr
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|orow
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|CV
operator|&&
name|plodstr
operator|-
name|saveplod
operator|>=
name|strlen
argument_list|(
name|direct
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|plodstr
operator|=
name|saveplod
expr_stmt|;
for|for
control|(
name|p
operator|=
name|direct
init|;
operator|*
name|plodstr
operator|=
operator|*
name|p
operator|++
condition|;
name|plodstr
operator|++
control|)
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|_hmove
argument_list|(
argument|ocol
argument_list|,
argument|ncol
argument_list|,
argument|row
argument_list|)
end_macro

begin_block
block|{
name|char
name|direct
index|[
literal|128
index|]
decl_stmt|;
name|char
name|ret
index|[
name|MAXLLEN
operator|*
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|saveplod
init|=
name|plodstr
decl_stmt|;
name|char
modifier|*
name|movstr
decl_stmt|;
name|int
name|cost
decl_stmt|,
name|newcost
decl_stmt|;
name|cost
operator|=
literal|999
expr_stmt|;
if|if
condition|(
name|CH
condition|)
block|{
name|plodstr
operator|=
name|direct
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CH
argument_list|,
name|ncol
argument_list|,
name|ncol
argument_list|)
argument_list|,
literal|0
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
name|cost
operator|=
name|plodstr
operator|-
name|direct
expr_stmt|;
name|movstr
operator|=
name|direct
expr_stmt|;
name|plodstr
operator|=
name|saveplod
expr_stmt|;
block|}
if|if
condition|(
name|RET
operator|&&
name|ocol
operator|>
name|ncol
condition|)
block|{
comment|/* consider doing carriage return */
name|plodstr
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|CR
condition|)
name|tputs
argument_list|(
name|CR
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
else|else
operator|*
name|plodstr
operator|++
operator|=
literal|'\r'
expr_stmt|;
if|if
condition|(
name|_relhmove
argument_list|(
literal|0
argument_list|,
name|ncol
argument_list|,
name|row
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|newcost
operator|=
name|plodstr
operator|-
name|ret
operator|)
operator|<
name|cost
condition|)
block|{
name|cost
operator|=
name|newcost
expr_stmt|;
name|movstr
operator|=
name|ret
expr_stmt|;
block|}
name|plodstr
operator|=
name|saveplod
expr_stmt|;
block|}
if|if
condition|(
name|_relhmove
argument_list|(
name|ocol
argument_list|,
name|ncol
argument_list|,
name|row
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cost
operator|==
literal|999
condition|)
return|return
operator|-
literal|1
return|;
goto|goto
name|copy
goto|;
block|}
if|if
condition|(
name|plodstr
operator|-
name|saveplod
operator|>
name|cost
condition|)
block|{
name|copy
label|:
name|plodstr
operator|=
name|saveplod
expr_stmt|;
while|while
condition|(
operator|--
name|cost
operator|>=
literal|0
condition|)
operator|*
name|plodstr
operator|++
operator|=
operator|*
name|movstr
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|_relhmove
argument_list|(
argument|ocol
argument_list|,
argument|ncol
argument_list|,
argument|row
argument_list|)
end_macro

begin_block
block|{
name|int
name|tab
decl_stmt|;
if|if
condition|(
name|ocol
operator|<
name|ncol
operator|&&
name|PT
operator|&&
name|GT
condition|)
block|{
comment|/* tab (nondestructive) */
while|while
condition|(
operator|(
name|tab
operator|=
operator|(
name|ocol
operator|+
literal|8
operator|)
operator|&
operator|~
literal|07
operator|)
operator|<=
name|ncol
condition|)
block|{
if|if
condition|(
name|TA
condition|)
name|tputs
argument_list|(
name|TA
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
else|else
operator|*
name|plodstr
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|ocol
operator|=
name|tab
expr_stmt|;
block|}
if|if
condition|(
name|tab
operator|<
name|COLS
operator|&&
name|tab
operator|-
name|ncol
operator|<
name|ncol
operator|-
name|ocol
condition|)
block|{
if|if
condition|(
name|TA
condition|)
name|tputs
argument_list|(
name|TA
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
else|else
operator|*
name|plodstr
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|ocol
operator|=
name|tab
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BT
operator|&&
name|GT
operator|&&
name|ocol
operator|>
name|ncol
condition|)
block|{
comment|/* backwards tab */
while|while
condition|(
operator|(
name|tab
operator|=
operator|(
name|ocol
operator|-
literal|1
operator|)
operator|&
operator|~
literal|07
operator|)
operator|>=
name|ncol
condition|)
block|{
if|if
condition|(
name|BS
operator|&&
name|tab
operator|==
name|ocol
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|BC
condition|)
name|tputs
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
else|else
operator|*
name|plodstr
operator|++
operator|=
literal|'\b'
expr_stmt|;
block|}
else|else
name|tputs
argument_list|(
name|BT
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
name|ocol
operator|=
name|tab
expr_stmt|;
block|}
if|if
condition|(
name|ncol
operator|-
name|tab
operator|+
literal|1
operator|<
name|ocol
operator|-
name|ncol
condition|)
block|{
name|tputs
argument_list|(
name|BT
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
name|ocol
operator|=
name|tab
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ocol
operator|>
name|ncol
condition|)
block|{
comment|/* cursor left */
if|if
condition|(
operator|!
name|BS
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|ocol
operator|>
name|ncol
condition|)
block|{
if|if
condition|(
name|BC
operator|!=
name|NULL
condition|)
name|tputs
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|,
name|plodput
argument_list|)
expr_stmt|;
else|else
operator|*
name|plodstr
operator|++
operator|=
literal|'\b'
expr_stmt|;
name|ocol
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ocol
operator|<
name|ncol
condition|)
block|{
comment|/* cursor right */
specifier|register
name|struct
name|line
modifier|*
name|lp
init|=
operator|&
name|_actual
index|[
name|row
index|]
decl_stmt|;
comment|/* 		 * This code doesn't move over underlined characters properly, 		 * but in practice this doesn't seem to matter. 		 */
while|while
condition|(
name|ocol
operator|<
name|ncol
condition|)
block|{
if|if
condition|(
name|ocol
operator|<
name|lp
operator|->
name|len
condition|)
operator|*
name|plodstr
operator|++
operator|=
name|lp
operator|->
name|l
index|[
name|ocol
index|]
expr_stmt|;
else|else
operator|*
name|plodstr
operator|++
operator|=
literal|' '
expr_stmt|;
name|ocol
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|_aputc
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|_uline
operator|!=
operator|(
name|c
operator|&
name|ULINE
operator|)
condition|)
comment|/* Inline for speed */
name|_setul
argument_list|(
name|c
operator|&
name|ULINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|_scol
operator|>=
name|COLS
condition|)
block|{
if|if
condition|(
name|_srow
operator|==
name|ROWS
operator|-
literal|1
condition|)
block|{
comment|/* Don't ever paint last char of last line */
name|_scol
operator|--
expr_stmt|;
return|return;
block|}
name|_curjunked
operator|++
expr_stmt|;
comment|/* Don't assume AM is right */
block|}
name|vputc
argument_list|(
name|c
operator|&
operator|~
name|ULINE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|_setul
argument_list|(
argument|on
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|_uline
operator|==
literal|0
operator|&&
name|US
operator|!=
name|NULL
condition|)
block|{
name|tputs
argument_list|(
name|US
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|_uline
operator|=
name|ULINE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|_uline
operator|!=
literal|0
operator|&&
name|UE
operator|!=
name|NULL
condition|)
block|{
name|tputs
argument_list|(
name|UE
argument_list|,
literal|1
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|_uline
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Initialize termcap strings for later use.  */
end_comment

begin_macro
name|initterm
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|tcbuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* termcap buffer */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|USG
name|struct
name|termio
name|tio
decl_stmt|;
else|#
directive|else
comment|/* !USG */
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
endif|#
directive|endif
comment|/* !USG */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"TERM not set in environment"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tgetent
argument_list|(
name|tcbuf
argument_list|,
name|cp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|xerror
argument_list|(
literal|"Terminal not found in TERMCAP"
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
name|xerror
argument_list|(
literal|"Can't open /etc/termcap"
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
break|break;
block|}
ifdef|#
directive|ifdef
name|TIOCGWINSZ
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
name|int
name|winch
parameter_list|()
function_decl|;
name|COLS
operator|=
name|ROWS
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ROWS
operator|=
name|ws
operator|.
name|ws_row
expr_stmt|;
name|COLS
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
block|}
if|if
condition|(
name|ROWS
operator|<=
literal|0
condition|)
name|ROWS
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|if
condition|(
name|COLS
operator|<=
literal|0
condition|)
name|COLS
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ROWS
operator|<=
literal|0
operator|)
operator|||
operator|(
name|COLS
operator|<=
literal|0
operator|)
condition|)
name|xerror
argument_list|(
literal|"Can't get screen size"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|winch
argument_list|)
expr_stmt|;
comment|/* allow for changing window size */
block|}
else|#
directive|else
comment|/* !TIOCGWINSZ */
if|if
condition|(
operator|(
name|ROWS
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|COLS
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|xerror
argument_list|(
literal|"Can't get screen size"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !TIOCGWINSZ */
name|_zap
argument_list|()
expr_stmt|;
if|if
condition|(
name|CL
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"No clear screen defined"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HO
operator|==
name|NULL
operator|&&
name|CM
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"No home or cursor addressing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HO
condition|)
name|HOlen
operator|=
name|strlen
argument_list|(
name|HO
argument_list|)
expr_stmt|;
else|else
name|HOlen
operator|=
literal|999
expr_stmt|;
name|PC
operator|=
name|xPC
condition|?
name|xPC
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
name|BC
operator|=
name|xBC
expr_stmt|;
name|UP
operator|=
name|xUP
expr_stmt|;
if|if
condition|(
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
operator|>
literal|0
condition|)
name|US
operator|=
name|UE
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|XT
condition|)
comment|/* Destructive tab code not included */
name|PT
operator|=
literal|0
expr_stmt|;
comment|/* to keep things simple */
ifdef|#
directive|ifdef
name|USG
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
literal|0
condition|)
name|GT
operator|=
name|tio
operator|.
name|c_oflag
operator|&
name|TAB3
expr_stmt|;
else|#
directive|else
comment|/* !USG */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|==
literal|0
condition|)
name|GT
operator|=
name|ttyb
operator|.
name|sg_flags
operator|&
name|XTABS
expr_stmt|;
endif|#
directive|endif
comment|/* !USG */
block|{
name|char
modifier|*
name|thelines
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|thelines
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|ROWS
operator|*
name|COLS
argument_list|)
expr_stmt|;
name|_virt
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|ROWS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|_actual
operator|=
name|_virt
operator|+
name|ROWS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROWS
condition|;
name|i
operator|++
control|)
block|{
name|_virt
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|_virt
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|_actual
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|_actual
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|_virt
index|[
name|i
index|]
operator|.
name|l
operator|=
name|thelines
expr_stmt|;
name|thelines
operator|+=
name|COLS
expr_stmt|;
name|_actual
index|[
name|i
index|]
operator|.
name|l
operator|=
name|thelines
expr_stmt|;
name|thelines
operator|+=
name|COLS
expr_stmt|;
block|}
block|}
comment|/* Select article scrolling algorithm.  We prefer scrolling region 	   over insert/delete line because it's faster on the HP */
name|hasscroll
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NS
condition|)
block|{
name|hasscroll
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SR
condition|)
name|hasscroll
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|CS
condition|)
name|hasscroll
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|AL
operator|&&
name|DL
operator|&&
name|hasscroll
operator|!=
literal|4
condition|)
name|hasscroll
operator|=
literal|5
expr_stmt|;
block|}
end_block

begin_macro
name|rawterm
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|TI
operator|!=
name|NULL
condition|)
name|tputs
argument_list|(
name|TI
argument_list|,
literal|0
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cookedterm
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|TE
operator|!=
name|NULL
condition|)
block|{
name|tputs
argument_list|(
name|TE
argument_list|,
literal|0
argument_list|,
name|vputc
argument_list|)
expr_stmt|;
name|vflush
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* get strings from termcap */
end_comment

begin_macro
name|_zap
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|tstrbuf
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
modifier|*
name|namp
decl_stmt|,
modifier|*
modifier|*
name|sp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|tp
operator|=
name|tstrbuf
expr_stmt|;
name|sp
operator|=
name|_tstr
expr_stmt|;
for|for
control|(
name|namp
operator|=
name|sname
init|;
operator|*
name|namp
condition|;
name|namp
operator|+=
literal|2
control|)
block|{
operator|*
name|sp
operator|++
operator|=
name|tgetstr
argument_list|(
name|namp
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|_tflg
expr_stmt|;
for|for
control|(
name|namp
operator|=
name|bname
init|;
operator|*
name|namp
condition|;
name|namp
operator|+=
literal|2
control|)
block|{
operator|*
name|bp
operator|++
operator|=
name|tgetflag
argument_list|(
name|namp
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_comment
comment|/*  * window changed size -- update ROWS and COLS  * and then redraw screen  */
end_comment

begin_macro
name|winch
argument_list|()
end_macro

begin_block
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
name|int
name|cols
decl_stmt|,
name|rows
decl_stmt|;
name|cols
operator|=
name|rows
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rows
operator|=
name|ws
operator|.
name|ws_row
expr_stmt|;
name|cols
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|==
name|ROWS
operator|&&
name|cols
operator|==
name|COLS
condition|)
block|{
comment|/* just redraw it if no change */
name|_junked
operator|=
literal|1
expr_stmt|;
comment|/* redraw */
name|updscr
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rows
operator|>
literal|0
condition|)
name|ROWS
operator|=
name|rows
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|0
condition|)
name|COLS
operator|=
name|cols
expr_stmt|;
if|if
condition|(
name|ROWS
operator|>
name|MAXPLEN
condition|)
name|ROWS
operator|=
name|MAXPLEN
expr_stmt|;
if|if
condition|(
name|COLS
operator|>
name|MAXLLEN
condition|)
block|{
name|COLS
operator|=
name|MAXLLEN
expr_stmt|;
name|AM
operator|=
name|XN
operator|=
literal|1
expr_stmt|;
block|}
name|winch_upd
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|TIOCGWINSZ
end_endif

end_unit

