begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: types.c,v 2.0 85/11/21 07:21:51 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	types.c,v $  * Revision 2.0  85/11/21  07:21:51  jqj  * 4.3BSD standard release  *   * Revision 1.3  85/03/11  16:40:43  jqj  * *** empty log message ***  *   * Revision 1.3  85/03/11  16:40:43  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.2  85/02/21  11:06:29  jqj  * alpha test version  *   * Revision 1.1  85/02/15  13:55:49  jqj  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_comment
comment|/*  * Object allocation.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|make_type
parameter_list|(
name|constr
parameter_list|)
name|enum
name|constr
name|constr
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|typtr
operator|=
name|New
argument_list|(
expr|struct
name|type
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_constr
operator|=
name|constr
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|enumeration_type
parameter_list|(
name|items
parameter_list|)
name|list
name|items
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|typtr
operator|=
name|make_type
argument_list|(
name|C_ENUMERATION
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_list
operator|=
name|items
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|record_type
parameter_list|(
name|fields
parameter_list|)
name|list
name|fields
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
if|if
condition|(
name|fields
operator|==
name|NIL
condition|)
return|return
operator|(
name|NilRecord_type
operator|)
return|;
name|typtr
operator|=
name|make_type
argument_list|(
name|C_RECORD
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_list
operator|=
name|fields
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|error_type
parameter_list|(
name|arguments
parameter_list|)
name|list
name|arguments
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|typtr
operator|=
name|make_type
argument_list|(
name|C_ERROR
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_list
operator|=
name|arguments
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|array_type
parameter_list|(
name|size
parameter_list|,
name|bt
parameter_list|)
name|char
modifier|*
name|size
decl_stmt|;
name|struct
name|type
modifier|*
name|bt
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|typtr
operator|=
name|make_type
argument_list|(
name|C_ARRAY
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_basetype
operator|=
name|bt
expr_stmt|;
name|typtr
operator|->
name|type_size
operator|=
name|stringtocard
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|sequence_type
parameter_list|(
name|size
parameter_list|,
name|bt
parameter_list|)
name|char
modifier|*
name|size
decl_stmt|;
name|struct
name|type
modifier|*
name|bt
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|typtr
operator|=
name|make_type
argument_list|(
name|C_SEQUENCE
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_basetype
operator|=
name|bt
expr_stmt|;
name|typtr
operator|->
name|type_size
operator|=
name|stringtocard
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|procedure_type
parameter_list|(
name|args
parameter_list|,
name|results
parameter_list|,
name|errors
parameter_list|)
name|list
name|args
decl_stmt|,
name|results
decl_stmt|,
name|errors
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|typtr
operator|=
name|make_type
argument_list|(
name|C_PROCEDURE
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_args
operator|=
name|args
expr_stmt|;
name|typtr
operator|->
name|type_results
operator|=
name|results
expr_stmt|;
name|typtr
operator|->
name|type_errors
operator|=
name|errors
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a choice type.  * There are two ways a choice can be specified:  * with an explicit enumeration type as a designator,  * or with an implicit enumeration type,  * by specifying values as well as names for each designator.  * Convert the second form into the first by creating  * an enumeration type on the fly.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|choice_type
parameter_list|(
name|designator
parameter_list|,
name|candidates
parameter_list|)
name|struct
name|type
modifier|*
name|designator
decl_stmt|;
name|list
name|candidates
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|list
name|p
decl_stmt|,
name|q
decl_stmt|,
name|dlist
decl_stmt|;
name|int
name|bad
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|designator
operator|!=
name|TNIL
condition|)
block|{
if|if
condition|(
name|designator
operator|->
name|type_constr
operator|!=
name|C_ENUMERATION
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"designator type %s is not an enumeration type"
argument_list|,
name|typename
argument_list|(
name|designator
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Unspecified_type
operator|)
return|;
block|}
comment|/* 		 * Check that designators don't specify conflicting values. 		 */
for|for
control|(
name|p
operator|=
name|candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
for|for
control|(
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
if|if
condition|(
name|cdar
argument_list|(
name|q
argument_list|)
operator|!=
name|NIL
operator|&&
name|stringtocard
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cdar
argument_list|(
name|q
argument_list|)
argument_list|)
operator|!=
name|enumvalue_of
argument_list|(
name|caar
argument_list|(
name|q
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"conflicting value specified for designator %s"
argument_list|,
name|name_of
argument_list|(
name|caar
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* 		 * Check that designators do specify values. 		 */
name|dlist
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
for|for
control|(
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
if|if
condition|(
name|cdar
argument_list|(
name|q
argument_list|)
operator|==
name|NIL
condition|)
block|{
name|error
argument_list|(
name|ERROR
argument_list|,
literal|"value must be specified for designator %s"
argument_list|,
name|name_of
argument_list|(
name|caar
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|dlist
operator|=
name|nconc
argument_list|(
name|dlist
argument_list|,
name|cons
argument_list|(
name|car
argument_list|(
name|q
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bad
condition|)
block|{
name|designator
operator|=
name|enumeration_type
argument_list|(
name|dlist
argument_list|)
expr_stmt|;
name|code_type
argument_list|(
name|gensym
argument_list|(
literal|"T_d"
argument_list|)
argument_list|,
name|designator
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad
condition|)
return|return
operator|(
name|Unspecified_type
operator|)
return|;
name|typtr
operator|=
name|make_type
argument_list|(
name|C_CHOICE
argument_list|)
expr_stmt|;
name|typtr
operator|->
name|type_designator
operator|=
name|designator
expr_stmt|;
name|typtr
operator|->
name|type_candidates
operator|=
name|candidates
expr_stmt|;
return|return
operator|(
name|typtr
operator|)
return|;
block|}
end_function

end_unit

