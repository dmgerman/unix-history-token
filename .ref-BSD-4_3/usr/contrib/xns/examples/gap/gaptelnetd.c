begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: gaptelnetd.c,v 2.0 85/11/21 07:23:06 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * server for GAP-style (TransportObject=server,teletype) telnet connections  * Note that we support only GAP version 3  */
end_comment

begin_comment
comment|/* $Log:	gaptelnetd.c,v $  * Revision 2.0  85/11/21  07:23:06  jqj  * 4.3BSD standard release  *   * Revision 1.3  85/11/21  06:53:22  jqj  * symbolic values for connection type  *   * Revision 1.2  85/11/08  17:17:13  bill  * version on bullwinkle  *   * Revision 1.3  85/08/05  09:58:00  jqj  * fixed for Interlisp -- data from Interlisp appears with dt==0 (wrong!)  * also, Interlisp trys to connect to a tty rather than a ttyHost.  * increased inactivity timeout to 4 hrs  *  * Revision 1.2  85/05/23  06:22:18  jqj  * *** empty log message ***  *   * Revision 1.1  85/05/22  09:46:52  jqj  * Initial revision  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/idp.h>
end_include

begin_include
include|#
directive|include
file|<netns/sp.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<xnscourier/realcourierconnection.h>
end_include

begin_include
include|#
directive|include
file|"GAP3.h"
end_include

begin_include
include|#
directive|include
file|"gapcontrols.h"
end_include

begin_include
include|#
directive|include
file|<xnscourier/except.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|BELL
value|'\07'
end_define

begin_define
define|#
directive|define
name|BANNER
value|"\r\n\r\n4.3 BSD UNIX (%s)\r\n\r\r\n\r"
end_define

begin_decl_stmt
name|int
name|pty
decl_stmt|,
name|net
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CourierConnection
modifier|*
name|_serverConnection
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
operator|+
name|SPPMAXDATA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sphdr
name|our_sphdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iovec
name|our_iovec
index|[
literal|2
index|]
init|=
block|{
block|{
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|our_sphdr
operator|)
block|,
expr|sizeof
operator|(
name|our_sphdr
operator|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * I/O data buffers, pointers, and counters.  */
end_comment

begin_decl_stmt
name|char
name|ptyibuf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|ptyip
init|=
name|ptyibuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ptyobuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|pfrontp
init|=
name|ptyobuf
decl_stmt|,
modifier|*
name|pbackp
init|=
name|ptyobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netip
init|=
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netobuf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|nfrontp
init|=
name|netobuf
decl_stmt|,
modifier|*
name|nbackp
init|=
name|netobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pcc
decl_stmt|,
name|ncc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|envinit
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wsenv
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * session parameters  */
end_comment

begin_decl_stmt
name|Cardinal
name|frametimeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 or time in seconds to wait */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * This modified version of the server is necessary since GAP specifies  * that the telnet data-transfer session occurs after the RPC to create  * it has returned!  */
end_comment

begin_macro
name|Server
argument_list|(
argument|skipcount
argument_list|,
argument|skippedwords
argument_list|)
end_macro

begin_decl_stmt
name|int
name|skipcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Unspecified
name|skippedwords
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Cardinal
name|_procedure
decl_stmt|;
specifier|register
name|Unspecified
modifier|*
name|_buf
decl_stmt|;
name|LongCardinal
name|programnum
decl_stmt|;
name|Cardinal
name|versionnum
decl_stmt|;
name|Cardinal
name|_n
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"Server: %d %d"
argument_list|,
name|skipcount
argument_list|,
name|skippedwords
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|_buf
operator|=
name|ReceiveCallMessage
argument_list|(
operator|&
name|_procedure
argument_list|,
name|skipcount
argument_list|,
name|skippedwords
argument_list|)
expr_stmt|;
name|DURING
switch|switch
condition|(
name|_procedure
condition|)
block|{
case|case
literal|3
case|:
name|server_GAP3_Delete
argument_list|(
name|_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|server_GAP3_Create
argument_list|(
name|_buf
argument_list|)
expr_stmt|;
name|net
operator|=
name|_serverConnection
operator|->
name|fd
expr_stmt|;
name|gaptelnet
argument_list|()
expr_stmt|;
comment|/* returns on connection close */
break|break;
case|case
literal|0
case|:
name|server_GAP3_Reset
argument_list|(
name|_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NoSuchProcedureValue
argument_list|(
literal|"GAP"
argument_list|,
name|_procedure
argument_list|)
expr_stmt|;
break|break;
block|}
name|HANDLER
block|{
name|Deallocate
argument_list|(
name|_buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Exception
operator|.
name|Code
condition|)
block|{
case|case
name|GAP3_serviceNotFound
case|:
case|case
name|GAP3_userNotAuthorized
case|:
case|case
name|GAP3_userNotAuthenticated
case|:
case|case
name|GAP3_serviceTooBusy
case|:
case|case
name|GAP3_terminalAddressInvalid
case|:
case|case
name|GAP3_terminalAddressInUse
case|:
case|case
name|GAP3_controllerDoesNotExist
case|:
case|case
name|GAP3_controllerAlreadyExists
case|:
case|case
name|GAP3_gapCommunicationError
case|:
case|case
name|GAP3_gapNotExported
case|:
case|case
name|GAP3_bugInGAPCode
case|:
case|case
name|GAP3_tooManyGateStreams
case|:
case|case
name|GAP3_inconsistentParams
case|:
case|case
name|GAP3_transmissionMediumUnavailable
case|:
case|case
name|GAP3_dialingHardwareProblem
case|:
case|case
name|GAP3_noDialingHardware
case|:
case|case
name|GAP3_badAddressFormat
case|:
case|case
name|GAP3_mediumConnectFailed
case|:
case|case
name|GAP3_illegalTransport
case|:
case|case
name|GAP3_noCommunicationHardware
case|:
case|case
name|GAP3_unimplemented
case|:
name|_buf
operator|=
name|Allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SendAbortMessage
argument_list|(
name|Exception
operator|.
name|Code
operator|-
name|ERROR_OFFSET
argument_list|,
literal|0
argument_list|,
name|_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|_buf
operator|=
name|Allocate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SendRejectMessage
argument_list|(
name|unspecifiedError
argument_list|,
literal|0
argument_list|,
name|_buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|END_HANDLER
expr_stmt|;
name|Deallocate
argument_list|(
name|_buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|skipcount
operator|=
name|LookAheadCallMsg
argument_list|(
operator|&
name|programnum
argument_list|,
operator|&
name|versionnum
argument_list|,
name|skippedwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipcount
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* timed out */
if|if
condition|(
name|programnum
operator|!=
literal|3
operator|||
name|versionnum
operator|!=
literal|3
condition|)
name|ExecCourierProgram
argument_list|(
name|programnum
argument_list|,
name|versionnum
argument_list|,
name|skipcount
argument_list|,
name|skippedwords
argument_list|)
expr_stmt|;
block|}
comment|/* loop if can't exec that program */
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|void
name|GAP3_Delete
parameter_list|(
name|session
parameter_list|)
name|GAP3_SessionHandle
name|session
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|GAP3_Reset
parameter_list|()
block|{ }
end_function

begin_decl_stmt
name|GAP3_CreateResults
name|GAP3_Create
argument_list|(
name|conn
argument_list|,
name|BDTproc
argument_list|,
name|sessionparams
argument_list|,
name|transports
argument_list|,
name|createTimeout
argument_list|,
name|credentials
argument_list|,
name|verifier
argument_list|)
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BDTproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GAP3_SessionParameterObject
name|sessionparams
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|Cardinal
name|length
decl_stmt|;
name|GAP3_TransportObject
modifier|*
name|sequence
decl_stmt|;
block|}
name|transports
struct|;
end_struct

begin_decl_stmt
name|GAP3_WaitTime
name|createTimeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Authentication1_Credentials
name|credentials
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Authentication1_Verifier
name|verifier
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|GAP3_CreateResults
name|result
decl_stmt|;
name|char
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|host
decl_stmt|;
name|int
name|t
decl_stmt|,
name|pid
decl_stmt|;
name|struct
name|sgttyb
name|b
decl_stmt|;
name|char
modifier|*
name|xntoa
argument_list|()
decl_stmt|,
modifier|*
name|wsname
argument_list|()
decl_stmt|;
name|struct
name|sockaddr_ns
name|who
decl_stmt|;
name|int
name|whosize
init|=
sizeof|sizeof
argument_list|(
name|who
argument_list|)
decl_stmt|;
name|LongCardinal
name|servicetype
decl_stmt|;
name|GAP3_CommParamObject
modifier|*
name|cp
decl_stmt|;
name|GAP3_Duplexity
name|duplexity
decl_stmt|;
comment|/* fullDuplex, halfDuplex */
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"CREATE"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sessionparams
operator|.
name|designator
condition|)
block|{
case|case
name|oldTty
case|:
case|case
name|oldTtyHost
case|:
name|frametimeout
operator|=
name|sessionparams
operator|.
name|oldTtyHost_case
operator|.
name|frameTimeout
operator|/
literal|1000
expr_stmt|;
comment|/* could set other parameters here */
break|break;
case|case
name|tty
case|:
case|case
name|ttyHost
case|:
name|frametimeout
operator|=
name|sessionparams
operator|.
name|ttyHost_case
operator|.
name|frameTimeout
operator|/
literal|1000
expr_stmt|;
comment|/* could set other parameters here */
break|break;
default|default:
name|raise
argument_list|(
name|GAP3_unimplemented
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|transports
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|raise
argument_list|(
name|GAP3_illegalTransport
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
switch|switch
condition|(
name|transports
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|designator
condition|)
block|{
case|case
name|service
case|:
name|servicetype
operator|=
name|transports
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|service_case
operator|.
name|id
expr_stmt|;
switch|switch
condition|(
name|servicetype
condition|)
block|{
case|case
name|TTYService_any
case|:
comment|/* 0 */
name|servicetype
operator|=
name|TTYService_sa
expr_stmt|;
case|case
name|TTYService_sa
case|:
comment|/* 1 */
case|case
name|TTYService_exec
case|:
comment|/* 2 */
case|case
name|TTYService_its
case|:
comment|/* 3 */
break|break;
default|default:
name|raise
argument_list|(
name|GAP3_serviceNotFound
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|duplexity
operator|=
name|fullduplex
expr_stmt|;
comment|/* services are allways fulldup */
break|break;
case|case
name|rs232c
case|:
comment|/* maybe some day */
name|cp
operator|=
operator|&
name|transports
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|rs232c_case
operator|.
name|commParams
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|accessDetail
operator|.
name|designator
operator|==
name|directConn
condition|)
block|{
name|duplexity
operator|=
name|cp
operator|->
name|accessDetail
operator|.
name|directConn_case
operator|.
name|duplex
expr_stmt|;
name|servicetype
operator|=
name|TTYService_sa
expr_stmt|;
comment|/* fake it */
break|break;
block|}
name|raise
argument_list|(
name|GAP3_noCommunicationHardware
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
name|raise
argument_list|(
name|GAP3_illegalTransport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|transports
operator|.
name|sequence
index|[
literal|1
index|]
operator|.
name|designator
operator|!=
name|teletype
condition|)
name|raise
argument_list|(
name|GAP3_illegalTransport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ignore createTimeout */
comment|/* ignore credentials and verifier */
for|for
control|(
name|c1
operator|=
literal|"pq"
init|;
operator|*
name|c1
operator|!=
literal|0
condition|;
name|c1
operator|++
control|)
for|for
control|(
name|c2
operator|=
literal|"0123456789abcdef"
init|;
operator|*
name|c2
operator|!=
literal|0
condition|;
name|c2
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"/dev/pty%c%c"
argument_list|,
operator|*
name|c1
argument_list|,
operator|*
name|c2
argument_list|)
expr_stmt|;
name|pty
operator|=
name|open
argument_list|(
name|line
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pty
operator|<
literal|0
condition|)
continue|continue;
name|line
index|[
name|strlen
argument_list|(
literal|"/dev/"
argument_list|)
index|]
operator|=
literal|'t'
expr_stmt|;
name|t
operator|=
name|open
argument_list|(
name|line
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|0
condition|)
goto|goto
name|gotpty
goto|;
name|close
argument_list|(
name|pty
argument_list|)
expr_stmt|;
block|}
name|raise
argument_list|(
name|GAP3_serviceTooBusy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|gotpty
label|:
name|getpeername
argument_list|(
name|_serverConnection
operator|->
name|fd
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|whosize
argument_list|)
expr_stmt|;
name|host
operator|=
name|wsname
argument_list|(
name|who
operator|.
name|sns_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"gotpty<%s> %d<%s>"
argument_list|,
name|line
argument_list|,
name|pty
argument_list|,
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|sg_flags
operator|=
name|CRMOD
operator||
name|XTABS
operator||
name|ANYP
expr_stmt|;
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplexity
operator|==
name|fullduplex
condition|)
name|b
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
else|else
name|b
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* we do the fork now so we can return failures as REPORTS */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pty
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|GAP3_serviceTooBusy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* in the execed fork */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* let parent get ready for us */
name|close
argument_list|(
name|_serverConnection
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* close net */
name|close
argument_list|(
name|pty
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|2
condition|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|envinit
index|[
literal|0
index|]
operator|=
literal|"TERM=network"
expr_stmt|;
name|envinit
index|[
literal|1
index|]
operator|=
name|sprintf
argument_list|(
name|wsenv
argument_list|,
literal|"WORKSTATION=%s"
argument_list|,
name|xntoa
argument_list|(
name|who
operator|.
name|sns_addr
argument_list|)
argument_list|)
expr_stmt|;
name|envinit
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"about to exec /bin/login"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|execl
argument_list|(
literal|"/bin/login"
argument_list|,
literal|"login"
argument_list|,
literal|"-h"
argument_list|,
name|host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"exec of /bin/login failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|perror
argument_list|(
literal|"/bin/login"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"fork successful"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|session
index|[
literal|0
index|]
operator|=
name|pid
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|jmp_buf
name|childdiedbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main loop.  Select from pty and network, and  * hand data to telnet receiver finite state machine.  * Returns 0 on orderly shutdown, 1 on abnormal shutdown.  */
end_comment

begin_macro
name|gaptelnet
argument_list|()
end_macro

begin_block
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
name|char
name|hostname
index|[
literal|32
index|]
decl_stmt|;
name|int
name|childdied
parameter_list|()
function_decl|;
name|int
name|ibits
init|=
literal|0
decl_stmt|,
name|obits
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|sphdr
modifier|*
name|si
init|=
operator|(
expr|struct
name|sphdr
operator|*
operator|)
name|buf
decl_stmt|;
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
literal|600
block|,
literal|0
block|}
decl_stmt|;
name|int
name|keepalives
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"gaptelnet net=%d,pty=%d"
argument_list|,
name|net
argument_list|,
name|pty
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|setjmp
argument_list|(
name|childdiedbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* child died */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|childdied
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|net
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pty
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
comment|/* 	 * Show banner that getty never gave. 	 */
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|nfrontp
argument_list|,
name|BANNER
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
name|strlen
argument_list|(
name|nfrontp
argument_list|)
expr_stmt|;
comment|/* 	 * Send status message indicating we're ready to go 	 */
name|changeSPPopts
argument_list|(
name|net
argument_list|,
name|GAPCTLnone
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sendoobdata
argument_list|(
name|GAPCTLmediumUp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"looping in gaptelnet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ibits
operator|=
name|obits
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Never look for input if there's still 		 * stuff in the corresponding output buffer 		 */
if|if
condition|(
name|nfrontp
operator|-
name|nbackp
operator|||
name|pcc
operator|>
literal|0
condition|)
name|obits
operator||=
operator|(
literal|1
operator|<<
name|net
operator|)
expr_stmt|;
else|else
name|ibits
operator||=
operator|(
literal|1
operator|<<
name|pty
operator|)
expr_stmt|;
if|if
condition|(
name|pfrontp
operator|-
name|pbackp
operator|||
name|ncc
operator|>
literal|0
condition|)
name|obits
operator||=
operator|(
literal|1
operator|<<
name|pty
operator|)
expr_stmt|;
else|else
name|ibits
operator||=
operator|(
literal|1
operator|<<
name|net
operator|)
expr_stmt|;
if|if
condition|(
name|ncc
operator|<
literal|0
operator|&&
name|pcc
operator|<
literal|0
condition|)
break|break;
name|timeout
operator|.
name|tv_sec
operator|=
literal|14400
expr_stmt|;
comment|/* 4 hrs. */
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|select
argument_list|(
literal|16
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibits
operator|==
literal|0
operator|&&
name|obits
operator|==
literal|0
condition|)
block|{
comment|/* timeout means no activity for a long time */
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"timeout from select"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|keepalives
operator|++
operator|<
literal|2
condition|)
block|{
comment|/* first time through send warning */
if|if
condition|(
name|nfrontp
operator|==
name|nbackp
operator|&&
name|pcc
operator|==
literal|0
condition|)
block|{
comment|/* but only if not blocked on output */
define|#
directive|define
name|WARNING
value|"\r\nYou've been idle much too long.  Respond or log off.\r\n"
name|strcpy
argument_list|(
name|nfrontp
argument_list|,
name|WARNING
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
sizeof|sizeof
argument_list|(
name|WARNING
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"keepalive expired -- calling cleanup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* keepalive count has expired */
name|cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Something to read from the network... 		 */
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|net
operator|)
condition|)
block|{
name|ncc
operator|=
name|read
argument_list|(
name|net
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"read %d from net, cc=0%o,dt=0%o"
argument_list|,
name|ncc
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
argument_list|,
name|si
operator|->
name|sp_cc
argument_list|,
name|si
operator|->
name|sp_dt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ncc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|ncc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ncc
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"short read, %d.  calling cleanup"
argument_list|,
name|ncc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
comment|/* will probably fail or block */
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|si
operator|->
name|sp_cc
operator|&
name|SP_OB
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"Got OOB control 0%o"
argument_list|,
operator|(
name|u_char
operator|)
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* a status or OOB control */
switch|switch
condition|(
operator|(
name|u_char
operator|)
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
index|]
condition|)
block|{
case|case
name|GAPCTLinterrupt
case|:
comment|/* shove interrupt char in buffer */
name|interrupt
argument_list|()
expr_stmt|;
break|break;
comment|/* from switch */
case|case
name|GAPCTLareYouThere
case|:
name|sendoobdata
argument_list|(
name|GAPCTLiAmHere
argument_list|)
expr_stmt|;
break|break;
comment|/* from switch */
default|default:
comment|/* Ignore other controls instead of: 					 * sendoobdata( 					 *     GAPCTLunexpectedRemoteBehavior); 					 */
break|break;
comment|/* from switch */
block|}
name|ncc
operator|=
literal|0
expr_stmt|;
comment|/* no chars here */
block|}
elseif|else
if|if
condition|(
name|si
operator|->
name|sp_dt
operator|==
name|GAPCTLnone
operator|||
name|si
operator|->
name|sp_dt
operator|==
literal|0
condition|)
block|{
comment|/* the normal case */
comment|/* N.B. the standard says dt should be 0300 				 * i.e. GAPCTLnone, but Interlisp CHAT 				 * generates 0, so we accept that too. 				 */
name|ncc
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"Now ncc == %d"
argument_list|,
name|ncc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|netip
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
name|keepalives
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|si
operator|->
name|sp_dt
operator|==
name|GAPCTLcleanup
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"got CLEANUP packet.  Done"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
comment|/* normal termination */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|si
operator|->
name|sp_dt
operator|==
name|SPPSST_END
condition|)
block|{
comment|/* got premature termination */
name|quitquit
argument_list|(
name|net
argument_list|,
name|pty
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* some other inband ctl */
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"ignoring IB packet, data = 0%o..."
argument_list|,
operator|(
name|u_char
operator|)
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 		 * Something to read from the pty... 		 */
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|pty
operator|)
condition|)
block|{
if|if
condition|(
name|frametimeout
operator|>
literal|0
condition|)
name|sleep
argument_list|(
name|frametimeout
argument_list|)
expr_stmt|;
name|pcc
operator|=
name|read
argument_list|(
name|pty
argument_list|,
name|ptyibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ptyibuf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"read from pty %d"
argument_list|,
name|pcc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pcc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|pcc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pcc
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"short read from pty. Calling cleanup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* ?? abnormal termination */
block|}
name|ptyip
operator|=
name|ptyibuf
expr_stmt|;
block|}
while|while
condition|(
name|pcc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|&
name|netobuf
index|[
sizeof|sizeof
argument_list|(
name|netobuf
argument_list|)
index|]
operator|-
name|nfrontp
operator|)
operator|<
literal|2
condition|)
break|break;
operator|*
name|nfrontp
operator|++
operator|=
operator|*
name|ptyip
operator|++
operator|&
literal|0377
expr_stmt|;
name|pcc
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|obits
operator|&
operator|(
literal|1
operator|<<
name|net
operator|)
operator|)
operator|&&
operator|(
name|nfrontp
operator|-
name|nbackp
operator|)
operator|>
literal|0
condition|)
name|netflush
argument_list|()
expr_stmt|;
while|while
condition|(
name|ncc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|&
name|ptyobuf
index|[
sizeof|sizeof
argument_list|(
name|ptyobuf
argument_list|)
index|]
operator|-
name|pfrontp
operator|)
operator|<
literal|2
condition|)
break|break;
operator|*
name|pfrontp
operator|++
operator|=
operator|*
name|netip
operator|++
operator|&
literal|0377
expr_stmt|;
name|ncc
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|obits
operator|&
operator|(
literal|1
operator|<<
name|pty
operator|)
operator|)
operator|&&
operator|(
name|pfrontp
operator|-
name|pbackp
operator|)
operator|>
literal|0
condition|)
name|ptyflush
argument_list|()
expr_stmt|;
block|}
comment|/* we should never get to here */
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"broke out of for(;;) somehow.  calling cleanup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Send out of band data to other end of network  */
end_comment

begin_macro
name|sendoobdata
argument_list|(
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|u_char
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
struct|struct
block|{
name|struct
name|sphdr
name|hdr
decl_stmt|;
name|char
name|val
decl_stmt|;
block|}
name|oob
struct|;
name|oob
operator|.
name|hdr
operator|=
name|our_sphdr
expr_stmt|;
name|oob
operator|.
name|val
operator|=
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"sendoobdata 0%o"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|send
argument_list|(
name|net
argument_list|,
operator|&
name|oob
argument_list|,
sizeof|sizeof
argument_list|(
name|oob
argument_list|)
argument_list|,
name|MSG_OOB
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Send interrupt to process on other side of pty.  * If it is in raw mode, just write NULL;  * otherwise, write intr char.  */
end_comment

begin_macro
name|interrupt
argument_list|()
end_macro

begin_block
block|{
name|struct
name|sgttyb
name|b
decl_stmt|;
name|struct
name|tchars
name|tchars
decl_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|sg_flags
operator|&
name|RAW
condition|)
block|{
operator|*
name|pfrontp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
operator|*
name|pfrontp
operator|++
operator|=
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tchars
argument_list|)
operator|<
literal|0
condition|?
literal|'\177'
else|:
name|tchars
operator|.
name|t_intrc
expr_stmt|;
block|}
end_block

begin_macro
name|ptyflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|pfrontp
operator|-
name|pbackp
operator|)
operator|>
literal|0
condition|)
name|n
operator|=
name|write
argument_list|(
name|pty
argument_list|,
name|pbackp
argument_list|,
name|n
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"ptyflush wrote %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return;
name|pbackp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|pbackp
operator|>=
name|pfrontp
condition|)
comment|/* actually,> is an error */
name|pbackp
operator|=
name|pfrontp
operator|=
name|ptyobuf
expr_stmt|;
block|}
end_block

begin_macro
name|netflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|nfrontp
operator|-
name|nbackp
operator|)
operator|>
literal|0
condition|)
block|{
name|our_iovec
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
operator|(
operator|(
name|n
operator|>
name|SPPMAXDATA
operator|)
condition|?
name|SPPMAXDATA
else|:
name|n
operator|)
expr_stmt|;
name|our_iovec
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|nbackp
expr_stmt|;
name|n
operator|=
name|writev
argument_list|(
name|net
argument_list|,
name|our_iovec
argument_list|,
literal|2
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"netflush wrote %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|our_iovec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|!=
operator|(
name|char
operator|*
operator|)
operator|&
name|our_sphdr
condition|)
name|BUGOUT
argument_list|(
literal|"Oops:  our_iovec clobbered"
argument_list|)
expr_stmt|;
name|BUGOUT
argument_list|(
literal|"header: %d %d, %d %d %d %d %d %d"
argument_list|,
name|our_sphdr
operator|.
name|sp_cc
argument_list|,
name|our_sphdr
operator|.
name|sp_dt
argument_list|,
name|our_sphdr
operator|.
name|sp_sid
argument_list|,
name|our_sphdr
operator|.
name|sp_did
argument_list|,
name|our_sphdr
operator|.
name|sp_seq
argument_list|,
name|our_sphdr
operator|.
name|sp_ack
argument_list|,
name|our_sphdr
operator|.
name|sp_alo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
return|return;
comment|/* should blow this guy away... */
return|return;
block|}
name|nbackp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|nbackp
operator|>=
name|nfrontp
condition|)
comment|/* actually ,> is an error */
name|nbackp
operator|=
name|nfrontp
operator|=
name|netobuf
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * handle receipt of an SPPSST_END packet  * This is currently an error, since client didn't send "cleanup" first  */
end_comment

begin_macro
name|quitquit
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"quitquit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|changeSPPopts
argument_list|(
name|net
argument_list|,
name|SPPSST_ENDREPLY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|net
argument_list|,
operator|&
name|our_sphdr
argument_list|,
sizeof|sizeof
argument_list|(
name|our_sphdr
argument_list|)
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|rmut
argument_list|()
expr_stmt|;
name|vhangup
argument_list|()
expr_stmt|;
comment|/* XXX */
name|shutdown
argument_list|(
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|net
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * shut down the data connection for one reason or another  */
end_comment

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
name|int
name|fdmask
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|sphdr
modifier|*
name|si
init|=
operator|(
expr|struct
name|sphdr
operator|*
operator|)
name|buf
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sendoobdata
argument_list|(
name|GAPCTLcleanup
argument_list|)
expr_stmt|;
name|changeSPPopts
argument_list|(
name|net
argument_list|,
name|SPPSST_END
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|net
argument_list|,
operator|&
name|our_sphdr
argument_list|,
sizeof|sizeof
argument_list|(
name|our_sphdr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fdmask
operator|=
literal|1
operator|<<
name|net
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|select
argument_list|(
name|net
operator|+
literal|1
argument_list|,
operator|&
name|fdmask
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
operator|&&
name|read
argument_list|(
name|net
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"cleanup -- got packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|!
operator|(
name|si
operator|->
name|sp_cc
operator|&
name|SP_OB
operator|)
operator|)
operator|&&
name|si
operator|->
name|sp_dt
operator|==
name|SPPSST_ENDREPLY
condition|)
block|{
name|changeSPPopts
argument_list|(
name|net
argument_list|,
name|SPPSST_ENDREPLY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|net
argument_list|,
operator|&
name|our_sphdr
argument_list|,
sizeof|sizeof
argument_list|(
name|our_sphdr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"cleanup -- wrote ENDREPLY"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|changeSPPopts
argument_list|(
name|net
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|net
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|rmut
argument_list|()
expr_stmt|;
name|vhangup
argument_list|()
expr_stmt|;
comment|/* XXX */
return|return;
block|}
comment|/* loop: ignore everything except ENDREPLY */
name|fdmask
operator|=
literal|1
operator|<<
name|net
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|10
expr_stmt|;
block|}
comment|/* timed out or read failed */
name|changeSPPopts
argument_list|(
name|net
argument_list|,
name|SPPSST_ENDREPLY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|net
argument_list|,
operator|&
name|our_sphdr
argument_list|,
sizeof|sizeof
argument_list|(
name|our_sphdr
argument_list|)
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|shutdown
argument_list|(
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|net
argument_list|)
expr_stmt|;
name|rmut
argument_list|()
expr_stmt|;
name|vhangup
argument_list|()
expr_stmt|;
comment|/* XXX */
block|}
end_block

begin_comment
comment|/*  * SIGCHLD interrupt handler  */
end_comment

begin_macro
name|childdied
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|BUGOUT
argument_list|(
literal|"child died"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|childdiedbuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|changeSPPopts
argument_list|(
argument|s
argument_list|,
argument|stream
argument_list|,
argument|eom
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SPP socket */
end_comment

begin_decl_stmt
name|u_char
name|stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* datastream type */
end_comment

begin_decl_stmt
name|char
name|eom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Boolean EOM */
end_comment

begin_block
block|{
name|our_sphdr
operator|.
name|sp_dt
operator|=
name|stream
expr_stmt|;
name|our_sphdr
operator|.
name|sp_cc
operator|=
operator|(
name|eom
condition|?
name|SP_EM
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|wtmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
literal|"/usr/adm/wtmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|utmp
index|[]
init|=
literal|"/etc/utmp"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SCPYN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncpy(a, b, sizeof (a))
end_define

begin_define
define|#
directive|define
name|SCMPN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncmp(a, b, sizeof (a))
end_define

begin_macro
name|rmut
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|f
expr_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|utmp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCMPN
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|line
operator|+
literal|5
argument_list|)
operator|||
name|wtmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|lseek
argument_list|(
name|f
argument_list|,
operator|-
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|wtmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|f
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|line
operator|+
literal|5
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|wtmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
literal|"/dev/"
argument_list|)
index|]
operator|=
literal|'p'
expr_stmt|;
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Convert network-format xns address  * to ascii  * --Replace this with a clearinghouse name lookup someday.  */
end_comment

begin_function
name|char
modifier|*
name|wsname
parameter_list|(
name|addr
parameter_list|)
name|struct
name|ns_addr
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|b
index|[
literal|50
index|]
decl_stmt|;
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* net */
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"%D."
argument_list|,
name|ntohl
argument_list|(
name|ns_netof
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip leading zeros */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|addr
operator|.
name|x_host
operator|.
name|c_host
index|[
name|i
index|]
operator|==
operator|(
name|char
operator|)
literal|0
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* print the rest */
for|for
control|(
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%x"
argument_list|,
name|addr
operator|.
name|x_host
operator|.
name|c_host
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|b
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * generate an xns address that "DE" can parse.   * This goes in the environment.  Should be the same as above   */
end_comment

begin_function
name|char
modifier|*
name|xntoa
parameter_list|(
name|addr
parameter_list|)
name|struct
name|ns_addr
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|b
index|[
literal|50
index|]
decl_stmt|;
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* net */
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"%X#"
argument_list|,
name|ntohl
argument_list|(
name|ns_netof
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* print the rest */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%x"
argument_list|,
name|addr
operator|.
name|x_host
operator|.
name|c_host
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|b
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|BUGOUT
argument_list|(
argument|str
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
literal|"/tmp/GAP3d.log"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
name|str
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

