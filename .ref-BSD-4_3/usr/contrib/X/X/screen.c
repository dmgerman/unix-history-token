begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_comment
comment|/*	Routines dealing with output:  *  *	Do_PixFill, Do_TileFill, Do_PixmapPut,  *	Do_PixmapBitsPut, Do_BitmapBitsPut,  *	Do_CopyArea,  *	Do_Text, Do_TextMask,  *	Do_Line, Do_Draw, Do_DrawFilled,  *	Do_PixmapSave, Do_PixmapGet,  *	Do_background, Do_refill, Do_border  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_screen_c
init|=
literal|"$Header: screen.c,v 10.6 86/02/01 15:17:20 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"Xint.h"
end_include

begin_decl_stmt
specifier|extern
name|DEVICE
name|device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|Xstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|WINDOW
modifier|*
name|rootwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|RECTANGLE
modifier|*
name|free_rectangles
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DUALTCP
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|swapped
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DUALTCP
end_endif

begin_decl_stmt
name|RECTANGLE
modifier|*
name|Rec_intersection
argument_list|()
decl_stmt|,
modifier|*
name|Alloc_rectangle
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|AllocateSpace
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PIXMAP
modifier|*
name|PixmapSave
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Do a PixFill in a window */
end_comment

begin_expr_stmt
name|Do_PixFill
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|mask
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|src
value|(int) req->param.u[4]
define|#
directive|define
name|dst
value|((REGION *) req->param.s)
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|dst
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|dst
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|width
operator|+=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|+=
name|dst
operator|->
name|top
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
name|dst
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|dst
operator|->
name|width
operator|-=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|-=
name|dst
operator|->
name|top
expr_stmt|;
block|}
name|PixFill
argument_list|(
name|src
argument_list|,
name|mask
argument_list|,
name|dst
operator|->
name|left
argument_list|,
name|dst
operator|->
name|top
argument_list|,
name|dst
operator|->
name|width
argument_list|,
name|dst
operator|->
name|height
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|src
undef|#
directive|undef
name|dst
block|}
end_block

begin_comment
comment|/* Do a TileFill in a window */
end_comment

begin_expr_stmt
name|Do_TileFill
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|tile
argument_list|,
name|mask
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PIXMAP
modifier|*
name|tile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|dst
value|((REGION *) req->param.s)
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
elseif|else
if|if FALSE
condition|(
name|tile
operator|->
name|tile
condition|)
block|{
name|Xstatus
operator|=
name|BadTile
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&&
operator|(
name|mask
operator|->
name|height
operator|!=
name|dst
operator|->
name|height
operator|||
name|mask
operator|->
name|width
operator|!=
name|dst
operator|->
name|width
operator|)
condition|)
block|{
name|Xstatus
operator|=
name|BadMatch
expr_stmt|;
return|return;
block|}
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|dst
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|dst
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|width
operator|+=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|+=
name|dst
operator|->
name|top
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
name|dst
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|dst
operator|->
name|width
operator|-=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|-=
name|dst
operator|->
name|top
expr_stmt|;
block|}
while|while TRUE
condition|(
name|w
operator|->
name|tilemode
condition|)
name|w
operator|=
name|w
operator|->
name|parent
expr_stmt|;
name|TileFill
argument_list|(
name|tile
argument_list|,
name|w
operator|->
name|full
operator|.
name|left
argument_list|,
name|w
operator|->
name|full
operator|.
name|top
argument_list|,
name|mask
argument_list|,
name|dst
operator|->
name|left
argument_list|,
name|dst
operator|->
name|top
argument_list|,
name|dst
operator|->
name|width
argument_list|,
name|dst
operator|->
name|height
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dst
block|}
end_block

begin_comment
comment|/* Do a PixmapPut in a window */
end_comment

begin_expr_stmt
name|Do_PixmapPut
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|pix
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PIXMAP
modifier|*
name|pix
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|src
value|((REGION *) req->param.s)
define|#
directive|define
name|dst
value|((RASTER *)&req->param.s[4])
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|dst
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|dst
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|right
operator|=
name|dst
operator|->
name|left
operator|+
name|src
operator|->
name|width
expr_stmt|;
name|dst
operator|->
name|bottom
operator|=
name|dst
operator|->
name|top
operator|+
name|src
operator|->
name|height
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
name|dst
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|PixmapPut
argument_list|(
name|pix
argument_list|,
name|src
operator|->
name|left
argument_list|,
name|src
operator|->
name|top
argument_list|,
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|,
name|dst
operator|->
name|left
argument_list|,
name|dst
operator|->
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|src
undef|#
directive|undef
name|dst
block|}
end_block

begin_comment
comment|/* Do a PixmapBitsPut in a window */
end_comment

begin_expr_stmt
name|Do_PixmapBitsPut
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|dst
value|((REGION *) req->param.s)
define|#
directive|define
name|format
value|req->param.s[4]
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&&
operator|(
name|mask
operator|->
name|height
operator|!=
name|dst
operator|->
name|height
operator|||
name|mask
operator|->
name|width
operator|!=
name|dst
operator|->
name|width
operator|)
condition|)
block|{
name|Xstatus
operator|=
name|BadMatch
expr_stmt|;
return|return;
block|}
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|dst
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|dst
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|width
operator|+=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|+=
name|dst
operator|->
name|top
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
name|dst
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|dst
operator|->
name|width
operator|-=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|-=
name|dst
operator|->
name|top
expr_stmt|;
block|}
name|PixmapBitsPut
argument_list|(
name|dst
operator|->
name|width
argument_list|,
name|dst
operator|->
name|height
argument_list|,
name|format
argument_list|,
name|data
argument_list|,
name|mask
argument_list|,
name|dst
operator|->
name|left
argument_list|,
name|dst
operator|->
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dst
undef|#
directive|undef
name|format
block|}
end_block

begin_comment
comment|/* Do a BitmapBitsPut in a window */
end_comment

begin_expr_stmt
name|Do_BitmapBitsPut
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|data
argument_list|,
name|mask
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|dst
value|((REGION *) req->param.s)
define|#
directive|define
name|fore
value|(int) req->param.u[4]
define|#
directive|define
name|back
value|(int) req->param.u[5]
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mask
operator|&&
operator|(
name|mask
operator|->
name|height
operator|!=
name|dst
operator|->
name|height
operator|||
name|mask
operator|->
name|width
operator|!=
name|dst
operator|->
name|width
operator|)
condition|)
block|{
name|Xstatus
operator|=
name|BadMatch
expr_stmt|;
return|return;
block|}
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|dst
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|dst
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|width
operator|+=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|+=
name|dst
operator|->
name|top
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
name|dst
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|dst
operator|->
name|width
operator|-=
name|dst
operator|->
name|left
expr_stmt|;
name|dst
operator|->
name|height
operator|-=
name|dst
operator|->
name|top
expr_stmt|;
block|}
name|BitmapBitsPut
argument_list|(
name|dst
operator|->
name|width
argument_list|,
name|dst
operator|->
name|height
argument_list|,
name|data
argument_list|,
name|fore
argument_list|,
name|back
argument_list|,
name|mask
argument_list|,
name|dst
operator|->
name|left
argument_list|,
name|dst
operator|->
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dst
undef|#
directive|undef
name|fore
undef|#
directive|undef
name|back
block|}
end_block

begin_comment
comment|/* Does a CopyArea in a window */
end_comment

begin_expr_stmt
name|Do_CopyArea
argument_list|(
name|w
argument_list|,
name|req
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|src
value|((REGION *) req->param.s)
define|#
directive|define
name|srs
value|((RASTER *) req->param.s)
define|#
directive|define
name|dstx
value|req->param.s[6]
define|#
directive|define
name|dsty
value|req->param.s[7]
specifier|register
name|RECTANGLE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
name|RECTANGLE
name|rec
decl_stmt|,
modifier|*
name|vlist
decl_stmt|,
modifier|*
name|vis
decl_stmt|,
modifier|*
name|new
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|RASTER
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|,
modifier|*
name|clipptr
decl_stmt|;
name|PIXMAP
modifier|*
name|tile
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
block|{
name|Stash_misses
argument_list|(
name|w
argument_list|,
operator|(
name|RECTANGLE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|dstx
operator|-=
name|src
operator|->
name|left
expr_stmt|;
name|dsty
operator|-=
name|src
operator|->
name|top
expr_stmt|;
name|src
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|src
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
comment|/* no hairy stuff */
name|CopyArea
argument_list|(
name|src
operator|->
name|left
argument_list|,
name|src
operator|->
name|top
argument_list|,
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|,
name|src
operator|->
name|left
operator|+
name|dstx
argument_list|,
name|src
operator|->
name|top
operator|+
name|dsty
argument_list|,
operator|&
name|w
operator|->
name|clip
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
name|srs
operator|->
name|right
operator|+=
name|srs
operator|->
name|left
expr_stmt|;
name|srs
operator|->
name|bottom
operator|+=
name|srs
operator|->
name|top
expr_stmt|;
comment|/* unless part of the source is invisible */
if|if
condition|(
name|srs
operator|->
name|left
operator|>=
name|w
operator|->
name|vs
operator|.
name|left
operator|&&
name|srs
operator|->
name|top
operator|>=
name|w
operator|->
name|vs
operator|.
name|top
operator|&&
name|srs
operator|->
name|right
operator|<=
name|w
operator|->
name|vs
operator|.
name|right
operator|&&
name|srs
operator|->
name|bottom
operator|<=
name|w
operator|->
name|vs
operator|.
name|bottom
condition|)
block|{
name|Stash_misses
argument_list|(
name|w
argument_list|,
operator|(
name|RECTANGLE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|vlist
operator|=
name|ow
operator|->
name|visible
expr_stmt|;
comment|/* get destination */
name|rec
operator|.
name|left
operator|=
name|srs
operator|->
name|left
operator|+
name|dstx
expr_stmt|;
name|rec
operator|.
name|top
operator|=
name|srs
operator|->
name|top
operator|+
name|dsty
expr_stmt|;
name|rec
operator|.
name|right
operator|=
name|srs
operator|->
name|right
operator|+
name|dstx
expr_stmt|;
name|rec
operator|.
name|bottom
operator|=
name|srs
operator|->
name|bottom
operator|+
name|dsty
expr_stmt|;
comment|/* get visible source */
name|Clip_raster
argument_list|(
name|srs
argument_list|,
operator|&
name|w
operator|->
name|vs
argument_list|)
expr_stmt|;
name|srs
operator|->
name|left
operator|+=
name|dstx
expr_stmt|;
name|srs
operator|->
name|top
operator|+=
name|dsty
expr_stmt|;
name|srs
operator|->
name|right
operator|+=
name|dstx
expr_stmt|;
name|srs
operator|->
name|bottom
operator|+=
name|dsty
expr_stmt|;
comment|/* get updated destination */
name|Clip_raster
argument_list|(
name|srs
argument_list|,
operator|&
name|w
operator|->
name|vs
argument_list|)
expr_stmt|;
name|RASTRECT
argument_list|(
name|v1
argument_list|,
operator|*
name|srs
argument_list|,
name|contents_rec
argument_list|)
expr_stmt|;
name|rec
operator|.
name|next
operator|=
name|v1
expr_stmt|;
name|rec
operator|.
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if TRUE
condition|(
name|w
operator|->
name|clipmode
condition|)
name|vlist
operator|=
name|ow
operator|->
name|cmvisible
expr_stmt|;
else|else
name|vlist
operator|=
name|ow
operator|->
name|visible
expr_stmt|;
comment|/* get source */
operator|*
operator|(
name|REGION
operator|*
operator|)
operator|&
name|rec
operator|=
operator|*
name|src
expr_stmt|;
name|rec
operator|.
name|right
operator|+=
name|src
operator|->
name|left
expr_stmt|;
name|rec
operator|.
name|bottom
operator|+=
name|src
operator|->
name|top
expr_stmt|;
name|rec
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v1
operator|=
name|vlist
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
block|{
comment|/* get visible source */
if|if
condition|(
name|v1
operator|->
name|type
operator|!=
name|contents_rec
operator|||
operator|(
name|vis
operator|=
name|Rec_intersection
argument_list|(
name|v1
argument_list|,
operator|&
name|rec
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|w
operator|!=
name|ow
operator|&&
name|TRUE
argument_list|(
name|Clip_rectangle
argument_list|(
name|vis
argument_list|,
operator|&
name|w
operator|->
name|vs
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* get destination */
name|vis
operator|->
name|left
operator|+=
name|dstx
expr_stmt|;
name|vis
operator|->
name|top
operator|+=
name|dsty
expr_stmt|;
name|vis
operator|->
name|right
operator|+=
name|dstx
expr_stmt|;
name|vis
operator|->
name|bottom
operator|+=
name|dsty
expr_stmt|;
for|for
control|(
name|v2
operator|=
name|vlist
init|;
name|v2
condition|;
name|v2
operator|=
name|v2
operator|->
name|next
control|)
block|{
comment|/* get visible destination */
if|if
condition|(
name|v2
operator|->
name|type
operator|!=
name|contents_rec
operator|||
operator|(
name|new
operator|=
name|Rec_intersection
argument_list|(
name|v2
argument_list|,
name|vis
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|w
operator|!=
name|ow
operator|&&
name|TRUE
argument_list|(
name|Clip_rectangle
argument_list|(
name|new
argument_list|,
operator|&
name|w
operator|->
name|vs
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* try to merge it in */
for|for
control|(
name|end
operator|=
name|rec
operator|.
name|next
init|;
name|end
condition|;
name|end
operator|=
name|end
operator|->
name|next
control|)
block|{
if|if
condition|(
name|end
operator|->
name|left
operator|!=
name|new
operator|->
name|left
operator|||
name|end
operator|->
name|right
operator|!=
name|new
operator|->
name|right
condition|)
continue|continue;
if|if
condition|(
name|end
operator|->
name|top
operator|==
name|new
operator|->
name|bottom
condition|)
block|{
name|end
operator|->
name|top
operator|=
name|new
operator|->
name|top
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
operator|->
name|bottom
operator|==
name|new
operator|->
name|top
condition|)
block|{
name|end
operator|->
name|bottom
operator|=
name|new
operator|->
name|bottom
expr_stmt|;
block|}
else|else
continue|continue;
name|FREERECT
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
continue|continue;
name|new
operator|->
name|next
operator|=
name|rec
operator|.
name|next
expr_stmt|;
name|rec
operator|.
name|next
operator|=
name|new
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|FREERECT
argument_list|(
name|vis
argument_list|)
expr_stmt|;
block|}
comment|/* reorder by direction of motion */
for|for
control|(
name|v1
operator|=
name|rec
operator|.
name|next
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
block|{
for|for
control|(
name|v2
operator|=
name|v1
operator|->
name|next
init|;
name|v2
condition|;
name|v2
operator|=
name|v2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|dsty
operator|<=
literal|0
operator|&&
name|v1
operator|->
name|top
operator|==
name|v2
operator|->
name|top
operator|)
operator|||
operator|(
name|dsty
operator|>
literal|0
operator|&&
name|v1
operator|->
name|bottom
operator|==
name|v2
operator|->
name|bottom
operator|)
operator|)
operator|&&
operator|(
operator|(
name|dstx
operator|<
literal|0
operator|&&
name|v1
operator|->
name|left
operator|>
name|v2
operator|->
name|left
operator|)
operator|||
operator|(
name|dstx
operator|>
literal|0
operator|&&
name|v1
operator|->
name|right
operator|<
name|v2
operator|->
name|right
operator|)
operator|)
operator|)
operator|||
operator|(
name|dsty
operator|<
literal|0
operator|&&
name|v1
operator|->
name|top
operator|>
name|v2
operator|->
name|top
operator|)
operator|||
operator|(
name|dsty
operator|>
literal|0
operator|&&
name|v1
operator|->
name|bottom
operator|<
name|v2
operator|->
name|bottom
operator|)
condition|)
block|{
name|temp
operator|=
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v1
expr_stmt|;
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v1
operator|=
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v2
expr_stmt|;
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v2
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
condition|)
block|{
name|clipptr
operator|=
operator|(
name|CLIP
operator|*
operator|)
name|AllocateSpace
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|CLIP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliplist
operator|=
name|clipptr
condition|)
block|{
for|for
control|(
name|v1
operator|=
name|rec
operator|.
name|next
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
block|{
name|clipptr
operator|->
name|left
operator|=
name|v1
operator|->
name|left
expr_stmt|;
name|clipptr
operator|->
name|top
operator|=
name|v1
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|height
operator|=
name|v1
operator|->
name|bottom
operator|-
name|v1
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|width
operator|=
name|v1
operator|->
name|right
operator|-
name|v1
operator|->
name|left
expr_stmt|;
name|clipptr
operator|++
expr_stmt|;
block|}
name|CopyArea
argument_list|(
name|src
operator|->
name|left
argument_list|,
name|src
operator|->
name|top
argument_list|,
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|,
name|src
operator|->
name|left
operator|+
name|dstx
argument_list|,
name|src
operator|->
name|top
operator|+
name|dsty
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|DeviceError
argument_list|(
literal|"Cliplist too large"
argument_list|)
expr_stmt|;
block|}
comment|/* get destination */
name|rec
operator|.
name|left
operator|+=
name|dstx
expr_stmt|;
name|rec
operator|.
name|top
operator|+=
name|dsty
expr_stmt|;
name|rec
operator|.
name|right
operator|+=
name|dstx
expr_stmt|;
name|rec
operator|.
name|bottom
operator|+=
name|dsty
expr_stmt|;
block|}
name|vis
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|v1
operator|=
name|vlist
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
block|{
comment|/* get updated destination */
if|if
condition|(
name|v1
operator|->
name|type
operator|!=
name|contents_rec
operator|||
operator|(
name|v2
operator|=
name|Rec_intersection
argument_list|(
name|v1
argument_list|,
operator|&
name|rec
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|w
operator|!=
name|ow
operator|&&
name|TRUE
argument_list|(
name|Clip_rectangle
argument_list|(
name|v2
argument_list|,
operator|&
name|w
operator|->
name|vs
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
name|v2
operator|->
name|next
operator|=
name|vis
expr_stmt|;
name|vis
operator|=
name|v2
expr_stmt|;
block|}
comment|/* get missed but visible destination */
for|for
control|(
name|v1
operator|=
name|rec
operator|.
name|next
init|;
name|v1
condition|;
name|v1
operator|=
name|v2
control|)
block|{
name|Calc_overlaps
argument_list|(
operator|(
name|RASTER
operator|*
operator|)
name|v1
argument_list|,
operator|&
name|vis
argument_list|)
expr_stmt|;
name|v2
operator|=
name|v1
operator|->
name|next
expr_stmt|;
name|FREERECT
argument_list|(
name|v1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v1
operator|=
name|vis
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|clipptr
operator|=
operator|(
name|CLIP
operator|*
operator|)
name|AllocateSpace
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|CLIP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliplist
operator|=
name|clipptr
condition|)
block|{
for|for
control|(
name|v1
operator|=
name|vis
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
block|{
name|clipptr
operator|->
name|left
operator|=
name|v1
operator|->
name|left
expr_stmt|;
name|clipptr
operator|->
name|top
operator|=
name|v1
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|height
operator|=
name|v1
operator|->
name|bottom
operator|-
name|v1
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|width
operator|=
name|v1
operator|->
name|right
operator|-
name|v1
operator|->
name|left
expr_stmt|;
name|clipptr
operator|++
expr_stmt|;
block|}
block|}
name|tile
operator|=
name|ow
operator|->
name|tile
expr_stmt|;
name|ow
operator|=
name|w
expr_stmt|;
while|while TRUE
condition|(
name|ow
operator|->
name|tilemode
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|clipptr
operator|==
name|NULL
condition|)
name|DeviceError
argument_list|(
literal|"Cliplist too large"
argument_list|)
expr_stmt|;
else|else
name|TileFill
argument_list|(
name|tile
argument_list|,
name|ow
operator|->
name|full
operator|.
name|left
argument_list|,
name|ow
operator|->
name|full
operator|.
name|top
argument_list|,
operator|(
name|BITMAP
operator|*
operator|)
name|NULL
argument_list|,
name|rec
operator|.
name|left
argument_list|,
name|rec
operator|.
name|top
argument_list|,
name|rec
operator|.
name|right
operator|-
name|rec
operator|.
name|left
argument_list|,
name|rec
operator|.
name|bottom
operator|-
name|rec
operator|.
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
block|}
name|Stash_misses
argument_list|(
name|w
argument_list|,
name|vis
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|src
undef|#
directive|undef
name|srs
undef|#
directive|undef
name|dstx
undef|#
directive|undef
name|dsty
block|}
end_block

begin_comment
comment|/* Writes text with a source font in a window */
end_comment

begin_expr_stmt
name|Do_Text
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|text
argument_list|,
name|font
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|dstx
value|req->param.s[0]
define|#
directive|define
name|dsty
value|req->param.s[1]
define|#
directive|define
name|fore
value|(int) req->param.u[4]
define|#
directive|define
name|back
value|(int) req->param.u[5]
define|#
directive|define
name|ccount
value|req->param.s[6]
define|#
directive|define
name|cpad
value|req->param.b[14]
define|#
directive|define
name|spad
value|req->param.b[15]
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
name|RASTER
name|bound
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|||
name|ccount
operator|==
literal|0
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|bound
operator|.
name|left
operator|=
name|dstx
operator|+
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|bound
operator|.
name|top
operator|=
name|dsty
operator|+
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bound
operator|.
name|bottom
operator|=
name|bound
operator|.
name|top
operator|+
name|font
operator|->
name|height
expr_stmt|;
name|bound
operator|.
name|right
operator|=
name|bound
operator|.
name|left
operator|+
name|ccount
operator|*
name|cpad
operator|+
name|TextWidth
argument_list|(
name|text
argument_list|,
name|ccount
argument_list|,
name|spad
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
operator|&
name|bound
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|PrintText
argument_list|(
name|text
argument_list|,
name|ccount
argument_list|,
name|font
argument_list|,
name|fore
argument_list|,
name|back
argument_list|,
name|cpad
argument_list|,
name|spad
argument_list|,
name|bound
operator|.
name|left
argument_list|,
name|bound
operator|.
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dstx
undef|#
directive|undef
name|dsty
undef|#
directive|undef
name|fore
undef|#
directive|undef
name|back
undef|#
directive|undef
name|ccount
undef|#
directive|undef
name|cpad
undef|#
directive|undef
name|spad
block|}
end_block

begin_comment
comment|/* Writes text with a mask font in a window */
end_comment

begin_expr_stmt
name|Do_TextMask
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|text
argument_list|,
name|font
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|dstx
value|req->param.s[0]
define|#
directive|define
name|dsty
value|req->param.s[1]
define|#
directive|define
name|src
value|(int) req->param.u[4]
define|#
directive|define
name|ccount
value|req->param.s[6]
define|#
directive|define
name|cpad
value|req->param.b[14]
define|#
directive|define
name|spad
value|req->param.b[15]
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
name|RASTER
name|bound
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|||
name|ccount
operator|==
literal|0
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|bound
operator|.
name|left
operator|=
name|dstx
operator|+
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|bound
operator|.
name|top
operator|=
name|dsty
operator|+
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bound
operator|.
name|bottom
operator|=
name|bound
operator|.
name|top
operator|+
name|font
operator|->
name|height
expr_stmt|;
name|bound
operator|.
name|right
operator|=
name|bound
operator|.
name|left
operator|+
name|ccount
operator|*
name|cpad
operator|+
name|TextWidth
argument_list|(
name|text
argument_list|,
name|ccount
argument_list|,
name|spad
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
operator|&
name|bound
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|PrintTextMask
argument_list|(
name|text
argument_list|,
name|ccount
argument_list|,
name|font
argument_list|,
name|src
argument_list|,
name|cpad
argument_list|,
name|spad
argument_list|,
name|bound
operator|.
name|left
argument_list|,
name|bound
operator|.
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dstx
undef|#
directive|undef
name|dsty
undef|#
directive|undef
name|ccount
undef|#
directive|undef
name|src
undef|#
directive|undef
name|cpad
undef|#
directive|undef
name|spad
block|}
end_block

begin_comment
comment|/* Draws a line in a window */
end_comment

begin_expr_stmt
name|Do_Line
argument_list|(
name|w
argument_list|,
name|req
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|x1
value|req->param.s[0]
define|#
directive|define
name|y1
value|req->param.s[1]
define|#
directive|define
name|x2
value|req->param.s[2]
define|#
directive|define
name|y2
value|req->param.s[3]
define|#
directive|define
name|src
value|(int) req->param.u[4]
define|#
directive|define
name|brushy
value|req->param.b[10]
define|#
directive|define
name|brushx
value|req->param.b[11]
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
name|RASTER
name|bound
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
name|Vertex
name|vlist
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
operator|||
name|brushx
operator|<=
literal|0
operator|||
name|brushy
operator|<=
literal|0
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* we can only approximate a minimal clipping region */
if|if
condition|(
name|x1
operator|<=
name|x2
condition|)
block|{
name|bound
operator|.
name|left
operator|=
name|x1
expr_stmt|;
name|bound
operator|.
name|right
operator|=
name|x2
expr_stmt|;
block|}
else|else
block|{
name|bound
operator|.
name|left
operator|=
name|x2
expr_stmt|;
name|bound
operator|.
name|right
operator|=
name|x1
expr_stmt|;
block|}
name|bound
operator|.
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
operator|-
name|brushx
expr_stmt|;
name|bound
operator|.
name|right
operator|+=
name|w
operator|->
name|full
operator|.
name|left
operator|+
name|brushx
expr_stmt|;
if|if
condition|(
name|y1
operator|<=
name|y2
condition|)
block|{
name|bound
operator|.
name|top
operator|=
name|y1
expr_stmt|;
name|bound
operator|.
name|bottom
operator|=
name|y2
expr_stmt|;
block|}
else|else
block|{
name|bound
operator|.
name|top
operator|=
name|y2
expr_stmt|;
name|bound
operator|.
name|bottom
operator|=
name|y1
expr_stmt|;
block|}
name|bound
operator|.
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
operator|-
name|brushy
expr_stmt|;
name|bound
operator|.
name|bottom
operator|+=
name|w
operator|->
name|full
operator|.
name|top
operator|+
name|brushy
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
operator|&
name|bound
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|vlist
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|vlist
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|vlist
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|VertexDontDraw
expr_stmt|;
name|vlist
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|x2
expr_stmt|;
name|vlist
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|y2
expr_stmt|;
name|vlist
index|[
literal|1
index|]
operator|.
name|flags
operator|=
name|VertexDrawLastPoint
expr_stmt|;
name|DrawCurve
argument_list|(
name|vlist
argument_list|,
literal|2
argument_list|,
name|w
operator|->
name|full
operator|.
name|left
argument_list|,
name|w
operator|->
name|full
operator|.
name|top
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
name|DrawSolidLine
argument_list|,
name|brushx
argument_list|,
name|brushy
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|x1
undef|#
directive|undef
name|y1
undef|#
directive|undef
name|x2
undef|#
directive|undef
name|y2
undef|#
directive|undef
name|src
undef|#
directive|undef
name|brushx
undef|#
directive|undef
name|brushy
block|}
end_block

begin_comment
comment|/* Draws a polygon/curve in a window */
end_comment

begin_expr_stmt
name|Do_Draw
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|vlist
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Vertex
modifier|*
name|vlist
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|vcount
value|req->param.s[0]
define|#
directive|define
name|src
value|(int) req->param.u[1]
define|#
directive|define
name|brushy
value|req->param.b[4]
define|#
directive|define
name|brushx
value|req->param.b[5]
define|#
directive|define
name|dmode
value|req->param.s[3]
define|#
directive|define
name|altsrc
value|(int) req->param.u[4]
define|#
directive|define
name|patstr
value|req->param.s[5]
define|#
directive|define
name|patlen
value|req->param.s[6]
define|#
directive|define
name|patmul
value|req->param.s[7]
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
operator|||
name|brushx
operator|<=
literal|0
operator|||
name|brushy
operator|<=
literal|0
operator|||
name|dmode
operator|<
literal|0
operator|||
name|dmode
operator|>
literal|2
operator|||
operator|(
name|dmode
operator|>
literal|0
operator|&&
operator|(
name|patlen
operator|<=
literal|0
operator|||
name|patlen
operator|>
literal|16
operator|||
name|patmul
operator|<=
literal|0
operator|)
operator|)
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|||
name|vcount
operator|==
literal|0
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* it is generally impossible for us to compute a minimal clip */
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
operator|&
name|w
operator|->
name|vs
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|vlist
operator|->
name|flags
operator|=
operator|(
name|vlist
operator|->
name|flags
operator||
name|VertexDontDraw
operator|)
operator|&
operator|~
name|VertexRelative
expr_stmt|;
name|DrawCurve
argument_list|(
name|vlist
argument_list|,
name|vcount
argument_list|,
name|w
operator|->
name|full
operator|.
name|left
argument_list|,
name|w
operator|->
name|full
operator|.
name|top
argument_list|,
name|src
argument_list|,
name|altsrc
argument_list|,
name|dmode
argument_list|,
name|brushx
argument_list|,
name|brushy
argument_list|,
name|patstr
argument_list|,
name|patlen
argument_list|,
name|patmul
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|vcount
undef|#
directive|undef
name|src
undef|#
directive|undef
name|brushy
undef|#
directive|undef
name|brushx
undef|#
directive|undef
name|dmode
undef|#
directive|undef
name|altsrc
undef|#
directive|undef
name|patstr
undef|#
directive|undef
name|patlen
undef|#
directive|undef
name|patmul
block|}
end_block

begin_comment
comment|/* Draws a filled polygon/curve in a window */
end_comment

begin_expr_stmt
name|Do_DrawFilled
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|vlist
argument_list|,
name|tile
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Vertex
modifier|*
name|vlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PIXMAP
modifier|*
name|tile
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|vcount
value|req->param.s[0]
define|#
directive|define
name|src
value|(int) req->param.u[1]
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|func
operator|>=
name|funclim
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|tile
operator|&&
name|FALSE
argument_list|(
name|tile
operator|->
name|tile
argument_list|)
condition|)
block|{
name|Xstatus
operator|=
name|BadTile
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|||
name|vcount
operator|==
literal|0
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
if|if TRUE
condition|(
name|ow
operator|->
name|unobscured
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* it is generally impossible for us to compute a minimal clip */
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
operator|&
name|w
operator|->
name|vs
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while TRUE
condition|(
name|ow
operator|->
name|tilemode
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|vlist
operator|->
name|flags
operator|=
operator|(
name|vlist
operator|->
name|flags
operator||
name|VertexDontDraw
operator|)
operator|&
operator|~
name|VertexRelative
expr_stmt|;
name|DrawFilled
argument_list|(
name|vlist
argument_list|,
name|vcount
argument_list|,
name|w
operator|->
name|full
operator|.
name|left
argument_list|,
name|w
operator|->
name|full
operator|.
name|top
argument_list|,
name|src
argument_list|,
name|tile
argument_list|,
name|ow
operator|->
name|full
operator|.
name|left
argument_list|,
name|ow
operator|->
name|full
operator|.
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|mask
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|vcount
undef|#
directive|undef
name|src
block|}
end_block

begin_comment
comment|/* Save a region of a window */
end_comment

begin_function
name|PIXMAP
modifier|*
name|Do_PixmapSave
parameter_list|(
name|w
parameter_list|,
name|req
parameter_list|)
specifier|register
name|WINDOW
modifier|*
name|w
decl_stmt|;
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
block|{
define|#
directive|define
name|src
value|((REGION *) req->param.s)
name|PIXMAP
modifier|*
name|pix
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|height
operator|<=
literal|0
operator|||
name|src
operator|->
name|width
operator|<=
literal|0
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|src
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|src
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|||
name|src
operator|->
name|left
operator|<
name|w
operator|->
name|vs
operator|.
name|left
operator|||
name|src
operator|->
name|top
operator|<
name|w
operator|->
name|vs
operator|.
name|top
operator|||
name|src
operator|->
name|left
operator|+
name|src
operator|->
name|width
operator|>
name|w
operator|->
name|vs
operator|.
name|right
operator|||
name|src
operator|->
name|top
operator|+
name|src
operator|->
name|height
operator|>
name|w
operator|->
name|vs
operator|.
name|bottom
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pix
operator|=
name|PixmapSave
argument_list|(
name|src
operator|->
name|left
argument_list|,
name|src
operator|->
name|top
argument_list|,
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|pix
operator|==
name|NULL
condition|)
name|Xstatus
operator|=
name|BadAlloc
expr_stmt|;
return|return
operator|(
name|pix
operator|)
return|;
undef|#
directive|undef
name|src
block|}
end_function

begin_comment
comment|/* Read a region of a window */
end_comment

begin_expr_stmt
name|Do_PixmapGet
argument_list|(
name|w
argument_list|,
name|req
argument_list|,
name|client
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XReq
modifier|*
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|client
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|src
value|((REGION *) req->param.s)
name|XRep
name|rep
decl_stmt|;
ifdef|#
directive|ifdef
name|DUALTCP
specifier|register
name|swaptype
name|n
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rep
operator|.
name|param
operator|.
name|l
index|[
literal|0
index|]
operator|=
name|Pix_size
argument_list|(
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
name|src
operator|->
name|height
argument_list|,
name|src
operator|->
name|width
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|src
operator|->
name|left
operator|+=
name|w
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|src
operator|->
name|top
operator|+=
name|w
operator|->
name|full
operator|.
name|top
expr_stmt|;
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|||
name|src
operator|->
name|left
operator|<
name|w
operator|->
name|vs
operator|.
name|left
operator|||
name|src
operator|->
name|top
operator|<
name|w
operator|->
name|vs
operator|.
name|top
operator|||
name|src
operator|->
name|left
operator|+
name|src
operator|->
name|width
operator|>
name|w
operator|->
name|vs
operator|.
name|right
operator|||
name|src
operator|->
name|top
operator|+
name|src
operator|->
name|height
operator|>
name|w
operator|->
name|vs
operator|.
name|bottom
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
name|rep
operator|.
name|code
operator|=
name|X_Reply
expr_stmt|;
ifdef|#
directive|ifdef
name|DUALTCP
if|if
condition|(
name|swapped
index|[
name|client
index|]
condition|)
block|{
name|pswapl
argument_list|(
operator|&
name|rep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|Write
argument_list|(
name|client
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rep
argument_list|,
sizeof|sizeof
argument_list|(
name|XRep
argument_list|)
argument_list|)
expr_stmt|;
name|PixmapGet
argument_list|(
name|src
operator|->
name|left
argument_list|,
name|src
operator|->
name|top
argument_list|,
name|src
operator|->
name|width
argument_list|,
name|src
operator|->
name|height
argument_list|,
name|client
argument_list|,
operator|(
name|int
operator|)
name|req
operator|->
name|func
argument_list|,
ifdef|#
directive|ifdef
name|DUALTCP
name|swapped
index|[
name|client
index|]
else|#
directive|else
literal|0
endif|#
directive|endif
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|src
block|}
end_block

begin_comment
comment|/* Fills a window with the background.  * Fills all the window if not_just_new is set, else just the changes.  */
end_comment

begin_expr_stmt
name|Do_background
argument_list|(
name|w
argument_list|,
name|not_just_new
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|not_just_new
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
name|PIXMAP
modifier|*
name|tile
decl_stmt|;
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
return|return;
name|ow
operator|=
name|w
expr_stmt|;
while|while
condition|(
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|ow
operator|->
name|visible
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|TRUE
argument_list|(
name|not_just_new
argument_list|)
operator|&&
name|TRUE
argument_list|(
name|ow
operator|->
name|unobscured
argument_list|)
condition|)
block|{
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|Get_clips
argument_list|(
operator|&
name|w
operator|->
name|vs
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
name|ow
argument_list|,
name|not_just_new
argument_list|,
operator|&
name|cliplist
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|tile
operator|=
name|ow
operator|->
name|tile
expr_stmt|;
name|ow
operator|=
name|w
expr_stmt|;
while|while TRUE
condition|(
name|ow
operator|->
name|tilemode
condition|)
name|ow
operator|=
name|ow
operator|->
name|parent
expr_stmt|;
name|TileFill
argument_list|(
name|tile
argument_list|,
name|ow
operator|->
name|full
operator|.
name|left
argument_list|,
name|ow
operator|->
name|full
operator|.
name|top
argument_list|,
operator|(
name|BITMAP
operator|*
operator|)
name|NULL
argument_list|,
name|w
operator|->
name|vs
operator|.
name|left
argument_list|,
name|w
operator|->
name|vs
operator|.
name|top
argument_list|,
name|w
operator|->
name|vs
operator|.
name|right
operator|-
name|w
operator|->
name|vs
operator|.
name|left
argument_list|,
name|w
operator|->
name|vs
operator|.
name|bottom
operator|-
name|w
operator|->
name|vs
operator|.
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
name|GXcopy
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move the contents of a window on the screen and redisplay the border. */
end_comment

begin_expr_stmt
name|Do_refill
argument_list|(
name|w
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
specifier|register
name|CLIP
modifier|*
name|clipptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
name|RASTER
name|temp
decl_stmt|;
comment|/* Order rectangles by direction of motion */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v1
operator|=
name|w
operator|->
name|cmvisible
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
block|{
name|i
operator|++
expr_stmt|;
for|for
control|(
name|v2
operator|=
name|v1
operator|->
name|next
init|;
name|v2
condition|;
name|v2
operator|=
name|v2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|dy
operator|<=
literal|0
operator|&&
name|v1
operator|->
name|top
operator|==
name|v2
operator|->
name|top
operator|)
operator|||
operator|(
name|dy
operator|>
literal|0
operator|&&
name|v1
operator|->
name|bottom
operator|==
name|v2
operator|->
name|bottom
operator|)
operator|)
operator|&&
operator|(
operator|(
name|dx
operator|<
literal|0
operator|&&
name|v1
operator|->
name|left
operator|>
name|v2
operator|->
name|left
operator|)
operator|||
operator|(
name|dx
operator|>
literal|0
operator|&&
name|v1
operator|->
name|right
operator|<
name|v2
operator|->
name|right
operator|)
operator|)
operator|)
operator|||
operator|(
name|dy
operator|<
literal|0
operator|&&
name|v1
operator|->
name|top
operator|>
name|v2
operator|->
name|top
operator|)
operator|||
operator|(
name|dy
operator|>
literal|0
operator|&&
name|v1
operator|->
name|bottom
operator|<
name|v2
operator|->
name|bottom
operator|)
condition|)
block|{
name|temp
operator|=
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v1
expr_stmt|;
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v1
operator|=
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v2
expr_stmt|;
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|v2
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|i
condition|)
block|{
name|clipptr
operator|=
operator|(
name|CLIP
operator|*
operator|)
name|AllocateSpace
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|CLIP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliplist
operator|=
name|clipptr
condition|)
block|{
for|for
control|(
name|v1
operator|=
name|w
operator|->
name|cmvisible
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|next
control|)
block|{
name|clipptr
operator|->
name|left
operator|=
name|v1
operator|->
name|left
expr_stmt|;
name|clipptr
operator|->
name|top
operator|=
name|v1
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|height
operator|=
name|v1
operator|->
name|bottom
operator|-
name|v1
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|width
operator|=
name|v1
operator|->
name|right
operator|-
name|v1
operator|->
name|left
expr_stmt|;
name|clipptr
operator|++
expr_stmt|;
block|}
name|CopyArea
argument_list|(
name|w
operator|->
name|vs
operator|.
name|left
operator|-
name|dx
argument_list|,
name|w
operator|->
name|vs
operator|.
name|top
operator|-
name|dy
argument_list|,
name|w
operator|->
name|vs
operator|.
name|right
operator|-
name|w
operator|->
name|vs
operator|.
name|left
argument_list|,
name|w
operator|->
name|vs
operator|.
name|bottom
operator|-
name|w
operator|->
name|vs
operator|.
name|top
argument_list|,
name|w
operator|->
name|vs
operator|.
name|left
argument_list|,
name|w
operator|->
name|vs
operator|.
name|top
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
name|GXcopy
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
block|}
else|else
name|DeviceError
argument_list|(
literal|"Cliplist too large"
argument_list|)
expr_stmt|;
block|}
name|Do_border
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Repaint the border of a window */
end_comment

begin_expr_stmt
name|Do_border
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
specifier|register
name|CLIP
modifier|*
name|clipptr
decl_stmt|;
for|for
control|(
name|r
operator|=
name|w
operator|->
name|visible
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|border_rec
condition|)
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return;
name|clipptr
operator|=
operator|(
name|CLIP
operator|*
operator|)
name|AllocateSpace
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|CLIP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clipptr
operator|==
name|NULL
condition|)
block|{
name|DeviceError
argument_list|(
literal|"Cliplist too large"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cliplist
operator|=
name|clipptr
expr_stmt|;
for|for
control|(
name|r
operator|=
name|w
operator|->
name|visible
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|border_rec
condition|)
block|{
name|clipptr
operator|->
name|left
operator|=
name|r
operator|->
name|left
expr_stmt|;
name|clipptr
operator|->
name|top
operator|=
name|r
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|height
operator|=
name|r
operator|->
name|bottom
operator|-
name|r
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|width
operator|=
name|r
operator|->
name|right
operator|-
name|r
operator|->
name|left
expr_stmt|;
name|clipptr
operator|++
expr_stmt|;
block|}
block|}
name|TileFill
argument_list|(
name|w
operator|->
name|border
argument_list|,
name|w
operator|->
name|full
operator|.
name|left
operator|-
name|w
operator|->
name|bwidth
argument_list|,
name|w
operator|->
name|full
operator|.
name|top
operator|-
name|w
operator|->
name|bwidth
argument_list|,
operator|(
name|BITMAP
operator|*
operator|)
name|NULL
argument_list|,
name|w
operator|->
name|full
operator|.
name|left
operator|-
name|w
operator|->
name|bwidth
argument_list|,
name|w
operator|->
name|full
operator|.
name|top
operator|-
name|w
operator|->
name|bwidth
argument_list|,
name|w
operator|->
name|full
operator|.
name|right
operator|-
name|w
operator|->
name|full
operator|.
name|left
operator|+
operator|(
name|w
operator|->
name|bwidth
operator|<<
literal|1
operator|)
argument_list|,
name|w
operator|->
name|full
operator|.
name|bottom
operator|-
name|w
operator|->
name|full
operator|.
name|top
operator|+
operator|(
name|w
operator|->
name|bwidth
operator|<<
literal|1
operator|)
argument_list|,
name|cliplist
argument_list|,
name|i
argument_list|,
name|GXcopy
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compute a clip list for a destination, and return clip count.  * w is the original window, ow is the actual output window.  * If not_just_new, compute for all of the window, else just the changes.  * We assume that it is better (cheaper/faster) for us to compute a minimal  * clip list than to expect all devices to do the computation.  */
end_comment

begin_expr_stmt
name|Get_clips
argument_list|(
name|dst
argument_list|,
name|w
argument_list|,
name|ow
argument_list|,
name|not_just_new
argument_list|,
name|cliplist
argument_list|)
specifier|register
name|RASTER
operator|*
name|dst
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|WINDOW
modifier|*
name|w
decl_stmt|,
modifier|*
name|ow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|not_just_new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIP
modifier|*
modifier|*
name|cliplist
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|r
decl_stmt|;
specifier|register
name|RECTANGLE
modifier|*
modifier|*
name|ptr1
decl_stmt|,
modifier|*
modifier|*
name|ptr2
decl_stmt|;
name|RECTANGLE
modifier|*
name|clips
decl_stmt|;
specifier|register
name|CLIP
modifier|*
name|clipptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|RASTER
name|rast
decl_stmt|;
if|if
condition|(
name|w
operator|&&
name|TRUE
argument_list|(
name|w
operator|->
name|clipmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|ow
operator|==
name|rootwindow
condition|)
block|{
operator|*
name|cliplist
operator|=
operator|&
name|w
operator|->
name|clip
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ptr1
operator|=
operator|&
name|ow
operator|->
name|cmvisible
expr_stmt|;
block|}
else|else
name|ptr1
operator|=
operator|&
name|ow
operator|->
name|visible
expr_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|!=
name|ow
condition|)
block|{
name|rast
operator|=
operator|*
name|dst
expr_stmt|;
name|dst
operator|=
operator|&
name|rast
expr_stmt|;
name|Clip_raster
argument_list|(
name|dst
argument_list|,
operator|&
name|w
operator|->
name|vs
argument_list|)
expr_stmt|;
block|}
name|ptr2
operator|=
operator|&
name|clips
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
operator|*
name|ptr1
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|r
operator|->
name|type
operator|==
name|contents_rec
operator|&&
name|not_just_new
operator|)
operator|||
operator|(
name|r
operator|->
name|type
operator|==
name|new_rec
operator|)
operator|)
operator|&&
name|max
argument_list|(
name|dst
operator|->
name|left
argument_list|,
name|r
operator|->
name|left
argument_list|)
operator|<
name|min
argument_list|(
name|dst
operator|->
name|right
argument_list|,
name|r
operator|->
name|right
argument_list|)
operator|&&
name|max
argument_list|(
name|dst
operator|->
name|top
argument_list|,
name|r
operator|->
name|top
argument_list|)
operator|<
name|min
argument_list|(
name|dst
operator|->
name|bottom
argument_list|,
name|r
operator|->
name|bottom
argument_list|)
condition|)
block|{
operator|*
name|ptr2
operator|=
name|r
expr_stmt|;
name|ptr2
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr1
operator|=
name|r
expr_stmt|;
name|ptr1
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
block|}
block|}
operator|*
name|ptr2
operator|=
name|NULL
expr_stmt|;
operator|*
name|ptr1
operator|=
name|clips
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|clipptr
operator|=
operator|(
name|CLIP
operator|*
operator|)
name|AllocateSpace
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|CLIP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clipptr
operator|==
name|NULL
condition|)
block|{
name|DeviceError
argument_list|(
literal|"Cliplist too large"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|cliplist
operator|=
name|clipptr
expr_stmt|;
for|for
control|(
name|r
operator|=
name|clips
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|clipptr
operator|->
name|left
operator|=
name|max
argument_list|(
name|r
operator|->
name|left
argument_list|,
name|dst
operator|->
name|left
argument_list|)
expr_stmt|;
name|clipptr
operator|->
name|top
operator|=
name|max
argument_list|(
name|r
operator|->
name|top
argument_list|,
name|dst
operator|->
name|top
argument_list|)
expr_stmt|;
name|clipptr
operator|->
name|height
operator|=
name|min
argument_list|(
name|r
operator|->
name|bottom
argument_list|,
name|dst
operator|->
name|bottom
argument_list|)
operator|-
name|clipptr
operator|->
name|top
expr_stmt|;
name|clipptr
operator|->
name|width
operator|=
name|min
argument_list|(
name|r
operator|->
name|right
argument_list|,
name|dst
operator|->
name|right
argument_list|)
operator|-
name|clipptr
operator|->
name|left
expr_stmt|;
name|clipptr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

end_unit

