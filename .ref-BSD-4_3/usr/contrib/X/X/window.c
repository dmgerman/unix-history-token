begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_comment
comment|/* Routines for maintaining windows:  *  *	Create_root_window, Create_window, Destroy_window,  *	Map_root_window, Map_window, Map_subwindows,  *	Unmap_window, Unmap_subwindows, Remove_subwindows,  *	Move_window, Change_window, Change_background, Change_border,  *	Raise_window, Lower_window, Circulate_window_up, Circulate_window_down,  *	Draw_window, Windex, Free_window_storage  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_window_c
init|=
literal|"$Header: window.c,v 10.8 86/02/01 15:17:33 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"Xint.h"
end_include

begin_decl_stmt
specifier|extern
name|u_char
name|Xstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|RESOURCE
modifier|*
modifier|*
name|Resources
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PIXMAP
modifier|*
name|roottile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|RECTANGLE
modifier|*
name|free_rectangles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mouse_grabber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|WINDOW
modifier|*
name|button_window
decl_stmt|,
modifier|*
name|mouse_grab_window
decl_stmt|,
modifier|*
name|key_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|RASTER
name|mbox
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|Xalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|Add_resource
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|RECTANGLE
modifier|*
name|Alloc_rectangle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|WINDOW
modifier|*
name|Unmap_window
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MBOX
parameter_list|(
name|w
parameter_list|)
value|if (w->vs.top< mbox.bottom&& mbox.top< w->vs.bottom&&\ 		    w->vs.left< mbox.right&& mbox.left< w->vs.right)\ 		    mbox.bottom = 0
end_define

begin_define
define|#
directive|define
name|alloc_at_once
value|25
end_define

begin_decl_stmt
name|WINDOW
modifier|*
name|rootwindow
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The background of the whole tree */
end_comment

begin_decl_stmt
specifier|static
name|WINDOW
modifier|*
name|mapped_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of windows mapped to the screeen */
end_comment

begin_decl_stmt
name|WINDOW
modifier|*
name|free_windows
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create_root_window creates and maps the root window on the screen.  * The root window differs from other windows in that it has no parent.  */
end_comment

begin_macro
name|Create_root_window
argument_list|(
argument|height
argument_list|,
argument|width
argument_list|,
argument|tile
argument_list|)
end_macro

begin_decl_stmt
name|int
name|height
decl_stmt|,
name|width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PIXMAP
modifier|*
name|tile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|root
decl_stmt|;
comment|/* make sure no other windows are in the root's malloc'd area */
name|free_windows
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|free_windows
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|root
operator|=
name|Create_window
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|PIXMAP
operator|*
operator|)
name|NULL
argument_list|,
name|tile
argument_list|,
name|IsOpaque
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rootwindow
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|Resources
index|[
name|RESIDX
argument_list|(
name|root
argument_list|)
index|]
operator|->
name|value
expr_stmt|;
name|rootwindow
operator|->
name|clipmode
operator|=
name|ClipModeDrawThru
expr_stmt|;
name|Map_root_window
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Create_window creates a new window with common parameters filled in.  * The window returned is unmapped.  */
end_comment

begin_function
name|int
name|Create_window
parameter_list|(
name|height
parameter_list|,
name|width
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|bwidth
parameter_list|,
name|border
parameter_list|,
name|tile
parameter_list|,
name|kind
parameter_list|,
name|parent
parameter_list|,
name|client
parameter_list|)
name|int
name|height
decl_stmt|,
name|width
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|bwidth
decl_stmt|,
name|kind
decl_stmt|,
name|client
decl_stmt|;
specifier|register
name|WINDOW
modifier|*
name|parent
decl_stmt|;
name|PIXMAP
modifier|*
name|border
decl_stmt|,
decl|*
name|tile
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|height
operator|<=
literal|0
operator|||
name|width
operator|<=
literal|0
operator|||
name|bwidth
operator|<
literal|0
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|IsTransparent
condition|)
block|{
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
block|{
name|Xstatus
operator|=
name|BadMatch
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|bwidth
operator|>
literal|0
operator|&&
name|border
operator|==
name|NULL
condition|)
block|{
name|Xstatus
operator|=
name|BadPixmap
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|border
operator|&&
name|FALSE
argument_list|(
name|border
operator|->
name|tile
argument_list|)
operator|)
operator|||
operator|(
name|tile
operator|&&
name|FALSE
argument_list|(
name|tile
operator|->
name|tile
argument_list|)
operator|)
condition|)
block|{
name|Xstatus
operator|=
name|BadTile
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tile
operator|==
name|NULL
condition|)
block|{
name|tile
operator|=
name|parent
operator|->
name|tile
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|w
operator|=
name|free_windows
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* We allocate in chunks to minimize fragmentation. */
name|w
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|Xalloc
argument_list|(
name|alloc_at_once
operator|*
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|free_windows
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|internal
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|alloc_at_once
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
name|w
operator|->
name|next
operator|=
name|w
operator|+
literal|1
expr_stmt|;
name|w
operator|++
expr_stmt|;
name|w
operator|->
name|internal
operator|=
literal|1
expr_stmt|;
block|}
name|w
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|w
operator|=
name|free_windows
expr_stmt|;
block|}
name|free_windows
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|left
operator|=
name|x
operator|+
name|bwidth
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|top
operator|=
name|y
operator|+
name|bwidth
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|right
operator|=
name|w
operator|->
name|full
operator|.
name|left
operator|+
name|width
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|bottom
operator|=
name|w
operator|->
name|full
operator|.
name|top
operator|+
name|height
expr_stmt|;
name|w
operator|->
name|bwidth
operator|=
name|bwidth
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|border
operator|=
name|border
condition|)
name|border
operator|->
name|refcnt
operator|++
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|tile
operator|=
name|tile
condition|)
name|tile
operator|->
name|refcnt
operator|++
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|IsTransparent
condition|)
name|w
operator|->
name|tilemode
operator|=
name|TileModeRelative
expr_stmt|;
else|else
name|w
operator|->
name|tilemode
operator|=
name|TileModeAbsolute
expr_stmt|;
name|w
operator|->
name|clipmode
operator|=
name|ClipModeClipped
expr_stmt|;
name|w
operator|->
name|cursor
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|mask
operator|=
name|NoEvent
expr_stmt|;
name|w
operator|->
name|client
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|w
operator|->
name|level
operator|=
name|parent
operator|->
name|level
operator|+
literal|1
expr_stmt|;
else|else
name|w
operator|->
name|level
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|w
operator|->
name|first_child
operator|=
name|w
operator|->
name|last_child
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|w
operator|->
name|visible
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|cmvisible
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|unobscured
operator|=
name|OB_NOT
expr_stmt|;
name|w
operator|->
name|mapped
operator|=
name|w
operator|->
name|should_be_mapped
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|bgrabs
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|width0
operator|=
name|w
operator|->
name|height0
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|widthinc
operator|=
name|w
operator|->
name|heightinc
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|icon
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
comment|/* make it the top-most child */
if|if
condition|(
name|parent
operator|->
name|last_child
condition|)
block|{
name|parent
operator|->
name|last_child
operator|->
name|next_sib
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|prev_sib
operator|=
name|parent
operator|->
name|last_child
expr_stmt|;
name|w
operator|->
name|next_sib
operator|=
name|NULL
expr_stmt|;
name|parent
operator|->
name|last_child
operator|=
name|w
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|->
name|first_child
operator|=
name|parent
operator|->
name|last_child
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|next_sib
operator|=
name|w
operator|->
name|prev_sib
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|w
operator|->
name|next_sib
operator|=
name|w
operator|->
name|prev_sib
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|w
operator|->
name|rid
operator|=
name|Add_resource
argument_list|(
name|RT_WINDOW
argument_list|,
name|client
argument_list|,
operator|(
name|caddr_t
operator|)
name|w
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Eliminate a window. */
end_comment

begin_expr_stmt
name|Destroy_window
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|icon
decl_stmt|;
comment|/* Check icon status */
if|if
condition|(
name|icon
operator|=
name|w
operator|->
name|icon
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|kind
operator|==
name|IsIcon
operator|&&
name|TRUE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|&&
name|FALSE
argument_list|(
name|icon
operator|->
name|mapped
argument_list|)
condition|)
name|Map_window
argument_list|(
name|icon
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|icon
operator|->
name|kind
operator|==
name|IsIcon
operator|&&
name|TRUE
argument_list|(
name|icon
operator|->
name|mapped
argument_list|)
condition|)
block|{
name|Unmap_window
argument_list|(
name|icon
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Stash_simple
argument_list|(
name|icon
argument_list|,
operator|(
name|long
operator|)
name|UnmapWindow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|icon
operator|->
name|kind
operator|=
name|IsOpaque
expr_stmt|;
name|icon
operator|->
name|icon
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Unmap it */
if|if TRUE
condition|(
name|w
operator|->
name|mapped
condition|)
name|Unmap_window
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Destroy all the children */
if|if
condition|(
name|w
operator|->
name|first_child
condition|)
name|Zap_subwindows
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Remove from parent's list */
if|if
condition|(
name|w
operator|->
name|next_sib
condition|)
name|w
operator|->
name|next_sib
operator|->
name|prev_sib
operator|=
name|w
operator|->
name|prev_sib
expr_stmt|;
else|else
name|w
operator|->
name|parent
operator|->
name|last_child
operator|=
name|w
operator|->
name|prev_sib
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|prev_sib
condition|)
name|w
operator|->
name|prev_sib
operator|->
name|next_sib
operator|=
name|w
operator|->
name|next_sib
expr_stmt|;
else|else
name|w
operator|->
name|parent
operator|->
name|first_child
operator|=
name|w
operator|->
name|next_sib
expr_stmt|;
comment|/* Get it out of any binds */
if|if
condition|(
name|w
operator|==
name|button_window
operator|||
operator|(
name|mouse_grabber
operator|&&
name|w
operator|==
name|mouse_grab_window
operator|)
condition|)
name|Stash_ungrabs
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|bgrabs
condition|)
name|Unbutton_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|key_window
condition|)
block|{
name|key_window
operator|=
name|NULL
expr_stmt|;
name|Focus_keyboard
argument_list|(
name|w
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
comment|/* Free the resources */
if|if
condition|(
name|w
operator|->
name|cursor
condition|)
name|Unregister_cursor
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|name
condition|)
name|free
argument_list|(
name|w
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|border
operator|&&
operator|--
name|w
operator|->
name|border
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreePixmap
argument_list|(
name|w
operator|->
name|border
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|tile
operator|&&
operator|--
name|w
operator|->
name|tile
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreePixmap
argument_list|(
name|w
operator|->
name|tile
argument_list|)
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|free_windows
expr_stmt|;
name|free_windows
operator|=
name|w
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Maps the root window */
end_comment

begin_macro
name|Map_root_window
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w
init|=
name|rootwindow
decl_stmt|;
specifier|register
name|RECTANGLE
modifier|*
name|r
decl_stmt|;
name|w
operator|->
name|vs
operator|=
name|w
operator|->
name|full
expr_stmt|;
name|w
operator|->
name|ovs
operator|=
name|w
operator|->
name|full
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|left
operator|=
name|w
operator|->
name|vs
operator|.
name|left
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|top
operator|=
name|w
operator|->
name|vs
operator|.
name|top
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|height
operator|=
name|w
operator|->
name|vs
operator|.
name|bottom
operator|-
name|w
operator|->
name|vs
operator|.
name|top
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|width
operator|=
name|w
operator|->
name|vs
operator|.
name|right
operator|-
name|w
operator|->
name|vs
operator|.
name|left
expr_stmt|;
name|RASTRECT
argument_list|(
name|r
argument_list|,
name|w
operator|->
name|full
argument_list|,
name|contents_rec
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|visible
operator|=
name|r
expr_stmt|;
name|RASTRECT
argument_list|(
name|r
argument_list|,
name|w
operator|->
name|full
argument_list|,
name|contents_rec
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|cmvisible
operator|=
name|r
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|mapped_list
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|mapped
operator|=
name|w
operator|->
name|should_be_mapped
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|unobscured
operator|=
name|OB_YES
expr_stmt|;
name|Do_background
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Map_window raises and displays the specified window on the screen.  It also  * goes through the window's subwindows and maps all those for whom the  * should_be_mapped flag is set.  */
end_comment

begin_expr_stmt
name|Map_window
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if FALSE
condition|(
name|w
operator|->
name|parent
operator|->
name|mapped
condition|)
block|{
name|w
operator|->
name|should_be_mapped
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|Map_window_main
argument_list|(
name|w
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MBOX
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|first_child
condition|)
name|Map_subwindows
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Draw_window
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Does the common work of mapping a window.  * If top is set, the window is top-most, else it is bottom-most.  * If dontMove is set, this window is already placed in the parent's list.  */
end_comment

begin_expr_stmt
name|Map_window_main
argument_list|(
name|w
argument_list|,
name|top
argument_list|,
name|dontMove
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|dontMove
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
init|=
name|w
operator|->
name|parent
decl_stmt|;
name|w
operator|->
name|mapped
operator|=
name|w
operator|->
name|should_be_mapped
operator|=
literal|1
expr_stmt|;
comment|/* get absolute coordinates */
name|w
operator|->
name|full
operator|.
name|left
operator|+=
name|w1
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|top
operator|+=
name|w1
operator|->
name|full
operator|.
name|top
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|right
operator|+=
name|w1
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|bottom
operator|+=
name|w1
operator|->
name|full
operator|.
name|top
expr_stmt|;
comment|/* clip to parent */
name|w
operator|->
name|vs
operator|=
name|w
operator|->
name|full
expr_stmt|;
name|Clip_raster
argument_list|(
operator|&
name|w
operator|->
name|vs
argument_list|,
operator|&
name|w1
operator|->
name|vs
argument_list|)
expr_stmt|;
name|w
operator|->
name|ovs
operator|.
name|left
operator|=
name|w
operator|->
name|full
operator|.
name|left
operator|-
name|w
operator|->
name|bwidth
expr_stmt|;
name|w
operator|->
name|ovs
operator|.
name|right
operator|=
name|w
operator|->
name|full
operator|.
name|right
operator|+
name|w
operator|->
name|bwidth
expr_stmt|;
name|w
operator|->
name|ovs
operator|.
name|top
operator|=
name|w
operator|->
name|full
operator|.
name|top
operator|-
name|w
operator|->
name|bwidth
expr_stmt|;
name|w
operator|->
name|ovs
operator|.
name|bottom
operator|=
name|w
operator|->
name|full
operator|.
name|bottom
operator|+
name|w
operator|->
name|bwidth
expr_stmt|;
name|Clip_raster
argument_list|(
operator|&
name|w
operator|->
name|ovs
argument_list|,
operator|&
name|w1
operator|->
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|ovs
operator|.
name|right
operator|<=
name|w
operator|->
name|ovs
operator|.
name|left
condition|)
name|w
operator|->
name|ovs
operator|.
name|right
operator|=
name|w
operator|->
name|ovs
operator|.
name|bottom
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|left
operator|=
name|w
operator|->
name|vs
operator|.
name|left
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|top
operator|=
name|w
operator|->
name|vs
operator|.
name|top
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|height
operator|=
name|w
operator|->
name|vs
operator|.
name|bottom
operator|-
name|w
operator|->
name|vs
operator|.
name|top
expr_stmt|;
name|w
operator|->
name|clip
operator|.
name|width
operator|=
name|w
operator|->
name|vs
operator|.
name|right
operator|-
name|w
operator|->
name|vs
operator|.
name|left
expr_stmt|;
if|if TRUE
condition|(
name|top
condition|)
block|{
comment|/* Search the mapped_list backwards starting at w's parent until we 	     * either find a window with a lower level or we find the beginning 	     * of the list.  Insert after it. 	     */
do|do
block|{
name|w1
operator|=
name|w1
operator|->
name|prev
expr_stmt|;
block|}
do|while
condition|(
name|w1
operator|&&
name|w1
operator|->
name|level
operator|>=
name|w
operator|->
name|level
condition|)
do|;
if|if
condition|(
name|w1
condition|)
block|{
name|w
operator|->
name|prev
operator|=
name|w1
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|w1
operator|->
name|next
expr_stmt|;
name|w
operator|->
name|next
operator|->
name|prev
operator|=
name|w
expr_stmt|;
name|w1
operator|->
name|next
operator|=
name|w
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|next
operator|=
name|mapped_list
expr_stmt|;
name|mapped_list
operator|->
name|prev
operator|=
name|w
expr_stmt|;
name|mapped_list
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Move w to be the last child of its parent */
if|if
condition|(
name|w
operator|->
name|next_sib
operator|&&
name|FALSE
argument_list|(
name|dontMove
argument_list|)
condition|)
name|Make_top_child
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* Get its rectangles and obscure other windows */
if|if
condition|(
name|w
operator|->
name|kind
operator|!=
name|IsTransparent
condition|)
name|Obscure_top
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Place w just before its parent in the mapped_list */
name|w
operator|->
name|next
operator|=
name|w1
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|prev
operator|=
name|w1
operator|->
name|prev
condition|)
name|w
operator|->
name|prev
operator|->
name|next
operator|=
name|w
expr_stmt|;
else|else
name|mapped_list
operator|=
name|w
expr_stmt|;
name|w1
operator|->
name|prev
operator|=
name|w
expr_stmt|;
comment|/* Move w to be the first child of its parent */
if|if
condition|(
name|w
operator|->
name|prev_sib
operator|&&
name|FALSE
argument_list|(
name|dontMove
argument_list|)
condition|)
name|Make_bottom_child
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* Get its rectangles and obscure other windows */
if|if
condition|(
name|w
operator|->
name|kind
operator|!=
name|IsTransparent
condition|)
name|Obscure_bottom
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Maps the subwindows of a window.  * If dontRedraw is set, the subwindows have already been displayed.  * If all is set, all subwindows are mapped, not just the should_be_mapped.  */
end_comment

begin_macro
name|Map_subwindows
argument_list|(
argument|w
argument_list|,
argument|dontRedraw
argument_list|,
argument|all
argument_list|)
end_macro

begin_decl_stmt
name|WINDOW
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dontRedraw
decl_stmt|,
name|all
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
decl_stmt|;
if|if TRUE
condition|(
name|w
operator|->
name|mapped
condition|)
block|{
comment|/* mapping from top to bottom is the most efficient */
for|for
control|(
name|w1
operator|=
name|w
operator|->
name|last_child
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|prev_sib
control|)
block|{
if|if
condition|(
name|FALSE
argument_list|(
name|w1
operator|->
name|mapped
argument_list|)
operator|&&
operator|(
name|TRUE
argument_list|(
name|all
argument_list|)
operator|||
name|TRUE
argument_list|(
name|w1
operator|->
name|should_be_mapped
argument_list|)
operator|)
condition|)
block|{
name|Map_window_main
argument_list|(
name|w1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|all
condition|)
block|{
name|MBOX
argument_list|(
name|w1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w1
operator|->
name|first_child
condition|)
name|Map_subwindows
argument_list|(
name|w1
argument_list|,
name|dontRedraw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if FALSE
condition|(
name|dontRedraw
condition|)
name|Draw_window
argument_list|(
name|w1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if TRUE
condition|(
name|all
condition|)
block|{
for|for
control|(
name|w1
operator|=
name|w
operator|->
name|first_child
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|next_sib
control|)
name|w1
operator|->
name|should_be_mapped
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Unmap_window removes the window from the list of mapped windows and updates  * all the windows that it may have been obscuring.  All the subwindows are  * unmapped but their should_be_mapped flags are unchanged.  If cleanup = 1,  * then update windows you uncover.  If cleanup< 0, then update the  * windows you uncover without changing the bits on the screen.  * Returns the next mapped window in the mapped_list chain.  */
end_comment

begin_function
name|WINDOW
modifier|*
name|Unmap_window
parameter_list|(
name|w
parameter_list|,
name|cleanup
parameter_list|)
specifier|register
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|int
name|cleanup
decl_stmt|;
block|{
name|WINDOW
modifier|*
name|w1
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|first_child
condition|)
block|{
name|Zap_subwindows
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Restore_rectangles
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|MBOX
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w1
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|Unmap_window_main
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
return|return
operator|(
name|w1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Restore the visible rectangles as if there were no subwindows, i.e.,  * make it a copy of cmvisible plus existing borders.  */
end_comment

begin_macro
name|Restore_rectangles
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|WINDOW
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|vr
decl_stmt|,
modifier|*
name|cr
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|cr
operator|=
name|w
operator|->
name|cmvisible
expr_stmt|;
name|prev
operator|=
operator|&
name|w
operator|->
name|visible
expr_stmt|;
comment|/* reuse what we can */
while|while
condition|(
name|vr
operator|=
operator|*
name|prev
condition|)
block|{
if|if
condition|(
name|vr
operator|->
name|type
operator|!=
name|border_rec
condition|)
block|{
if|if
condition|(
name|cr
operator|==
name|NULL
condition|)
block|{
operator|*
name|prev
operator|=
name|vr
operator|->
name|next
expr_stmt|;
name|FREERECT
argument_list|(
name|vr
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|vr
operator|=
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|cr
expr_stmt|;
name|vr
operator|->
name|type
operator|=
name|contents_rec
expr_stmt|;
name|cr
operator|=
name|cr
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|=
operator|&
name|vr
operator|->
name|next
expr_stmt|;
block|}
comment|/* allocate the rest */
for|for
control|(
init|;
name|cr
condition|;
name|cr
operator|=
name|cr
operator|->
name|next
control|)
block|{
name|RASTRECT
argument_list|(
name|vr
argument_list|,
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|cr
argument_list|,
name|contents_rec
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|vr
expr_stmt|;
name|prev
operator|=
operator|&
name|vr
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Do the common work of unmapping a window.  * Set should_be_mapped to the indicated state.  If cleanup = 1, then update  * windows you uncover.  If cleanup< 0, then update the windows you uncover  * without changing the bits on the screen.  */
end_comment

begin_expr_stmt
name|Unmap_window_main
argument_list|(
name|w
argument_list|,
name|should_be_mapped
argument_list|,
name|cleanup
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|should_be_mapped
decl_stmt|,
name|cleanup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
decl_stmt|;
comment|/* Remove it from the list */
name|w1
operator|=
name|w
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|w1
operator|->
name|prev
operator|=
name|w
operator|->
name|prev
condition|)
name|w
operator|->
name|prev
operator|->
name|next
operator|=
name|w1
expr_stmt|;
else|else
name|mapped_list
operator|=
name|w1
expr_stmt|;
comment|/* Get rid of the rectangles */
if|if
condition|(
name|w
operator|->
name|visible
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|cmvisible
condition|)
block|{
name|Free_rectangles
argument_list|(
name|w
operator|->
name|cmvisible
argument_list|)
expr_stmt|;
name|w
operator|->
name|cmvisible
operator|=
name|NULL
expr_stmt|;
block|}
name|Remove_rectangles
argument_list|(
name|w
argument_list|,
name|w1
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|next
operator|=
name|w
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* make coordinates relative */
name|w1
operator|=
name|w
operator|->
name|parent
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|left
operator|-=
name|w1
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|top
operator|-=
name|w1
operator|->
name|full
operator|.
name|top
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|right
operator|-=
name|w1
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|bottom
operator|-=
name|w1
operator|->
name|full
operator|.
name|top
expr_stmt|;
name|w
operator|->
name|should_be_mapped
operator|=
name|should_be_mapped
expr_stmt|;
name|w
operator|->
name|mapped
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|unobscured
operator|=
name|OB_NOT
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Unmap all the subwindows of a window. */
end_comment

begin_macro
name|Unmap_subwindows
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|WINDOW
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
decl_stmt|;
for|for
control|(
name|w1
operator|=
name|w
operator|->
name|first_child
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|next_sib
control|)
block|{
if|if TRUE
condition|(
name|w1
operator|->
name|mapped
condition|)
name|Stash_simple
argument_list|(
name|w1
argument_list|,
operator|(
name|long
operator|)
name|UnmapWindow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Remove_subwindows
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Unmap all subwindows, giving space back to parent.  Destroy the subwindows  * if destroy flag is set.  Display the window if cleanup is set.  */
end_comment

begin_macro
name|Remove_subwindows
argument_list|(
argument|w
argument_list|,
argument|destroy
argument_list|,
argument|cleanup
argument_list|)
end_macro

begin_decl_stmt
name|WINDOW
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|destroy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
decl_stmt|;
specifier|register
name|RECTANGLE
modifier|*
name|rec
decl_stmt|,
modifier|*
name|rlist
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|vn
decl_stmt|,
name|cn
decl_stmt|;
comment|/* count visible rectangles */
name|vn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|prev
operator|=
operator|&
name|w
operator|->
name|visible
init|;
name|rec
operator|=
operator|*
name|prev
condition|;
name|prev
operator|=
operator|&
name|rec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rec
operator|->
name|type
operator|!=
name|border_rec
condition|)
name|vn
operator|++
expr_stmt|;
block|}
comment|/* collect new visible rectangles and unmap subwindows */
name|cn
operator|=
literal|0
expr_stmt|;
name|rlist
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|w1
operator|=
name|w
operator|->
name|first_child
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|next_sib
control|)
block|{
if|if TRUE
condition|(
name|w1
operator|->
name|mapped
condition|)
block|{
if|if
condition|(
name|rec
operator|=
name|w1
operator|->
name|cmvisible
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|rec
operator|->
name|type
operator|=
name|new_rec
expr_stmt|;
name|cn
operator|++
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|next
operator|==
name|NULL
condition|)
break|break;
name|rec
operator|=
name|rec
operator|->
name|next
expr_stmt|;
block|}
name|rec
operator|->
name|next
operator|=
name|rlist
expr_stmt|;
name|rlist
operator|=
name|w1
operator|->
name|cmvisible
expr_stmt|;
name|w1
operator|->
name|cmvisible
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|rec
operator|=
name|w1
operator|->
name|visible
condition|)
block|{
name|w1
operator|->
name|visible
operator|=
name|rec
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|type
operator|==
name|border_rec
condition|)
block|{
name|rec
operator|->
name|type
operator|=
name|new_rec
expr_stmt|;
name|rec
operator|->
name|next
operator|=
name|rlist
expr_stmt|;
name|rlist
operator|=
name|rec
expr_stmt|;
name|cn
operator|++
expr_stmt|;
block|}
else|else
block|{
name|FREERECT
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
block|}
if|if TRUE
condition|(
name|cleanup
condition|)
block|{
name|MBOX
argument_list|(
name|w1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w1
operator|->
name|first_child
condition|)
name|Zap_subwindows
argument_list|(
name|w1
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
name|Unmap_window_main
argument_list|(
name|w1
argument_list|,
name|cleanup
operator|^
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TRUE
argument_list|(
name|destroy
argument_list|)
operator|&&
name|w1
operator|->
name|first_child
condition|)
name|Zap_subwindows
argument_list|(
name|w1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|w1
operator|->
name|should_be_mapped
operator|=
literal|0
expr_stmt|;
block|}
if|if TRUE
condition|(
name|destroy
condition|)
block|{
while|while
condition|(
name|w1
operator|=
name|w
operator|->
name|first_child
condition|)
name|Free_resource
argument_list|(
name|Resources
index|[
name|RESIDX
argument_list|(
name|w1
operator|->
name|rid
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cn
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|vn
operator|==
literal|0
operator|&&
name|cn
operator|>
literal|2
condition|)
block|{
name|Free_rectangles
argument_list|(
name|rlist
argument_list|)
expr_stmt|;
for|for
control|(
name|rlist
operator|=
name|w
operator|->
name|cmvisible
init|;
name|rlist
condition|;
name|rlist
operator|=
name|rlist
operator|->
name|next
control|)
block|{
name|RASTRECT
argument_list|(
name|rec
argument_list|,
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|rlist
argument_list|,
name|new_rec
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|rec
expr_stmt|;
name|prev
operator|=
operator|&
name|rec
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|->
name|cmvisible
operator|->
name|next
operator|==
name|NULL
operator|&&
operator|(
name|cn
operator|>>
literal|3
operator|)
operator|>
name|vn
condition|)
block|{
name|Free_rectangles
argument_list|(
name|rlist
argument_list|)
expr_stmt|;
name|RASTRECT
argument_list|(
name|rec
argument_list|,
operator|*
operator|(
name|RASTER
operator|*
operator|)
name|w
operator|->
name|cmvisible
argument_list|,
name|new_rec
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|rec
expr_stmt|;
name|rec
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rec
operator|=
name|w
operator|->
name|visible
init|;
condition|;
name|rec
operator|=
name|rec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rec
operator|->
name|type
operator|!=
name|border_rec
condition|)
name|Calc_overlaps
argument_list|(
operator|(
name|RASTER
operator|*
operator|)
name|rec
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
operator|&
name|rec
operator|->
name|next
condition|)
break|break;
block|}
block|}
else|else
name|Merge_rectangles
argument_list|(
name|rlist
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|cleanup
condition|)
block|{
name|Do_background
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Stash_changes
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Unmap all subwindows, discarding their rectangles.  Destroy the subwindows  * if destroy flag is set.  */
end_comment

begin_expr_stmt
name|Zap_subwindows
argument_list|(
name|w
argument_list|,
name|destroy
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|destroy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
decl_stmt|;
for|for
control|(
name|w1
operator|=
name|w
operator|->
name|first_child
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|next_sib
control|)
block|{
if|if TRUE
condition|(
name|w1
operator|->
name|mapped
condition|)
block|{
if|if
condition|(
name|w1
operator|->
name|visible
condition|)
block|{
name|Free_rectangles
argument_list|(
name|w1
operator|->
name|visible
argument_list|)
expr_stmt|;
name|w1
operator|->
name|visible
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|w1
operator|->
name|cmvisible
condition|)
block|{
name|Free_rectangles
argument_list|(
name|w1
operator|->
name|cmvisible
argument_list|)
expr_stmt|;
name|w1
operator|->
name|cmvisible
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|w1
operator|->
name|first_child
condition|)
name|Zap_subwindows
argument_list|(
name|w1
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
name|Unmap_window_main
argument_list|(
name|w1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if TRUE
condition|(
name|destroy
condition|)
block|{
while|while
condition|(
name|w1
operator|=
name|w
operator|->
name|first_child
condition|)
name|Free_resource
argument_list|(
name|Resources
index|[
name|RESIDX
argument_list|(
name|w1
operator|->
name|rid
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Change the x-y coordinates of a window */
end_comment

begin_expr_stmt
name|Move_window
argument_list|(
name|w
argument_list|,
name|new_x
argument_list|,
name|new_y
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|new_x
decl_stmt|,
name|new_y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|deltax
decl_stmt|,
name|deltay
decl_stmt|;
specifier|register
name|WINDOW
modifier|*
name|w1
init|=
name|NULL
decl_stmt|;
specifier|register
name|RECTANGLE
modifier|*
name|r
decl_stmt|;
specifier|register
name|WINDOW
modifier|*
name|head
decl_stmt|;
specifier|register
name|RECTANGLE
modifier|*
name|cr
decl_stmt|;
name|RECTANGLE
modifier|*
name|vlist
decl_stmt|;
name|WINDOW
modifier|*
name|tail
decl_stmt|;
name|int
name|unobscured
init|=
name|OB_NOT
decl_stmt|;
name|deltax
operator|=
name|new_x
operator|-
operator|(
name|w
operator|->
name|full
operator|.
name|left
operator|-
name|w
operator|->
name|bwidth
operator|)
expr_stmt|;
name|deltay
operator|=
name|new_y
operator|-
operator|(
name|w
operator|->
name|full
operator|.
name|top
operator|-
name|w
operator|->
name|bwidth
operator|)
expr_stmt|;
if|if TRUE
condition|(
name|w
operator|->
name|mapped
condition|)
block|{
name|MBOX
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|deltax
operator|+=
name|w
operator|->
name|parent
operator|->
name|full
operator|.
name|left
expr_stmt|;
name|deltay
operator|+=
name|w
operator|->
name|parent
operator|->
name|full
operator|.
name|top
expr_stmt|;
comment|/* Check if all visible */
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|tilemode
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|w
operator|->
name|cmvisible
operator|)
operator|&&
name|r
operator|->
name|next
operator|==
name|NULL
operator|&&
name|r
operator|->
name|left
operator|==
name|w
operator|->
name|full
operator|.
name|left
operator|&&
name|r
operator|->
name|top
operator|==
name|w
operator|->
name|full
operator|.
name|top
operator|&&
name|r
operator|->
name|right
operator|==
name|w
operator|->
name|full
operator|.
name|right
operator|&&
name|r
operator|->
name|bottom
operator|==
name|w
operator|->
name|full
operator|.
name|bottom
condition|)
name|unobscured
operator|=
name|OB_YES
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|first_child
condition|)
block|{
if|if TRUE
condition|(
name|unobscured
condition|)
block|{
comment|/* Find earliest mapped subwindow */
name|w1
operator|=
name|w
expr_stmt|;
do|do
block|{
name|head
operator|=
name|w1
expr_stmt|;
for|for
control|(
name|w1
operator|=
name|head
operator|->
name|last_child
init|;
name|w1
operator|&&
name|FALSE
argument_list|(
name|w1
operator|->
name|mapped
argument_list|)
condition|;
name|w1
operator|=
name|w1
operator|->
name|prev_sib
control|)
empty_stmt|;
block|}
do|while
condition|(
name|w1
condition|)
do|;
if|if
condition|(
name|head
operator|!=
name|w
condition|)
block|{
name|tail
operator|=
name|w
operator|->
name|prev
expr_stmt|;
comment|/* Remove all subwindows from list */
if|if
condition|(
name|w
operator|->
name|prev
operator|=
name|head
operator|->
name|prev
condition|)
name|head
operator|->
name|prev
operator|->
name|next
operator|=
name|w
expr_stmt|;
else|else
name|mapped_list
operator|=
name|w
expr_stmt|;
comment|/* Extract visible insides */
name|vlist
operator|=
name|NULL
expr_stmt|;
name|cr
operator|=
name|w
operator|->
name|visible
expr_stmt|;
name|w
operator|->
name|visible
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|r
operator|=
name|cr
condition|)
block|{
name|cr
operator|=
name|r
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|border_rec
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|w
operator|->
name|visible
expr_stmt|;
name|w
operator|->
name|visible
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|left
operator|+=
name|deltax
expr_stmt|;
name|r
operator|->
name|right
operator|+=
name|deltax
expr_stmt|;
name|r
operator|->
name|top
operator|+=
name|deltay
expr_stmt|;
name|r
operator|->
name|bottom
operator|+=
name|deltay
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|vlist
expr_stmt|;
name|vlist
operator|=
name|r
expr_stmt|;
block|}
block|}
name|Restore_rectangles
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Zap_subwindows
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Restore_rectangles
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
name|w1
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|Unmap_window_main
argument_list|(
name|w
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|full
operator|.
name|left
operator|+=
name|deltax
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|right
operator|+=
name|deltax
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|top
operator|+=
name|deltay
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|bottom
operator|+=
name|deltay
expr_stmt|;
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|should_be_mapped
argument_list|)
operator|||
name|FALSE
argument_list|(
name|w
operator|->
name|parent
operator|->
name|mapped
argument_list|)
condition|)
return|return;
name|Map_window_main
argument_list|(
name|w
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MBOX
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|first_child
condition|)
block|{
if|if FALSE
condition|(
name|unobscured
condition|)
name|Map_subwindows
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|!=
name|w
condition|)
block|{
comment|/* Reinsert subwindows */
if|if
condition|(
name|head
operator|->
name|prev
operator|=
name|w
operator|->
name|prev
condition|)
name|w
operator|->
name|prev
operator|->
name|next
operator|=
name|head
expr_stmt|;
else|else
name|mapped_list
operator|=
name|head
expr_stmt|;
name|tail
operator|->
name|next
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|prev
operator|=
name|tail
expr_stmt|;
comment|/* Check if still all visible */
if|if
condition|(
operator|(
name|r
operator|=
name|w
operator|->
name|cmvisible
operator|)
operator|&&
name|r
operator|->
name|next
operator|==
name|NULL
operator|&&
name|r
operator|->
name|left
operator|==
name|w
operator|->
name|full
operator|.
name|left
operator|&&
name|r
operator|->
name|top
operator|==
name|w
operator|->
name|full
operator|.
name|top
operator|&&
name|r
operator|->
name|right
operator|==
name|w
operator|->
name|full
operator|.
name|right
operator|&&
name|r
operator|->
name|bottom
operator|==
name|w
operator|->
name|full
operator|.
name|bottom
condition|)
block|{
name|unobscured
operator|=
name|OB_TMP
expr_stmt|;
comment|/* Move all subwindows */
do|do
block|{
name|tail
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|head
operator|->
name|full
operator|.
name|left
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|full
operator|.
name|right
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|full
operator|.
name|top
operator|+=
name|deltay
expr_stmt|;
name|head
operator|->
name|full
operator|.
name|bottom
operator|+=
name|deltay
expr_stmt|;
name|head
operator|->
name|vs
operator|.
name|left
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|vs
operator|.
name|right
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|vs
operator|.
name|top
operator|+=
name|deltay
expr_stmt|;
name|head
operator|->
name|vs
operator|.
name|bottom
operator|+=
name|deltay
expr_stmt|;
name|head
operator|->
name|ovs
operator|.
name|left
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|ovs
operator|.
name|right
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|ovs
operator|.
name|top
operator|+=
name|deltay
expr_stmt|;
name|head
operator|->
name|ovs
operator|.
name|bottom
operator|+=
name|deltay
expr_stmt|;
name|head
operator|->
name|clip
operator|.
name|left
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|clip
operator|.
name|top
operator|+=
name|deltay
expr_stmt|;
for|for
control|(
name|r
operator|=
name|head
operator|->
name|visible
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|r
operator|->
name|left
operator|+=
name|deltax
expr_stmt|;
name|r
operator|->
name|right
operator|+=
name|deltax
expr_stmt|;
name|r
operator|->
name|top
operator|+=
name|deltay
expr_stmt|;
name|r
operator|->
name|bottom
operator|+=
name|deltay
expr_stmt|;
block|}
for|for
control|(
name|r
operator|=
name|head
operator|->
name|cmvisible
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|r
operator|->
name|left
operator|+=
name|deltax
expr_stmt|;
name|r
operator|->
name|right
operator|+=
name|deltax
expr_stmt|;
name|r
operator|->
name|top
operator|+=
name|deltay
expr_stmt|;
name|r
operator|->
name|bottom
operator|+=
name|deltay
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|head
operator|=
name|tail
operator|)
operator|!=
name|w
condition|)
do|;
name|cr
operator|=
name|w
operator|->
name|visible
expr_stmt|;
while|while
condition|(
name|r
operator|=
name|cr
condition|)
block|{
name|cr
operator|=
name|r
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|type
operator|==
name|border_rec
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|vlist
expr_stmt|;
name|vlist
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|FREERECT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|w
operator|->
name|visible
operator|=
name|vlist
expr_stmt|;
block|}
else|else
block|{
comment|/* Unmap all subwindows and move children */
do|do
block|{
name|tail
operator|=
name|head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|visible
condition|)
block|{
name|Free_rectangles
argument_list|(
name|head
operator|->
name|visible
argument_list|)
expr_stmt|;
name|head
operator|->
name|visible
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|->
name|cmvisible
condition|)
block|{
name|Free_rectangles
argument_list|(
name|head
operator|->
name|cmvisible
argument_list|)
expr_stmt|;
name|head
operator|->
name|cmvisible
operator|=
name|NULL
expr_stmt|;
block|}
name|Unmap_window_main
argument_list|(
name|head
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|parent
operator|==
name|w
condition|)
block|{
name|head
operator|->
name|full
operator|.
name|left
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|full
operator|.
name|right
operator|+=
name|deltax
expr_stmt|;
name|head
operator|->
name|full
operator|.
name|top
operator|+=
name|deltay
expr_stmt|;
name|head
operator|->
name|full
operator|.
name|bottom
operator|+=
name|deltay
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|head
operator|=
name|tail
operator|)
operator|!=
name|w
condition|)
do|;
if|if
condition|(
name|vlist
condition|)
name|Free_rectangles
argument_list|(
name|vlist
argument_list|)
expr_stmt|;
comment|/* Remap all subwindows */
name|Map_subwindows
argument_list|(
name|w
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if TRUE
condition|(
name|unobscured
condition|)
name|Do_refill
argument_list|(
name|w
argument_list|,
name|deltax
argument_list|,
name|deltay
argument_list|)
expr_stmt|;
else|else
name|Draw_window
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|w1
operator|->
name|unobscured
operator|==
name|OB_TMP
condition|)
block|{
name|w1
operator|->
name|unobscured
operator|=
name|OB_NOT
expr_stmt|;
name|Draw_window
argument_list|(
name|w1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Change the size and position of a window. */
end_comment

begin_expr_stmt
name|Change_window
argument_list|(
name|w
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|height
decl_stmt|,
name|width
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|height
operator|<=
literal|0
operator|||
name|width
operator|<=
literal|0
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
if|if TRUE
condition|(
name|w
operator|->
name|mapped
condition|)
block|{
name|w1
operator|=
name|Unmap_window
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|w
operator|->
name|should_be_mapped
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|-=
name|w
operator|->
name|full
operator|.
name|left
operator|-
name|w
operator|->
name|bwidth
expr_stmt|;
name|y
operator|-=
name|w
operator|->
name|full
operator|.
name|top
operator|-
name|w
operator|->
name|bwidth
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|left
operator|+=
name|x
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|top
operator|+=
name|y
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|right
operator|=
name|w
operator|->
name|full
operator|.
name|left
operator|+
name|width
expr_stmt|;
name|w
operator|->
name|full
operator|.
name|bottom
operator|=
name|w
operator|->
name|full
operator|.
name|top
operator|+
name|height
expr_stmt|;
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|should_be_mapped
argument_list|)
operator|||
name|FALSE
argument_list|(
name|w
operator|->
name|parent
operator|->
name|mapped
argument_list|)
condition|)
return|return;
name|Map_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|w1
operator|->
name|unobscured
operator|==
name|OB_TMP
condition|)
block|{
name|w1
operator|->
name|unobscured
operator|=
name|OB_NOT
expr_stmt|;
name|Draw_window
argument_list|(
name|w1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Change the background tile of a window */
end_comment

begin_expr_stmt
name|Change_background
argument_list|(
name|w
argument_list|,
name|tile
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|PIXMAP
modifier|*
name|tile
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|w
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
block|{
name|Xstatus
operator|=
name|BadMatch
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|tile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|parent
condition|)
name|tile
operator|=
name|w
operator|->
name|parent
operator|->
name|tile
expr_stmt|;
else|else
name|tile
operator|=
name|roottile
expr_stmt|;
block|}
elseif|else
if|if FALSE
condition|(
name|tile
operator|->
name|tile
condition|)
block|{
name|Xstatus
operator|=
name|BadTile
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tile
operator|!=
name|w
operator|->
name|tile
condition|)
block|{
name|tile
operator|->
name|refcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|w
operator|->
name|tile
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreePixmap
argument_list|(
name|w
operator|->
name|tile
argument_list|)
expr_stmt|;
name|w
operator|->
name|tile
operator|=
name|tile
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Change the border tile of a window. */
end_comment

begin_expr_stmt
name|Change_border
argument_list|(
name|w
argument_list|,
name|tile
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|PIXMAP
modifier|*
name|tile
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|w
operator|->
name|bwidth
operator|==
literal|0
condition|)
block|{
name|Xstatus
operator|=
name|BadMatch
expr_stmt|;
return|return;
block|}
elseif|else
if|if FALSE
condition|(
name|tile
operator|->
name|tile
condition|)
block|{
name|Xstatus
operator|=
name|BadTile
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tile
operator|!=
name|w
operator|->
name|border
condition|)
block|{
name|tile
operator|->
name|refcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|w
operator|->
name|border
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreePixmap
argument_list|(
name|w
operator|->
name|border
argument_list|)
expr_stmt|;
name|w
operator|->
name|border
operator|=
name|tile
expr_stmt|;
name|Do_border
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move a window to the top of (depthwise) the screen. */
end_comment

begin_expr_stmt
name|Raise_window
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|ww
decl_stmt|,
modifier|*
name|nw
decl_stmt|;
name|int
name|changed
decl_stmt|;
comment|/* Check if we're already on top. */
if|if
condition|(
name|w
operator|->
name|next_sib
operator|==
name|NULL
condition|)
return|return;
comment|/* If w is unmapped, simply put it on top. */
if|if FALSE
condition|(
name|w
operator|->
name|mapped
condition|)
block|{
name|Make_top_child
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
name|MBOX
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* If w is transparent, simply put it on top. */
if|if
condition|(
name|w
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
block|{
name|Make_top_child
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* Lower any of w's siblings that are above it. */
while|while
condition|(
name|ww
operator|=
name|w
operator|->
name|next_sib
condition|)
block|{
comment|/* move it over us */
if|if
condition|(
name|w
operator|->
name|next_sib
operator|=
name|ww
operator|->
name|next_sib
condition|)
name|ww
operator|->
name|next_sib
operator|->
name|prev_sib
operator|=
name|w
expr_stmt|;
else|else
name|w
operator|->
name|parent
operator|->
name|last_child
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|ww
operator|->
name|prev_sib
operator|=
name|w
operator|->
name|prev_sib
condition|)
name|w
operator|->
name|prev_sib
operator|->
name|next_sib
operator|=
name|ww
expr_stmt|;
else|else
name|w
operator|->
name|parent
operator|->
name|first_child
operator|=
name|ww
expr_stmt|;
name|w
operator|->
name|prev_sib
operator|=
name|ww
expr_stmt|;
name|ww
operator|->
name|next_sib
operator|=
name|w
expr_stmt|;
comment|/* If ww is unmapped, we're done. */
if|if FALSE
condition|(
name|ww
operator|->
name|mapped
condition|)
continue|continue;
comment|/* If ww is transparent or doesn't overlap, just reposition */
if|if
condition|(
name|ww
operator|->
name|kind
operator|==
name|IsTransparent
operator|||
name|ww
operator|->
name|ovs
operator|.
name|left
operator|>=
name|w
operator|->
name|ovs
operator|.
name|right
operator|||
name|w
operator|->
name|ovs
operator|.
name|left
operator|>=
name|ww
operator|->
name|ovs
operator|.
name|right
operator|||
name|ww
operator|->
name|ovs
operator|.
name|top
operator|>=
name|w
operator|->
name|ovs
operator|.
name|bottom
operator|||
name|w
operator|->
name|ovs
operator|.
name|top
operator|>=
name|ww
operator|->
name|ovs
operator|.
name|bottom
condition|)
block|{
comment|/* Find earliest mapped subwindow of ww */
do|do
block|{
name|nw
operator|=
name|ww
expr_stmt|;
for|for
control|(
name|ww
operator|=
name|nw
operator|->
name|last_child
init|;
name|ww
operator|&&
name|FALSE
argument_list|(
name|ww
operator|->
name|mapped
argument_list|)
condition|;
name|ww
operator|=
name|ww
operator|->
name|prev_sib
control|)
empty_stmt|;
block|}
do|while
condition|(
name|ww
condition|)
do|;
name|ww
operator|=
name|w
operator|->
name|prev_sib
expr_stmt|;
comment|/* Reposition in mapped_list just after w */
if|if
condition|(
name|ww
operator|->
name|next
operator|->
name|prev
operator|=
name|nw
operator|->
name|prev
condition|)
name|nw
operator|->
name|prev
operator|->
name|next
operator|=
name|ww
operator|->
name|next
expr_stmt|;
else|else
name|mapped_list
operator|=
name|ww
operator|->
name|next
expr_stmt|;
name|ww
operator|->
name|next
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|w
operator|->
name|next
operator|->
name|prev
operator|=
name|ww
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|nw
expr_stmt|;
name|nw
operator|->
name|prev
operator|=
name|w
expr_stmt|;
continue|continue;
block|}
name|changed
operator|=
literal|1
expr_stmt|;
comment|/* Unmap all the children of ww. */
if|if
condition|(
name|ww
operator|->
name|first_child
condition|)
name|Remove_subwindows
argument_list|(
name|ww
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove ww from its current position. */
name|nw
operator|=
name|ww
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|nw
operator|->
name|prev
operator|=
name|ww
operator|->
name|prev
condition|)
name|ww
operator|->
name|prev
operator|->
name|next
operator|=
name|nw
expr_stmt|;
else|else
name|mapped_list
operator|=
name|nw
expr_stmt|;
comment|/* Insert ww just after w. */
name|ww
operator|->
name|next
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|w
operator|->
name|next
operator|->
name|prev
operator|=
name|ww
expr_stmt|;
name|ww
operator|->
name|prev
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|ww
expr_stmt|;
comment|/* Remove the rectangles from ww as appropriate */
name|Remove_rectangles
argument_list|(
name|ww
argument_list|,
name|nw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Remap the children without redrawing */
if|if
condition|(
name|ww
operator|->
name|first_child
condition|)
name|Map_subwindows
argument_list|(
name|ww
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if TRUE
condition|(
name|changed
condition|)
name|Draw_window
argument_list|(
name|w
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move a window to the bottom of the screen. */
end_comment

begin_expr_stmt
name|Lower_window
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|ww
decl_stmt|,
modifier|*
name|nw
decl_stmt|;
comment|/* Check if we're already on bottom. */
if|if
condition|(
operator|(
name|ww
operator|=
name|w
operator|->
name|prev_sib
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* If w is unmapped or all higher siblings are unmapped, simply 	 * put it on the bottom. 	 */
if|if
condition|(
name|FALSE
argument_list|(
name|w
operator|->
name|mapped
argument_list|)
operator|||
name|w
operator|->
name|next
operator|==
name|w
operator|->
name|parent
condition|)
block|{
name|Make_bottom_child
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
name|MBOX
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* If w is transparent, simply put it on the bottom. * 	if (w->kind == IsTransparent) { 	    Make_bottom_child (w); 	    return; 	}  	/* See if w obscures any lower opaque window. */
while|while
condition|(
name|FALSE
argument_list|(
name|ww
operator|->
name|mapped
argument_list|)
operator|||
name|ww
operator|->
name|kind
operator|==
name|IsTransparent
operator|||
name|ww
operator|->
name|ovs
operator|.
name|left
operator|>=
name|w
operator|->
name|ovs
operator|.
name|right
operator|||
name|w
operator|->
name|ovs
operator|.
name|left
operator|>=
name|ww
operator|->
name|ovs
operator|.
name|right
operator|||
name|ww
operator|->
name|ovs
operator|.
name|top
operator|>=
name|w
operator|->
name|ovs
operator|.
name|bottom
operator|||
name|w
operator|->
name|ovs
operator|.
name|top
operator|>=
name|ww
operator|->
name|ovs
operator|.
name|bottom
condition|)
block|{
if|if
condition|(
operator|(
name|ww
operator|=
name|ww
operator|->
name|prev_sib
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Move w to be the first child of its parent. */
name|Make_bottom_child
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|ww
operator|==
name|NULL
condition|)
block|{
comment|/* w doesn't obscure anything, find earliest mapped subwindow */
name|ww
operator|=
name|w
expr_stmt|;
do|do
block|{
name|nw
operator|=
name|ww
expr_stmt|;
for|for
control|(
name|ww
operator|=
name|nw
operator|->
name|last_child
init|;
name|ww
operator|&&
name|FALSE
argument_list|(
name|ww
operator|->
name|mapped
argument_list|)
condition|;
name|ww
operator|=
name|ww
operator|->
name|prev_sib
control|)
empty_stmt|;
block|}
do|while
condition|(
name|ww
condition|)
do|;
comment|/* Reposition in mapped_list just before parent */
if|if
condition|(
name|w
operator|->
name|next
operator|->
name|prev
operator|=
name|nw
operator|->
name|prev
condition|)
name|nw
operator|->
name|prev
operator|->
name|next
operator|=
name|w
operator|->
name|next
expr_stmt|;
else|else
name|mapped_list
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|ww
operator|=
name|w
operator|->
name|parent
expr_stmt|;
name|ww
operator|->
name|prev
operator|->
name|next
operator|=
name|nw
expr_stmt|;
name|nw
operator|->
name|prev
operator|=
name|ww
operator|->
name|prev
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|ww
expr_stmt|;
name|ww
operator|->
name|prev
operator|=
name|w
expr_stmt|;
return|return;
block|}
comment|/* w obscures something, unmap all the children. */
if|if
condition|(
name|w
operator|->
name|first_child
condition|)
name|Remove_subwindows
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove w from its current position. */
if|if
condition|(
name|w
operator|->
name|next
operator|->
name|prev
operator|=
name|w
operator|->
name|prev
condition|)
name|w
operator|->
name|prev
operator|->
name|next
operator|=
name|w
operator|->
name|next
expr_stmt|;
else|else
name|mapped_list
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|nw
operator|=
name|w
operator|->
name|next
expr_stmt|;
comment|/* Put w just in front of its parent.  The parent cannot be 	 * right after w, because we already checked for that. 	 */
name|ww
operator|=
name|w
operator|->
name|parent
expr_stmt|;
name|w
operator|->
name|prev
operator|=
name|ww
operator|->
name|prev
expr_stmt|;
name|ww
operator|->
name|prev
operator|->
name|next
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|ww
expr_stmt|;
name|ww
operator|->
name|prev
operator|=
name|w
expr_stmt|;
comment|/* Remove the rectangles from w as appropriate */
name|Remove_rectangles
argument_list|(
name|w
argument_list|,
name|nw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Remap the children */
if|if
condition|(
name|w
operator|->
name|first_child
condition|)
name|Map_subwindows
argument_list|(
name|w
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Raise the lowest mapped subwindow obscured by another subwindow. */
end_comment

begin_expr_stmt
name|Circulate_window_up
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
for|for
control|(
name|w
operator|=
name|w
operator|->
name|first_child
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|next_sib
control|)
block|{
if|if FALSE
condition|(
name|w
operator|->
name|should_be_mapped
condition|)
continue|continue;
for|for
control|(
name|ow
operator|=
name|w
operator|->
name|next_sib
init|;
name|ow
condition|;
name|ow
operator|=
name|ow
operator|->
name|next_sib
control|)
block|{
if|if
condition|(
name|FALSE
argument_list|(
name|ow
operator|->
name|should_be_mapped
argument_list|)
operator|||
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
operator|||
name|ow
operator|->
name|ovs
operator|.
name|left
operator|>=
name|w
operator|->
name|ovs
operator|.
name|right
operator|||
name|w
operator|->
name|ovs
operator|.
name|left
operator|>=
name|ow
operator|->
name|ovs
operator|.
name|right
operator|||
name|ow
operator|->
name|ovs
operator|.
name|top
operator|>=
name|w
operator|->
name|ovs
operator|.
name|bottom
operator|||
name|w
operator|->
name|ovs
operator|.
name|top
operator|>=
name|ow
operator|->
name|ovs
operator|.
name|bottom
condition|)
continue|continue;
name|Raise_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Lower the highest mapped subwindow obscuring another subwindow. */
end_comment

begin_expr_stmt
name|Circulate_window_down
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|ow
decl_stmt|;
for|for
control|(
name|w
operator|=
name|w
operator|->
name|last_child
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|prev_sib
control|)
block|{
if|if FALSE
condition|(
name|w
operator|->
name|should_be_mapped
condition|)
continue|continue;
for|for
control|(
name|ow
operator|=
name|w
operator|->
name|prev_sib
init|;
name|ow
condition|;
name|ow
operator|=
name|ow
operator|->
name|prev_sib
control|)
block|{
if|if
condition|(
name|FALSE
argument_list|(
name|ow
operator|->
name|should_be_mapped
argument_list|)
operator|||
name|ow
operator|->
name|kind
operator|==
name|IsTransparent
operator|||
name|ow
operator|->
name|ovs
operator|.
name|left
operator|>=
name|w
operator|->
name|ovs
operator|.
name|right
operator|||
name|w
operator|->
name|ovs
operator|.
name|left
operator|>=
name|ow
operator|->
name|ovs
operator|.
name|right
operator|||
name|ow
operator|->
name|ovs
operator|.
name|top
operator|>=
name|w
operator|->
name|ovs
operator|.
name|bottom
operator|||
name|w
operator|->
name|ovs
operator|.
name|top
operator|>=
name|ow
operator|->
name|ovs
operator|.
name|bottom
condition|)
continue|continue;
name|Lower_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Make w the last sibling of its parent, making it top-most */
end_comment

begin_expr_stmt
name|Make_top_child
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
init|=
name|w
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|prev_sib
condition|)
name|w
operator|->
name|prev_sib
operator|->
name|next_sib
operator|=
name|w
operator|->
name|next_sib
expr_stmt|;
else|else
name|w1
operator|->
name|first_child
operator|=
name|w
operator|->
name|next_sib
expr_stmt|;
name|w
operator|->
name|next_sib
operator|->
name|prev_sib
operator|=
name|w
operator|->
name|prev_sib
expr_stmt|;
name|w1
operator|->
name|last_child
operator|->
name|next_sib
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|prev_sib
operator|=
name|w1
operator|->
name|last_child
expr_stmt|;
name|w1
operator|->
name|last_child
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|next_sib
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make w the first sibling of its parent, making it bottom-most */
end_comment

begin_expr_stmt
name|Make_bottom_child
argument_list|(
name|w
argument_list|)
specifier|register
name|WINDOW
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
init|=
name|w
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|next_sib
condition|)
name|w
operator|->
name|next_sib
operator|->
name|prev_sib
operator|=
name|w
operator|->
name|prev_sib
expr_stmt|;
else|else
name|w1
operator|->
name|last_child
operator|=
name|w
operator|->
name|prev_sib
expr_stmt|;
name|w
operator|->
name|prev_sib
operator|->
name|next_sib
operator|=
name|w
operator|->
name|next_sib
expr_stmt|;
name|w1
operator|->
name|first_child
operator|->
name|prev_sib
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|next_sib
operator|=
name|w1
operator|->
name|first_child
expr_stmt|;
name|w1
operator|->
name|first_child
operator|=
name|w
expr_stmt|;
name|w
operator|->
name|prev_sib
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Draw_window draws a window of the appropriate type.  If subflag is    set, it also redisplays the windows subwindows.  If not_just_new    is set, all the rectangles are redisplayed, not just the new ones.    If not, after the new rectangles have been displayed they are    changed to old ones and the window is Windexed. */
end_comment

begin_macro
name|Draw_window
argument_list|(
argument|w
argument_list|,
argument|subflag
argument_list|,
argument|not_just_new
argument_list|)
end_macro

begin_decl_stmt
name|WINDOW
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|subflag
decl_stmt|,
name|not_just_new
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w1
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|kind
operator|==
name|IsTransparent
condition|)
return|return;
if|if
condition|(
name|w
operator|->
name|bwidth
condition|)
name|Do_border
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|Do_background
argument_list|(
name|w
argument_list|,
name|not_just_new
argument_list|)
expr_stmt|;
if|if TRUE
condition|(
name|subflag
condition|)
block|{
for|for
control|(
name|w1
operator|=
name|w
operator|->
name|first_child
init|;
name|w1
condition|;
name|w1
operator|=
name|w1
operator|->
name|next_sib
control|)
block|{
if|if TRUE
condition|(
name|w1
operator|->
name|mapped
condition|)
name|Draw_window
argument_list|(
name|w1
argument_list|,
literal|1
argument_list|,
name|not_just_new
argument_list|)
expr_stmt|;
block|}
block|}
name|Stash_changes
argument_list|(
name|w
argument_list|,
name|not_just_new
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Windex recomputes if the window is obscured. */
end_comment

begin_macro
name|Windex
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|WINDOW
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|r1
decl_stmt|;
for|for
control|(
name|r1
operator|=
name|w
operator|->
name|visible
init|;
name|r1
condition|;
name|r1
operator|=
name|r1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r1
operator|->
name|type
operator|==
name|border_rec
condition|)
continue|continue;
if|if
condition|(
name|r1
operator|->
name|type
operator|==
name|contents_rec
operator|&&
name|r1
operator|->
name|left
operator|==
name|w
operator|->
name|vs
operator|.
name|left
operator|&&
name|r1
operator|->
name|top
operator|==
name|w
operator|->
name|vs
operator|.
name|top
operator|&&
name|r1
operator|->
name|right
operator|==
name|w
operator|->
name|vs
operator|.
name|right
operator|&&
name|r1
operator|->
name|bottom
operator|==
name|w
operator|->
name|vs
operator|.
name|bottom
condition|)
name|w
operator|->
name|unobscured
operator|=
name|OB_YES
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/* Free all storage associated with unused windows */
end_comment

begin_macro
name|Free_window_storage
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|WINDOW
modifier|*
name|w
decl_stmt|,
modifier|*
modifier|*
name|pw
decl_stmt|;
comment|/* drop the "internal" windows */
name|pw
operator|=
operator|&
name|free_windows
expr_stmt|;
while|while
condition|(
name|w
operator|=
operator|*
name|pw
condition|)
block|{
if|if TRUE
condition|(
name|w
operator|->
name|internal
condition|)
operator|*
name|pw
operator|=
name|w
operator|->
name|next
expr_stmt|;
else|else
name|pw
operator|=
operator|&
name|w
operator|->
name|next
expr_stmt|;
block|}
comment|/* now free the "head" windows */
while|while
condition|(
name|w
operator|=
name|free_windows
condition|)
block|{
name|free_windows
operator|=
name|w
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|w
argument_list|)
expr_stmt|;
block|}
name|FREERECT
argument_list|(
name|rootwindow
operator|->
name|visible
argument_list|)
expr_stmt|;
name|FREERECT
argument_list|(
name|rootwindow
operator|->
name|cmvisible
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

