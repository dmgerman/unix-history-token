begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: XMenuActivate.c,v 10.16 86/02/01 16:14:11 tony Rel $ */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_comment
comment|/*  * XMenu:	MIT Project Athena, X Window system menu package  *  *	XMenuActivate -	Maps a given menu to the display and activates  *			the menu for user selection.  The user is allowed to  *			specify which pane and selection will be current,  *			the X and Y location of the menu (relative to the  *			parent window) and the mouse button event mask that  *			will be used to identify a selection request.  *  *			A menu selection is shown to be current by placing  *			a highlight box around the selection as the mouse  *			cursor enters its active region.  Inactive selections  *			will not be highlited.	As the mouse cursor moved  *			from one menu pane to another menu pane the pane being  *			entered is raised and made current and the pane being  *			left is lowered.  *  *			Anytime XMenuActivate returns, the p_num and  *			s_num are left at their last known values (i.e.,  *			the last known current pane and selection indices).  *			The following are the defined return states:  *  *			1)	If at any time an error occurs the data  *				pointer is left untouched and XM_FAILURE  *				is returned.    *  *			2)	When a selection request is recieved (i.e.,  *				when the specified mouse event occurs) the  *				data pointer will be set to the data  *				associated with the particular selection  *				current at the time of the selection request  *				and XM_SUCCESS is returned.  *  *			3)	If no selection was current at the time a  *				selection request is made the data pointer  *				will be left untouched and XM_NO_SELECT will  *				be returned.  *  *			4)	If the selection that was current at the time   *				a selection request is made is not an active  *				selection the data pointer will be left  *				untouched and XM_IA_SELECT will be returned.  *  *	Author:		Tony Della Fera, DEC  *			January 13, 1986  *  */
end_comment

begin_include
include|#
directive|include
file|"XMenuInternal.h"
end_include

begin_function
name|int
name|XMenuActivate
parameter_list|(
name|menu
parameter_list|,
name|p_num
parameter_list|,
name|s_num
parameter_list|,
name|x_pos
parameter_list|,
name|y_pos
parameter_list|,
name|event_mask
parameter_list|,
name|data
parameter_list|)
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu to activate. */
name|int
modifier|*
name|p_num
decl_stmt|;
comment|/* Pane number selected. */
name|int
modifier|*
name|s_num
decl_stmt|;
comment|/* Selection number selected. */
name|int
name|x_pos
decl_stmt|;
comment|/* X coordinate of menu position. */
name|int
name|y_pos
decl_stmt|;
comment|/* Y coordinate of menu position. */
name|int
name|event_mask
decl_stmt|;
comment|/* Mouse button event mask. */
name|char
modifier|*
modifier|*
name|data
decl_stmt|;
comment|/* Pointer to return data value. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
name|int
name|status
decl_stmt|;
comment|/* X routine call status. */
name|int
name|orig_x
decl_stmt|;
comment|/* Upper left menu origin X coord. */
name|int
name|orig_y
decl_stmt|;
comment|/* Upper left menu origin Y coord. */
name|int
name|save_x
decl_stmt|;
comment|/* Upper left X of save region. */
name|int
name|save_y
decl_stmt|;
comment|/* Upper left Y of save region. */
name|int
name|save_w
decl_stmt|;
comment|/* Width of pixmap save region. */
name|int
name|save_h
decl_stmt|;
comment|/* Height of pixmap save region. */
name|int
name|save_w_offscr
decl_stmt|;
comment|/* Pixmap save width off screen. */
name|int
name|save_h_offscr
decl_stmt|;
comment|/* Pixmap save height off screen. */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Dummy X and Y arguments. */
name|int
name|ret_val
decl_stmt|;
comment|/* Return value. */
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* Current XMPane. */
specifier|register
name|XMPane
modifier|*
name|event_xmp
decl_stmt|;
comment|/* Event XMPane pointer. */
specifier|register
name|XMPane
modifier|*
name|cur_p
decl_stmt|;
comment|/* Current pane. */
specifier|register
name|XMSelect
modifier|*
name|cur_s
decl_stmt|;
comment|/* Current selection. */
name|XMWindow
modifier|*
name|event_xmw
decl_stmt|;
comment|/* Event XMWindow pointer. */
name|XEvent
name|event
decl_stmt|;
comment|/* X input event. */
name|XCrossingEvent
modifier|*
name|xc_event
decl_stmt|;
comment|/* X window crossing event. */
name|Window
name|xc_window
decl_stmt|;
comment|/* X window crossing event window. */
name|Pixmap
name|save_pixmap
decl_stmt|;
comment|/* Pixmap to save bits under menu. */
name|Bool
name|saved
init|=
name|TRUE
decl_stmt|;
comment|/* Pixmap save succeeded. */
name|Bool
name|selection
init|=
name|FALSE
decl_stmt|;
comment|/* Selection has been made. */
name|Bool
name|forward
init|=
name|TRUE
decl_stmt|;
comment|/* Moving forward in the pane list. */
name|Bool
name|p_lock
init|=
name|TRUE
decl_stmt|;
comment|/* Pane entrance lock. */
name|Bool
name|s_lock
init|=
name|TRUE
decl_stmt|;
comment|/* Selection entrance lock. */
comment|/*      * Are the position arguments are positive?      */
if|if
condition|(
operator|(
name|x_pos
operator|<=
literal|0
operator|)
operator|||
operator|(
name|y_pos
operator|<=
literal|0
operator|)
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_ARG_BOUNDS
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
comment|/*      * If there are no panes in the menu then return failure      * beacuse the menu is not initialized.      */
if|if
condition|(
name|menu
operator|->
name|p_count
operator|==
literal|0
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_NOT_INIT
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
comment|/*      * Find the desired current pane.      */
name|cur_p
operator|=
name|_XMGetPanePtr
argument_list|(
name|menu
argument_list|,
operator|*
name|p_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_p
operator|==
name|NULL
condition|)
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
comment|/*      * Find the desired current selection.      */
name|cur_s
operator|=
name|_XMGetSelectionPtr
argument_list|(
name|cur_p
argument_list|,
operator|*
name|s_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_s
operator|==
name|NULL
condition|)
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
comment|/*      * Check to see that the menu's dependencies have been      * recomputed and are up to date.  If not, do it now.      */
if|if
condition|(
name|menu
operator|->
name|recompute
condition|)
name|XMenuRecompute
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/*      * If the current pane is active then activate it.      */
if|if
condition|(
name|cur_p
operator|->
name|active
condition|)
block|{
name|cur_p
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
name|XChangeBackground
argument_list|(
name|cur_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|bkgnd_pixmap
argument_list|)
expr_stmt|;
block|}
comment|/*      * Compute the new menu origin such that the cursor hot point lies      * in the center of the desired current pane and selection.      */
name|_XMTransToOrigin
argument_list|(
name|menu
argument_list|,
name|cur_p
argument_list|,
name|cur_s
argument_list|,
name|x_pos
argument_list|,
name|y_pos
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
comment|/*      * Then move all the panes into position relative to the newly      * computed origin.      */
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
block|{
name|XMoveWindow
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|,
name|orig_x
operator|+
name|p_ptr
operator|->
name|window_x
argument_list|,
name|orig_y
operator|+
name|p_ptr
operator|->
name|window_y
argument_list|)
expr_stmt|;
block|}
comment|/*<      * If server freeze mode is selected...      */
if|if
condition|(
name|menu
operator|->
name|freeze
condition|)
block|{
comment|/* 	 * Compute pixmap save region. 	 */
name|save_x
operator|=
name|max
argument_list|(
name|orig_x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save_y
operator|=
name|max
argument_list|(
name|orig_y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|save_w_offscr
operator|=
operator|(
name|orig_x
operator|+
name|menu
operator|->
name|width
operator|)
operator|-
name|DisplayWidth
argument_list|()
expr_stmt|;
name|save_h_offscr
operator|=
operator|(
name|orig_y
operator|+
name|menu
operator|->
name|height
operator|)
operator|-
name|DisplayHeight
argument_list|()
expr_stmt|;
if|if
condition|(
name|save_w_offscr
operator|<
literal|0
condition|)
name|save_w
operator|=
name|menu
operator|->
name|width
expr_stmt|;
else|else
name|save_w
operator|=
name|menu
operator|->
name|width
operator|-
name|save_w_offscr
expr_stmt|;
if|if
condition|(
name|save_h_offscr
operator|<
literal|0
condition|)
name|save_h
operator|=
name|menu
operator|->
name|height
expr_stmt|;
else|else
name|save_h
operator|=
name|menu
operator|->
name|height
operator|-
name|save_h_offscr
expr_stmt|;
comment|/* 	 * Grab the X server. 	 */
name|XGrabServer
argument_list|()
expr_stmt|;
comment|/*  	 * Save the bits under where the menu will be. 	 */
name|save_pixmap
operator|=
name|XPixmapSave
argument_list|(
name|menu
operator|->
name|parent
argument_list|,
name|save_x
argument_list|,
name|save_y
argument_list|,
name|save_w
argument_list|,
name|save_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_pixmap
operator|==
name|_X_FAILURE
condition|)
name|saved
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|saved
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*      * Synchronize the X buffers and the event queue.      * From here on, all events in the queue that don't belong to      * XMenu are send back to the application via an application      * provided event handler or discarded if the application has      * not provided an event handler.      */
name|XSync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Grab the mouse for menu input.      */
name|status
operator|=
name|XGrabMouse
argument_list|(
name|menu
operator|->
name|parent
argument_list|,
name|menu
operator|->
name|mouse_cursor
argument_list|,
name|event_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|_X_FAILURE
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_GRAB_MOUSE
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
comment|/*      * Map the menu panes.      */
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|prev
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|p_ptr
operator|==
name|cur_p
condition|)
break|break;
name|XMapWindow
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p_ptr
operator|==
name|cur_p
condition|)
break|break;
name|XMapWindow
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
name|XMapWindow
argument_list|(
name|cur_p
operator|->
name|window
argument_list|)
expr_stmt|;
comment|/*      * Clear the current selection.      */
name|cur_s
operator|=
name|NULL
expr_stmt|;
comment|/*      * Begin event processing loop.      */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	 * Fetch the next event. 	 */
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
comment|/* 	 * Dispatch on the event type. 	 */
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
name|event_xmp
operator|=
operator|(
name|XMPane
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|_XMEventHandler
condition|)
call|(
modifier|*
name|_XMEventHandler
call|)
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|event_xmp
operator|==
name|cur_p
condition|)
block|{
name|_XMRefreshPane
argument_list|(
name|menu
argument_list|,
name|cur_p
argument_list|)
expr_stmt|;
block|}
else|else
name|_XMRefreshPaneText
argument_list|(
name|menu
argument_list|,
name|event_xmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|EnterWindow
case|:
name|event_xmw
operator|=
operator|(
name|XMWindow
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmw
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|event_xmw
operator|->
name|type
operator|==
name|SELECTION
condition|)
block|{
comment|/* 		     * We have entered a selection. 		     */
name|cur_s
operator|=
operator|(
name|XMSelect
operator|*
operator|)
name|event_xmw
expr_stmt|;
comment|/* 		     * If the pane we are in is active and the 		     * selection entered is active then activate 		     * the selection. 		     */
if|if
condition|(
name|cur_p
operator|->
name|active
operator|&&
name|cur_s
operator|->
name|active
condition|)
block|{
name|cur_s
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
name|_XMRefreshSelection
argument_list|(
name|menu
argument_list|,
name|cur_s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * We have entered a pane. 		     */
name|xc_event
operator|=
operator|(
name|XCrossingEvent
operator|*
operator|)
operator|&
name|event
expr_stmt|;
name|status
operator|=
name|XInterpretLocator
argument_list|(
name|menu
operator|->
name|parent
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|xc_window
argument_list|,
name|xc_event
operator|->
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|_X_FAILURE
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_INTERP_LOC
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
name|event_xmp
operator|=
operator|(
name|XMPane
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|menu
operator|->
name|assoc_tab
argument_list|,
name|xc_window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmp
operator|->
name|window
operator|==
name|cur_p
operator|->
name|window
condition|)
break|break;
if|if
condition|(
name|event_xmp
operator|->
name|serial
operator|>
name|cur_p
operator|->
name|serial
condition|)
name|forward
operator|=
name|TRUE
expr_stmt|;
else|else
name|forward
operator|=
name|FALSE
expr_stmt|;
name|p_ptr
operator|=
name|cur_p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|forward
condition|)
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
expr_stmt|;
else|else
name|p_ptr
operator|=
name|p_ptr
operator|->
name|prev
expr_stmt|;
comment|/* 			 * If the new pane is an active pane then 			 * activate it. 			 */
if|if
condition|(
name|p_ptr
operator|->
name|active
condition|)
block|{
name|p_ptr
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
name|XChangeBackground
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|,
name|menu
operator|->
name|bkgnd_pixmap
argument_list|)
expr_stmt|;
name|XClear
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Raise the new pane. 			 */
name|XRaiseWindow
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
comment|/* 			 * If the previous current pane was activated 			 * deactivate it. 			 */
if|if
condition|(
name|cur_p
operator|->
name|activated
condition|)
block|{
name|cur_p
operator|->
name|activated
operator|=
literal|0
expr_stmt|;
name|XChangeBackground
argument_list|(
name|cur_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_pixmap
argument_list|)
expr_stmt|;
name|_XMRefreshPaneText
argument_list|(
name|menu
argument_list|,
name|cur_p
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Make the new pane the current pane. 			 */
name|cur_p
operator|=
name|p_ptr
expr_stmt|;
comment|/*  			 * If we have cycled through to the event 			 * pane we are done. 			 */
if|if
condition|(
name|p_ptr
operator|->
name|window
operator|==
name|event_xmp
operator|->
name|window
condition|)
break|break;
block|}
block|}
break|break;
case|case
name|LeaveWindow
case|:
name|event_xmw
operator|=
operator|(
name|XMWindow
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmw
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * If the current selection was activated then 		 * deactivate it. 		 */
if|if
condition|(
name|cur_s
operator|->
name|activated
condition|)
block|{
name|cur_s
operator|->
name|activated
operator|=
literal|0
expr_stmt|;
name|_XMRefreshSelection
argument_list|(
name|menu
argument_list|,
name|cur_s
argument_list|)
expr_stmt|;
block|}
name|cur_s
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|ButtonPressed
case|:
case|case
name|ButtonReleased
case|:
operator|*
name|p_num
operator|=
name|cur_p
operator|->
name|serial
expr_stmt|;
comment|/* 		 * Check to see if there is a current selecion. 		 */
if|if
condition|(
name|cur_s
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * Set the selection number to the current selection. 		     */
operator|*
name|s_num
operator|=
name|cur_s
operator|->
name|serial
expr_stmt|;
comment|/* 		     * If the current selection was activated then 		     * we have a valid selection otherwise we have 		     * an inactive selection. 		     */
if|if
condition|(
name|cur_s
operator|->
name|activated
condition|)
block|{
operator|*
name|data
operator|=
name|cur_s
operator|->
name|data
expr_stmt|;
name|ret_val
operator|=
name|XM_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|XM_IA_SELECT
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * No selection was current. 		     */
name|ret_val
operator|=
name|XM_NO_SELECT
expr_stmt|;
block|}
name|selection
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|_XMEventHandler
condition|)
call|(
modifier|*
name|_XMEventHandler
call|)
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If a selection has been made, break out of the event loop. 	 */
if|if
condition|(
name|selection
operator|==
name|TRUE
condition|)
break|break;
block|}
comment|/*      * Unmap the menu.      */
if|if
condition|(
name|saved
condition|)
block|{
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
block|{
name|XUnmapTransparent
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
block|{
name|XUnmapWindow
argument_list|(
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Ungrab the mouse.      */
name|XUngrabMouse
argument_list|()
expr_stmt|;
comment|/*       * Restore bits under where the menu was if we managed      * to save them and free the pixmap.      */
if|if
condition|(
name|saved
condition|)
block|{
name|XPixmapPut
argument_list|(
name|menu
operator|->
name|parent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|save_x
argument_list|,
name|save_y
argument_list|,
name|save_w
argument_list|,
name|save_h
argument_list|,
name|save_pixmap
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|save_pixmap
argument_list|)
expr_stmt|;
block|}
comment|/*      * Ungrab the X server.      */
if|if
condition|(
name|menu
operator|->
name|freeze
condition|)
name|XUngrabServer
argument_list|()
expr_stmt|;
comment|/*      * If there is a current selection deactivate it.      */
if|if
condition|(
name|cur_s
operator|!=
name|NULL
condition|)
name|cur_s
operator|->
name|activated
operator|=
literal|0
expr_stmt|;
comment|/*      * Deactivate the current pane.      */
name|cur_p
operator|->
name|activated
operator|=
literal|0
expr_stmt|;
name|XChangeBackground
argument_list|(
name|cur_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_pixmap
argument_list|)
expr_stmt|;
comment|/*      * Synchronize the X buffers and the event queue.      */
name|XSync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Now discard any extraneous events.      */
while|while
condition|(
name|QLength
argument_list|()
condition|)
block|{
comment|/* 	 * Fetch the next event. 	 */
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
comment|/* 	 * Dispatch on the event type. 	 */
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
case|case
name|EnterWindow
case|:
case|case
name|LeaveWindow
case|:
case|case
name|ButtonPressed
case|:
case|case
name|ButtonReleased
case|:
name|event_xmp
operator|=
operator|(
name|XMPane
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event_xmp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|_XMEventHandler
operator|!=
name|NULL
operator|)
condition|)
call|(
modifier|*
name|_XMEventHandler
call|)
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|_XMEventHandler
condition|)
call|(
modifier|*
name|_XMEventHandler
call|)
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

end_unit

