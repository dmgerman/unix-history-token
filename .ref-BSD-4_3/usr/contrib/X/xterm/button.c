begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1984, 1985	*/
end_comment

begin_comment
comment|/* button.c	Handles button events in the terminal emulator. 		does cut/paste operations, change modes via menu, 		passes button events through to some applications. 				J. Gettys. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_window_c
init|=
literal|"$Header: button.c,v 10.11 86/02/01 16:05:41 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|"ptyx.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MODEMENU
end_ifdef

begin_include
include|#
directive|include
file|<X/XMenu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NBUTS
value|3
end_define

begin_define
define|#
directive|define
name|DIRS
value|2
end_define

begin_define
define|#
directive|define
name|UP
value|1
end_define

begin_define
define|#
directive|define
name|DOWN
value|0
end_define

begin_define
define|#
directive|define
name|SHIFTS
value|8
end_define

begin_comment
comment|/* three keys, so eight combinations */
end_comment

begin_function_decl
name|char
modifier|*
name|GetRestOfLine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|SaveText
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern UnSaltText(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern SaltTextAway(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern StartCut(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern ReExecute(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern EditorDown(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MODEMENU
end_ifdef

begin_extern
extern|extern ModeMenu(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xterm_name
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ModeMenu
value|Bogus
end_define

begin_endif
endif|#
directive|endif
endif|MODEMENU
end_endif

begin_extern
extern|extern Bogus(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|Silence
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* due to LK201 limitations, not all of the below are actually possible */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|bfunc
index|[
name|SHIFTS
index|]
index|[
name|DIRS
index|]
index|[
name|NBUTS
index|]
function_decl|)
parameter_list|()
init|=
block|{
comment|/*	left		middle		right	*/
name|EditorDown
operator|,
function_decl|EditorDown
operator|,
function_decl|EditorDown
operator|,
comment|/* down	|	  */
function_decl|Silence
operator|,
function_decl|Silence
operator|,
function_decl|Silence
operator|,
comment|/* up	|no shift */
function_decl|Silence
operator|,
function_decl|StartCut
operator|,
function_decl|Silence
operator|,
comment|/* down |	  */
function_decl|ReExecute
operator|,
function_decl|SaltTextAway
operator|,
function_decl|UnSaltText
operator|,
comment|/* up	|shift	  */
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
comment|/* down	|	  */
function_decl|Silence
operator|,
function_decl|Silence
operator|,
function_decl|Silence
operator|,
comment|/* up	|meta	  */
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
comment|/* down	|	  */
function_decl|Silence
operator|,
function_decl|Silence
operator|,
function_decl|Silence
operator|,
comment|/* up	|meta shift */
function_decl|Bogus
operator|,
function_decl|ModeMenu
operator|,
function_decl|Bogus
operator|,
comment|/* down	|	  */
function_decl|Silence
operator|,
function_decl|Silence
operator|,
function_decl|Silence
operator|,
comment|/* up	|control  */
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
comment|/* down	|	  */
function_decl|Silence
operator|,
function_decl|Silence
operator|,
function_decl|Silence
operator|,
comment|/* up	|ctl shift */
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
comment|/* down	|	  */
function_decl|Silence
operator|,
function_decl|Silence
operator|,
function_decl|Silence
operator|,
comment|/* up	|no shift */
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
function_decl|Bogus
operator|,
comment|/* down	| control  */
function_decl|Silence
operator|,
function_decl|Silence
operator|,
function_decl|Silence
end_function_decl

begin_comment
comment|/* up	|meta shift*/
end_comment

begin_comment
unit|};
comment|/* button, shift keys, and direction */
end_comment

begin_expr_stmt
specifier|static
name|crow
operator|,
name|ccol
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* cut row and column */
end_comment

begin_expr_stmt
name|HandleButtons
argument_list|(
name|term
argument_list|,
name|reply
argument_list|,
name|pty
argument_list|)
specifier|register
name|Terminal
operator|*
name|term
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of pty */
end_comment

begin_block
block|{
name|int
function_decl|(
modifier|*
name|bp
function_decl|)
parameter_list|()
function_decl|;
name|int
name|dir
init|=
name|DOWN
decl_stmt|;
comment|/* so table above will be nice, we change left to right */
name|int
name|button
init|=
literal|2
operator|-
operator|(
operator|(
name|XKeyOrButtonEvent
operator|*
operator|)
name|reply
operator|)
operator|->
name|detail
operator|&
literal|0177
decl_stmt|;
name|int
name|shift
init|=
name|KeyState
argument_list|(
operator|(
operator|(
name|XKeyOrButtonEvent
operator|*
operator|)
name|reply
operator|)
operator|->
name|detail
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|reply
operator|->
name|type
condition|)
block|{
case|case
name|ButtonPressed
case|:
name|dir
operator|=
name|DOWN
expr_stmt|;
break|break;
case|case
name|ButtonReleased
case|:
name|dir
operator|=
name|UP
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bp
operator|=
name|bfunc
index|[
name|shift
index|]
index|[
name|dir
index|]
index|[
name|button
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|bp
call|)
argument_list|(
name|term
argument_list|,
name|reply
argument_list|,
name|pty
argument_list|)
operator|)
return|;
name|XFeep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|UnSaltText
argument_list|(
name|term
argument_list|,
name|reply
argument_list|,
name|pty
argument_list|)
specifier|register
name|Terminal
operator|*
name|term
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XKeyOrButtonEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of pty */
end_comment

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
specifier|register
name|char
modifier|*
name|lag
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|line
operator|=
name|XFetchBytes
argument_list|(
operator|&
name|nbytes
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
name|line
index|[
name|nbytes
index|]
expr_stmt|;
name|lag
operator|=
name|line
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|line
init|;
name|cp
operator|!=
name|end
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
continue|continue;
operator|*
name|cp
operator|=
literal|'\r'
expr_stmt|;
name|write
argument_list|(
name|pty
argument_list|,
name|lag
argument_list|,
name|cp
operator|-
name|lag
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lag
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lag
operator|!=
name|end
condition|)
name|write
argument_list|(
name|pty
argument_list|,
name|lag
argument_list|,
name|end
operator|-
name|lag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* free text from fetch */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ReExecute
argument_list|(
name|term
argument_list|,
name|reply
argument_list|,
name|pty
argument_list|)
specifier|register
name|Terminal
operator|*
name|term
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XKeyOrButtonEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of pty */
end_comment

begin_block
block|{
name|char
modifier|*
name|line
init|=
name|GetRestOfLine
argument_list|(
operator|&
name|term
operator|->
name|screen
argument_list|,
name|reply
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nbytes
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|pty
argument_list|,
name|line
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|line
index|[
name|nbytes
index|]
operator|=
literal|'\n'
expr_stmt|;
name|XStoreBytes
argument_list|(
name|line
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* free text from fetch */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|GetRestOfLine
parameter_list|(
name|screen
parameter_list|,
name|reply
parameter_list|)
specifier|register
name|XKeyOrButtonEvent
modifier|*
name|reply
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|screen
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|row
operator|=
operator|(
name|reply
operator|->
name|y
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_height
expr_stmt|;
name|col
operator|=
operator|(
name|reply
operator|->
name|x
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_width
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
condition|)
name|row
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|row
operator|>
name|screen
operator|->
name|max_row
condition|)
name|row
operator|=
name|screen
operator|->
name|max_row
expr_stmt|;
if|if
condition|(
name|col
operator|<
literal|0
condition|)
name|col
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|col
operator|>
name|screen
operator|->
name|max_col
condition|)
name|col
operator|=
name|screen
operator|->
name|max_col
expr_stmt|;
name|i
operator|=
name|Length
argument_list|(
name|screen
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|screen
operator|->
name|max_col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|+
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Error
argument_list|()
expr_stmt|;
name|SaveText
argument_list|(
name|screen
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|screen
operator|->
name|max_col
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
index|[
name|i
index|]
operator|=
literal|'\r'
expr_stmt|;
name|line
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|StartCut
argument_list|(
name|term
argument_list|,
name|reply
argument_list|,
name|pty
argument_list|)
specifier|register
name|XKeyOrButtonEvent
operator|*
name|reply
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
name|crow
operator|=
operator|(
name|reply
operator|->
name|y
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_height
expr_stmt|;
name|ccol
operator|=
operator|(
name|reply
operator|->
name|x
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_width
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|SaltTextAway
argument_list|(
name|term
argument_list|,
name|reply
argument_list|,
name|pty
argument_list|)
specifier|register
name|XKeyOrButtonEvent
operator|*
name|reply
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
specifier|register
name|row
operator|,
name|col
expr_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to be saved */
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|row
operator|=
operator|(
name|reply
operator|->
name|y
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_height
expr_stmt|;
name|col
operator|=
operator|(
name|reply
operator|->
name|x
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_width
expr_stmt|;
comment|/* first order of business is to guarantee that crow,ccol is before */
comment|/* row,col. */
if|if
condition|(
name|row
operator|==
name|crow
condition|)
block|{
comment|/* must exchange as pairs */
if|if
condition|(
name|ccol
operator|>
name|col
condition|)
block|{
comment|/* may have to exchange columns */
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ccol
expr_stmt|;
name|ccol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|crow
operator|>
name|row
condition|)
block|{
comment|/* may have to exchange row and col */
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ccol
expr_stmt|;
name|ccol
operator|=
name|col
expr_stmt|;
name|col
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|crow
expr_stmt|;
name|crow
operator|=
name|row
expr_stmt|;
name|row
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ccol
operator|<
literal|0
condition|)
name|ccol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ccol
operator|>
name|screen
operator|->
name|max_col
condition|)
block|{
name|crow
operator|++
expr_stmt|;
name|ccol
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|crow
operator|<
literal|0
condition|)
name|crow
operator|=
name|ccol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|crow
operator|>
name|screen
operator|->
name|max_row
condition|)
block|{
name|crow
operator|=
name|screen
operator|->
name|max_row
expr_stmt|;
name|ccol
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|>
name|screen
operator|->
name|max_row
condition|)
block|{
name|row
operator|=
name|screen
operator|->
name|max_row
operator|+
literal|1
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|col
operator|>
name|screen
operator|->
name|max_col
condition|)
name|col
operator|=
name|screen
operator|->
name|max_col
expr_stmt|;
comment|/* first we need to know how long the string is before we can save it*/
if|if
condition|(
name|row
operator|==
name|crow
condition|)
name|j
operator|=
name|Length
argument_list|(
name|screen
argument_list|,
name|crow
argument_list|,
name|ccol
argument_list|,
name|col
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* two cases, cut is on same line, cut spans multiple lines */
name|j
operator|+=
name|Length
argument_list|(
name|screen
argument_list|,
name|crow
argument_list|,
name|ccol
argument_list|,
name|screen
operator|->
name|max_col
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|crow
operator|+
literal|1
init|;
name|i
operator|<
name|row
condition|;
name|i
operator|++
control|)
name|j
operator|+=
name|Length
argument_list|(
name|screen
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|screen
operator|->
name|max_col
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|col
operator|>=
literal|0
condition|)
name|j
operator|+=
name|Length
argument_list|(
name|screen
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
comment|/* now get some memory to save it in */
if|if
condition|(
operator|(
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|j
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Error
argument_list|()
expr_stmt|;
name|line
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure it is null terminated */
name|lp
operator|=
name|line
expr_stmt|;
comment|/* lp points to where to save the text */
if|if
condition|(
name|row
operator|==
name|crow
condition|)
name|lp
operator|=
name|SaveText
argument_list|(
name|screen
argument_list|,
name|row
argument_list|,
name|ccol
argument_list|,
name|col
argument_list|,
name|lp
argument_list|)
expr_stmt|;
else|else
block|{
name|lp
operator|=
name|SaveText
argument_list|(
name|screen
argument_list|,
name|crow
argument_list|,
name|ccol
argument_list|,
name|screen
operator|->
name|max_col
argument_list|,
name|lp
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* put in newline at end of line */
for|for
control|(
name|i
operator|=
name|crow
operator|+
literal|1
init|;
name|i
operator|<
name|row
condition|;
name|i
operator|++
control|)
block|{
name|lp
operator|=
name|SaveText
argument_list|(
name|screen
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|screen
operator|->
name|max_col
argument_list|,
name|lp
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|>=
literal|0
condition|)
name|lp
operator|=
name|SaveText
argument_list|(
name|screen
argument_list|,
name|row
argument_list|,
literal|0
argument_list|,
name|col
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
operator|*
name|lp
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure we have end marked */
name|XStoreBytes
argument_list|(
name|line
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* returns number of chars in line from scol to ecol out */
end_comment

begin_function
name|int
name|Length
parameter_list|(
name|screen
parameter_list|,
name|row
parameter_list|,
name|scol
parameter_list|,
name|ecol
parameter_list|)
specifier|register
name|int
name|row
decl_stmt|,
name|scol
decl_stmt|,
name|ecol
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|screen
decl_stmt|;
block|{
specifier|register
name|short
modifier|*
name|ch
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|ch
operator|=
name|screen
operator|->
name|buf
index|[
name|row
index|]
expr_stmt|;
while|while
condition|(
name|ecol
operator|>=
name|scol
operator|&&
operator|(
operator|(
name|ch
index|[
name|ecol
index|]
operator|&
name|CHAR
operator|)
operator|==
literal|0
operator|||
operator|(
name|ch
index|[
name|ecol
index|]
operator|&
name|CHAR
operator|)
operator|==
literal|' '
operator|)
condition|)
name|ecol
operator|--
expr_stmt|;
return|return
operator|(
name|ecol
operator|-
name|scol
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copies text into line, preallocated */
end_comment

begin_function
name|char
modifier|*
name|SaveText
parameter_list|(
name|screen
parameter_list|,
name|row
parameter_list|,
name|scol
parameter_list|,
name|ecol
parameter_list|,
name|lp
parameter_list|)
name|int
name|row
decl_stmt|;
name|int
name|scol
decl_stmt|,
name|ecol
decl_stmt|;
name|Screen
modifier|*
name|screen
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
comment|/* pointer to where to put the text */
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|short
modifier|*
name|ch
init|=
name|screen
operator|->
name|buf
index|[
name|row
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Length
argument_list|(
name|screen
argument_list|,
name|row
argument_list|,
name|scol
argument_list|,
name|ecol
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|lp
operator|)
return|;
name|ecol
operator|=
name|scol
operator|+
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scol
init|;
name|i
operator|<
name|ecol
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ch
index|[
name|i
index|]
operator|&
name|CHAR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_macro
name|EditorDown
argument_list|(
argument|term
argument_list|,
argument|reply
argument_list|,
argument|pty
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|XKeyOrButtonEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of pty */
end_comment

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
name|char
name|line
index|[
literal|6
index|]
decl_stmt|;
specifier|register
name|unsigned
name|row
decl_stmt|,
name|col
decl_stmt|;
name|int
name|button
init|=
literal|2
operator|-
name|reply
operator|->
name|detail
operator|&
literal|0177
decl_stmt|;
if|if
condition|(
operator|!
name|screen
operator|->
name|send_mouse_pos
condition|)
block|{
name|XFeep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|row
operator|=
operator|(
name|reply
operator|->
name|y
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_height
expr_stmt|;
name|col
operator|=
operator|(
name|reply
operator|->
name|x
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_width
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"\033[M"
argument_list|)
expr_stmt|;
name|line
index|[
literal|3
index|]
operator|=
literal|' '
operator|+
name|button
expr_stmt|;
name|line
index|[
literal|4
index|]
operator|=
literal|' '
operator|+
name|col
operator|+
literal|1
expr_stmt|;
name|line
index|[
literal|5
index|]
operator|=
literal|' '
operator|+
name|row
operator|+
literal|1
expr_stmt|;
name|write
argument_list|(
name|pty
argument_list|,
name|line
argument_list|,
literal|6
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MODEMENU
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|menutoggled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Terminal
modifier|*
name|menuterm
decl_stmt|;
end_decl_stmt

begin_macro
name|HandleMenuEvent
argument_list|(
argument|rep
argument_list|)
end_macro

begin_decl_stmt
name|XEvent
modifier|*
name|rep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|menuterm
operator|->
name|screen
decl_stmt|;
switch|switch
condition|(
name|rep
operator|->
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
name|menutoggled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ScreenResize
argument_list|(
name|screen
argument_list|,
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
name|rep
operator|)
operator|->
name|width
argument_list|,
operator|(
operator|(
name|XExposeWindowEvent
operator|*
operator|)
name|rep
operator|)
operator|->
name|height
argument_list|,
name|menuterm
operator|->
name|flags
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|TabReset
argument_list|(
name|menuterm
operator|->
name|tabs
argument_list|)
expr_stmt|;
name|XClear
argument_list|(
name|screen
operator|->
name|window
argument_list|)
expr_stmt|;
name|ScrnRefresh
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen
operator|->
name|max_row
operator|+
literal|1
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|TekEmu
condition|)
name|TekRefresh
argument_list|(
name|menuterm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ExposeRegion
case|:
if|if
condition|(
name|HandleExposure
argument_list|(
name|screen
argument_list|,
name|rep
argument_list|)
condition|)
name|menutoggled
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|MMENU_SCROLL
value|1
end_define

begin_define
define|#
directive|define
name|MMENU_VIDEO
value|2
end_define

begin_define
define|#
directive|define
name|MMENU_WRAP
value|3
end_define

begin_define
define|#
directive|define
name|MMENU_NLM
value|4
end_define

begin_define
define|#
directive|define
name|MMENU_CURSOR
value|5
end_define

begin_define
define|#
directive|define
name|MMENU_PAD
value|6
end_define

begin_define
define|#
directive|define
name|MMENU_RESET
value|7
end_define

begin_define
define|#
directive|define
name|MMENU_FULLRESET
value|8
end_define

begin_decl_stmt
specifier|static
name|XMenu
modifier|*
name|menu
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|menutermflags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|menukbdflags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastmenupane
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastmenusel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|ModeMenu
argument_list|(
argument|term
argument_list|,
argument|reply
argument_list|,
argument|pty
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|XKeyOrButtonEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of pty */
end_comment

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|ulx
decl_stmt|,
name|uly
decl_stmt|;
name|int
name|menuw
decl_stmt|,
name|menuh
decl_stmt|;
name|int
name|pnum
init|=
name|lastmenupane
decl_stmt|,
name|snum
init|=
name|lastmenusel
decl_stmt|;
name|int
name|status
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|menu
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|menu
operator|=
operator|(
name|XMenu
operator|*
operator|)
name|XMenuCreate
argument_list|(
name|RootWindow
argument_list|,
name|xterm_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|XMenuAddPane
argument_list|(
name|menu
argument_list|,
literal|"Modes"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_SCROLL
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|SMOOTHSCROLL
operator|)
condition|?
literal|"jump scroll"
else|:
literal|"smooth scroll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_VIDEO
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|REVERSE_VIDEO
operator|)
condition|?
literal|"normal video"
else|:
literal|"reverse video"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_WRAP
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|WRAPAROUND
operator|)
condition|?
literal|"no wrap"
else|:
literal|"auto wrap"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_NLM
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|LINEFEED
operator|)
condition|?
literal|"normal linefeed"
else|:
literal|"auto linefeed"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_CURSOR
argument_list|,
operator|(
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|&
name|CURSOR_APL
operator|)
condition|?
literal|"normal cursors"
else|:
literal|"application cursors"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_PAD
argument_list|,
operator|(
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|&
name|KYPD_APL
operator|)
condition|?
literal|"numeric pad"
else|:
literal|"application pad"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_RESET
argument_list|,
literal|"soft reset"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XMenuAddSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_FULLRESET
argument_list|,
literal|"full reset"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|menuterm
operator|=
name|term
expr_stmt|;
name|menutermflags
operator|=
name|term
operator|->
name|flags
expr_stmt|;
name|menukbdflags
operator|=
name|term
operator|->
name|keyboard
operator|.
name|flags
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
operator|(
name|menutermflags
operator|^
name|term
operator|->
name|flags
operator|)
operator|&
name|SMOOTHSCROLL
condition|)
block|{
name|XMenuChangeSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_SCROLL
operator|-
literal|1
argument_list|,
name|MMENU_SCROLL
argument_list|,
literal|1
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|SMOOTHSCROLL
operator|)
condition|?
literal|"jump scroll"
else|:
literal|"smooth scroll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|menutermflags
operator|^
name|term
operator|->
name|flags
operator|)
operator|&
name|REVERSE_VIDEO
condition|)
block|{
name|XMenuChangeSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_VIDEO
operator|-
literal|1
argument_list|,
name|MMENU_VIDEO
argument_list|,
literal|1
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|REVERSE_VIDEO
operator|)
condition|?
literal|"normal video"
else|:
literal|"reverse video"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|menutermflags
operator|^
name|term
operator|->
name|flags
operator|)
operator|&
name|WRAPAROUND
condition|)
block|{
name|XMenuChangeSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_WRAP
operator|-
literal|1
argument_list|,
name|MMENU_WRAP
argument_list|,
literal|1
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|WRAPAROUND
operator|)
condition|?
literal|"no wrap"
else|:
literal|"auto wrap"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|menutermflags
operator|^
name|term
operator|->
name|flags
operator|)
operator|&
name|LINEFEED
condition|)
block|{
name|XMenuChangeSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_NLM
operator|-
literal|1
argument_list|,
name|MMENU_NLM
argument_list|,
literal|1
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|LINEFEED
operator|)
condition|?
literal|"normal linefeed"
else|:
literal|"auto linefeed"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|menukbdflags
operator|^
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|)
operator|&
name|CURSOR_APL
condition|)
block|{
name|XMenuChangeSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_CURSOR
operator|-
literal|1
argument_list|,
name|MMENU_CURSOR
argument_list|,
literal|1
argument_list|,
operator|(
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|&
name|CURSOR_APL
operator|)
condition|?
literal|"normal cursors"
else|:
literal|"application cursors"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|menukbdflags
operator|^
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|)
operator|&
name|KYPD_APL
condition|)
block|{
name|XMenuChangeSelection
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
name|MMENU_PAD
operator|-
literal|1
argument_list|,
name|MMENU_PAD
argument_list|,
literal|1
argument_list|,
operator|(
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|&
name|KYPD_APL
operator|)
condition|?
literal|"numeric pad"
else|:
literal|"application pad"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|XMenuRecompute
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|menutermflags
operator|=
name|term
operator|->
name|flags
expr_stmt|;
name|menukbdflags
operator|=
name|term
operator|->
name|keyboard
operator|.
name|flags
expr_stmt|;
name|x
operator|=
operator|(
name|reply
operator|->
name|location
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|y
operator|=
name|reply
operator|->
name|location
operator|&
literal|0xffff
expr_stmt|;
name|XMenuLocate
argument_list|(
name|menu
argument_list|,
name|pnum
argument_list|,
name|snum
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|ulx
argument_list|,
operator|&
name|uly
argument_list|,
operator|&
name|menuw
argument_list|,
operator|&
name|menuh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ulx
operator|+
name|menuw
operator|)
operator|>
name|DisplayWidth
argument_list|()
condition|)
name|x
operator|-=
operator|(
operator|(
name|ulx
operator|+
name|menuw
operator|)
operator|-
name|DisplayWidth
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|ulx
operator|<
literal|0
condition|)
name|x
operator|-=
name|ulx
expr_stmt|;
if|if
condition|(
operator|(
name|uly
operator|+
name|menuh
operator|)
operator|>
name|DisplayHeight
argument_list|()
condition|)
name|y
operator|-=
operator|(
operator|(
name|uly
operator|+
name|menuh
operator|)
operator|-
name|DisplayHeight
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|uly
operator|<
literal|0
condition|)
name|y
operator|-=
name|uly
expr_stmt|;
name|XMenuEventHandler
argument_list|(
name|HandleMenuEvent
argument_list|)
expr_stmt|;
name|menutoggled
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|XMenuActivate
argument_list|(
name|menu
argument_list|,
operator|&
name|pnum
argument_list|,
operator|&
name|snum
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|MiddleMask
operator||
name|ButtonReleased
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XM_FAILURE
condition|)
return|return
operator|(
name|menutoggled
operator|)
return|;
if|if
condition|(
name|status
operator|==
name|XM_NO_SELECT
condition|)
return|return
operator|(
name|menutoggled
operator|)
return|;
else|else
block|{
name|lastmenupane
operator|=
name|pnum
expr_stmt|;
name|lastmenusel
operator|=
name|snum
expr_stmt|;
block|}
switch|switch
condition|(
name|val
condition|)
block|{
ifdef|#
directive|ifdef
name|JUMPSCROLL
case|case
name|MMENU_SCROLL
case|:
name|term
operator|->
name|flags
operator|^=
name|SMOOTHSCROLL
expr_stmt|;
if|if
condition|(
name|term
operator|->
name|flags
operator|&
name|SMOOTHSCROLL
condition|)
block|{
name|screen
operator|->
name|jumpscroll
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|screen
operator|->
name|TekEmu
condition|)
name|screen
operator|->
name|jumpscroll
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|MMENU_VIDEO
case|:
name|term
operator|->
name|flags
operator|^=
name|REVERSE_VIDEO
expr_stmt|;
name|ReverseVideo
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|menutoggled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MMENU_WRAP
case|:
name|term
operator|->
name|flags
operator|^=
name|WRAPAROUND
expr_stmt|;
case|case
name|MMENU_NLM
case|:
name|term
operator|->
name|flags
operator|^=
name|LINEFEED
expr_stmt|;
case|case
name|MMENU_CURSOR
case|:
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|^=
name|CURSOR_APL
expr_stmt|;
break|break;
case|case
name|MMENU_PAD
case|:
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|^=
name|KYPD_APL
expr_stmt|;
break|break;
case|case
name|MMENU_FULLRESET
case|:
name|TabReset
argument_list|(
name|term
operator|->
name|tabs
argument_list|)
expr_stmt|;
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|=
name|NULL
expr_stmt|;
name|screen
operator|->
name|mode
operator|=
name|ANSInormal
expr_stmt|;
comment|/* Reset Tektronix alpha mode */
name|screen
operator|->
name|TekGMode
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|TekAMode
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|gsets
index|[
literal|0
index|]
operator|=
literal|'B'
expr_stmt|;
name|screen
operator|->
name|gsets
index|[
literal|1
index|]
operator|=
literal|'B'
expr_stmt|;
name|screen
operator|->
name|gsets
index|[
literal|2
index|]
operator|=
literal|'<'
expr_stmt|;
name|screen
operator|->
name|gsets
index|[
literal|3
index|]
operator|=
literal|'<'
expr_stmt|;
name|screen
operator|->
name|curgl
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|curgr
operator|=
literal|2
expr_stmt|;
name|screen
operator|->
name|cur_x
operator|=
name|screen
operator|->
name|cur_y
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|cur_X
operator|=
name|screen
operator|->
name|cur_Y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|term
operator|->
name|flags
operator|&
name|REVERSE_VIDEO
condition|)
name|ReverseVideo
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|->
name|flags
operator|&=
operator|~
name|REVERSE_VIDEO
expr_stmt|;
name|menutoggled
operator|=
literal|1
expr_stmt|;
name|CursorSet
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|term
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ClearScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|term
operator|->
name|flags
operator|=
name|WRAPAROUND
operator||
name|SMOOTHSCROLL
expr_stmt|;
case|case
name|MMENU_RESET
case|:
comment|/* reset scrolling region */
name|screen
operator|->
name|top_marg
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|bot_marg
operator|=
name|screen
operator|->
name|max_row
expr_stmt|;
name|term
operator|->
name|flags
operator|&=
operator|~
name|ORIGIN
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|menutoggled
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MODEMENU
end_endif

begin_macro
name|Bogus
argument_list|(
argument|term
argument_list|,
argument|reply
argument_list|,
argument|pty
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XKeyOrButtonEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of pty */
end_comment

begin_block
block|{
name|XFeep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|Silence
argument_list|(
argument|term
argument_list|,
argument|reply
argument_list|,
argument|pty
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XKeyOrButtonEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of pty */
end_comment

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

