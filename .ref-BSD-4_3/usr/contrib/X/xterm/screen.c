begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1984, 1985	*/
end_comment

begin_comment
comment|/* screen.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_screen_c
init|=
literal|"$Header: screen.c,v 10.13 86/02/01 16:07:00 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"ptyx.h"
end_include

begin_function
name|ScrnBuf
name|Allocate
parameter_list|(
name|nrow
parameter_list|,
name|ncol
parameter_list|)
comment|/*    allocates memory for a 2-dimensional array of shorts and returns a pointer thereto  */
specifier|register
name|int
name|nrow
decl_stmt|,
name|ncol
decl_stmt|;
block|{
specifier|register
name|ScrnBuf
name|base
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
operator|(
name|ScrnBuf
operator|)
name|calloc
argument_list|(
name|nrow
argument_list|,
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|Error
argument_list|()
expr_stmt|;
for|for
control|(
name|nrow
operator|--
init|;
name|nrow
operator|>=
literal|0
condition|;
name|nrow
operator|--
control|)
if|if
condition|(
operator|(
name|base
index|[
name|nrow
index|]
operator|=
operator|(
name|short
operator|*
operator|)
name|calloc
argument_list|(
name|ncol
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|Error
argument_list|()
expr_stmt|;
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_macro
name|ScreenWrite
argument_list|(
argument|screen
argument_list|,
argument|str
argument_list|,
argument|flags
argument_list|,
argument|length
argument_list|)
end_macro

begin_comment
comment|/*    Writes str into buf at row row and column col.  Characters are set to match flags.  */
end_comment

begin_decl_stmt
name|Screen
modifier|*
name|screen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of string */
end_comment

begin_block
block|{
specifier|register
name|short
name|mask
init|=
literal|0
decl_stmt|;
specifier|register
name|short
modifier|*
name|row
init|=
name|screen
operator|->
name|buf
index|[
name|screen
operator|->
name|cur_row
index|]
decl_stmt|;
specifier|register
name|short
modifier|*
name|col
init|=
name|row
operator|+
name|screen
operator|->
name|cur_col
decl_stmt|;
specifier|register
name|int
name|avail
init|=
name|screen
operator|->
name|max_col
operator|-
name|screen
operator|->
name|cur_col
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|avail
condition|)
name|length
operator|=
name|avail
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|INVERSE
condition|)
name|mask
operator||=
name|INVERSEbit
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BOLD
condition|)
name|mask
operator||=
name|BOLDbit
expr_stmt|;
if|if
condition|(
name|mask
condition|)
do|do
block|{
operator|*
name|col
operator|++
operator|=
operator|*
name|str
operator|++
operator||
name|mask
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|length
operator|>
literal|0
condition|)
do|;
else|else
do|do
block|{
operator|*
name|col
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|length
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_function
name|char
modifier|*
name|ScrnGetChars
parameter_list|(
name|sb
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|,
name|max
parameter_list|,
name|ptr
parameter_list|,
name|flags
parameter_list|)
comment|/*    Stores characters from sb at row, col into *ptr.  At most max    characters are stored; will stop if the characters in sb do not match    the characteristics of flags.  Returns the number of characters actually    stored + ptr.     Requires max + col - 1<= the maximum size of a row in sb.    	    max>= 0  */
name|ScrnBuf
name|sb
decl_stmt|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|short
name|mask
init|=
literal|0
decl_stmt|;
specifier|register
name|short
modifier|*
name|fetch
init|=
name|sb
index|[
name|row
index|]
operator|+
name|col
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|INVERSE
condition|)
name|mask
operator||=
name|INVERSEbit
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BOLD
condition|)
name|mask
operator||=
name|BOLDbit
expr_stmt|;
while|while
condition|(
operator|(
operator|(
operator|*
name|fetch
operator|&
operator|(
name|short
operator|)
literal|0xff00
operator|)
operator|==
name|mask
operator|)
operator|&&
operator|(
name|max
operator|--
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|fetch
operator|==
literal|0
condition|)
operator|*
name|fetch
operator|=
operator|(
name|short
operator|)
literal|' '
expr_stmt|;
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|=
call|(
name|char
call|)
argument_list|(
operator|*
operator|(
name|fetch
operator|++
operator|)
operator|&
operator|(
name|short
operator|)
literal|0xff
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|ScrnInsertLine
argument_list|(
name|sb
argument_list|,
name|last
argument_list|,
name|where
argument_list|,
name|n
argument_list|,
name|size
argument_list|)
comment|/*    Inserts n blank lines at sb + where, treating last as a bottom margin.    Size is the size of each entry in sb.    Requires: 0<= where< where + n<= last    	     n<= MAX_ROWS  */
specifier|register
name|ScrnBuf
name|sb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|where
decl_stmt|,
name|n
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|short
modifier|*
name|save
index|[
name|MAX_ROWS
index|]
decl_stmt|;
name|int
name|length
init|=
name|size
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
decl_stmt|;
comment|/* save n lines at bottom */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|last
operator|-
name|n
operator|+
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear contents of old rows */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
index|[
name|i
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* move down lines */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|where
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|where
operator|+
name|n
index|]
argument_list|,
operator|(
name|last
operator|-
name|where
operator|-
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reuse storage for new lines at where */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|where
index|]
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ScrnDeleteLine
argument_list|(
name|sb
argument_list|,
name|last
argument_list|,
name|where
argument_list|,
name|n
argument_list|,
name|size
argument_list|)
comment|/*    Deletes n lines at sb + where, treating last as a bottom margin.    Size is the size of each entry in sb.    Requires 0<= where< where + n< = last    	    n<= MAX_ROWS  */
specifier|register
name|ScrnBuf
name|sb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|,
name|last
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|short
modifier|*
name|save
index|[
name|MAX_ROWS
index|]
decl_stmt|;
name|int
name|length
init|=
name|size
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
decl_stmt|;
comment|/* save n lines at where */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|where
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear contents of old rows */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
index|[
name|i
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* move up lines */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|where
operator|+
name|n
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|where
index|]
argument_list|,
operator|(
name|last
operator|-
name|where
operator|-
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reuse storage for new bottom lines */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|save
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
index|[
name|last
operator|-
name|n
operator|+
literal|1
index|]
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ScrnInsertChar
argument_list|(
argument|sb
argument_list|,
argument|row
argument_list|,
argument|col
argument_list|,
argument|n
argument_list|,
argument|size
argument_list|)
end_macro

begin_comment
comment|/*    Inserts n blanks in sb at row, col.  Size is the size of each row.  */
end_comment

begin_decl_stmt
name|ScrnBuf
name|sb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|row
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|col
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|ptr
init|=
name|sb
index|[
name|row
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
name|col
operator|+
name|n
condition|;
name|i
operator|--
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|ptr
index|[
name|i
operator|-
name|n
index|]
expr_stmt|;
name|bzero
argument_list|(
name|ptr
operator|+
name|col
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ScrnDeleteChar
argument_list|(
argument|sb
argument_list|,
argument|row
argument_list|,
argument|col
argument_list|,
argument|n
argument_list|,
argument|size
argument_list|)
end_macro

begin_comment
comment|/*    Deletes n characters in sb at row, col. Size is the size of each row.  */
end_comment

begin_decl_stmt
name|ScrnBuf
name|sb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|row
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|,
name|col
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|ptr
init|=
name|sb
index|[
name|row
index|]
decl_stmt|;
specifier|register
name|nbytes
expr_stmt|;
name|nbytes
operator|=
operator|(
name|size
operator|-
name|n
operator|-
name|col
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
operator|+
name|col
operator|+
name|n
argument_list|,
name|ptr
operator|+
name|col
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ptr
operator|+
name|size
operator|-
name|n
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ScrnRefresh
argument_list|(
name|screen
argument_list|,
name|toprow
argument_list|,
name|leftcol
argument_list|,
name|nrows
argument_list|,
name|ncols
argument_list|)
comment|/*    Repaints the area enclosed by the parameters.    Requires: (toprow, leftcol), (toprow + nrows, leftcol + ncols) are    	     coordinates of characters in screen; 	     nrows and ncols positive.  */
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|toprow
decl_stmt|,
name|leftcol
decl_stmt|,
name|nrows
decl_stmt|,
name|ncols
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
name|MAX_COLS
index|]
decl_stmt|;
name|int
name|y
init|=
name|toprow
operator|*
name|screen
operator|->
name|f_height
operator|+
name|screen
operator|->
name|border
decl_stmt|;
specifier|register
name|int
name|row
decl_stmt|;
name|int
name|maxrow
init|=
name|toprow
operator|+
name|nrows
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|row
operator|=
name|toprow
init|;
name|row
operator|<=
name|maxrow
condition|;
name|y
operator|+=
name|screen
operator|->
name|f_height
operator|,
name|row
operator|++
control|)
block|{
specifier|register
name|short
modifier|*
name|chars
init|=
name|screen
operator|->
name|buf
index|[
name|row
index|]
decl_stmt|;
specifier|register
name|int
name|col
init|=
name|leftcol
decl_stmt|;
name|int
name|maxcol
init|=
name|leftcol
operator|+
name|ncols
operator|-
literal|1
decl_stmt|;
name|int
name|lastind
decl_stmt|,
name|curind
decl_stmt|;
name|unsigned
name|short
name|flags
decl_stmt|;
name|int
name|gxfunction
decl_stmt|;
name|Font
name|fnt
decl_stmt|;
name|int
name|x
decl_stmt|;
name|short
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
name|curind
operator|=
name|row
operator|-
name|screen
operator|->
name|scroll_amt
expr_stmt|;
if|if
condition|(
name|curind
operator|<
literal|0
operator|||
name|curind
operator|>
name|screen
operator|->
name|max_row
condition|)
continue|continue;
name|chars
operator|=
name|screen
operator|->
name|buf
index|[
name|curind
index|]
expr_stmt|;
else|#
directive|else
name|chars
operator|=
name|screen
operator|->
name|buf
index|[
name|row
index|]
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
while|while
condition|(
name|col
operator|<=
name|maxcol
operator|&&
operator|(
operator|(
name|s
operator|=
operator|(
name|chars
index|[
name|col
index|]
operator|&
operator|~
name|BOLDbit
operator|)
operator|)
operator|==
literal|0
operator|||
name|s
operator|==
literal|' '
operator|)
condition|)
name|col
operator|++
expr_stmt|;
while|while
condition|(
name|col
operator|<=
name|maxcol
operator|&&
operator|(
operator|(
name|s
operator|=
operator|(
name|chars
index|[
name|maxcol
index|]
operator|&
operator|~
name|BOLDbit
operator|)
operator|)
operator|==
literal|0
operator|||
name|s
operator|==
literal|' '
operator|)
condition|)
name|maxcol
operator|--
expr_stmt|;
if|if
condition|(
name|col
operator|>
name|maxcol
condition|)
continue|continue;
name|flags
operator|=
operator|(
name|chars
index|[
name|col
index|]
operator|&
operator|~
name|CHAR
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BOLDbit
condition|)
name|fnt
operator|=
name|screen
operator|->
name|fnt_bold
expr_stmt|;
else|else
name|fnt
operator|=
name|screen
operator|->
name|fnt_norm
expr_stmt|;
name|x
operator|=
name|col
operator|*
name|screen
operator|->
name|f_width
operator|+
name|screen
operator|->
name|border
expr_stmt|;
name|lastind
operator|=
name|curind
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|col
operator|<=
name|maxcol
condition|;
name|col
operator|++
operator|,
name|curind
operator|++
control|)
block|{
name|s
operator|=
name|chars
index|[
name|col
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
operator|~
name|CHAR
operator|)
operator|!=
name|flags
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|INVERSEbit
condition|)
name|XText
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|str
index|[
name|lastind
index|]
argument_list|,
name|curind
operator|-
name|lastind
argument_list|,
name|fnt
argument_list|,
name|screen
operator|->
name|background
argument_list|,
name|screen
operator|->
name|foreground
argument_list|)
expr_stmt|;
else|else
name|XText
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|str
index|[
name|lastind
index|]
argument_list|,
name|curind
operator|-
name|lastind
argument_list|,
name|fnt
argument_list|,
name|screen
operator|->
name|foreground
argument_list|,
name|screen
operator|->
name|background
argument_list|)
expr_stmt|;
name|x
operator|+=
operator|(
name|curind
operator|-
name|lastind
operator|)
operator|*
name|screen
operator|->
name|f_width
expr_stmt|;
name|lastind
operator|=
name|curind
expr_stmt|;
name|flags
operator|=
operator|(
name|s
operator|&
operator|~
name|CHAR
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BOLDbit
condition|)
name|fnt
operator|=
name|screen
operator|->
name|fnt_bold
expr_stmt|;
else|else
name|fnt
operator|=
name|screen
operator|->
name|fnt_norm
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|str
index|[
name|curind
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|s
operator|&
name|CHAR
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|str
index|[
name|curind
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|INVERSEbit
condition|)
name|XText
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|str
index|[
name|lastind
index|]
argument_list|,
name|curind
operator|-
name|lastind
argument_list|,
name|fnt
argument_list|,
name|screen
operator|->
name|background
argument_list|,
name|screen
operator|->
name|foreground
argument_list|)
expr_stmt|;
else|else
name|XText
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|str
index|[
name|lastind
index|]
argument_list|,
name|curind
operator|-
name|lastind
argument_list|,
name|fnt
argument_list|,
name|screen
operator|->
name|foreground
argument_list|,
name|screen
operator|->
name|background
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|ClearBufRows
argument_list|(
name|screen
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
comment|/*    Sets the rows first though last of the buffer of screen to spaces.    Requires first<= last; first, last are rows of screen->buf.  */
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|first
operator|<=
name|last
condition|)
name|bzero
argument_list|(
name|screen
operator|->
name|buf
index|[
name|first
operator|++
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
operator|(
name|screen
operator|->
name|max_col
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ScreenResize
argument_list|(
name|screen
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|flags
argument_list|)
comment|/*    Resizes screen:    1. If new window would have fractional characters, sets window size so as to discard fractional characters and returns -1.       Minimum screen size is 1 X 1.       Note that this causes another ExposeWindow event.    2. Enlarges screen->buf if necessary.  New space is appended to the bottom and to the right    3. Reduces  screen->buf if necessary.  Old space is removed from the bottom and from the right    4. Cursor is positioned as closely to its former position as possible    5. Sets screen->max_row and screen->max_col to reflect new size    6. Maintains the inner border.    7. Clears origin mode and sets scrolling region to be entire screen.    8. Returns 0  */
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|ScrnBuf
name|sb
init|=
name|screen
operator|->
name|buf
decl_stmt|;
name|double
name|scale_x
decl_stmt|,
name|scale_y
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCSWINSZ
name|struct
name|winsize
name|ws
decl_stmt|;
endif|#
directive|endif
comment|/* round so that it is unlikely the screen will change size on  */
comment|/* small mouse movements.					*/
name|rows
operator|=
operator|(
name|height
operator|+
name|screen
operator|->
name|f_height
operator|/
literal|2
operator|-
literal|2
operator|*
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_height
expr_stmt|;
name|cols
operator|=
operator|(
name|width
operator|+
name|screen
operator|->
name|f_width
operator|/
literal|2
operator|-
literal|2
operator|*
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_width
expr_stmt|;
if|if
condition|(
name|rows
operator|<
literal|1
condition|)
name|rows
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cols
operator|<
literal|1
condition|)
name|cols
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|width
operator|-
name|screen
operator|->
name|border
operator|*
literal|2
operator|)
operator|%
name|screen
operator|->
name|f_width
operator|!=
literal|0
operator|||
operator|(
name|height
operator|-
name|screen
operator|->
name|border
operator|*
literal|2
operator|)
operator|%
name|screen
operator|->
name|f_height
operator|!=
literal|0
condition|)
block|{
name|int
name|nwidth
init|=
name|cols
operator|*
name|screen
operator|->
name|f_width
operator|+
name|screen
operator|->
name|border
operator|*
literal|2
decl_stmt|;
name|int
name|nheight
init|=
name|rows
operator|*
name|screen
operator|->
name|f_height
operator|+
name|screen
operator|->
name|border
operator|*
literal|2
decl_stmt|;
name|XChangeWindow
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|nwidth
argument_list|,
name|nheight
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* don't change anything if the screen has not changed size */
if|if
condition|(
name|screen
operator|->
name|max_row
operator|==
name|rows
operator|-
literal|1
operator|&&
name|screen
operator|->
name|max_col
operator|==
name|cols
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* resize current lines */
if|if
condition|(
name|sb
condition|)
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<=
name|screen
operator|->
name|max_row
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sb
index|[
name|index
index|]
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sb
index|[
name|index
index|]
argument_list|,
name|cols
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Error
argument_list|()
expr_stmt|;
if|if
condition|(
name|cols
operator|>
operator|(
name|screen
operator|->
name|max_col
operator|+
literal|1
operator|)
condition|)
name|bzero
argument_list|(
name|sb
index|[
name|index
index|]
operator|+
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
operator|(
name|cols
operator|-
operator|(
name|screen
operator|->
name|max_col
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* discard excess bottom rows */
for|for
control|(
name|index
operator|=
name|rows
init|;
name|index
operator|<=
name|screen
operator|->
name|max_row
condition|;
name|index
operator|++
control|)
name|free
argument_list|(
name|sb
index|[
name|index
index|]
argument_list|)
expr_stmt|;
comment|/* resize sb */
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
name|sb
operator|=
operator|(
name|ScrnBuf
operator|)
name|malloc
argument_list|(
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sb
operator|=
operator|(
name|ScrnBuf
operator|)
name|realloc
argument_list|(
name|sb
argument_list|,
name|rows
operator|*
sizeof|sizeof
argument_list|(
name|short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
name|Error
argument_list|()
expr_stmt|;
name|screen
operator|->
name|buf
operator|=
name|sb
expr_stmt|;
comment|/* create additional bottom rows as required */
for|for
control|(
name|index
operator|=
name|screen
operator|->
name|max_row
operator|+
literal|1
init|;
name|index
operator|<
name|rows
condition|;
name|index
operator|++
control|)
if|if
condition|(
operator|(
name|sb
index|[
name|index
index|]
operator|=
operator|(
name|short
operator|*
operator|)
name|calloc
argument_list|(
name|cols
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Error
argument_list|()
expr_stmt|;
name|screen
operator|->
name|max_row
operator|=
name|rows
operator|-
literal|1
expr_stmt|;
name|screen
operator|->
name|max_col
operator|=
name|cols
operator|-
literal|1
expr_stmt|;
comment|/* adjust scrolling region */
name|screen
operator|->
name|top_marg
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|bot_marg
operator|=
name|screen
operator|->
name|max_row
expr_stmt|;
operator|*
name|flags
operator|&=
operator|~
name|ORIGIN
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|cur_row
operator|>
name|screen
operator|->
name|max_row
condition|)
name|screen
operator|->
name|cur_row
operator|=
name|screen
operator|->
name|max_row
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|cur_col
operator|>
name|screen
operator|->
name|max_col
condition|)
name|screen
operator|->
name|cur_col
operator|=
name|screen
operator|->
name|max_col
expr_stmt|;
name|screen
operator|->
name|height
operator|=
name|height
operator|-
literal|2
operator|*
name|screen
operator|->
name|border
expr_stmt|;
name|screen
operator|->
name|width
operator|=
name|width
operator|-
literal|2
operator|*
name|screen
operator|->
name|border
expr_stmt|;
comment|/* Set Tektronix scale factor */
name|scale_x
operator|=
name|screen
operator|->
name|width
operator|/
literal|4096.0
expr_stmt|;
name|scale_y
operator|=
name|screen
operator|->
name|height
operator|/
literal|3128.0
expr_stmt|;
name|screen
operator|->
name|TekScale
operator|=
operator|(
name|scale_x
operator|<
name|scale_y
operator|)
condition|?
name|scale_x
else|:
name|scale_y
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSWINSZ
comment|/* Set tty's idea of window size */
name|ws
operator|.
name|ws_row
operator|=
name|rows
expr_stmt|;
name|ws
operator|.
name|ws_col
operator|=
name|cols
expr_stmt|;
name|ws
operator|.
name|ws_xpixel
operator|=
name|width
expr_stmt|;
name|ws
operator|.
name|ws_ypixel
operator|=
name|height
expr_stmt|;
name|ioctl
argument_list|(
name|screen
operator|->
name|respond
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

