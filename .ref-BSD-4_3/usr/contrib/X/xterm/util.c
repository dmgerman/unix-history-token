begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1984, 1985	*/
end_comment

begin_comment
comment|/* util.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_util_c
init|=
literal|"$Header: util.c,v 10.11 86/04/28 15:05:29 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"ptyx.h"
end_include

begin_extern
extern|extern errno;
end_extern

begin_extern
extern|extern debug;
end_extern

begin_ifdef
ifdef|#
directive|ifdef
name|JUMPSCROLL
end_ifdef

begin_comment
comment|/*  * These routines are used for the jump scroll feature  */
end_comment

begin_expr_stmt
name|FlushScroll
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|height
init|=
name|screen
operator|->
name|bot_marg
operator|-
name|screen
operator|->
name|top_marg
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|samount
init|=
name|screen
operator|->
name|scroll_amt
decl_stmt|;
specifier|register
name|int
name|ramount
init|=
name|screen
operator|->
name|refresh_amt
decl_stmt|;
specifier|register
name|int
name|scrolled
init|=
name|samount
operator|*
name|screen
operator|->
name|f_height
decl_stmt|;
specifier|register
name|int
name|refreshed
init|=
name|ramount
operator|*
name|screen
operator|->
name|f_height
decl_stmt|;
specifier|register
name|int
name|top
init|=
name|screen
operator|->
name|top_marg
operator|*
name|screen
operator|->
name|f_height
operator|+
name|screen
operator|->
name|border
decl_stmt|;
name|int
name|rtop
decl_stmt|;
if|if
condition|(
name|samount
operator|>
literal|0
condition|)
block|{
name|rtop
operator|=
name|screen
operator|->
name|bot_marg
operator|-
name|ramount
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rtop
operator|=
name|screen
operator|->
name|top_marg
expr_stmt|;
name|top
operator|-=
name|scrolled
expr_stmt|;
name|ramount
operator|=
operator|-
name|ramount
expr_stmt|;
name|refreshed
operator|=
operator|-
name|refreshed
expr_stmt|;
block|}
if|if
condition|(
name|ramount
operator|!=
name|height
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|multiscroll
operator|&&
name|samount
operator|==
literal|1
operator|&&
name|screen
operator|->
name|top_marg
operator|==
literal|0
operator|&&
name|screen
operator|->
name|bot_marg
operator|==
name|screen
operator|->
name|max_row
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|incopy
operator|<
literal|0
operator|&&
name|screen
operator|->
name|scrolls
operator|==
literal|0
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scrolls
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|screen
operator|->
name|incopy
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|XMoveArea
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|top
operator|+
name|scrolled
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|top
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|height
operator|*
name|screen
operator|->
name|f_height
operator|-
name|refreshed
argument_list|)
expr_stmt|;
block|}
name|screen
operator|->
name|scroll_amt
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|refresh_amt
operator|=
literal|0
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|rtop
operator|*
name|screen
operator|->
name|f_height
operator|+
name|screen
operator|->
name|border
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|refreshed
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
name|ScrnRefresh
argument_list|(
name|screen
argument_list|,
name|rtop
argument_list|,
literal|0
argument_list|,
name|ramount
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|AddToRefresh
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|amount
init|=
name|screen
operator|->
name|refresh_amt
decl_stmt|;
specifier|register
name|int
name|row
init|=
name|screen
operator|->
name|cur_row
decl_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|bottom
decl_stmt|;
if|if
condition|(
name|row
operator|==
operator|(
name|bottom
operator|=
name|screen
operator|->
name|bot_marg
operator|)
operator|-
name|amount
condition|)
block|{
name|screen
operator|->
name|refresh_amt
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|row
operator|>=
name|bottom
operator|-
name|amount
operator|+
literal|1
operator|&&
name|row
operator|<=
name|bottom
operator|)
return|;
block|}
else|else
block|{
specifier|register
name|int
name|top
decl_stmt|;
name|amount
operator|=
operator|-
name|amount
expr_stmt|;
if|if
condition|(
name|row
operator|==
operator|(
name|top
operator|=
name|screen
operator|->
name|top_marg
operator|)
operator|+
name|amount
condition|)
block|{
name|screen
operator|->
name|refresh_amt
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|row
operator|<=
name|top
operator|+
name|amount
operator|-
literal|1
operator|&&
name|row
operator|>=
name|top
operator|)
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|JUMPSCROLL
end_endif

begin_comment
comment|/*   * scrolls the screen by amount lines, erases bottom, doesn't alter   * cursor position (i.e. cursor moves down amount relative to text).  * All done within the scrolling region, of course.   * requires: amount> 0  */
end_comment

begin_expr_stmt
name|Scroll
argument_list|(
name|screen
argument_list|,
name|amount
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|height
init|=
name|screen
operator|->
name|bot_marg
operator|-
name|screen
operator|->
name|top_marg
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|covered
decl_stmt|;
specifier|register
name|int
name|border
init|=
name|screen
operator|->
name|border
decl_stmt|;
specifier|register
name|int
name|top
init|=
name|screen
operator|->
name|top_marg
operator|*
name|screen
operator|->
name|f_height
operator|+
name|border
decl_stmt|;
if|if
condition|(
name|amount
operator|>
name|height
condition|)
name|amount
operator|=
name|height
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|jumpscroll
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|refresh_amt
operator|+
name|amount
operator|>
name|height
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scroll_amt
operator|+=
name|amount
expr_stmt|;
name|screen
operator|->
name|refresh_amt
operator|+=
name|amount
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
operator|<
literal|0
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scroll_amt
operator|=
name|amount
expr_stmt|;
name|screen
operator|->
name|refresh_amt
operator|=
name|amount
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
endif|JUMPSCROLL
if|if
condition|(
name|amount
operator|==
name|height
condition|)
block|{
name|ClearScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
return|return;
block|}
name|covered
operator|=
name|amount
operator|*
name|screen
operator|->
name|f_height
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|multiscroll
operator|&&
name|amount
operator|==
literal|1
operator|&&
name|screen
operator|->
name|top_marg
operator|==
literal|0
operator|&&
name|screen
operator|->
name|bot_marg
operator|==
name|screen
operator|->
name|max_row
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|incopy
operator|<
literal|0
operator|&&
name|screen
operator|->
name|scrolls
operator|==
literal|0
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scrolls
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|screen
operator|->
name|incopy
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|XMoveArea
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|border
argument_list|,
name|top
operator|+
name|covered
argument_list|,
name|border
argument_list|,
name|top
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|height
operator|*
name|screen
operator|->
name|f_height
operator|-
name|covered
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|border
argument_list|,
operator|(
name|screen
operator|->
name|bot_marg
operator|-
name|amount
operator|+
literal|1
operator|)
operator|*
name|screen
operator|->
name|f_height
operator|+
name|border
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|covered
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
name|ScrnDeleteLine
argument_list|(
name|screen
operator|->
name|buf
argument_list|,
name|screen
operator|->
name|bot_marg
argument_list|,
name|screen
operator|->
name|top_marg
argument_list|,
name|amount
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reverse scrolls the screen by amount lines, erases top, doesn't alter  * cursor position (i.e. cursor moves up amount relative to text).  * All done within the scrolling region, of course.  * Requires: amount> 0  */
end_comment

begin_expr_stmt
name|RevScroll
argument_list|(
name|screen
argument_list|,
name|amount
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|height
init|=
name|screen
operator|->
name|bot_marg
operator|-
name|screen
operator|->
name|top_marg
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|border
init|=
name|screen
operator|->
name|border
decl_stmt|;
specifier|register
name|int
name|top
init|=
name|screen
operator|->
name|top_marg
operator|*
name|screen
operator|->
name|f_height
operator|+
name|border
decl_stmt|;
specifier|register
name|int
name|covered
decl_stmt|;
name|amount
operator|=
operator|(
name|amount
operator|<
name|height
operator|)
condition|?
name|amount
else|:
name|height
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|jumpscroll
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|screen
operator|->
name|refresh_amt
operator|+
name|amount
operator|>
name|height
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scroll_amt
operator|-=
name|amount
expr_stmt|;
name|screen
operator|->
name|refresh_amt
operator|-=
name|amount
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
operator|>
literal|0
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scroll_amt
operator|=
operator|-
name|amount
expr_stmt|;
name|screen
operator|->
name|refresh_amt
operator|=
operator|-
name|amount
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
endif|JUMPSCROLL
name|covered
operator|=
name|amount
operator|*
name|screen
operator|->
name|f_height
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|incopy
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
name|XMoveArea
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|border
argument_list|,
name|top
argument_list|,
name|border
argument_list|,
name|top
operator|+
name|covered
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|height
operator|*
name|screen
operator|->
name|f_height
operator|-
name|covered
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|border
argument_list|,
name|top
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|covered
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
name|ScrnInsertLine
argument_list|(
name|screen
operator|->
name|buf
argument_list|,
name|screen
operator|->
name|bot_marg
argument_list|,
name|screen
operator|->
name|top_marg
argument_list|,
name|amount
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * If cursor not in scrolling region, returns.  Else,  * inserts n blank lines at the cursor's position.  Lines above the  * bottom margin are lost.  */
end_comment

begin_expr_stmt
name|InsertLine
argument_list|(
name|screen
argument_list|,
name|n
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|height
decl_stmt|;
specifier|register
name|int
name|bottom
init|=
name|screen
operator|->
name|bot_marg
decl_stmt|;
if|if
condition|(
name|screen
operator|->
name|cur_row
operator|<
name|screen
operator|->
name|top_marg
operator|||
name|screen
operator|->
name|cur_row
operator|>
name|screen
operator|->
name|bot_marg
condition|)
return|return;
if|if
condition|(
name|screen
operator|->
name|cur_row
operator|+
name|n
operator|-
literal|1
operator|>
name|bottom
condition|)
name|n
operator|=
name|bottom
operator|-
name|screen
operator|->
name|cur_row
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|jumpscroll
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
operator|<=
literal|0
operator|&&
name|screen
operator|->
name|cur_row
operator|<=
operator|-
name|screen
operator|->
name|refresh_amt
condition|)
block|{
if|if
condition|(
operator|-
name|screen
operator|->
name|refresh_amt
operator|+
name|n
operator|>
name|height
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scroll_amt
operator|-=
name|n
expr_stmt|;
name|screen
operator|->
name|refresh_amt
operator|-=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|screen
operator|->
name|scroll_amt
condition|)
block|{
endif|#
directive|endif
endif|JUMPSCROLL
name|height
operator|=
name|n
operator|*
name|screen
operator|->
name|f_height
expr_stmt|;
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|incopy
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * move stuff down. 	 * clear hole. 	 */
name|XMoveArea
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
operator|+
name|height
argument_list|,
name|screen
operator|->
name|width
argument_list|,
operator|(
name|bottom
operator|+
literal|1
operator|-
name|screen
operator|->
name|cur_row
operator|-
name|n
operator|)
operator|*
name|screen
operator|->
name|f_height
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
comment|/* adjust screen->buf */
name|ScrnInsertLine
argument_list|(
name|screen
operator|->
name|buf
argument_list|,
name|bottom
argument_list|,
name|screen
operator|->
name|cur_row
argument_list|,
name|n
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * If cursor not in scrolling region, returns.  Else, deletes n lines  * at the cursor's position, lines added at bottom margin are blank.  */
end_comment

begin_expr_stmt
name|DeleteLine
argument_list|(
name|screen
argument_list|,
name|n
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|height
decl_stmt|;
specifier|register
name|int
name|bottom
init|=
name|screen
operator|->
name|bot_marg
decl_stmt|;
if|if
condition|(
name|screen
operator|->
name|cur_row
operator|<
name|screen
operator|->
name|top_marg
operator|||
name|screen
operator|->
name|cur_row
operator|>
name|screen
operator|->
name|bot_marg
condition|)
return|return;
if|if
condition|(
name|screen
operator|->
name|cur_row
operator|+
name|n
operator|-
literal|1
operator|>
name|bottom
condition|)
name|n
operator|=
name|bottom
operator|-
name|screen
operator|->
name|cur_row
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|jumpscroll
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
operator|>=
literal|0
operator|&&
name|screen
operator|->
name|cur_row
operator|==
name|screen
operator|->
name|top_marg
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|refresh_amt
operator|+
name|n
operator|>
name|height
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|scroll_amt
operator|+=
name|n
expr_stmt|;
name|screen
operator|->
name|refresh_amt
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|screen
operator|->
name|scroll_amt
condition|)
block|{
endif|#
directive|endif
endif|JUMPSCROLL
name|height
operator|=
name|n
operator|*
name|screen
operator|->
name|f_height
expr_stmt|;
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|incopy
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * move stuff up. 	 * clear bottom. 	 */
name|XMoveArea
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
operator|+
name|height
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|width
argument_list|,
operator|(
name|bottom
operator|+
literal|1
operator|-
name|screen
operator|->
name|cur_row
operator|-
name|n
operator|)
operator|*
name|screen
operator|->
name|f_height
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
operator|(
name|bottom
operator|+
literal|1
operator|-
name|n
operator|)
operator|*
name|screen
operator|->
name|f_height
operator|+
name|screen
operator|->
name|border
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
comment|/* adjust screen->buf */
name|ScrnDeleteLine
argument_list|(
name|screen
operator|->
name|buf
argument_list|,
name|bottom
argument_list|,
name|screen
operator|->
name|cur_row
argument_list|,
name|n
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Insert n blanks at the cursor's position, no wraparound.  */
end_comment

begin_expr_stmt
name|InsertChar
argument_list|(
name|screen
argument_list|,
name|n
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|width
init|=
name|n
operator|*
name|screen
operator|->
name|f_width
decl_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
operator|!
name|AddToRefresh
argument_list|(
name|screen
argument_list|)
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|incopy
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
name|XMoveArea
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
operator|+
name|width
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|width
operator|-
operator|(
name|screen
operator|->
name|cur_col
operator|+
name|n
operator|)
operator|*
name|screen
operator|->
name|f_width
argument_list|,
name|screen
operator|->
name|f_height
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|width
argument_list|,
name|screen
operator|->
name|f_height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
comment|/* adjust screen->buf */
name|ScrnInsertChar
argument_list|(
name|screen
operator|->
name|buf
argument_list|,
name|screen
operator|->
name|cur_row
argument_list|,
name|screen
operator|->
name|cur_col
argument_list|,
name|n
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Deletes n chars at the cursor's position, no wraparound.  */
end_comment

begin_expr_stmt
name|DeleteChar
argument_list|(
name|screen
argument_list|,
name|n
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|width
decl_stmt|;
if|if
condition|(
name|screen
operator|->
name|cur_col
operator|+
name|n
operator|>
name|screen
operator|->
name|max_col
operator|+
literal|1
condition|)
name|n
operator|=
name|screen
operator|->
name|max_col
operator|+
literal|1
operator|-
name|screen
operator|->
name|cur_col
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
operator|!
name|AddToRefresh
argument_list|(
name|screen
argument_list|)
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|width
operator|=
name|n
operator|*
name|screen
operator|->
name|f_width
expr_stmt|;
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|incopy
condition|)
name|CopyWait
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
name|XMoveArea
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
operator|+
name|width
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|width
operator|-
operator|(
name|screen
operator|->
name|cur_col
operator|+
name|n
operator|)
operator|*
name|screen
operator|->
name|f_width
argument_list|,
name|screen
operator|->
name|f_height
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
operator|+
name|screen
operator|->
name|width
operator|-
name|width
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|width
argument_list|,
name|screen
operator|->
name|f_height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
comment|/* adjust screen->buf */
name|ScrnDeleteChar
argument_list|(
name|screen
operator|->
name|buf
argument_list|,
name|screen
operator|->
name|cur_row
argument_list|,
name|screen
operator|->
name|cur_col
argument_list|,
name|n
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear from cursor position to beginning of display, inclusive.  */
end_comment

begin_expr_stmt
name|ClearAbove
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|ClearLeft
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
literal|0
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
name|ClearBufRows
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
name|screen
operator|->
name|cur_row
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear from cursor position to end of display, inclusive.  */
end_comment

begin_expr_stmt
name|ClearBelow
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|sy
init|=
name|CursorY
argument_list|(
name|screen
argument_list|)
operator|+
name|screen
operator|->
name|f_height
decl_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|ClearRight
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|sy
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|screen
operator|->
name|height
operator|-
name|sy
operator|+
name|screen
operator|->
name|border
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
name|ClearBufRows
argument_list|(
name|screen
argument_list|,
name|screen
operator|->
name|cur_row
operator|+
literal|1
argument_list|,
name|screen
operator|->
name|max_row
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Clear last part of cursor's line, inclusive.  */
end_comment

begin_expr_stmt
name|ClearRight
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
operator|!
name|AddToRefresh
argument_list|(
name|screen
argument_list|)
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|width
operator|-
name|screen
operator|->
name|cur_col
operator|*
name|screen
operator|->
name|f_width
argument_list|,
name|screen
operator|->
name|f_height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|screen
operator|->
name|buf
index|[
name|screen
operator|->
name|cur_row
index|]
operator|+
name|screen
operator|->
name|cur_col
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
operator|(
name|screen
operator|->
name|max_col
operator|-
name|screen
operator|->
name|cur_col
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clear first part of cursor's line, inclusive.  */
end_comment

begin_expr_stmt
name|ClearLeft
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
operator|!
name|AddToRefresh
argument_list|(
name|screen
argument_list|)
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
operator|(
name|screen
operator|->
name|cur_col
operator|+
literal|1
operator|)
operator|*
name|screen
operator|->
name|f_width
argument_list|,
name|screen
operator|->
name|f_height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|screen
operator|->
name|buf
index|[
name|screen
operator|->
name|cur_row
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
operator|(
name|screen
operator|->
name|cur_col
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Erase the cursor's line.  */
end_comment

begin_expr_stmt
name|ClearLine
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
operator|!
name|AddToRefresh
argument_list|(
name|screen
argument_list|)
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|border
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|screen
operator|->
name|width
argument_list|,
name|screen
operator|->
name|f_height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|screen
operator|->
name|buf
index|[
name|screen
operator|->
name|cur_row
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
operator|(
name|screen
operator|->
name|max_col
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ClearScreen
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|XClear
argument_list|(
name|screen
operator|->
name|window
argument_list|)
expr_stmt|;
name|ClearBufRows
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
name|screen
operator|->
name|max_row
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|CopyWait
argument_list|(
name|screen
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XEvent
name|reply
decl_stmt|;
name|XEvent
modifier|*
name|rep
init|=
operator|&
name|reply
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|XWindowEvent
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|ExposeRegion
operator||
name|ExposeCopy
argument_list|,
operator|&
name|reply
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reply
operator|.
name|type
condition|)
block|{
case|case
name|ExposeRegion
case|:
if|if
condition|(
operator|(
operator|(
name|XExposeEvent
operator|*
operator|)
name|rep
operator|)
operator|->
name|detail
operator|==
name|ExposeCopy
operator|&&
name|screen
operator|->
name|incopy
operator|<=
literal|0
condition|)
block|{
name|screen
operator|->
name|incopy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|scrolls
operator|>
literal|0
condition|)
name|screen
operator|->
name|scrolls
operator|--
expr_stmt|;
block|}
name|HandleExposure
argument_list|(
name|screen
argument_list|,
operator|&
name|reply
argument_list|)
expr_stmt|;
break|break;
case|case
name|ExposeCopy
case|:
if|if
condition|(
name|screen
operator|->
name|incopy
operator|<=
literal|0
operator|&&
name|screen
operator|->
name|scrolls
operator|>
literal|0
condition|)
name|screen
operator|->
name|scrolls
operator|--
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|scrolls
operator|==
literal|0
condition|)
block|{
name|screen
operator|->
name|incopy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|screen
operator|->
name|incopy
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * This routine handles exposure events  */
end_comment

begin_expr_stmt
name|HandleExposure
argument_list|(
name|screen
argument_list|,
name|reply
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XExposeEvent
modifier|*
name|reply
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|toprow
decl_stmt|,
name|leftcol
decl_stmt|,
name|nrows
decl_stmt|,
name|ncols
decl_stmt|;
specifier|extern
name|Terminal
name|term
decl_stmt|;
comment|/* kludge */
name|XExposeRegionEvent
name|event
decl_stmt|;
name|toprow
operator|=
operator|(
name|reply
operator|->
name|y
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_height
expr_stmt|;
name|leftcol
operator|=
operator|(
name|reply
operator|->
name|x
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_width
expr_stmt|;
name|nrows
operator|=
operator|(
name|reply
operator|->
name|y
operator|+
name|reply
operator|->
name|height
operator|-
literal|1
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_height
operator|-
name|toprow
operator|+
literal|1
expr_stmt|;
name|ncols
operator|=
operator|(
name|reply
operator|->
name|x
operator|+
name|reply
operator|->
name|width
operator|-
literal|1
operator|-
name|screen
operator|->
name|border
operator|)
operator|/
name|screen
operator|->
name|f_width
operator|-
name|leftcol
operator|+
literal|1
expr_stmt|;
name|toprow
operator|-=
name|screen
operator|->
name|scrolls
expr_stmt|;
if|if
condition|(
name|toprow
operator|<
literal|0
condition|)
block|{
name|nrows
operator|+=
name|toprow
expr_stmt|;
name|toprow
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|toprow
operator|+
name|nrows
operator|-
literal|1
operator|>
name|screen
operator|->
name|max_row
condition|)
name|nrows
operator|=
name|screen
operator|->
name|max_row
operator|-
name|toprow
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|leftcol
operator|+
name|ncols
operator|-
literal|1
operator|>
name|screen
operator|->
name|max_col
condition|)
name|ncols
operator|=
name|screen
operator|->
name|max_col
operator|-
name|leftcol
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nrows
operator|>
literal|0
operator|&&
name|ncols
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|TekEmu
operator|&&
name|reply
operator|->
name|detail
operator|!=
name|ExposeCopy
condition|)
comment|/* Clear to avoid possible dangling cursor */
name|XTileSet
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|leftcol
operator|*
name|screen
operator|->
name|f_width
operator|+
name|screen
operator|->
name|border
argument_list|,
name|toprow
operator|*
name|screen
operator|->
name|f_height
operator|+
name|screen
operator|->
name|border
argument_list|,
name|ncols
operator|*
name|screen
operator|->
name|f_width
argument_list|,
name|nrows
operator|*
name|screen
operator|->
name|f_height
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
name|ScrnRefresh
argument_list|(
name|screen
argument_list|,
name|toprow
argument_list|,
name|leftcol
argument_list|,
name|nrows
argument_list|,
name|ncols
argument_list|)
expr_stmt|;
comment|/* only do the tek refresh on the last refresh event */
if|if
condition|(
name|screen
operator|->
name|TekEmu
condition|)
block|{
name|XSync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure they are all here */
if|if
condition|(
name|XPending
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|XPeekEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|.
name|type
operator|!=
name|ExposeRegion
condition|)
block|{
if|if
condition|(
name|reply
operator|->
name|detail
operator|!=
name|ExposeCopy
condition|)
name|TekRefresh
argument_list|(
operator|&
name|term
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reply
operator|->
name|detail
operator|!=
name|ExposeCopy
condition|)
name|TekRefresh
argument_list|(
operator|&
name|term
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|screen
operator|->
name|cur_row
operator|>=
name|toprow
operator|&&
name|screen
operator|->
name|cur_row
operator|<
name|toprow
operator|+
name|nrows
operator|&&
name|screen
operator|->
name|cur_col
operator|>=
name|leftcol
operator|&&
name|screen
operator|->
name|cur_col
operator|<
name|leftcol
operator|+
name|ncols
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|Panic
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PANIC!	"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Error
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error %d: "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|Cleanup
argument_list|(
literal|66
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * cleanup by sending SIGHUP to client processes  */
end_comment

begin_macro
name|Cleanup
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|Terminal
name|term
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|screen
decl_stmt|;
specifier|register
name|long
name|pgrp
decl_stmt|;
name|screen
operator|=
operator|&
name|term
operator|.
name|screen
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|pid
operator|>
literal|1
condition|)
block|{
name|pgrp
operator|=
name|getpgrp
argument_list|(
name|screen
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgrp
operator|>
literal|1
condition|)
name|killpg
argument_list|(
name|pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sets the value of var to be arg in the Unix 4.2 BSD environment env.  * Var should end with '=' (bindings are of the form "var=value").  * This procedure assumes the memory for the first level of environ  * was allocated using malloc.  */
end_comment

begin_expr_stmt
name|Setenv
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
specifier|register
name|char
operator|*
name|var
operator|,
operator|*
name|value
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|environ
index|[
name|index
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|var
argument_list|,
name|strlen
argument_list|(
name|var
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it */
name|environ
index|[
name|index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|var
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"expanding env\n"
argument_list|)
expr_stmt|;
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|environ
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|index
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|environ
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Setenv: malloc out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|environ
index|[
name|index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|var
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|environ
index|[
operator|++
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * returns a pointer to the first occurrence of s2 in s1,  * or NULL if there are none.  */
end_comment

begin_function
name|char
modifier|*
name|strindex
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|s3
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|s3
operator|=
name|index
argument_list|(
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|s3
argument_list|,
name|s2
argument_list|,
name|strlen
argument_list|(
name|s2
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|s3
operator|)
return|;
name|s1
operator|=
operator|++
name|s3
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

end_unit

