begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985 */
end_comment

begin_comment
comment|/*  *	xwm - X Window System window manager main routine.  *  */
end_comment

begin_include
include|#
directive|include
file|"xwm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PROFIL
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_main_c
init|=
literal|"$Header: main.c,v 10.6 86/02/01 16:10:36 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Dummy handler for profiling.  */
end_comment

begin_macro
name|ptrap
argument_list|()
end_macro

begin_block
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|short
name|gray_bits
index|[
literal|16
index|]
init|=
block|{
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
comment|/* Argument count. */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Argument vector. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Loop index. */
specifier|register
name|int
name|status
decl_stmt|;
comment|/* Routine call return status. */
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* Current argument pointer. */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Mouse X and Y coordinates. */
name|int
name|str_width
decl_stmt|;
comment|/* Width in pixels of output string. */
name|int
name|pop_width
decl_stmt|,
name|pop_height
decl_stmt|;
comment|/* Pop up window width and height. */
name|int
name|temp_button_mask
init|=
literal|0
decl_stmt|;
comment|/* Temporary button event mask. */
name|char
modifier|*
name|def_val
decl_stmt|;
comment|/* X Default value. */
name|char
modifier|*
name|i_font_name
decl_stmt|;
comment|/* Icon font name. */
name|char
modifier|*
name|p_font_name
decl_stmt|;
comment|/* Pop up font name. */
name|char
name|display
index|[
literal|256
index|]
decl_stmt|;
comment|/* Display identifier string. */
name|char
name|message
index|[
literal|128
index|]
decl_stmt|;
comment|/* Error message buffer. */
name|Bitmap
name|gray_bitmap
decl_stmt|;
comment|/* Gray bitmap used for gray pixmap. */
name|Window
name|event_win
decl_stmt|;
comment|/* Event window. */
name|Window
name|focus_win
decl_stmt|;
comment|/* Keyboard focus window. */
name|WindowInfo
name|root_info
decl_stmt|;
comment|/* Root window info. */
name|XButtonEvent
name|button_event
decl_stmt|;
comment|/* Button input event. */
name|Bool
name|focus_seq
init|=
name|FALSE
decl_stmt|;
comment|/* Has a focus sequence begun? */
name|Bool
name|changed
init|=
name|FALSE
decl_stmt|;
comment|/* Has the window changed? */
name|Bool
name|none
init|=
name|FALSE
decl_stmt|;
comment|/* Allow the mouse with no keys. */
name|Bool
name|focus
init|=
name|FALSE
decl_stmt|;
comment|/* Allow input focusing? */
name|Bool
name|reverse
init|=
name|FALSE
decl_stmt|;
comment|/* Reverse video? */
ifdef|#
directive|ifdef
name|PROFIL
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|ptrap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Set up internal defaults.      */
name|i_font_name
operator|=
name|DEF_I_FONT
expr_stmt|;
name|p_font_name
operator|=
name|DEF_P_FONT
expr_stmt|;
name|CursorFunc
operator|=
name|DEF_FUNC
expr_stmt|;
name|ButtonMask
operator|=
name|DEF_BUTTON_MASK
expr_stmt|;
name|Delta
operator|=
name|DEF_DELTA
expr_stmt|;
name|IBorderWidth
operator|=
name|DEF_ICON_BORDER_WIDTH
expr_stmt|;
name|IPadding
operator|=
name|DEF_ICON_PADDING
expr_stmt|;
name|PBorderWidth
operator|=
name|DEF_POP_BORDER_WIDTH
expr_stmt|;
name|PPadding
operator|=
name|DEF_POP_PADDING
expr_stmt|;
comment|/*      * Initialize fixed globals.      */
name|Grid
operator|=
name|FALSE
expr_stmt|;
name|Zap
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Set XErrorFunction to be non-terminating.      */
name|XErrorHandler
argument_list|(
name|XError
argument_list|)
expr_stmt|;
comment|/*      * Check for X defaults.      */
name|def_val
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"IconFont"
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_val
operator|!=
name|NULL
condition|)
name|i_font_name
operator|=
name|def_val
expr_stmt|;
name|def_val
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BodyFont"
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_val
operator|!=
name|NULL
condition|)
name|p_font_name
operator|=
name|def_val
expr_stmt|;
name|def_val
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"InternalBorder"
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_val
operator|!=
name|NULL
condition|)
block|{
name|IPadding
operator|=
name|atoi
argument_list|(
name|def_val
argument_list|)
expr_stmt|;
name|PPadding
operator|=
name|atoi
argument_list|(
name|def_val
argument_list|)
expr_stmt|;
block|}
name|def_val
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BorderWidth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_val
operator|!=
name|NULL
condition|)
block|{
name|IBorderWidth
operator|=
name|atoi
argument_list|(
name|def_val
argument_list|)
expr_stmt|;
name|PBorderWidth
operator|=
name|atoi
argument_list|(
name|def_val
argument_list|)
expr_stmt|;
block|}
name|def_val
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ReverseVideo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_val
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|def_val
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|reverse
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*      * Parse the command line arguments.      */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'\0'
case|:
continue|continue;
case|case
literal|'-'
case|:
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
condition|)
break|break;
for|for
control|(
init|;
operator|*
name|arg
condition|;
name|arg
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* 			 * Add the control key to the mouse button mask. 			 */
name|temp_button_mask
operator||=
name|ControlMask
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* 			 * Check for a debug flag. 			 */
name|Debug
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* 			 * Add the shift key to the mouse button mask. 			 */
name|temp_button_mask
operator||=
name|ShiftMask
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* 			 * Add the meta key to the mouse button mask. 			 */
name|temp_button_mask
operator||=
name|MetaMask
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* 			 * No keys are needed with the mouse. 			 */
name|none
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* 			 * Require double clicking to focus input. 			 */
name|focus
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* 			 * Display the tic tac toe grid on window change. 			 */
name|Grid
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* 			 * Make icons and pop-ups reverse video. 			 */
name|reverse
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* 			 * Use zap effect? 			 */
name|Zap
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'+'
case|:
name|CursorFunc
operator|=
name|atoi
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CursorFunc
operator|<=
literal|0
operator|||
name|CursorFunc
operator|>
literal|15
condition|)
block|{
comment|/* 		 * Oops, cursor function code out of range! 		 */
name|errno
operator|=
name|EDOM
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cursor function code '%d' out of range (0 - 14)."
argument_list|,
name|CursorFunc
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'@'
case|:
name|Delta
operator|=
name|atoi
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delta
operator|<=
literal|0
operator|||
name|Delta
operator|>
literal|100
condition|)
block|{
comment|/* 		 * Oops, delta value out of range! 		 */
name|errno
operator|=
name|EDOM
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Delta value '%d' out of range (1 - 99)."
argument_list|,
name|Delta
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'='
operator|)
condition|)
block|{
name|p_font_name
operator|=
name|arg
operator|+
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'='
operator|)
condition|)
block|{
name|i_font_name
operator|=
name|arg
operator|+
literal|3
expr_stmt|;
block|}
break|break;
default|default:
comment|/* 	     * All that is left is a possible display string. 	     */
name|strcpy
argument_list|(
name|display
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Set the global mouse button event mask.      */
if|if
condition|(
name|temp_button_mask
condition|)
name|ButtonMask
operator|=
name|temp_button_mask
expr_stmt|;
if|if
condition|(
name|none
condition|)
name|ButtonMask
operator|=
literal|0
expr_stmt|;
comment|/*      * Open the Display.      */
if|if
condition|(
name|XOpenDisplay
argument_list|(
name|display
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Oops, can't open the display! 	 */
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to open display '%s'."
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/*      * Gather information about the root window.      */
name|status
operator|=
name|XQueryWindow
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|root_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
block|{
name|Error
argument_list|(
literal|"Can't acquire root window information from X server."
argument_list|)
expr_stmt|;
block|}
name|ScreenHeight
operator|=
name|root_info
operator|.
name|height
expr_stmt|;
comment|/* True height of entire screen. */
name|ScreenWidth
operator|=
name|root_info
operator|.
name|width
expr_stmt|;
comment|/* True width of entire screen. */
comment|/*      * Create and store the icon background pixmap.      */
name|gray_bitmap
operator|=
name|XStoreBitmap
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|gray_bits
argument_list|)
expr_stmt|;
name|GrayPixmap
operator|=
name|XMakePixmap
argument_list|(
name|gray_bitmap
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|)
expr_stmt|;
comment|/*      * Set up icon window, icon cursor and pop-up window color parameters.      */
if|if
condition|(
name|reverse
condition|)
block|{
name|IconCursorFunc
operator|=
name|GXcopyInverted
expr_stmt|;
name|IBorder
operator|=
name|WhitePixmap
expr_stmt|;
name|IBackground
operator|=
name|GrayPixmap
expr_stmt|;
name|ITextForground
operator|=
name|WhitePixel
expr_stmt|;
name|ITextBackground
operator|=
name|BlackPixel
expr_stmt|;
name|PBorder
operator|=
name|BlackPixmap
expr_stmt|;
name|PBackground
operator|=
name|WhitePixmap
expr_stmt|;
name|PTextForground
operator|=
name|BlackPixel
expr_stmt|;
name|PTextBackground
operator|=
name|WhitePixel
expr_stmt|;
block|}
else|else
block|{
name|IconCursorFunc
operator|=
name|GXcopy
expr_stmt|;
name|IBorder
operator|=
name|BlackPixmap
expr_stmt|;
name|IBackground
operator|=
name|GrayPixmap
expr_stmt|;
name|ITextForground
operator|=
name|BlackPixel
expr_stmt|;
name|ITextBackground
operator|=
name|WhitePixel
expr_stmt|;
name|PBorder
operator|=
name|WhitePixmap
expr_stmt|;
name|PBackground
operator|=
name|BlackPixmap
expr_stmt|;
name|PTextForground
operator|=
name|WhitePixel
expr_stmt|;
name|PTextBackground
operator|=
name|BlackPixel
expr_stmt|;
block|}
comment|/*      * Store all the cursors.      */
name|StoreCursors
argument_list|()
expr_stmt|;
comment|/*      * Grab all 3 mouse buttons w/ respect to the root window.  Grab      * pressed status with the mouse button mask.      */
name|status
operator|=
name|XGrabButton
argument_list|(
name|RootWindow
argument_list|,
name|DotCursor
argument_list|,
operator|(
name|LeftMask
operator||
name|ButtonMask
operator|)
argument_list|,
operator|(
name|ButtonPressed
operator||
name|ButtonReleased
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't grab left mouse button."
argument_list|)
expr_stmt|;
name|status
operator|=
name|XGrabButton
argument_list|(
name|RootWindow
argument_list|,
name|ArrowCrossCursor
argument_list|,
operator|(
name|MiddleMask
operator||
name|ButtonMask
operator|)
argument_list|,
operator|(
name|ButtonPressed
operator||
name|ButtonReleased
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't grab middle mouse button."
argument_list|)
expr_stmt|;
name|status
operator|=
name|XGrabButton
argument_list|(
name|RootWindow
argument_list|,
name|CircleCursor
argument_list|,
operator|(
name|RightMask
operator||
name|ButtonMask
operator|)
argument_list|,
operator|(
name|ButtonPressed
operator||
name|ButtonReleased
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't grab right mouse button."
argument_list|)
expr_stmt|;
comment|/*      * Load the selected fonts and retrieve the information structure      * for each.  Set global font information pointers.      */
name|IFont
operator|=
name|XGetFont
argument_list|(
name|i_font_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFont
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to get icon font '%s'."
argument_list|,
name|i_font_name
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|XQueryFont
argument_list|(
name|IFont
argument_list|,
operator|&
name|IFontInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
block|{
name|Error
argument_list|(
literal|"Unable to query X server for icon font information."
argument_list|)
expr_stmt|;
block|}
name|PFont
operator|=
name|XGetFont
argument_list|(
name|p_font_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|PFont
operator|==
name|FAILURE
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Unable to get pop up font '%s'."
argument_list|,
name|p_font_name
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|XQueryFont
argument_list|(
name|PFont
argument_list|,
operator|&
name|PFontInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
block|{
name|Error
argument_list|(
literal|"Unable to query X server for pop up font information."
argument_list|)
expr_stmt|;
block|}
comment|/*      * Calculate size of the resize pop-up window.      */
name|str_width
operator|=
name|XQueryWidth
argument_list|(
name|PText
argument_list|,
name|PFont
argument_list|)
expr_stmt|;
name|pop_width
operator|=
name|str_width
operator|+
operator|(
name|PPadding
operator|<<
literal|1
operator|)
expr_stmt|;
name|PWidth
operator|=
name|pop_width
operator|+
operator|(
name|PBorderWidth
operator|<<
literal|1
operator|)
expr_stmt|;
name|pop_height
operator|=
name|PFontInfo
operator|.
name|height
operator|+
operator|(
name|PPadding
operator|<<
literal|1
operator|)
expr_stmt|;
name|PHeight
operator|=
name|pop_height
operator|+
operator|(
name|PBorderWidth
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/*      * Create the pop-up window.  Create it at (0, 0) for now, we will      * move it where we want later.      */
name|Pop
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pop_width
argument_list|,
name|pop_height
argument_list|,
name|PBorderWidth
argument_list|,
name|PBorder
argument_list|,
name|PBackground
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pop
operator|==
name|FAILURE
condition|)
name|Error
argument_list|(
literal|"Can't open pop-up dimension display window."
argument_list|)
expr_stmt|;
comment|/*      * Main command loop.      */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* 	 * Get the next mouse button event.  Spin our wheels until 	 * a button event is returned (ie. GetButton == TRUE). 	 * Note that mouse events within an icon window are handled 	 * in the "GetButton" function or by the icon's owner if 	 * it is not xwm. 	 */
if|if
condition|(
operator|!
name|GetButton
argument_list|(
operator|&
name|button_event
argument_list|)
condition|)
continue|continue;
comment|/* 	 * If the button event recieved is not a ButtonPressed event 	 * then continue until we find one. 	 */
if|if
condition|(
name|button_event
operator|.
name|type
operator|!=
name|ButtonPressed
condition|)
continue|continue;
comment|/* 	 * Ok, determine the event window and mouse coordinates. 	 */
name|status
operator|=
name|XInterpretLocator
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|event_win
argument_list|,
name|button_event
operator|.
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAILURE
condition|)
continue|continue;
comment|/* 	 * If the event subwindow is 0 then the event 	 * occured on the root window. 	 */
if|if
condition|(
name|event_win
operator|==
literal|0
condition|)
block|{
name|event_win
operator|=
name|RootWindow
expr_stmt|;
block|}
comment|/* 	 * Invoke a function based on which button was pressed. 	 */
switch|switch
condition|(
name|button_event
operator|.
name|detail
operator|&
name|ValueMask
condition|)
block|{
case|case
name|LeftButton
case|:
comment|/* 		 * LeftDown is used to lower or iconify a window if 		 * the event window is not the root window.  If it is the 		 * RoowWindow then circulate all windows down. 		 */
comment|/* 		 * Abort any focus sequence that is in progress. 		 */
name|focus_seq
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|event_win
operator|==
name|RootWindow
condition|)
block|{
name|XCircWindowDown
argument_list|(
name|RootWindow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LowerIconify
argument_list|(
name|event_win
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MiddleButton
case|:
comment|/* 		 * MiddleDown is used to resize a window and establish the 		 * focus window. 		 */
comment|/* 		 * If this is not the root window, go ahead and allow it 		 * to be changed. 		 */
name|changed
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|event_win
operator|!=
name|RootWindow
condition|)
block|{
name|changed
operator|=
name|Change
argument_list|(
name|event_win
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|focus
condition|)
block|{
comment|/* 		     * Two middle clicks will focus the keyboard... 		     */
if|if
condition|(
name|focus_seq
condition|)
block|{
comment|/* 			 * ... and this is the second ... 			 */
if|if
condition|(
name|focus_win
operator|==
name|event_win
condition|)
block|{
comment|/* 			     * ... and both have the same event window then 			     * focus the keyboard provided the window did not 			     * change.  This also ends the focus sequence. 			     */
if|if
condition|(
operator|!
name|changed
condition|)
name|XFocusKeyboard
argument_list|(
name|event_win
argument_list|)
expr_stmt|;
name|focus_seq
operator|=
name|FALSE
expr_stmt|;
name|focus_win
operator|=
name|RootWindow
expr_stmt|;
block|}
else|else
block|{
comment|/* 			     * ... both don't have the same window.  This 			     * ends the focus sequence. 			     */
name|focus_seq
operator|=
name|FALSE
expr_stmt|;
name|focus_win
operator|=
name|RootWindow
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Begin a focus sequence, salt away the  			 * perspective focus window. 			 */
name|focus_seq
operator|=
name|TRUE
expr_stmt|;
name|focus_win
operator|=
name|event_win
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RightButton
case|:
comment|/* 		 * RightDown is used to move a window or bring it to the 		 * top of the window stack if the event window is not 		 * the root window.  If it is the root window then circulate 		 * all windows up. 		 */
comment|/* 		 * Abort any focus sequence that is in progress. 		 */
name|focus_seq
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|event_win
operator|==
name|RootWindow
condition|)
block|{
name|XCircWindowUp
argument_list|(
name|RootWindow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Move
argument_list|(
name|event_win
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

end_unit

