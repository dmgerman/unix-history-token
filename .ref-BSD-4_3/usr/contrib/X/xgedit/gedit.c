begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1984, 1985	*/
end_comment

begin_include
include|#
directive|include
file|"gedit.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_gedit_c
init|=
literal|"$Header: gedit.c,v 10.6 86/02/01 16:18:53 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|gentry
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|state
name|cur_state
init|=
block|{
comment|/* everything about what we are doing */
name|NULL
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*extern char Aborted;*/
end_comment

begin_decl_stmt
name|struct
name|prototype
modifier|*
name|directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|incol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current text prompt column */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what the current user prompt is */
end_comment

begin_decl_stmt
name|char
name|typein
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user input buffer */
end_comment

begin_decl_stmt
name|char
name|ocomp
index|[
literal|8
index|]
index|[
literal|8
index|]
init|=
comment|/* orientation composition matrix */
block|{
name|NORTH
block|,
name|EAST
block|,
name|SOUTH
block|,
name|WEST
block|,
name|RNORTH
block|,
name|REAST
block|,
name|RSOUTH
block|,
name|RWEST
block|,
name|EAST
block|,
name|SOUTH
block|,
name|WEST
block|,
name|NORTH
block|,
name|RWEST
block|,
name|RNORTH
block|,
name|REAST
block|,
name|RSOUTH
block|,
name|SOUTH
block|,
name|WEST
block|,
name|NORTH
block|,
name|EAST
block|,
name|RSOUTH
block|,
name|RWEST
block|,
name|RNORTH
block|,
name|REAST
block|,
name|WEST
block|,
name|NORTH
block|,
name|EAST
block|,
name|SOUTH
block|,
name|REAST
block|,
name|RSOUTH
block|,
name|RWEST
block|,
name|RNORTH
block|,
name|RNORTH
block|,
name|REAST
block|,
name|RSOUTH
block|,
name|RWEST
block|,
name|NORTH
block|,
name|EAST
block|,
name|SOUTH
block|,
name|WEST
block|,
name|REAST
block|,
name|RSOUTH
block|,
name|RWEST
block|,
name|RNORTH
block|,
name|WEST
block|,
name|NORTH
block|,
name|EAST
block|,
name|SOUTH
block|,
name|RSOUTH
block|,
name|RWEST
block|,
name|RNORTH
block|,
name|REAST
block|,
name|SOUTH
block|,
name|WEST
block|,
name|NORTH
block|,
name|EAST
block|,
name|RWEST
block|,
name|RNORTH
block|,
name|REAST
block|,
name|RSOUTH
block|,
name|EAST
block|,
name|SOUTH
block|,
name|WEST
block|,
name|NORTH
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lcomp
index|[
literal|8
index|]
index|[
literal|9
index|]
init|=
comment|/* orient& label composition matrix */
block|{
name|CC
block|,
name|TC
block|,
name|BC
block|,
name|CL
block|,
name|TL
block|,
name|BL
block|,
name|CR
block|,
name|TR
block|,
name|BR
block|,
comment|/* north */
name|CC
block|,
name|CR
block|,
name|CL
block|,
name|TC
block|,
name|TR
block|,
name|TL
block|,
name|BC
block|,
name|BR
block|,
name|BL
block|,
comment|/* east */
name|CC
block|,
name|BC
block|,
name|TC
block|,
name|CR
block|,
name|BR
block|,
name|TR
block|,
name|CL
block|,
name|BL
block|,
name|TL
block|,
comment|/* south */
name|CC
block|,
name|CL
block|,
name|CR
block|,
name|BC
block|,
name|BL
block|,
name|BR
block|,
name|TC
block|,
name|TL
block|,
name|TR
block|,
comment|/* west */
name|CC
block|,
name|TC
block|,
name|BC
block|,
name|CR
block|,
name|TR
block|,
name|BR
block|,
name|CL
block|,
name|TL
block|,
name|BL
block|,
comment|/* rnorth */
name|CC
block|,
name|CL
block|,
name|CR
block|,
name|TC
block|,
name|TL
block|,
name|TR
block|,
name|BC
block|,
name|BL
block|,
name|BR
block|,
comment|/* reast */
name|CC
block|,
name|BC
block|,
name|TC
block|,
name|CL
block|,
name|BL
block|,
name|TL
block|,
name|CR
block|,
name|BR
block|,
name|TR
block|,
comment|/* rsouth */
name|CC
block|,
name|CR
block|,
name|CL
block|,
name|BC
block|,
name|BR
block|,
name|BL
block|,
name|TC
block|,
name|TR
block|,
name|TL
comment|/* rwest */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lorient
index|[]
init|=
block|{
literal|"cc"
block|,
literal|"tc"
block|,
literal|"bc"
block|,
literal|"cl"
block|,
literal|"tl"
block|,
literal|"bl"
block|,
literal|"cr"
block|,
literal|"tr"
block|,
literal|"br"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|oorient
index|[]
init|=
block|{
literal|"n"
block|,
literal|"e"
block|,
literal|"s"
block|,
literal|"w"
block|,
literal|"rn"
block|,
literal|"re"
block|,
literal|"rs"
block|,
literal|"rw"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read a coordinate from the input file */
end_comment

begin_function
name|short
name|read_coord
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|short
name|coord
init|=
literal|0
decl_stmt|;
name|char
name|sign
init|=
literal|0
decl_stmt|;
comment|/* skip over leading blanks */
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|<=
literal|' '
operator|&&
name|ch
operator|!=
name|EOF
condition|)
empty_stmt|;
comment|/* look for negative coord */
if|if
condition|(
name|ch
operator|==
literal|'~'
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* read in the number itself */
while|while
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|coord
operator|*=
literal|10
expr_stmt|;
name|coord
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sign
condition|?
operator|-
name|coord
else|:
name|coord
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read a token from the input file */
end_comment

begin_macro
name|read_token
argument_list|(
argument|f
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ch
decl_stmt|;
comment|/* skip over leading blanks */
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|<=
literal|' '
operator|&&
name|ch
operator|!=
name|EOF
condition|)
empty_stmt|;
comment|/* read in the number itself */
while|while
condition|(
name|ch
operator|>
literal|' '
operator|&&
name|ch
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'~'
condition|)
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* embedded blank */
else|else
operator|*
name|t
operator|++
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* read a .def file and return pointer to linked list of objects.  For now,  * not much error checking is done...  */
end_comment

begin_function
name|struct
name|prototype
modifier|*
name|read_def
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|gptr
name|p
decl_stmt|;
name|struct
name|prototype
modifier|*
name|d
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|char
name|token
index|[
literal|200
index|]
decl_stmt|,
name|iname
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|short
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
comment|/* see if we've already got a copy in core */
for|for
control|(
name|d
operator|=
name|directory
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|d
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|d
operator|)
return|;
comment|/* new widget, set up directory entry */
name|d
operator|=
operator|(
expr|struct
name|prototype
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|prototype
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|recent
operator|=
name|cur_state
expr_stmt|;
comment|/* Copy current parameters. */
name|d
operator|->
name|recent
operator|.
name|curobj
operator|=
name|d
expr_stmt|;
name|d
operator|->
name|recent
operator|.
name|editee
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|recent
operator|.
name|curx
operator|=
name|d
operator|->
name|recent
operator|.
name|cury
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|recent
operator|.
name|oldx
operator|=
name|d
operator|->
name|recent
operator|.
name|oldy
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|recent
operator|.
name|lxoff
operator|=
name|d
operator|->
name|recent
operator|.
name|lyoff
operator|=
literal|0
expr_stmt|;
name|new_window
argument_list|(
operator|&
name|d
operator|->
name|recent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|directory
expr_stmt|;
name|directory
operator|=
name|d
expr_stmt|;
name|d
operator|->
name|name
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|body
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|iname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|iname
argument_list|,
literal|".def"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|iname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|d
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"reading in %s"
argument_list|,
name|iname
argument_list|)
expr_stmt|;
name|msg
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* read through file processing commands */
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'|'
case|:
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
empty_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|read_token
argument_list|(
name|in
argument_list|,
name|token
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
goto|goto
name|done
goto|;
case|case
literal|'m'
case|:
name|x1
operator|=
name|read_coord
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|y1
operator|=
name|read_coord
argument_list|(
name|in
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
case|case
literal|'l'
case|:
name|x2
operator|=
name|read_coord
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|y2
operator|=
name|read_coord
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'A'
condition|)
name|read_token
argument_list|(
name|in
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* angle */
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|gptr
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|segment
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p
operator|->
name|s
operator|.
name|type
operator|=
name|SEGMENT
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|selink
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|next
operator|=
name|d
operator|->
name|body
expr_stmt|;
name|d
operator|->
name|body
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|parent
operator|=
name|d
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x1
operator|=
name|x1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y1
operator|=
name|y1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x2
operator|=
name|x2
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y2
operator|=
name|y2
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'A'
condition|)
name|p
operator|->
name|s
operator|.
name|angle
operator|=
name|atoi
argument_list|(
name|token
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|s
operator|.
name|angle
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|cache
operator|=
name|NULL
expr_stmt|;
name|newalist
argument_list|(
operator|&
name|p
operator|->
name|s
argument_list|,
name|p
operator|->
name|s
operator|.
name|x1
argument_list|,
name|p
operator|->
name|s
operator|.
name|y1
argument_list|,
name|p
operator|->
name|s
operator|.
name|x2
argument_list|,
name|p
operator|->
name|s
operator|.
name|y2
argument_list|)
expr_stmt|;
name|x1
operator|=
name|x2
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|read_token
argument_list|(
name|in
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* label orientation */
name|x2
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|y2
operator|=
name|token
index|[
literal|1
index|]
expr_stmt|;
name|read_token
argument_list|(
name|in
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* the label itself */
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|gptr
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p
operator|->
name|l
operator|.
name|type
operator|=
name|LABEL
expr_stmt|;
name|p
operator|->
name|l
operator|.
name|selink
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|l
operator|.
name|next
operator|=
name|d
operator|->
name|body
expr_stmt|;
name|d
operator|->
name|body
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|l
operator|.
name|parent
operator|=
name|d
expr_stmt|;
name|p
operator|->
name|l
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|p
operator|->
name|l
operator|.
name|y
operator|=
name|y1
expr_stmt|;
switch|switch
condition|(
name|x2
condition|)
block|{
default|default:
case|case
literal|'c'
case|:
name|x2
operator|=
name|CC
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|x2
operator|=
name|TC
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|x2
operator|=
name|BC
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|y2
condition|)
block|{
default|default:
case|case
literal|'c'
case|:
name|p
operator|->
name|l
operator|.
name|orient
operator|=
name|CC
operator|+
name|x2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|p
operator|->
name|l
operator|.
name|orient
operator|=
name|CL
operator|+
name|x2
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|p
operator|->
name|l
operator|.
name|orient
operator|=
name|CR
operator|+
name|x2
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|l
operator|.
name|string
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|,
name|token
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|read_token
argument_list|(
name|in
argument_list|,
name|iname
argument_list|)
expr_stmt|;
comment|/* name of file */
comment|/* next is "___" or scale factor */
name|read_token
argument_list|(
name|in
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|token
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%hd:%hd"
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|y2
argument_list|)
expr_stmt|;
else|else
name|x2
operator|=
name|y2
operator|=
literal|1
expr_stmt|;
name|read_token
argument_list|(
name|in
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* orientation */
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|gptr
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p
operator|->
name|o
operator|.
name|type
operator|=
name|OBJECT
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|selink
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|next
operator|=
name|d
operator|->
name|body
expr_stmt|;
name|d
operator|->
name|body
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|parent
operator|=
name|d
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|y
operator|=
name|y1
expr_stmt|;
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
name|p
operator|->
name|o
operator|.
name|orient
operator|=
name|RNORTH
expr_stmt|;
name|token
index|[
literal|0
index|]
operator|=
name|token
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|p
operator|->
name|o
operator|.
name|orient
operator|=
name|NORTH
expr_stmt|;
switch|switch
condition|(
name|token
index|[
literal|0
index|]
condition|)
block|{
default|default:
case|case
literal|'n'
case|:
name|ch
operator|=
name|NORTH
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|ch
operator|=
name|EAST
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ch
operator|=
name|SOUTH
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ch
operator|=
name|WEST
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|o
operator|.
name|orient
operator|=
name|ocomp
index|[
name|p
operator|->
name|o
operator|.
name|orient
index|]
index|[
name|ch
index|]
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|proto
operator|=
name|read_def
argument_list|(
name|iname
argument_list|)
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|mscale
operator|=
name|x2
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|dscale
operator|=
name|y2
expr_stmt|;
continue|continue;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: unrecognized .def command: 0%o, ESC continues..."
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|userinput
argument_list|(
literal|""
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|done
label|:
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|clearprompt
argument_list|()
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* print .def file coordinate */
end_comment

begin_macro
name|pcoord
argument_list|(
argument|f
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" ~%d"
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* write out a object list */
end_comment

begin_expr_stmt
name|write_defn
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|prototype
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|gptr
name|o
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|temp
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
literal|".def"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cannot open %s for output, ESC continues..."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|userinput
argument_list|(
literal|""
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing out %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|msg
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"d main\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|p
operator|->
name|body
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|s
operator|.
name|next
control|)
block|{
name|putc
argument_list|(
literal|'m'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pcoord
argument_list|(
name|out
argument_list|,
name|o
operator|->
name|s
operator|.
name|x1
argument_list|)
expr_stmt|;
name|pcoord
argument_list|(
name|out
argument_list|,
name|o
operator|->
name|s
operator|.
name|y1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|SEGMENT
case|:
if|if
condition|(
name|o
operator|->
name|s
operator|.
name|angle
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'l'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pcoord
argument_list|(
name|out
argument_list|,
name|o
operator|->
name|s
operator|.
name|x2
argument_list|)
expr_stmt|;
name|pcoord
argument_list|(
name|out
argument_list|,
name|o
operator|->
name|s
operator|.
name|y2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'A'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pcoord
argument_list|(
name|out
argument_list|,
name|o
operator|->
name|s
operator|.
name|x2
argument_list|)
expr_stmt|;
name|pcoord
argument_list|(
name|out
argument_list|,
name|o
operator|->
name|s
operator|.
name|y2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %d"
argument_list|,
name|o
operator|->
name|s
operator|.
name|angle
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LABEL
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"c %s "
argument_list|,
name|lorient
index|[
name|o
operator|->
name|l
operator|.
name|orient
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|o
operator|->
name|l
operator|.
name|string
init|;
operator|*
name|s
condition|;
name|s
operator|+=
literal|1
control|)
name|putc
argument_list|(
operator|*
name|s
operator|==
literal|' '
condition|?
literal|'~'
else|:
operator|*
name|s
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJECT
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"i %s %d:%d %s"
argument_list|,
name|o
operator|->
name|o
operator|.
name|proto
operator|->
name|name
argument_list|,
name|o
operator|->
name|o
operator|.
name|mscale
argument_list|,
name|o
operator|->
name|o
operator|.
name|dscale
argument_list|,
name|oorient
index|[
name|o
operator|->
name|o
operator|.
name|orient
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"e\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|clearprompt
argument_list|()
expr_stmt|;
name|p
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
comment|/* we've saved away changes */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* remove an object from its prototype and reclaim its storage */
end_comment

begin_expr_stmt
name|rmalist
argument_list|(
name|q
argument_list|)
specifier|register
name|gptr
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|gptr
name|r
decl_stmt|;
for|for
control|(
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|r
control|)
block|{
name|r
operator|=
name|q
operator|->
name|s
operator|.
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|remove
argument_list|(
name|p
argument_list|)
specifier|register
name|gptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|gptr
name|q
decl_stmt|;
name|p
operator|->
name|s
operator|.
name|parent
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|->
name|s
operator|.
name|parent
operator|->
name|body
operator|)
operator|==
name|p
condition|)
name|p
operator|->
name|s
operator|.
name|parent
operator|->
name|body
operator|=
name|p
operator|->
name|s
operator|.
name|next
expr_stmt|;
else|else
block|{
while|while
condition|(
name|q
operator|->
name|s
operator|.
name|next
operator|!=
name|p
operator|&&
name|q
operator|!=
name|NULL
condition|)
name|q
operator|=
name|q
operator|->
name|s
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|q
operator|->
name|s
operator|.
name|next
operator|=
name|p
operator|->
name|s
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|type
operator|==
name|LABEL
condition|)
name|free
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|type
operator|==
name|SEGMENT
condition|)
name|rmalist
argument_list|(
name|p
operator|->
name|s
operator|.
name|cache
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|struct
name|prototype
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|fname
operator|=
name|gentry
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* initialize display and keyboard */
name|prompt
operator|=
name|NULL
expr_stmt|;
comment|/* not reading anything from user */
name|typein
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|directory
operator|=
name|NULL
expr_stmt|;
name|cur_state
operator|.
name|mscale
operator|=
literal|1
expr_stmt|;
comment|/* initial state settings */
name|cur_state
operator|.
name|dscale
operator|=
literal|4
expr_stmt|;
name|cur_state
operator|.
name|csize
operator|=
literal|16
expr_stmt|;
name|cur_state
operator|.
name|grid
operator|=
literal|0
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
comment|/* start with a fresh slate */
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|again
label|:
do|do
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
literal|"name of definition to edit: "
argument_list|)
condition|)
goto|goto
name|done
goto|;
do|while
condition|(
name|typein
index|[
literal|0
index|]
operator|==
literal|0
condition|)
do|;
name|d
operator|=
name|read_def
argument_list|(
name|typein
argument_list|)
expr_stmt|;
block|}
else|else
name|d
operator|=
name|read_def
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|d
operator|->
name|recent
expr_stmt|;
comment|/* Restore state at last edit */
name|redisplay
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|extern
name|char
name|mousechanged
decl_stmt|;
if|if
condition|(
name|mousechanged
operator|||
name|UserReady
argument_list|()
condition|)
block|{
if|if
condition|(
name|command
argument_list|()
condition|)
break|break;
block|}
else|else
block|{
name|DpyUp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|recent
operator|=
name|cur_state
expr_stmt|;
comment|/* check to see if we should write anything out */
for|for
control|(
name|d
operator|=
name|directory
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|modified
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s has not been written out, should it be? (y,n) "
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
name|buf
argument_list|)
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|typein
index|[
literal|0
index|]
operator|==
literal|'y'
condition|)
if|if
condition|(
name|write_defn
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|again
goto|;
block|}
comment|/* return to system */
name|done
label|:
name|gexit
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

