begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1984, 1985	*/
end_comment

begin_include
include|#
directive|include
file|"gedit.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_garc_c
init|=
literal|"$Header: garc.c,v 10.5 86/02/01 16:18:41 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* arc drawing routines */
end_comment

begin_decl_stmt
name|double
name|sqrt
argument_list|()
decl_stmt|,
name|atan2
argument_list|()
decl_stmt|,
name|sin
argument_list|()
decl_stmt|,
name|cos
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* construct a line object */
end_comment

begin_function
name|gptr
name|mline
parameter_list|(
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|next
parameter_list|)
name|gptr
name|next
decl_stmt|;
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|gptr
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|segment
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
name|p
operator|->
name|s
operator|.
name|type
operator|=
name|SEGMENT
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|parent
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x1
operator|=
name|x1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y1
operator|=
name|y1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x2
operator|=
name|x2
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y2
operator|=
name|y2
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|angle
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|cache
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* rounds the double x off to an integer */
end_comment

begin_function
name|int
name|round
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0.0
condition|)
name|i
operator|=
name|x
operator|+
literal|0.5
expr_stmt|;
else|else
name|i
operator|=
name|x
operator|-
literal|0.5
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compute center from arc end point and radius */
end_comment

begin_macro
name|circcent
argument_list|(
argument|ang
argument_list|,
argument|fx
argument_list|,
argument|fy
argument_list|,
argument|tx
argument_list|,
argument|ty
argument_list|,
argument|xcp
argument_list|,
argument|ycp
argument_list|,
argument|rp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ang
decl_stmt|,
name|fx
decl_stmt|,
name|fy
decl_stmt|,
name|tx
decl_stmt|,
name|ty
decl_stmt|,
modifier|*
name|xcp
decl_stmt|,
modifier|*
name|ycp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
modifier|*
name|rp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|xx
decl_stmt|,
name|yy
decl_stmt|,
name|ss
decl_stmt|,
name|dd
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|xx
operator|=
name|tx
operator|-
name|fx
expr_stmt|;
name|yy
operator|=
name|ty
operator|-
name|fy
expr_stmt|;
name|dd
operator|=
name|sqrt
argument_list|(
name|xx
operator|*
name|xx
operator|+
name|yy
operator|*
name|yy
argument_list|)
expr_stmt|;
comment|/* length of chord */
if|if
condition|(
name|dd
operator|==
literal|0
condition|)
block|{
operator|*
name|xcp
operator|=
name|fx
expr_stmt|;
operator|*
name|ycp
operator|=
name|fy
expr_stmt|;
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* radius of arc */
operator|*
name|rp
operator|=
name|dd
operator|/
operator|(
literal|2.0
operator|*
name|sin
argument_list|(
literal|3.141592653
operator|*
name|ang
operator|/
literal|2048.0
argument_list|)
operator|)
expr_stmt|;
comment|/* length of perpendicular to chord */
name|ss
operator|=
name|sqrt
argument_list|(
operator|(
operator|*
name|rp
operator|)
operator|*
operator|(
operator|*
name|rp
operator|)
operator|-
name|dd
operator|*
name|dd
operator|/
literal|4.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ang
operator|>
literal|1024
condition|)
name|ss
operator|=
operator|-
name|ss
expr_stmt|;
name|x1
operator|=
operator|(
name|tx
operator|+
name|fx
operator|)
operator|/
literal|2.0
expr_stmt|;
comment|/* compute center point of chord */
name|y1
operator|=
operator|(
name|ty
operator|+
name|fy
operator|)
operator|/
literal|2.0
expr_stmt|;
name|x1
operator|-=
name|yy
operator|*
name|ss
operator|/
name|dd
expr_stmt|;
comment|/* now compute center of circle */
name|y1
operator|+=
name|xx
operator|*
name|ss
operator|/
name|dd
expr_stmt|;
operator|*
name|xcp
operator|=
name|round
argument_list|(
name|x1
argument_list|)
expr_stmt|;
operator|*
name|ycp
operator|=
name|round
argument_list|(
name|y1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* calculate new arc list */
end_comment

begin_expr_stmt
name|newalist
argument_list|(
name|p
argument_list|,
name|xa
argument_list|,
name|ya
argument_list|,
name|xb
argument_list|,
name|yb
argument_list|)
specifier|register
expr|struct
name|segment
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|double
name|xx
decl_stmt|,
name|yy
decl_stmt|,
name|aa
decl_stmt|,
name|bb
decl_stmt|;
name|double
name|ainc
decl_stmt|,
name|r
decl_stmt|;
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|,
name|xc
decl_stmt|,
name|yc
decl_stmt|;
name|int
name|wherex
decl_stmt|,
name|wherey
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|cache
operator|!=
name|NULL
condition|)
block|{
name|rmalist
argument_list|(
name|p
operator|->
name|cache
argument_list|)
expr_stmt|;
name|p
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|angle
operator|==
literal|0
condition|)
return|return;
name|circcent
argument_list|(
name|p
operator|->
name|angle
argument_list|,
name|xa
argument_list|,
name|ya
argument_list|,
name|xb
argument_list|,
name|yb
argument_list|,
operator|&
name|xc
argument_list|,
operator|&
name|yc
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|2.0
condition|)
block|{
name|p
operator|->
name|cache
operator|=
name|mline
argument_list|(
name|xa
operator|-
literal|1
argument_list|,
name|ya
operator|-
literal|1
argument_list|,
name|xa
operator|+
literal|1
argument_list|,
name|ya
operator|-
literal|1
argument_list|,
name|p
operator|->
name|cache
argument_list|)
expr_stmt|;
name|p
operator|->
name|cache
operator|=
name|mline
argument_list|(
name|xa
operator|-
literal|1
argument_list|,
name|ya
argument_list|,
name|xa
operator|+
literal|1
argument_list|,
name|ya
argument_list|,
name|p
operator|->
name|cache
argument_list|)
expr_stmt|;
name|p
operator|->
name|cache
operator|=
name|mline
argument_list|(
name|xa
operator|-
literal|1
argument_list|,
name|ya
operator|+
literal|1
argument_list|,
name|xa
operator|+
literal|1
argument_list|,
name|ya
operator|+
literal|1
argument_list|,
name|p
operator|->
name|cache
argument_list|)
expr_stmt|;
return|return;
block|}
name|xx
operator|=
name|xa
operator|-
name|xc
expr_stmt|;
name|yy
operator|=
name|ya
operator|-
name|yc
expr_stmt|;
name|aa
operator|=
name|atan2
argument_list|(
name|yy
argument_list|,
name|xx
argument_list|)
expr_stmt|;
name|xx
operator|=
name|xb
operator|-
name|xc
expr_stmt|;
name|yy
operator|=
name|yb
operator|-
name|yc
expr_stmt|;
name|bb
operator|=
name|atan2
argument_list|(
name|yy
argument_list|,
name|xx
argument_list|)
expr_stmt|;
comment|/* put aa and bb into proper relationship */
comment|/*	if (p->angle<= 1024) { */
if|if
condition|(
name|aa
operator|>
name|bb
condition|)
name|bb
operator|+=
literal|2
operator|*
literal|3.141592653
expr_stmt|;
comment|/*	} else { 	  if (bb> aa) aa += 2*3.141592653; 	} */
comment|/* usually 32 lines/arc, but use enough to ensure that there would 	 * be at least 100 segments for a full circle. 	 */
name|ainc
operator|=
operator|(
name|bb
operator|-
name|aa
operator|)
operator|/
literal|32.0
expr_stmt|;
if|if
condition|(
name|ainc
operator|>
literal|0.628
condition|)
name|ainc
operator|=
literal|0.628
expr_stmt|;
elseif|else
if|if
condition|(
name|ainc
operator|<
operator|-
literal|0.628
condition|)
name|ainc
operator|=
operator|-
literal|0.628
expr_stmt|;
name|wherex
operator|=
name|xa
expr_stmt|;
name|wherey
operator|=
name|ya
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ix
operator|=
name|xc
operator|+
name|r
operator|*
name|cos
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|iy
operator|=
name|yc
operator|+
name|r
operator|*
name|sin
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|p
operator|->
name|cache
operator|=
name|mline
argument_list|(
name|wherex
argument_list|,
name|wherey
argument_list|,
name|ix
argument_list|,
name|iy
argument_list|,
name|p
operator|->
name|cache
argument_list|)
expr_stmt|;
name|wherex
operator|=
name|ix
expr_stmt|;
name|wherey
operator|=
name|iy
expr_stmt|;
name|aa
operator|+=
name|ainc
expr_stmt|;
if|if
condition|(
operator|(
name|ainc
operator|<
literal|0
operator|&&
name|aa
operator|<=
name|bb
operator|)
operator|||
operator|(
name|ainc
operator|>=
literal|0
operator|&&
name|aa
operator|>=
name|bb
operator|)
condition|)
break|break;
block|}
empty_stmt|;
name|p
operator|->
name|cache
operator|=
name|mline
argument_list|(
name|wherex
argument_list|,
name|wherey
argument_list|,
name|xb
argument_list|,
name|yb
argument_list|,
name|p
operator|->
name|cache
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

