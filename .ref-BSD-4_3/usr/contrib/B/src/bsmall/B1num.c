begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: B1num.c,v 1.1 84/06/28 00:48:56 timo Exp $ */
end_comment

begin_comment
comment|/* B numbers, small version */
end_comment

begin_comment
comment|/* 	 * THIS VERSION SHOULD ONLY BE USED IF 	 * THE SYSTEM IS TOO LARGE OTHERWISE. 	 * IT USES FLOATING POINT ARITHMETIC FOR EXACT NUMBERS 	 * INSTEAD OF ARBITRARY LENGTH RATIONAL ARITHMETIC. 	 */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_comment
comment|/* for def of Keymark() only */
end_comment

begin_include
include|#
directive|include
file|"B1num.h"
end_include

begin_function
name|value
name|numerator
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|Checknum
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
literal|"*/ on approximate number"
argument_list|)
expr_stmt|;
return|return
name|mk_int
argument_list|(
name|Numerator
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|denominator
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|Checknum
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
literal|"/* on approximate number"
argument_list|)
expr_stmt|;
comment|/* */
return|return
name|mk_int
argument_list|(
name|Denominator
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|double
name|numval
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|Checknum
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|Numval
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_macro
name|checkint
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|value
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Checknum
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|Denominator
argument_list|(
name|v
argument_list|)
operator|!=
name|One
condition|)
name|error
argument_list|(
literal|"number not an integer"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|bool
name|large
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|checkint
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|Numerator
argument_list|(
name|v
argument_list|)
operator|<
operator|-
name|Maxint
operator|||
name|Numerator
argument_list|(
name|v
argument_list|)
operator|>
name|Maxint
condition|)
return|return
name|Yes
return|;
return|return
name|No
return|;
block|}
end_function

begin_function
name|int
name|intval
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|checkint
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|Numerator
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|intlet
name|propintlet
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
operator|-
name|Maxintlet
operator|||
name|i
operator|>
name|Maxintlet
condition|)
name|error
argument_list|(
literal|"exceedingly large integer"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|integer
name|gcd
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|integer
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|integer
name|k
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|Zero
operator|&&
name|j
operator|==
name|Zero
condition|)
name|syserr
argument_list|(
literal|"gcd(0, 0)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|floor
argument_list|(
name|i
argument_list|)
operator|||
name|j
operator|!=
name|floor
argument_list|(
name|j
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"gcd called with non-integer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|Zero
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|Zero
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|j
condition|)
block|{
name|k
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
while|while
condition|(
name|j
operator|>=
name|One
condition|)
block|{
name|k
operator|=
name|i
operator|-
name|j
operator|*
name|floor
argument_list|(
name|i
operator|/
name|j
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|Zero
condition|)
name|error
argument_list|(
literal|"arithmetic overflow while simplifying exact number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|floor
argument_list|(
name|i
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"gcd returns non-integer"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_decl_stmt
name|value
name|b_zero
decl_stmt|,
name|b_one
decl_stmt|,
name|b_minus_one
decl_stmt|,
name|zero
decl_stmt|,
name|one
decl_stmt|;
end_decl_stmt

begin_function
name|value
name|mk_exact
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|,
name|len
parameter_list|)
specifier|register
name|integer
name|p
decl_stmt|,
name|q
decl_stmt|;
name|intlet
name|len
decl_stmt|;
block|{
name|value
name|v
decl_stmt|;
name|integer
name|d
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|One
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|Zero
condition|)
return|return
name|copy
argument_list|(
name|b_zero
argument_list|)
return|;
if|if
condition|(
name|p
operator|==
name|One
condition|)
return|return
name|copy
argument_list|(
name|b_one
argument_list|)
return|;
if|if
condition|(
name|p
operator|==
operator|-
name|One
condition|)
return|return
name|copy
argument_list|(
name|b_minus_one
argument_list|)
return|;
block|}
name|v
operator|=
name|grab_num
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|One
condition|)
block|{
name|Numerator
argument_list|(
name|v
argument_list|)
operator|=
name|p
expr_stmt|;
name|Denominator
argument_list|(
name|v
argument_list|)
operator|=
name|q
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
name|q
operator|==
name|Zero
condition|)
name|error
argument_list|(
literal|"attempt to make exact number with denominator 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|<
name|Zero
condition|)
block|{
name|p
operator|=
operator|-
name|p
expr_stmt|;
name|q
operator|=
operator|-
name|q
expr_stmt|;
block|}
name|d
operator|=
operator|(
name|q
operator|==
name|One
condition|?
name|One
else|:
name|p
operator|==
name|One
condition|?
name|One
else|:
name|gcd
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
operator|)
expr_stmt|;
name|Numerator
argument_list|(
name|v
argument_list|)
operator|=
name|p
operator|/
name|d
expr_stmt|;
name|Denominator
argument_list|(
name|v
argument_list|)
operator|=
name|q
operator|/
name|d
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|bool
name|integral
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|Integral
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|mk_integer
parameter_list|(
name|p
parameter_list|)
name|int
name|p
decl_stmt|;
block|{
return|return
name|mk_exact
argument_list|(
operator|(
name|integer
operator|)
name|p
argument_list|,
name|One
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|mk_int
parameter_list|(
name|p
parameter_list|)
name|integer
name|p
decl_stmt|;
block|{
return|return
name|mk_exact
argument_list|(
name|p
argument_list|,
name|One
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|mk_approx
parameter_list|(
name|x
parameter_list|)
specifier|register
name|double
name|x
decl_stmt|;
block|{
name|value
name|v
init|=
name|grab_num
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Approxval
argument_list|(
name|v
argument_list|)
operator|=
name|x
expr_stmt|;
name|Denominator
argument_list|(
name|v
argument_list|)
operator|=
name|Zero
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_macro
name|initnum
argument_list|()
end_macro

begin_block
block|{
name|b_zero
operator|=
name|grab_num
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Numerator
argument_list|(
name|b_zero
argument_list|)
operator|=
name|Zero
expr_stmt|;
name|Denominator
argument_list|(
name|b_zero
argument_list|)
operator|=
name|One
expr_stmt|;
name|b_one
operator|=
name|grab_num
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Numerator
argument_list|(
name|b_one
argument_list|)
operator|=
name|One
expr_stmt|;
name|Denominator
argument_list|(
name|b_one
argument_list|)
operator|=
name|One
expr_stmt|;
name|b_minus_one
operator|=
name|grab_num
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Numerator
argument_list|(
name|b_minus_one
argument_list|)
operator|=
operator|-
name|One
expr_stmt|;
name|Denominator
argument_list|(
name|b_minus_one
argument_list|)
operator|=
name|One
expr_stmt|;
name|zero
operator|=
name|mk_integer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|one
operator|=
name|mk_integer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|value
name|approximate
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|copy
argument_list|(
name|v
argument_list|)
return|;
return|return
name|mk_approx
argument_list|(
name|Numerator
argument_list|(
name|v
argument_list|)
operator|/
name|Denominator
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_macro
name|numcomp
argument_list|(
argument|v
argument_list|,
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|vv
init|=
name|Numval
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|ww
init|=
name|Numval
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|vv
operator|<
name|ww
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|vv
operator|>
name|ww
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|Exact
argument_list|(
name|v
argument_list|)
operator|&&
name|Exact
argument_list|(
name|w
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 1< 1E0 */
if|if
condition|(
name|Exact
argument_list|(
name|w
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* 1E0> 1 */
return|return
literal|0
return|;
block|}
end_block

begin_function
name|double
name|numhash
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|number
modifier|*
name|n
init|=
operator|(
name|number
operator|*
operator|)
name|Ats
argument_list|(
name|v
argument_list|)
decl_stmt|;
return|return
literal|.123
operator|*
name|n
operator|->
name|p
operator|+
literal|.777
operator|*
name|n
operator|->
name|q
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CONVBUFSIZ
value|100
end_define

begin_decl_stmt
name|char
name|convbuf
index|[
name|CONVBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|string
name|convnum
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|double
name|x
decl_stmt|;
name|string
name|bp
decl_stmt|;
name|bool
name|prec_loss
init|=
name|No
decl_stmt|;
name|Checknum
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|x
operator|=
name|Numval
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|conv
label|:
if|if
condition|(
operator|!
name|prec_loss
operator|&&
name|Exact
argument_list|(
name|v
argument_list|)
operator|&&
name|fabs
argument_list|(
name|x
argument_list|)
operator|<=
name|LONG
operator|&&
name|fabs
argument_list|(
name|Numerator
argument_list|(
name|v
argument_list|)
argument_list|)
operator|<
name|BIG
operator|&&
name|fabs
argument_list|(
name|Denominator
argument_list|(
name|v
argument_list|)
argument_list|)
operator|<
name|BIG
condition|)
block|{
name|intlet
name|len
init|=
literal|0
operator|<
name|Length
argument_list|(
name|v
argument_list|)
operator|&&
name|Length
argument_list|(
name|v
argument_list|)
operator|<=
name|MAXNUMDIG
condition|?
name|Length
argument_list|(
name|v
argument_list|)
else|:
literal|0
decl_stmt|;
name|intlet
name|dcnt
decl_stmt|,
name|sigcnt
decl_stmt|;
name|bool
name|sig
decl_stmt|;
if|if
condition|(
name|Denominator
argument_list|(
name|v
argument_list|)
operator|!=
name|One
condition|)
block|{
name|intlet
name|k
decl_stmt|;
name|double
name|p
init|=
literal|1.0
decl_stmt|,
name|q
decl_stmt|;
name|prec_loss
operator|=
name|Yes
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|MAXNUMDIG
condition|;
name|k
operator|++
control|)
block|{
name|p
operator|*=
literal|10.0
expr_stmt|;
name|q
operator|=
name|p
operator|/
name|Denominator
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|len
operator|&&
name|q
operator|==
name|floor
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|prec_loss
operator|=
name|No
expr_stmt|;
break|break;
block|}
block|}
name|len
operator|=
name|k
expr_stmt|;
block|}
name|convex
label|:
name|sprintf
argument_list|(
name|convbuf
argument_list|,
literal|"%.*f"
argument_list|,
name|len
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|dcnt
operator|=
name|sigcnt
operator|=
literal|0
expr_stmt|;
name|sig
operator|=
name|No
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|convbuf
init|;
operator|*
name|bp
operator|!=
literal|'\0'
condition|;
name|bp
operator|++
control|)
if|if
condition|(
literal|'0'
operator|<=
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|<=
literal|'9'
condition|)
block|{
name|dcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'0'
condition|)
name|sig
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
name|sig
condition|)
name|sigcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sigcnt
operator|<
name|MINNUMDIG
operator|&&
name|prec_loss
condition|)
goto|goto
name|conv
goto|;
if|if
condition|(
name|dcnt
operator|>
name|MAXNUMDIG
condition|)
block|{
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|syserr
argument_list|(
literal|"conversion error 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Denominator
argument_list|(
name|v
argument_list|)
operator|==
name|One
condition|)
name|len
operator|=
literal|0
expr_stmt|;
else|else
name|len
operator|-=
name|dcnt
operator|-
name|MAXNUMDIG
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"conversion error 2"
argument_list|)
expr_stmt|;
goto|goto
name|convex
goto|;
block|}
block|}
else|else
block|{
comment|/*approx etc*/
name|sprintf
argument_list|(
name|convbuf
argument_list|,
literal|"%.*e"
argument_list|,
name|MAXNUMDIG
operator|-
literal|5
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|convbuf
init|;
operator|*
name|bp
operator|!=
literal|'\0'
condition|;
name|bp
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|==
literal|'e'
condition|)
block|{
operator|*
name|bp
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
block|}
return|return
name|convbuf
return|;
block|}
end_function

begin_function
name|value
name|numconst
parameter_list|(
name|tx
parameter_list|,
name|q
parameter_list|)
name|txptr
name|tx
decl_stmt|,
name|q
decl_stmt|;
block|{
name|bool
name|dig
init|=
name|No
decl_stmt|;
name|double
name|ex
init|=
literal|0
decl_stmt|,
name|ap
init|=
literal|1
decl_stmt|;
name|intlet
name|ndap
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
literal|'0'
operator|<=
operator|*
name|tx
operator|&&
operator|*
name|tx
operator|<=
literal|'9'
condition|)
block|{
name|dig
operator|=
name|Yes
expr_stmt|;
name|ex
operator|=
literal|10
operator|*
name|ex
operator|+
operator|(
operator|*
name|tx
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|<
name|q
operator|&&
operator|*
name|tx
operator|==
literal|'.'
condition|)
block|{
name|tx
operator|++
expr_stmt|;
name|ndap
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
literal|'0'
operator|<=
operator|*
name|tx
operator|&&
operator|*
name|tx
operator|<=
literal|'9'
condition|)
block|{
name|dig
operator|=
name|Yes
expr_stmt|;
name|ndap
operator|++
expr_stmt|;
name|len
operator|=
operator|*
name|tx
operator|==
literal|'0'
condition|?
name|ndap
else|:
literal|0
expr_stmt|;
name|ex
operator|=
literal|10
operator|*
name|ex
operator|+
operator|(
operator|*
name|tx
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ap
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dig
condition|)
name|syserr
argument_list|(
literal|"numconst[1]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|<
name|q
operator|&&
operator|*
name|tx
operator|==
literal|'E'
condition|)
block|{
name|intlet
name|sign
init|=
literal|1
decl_stmt|;
name|double
name|expo
init|=
literal|0
decl_stmt|;
name|tx
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
operator|*
name|tx
operator|&&
operator|*
name|tx
operator|<=
literal|'9'
operator|)
operator|&&
name|Keymark
argument_list|(
operator|*
name|tx
argument_list|)
condition|)
block|{
name|tx
operator|--
expr_stmt|;
goto|goto
name|exact
goto|;
block|}
if|if
condition|(
operator|!
name|dig
condition|)
name|ex
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tx
operator|<
name|q
operator|&&
operator|(
operator|*
name|tx
operator|==
literal|'+'
operator|||
operator|*
name|tx
operator|==
literal|'-'
operator|)
condition|)
if|if
condition|(
operator|*
name|tx
operator|++
operator|==
literal|'-'
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|dig
operator|=
name|No
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|q
operator|&&
literal|'0'
operator|<=
operator|*
name|tx
operator|&&
operator|*
name|tx
operator|<=
literal|'9'
condition|)
block|{
name|dig
operator|=
name|Yes
expr_stmt|;
name|expo
operator|=
literal|10
operator|*
name|expo
operator|+
operator|(
operator|*
name|tx
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dig
condition|)
name|syserr
argument_list|(
literal|"numconst[2]"
argument_list|)
expr_stmt|;
return|return
name|mk_approx
argument_list|(
name|ex
operator|/
name|ap
operator|*
name|exp
argument_list|(
name|sign
operator|*
name|expo
operator|*
name|log
argument_list|(
literal|10.0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|exact
label|:
return|return
name|mk_exact
argument_list|(
name|ex
argument_list|,
name|ap
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_macro
name|printnum
argument_list|(
argument|f1
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|f
init|=
name|f1
condition|?
name|f1
else|:
name|stdout
decl_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|v
argument_list|)
operator|||
name|Denominator
argument_list|(
name|v
argument_list|)
operator|==
name|One
condition|)
block|{
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'~'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|convnum
argument_list|(
name|v
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
name|w
init|=
name|numerator
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|convnum
argument_list|(
name|w
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'/'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|w
operator|=
name|denominator
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|convnum
argument_list|(
name|w
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Flush buffer for sdb */
block|}
end_block

end_unit

