begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: eval.c,v 2.3 84/07/19 11:47:18 guido Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Width attribute evaluation.  */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_comment
comment|/*  * The following convention is used throughout the editor to indicate  * the sizes of objects.  * - A zero or positive `width' value means the object contains no  *   linefeeds.  The width is counted in characters.  * - A negative `width' means the object (or its children) contains  *   at leasty one linefeed (return is treated as a linefeed here).  *   The number of linefeeds is -width.  *   There is no indication whether the object fits on that number of  *   physical lines, as logical lines may have arbitrary length.  *  * For coordinates the following convention is used.  * (Note that, in accordance to the convention in curses(3), the  * `y' coordinate always precedes the `x' coorxdinate.)  * - `Y' is the line number, counted from the beginning of the unit.  *   These are logical lines rather than physical lines.  *   The first line has line number 0.  * - `X' is the column number.  The first column is 0.  For x< 0,  *   see the important notice below.  * - `Level' is the indentation level, indicating where a new line  *   would start if inserted at the current position.  *   The initial `x' position of such a line is `level*TABS'.  *  * ***** IMPORTANT NOTICE *****  * A special case is x = -1.  This means that the current x position is  * unknown.  Further output on the same line is suppressed, until a  * linefeed is encountered.  This feature is necessary because while  * calculating coordinates, when an object has width< 0, only the y  * coordinate of the end of that object is known.  In this case, the  * next non-empty object MUST START WITH A LINEFEED, or it will not  * be visible on the screen (in practice, a space is sometimes present  * in the parse tree which is not shown then).  */
end_comment

begin_comment
comment|/*  * Compute the (y, x) coordinates and indent level just before  * the beginning of the j'th child, if the current node starts  * at the initial values of (y, x) and level.  */
end_comment

begin_function
name|Visible
name|Procedure
name|evalcoord
parameter_list|(
name|n
parameter_list|,
name|jch
parameter_list|,
name|py
parameter_list|,
name|px
parameter_list|,
name|plevel
parameter_list|)
specifier|register
name|node
name|n
decl_stmt|;
specifier|register
name|int
name|jch
decl_stmt|;
name|int
modifier|*
name|py
decl_stmt|;
name|int
modifier|*
name|px
decl_stmt|;
name|int
modifier|*
name|plevel
decl_stmt|;
block|{
name|node
name|nn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|string
modifier|*
name|rp
init|=
name|noderepr
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|y
init|=
literal|0
decl_stmt|;
name|int
name|x
init|=
operator|*
name|px
decl_stmt|;
name|int
name|level
init|=
operator|*
name|plevel
decl_stmt|;
name|int
name|nch
init|=
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|?
literal|0
else|:
name|nchildren
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|jch
operator|>
name|nch
condition|)
name|jch
operator|=
name|nch
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|jch
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|nn
operator|=
name|child
argument_list|(
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|k
operator|=
name|width
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
name|y
operator|+=
operator|-
name|k
expr_stmt|;
name|x
operator|=
name|k
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
name|x
operator|+=
name|k
expr_stmt|;
block|}
name|k
operator|=
name|Fwidth
argument_list|(
name|rp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
name|y
operator|+=
operator|-
name|k
expr_stmt|;
name|x
operator|=
name|rp
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\r'
condition|?
literal|0
else|:
name|TABS
operator|*
name|level
expr_stmt|;
name|x
operator|+=
name|strlen
argument_list|(
name|rp
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
name|x
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|rp
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|rp
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'\t'
condition|)
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|'\b'
condition|)
operator|--
name|level
expr_stmt|;
block|}
block|}
block|}
operator|*
name|py
operator|+=
name|y
expr_stmt|;
operator|*
name|px
operator|=
name|x
expr_stmt|;
operator|*
name|plevel
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Yield the width of a piece of fixed text as found in a node's repr,  * excluding \b or \t.  If \n or \r is found, -1 is returned.  * It assumes that \n or \r only occur as first  * character, and \b or \t only as last.  */
end_comment

begin_function
name|Visible
name|int
name|fwidth
parameter_list|(
name|str
parameter_list|)
specifier|register
name|string
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
name|c
condition|;
name|c
operator|=
operator|*
operator|++
name|str
control|)
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|str
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\b'
condition|)
operator|--
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate the width of node n, assuming the widths of its children  * have correctly been calculated.  */
end_comment

begin_function
name|Visible
name|int
name|evalwidth
parameter_list|(
name|n
parameter_list|)
specifier|register
name|node
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|w
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|string
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|y
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|x
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|nch
decl_stmt|;
specifier|register
name|node
name|nn
decl_stmt|;
name|rp
operator|=
name|noderepr
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|nch
operator|=
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|?
literal|0
else|:
name|nchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nch
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|nn
operator|=
name|child
argument_list|(
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|w
operator|=
name|width
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|y
operator|+=
operator|-
name|w
expr_stmt|;
name|x
operator|=
name|w
expr_stmt|;
block|}
else|else
name|x
operator|+=
name|w
expr_stmt|;
block|}
name|w
operator|=
name|Fwidth
argument_list|(
name|rp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|y
operator|+=
operator|-
name|w
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|x
operator|+=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>
literal|0
condition|)
return|return
operator|-
name|y
return|;
return|return
name|x
return|;
block|}
end_function

end_unit

