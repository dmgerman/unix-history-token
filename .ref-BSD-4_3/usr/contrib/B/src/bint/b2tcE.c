begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b2tcE.c,v 1.4 85/08/22 16:56:55 timo Exp $ */
end_comment

begin_comment
comment|/* process type unification errors */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2tcP.h"
end_include

begin_include
include|#
directive|include
file|"b2tcE.h"
end_include

begin_include
include|#
directive|include
file|"b2tcU.h"
end_include

begin_comment
comment|/*   * The variables from the users line are inserted in var_list.  * This is used to produce the right variable names  * in the error message.  * Call start_vars() when a new error context is established  * with the setting of curline.  */
end_comment

begin_decl_stmt
name|Hidden
name|value
name|var_list
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|Procedure
name|start_vars
parameter_list|()
block|{
name|var_list
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|add_var
parameter_list|(
name|tvar
parameter_list|)
name|polytype
name|tvar
decl_stmt|;
block|{
name|insert
argument_list|(
name|tvar
argument_list|,
operator|&
name|var_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|in_vars
parameter_list|(
name|t
parameter_list|)
name|polytype
name|t
decl_stmt|;
block|{
return|return
name|in
argument_list|(
name|t
argument_list|,
name|var_list
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|end_vars
parameter_list|()
block|{
name|release
argument_list|(
name|var_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* t_repr(u) is used to print polytypes when an error  * has occurred.  * Because the errors are printed AFTER unification, the variable   * polytypes in question have changed to the error-type.  * To print the real types in error, the table has to be   * saved in reprtable.  * The routines are called in unify().  */
end_comment

begin_decl_stmt
name|Hidden
name|value
name|reprtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|value
name|typeof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in b2tcP.c */
end_comment

begin_function
name|Visible
name|Procedure
name|setreprtable
parameter_list|()
block|{
name|reprtable
operator|=
name|copy
argument_list|(
name|typeof
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|delreprtable
parameter_list|()
block|{
name|release
argument_list|(
name|reprtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* miscellaneous procs */
end_comment

begin_function
name|Hidden
name|value
name|conc
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|value
name|c
decl_stmt|;
name|c
operator|=
name|concat
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|newvar
parameter_list|(
name|u
parameter_list|)
name|polytype
name|u
decl_stmt|;
block|{
name|value
name|u1
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|u1
operator|=
name|curtail
argument_list|(
name|ident
argument_list|(
name|u
argument_list|)
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|ch
operator|=
name|charval
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u1
argument_list|)
expr_stmt|;
return|return
call|(
name|bool
call|)
argument_list|(
literal|'0'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'9'
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Known
parameter_list|(
name|tu
parameter_list|)
value|(!t_is_var(kind(tu))&& !t_is_error(kind(tu)))
end_define

begin_function
name|Hidden
name|bool
name|knowntype
parameter_list|(
name|u
parameter_list|)
name|polytype
name|u
decl_stmt|;
block|{
name|value
name|tu
decl_stmt|;
name|tu
operator|=
name|u
expr_stmt|;
while|while
condition|(
name|t_is_var
argument_list|(
name|kind
argument_list|(
name|tu
argument_list|)
argument_list|)
operator|&&
name|in_keys
argument_list|(
name|ident
argument_list|(
name|tu
argument_list|)
argument_list|,
name|reprtable
argument_list|)
condition|)
name|tu
operator|=
operator|*
name|adrassoc
argument_list|(
name|reprtable
argument_list|,
name|ident
argument_list|(
name|tu
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Known
argument_list|(
name|tu
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|Hidden
name|bool
name|outervar
init|=
name|Yes
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|value
name|t_repr
parameter_list|(
name|u
parameter_list|)
name|polytype
name|u
decl_stmt|;
block|{
name|typekind
name|u_kind
decl_stmt|;
name|value
name|c
decl_stmt|;
name|u_kind
operator|=
name|kind
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_is_number
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
return|return
name|mk_text
argument_list|(
literal|"0"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t_is_text
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
return|return
name|mk_text
argument_list|(
literal|"''"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t_is_tn
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
return|return
name|mk_text
argument_list|(
literal|"'' or 0"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t_is_compound
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
name|intlet
name|k
decl_stmt|,
name|len
init|=
name|nsubtypes
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|c
operator|=
name|mk_text
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
operator|-
literal|1
condition|;
name|k
operator|++
control|)
block|{
name|c
operator|=
name|conc
argument_list|(
name|c
argument_list|,
name|t_repr
argument_list|(
name|subtype
argument_list|(
name|u
argument_list|,
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|conc
argument_list|(
name|c
argument_list|,
name|mk_text
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|conc
argument_list|(
name|c
argument_list|,
name|t_repr
argument_list|(
name|subtype
argument_list|(
name|u
argument_list|,
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|conc
argument_list|(
name|c
argument_list|,
name|mk_text
argument_list|(
literal|")"
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t_is_error
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
return|return
name|mk_text
argument_list|(
literal|" "
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t_is_var
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
name|value
name|tu
decl_stmt|;
name|tu
operator|=
name|u
expr_stmt|;
while|while
condition|(
name|t_is_var
argument_list|(
name|kind
argument_list|(
name|tu
argument_list|)
argument_list|)
operator|&&
name|in_keys
argument_list|(
name|ident
argument_list|(
name|tu
argument_list|)
argument_list|,
name|reprtable
argument_list|)
condition|)
name|tu
operator|=
operator|*
name|adrassoc
argument_list|(
name|reprtable
argument_list|,
name|ident
argument_list|(
name|tu
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_vars
argument_list|(
name|u
argument_list|)
condition|)
block|{
if|if
condition|(
name|Known
argument_list|(
name|tu
argument_list|)
condition|)
block|{
if|if
condition|(
name|outervar
condition|)
block|{
name|outervar
operator|=
name|No
expr_stmt|;
name|c
operator|=
name|conc
argument_list|(
name|t_repr
argument_list|(
name|tu
argument_list|)
argument_list|,
name|mk_text
argument_list|(
literal|" for "
argument_list|)
argument_list|)
expr_stmt|;
name|outervar
operator|=
name|Yes
expr_stmt|;
return|return
name|conc
argument_list|(
name|c
argument_list|,
name|copy
argument_list|(
name|ident
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|t_repr
argument_list|(
name|tu
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|copy
argument_list|(
name|ident
argument_list|(
name|u
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|Known
argument_list|(
name|tu
argument_list|)
condition|)
return|return
name|t_repr
argument_list|(
name|tu
argument_list|)
return|;
elseif|else
if|if
condition|(
name|newvar
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|mk_text
argument_list|(
literal|" "
argument_list|)
return|;
else|else
return|return
name|copy
argument_list|(
name|ident
argument_list|(
name|u
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t_is_table
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|knowntype
argument_list|(
name|keytype
argument_list|(
name|u
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|knowntype
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
condition|)
block|{
name|c
operator|=
name|conc
argument_list|(
name|mk_text
argument_list|(
literal|"{["
argument_list|)
argument_list|,
name|t_repr
argument_list|(
name|keytype
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|conc
argument_list|(
name|c
argument_list|,
name|mk_text
argument_list|(
literal|"]:"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|conc
argument_list|(
name|c
argument_list|,
name|t_repr
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|conc
argument_list|(
name|c
argument_list|,
name|mk_text
argument_list|(
literal|"}"
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|c
operator|=
name|conc
argument_list|(
name|mk_text
argument_list|(
literal|"table with type "
argument_list|)
argument_list|,
name|t_repr
argument_list|(
name|keytype
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|conc
argument_list|(
name|c
argument_list|,
name|mk_text
argument_list|(
literal|" keys"
argument_list|)
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|knowntype
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
condition|)
block|{
name|c
operator|=
name|conc
argument_list|(
name|mk_text
argument_list|(
literal|"table with type "
argument_list|)
argument_list|,
name|t_repr
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|conc
argument_list|(
name|c
argument_list|,
name|mk_text
argument_list|(
literal|" associates"
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|mk_text
argument_list|(
literal|"table"
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|t_is_list
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|knowntype
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
condition|)
block|{
name|c
operator|=
name|conc
argument_list|(
name|mk_text
argument_list|(
literal|"{"
argument_list|)
argument_list|,
name|t_repr
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|conc
argument_list|(
name|c
argument_list|,
name|mk_text
argument_list|(
literal|"}"
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|mk_text
argument_list|(
literal|"list"
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|t_is_lt
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|knowntype
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
condition|)
return|return
name|conc
argument_list|(
name|mk_text
argument_list|(
literal|"list or table of "
argument_list|)
argument_list|,
name|t_repr
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|mk_text
argument_list|(
literal|"{}"
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|t_is_tlt
argument_list|(
name|u_kind
argument_list|)
condition|)
block|{
if|if
condition|(
name|knowntype
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
condition|)
return|return
name|conc
argument_list|(
name|mk_text
argument_list|(
literal|"text list or table of "
argument_list|)
argument_list|,
name|t_repr
argument_list|(
name|asctype
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|mk_text
argument_list|(
literal|"text list or table"
argument_list|)
return|;
block|}
else|else
block|{
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4300
argument_list|,
literal|"unknown polytype in t_repr"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mk_text
argument_list|(
literal|"***"
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* now, the real error messages */
end_comment

begin_function
name|Visible
name|Procedure
name|badtyperr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|polytype
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|value
name|t
decl_stmt|;
comment|/*error4("incompatible types: ", ta, ", and ", tb); */
name|t
operator|=
name|conc
argument_list|(
name|t_repr
argument_list|(
name|a
argument_list|)
argument_list|,
name|mk_text
argument_list|(
literal|" and "
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|conc
argument_list|(
name|t
argument_list|,
name|t_repr
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|error2
argument_list|(
name|MESS
argument_list|(
literal|4301
argument_list|,
literal|"incompatible types "
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|cyctyperr
parameter_list|(
name|a
parameter_list|)
name|polytype
name|a
decl_stmt|;
block|{
name|value
name|vcyc
decl_stmt|;
name|vcyc
operator|=
name|Vnil
expr_stmt|;
if|if
condition|(
name|in_vars
argument_list|(
name|a
argument_list|)
condition|)
name|vcyc
operator|=
name|ident
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
block|{
name|value
name|n
decl_stmt|,
name|m
decl_stmt|,
name|nvars
decl_stmt|,
name|v
decl_stmt|;
name|n
operator|=
name|copy
argument_list|(
name|one
argument_list|)
expr_stmt|;
name|nvars
operator|=
name|size
argument_list|(
name|var_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|compare
argument_list|(
name|n
argument_list|,
name|nvars
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|v
operator|=
name|th_of
argument_list|(
name|n
argument_list|,
name|var_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal_vars
argument_list|(
name|v
argument_list|,
name|a
argument_list|)
operator|||
name|contains
argument_list|(
name|v
argument_list|,
name|a
argument_list|)
condition|)
block|{
name|vcyc
operator|=
name|ident
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|sum
argument_list|(
name|n
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|nvars
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcyc
name|EQ
name|Vnil
condition|)
block|{
name|error2
argument_list|(
name|MESS
argument_list|(
literal|4302
argument_list|,
literal|"unknown cyclic type"
argument_list|)
argument_list|,
name|ident
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4303
argument_list|,
literal|"unknown cyclic type"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|error3
argument_list|(
name|MESS
argument_list|(
literal|4304
argument_list|,
literal|"(sub)type of "
argument_list|)
argument_list|,
name|vcyc
argument_list|,
name|MESS
argument_list|(
literal|4305
argument_list|,
literal|" contains itself"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

