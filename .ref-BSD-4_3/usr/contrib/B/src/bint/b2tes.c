begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b2tes.c,v 1.4 85/08/22 16:57:17 timo Exp $ */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2par.h"
end_include

begin_include
include|#
directive|include
file|"b2key.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_decl_stmt
name|Forward
name|bool
name|conjunction
argument_list|()
decl_stmt|,
name|disjunction
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Forward
name|parsetree
name|right_test
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Visible
name|parsetree
name|test
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|parsetree
name|v
decl_stmt|;
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|conjunction
argument_list|(
name|q
argument_list|,
operator|&
name|v
argument_list|)
operator|||
name|disjunction
argument_list|(
name|q
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
name|v
operator|=
name|right_test
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_decl_stmt
name|Forward
name|bool
name|negation
argument_list|()
decl_stmt|,
name|quantification
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Forward
name|parsetree
name|tight_test
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Hidden
name|parsetree
name|right_test
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|parsetree
name|v
decl_stmt|;
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|negation
argument_list|(
name|q
argument_list|,
operator|&
name|v
argument_list|)
operator|||
name|quantification
argument_list|(
name|q
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
name|v
operator|=
name|tight_test
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|conjunction
parameter_list|(
name|q
parameter_list|,
name|v
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|parsetree
modifier|*
name|v
decl_stmt|;
block|{
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|;
if|if
condition|(
name|find
argument_list|(
name|K_AND
argument_list|,
name|q
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
block|{
name|parsetree
name|t
decl_stmt|;
name|t
operator|=
name|tight_test
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
if|if
condition|(
operator|!
name|conjunction
argument_list|(
name|q
argument_list|,
name|v
argument_list|)
condition|)
operator|*
name|v
operator|=
name|right_test
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|node3
argument_list|(
name|AND
argument_list|,
name|t
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|disjunction
parameter_list|(
name|q
parameter_list|,
name|v
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|parsetree
modifier|*
name|v
decl_stmt|;
block|{
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|;
if|if
condition|(
name|find
argument_list|(
name|K_OR
argument_list|,
name|q
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
block|{
name|parsetree
name|t
decl_stmt|;
name|t
operator|=
name|tight_test
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
if|if
condition|(
operator|!
name|disjunction
argument_list|(
name|q
argument_list|,
name|v
argument_list|)
condition|)
operator|*
name|v
operator|=
name|right_test
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|node3
argument_list|(
name|OR
argument_list|,
name|t
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|negation
parameter_list|(
name|q
parameter_list|,
name|v
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|parsetree
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
name|not_keyword
argument_list|()
condition|)
block|{
operator|*
name|v
operator|=
name|node2
argument_list|(
name|NOT
argument_list|,
name|right_test
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|quantification
parameter_list|(
name|q
parameter_list|,
name|v
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|parsetree
modifier|*
name|v
decl_stmt|;
block|{
name|bool
name|some
decl_stmt|,
name|each
decl_stmt|;
if|if
condition|(
operator|(
name|some
operator|=
name|some_keyword
argument_list|()
operator|)
operator|||
operator|(
name|each
operator|=
name|each_keyword
argument_list|()
operator|)
operator|||
name|no_keyword
argument_list|()
condition|)
block|{
name|parsetree
name|t
decl_stmt|,
name|e
decl_stmt|;
name|typenode
name|type
decl_stmt|;
name|txptr
name|utx
decl_stmt|,
name|vtx
decl_stmt|,
name|ftx
decl_stmt|,
name|ttx
decl_stmt|;
name|req
argument_list|(
name|K_HAS
argument_list|,
name|ceol
argument_list|,
operator|&
name|utx
argument_list|,
operator|&
name|vtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|utx
operator|>
name|q
condition|)
block|{
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|2700
argument_list|,
literal|"HAS follows colon"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as in: SOME i IN x: SHOW i HAS a */
name|utx
operator|=
name|tx
expr_stmt|;
name|vtx
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|find
argument_list|(
name|K_IN_quant
argument_list|,
name|utx
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
block|{
name|idf_cntxt
operator|=
name|In_ranger
expr_stmt|;
name|t
operator|=
name|idf
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|type
operator|=
name|some
condition|?
name|SOME_IN
else|:
name|each
condition|?
name|EACH_IN
else|:
name|NO_IN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|find
argument_list|(
name|K_PARSING
argument_list|,
name|utx
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
block|{
name|idf_cntxt
operator|=
name|In_ranger
expr_stmt|;
name|t
operator|=
name|idf
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodetype
argument_list|(
name|t
argument_list|)
operator|!=
name|COLLATERAL
condition|)
name|pprerr
argument_list|(
name|MESS
argument_list|(
literal|2701
argument_list|,
literal|"no collateral_identifier where expected"
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|type
operator|=
name|some
condition|?
name|SOME_PARSING
else|:
name|each
condition|?
name|EACH_PARSING
else|:
name|NO_PARSING
expr_stmt|;
block|}
else|else
block|{
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|2702
argument_list|,
literal|"neither IN nor PARSING found"
argument_list|)
argument_list|)
expr_stmt|;
name|utx
operator|=
name|tx
expr_stmt|;
name|vtx
operator|=
name|q
expr_stmt|;
name|t
operator|=
name|NilTree
expr_stmt|;
name|type
operator|=
name|Nonode
expr_stmt|;
block|}
name|e
operator|=
name|expr
argument_list|(
name|utx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|vtx
expr_stmt|;
operator|*
name|v
operator|=
name|node4
argument_list|(
name|type
argument_list|,
name|t
argument_list|,
name|e
argument_list|,
name|right_test
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_decl_stmt
name|Forward
name|bool
name|cl_test
argument_list|()
decl_stmt|,
name|order_test
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Forward
name|parsetree
name|ref_or_prop
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Hidden
name|parsetree
name|tight_test
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|parsetree
name|v
decl_stmt|;
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nothing
argument_list|(
name|q
argument_list|,
literal|"test"
argument_list|)
condition|)
name|v
operator|=
name|NilTree
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|cl_test
argument_list|(
name|q
argument_list|,
operator|&
name|v
argument_list|)
operator|||
name|order_test
argument_list|(
name|q
argument_list|,
operator|&
name|v
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|is_expr
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
name|v
operator|=
name|ref_or_prop
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|2703
argument_list|,
literal|"no test where expected"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|NilTree
expr_stmt|;
block|}
block|}
name|upto_test
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|cl_test
parameter_list|(
name|q
parameter_list|,
name|v
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|parsetree
modifier|*
name|v
decl_stmt|;
block|{
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
if|if
condition|(
name|open_sign
argument_list|()
condition|)
block|{
comment|/* (expr) or (test) */
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|,
name|tx1
decl_stmt|;
name|tx1
operator|=
name|tx
expr_stmt|;
name|req
argument_list|(
literal|")"
argument_list|,
name|q
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Text
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|tx
operator|=
name|tx1
expr_stmt|;
operator|*
name|v
operator|=
name|compound
argument_list|(
name|ttx
argument_list|,
name|test
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
name|tx
operator|=
name|tx0
expr_stmt|;
return|return
name|No
return|;
block|}
end_function

begin_function_decl
name|Forward
name|typenode
name|relop
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Hidden
name|bool
name|order_test
parameter_list|(
name|q
parameter_list|,
name|v
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|parsetree
modifier|*
name|v
decl_stmt|;
block|{
name|txptr
name|ftx
decl_stmt|;
if|if
condition|(
name|findrel
argument_list|(
name|q
argument_list|,
operator|&
name|ftx
argument_list|)
condition|)
block|{
name|typenode
name|r
decl_stmt|;
operator|*
name|v
operator|=
name|singexpr
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
do|do
block|{
name|r
operator|=
name|relop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|findrel
argument_list|(
name|q
argument_list|,
operator|&
name|ftx
argument_list|)
condition|)
name|ftx
operator|=
name|q
expr_stmt|;
operator|*
name|v
operator|=
name|node3
argument_list|(
name|r
argument_list|,
operator|*
name|v
argument_list|,
name|singexpr
argument_list|(
name|ftx
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ftx
operator|<
name|q
condition|)
do|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_function
name|Hidden
name|typenode
name|relop
parameter_list|()
block|{
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
return|return
name|at_most_sign
argument_list|()
condition|?
name|AT_MOST
else|:
name|unequal_sign
argument_list|()
condition|?
name|UNEQUAL
else|:
name|at_least_sign
argument_list|()
condition|?
name|AT_LEAST
else|:
name|equals_sign
argument_list|()
condition|?
name|EQUAL
else|:
name|less_than_sign
argument_list|()
condition|?
name|LESS_THAN
else|:
name|greater_than_sign
argument_list|()
condition|?
name|GREATER_THAN
else|:
comment|/* psyserr */
name|Nonode
return|;
block|}
end_function

begin_comment
comment|/* refined_test or proposition */
end_comment

begin_function_decl
name|Forward
name|parsetree
name|dyadic_proposition
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Hidden
name|parsetree
name|ref_or_prop
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|value
name|t1
decl_stmt|;
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
if|if
condition|(
name|tag_operator
argument_list|(
name|q
argument_list|,
operator|&
name|t1
argument_list|)
condition|)
block|{
name|value
name|t2
decl_stmt|;
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Text
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|node2
argument_list|(
name|TAG
argument_list|,
name|t1
argument_list|)
return|;
if|if
condition|(
name|tag_operator
argument_list|(
name|q
argument_list|,
operator|&
name|t2
argument_list|)
condition|)
block|{
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Text
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|node4
argument_list|(
name|MONPRD
argument_list|,
name|t1
argument_list|,
name|node2
argument_list|(
name|TAG
argument_list|,
name|t2
argument_list|)
argument_list|,
name|Vnil
argument_list|)
return|;
name|release
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t2
argument_list|)
expr_stmt|;
return|return
operator|(
name|tx
operator|=
name|tx0
operator|,
name|unp_test
argument_list|(
name|q
argument_list|)
operator|)
return|;
block|}
name|release
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dya_sign
argument_list|()
condition|)
return|return
operator|(
name|tx
operator|=
name|tx0
operator|,
name|unp_test
argument_list|(
name|q
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|tx
operator|=
name|tx0
operator|,
name|dyadic_proposition
argument_list|(
name|q
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|Visible
name|bool
name|dya_proposition
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|parsetree
name|dyadic_proposition
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|parsetree
name|v
decl_stmt|;
name|value
name|name
decl_stmt|;
name|dya_proposition
operator|=
name|Yes
expr_stmt|;
name|v
operator|=
name|singexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Text
argument_list|(
name|q
argument_list|)
condition|)
comment|/* unparsed */
return|return
name|v
return|;
if|if
condition|(
operator|!
name|tag_operator
argument_list|(
name|q
argument_list|,
operator|&
name|name
argument_list|)
condition|)
block|{
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|2704
argument_list|,
literal|"no dyadic predicate where expected"
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|Vnil
expr_stmt|;
block|}
return|return
name|node5
argument_list|(
name|DYAPRD
argument_list|,
name|v
argument_list|,
name|name
argument_list|,
name|singexpr
argument_list|(
name|q
argument_list|)
argument_list|,
name|Vnil
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|upto_test
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|skipsp
argument_list|(
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Text
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|;
if|if
condition|(
name|find
argument_list|(
name|K_AND
argument_list|,
name|q
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
operator|||
name|find
argument_list|(
name|K_OR
argument_list|,
name|q
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
block|{
name|tx
operator|=
name|ftx
expr_stmt|;
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|2705
argument_list|,
literal|"cannot determine priorities; use ( and ) to resolve"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|2706
argument_list|,
literal|"something unexpected following test"
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|q
expr_stmt|;
block|}
block|}
end_function

end_unit

