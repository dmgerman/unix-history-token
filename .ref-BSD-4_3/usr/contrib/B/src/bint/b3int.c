begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3int.c,v 1.4 85/08/22 16:58:27 timo Exp $ */
end_comment

begin_comment
comment|/* B interpreter using theaded trees */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3sem.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3int.h"
end_include

begin_include
include|#
directive|include
file|"b3in2.h"
end_include

begin_include
include|#
directive|include
file|"b3sta.h"
end_include

begin_comment
comment|/* Relicts from old system: */
end_comment

begin_decl_stmt
name|Visible
name|value
name|resval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|bool
name|terminated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Shorthands: */
end_comment

begin_define
define|#
directive|define
name|Pop2
parameter_list|(
name|fun
parameter_list|)
value|(w = pop(), v = pop(), fun(v, w), release(v), release(w))
end_define

begin_define
define|#
directive|define
name|Pop1
parameter_list|(
name|fun
parameter_list|)
value|(v = pop(), fun(v), release(v))
end_define

begin_define
define|#
directive|define
name|Dyop
parameter_list|(
name|funvw
parameter_list|)
define|\
value|(w = pop(), v = pop(), push(funvw), release(v), release(w))
end_define

begin_define
define|#
directive|define
name|Monop
parameter_list|(
name|funv
parameter_list|)
value|(v = pop(), push(funv), release(v))
end_define

begin_define
define|#
directive|define
name|Flagged
parameter_list|()
value|(Thread2(pc) != NilTree)
end_define

begin_define
define|#
directive|define
name|LocFlagged
parameter_list|()
value|(Thread2(pc) != NilTree&& !noloc)
end_define

begin_define
define|#
directive|define
name|ValOrLoc
parameter_list|(
name|feval
parameter_list|,
name|floc
parameter_list|)
value|(LocFlagged() ? (floc) : (feval))
end_define

begin_define
define|#
directive|define
name|Jump
parameter_list|()
value|(tracing&& tr_jump(), next = Thread2(pc))
end_define

begin_define
define|#
directive|define
name|Comp
parameter_list|(
name|op
parameter_list|)
value|(w = pop(), v = pop(), report = (compare(v, w) op 0), Comp2())
end_define

begin_define
define|#
directive|define
name|Comp2
parameter_list|()
value|(release(v), !Flagged() ? release(w) : Comp3())
end_define

begin_define
define|#
directive|define
name|Comp3
parameter_list|()
value|(report ? push(w) : (Jump(), release(w)))
end_define

begin_define
define|#
directive|define
name|F
parameter_list|(
name|n
parameter_list|)
value|((value)*Branch(pc, (n)))
end_define

begin_comment
comment|/* Execute a threaded tree until the end or until a terminating-command.    The boolean argument 'wantvalue' tells whether it must deliver    a value or not. */
end_comment

begin_function
name|Hidden
name|value
name|run
parameter_list|(
name|start
parameter_list|,
name|wantvalue
parameter_list|)
name|parsetree
name|start
decl_stmt|;
name|bool
name|wantvalue
decl_stmt|;
block|{
name|value
name|u
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|;
name|int
name|k
decl_stmt|;
name|bool
name|X
decl_stmt|,
name|Y
decl_stmt|;
name|int
name|call_stop
init|=
name|call_level
decl_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|int
name|loopcnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|parsetree
name|old_next
init|=
name|next
decl_stmt|;
comment|/* While run can be used recursively, save some state info */
name|next
operator|=
name|start
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|loopcnt
operator|++
operator|==
literal|100
condition|)
block|{
name|bdos
argument_list|(
literal|0x2c
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* forcing a DOS function call (get time) */
comment|/* so that a break interrupt can be executed */
name|loopcnt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|still_ok
condition|)
break|break;
name|pc
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|Halt
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|3500
argument_list|,
literal|"unexpected program halt"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|Is_parsetree
argument_list|(
name|pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|pc
operator|==
name|Stop
condition|)
block|{
if|if
condition|(
name|call_level
operator|==
name|call_stop
condition|)
break|break;
name|ret
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|pc
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3501
argument_list|,
literal|"run: bad thread"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intval
argument_list|(
name|pc
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|pc
operator|=
name|Stop
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|error
argument_list|(
name|MESS
argument_list|(
literal|3502
argument_list|,
literal|"none of the alternative tests of SELECT succeeds"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|resexp
operator|==
name|Rep
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3503
argument_list|,
literal|"TEST-unit reports no outcome"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|MESS
argument_list|(
literal|3504
argument_list|,
literal|"YIELD-unit returns no value"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|resexp
operator|==
name|Rep
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3505
argument_list|,
literal|"test-refinement reports no outcome"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|MESS
argument_list|(
literal|3506
argument_list|,
literal|"refinement returns no value"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "expression-" seems superfluous here */
break|break;
default|default:
name|v
operator|=
name|convert
argument_list|(
name|pc
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|error3
argument_list|(
name|MESS
argument_list|(
literal|3507
argument_list|,
literal|"run-time error "
argument_list|)
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|next
operator|=
name|Thread
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
condition|)
name|tr_node
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/*<<<<<<<<<<<<<<<< */
switch|switch
condition|(
name|Nodetype
argument_list|(
name|pc
argument_list|)
condition|)
block|{
case|case
name|HOW_TO
case|:
case|case
name|REFINEMENT
case|:
name|error
argument_list|(
name|MESS
argument_list|(
literal|3508
argument_list|,
literal|"run: cannot execute unit-definition"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YIELD
case|:
case|case
name|TEST
case|:
switch|switch
condition|(
name|Nodetype
argument_list|(
name|F
argument_list|(
name|FPR_FORMALS
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TAG
case|:
break|break;
case|case
name|MONF
case|:
case|case
name|MONPRD
case|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|put
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|DYAF
case|:
case|case
name|DYAPRD
case|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|u
operator|=
name|pop
argument_list|()
expr_stmt|;
name|put
argument_list|(
name|u
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|u
operator|=
name|pop
argument_list|()
expr_stmt|;
name|put
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3509
argument_list|,
literal|"bad FPR_FORMAL"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Commands */
case|case
name|SUITE
case|:
name|curlino
operator|=
name|F
argument_list|(
name|SUI_LINO
argument_list|)
expr_stmt|;
name|curline
operator|=
name|F
argument_list|(
name|SUI_CMD
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF
case|:
case|case
name|AND
case|:
case|case
name|WHILE
case|:
case|case
name|TEST_SUITE
case|:
if|if
condition|(
operator|!
name|report
condition|)
name|Jump
argument_list|()
expr_stmt|;
break|break;
case|case
name|OR
case|:
if|if
condition|(
name|report
condition|)
name|Jump
argument_list|()
expr_stmt|;
break|break;
case|case
name|FOR
case|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_ranger
argument_list|(
name|v
argument_list|,
operator|&
name|w
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|Jump
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PUT
case|:
name|Pop2
argument_list|(
name|put_with_check
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSERT
case|:
name|Pop2
argument_list|(
name|l_insert
argument_list|)
expr_stmt|;
break|break;
case|case
name|REMOVE
case|:
name|Pop2
argument_list|(
name|l_remove
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHOOSE
case|:
name|Pop2
argument_list|(
name|choose
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRAW
case|:
name|Pop1
argument_list|(
name|draw
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_RANDOM
case|:
name|Pop1
argument_list|(
name|set_random
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|Pop1
argument_list|(
name|l_delete
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHECK
case|:
if|if
condition|(
operator|!
name|report
condition|)
name|checkerr
argument_list|()
expr_stmt|;
break|break;
case|case
name|WRITE
case|:
name|nl
argument_list|(
name|F
argument_list|(
name|WRT_L_LINES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
argument_list|(
name|WRT_EXPR
argument_list|)
condition|)
block|{
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|writ
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|nl
argument_list|(
name|F
argument_list|(
name|WRT_R_LINES
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|READ
case|:
name|Pop2
argument_list|(
name|read_eg
argument_list|)
expr_stmt|;
break|break;
case|case
name|READ_RAW
case|:
name|Pop1
argument_list|(
name|read_raw
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUIT
case|:
if|if
condition|(
name|resexp
operator|!=
name|Voi
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3510
argument_list|,
literal|"QUIT may only occur in a HOW'TO or command-refinement"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_level
operator|==
literal|0
operator|&&
name|still_ok
condition|)
name|terminated
operator|=
name|Yes
expr_stmt|;
name|next
operator|=
name|Stop
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
if|if
condition|(
name|resexp
operator|!=
name|Ret
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3511
argument_list|,
literal|"RETURN may only occur in a YIELD or expression-refinement"
argument_list|)
argument_list|)
expr_stmt|;
name|resval
operator|=
name|pop
argument_list|()
expr_stmt|;
name|next
operator|=
name|Stop
expr_stmt|;
break|break;
case|case
name|REPORT
case|:
if|if
condition|(
name|resexp
operator|!=
name|Rep
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3512
argument_list|,
literal|"REPORT may only occur in a TEST-unit or test-refinement"
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|Stop
expr_stmt|;
break|break;
case|case
name|SUCCEED
case|:
if|if
condition|(
name|resexp
operator|!=
name|Rep
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3513
argument_list|,
literal|"SUCCEED may only occur in a TEST-unit or test-refinement"
argument_list|)
argument_list|)
expr_stmt|;
name|report
operator|=
name|Yes
expr_stmt|;
name|next
operator|=
name|Stop
expr_stmt|;
break|break;
case|case
name|FAIL
case|:
if|if
condition|(
name|resexp
operator|!=
name|Rep
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3514
argument_list|,
literal|"FAIL may only occur in a TEST-unit or test-refinement"
argument_list|)
argument_list|)
expr_stmt|;
name|report
operator|=
name|No
expr_stmt|;
name|next
operator|=
name|Stop
expr_stmt|;
break|break;
case|case
name|USER_COMMAND
case|:
name|x_user_command
argument_list|(
name|F
argument_list|(
name|UCMD_NAME
argument_list|)
argument_list|,
name|F
argument_list|(
name|UCMD_ACTUALS
argument_list|)
argument_list|,
name|F
argument_list|(
name|UCMD_DEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTENDED_COMMAND
case|:
ifdef|#
directive|ifdef
name|EXT_COMMAND
name|x_extended_command
argument_list|(
name|F
argument_list|(
name|ECMD_NAME
argument_list|)
argument_list|,
name|F
argument_list|(
name|ECMD_ACTUALS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Expressions, targets */
case|case
name|COLLATERAL
case|:
name|v
operator|=
name|mk_compound
argument_list|(
name|k
operator|=
name|Nfields
argument_list|(
name|F
argument_list|(
name|COLL_SEQ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|k
operator|>=
literal|0
condition|)
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
operator|=
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
comment|/* Expressions, targets */
case|case
name|SELECTION
case|:
name|Dyop
argument_list|(
name|ValOrLoc
argument_list|(
name|associate
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
argument_list|,
name|tbsel_loc
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BEHEAD
case|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|LocFlagged
argument_list|()
condition|?
name|trim_loc
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
literal|'@'
argument_list|)
else|:
name|behead
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|CURTAIL
case|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|LocFlagged
argument_list|()
condition|?
name|trim_loc
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
literal|'|'
argument_list|)
else|:
name|curtail
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONF
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|formula
argument_list|(
name|Vnil
argument_list|,
name|F
argument_list|(
name|MON_NAME
argument_list|)
argument_list|,
name|v
argument_list|,
name|F
argument_list|(
name|MON_FCT
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|DYAF
case|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|formula
argument_list|(
name|v
argument_list|,
name|F
argument_list|(
name|DYA_NAME
argument_list|)
argument_list|,
name|w
argument_list|,
name|F
argument_list|(
name|DYA_FCT
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXT_LIT
case|:
name|v
operator|=
name|F
argument_list|(
name|XLIT_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
argument_list|(
name|XLIT_NEXT
argument_list|)
condition|)
block|{
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|concat
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
else|else
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXT_CONV
case|:
if|if
condition|(
name|F
argument_list|(
name|XCON_NEXT
argument_list|)
condition|)
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|u
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|convert
argument_list|(
name|u
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|F
argument_list|(
name|XCON_NEXT
argument_list|)
condition|)
block|{
name|v
operator|=
name|concat
argument_list|(
name|u
operator|=
name|v
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELT_DIS
case|:
name|push
argument_list|(
name|mk_elt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_DIS
case|:
name|u
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|k
operator|=
name|Nfields
argument_list|(
name|F
argument_list|(
name|LDIS_SEQ
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|k
operator|>=
literal|0
condition|)
block|{
name|insert
argument_list|(
name|v
operator|=
name|pop
argument_list|()
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|push
argument_list|(
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|RANGE_DIS
case|:
name|Dyop
argument_list|(
name|mk_range
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAB_DIS
case|:
name|u
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|k
operator|=
name|Nfields
argument_list|(
name|F
argument_list|(
name|TDIS_SEQ
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|-=
literal|2
operator|)
operator|>=
literal|0
condition|)
block|{
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
comment|/* Should check for same key with different associate */
name|replace
argument_list|(
name|w
argument_list|,
operator|&
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|push
argument_list|(
name|u
argument_list|)
expr_stmt|;
break|break;
comment|/* Tests */
case|case
name|NOT
case|:
name|report
operator|=
operator|!
name|report
expr_stmt|;
break|break;
comment|/* Quantifiers can be described as follows:    Report X at first test which reports Y.  If no test reports Y, report !X.       type	X	Y       SOME	Yes	Yes       EACH	No	No       NO	No	Yes. */
case|case
name|EACH_IN
case|:
name|X
operator|=
name|Y
operator|=
name|No
expr_stmt|;
goto|goto
name|quant
goto|;
case|case
name|NO_IN
case|:
name|X
operator|=
name|No
expr_stmt|;
name|Y
operator|=
name|Yes
expr_stmt|;
goto|goto
name|quant
goto|;
case|case
name|SOME_IN
case|:
name|X
operator|=
name|Y
operator|=
name|Yes
expr_stmt|;
name|quant
label|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|Is_compound
argument_list|(
name|w
argument_list|)
operator|&&
name|report
operator|==
name|Y
condition|)
block|{
name|report
operator|=
name|X
expr_stmt|;
name|Jump
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|in_ranger
argument_list|(
name|v
argument_list|,
operator|&
name|w
argument_list|)
condition|)
block|{
name|report
operator|=
operator|!
name|X
expr_stmt|;
name|Jump
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|EACH_PARSING
case|:
name|X
operator|=
name|Y
operator|=
name|No
expr_stmt|;
goto|goto
name|parse
goto|;
case|case
name|NO_PARSING
case|:
name|X
operator|=
name|No
expr_stmt|;
name|Y
operator|=
name|Yes
expr_stmt|;
goto|goto
name|parse
goto|;
case|case
name|SOME_PARSING
case|:
name|X
operator|=
name|Y
operator|=
name|Yes
expr_stmt|;
name|parse
label|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|Is_compound
argument_list|(
name|w
argument_list|)
operator|&&
name|report
operator|==
name|Y
condition|)
block|{
name|report
operator|=
name|X
expr_stmt|;
name|Jump
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pa_ranger
argument_list|(
name|v
argument_list|,
operator|&
name|w
argument_list|)
condition|)
block|{
name|report
operator|=
operator|!
name|X
expr_stmt|;
name|Jump
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONPRD
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|proposition
argument_list|(
name|Vnil
argument_list|,
name|F
argument_list|(
name|MON_NAME
argument_list|)
argument_list|,
name|v
argument_list|,
name|F
argument_list|(
name|MON_FCT
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|DYAPRD
case|:
name|w
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|proposition
argument_list|(
name|v
argument_list|,
name|F
argument_list|(
name|DYA_NAME
argument_list|)
argument_list|,
name|w
argument_list|,
name|F
argument_list|(
name|DYA_FCT
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
name|LESS_THAN
case|:
name|Comp
argument_list|(
operator|<
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_MOST
case|:
name|Comp
argument_list|(
operator|<=
argument_list|)
expr_stmt|;
break|break;
case|case
name|GREATER_THAN
case|:
name|Comp
argument_list|(
operator|>
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_LEAST
case|:
name|Comp
argument_list|(
operator|>=
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQUAL
case|:
name|Comp
argument_list|(
operator|==
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEQUAL
case|:
name|Comp
argument_list|(
operator|!=
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGformal
case|:
name|call_formal
argument_list|(
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|,
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|,
name|LocFlagged
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGlocal
case|:
name|push
argument_list|(
name|ValOrLoc
argument_list|(
name|v_local
argument_list|(
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|,
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|)
argument_list|,
name|local_loc
argument_list|(
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGglobal
case|:
name|push
argument_list|(
name|ValOrLoc
argument_list|(
name|v_global
argument_list|(
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|)
argument_list|,
name|global_loc
argument_list|(
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGmystery
case|:
if|if
condition|(
name|LocFlagged
argument_list|()
condition|)
name|push
argument_list|(
name|l_mystery
argument_list|(
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|,
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|v_mystery
argument_list|(
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|,
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGrefinement
case|:
name|call_refinement
argument_list|(
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|,
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|,
name|Flagged
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGzerfun
case|:
name|formula
argument_list|(
name|Vnil
argument_list|,
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGzerprd
case|:
name|proposition
argument_list|(
name|Vnil
argument_list|,
name|F
argument_list|(
name|TAG_NAME
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|F
argument_list|(
name|TAG_ID
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|push
argument_list|(
name|copy
argument_list|(
name|F
argument_list|(
name|NUM_VALUE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3515
argument_list|,
literal|"run: bad node type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*>>>>>>>>>>>>>>>> */
block|}
name|v
operator|=
name|Vnil
expr_stmt|;
if|if
condition|(
name|wantvalue
operator|&&
name|still_ok
condition|)
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
comment|/* Unwind stack when stopped by error: */
while|while
condition|(
name|call_level
operator|!=
name|call_stop
condition|)
name|ret
argument_list|()
expr_stmt|;
name|next
operator|=
name|old_next
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* External interfaces: */
end_comment

begin_function
name|Visible
name|Procedure
name|execthread
parameter_list|(
name|start
parameter_list|)
name|parsetree
name|start
decl_stmt|;
block|{
name|run
argument_list|(
name|start
argument_list|,
name|No
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|value
name|evalthread
parameter_list|(
name|start
parameter_list|)
name|parsetree
name|start
decl_stmt|;
block|{
return|return
name|run
argument_list|(
name|start
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|initint
parameter_list|()
block|{
comment|/* Dummy, relict */
block|}
end_function

end_unit

