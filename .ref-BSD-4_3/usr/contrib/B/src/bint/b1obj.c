begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1obj.c,v 1.4 85/08/22 16:52:13 timo Exp $ */
end_comment

begin_comment
comment|/* Generic routines for all values */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_include
include|#
directive|include
file|"b1btr.h"
end_include

begin_include
include|#
directive|include
file|"b1val.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"b1tlt.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3typ.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_decl_stmt
name|Visible
name|bool
name|comp_ok
init|=
name|Yes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary, to catch type errors */
end_comment

begin_decl_stmt
name|relation
name|comp_tlt
argument_list|()
decl_stmt|,
name|comp_text
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From b1lta.c */
end_comment

begin_function
name|Hidden
name|Procedure
name|incompatible
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|value
name|message
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|,
name|m4
decl_stmt|,
name|m5
decl_stmt|,
name|m6
decl_stmt|;
name|message
operator|=
name|concat
argument_list|(
name|m1
operator|=
name|convert
argument_list|(
name|m2
operator|=
operator|(
name|value
operator|)
name|valtype
argument_list|(
name|v
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|,
name|m3
operator|=
name|concat
argument_list|(
name|m4
operator|=
name|mk_text
argument_list|(
literal|" and "
argument_list|)
argument_list|,
name|m5
operator|=
name|convert
argument_list|(
name|m6
operator|=
operator|(
name|value
operator|)
name|valtype
argument_list|(
name|w
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error2
argument_list|(
name|MESS
argument_list|(
literal|1400
argument_list|,
literal|"incompatible types "
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|m3
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|m4
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|m5
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|m6
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|relation
name|compare
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|literal
name|vt
decl_stmt|,
name|wt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|relation
name|rel
decl_stmt|;
name|comp_ok
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
name|v
name|EQ
name|w
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|IsSmallInt
argument_list|(
name|v
argument_list|)
operator|&&
name|IsSmallInt
argument_list|(
name|w
argument_list|)
condition|)
return|return
name|SmallIntVal
argument_list|(
name|v
argument_list|)
operator|-
name|SmallIntVal
argument_list|(
name|w
argument_list|)
return|;
name|vt
operator|=
name|Type
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|wt
operator|=
name|Type
argument_list|(
name|w
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vt
condition|)
block|{
case|case
name|Num
case|:
if|if
condition|(
name|wt
operator|!=
name|Num
condition|)
block|{
name|incomp
label|:
comment|/*Temporary until static checks are implemented*/
name|incompatible
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|comp_ok
operator|=
name|No
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|numcomp
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
operator|)
return|;
case|case
name|Com
case|:
if|if
condition|(
name|wt
operator|!=
name|Com
operator|||
name|Nfields
argument_list|(
name|v
argument_list|)
operator|!=
name|Nfields
argument_list|(
name|w
argument_list|)
condition|)
goto|goto
name|incomp
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Nfields
argument_list|(
name|v
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rel
operator|=
name|compare
argument_list|(
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
argument_list|,
operator|*
name|Field
argument_list|(
name|w
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
name|NE
literal|0
condition|)
return|return
operator|(
name|rel
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Tex
case|:
if|if
condition|(
name|wt
operator|!=
name|Tex
condition|)
goto|goto
name|incomp
goto|;
return|return
operator|(
name|comp_text
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
operator|)
return|;
case|case
name|Lis
case|:
if|if
condition|(
name|wt
operator|!=
name|Lis
operator|&&
name|wt
operator|!=
name|ELT
condition|)
goto|goto
name|incomp
goto|;
return|return
operator|(
name|comp_tlt
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
operator|)
return|;
case|case
name|Tab
case|:
if|if
condition|(
name|wt
operator|!=
name|Tab
operator|&&
name|wt
operator|!=
name|ELT
condition|)
goto|goto
name|incomp
goto|;
return|return
operator|(
name|comp_tlt
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
operator|)
return|;
case|case
name|ELT
case|:
if|if
condition|(
name|wt
operator|!=
name|Tab
operator|&&
name|wt
operator|!=
name|Lis
operator|&&
name|wt
operator|!=
name|ELT
condition|)
goto|goto
name|incomp
goto|;
return|return
operator|(
name|Root
argument_list|(
argument|w
argument_list|)
name|EQ
name|Bnil
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1401
argument_list|,
literal|"comparison of unknown types"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_function

begin_comment
comment|/* Used for set'random. Needs to be rewritten so that for small changes in v */
end_comment

begin_comment
comment|/* you get large changes in hash(v) */
end_comment

begin_function
name|Visible
name|double
name|hash
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
name|Is_number
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|numhash
argument_list|(
name|v
argument_list|)
return|;
elseif|else
if|if
condition|(
name|Is_compound
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|Nfields
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|double
name|d
init|=
literal|.404
operator|*
name|len
decl_stmt|;
name|k_Overfields
block|{
name|d
operator|=
literal|.874
operator|*
name|d
operator|+
literal|.310
operator|*
name|hash
argument_list|(
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
else|else
block|{
name|int
name|len
init|=
name|length
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|double
name|d
init|=
literal|.404
operator|*
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|.909
return|;
elseif|else
if|if
condition|(
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|value
name|ch
decl_stmt|;
name|k_Over_len
block|{
name|ch
operator|=
name|thof
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|d
operator|=
literal|.987
operator|*
name|d
operator|+
literal|.277
operator|*
name|charval
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
elseif|else
if|if
condition|(
name|Is_list
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|value
name|el
decl_stmt|;
name|k_Over_len
block|{
name|d
operator|=
literal|.874
operator|*
name|d
operator|+
literal|.310
operator|*
name|hash
argument_list|(
name|el
operator|=
name|thof
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
elseif|else
if|if
condition|(
name|Is_table
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|k_Over_len
block|{
name|d
operator|=
literal|.874
operator|*
name|d
operator|+
literal|.310
operator|*
name|hash
argument_list|(
operator|*
name|key
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|)
operator|+
literal|.123
operator|*
name|hash
argument_list|(
operator|*
name|assoc
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
else|else
block|{
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1402
argument_list|,
literal|"hash called with unknown type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|double
operator|)
name|Dummy
return|;
block|}
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|concato
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|value
modifier|*
name|v
decl_stmt|;
name|value
name|t
decl_stmt|;
block|{
name|value
name|v1
init|=
operator|*
name|v
decl_stmt|;
operator|*
name|v
operator|=
name|concat
argument_list|(
operator|*
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|value
name|convert
parameter_list|(
name|v
parameter_list|,
name|coll
parameter_list|,
name|outer
parameter_list|)
name|value
name|v
decl_stmt|;
name|bool
name|coll
decl_stmt|,
name|outer
decl_stmt|;
block|{
name|value
name|t
decl_stmt|,
name|quote
decl_stmt|,
name|c
decl_stmt|,
name|cv
decl_stmt|,
name|sep
decl_stmt|,
name|th
decl_stmt|,
name|open
decl_stmt|,
name|close
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
decl_stmt|;
name|char
name|ch
decl_stmt|;
switch|switch
condition|(
name|Type
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
name|Num
case|:
return|return
name|mk_text
argument_list|(
name|convnum
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
case|case
name|Tex
case|:
if|if
condition|(
name|outer
condition|)
return|return
name|copy
argument_list|(
name|v
argument_list|)
return|;
name|quote
operator|=
name|mk_text
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|len
operator|=
name|length
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|t
operator|=
name|copy
argument_list|(
name|quote
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|len
condition|;
name|k
operator|++
control|)
block|{
name|c
operator|=
name|thof
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|ch
operator|=
name|charval
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
operator|||
name|ch
operator|==
literal|'`'
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|quote
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|quote
argument_list|)
expr_stmt|;
break|break;
case|case
name|Com
case|:
name|len
operator|=
name|Nfields
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|outer
operator|&=
name|coll
expr_stmt|;
name|sep
operator|=
name|mk_text
argument_list|(
name|outer
condition|?
literal|" "
else|:
literal|", "
argument_list|)
expr_stmt|;
name|t
operator|=
name|mk_text
argument_list|(
name|coll
condition|?
literal|""
else|:
literal|"("
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|convert
argument_list|(
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|No
argument_list|,
name|outer
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Last
argument_list|(
name|k
argument_list|)
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|coll
condition|)
block|{
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|mk_text
argument_list|(
literal|")"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Lis
case|:
case|case
name|ELT
case|:
name|len
operator|=
name|length
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|t
operator|=
name|mk_text
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|sep
operator|=
name|mk_text
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|len
condition|;
name|k
operator|++
control|)
block|{
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|convert
argument_list|(
name|th
operator|=
name|thof
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|len
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|sep
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|mk_text
argument_list|(
literal|"}"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tab
case|:
name|len
operator|=
name|length
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|open
operator|=
name|mk_text
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|close
operator|=
name|mk_text
argument_list|(
literal|"]: "
argument_list|)
expr_stmt|;
name|sep
operator|=
name|mk_text
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|t
operator|=
name|mk_text
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|open
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|convert
argument_list|(
operator|*
name|key
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|close
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|convert
argument_list|(
operator|*
name|assoc
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Last
argument_list|(
name|k
argument_list|)
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|mk_text
argument_list|(
literal|"}"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|open
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|close
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|sep
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|bugs
operator|||
name|testing
condition|)
block|{
name|t
operator|=
name|mk_text
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|mkchar
argument_list|(
name|Type
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cv
operator|=
name|mkchar
argument_list|(
literal|'$'
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
break|break;
block|}
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1403
argument_list|,
literal|"unknown type in convert"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|adj
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|,
name|side
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
name|char
name|side
decl_stmt|;
block|{
name|value
name|t
decl_stmt|,
name|c
decl_stmt|,
name|sp
decl_stmt|,
name|r
decl_stmt|,
name|i
decl_stmt|;
name|int
name|len
decl_stmt|,
name|wid
decl_stmt|,
name|diff
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
name|c
operator|=
name|convert
argument_list|(
name|v
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|len
operator|=
name|length
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|wid
operator|=
name|intval
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|wid
operator|<=
name|len
condition|)
return|return
name|c
return|;
else|else
block|{
name|diff
operator|=
name|wid
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|side
operator|==
literal|'L'
condition|)
block|{
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
name|diff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|side
operator|==
literal|'R'
condition|)
block|{
name|left
operator|=
name|diff
expr_stmt|;
name|right
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|left
operator|=
name|diff
operator|/
literal|2
expr_stmt|;
name|right
operator|=
operator|(
name|diff
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
name|sp
operator|=
name|mk_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
name|t
operator|=
name|c
expr_stmt|;
else|else
block|{
name|t
operator|=
name|repeat
argument_list|(
name|sp
argument_list|,
name|i
operator|=
name|mk_integer
argument_list|(
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|repeat
argument_list|(
name|sp
argument_list|,
name|i
operator|=
name|mk_integer
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|adjleft
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
return|return
name|adj
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
literal|'L'
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|adjright
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
return|return
name|adj
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
literal|'R'
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|centre
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
return|return
name|adj
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
literal|'C'
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
else|INTEGRATION
end_else

begin_define
define|#
directive|define
name|Sgn
parameter_list|(
name|d
parameter_list|)
value|(d)
end_define

begin_function
name|Visible
name|relation
name|compare
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
name|literal
name|vt
init|=
name|Type
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|wt
init|=
name|Type
argument_list|(
name|w
argument_list|)
decl_stmt|;
specifier|register
name|intlet
name|vlen
decl_stmt|,
name|wlen
decl_stmt|,
name|len
decl_stmt|,
name|k
decl_stmt|;
name|value
name|message
decl_stmt|;
name|vlen
operator|=
name|IsSmallInt
argument_list|(
name|v
argument_list|)
condition|?
literal|0
else|:
name|Length
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|wlen
operator|=
name|IsSmallInt
argument_list|(
name|w
argument_list|)
condition|?
literal|0
else|:
name|Length
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|w
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|vt
operator|==
name|wt
operator|&&
operator|!
operator|(
name|vt
operator|==
name|Com
operator|&&
name|vlen
operator|!=
name|wlen
operator|)
operator|||
name|vt
operator|==
name|ELT
operator|&&
operator|(
name|wt
operator|==
name|Lis
operator|||
name|wt
operator|==
name|Tab
operator|)
operator|||
name|wt
operator|==
name|ELT
operator|&&
operator|(
name|vt
operator|==
name|Lis
operator|||
name|vt
operator|==
name|Tab
operator|)
operator|)
condition|)
block|{
name|message
operator|=
name|concat
argument_list|(
name|convert
argument_list|(
operator|(
name|value
operator|)
name|valtype
argument_list|(
name|v
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|,
name|concat
argument_list|(
name|mk_text
argument_list|(
literal|" and "
argument_list|)
argument_list|,
name|convert
argument_list|(
operator|(
name|value
operator|)
name|valtype
argument_list|(
name|w
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error2
argument_list|(
name|MESS
argument_list|(
literal|1404
argument_list|,
literal|"incompatible types "
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
comment|/*doesn't return: so can't release message*/
block|}
if|if
condition|(
name|vt
operator|!=
name|Num
operator|&&
operator|(
name|vlen
operator|==
literal|0
operator|||
name|wlen
operator|==
literal|0
operator|)
condition|)
return|return
name|Sgn
argument_list|(
name|vlen
operator|-
name|wlen
argument_list|)
return|;
switch|switch
condition|(
name|vt
condition|)
block|{
case|case
name|Num
case|:
return|return
name|numcomp
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
return|;
case|case
name|Tex
case|:
return|return
name|strcmp
argument_list|(
name|Str
argument_list|(
name|v
argument_list|)
argument_list|,
name|Str
argument_list|(
name|w
argument_list|)
argument_list|)
return|;
case|case
name|Com
case|:
case|case
name|Lis
case|:
case|case
name|Tab
case|:
case|case
name|ELT
case|:
block|{
name|value
modifier|*
name|vp
init|=
name|Ats
argument_list|(
name|v
argument_list|)
decl_stmt|,
modifier|*
name|wp
init|=
name|Ats
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|relation
name|c
decl_stmt|;
name|len
operator|=
name|vlen
operator|<
name|wlen
condition|?
name|vlen
else|:
name|wlen
expr_stmt|;
name|Overall
if|if
condition|(
operator|(
name|c
operator|=
name|compare
argument_list|(
operator|*
name|vp
operator|++
argument_list|,
operator|*
name|wp
operator|++
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|c
return|;
return|return
name|Sgn
argument_list|(
name|vlen
operator|-
name|wlen
argument_list|)
return|;
block|}
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1405
argument_list|,
literal|"comparison of unknown types"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
name|Visible
name|double
name|hash
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|literal
name|t
init|=
name|Type
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|intlet
name|len
init|=
name|Length
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|double
name|d
init|=
name|t
operator|+
literal|.404
operator|*
name|len
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|Num
case|:
return|return
name|numhash
argument_list|(
name|v
argument_list|)
return|;
case|case
name|Tex
case|:
block|{
name|string
name|vp
init|=
name|Str
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|Overall
name|d
init|=
literal|.987
operator|*
name|d
operator|+
literal|.277
operator|*
operator|(
operator|*
name|vp
operator|++
operator|)
decl_stmt|;
return|return
name|d
return|;
block|}
case|case
name|Com
case|:
case|case
name|Lis
case|:
case|case
name|Tab
case|:
case|case
name|ELT
case|:
block|{
name|value
modifier|*
name|vp
init|=
name|Ats
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|.909
return|;
name|Overall
name|d
init|=
literal|.874
operator|*
name|d
operator|+
literal|.310
operator|*
name|hash
argument_list|(
operator|*
name|vp
operator|++
argument_list|)
decl_stmt|;
return|return
name|d
return|;
block|}
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1406
argument_list|,
literal|"hash called with unknown type"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|INTEGRATION
end_endif

end_unit

