begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*  * $Header: b1tex.c,v 1.4 85/08/22 16:52:36 timo Exp $  */
end_comment

begin_comment
comment|/* B texts */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_include
include|#
directive|include
file|"b1btr.h"
end_include

begin_include
include|#
directive|include
file|"b1val.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"b1tlt.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_comment
comment|/*  * Operations on texts represented as B-trees.  *  * Comments:  * - The functions with 'i' prepended (ibehead, etc.) do no argument  *   checking at all.  They actually implement the planned behaviour  *   of | and @, where out-of-bounds numerical values are truncated  *   rather than causing errors ("abc"|100 = "abc"@-100 = "abc").  * - The 'size' field of all texts must fit in a C int.  If the result of  *   ^ or ^^ would exceed Maxint in size, a user error is signalled.  If  *   the size of the *input* value(s) of any operation is Bigsize, a syserr  *   is signalled.  * - Argument checking: trims, concat and repeat must check their arguments  *   for user errors.  * - t^^n is implemented with an algorithm similar to the 'square and  *   multiply' algorithm for x**n, using the binary representation of n,  *   but it uses straightforward 'concat' operations.  A more efficient  *   scheme is possible [see IW219], but small code seems more important.  * - Degenerated cases (e.g. t@1, t|0, t^'' or t^^n) are not optimized,  *   but produce the desired result by virtue of the algorithms used.  *   The extra checking does not seem worth the overhead for the  *   non-degenerate cases.  * - The code for PUT v IN t@h|l is still there, but it is not compiled,  *   as the interpreter implements the same strategy directly.  * - 'trim()' is only used by f_uname in "b3fil.c".  * - Code for outputting texts has been added.	This is called from wri()  *   to output a text, and has running time O(n), compared to O(n log n)  *   for the old code in wri().  *  * *** WARNING ***  * - The 'zip' routine and its subroutine 'copynptrs' assume that items and  *   pointers are stored contiguously, so that&Ptr(p, i+1) ==&Ptr(p, i)+1  *   and&[IB]char(p, i+1) ==&[IB]char(p, i)+1.  For pointers, the order  *   might be reversed in the future; then change the macro Incr(pp, n) below  *   to *decrement* the pointer!  * - Mkbtext and bstrval make the same assumption about items (using strncpy  *   to move charaters to/from a bottom node).  */
end_comment

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_define
define|#
directive|define
name|IsInner
parameter_list|(
name|p
parameter_list|)
value|(Flag(p) == Inner)
end_define

begin_define
define|#
directive|define
name|IsBottom
parameter_list|(
name|p
parameter_list|)
value|(Flag(p) == Bottom)
end_define

begin_define
define|#
directive|define
name|Incr
parameter_list|(
name|pp
parameter_list|,
name|n
parameter_list|)
value|((pp) += (n))
end_define

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* make a B text out of a C char */
end_comment

begin_function
name|Visible
name|value
name|mkchar
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|mk_text
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|char
name|charval
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Character
argument_list|(
name|v
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1600
argument_list|,
literal|"charval on non-char"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Bchar
argument_list|(
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|character
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|Character
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Hidden
name|btreeptr
name|mkbtext
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|string
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|btreeptr
name|p
decl_stmt|;
name|int
name|chunk
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|nbig
decl_stmt|;
comment|/* 	 * Determine level of tree. 	 * This is done for each inner node anew, to avoid having 	 * to keep an explicit stack. 	 * Problem is: make sure that for each node at the same 	 * level, the computation indeed finds the same level! 	 * (Don't care about efficiency here; in practice the trees 	 * built by mk_text rarely need more than two levels.) 	 */
name|chunk
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|Maxbottom
expr_stmt|;
comment|/* Next larger chunk size */
while|while
condition|(
name|len
operator|>
name|i
condition|)
block|{
name|chunk
operator|=
name|i
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|Maxinner
operator|+
name|Maxinner
expr_stmt|;
block|}
name|n
operator|=
name|len
operator|/
operator|(
name|chunk
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Number of items at this level; n+1 subtrees */
name|chunk
operator|=
name|len
operator|/
operator|(
name|n
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Use minimal chunk size for subtrees */
name|p
operator|=
name|grabbtreenode
argument_list|(
name|chunk
condition|?
name|Inner
else|:
name|Bottom
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
name|Size
argument_list|(
name|p
argument_list|)
operator|=
name|len
expr_stmt|;
name|Lim
argument_list|(
name|p
argument_list|)
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|chunk
condition|)
name|strncpy
argument_list|(
operator|&
name|Bchar
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|nbig
operator|=
name|len
operator|+
literal|1
operator|-
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
name|chunk
expr_stmt|;
comment|/* There will be 'nbig' nodes of size 'chunk'. */
comment|/* The remaining 'n-nbig' will have size 'chunk-1'. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|mkbtext
argument_list|(
name|s
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|s
operator|+=
name|chunk
expr_stmt|;
name|Ichar
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|len
operator|-=
name|chunk
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|nbig
operator|==
literal|0
condition|)
operator|--
name|chunk
expr_stmt|;
comment|/* This was the last 'big' node */
block|}
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
operator|=
name|mkbtext
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|mk_text
parameter_list|(
name|s
parameter_list|)
name|string
name|s
decl_stmt|;
block|{
name|value
name|v
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|v
operator|=
name|grab_tlt
argument_list|(
name|Tex
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|Root
argument_list|(
name|v
argument_list|)
operator|=
name|Bnil
expr_stmt|;
else|else
name|Root
argument_list|(
name|v
argument_list|)
operator|=
name|mkbtext
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Hidden
name|string
name|bstrval
parameter_list|(
name|buf
parameter_list|,
name|p
parameter_list|)
name|string
name|buf
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
block|{
comment|/* Returns *next* available position in buffer */
name|int
name|i
decl_stmt|,
name|n
init|=
name|Lim
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|IsInner
argument_list|(
name|p
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|buf
operator|=
name|bstrval
argument_list|(
name|buf
argument_list|,
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|Ichar
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|bstrval
argument_list|(
name|buf
argument_list|,
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|)
return|;
block|}
name|strncpy
argument_list|(
name|buf
argument_list|,
operator|&
name|Bchar
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|buf
operator|+
name|n
return|;
block|}
end_function

begin_function
name|Visible
name|string
name|strval
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|len
init|=
name|Tltsize
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|Bigsize
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1601
argument_list|,
literal|"strval on big text"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|regetmem
argument_list|(
operator|&
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|buffer
operator|=
name|getmem
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|bstrval
argument_list|(
name|buffer
argument_list|,
name|Root
argument_list|(
name|v
argument_list|)
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|stackelem
block|{
name|btreeptr
name|s_ptr
decl_stmt|;
name|int
name|s_lim
decl_stmt|;
block|}
name|stackelem
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|stackelem
name|stack
index|[
name|Maxheight
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|stackelem
modifier|*
name|stackptr
typedef|;
end_typedef

begin_define
define|#
directive|define
name|Snil
value|((stackptr)0)
end_define

begin_define
define|#
directive|define
name|Push
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|((s)->s_ptr = (p), ((s)->s_lim = (l)), (s)++)
end_define

begin_define
define|#
directive|define
name|Pop
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|(--(s), (p) = (s)->s_ptr, (l) = (s)->s_lim)
end_define

begin_function_decl
specifier|extern
name|stackptr
name|unzip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Procedure
name|cpynptrs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|movnptrs
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Hidden
name|btreeptr
name|zip
parameter_list|(
name|s1
parameter_list|,
name|sp1
parameter_list|,
name|s2
parameter_list|,
name|sp2
parameter_list|)
name|stackptr
name|s1
decl_stmt|,
name|sp1
decl_stmt|,
name|s2
decl_stmt|,
name|sp2
decl_stmt|;
block|{
name|btreeptr
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|newptr
index|[
literal|2
index|]
decl_stmt|;
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|n2
decl_stmt|;
define|#
directive|define
name|q1
value|newptr[0]
define|#
directive|define
name|q2
value|newptr[1]
name|char
name|newitem
decl_stmt|;
name|bool
name|overflow
decl_stmt|,
name|underflow
decl_stmt|,
name|inner
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|btreeptr
modifier|*
name|pp
decl_stmt|;
name|char
name|cbuf
index|[
literal|2
operator|*
name|Maxbottom
index|]
decl_stmt|;
name|btreeptr
name|pbuf
index|[
literal|2
operator|*
name|Maxinner
operator|+
literal|2
index|]
decl_stmt|;
while|while
condition|(
name|s1
operator|<
name|sp1
operator|&&
name|s1
operator|->
name|s_lim
operator|==
literal|0
condition|)
operator|++
name|s1
expr_stmt|;
while|while
condition|(
name|s2
operator|<
name|sp2
operator|&&
name|s2
operator|->
name|s_lim
operator|==
name|Lim
argument_list|(
name|s2
operator|->
name|s_ptr
argument_list|)
condition|)
operator|++
name|s2
expr_stmt|;
name|inner
operator|=
name|overflow
operator|=
name|underflow
operator|=
name|No
expr_stmt|;
name|q1
operator|=
name|Bnil
expr_stmt|;
while|while
condition|(
name|s1
operator|<
name|sp1
operator|||
name|s2
operator|<
name|sp2
condition|)
block|{
if|if
condition|(
name|s1
operator|<
name|sp1
condition|)
name|Pop
argument_list|(
name|sp1
argument_list|,
name|p1
argument_list|,
name|l1
argument_list|)
expr_stmt|;
else|else
name|p1
operator|=
name|Bnil
expr_stmt|;
if|if
condition|(
name|s2
operator|<
name|sp2
condition|)
name|Pop
argument_list|(
name|sp2
argument_list|,
name|p2
argument_list|,
name|l2
argument_list|)
expr_stmt|;
else|else
name|p2
operator|=
name|Bnil
expr_stmt|;
name|cp
operator|=
name|cbuf
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|Bnil
condition|)
block|{
name|strncpy
argument_list|(
name|cp
argument_list|,
operator|(
name|inner
condition|?
operator|&
name|Ichar
argument_list|(
name|p1
argument_list|,
literal|0
argument_list|)
else|:
operator|&
name|Bchar
argument_list|(
name|p1
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|l1
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
operator|*
name|cp
operator|++
operator|=
name|newitem
expr_stmt|;
name|n
operator|=
name|cp
operator|-
name|cbuf
expr_stmt|;
if|if
condition|(
name|p2
operator|!=
name|Bnil
condition|)
block|{
name|strncpy
argument_list|(
name|cp
argument_list|,
operator|(
name|inner
condition|?
operator|&
name|Ichar
argument_list|(
name|p2
argument_list|,
name|l2
argument_list|)
else|:
operator|&
name|Bchar
argument_list|(
name|p2
argument_list|,
name|l2
argument_list|)
operator|)
argument_list|,
name|Lim
argument_list|(
name|p2
argument_list|)
operator|-
name|l2
argument_list|)
expr_stmt|;
name|n
operator|+=
name|Lim
argument_list|(
name|p2
argument_list|)
operator|-
name|l2
expr_stmt|;
block|}
if|if
condition|(
name|inner
condition|)
block|{
name|pp
operator|=
name|pbuf
expr_stmt|;
comment|/***** Change if reverse direction! *****/
if|if
condition|(
name|p1
operator|!=
name|Bnil
condition|)
block|{
name|cpynptrs
argument_list|(
name|pp
argument_list|,
operator|&
name|Ptr
argument_list|(
name|p1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|pp
argument_list|,
name|l1
argument_list|)
expr_stmt|;
block|}
name|movnptrs
argument_list|(
name|pp
argument_list|,
name|newptr
argument_list|,
literal|1
operator|+
name|overflow
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|pp
argument_list|,
literal|1
operator|+
name|overflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|!=
name|Bnil
condition|)
block|{
name|cpynptrs
argument_list|(
name|pp
argument_list|,
operator|&
name|Ptr
argument_list|(
name|p2
argument_list|,
name|l2
operator|+
literal|1
argument_list|)
argument_list|,
name|Lim
argument_list|(
name|p2
argument_list|)
operator|-
name|l2
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|pp
argument_list|,
name|Lim
argument_list|(
name|p2
argument_list|)
operator|-
name|l2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|underflow
condition|)
block|{
name|underflow
operator|=
name|No
expr_stmt|;
name|n
operator|=
name|uflow
argument_list|(
name|n
argument_list|,
name|p1
condition|?
name|l1
else|:
literal|0
argument_list|,
name|cbuf
argument_list|,
name|pbuf
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
block|}
block|}
name|overflow
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
name|inner
condition|?
name|Maxinner
else|:
name|Maxbottom
operator|)
condition|)
block|{
name|overflow
operator|=
name|Yes
expr_stmt|;
name|n2
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|n
operator|-=
name|n2
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
operator|(
name|inner
condition|?
name|Mininner
else|:
name|Minbottom
operator|)
condition|)
name|underflow
operator|=
name|Yes
expr_stmt|;
name|q1
operator|=
name|grabbtreenode
argument_list|(
name|inner
condition|?
name|Inner
else|:
name|Bottom
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
name|Lim
argument_list|(
name|q1
argument_list|)
operator|=
name|n
expr_stmt|;
name|cp
operator|=
name|cbuf
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|inner
condition|?
operator|&
name|Ichar
argument_list|(
name|q1
argument_list|,
literal|0
argument_list|)
else|:
operator|&
name|Bchar
argument_list|(
name|q1
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|pp
operator|=
name|pbuf
expr_stmt|;
name|i
operator|=
name|movnptrs
argument_list|(
operator|&
name|Ptr
argument_list|(
name|q1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pp
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|pp
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n
operator|+=
name|i
expr_stmt|;
block|}
name|Size
argument_list|(
name|q1
argument_list|)
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
name|newitem
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|q2
operator|=
name|grabbtreenode
argument_list|(
name|inner
condition|?
name|Inner
else|:
name|Bottom
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
name|Lim
argument_list|(
name|q2
argument_list|)
operator|=
name|n2
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|inner
condition|?
operator|&
name|Ichar
argument_list|(
name|q2
argument_list|,
literal|0
argument_list|)
else|:
operator|&
name|Bchar
argument_list|(
name|q2
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|,
name|cp
argument_list|,
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
condition|)
name|n2
operator|+=
name|movnptrs
argument_list|(
operator|&
name|Ptr
argument_list|(
name|q2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pp
argument_list|,
name|n2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Size
argument_list|(
name|q2
argument_list|)
operator|=
name|n2
expr_stmt|;
block|}
name|inner
operator|=
name|Yes
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
name|q1
operator|=
name|mknewroot
argument_list|(
name|q1
argument_list|,
operator|(
name|itemptr
operator|)
operator|&
name|newitem
argument_list|,
name|q2
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
return|return
name|q1
return|;
undef|#
directive|undef
name|q1
undef|#
directive|undef
name|q2
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Hidden
name|value
name|ibehead
parameter_list|(
name|v
parameter_list|,
name|h
parameter_list|)
name|value
name|v
decl_stmt|;
name|int
name|h
decl_stmt|;
block|{
comment|/* v@h */
name|stack
name|s
decl_stmt|;
name|stackptr
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
name|stackptr
operator|)
name|unzip
argument_list|(
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
name|h
operator|-
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|v
operator|=
name|grab_tlt
argument_list|(
name|Tex
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
name|Root
argument_list|(
name|v
argument_list|)
operator|=
name|zip
argument_list|(
name|Snil
argument_list|,
name|Snil
argument_list|,
name|s
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|icurtail
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|value
name|v
decl_stmt|;
name|int
name|t
decl_stmt|;
block|{
comment|/* v|t */
name|stack
name|s
decl_stmt|;
name|stackptr
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
name|stackptr
operator|)
name|unzip
argument_list|(
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|v
operator|=
name|grab_tlt
argument_list|(
name|Tex
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
name|Root
argument_list|(
name|v
argument_list|)
operator|=
name|zip
argument_list|(
name|s
argument_list|,
name|sp
argument_list|,
name|Snil
argument_list|,
name|Snil
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|iconcat
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
block|{
comment|/* v^w */
name|stack
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|stackptr
name|sp1
init|=
operator|(
name|stackptr
operator|)
name|unzip
argument_list|(
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
name|Tltsize
argument_list|(
name|v
argument_list|)
argument_list|,
name|s1
argument_list|)
decl_stmt|;
name|stackptr
name|sp2
init|=
operator|(
name|stackptr
operator|)
name|unzip
argument_list|(
name|Root
argument_list|(
name|w
argument_list|)
argument_list|,
literal|0
argument_list|,
name|s2
argument_list|)
decl_stmt|;
name|v
operator|=
name|grab_tlt
argument_list|(
name|Tex
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
name|Root
argument_list|(
name|v
argument_list|)
operator|=
name|zip
argument_list|(
name|s1
argument_list|,
name|sp1
argument_list|,
name|s2
argument_list|,
name|sp2
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Odd
parameter_list|(
name|n
parameter_list|)
value|(((n)&1) != 0)
end_define

begin_function
name|Hidden
name|value
name|irepeat
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
name|value
name|v
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
comment|/* v^^n */
name|value
name|x
decl_stmt|,
name|w
init|=
name|grab_tlt
argument_list|(
name|Tex
argument_list|,
name|Ct
argument_list|)
decl_stmt|;
name|Root
argument_list|(
name|w
argument_list|)
operator|=
name|Bnil
expr_stmt|;
name|v
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|Odd
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|w
operator|=
name|iconcat
argument_list|(
name|x
operator|=
name|w
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|n
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
name|v
operator|=
name|iconcat
argument_list|(
name|x
operator|=
name|v
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED_CODE
end_ifdef

begin_function
name|Hidden
name|value
name|jrepeat
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
name|value
name|v
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
comment|/* v^^n, recursive solution */
name|value
name|w
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|copy
argument_list|(
name|v
argument_list|)
return|;
name|w
operator|=
name|grab_tlt
argument_list|(
name|Tex
argument_list|,
name|Ct
argument_list|)
expr_stmt|;
name|Root
argument_list|(
name|w
argument_list|)
operator|=
name|Bnil
expr_stmt|;
return|return
name|w
return|;
block|}
name|w
operator|=
name|jrepeat
argument_list|(
name|v
argument_list|,
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
name|w
operator|=
name|iconcat
argument_list|(
name|x
operator|=
name|w
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|Odd
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|w
operator|=
name|iconcat
argument_list|(
name|x
operator|=
name|w
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|w
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|UNUSED_CODE
end_endif

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Visible
name|value
name|curtail
parameter_list|(
name|t
parameter_list|,
name|after
parameter_list|)
name|value
name|t
decl_stmt|,
name|after
decl_stmt|;
block|{
name|int
name|syzcurv
decl_stmt|,
name|syztext
decl_stmt|;
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1602
argument_list|,
literal|"in t|n, t is not a text"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|after
argument_list|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1603
argument_list|,
literal|"in t|n, n is not a number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|syztext
operator|=
name|Tltsize
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|syztext
operator|==
name|Bigsize
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1604
argument_list|,
literal|"curtail on very big text"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|large
argument_list|(
name|after
argument_list|)
operator|||
operator|(
name|syzcurv
operator|=
name|intval
argument_list|(
name|after
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|syztext
operator|<
name|syzcurv
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1605
argument_list|,
literal|"in t|n, n is out of bounds"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
return|return
name|icurtail
argument_list|(
name|t
argument_list|,
name|syzcurv
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|behead
parameter_list|(
name|t
parameter_list|,
name|before
parameter_list|)
name|value
name|t
decl_stmt|,
name|before
decl_stmt|;
block|{
name|int
name|syzbehv
decl_stmt|,
name|syztext
decl_stmt|;
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1606
argument_list|,
literal|"in t@n, t is not a text"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|before
argument_list|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1607
argument_list|,
literal|"in t@n, n is not a number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|syztext
operator|=
name|Tltsize
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|syztext
operator|==
name|Bigsize
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1608
argument_list|,
literal|"behead on very big text"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|large
argument_list|(
name|before
argument_list|)
operator|||
operator|(
name|syzbehv
operator|=
name|intval
argument_list|(
name|before
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|syztext
operator|<
name|syzbehv
operator|-
literal|1
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1609
argument_list|,
literal|"in t@n, n is out of bounds"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
return|return
name|ibehead
argument_list|(
name|t
argument_list|,
name|syzbehv
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_function
name|Visible
name|value
name|trim
parameter_list|(
name|v
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|value
name|v
decl_stmt|;
name|intlet
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
comment|/*temporary*/
comment|/* Only used in f_uname */
name|int
name|len
init|=
name|Tltsize
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|value
name|r
init|=
name|ibehead
argument_list|(
name|v
argument_list|,
name|b
operator|+
literal|1
argument_list|)
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|icurtail
argument_list|(
name|r
argument_list|,
name|len
operator|-
name|b
operator|-
name|c
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Visible
name|value
name|concat
parameter_list|(
name|tleft
parameter_list|,
name|tright
parameter_list|)
name|value
name|tleft
decl_stmt|,
name|tright
decl_stmt|;
block|{
name|int
name|syzleft
decl_stmt|,
name|syzright
decl_stmt|;
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|tleft
argument_list|)
operator|||
operator|!
name|Is_text
argument_list|(
name|tright
argument_list|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1610
argument_list|,
literal|"in t^u, t or u is not a text"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|syzleft
operator|=
name|Tltsize
argument_list|(
name|tleft
argument_list|)
expr_stmt|;
name|syzright
operator|=
name|Tltsize
argument_list|(
name|tright
argument_list|)
expr_stmt|;
if|if
condition|(
name|syzleft
operator|==
name|Bigsize
operator|||
name|syzright
operator|==
name|Bigsize
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1611
argument_list|,
literal|"concat on very big text"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|syzleft
operator|>
name|Maxint
operator|-
name|syzright
operator|||
name|syzright
operator|>
name|Maxint
operator|-
name|syzleft
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1612
argument_list|,
literal|"in t^u, the result is too long"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
return|return
name|iconcat
argument_list|(
name|tleft
argument_list|,
name|tright
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Visible
name|value
name|repeat
parameter_list|(
name|t
parameter_list|,
name|n
parameter_list|)
name|value
name|t
decl_stmt|,
name|n
decl_stmt|;
block|{
name|int
name|tsize
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1613
argument_list|,
literal|"in t^^n, t is not a text"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1614
argument_list|,
literal|"in t^^n, n is not a number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
if|if
condition|(
name|numcomp
argument_list|(
name|n
argument_list|,
name|zero
argument_list|)
operator|<
literal|0
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1615
argument_list|,
literal|"in t^^n, n is negative"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|tsize
operator|=
name|Tltsize
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|==
literal|0
condition|)
return|return
name|copy
argument_list|(
name|t
argument_list|)
return|;
if|if
condition|(
name|large
argument_list|(
name|n
argument_list|)
operator|||
name|Maxint
operator|/
name|tsize
operator|<
operator|(
name|k
operator|=
name|intval
argument_list|(
name|n
argument_list|)
operator|)
condition|)
block|{
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1616
argument_list|,
literal|"in t^^n, the result is too long"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
return|return
name|irepeat
argument_list|(
name|t
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_decl_stmt
name|Visible
name|Procedure
name|wrtext
argument_list|(
name|putch
argument_list|,
name|v
argument_list|,
name|quote
argument_list|)
name|int
argument_list|(
operator|*
name|putch
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value
name|v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|quote
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|v
operator|==
name|Vnil
operator|||
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
block|{
call|(
modifier|*
name|putch
call|)
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|quote
condition|)
call|(
modifier|*
name|putch
call|)
argument_list|(
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
name|Root
argument_list|(
name|v
argument_list|)
operator|!=
name|Bnil
condition|)
name|wrbtext
argument_list|(
name|putch
argument_list|,
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
call|(
modifier|*
name|putch
call|)
argument_list|(
name|quote
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|Hidden
name|Procedure
name|wrbtext
argument_list|(
name|putch
argument_list|,
name|p
argument_list|,
name|quote
argument_list|)
name|int
argument_list|(
operator|*
name|putch
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|btreeptr
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|quote
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|Lim
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|IsInner
argument_list|(
name|p
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|still_ok
operator|&&
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|wrbtext
argument_list|(
name|putch
argument_list|,
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|quote
argument_list|)
expr_stmt|;
name|c
operator|=
name|Ichar
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
call|(
modifier|*
name|putch
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
operator|&&
operator|(
name|c
operator|==
name|quote
operator|||
name|c
operator|==
literal|'`'
operator|)
condition|)
call|(
modifier|*
name|putch
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|wrbtext
argument_list|(
name|putch
argument_list|,
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|quote
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quote
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|Bchar
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
call|(
modifier|*
name|putch
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
operator|||
name|c
operator|==
literal|'`'
condition|)
call|(
modifier|*
name|putch
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
call|(
modifier|*
name|putch
call|)
argument_list|(
name|Bchar
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_else
else|#
directive|else
else|INTEGRATION
end_else

begin_function
name|Visible
name|value
name|mk_text
parameter_list|(
name|m
parameter_list|)
name|string
name|m
decl_stmt|;
block|{
name|value
name|v
decl_stmt|;
name|intlet
name|len
init|=
name|strlen
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|v
operator|=
name|grab_tex
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Str
argument_list|(
name|v
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|character
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
name|Is_text
argument_list|(
name|v
argument_list|)
operator|&&
name|Length
argument_list|(
name|v
argument_list|)
operator|==
literal|1
condition|)
return|return
name|Yes
return|;
else|else
return|return
name|No
return|;
block|}
end_function

begin_function
name|Visible
name|char
name|charval
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
operator|||
name|Length
argument_list|(
name|v
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1617
argument_list|,
literal|"value not a character"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|Str
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|string
name|strval
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|Str
argument_list|(
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|concat
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|value
name|s
decl_stmt|,
name|t
decl_stmt|;
block|{
if|if
condition|(
name|Type
argument_list|(
name|s
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1618
argument_list|,
literal|"in t^u, t is not a text"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Type
argument_list|(
name|t
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1619
argument_list|,
literal|"in t^u, t is a text, but u is not"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|value
name|c
init|=
name|grab_tex
argument_list|(
name|Length
argument_list|(
name|s
argument_list|)
operator|+
name|Length
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|Str
argument_list|(
name|c
argument_list|)
argument_list|,
name|Str
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Str
argument_list|(
name|c
argument_list|)
operator|+
name|Length
argument_list|(
name|s
argument_list|)
argument_list|,
name|Str
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
return|return
name|grab_tex
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|VERSION2
end_define

begin_function
name|Visible
name|Procedure
name|concato
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|value
modifier|*
name|s
decl_stmt|;
name|string
name|t
decl_stmt|;
block|{
if|if
condition|(
name|Type
argument_list|(
operator|*
name|s
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1620
argument_list|,
literal|"attempt to join text with non-text"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|VERSION1
name|xtndtex
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Str
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VERSION2
name|value
name|v
init|=
name|mk_text
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|value
name|w
init|=
name|concat
argument_list|(
operator|*
name|s
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|w
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|trim
parameter_list|(
name|v
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|)
name|value
name|v
decl_stmt|;
name|intlet
name|B
decl_stmt|,
name|C
decl_stmt|;
block|{
name|intlet
name|len
init|=
name|Length
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|v
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1621
argument_list|,
literal|"trim (@ or |) applied to non-text"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|B
operator|<
literal|0
operator|||
name|C
operator|<
literal|0
operator|||
name|B
operator|+
name|C
operator|>
name|len
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1622
argument_list|,
literal|"trim (@ or |) out of bounds"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|value
name|w
init|=
name|grab_tex
argument_list|(
name|len
operator|-=
operator|(
name|B
operator|+
name|C
operator|)
argument_list|)
decl_stmt|;
name|string
name|vp
init|=
name|Str
argument_list|(
name|v
argument_list|)
operator|+
name|B
decl_stmt|,
name|wp
init|=
name|Str
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|Overall
operator|*
name|wp
operator|++
operator|=
operator|*
name|vp
operator|++
expr_stmt|;
operator|*
name|wp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|w
return|;
block|}
return|return
name|grab_tex
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|putintrim
parameter_list|(
name|pn
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|,
name|str
parameter_list|)
name|value
modifier|*
name|pn
decl_stmt|;
name|intlet
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|string
name|str
decl_stmt|;
block|{
name|value
name|v
init|=
operator|*
name|pn
decl_stmt|;
name|intlet
name|len
init|=
name|Length
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|v
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1623
argument_list|,
literal|"putintrim (@ or |) applied to non-text"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|head
operator|<
literal|0
operator|||
name|tail
operator|<
literal|0
operator|||
name|head
operator|+
name|tail
operator|>
name|len
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1624
argument_list|,
literal|"putintrim (@ or |) out of bounds"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|value
name|w
init|=
name|head
operator|==
literal|0
condition|?
name|mk_text
argument_list|(
literal|""
argument_list|)
else|:
name|head
operator|==
name|len
condition|?
name|copy
argument_list|(
name|v
argument_list|)
else|:
name|trim
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|len
operator|-
name|head
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|str
condition|)
name|concato
argument_list|(
operator|&
name|w
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|>
literal|0
condition|)
name|concato
argument_list|(
operator|&
name|w
argument_list|,
name|Str
argument_list|(
name|v
argument_list|)
operator|+
operator|(
name|len
operator|-
name|tail
operator|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
operator|*
name|pn
operator|=
name|w
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|curtail
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
name|value
name|v
decl_stmt|,
name|n
decl_stmt|;
block|{
name|intlet
name|c
init|=
name|intval
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|v
operator|=
name|trim
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|Length
argument_list|(
name|v
argument_list|)
operator|-
name|c
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|behead
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
name|value
name|v
decl_stmt|,
name|n
decl_stmt|;
block|{
name|intlet
name|b
init|=
name|intval
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|v
operator|=
name|trim
argument_list|(
name|v
argument_list|,
name|b
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|repeat
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|intlet
name|i
init|=
name|propintlet
argument_list|(
name|intval
argument_list|(
name|y
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|x
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1625
argument_list|,
literal|"in t^^n, t is not a text"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1626
argument_list|,
literal|"in t^^n, n is negative"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|value
name|r
decl_stmt|;
name|string
name|xp
decl_stmt|,
name|rp
decl_stmt|;
name|intlet
name|p
decl_stmt|,
name|q
decl_stmt|,
name|xl
init|=
name|Length
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|r
operator|=
name|grab_tex
argument_list|(
name|propintlet
argument_list|(
name|i
operator|*
name|xl
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|=
name|Str
argument_list|(
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|i
condition|;
name|p
operator|++
control|)
block|{
name|xp
operator|=
name|Str
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|xl
condition|;
name|q
operator|++
control|)
operator|*
name|rp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|r
return|;
block|}
return|return
name|grab_tex
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Left
value|'L'
end_define

begin_define
define|#
directive|define
name|Right
value|'R'
end_define

begin_define
define|#
directive|define
name|Centre
value|'C'
end_define

begin_function
name|Hidden
name|value
name|adj
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|side
parameter_list|)
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
name|literal
name|side
decl_stmt|;
block|{
name|value
name|r
decl_stmt|,
name|v
init|=
name|convert
argument_list|(
name|x
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|intval
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|intlet
name|lv
init|=
name|Length
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|la
decl_stmt|,
name|k
decl_stmt|,
name|ls
decl_stmt|,
name|rs
decl_stmt|;
name|string
name|rp
decl_stmt|,
name|vp
decl_stmt|;
name|la
operator|=
name|propintlet
argument_list|(
name|i
argument_list|)
operator|-
name|lv
expr_stmt|;
if|if
condition|(
name|la
operator|<=
literal|0
condition|)
return|return
name|v
return|;
name|r
operator|=
name|grab_tex
argument_list|(
name|lv
operator|+
name|la
argument_list|)
expr_stmt|;
name|rp
operator|=
name|Str
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|vp
operator|=
name|Str
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|side
operator|==
name|Left
condition|)
block|{
name|ls
operator|=
literal|0
expr_stmt|;
name|rs
operator|=
name|la
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|side
operator|==
name|Centre
condition|)
block|{
name|ls
operator|=
name|la
operator|/
literal|2
expr_stmt|;
name|rs
operator|=
operator|(
name|la
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ls
operator|=
name|la
expr_stmt|;
name|rs
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ls
condition|;
name|k
operator|++
control|)
operator|*
name|rp
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|lv
condition|;
name|k
operator|++
control|)
operator|*
name|rp
operator|++
operator|=
operator|*
name|vp
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|rs
condition|;
name|k
operator|++
control|)
operator|*
name|rp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|adjleft
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
name|adj
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|Left
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|centre
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
name|adj
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|Centre
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|adjright
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
name|adj
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|Right
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For reasons of efficiency, wri does not always call convert but writes    directly on the standard output. Modifications in convert should    be mirrored by changes in wri and vice versa. */
end_comment

begin_function
name|Visible
name|value
name|convert
parameter_list|(
name|v
parameter_list|,
name|coll
parameter_list|,
name|outer
parameter_list|)
name|value
name|v
decl_stmt|;
name|bool
name|coll
decl_stmt|,
name|outer
decl_stmt|;
block|{
name|literal
name|type
init|=
name|Type
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|intlet
name|len
init|=
name|Length
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|value
modifier|*
name|vp
init|=
name|Ats
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|value
name|t
decl_stmt|,
name|cv
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Num
case|:
return|return
name|mk_text
argument_list|(
name|convnum
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
case|case
name|Tex
case|:
if|if
condition|(
name|outer
condition|)
return|return
name|copy
argument_list|(
name|v
argument_list|)
return|;
else|else
block|{
name|string
name|tp
init|=
operator|(
name|string
operator|)
name|vp
decl_stmt|;
name|char
name|cs
index|[
literal|2
index|]
decl_stmt|;
name|cs
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|=
name|mk_text
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|Overall
block|{
name|cs
index|[
literal|0
index|]
operator|=
operator|*
name|tp
operator|++
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
index|[
literal|0
index|]
operator|==
literal|'\''
operator|||
name|cs
index|[
literal|0
index|]
operator|==
literal|'`'
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
case|case
name|Com
case|:
name|outer
operator|&=
name|coll
expr_stmt|;
name|t
operator|=
name|mk_text
argument_list|(
name|coll
condition|?
literal|""
else|:
literal|"("
argument_list|)
expr_stmt|;
name|Overall
block|{
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|Str
argument_list|(
name|cv
operator|=
name|convert
argument_list|(
operator|*
name|vp
operator|++
argument_list|,
name|No
argument_list|,
name|outer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|len
operator|-
literal|1
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|outer
condition|?
literal|" "
else|:
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coll
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|Lis
case|:
case|case
name|ELT
case|:
name|t
operator|=
name|mk_text
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|Overall
block|{
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|Str
argument_list|(
name|cv
operator|=
name|convert
argument_list|(
operator|*
name|vp
operator|++
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|len
operator|-
literal|1
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|Tab
case|:
name|t
operator|=
name|mk_text
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|Overall
block|{
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|Str
argument_list|(
name|cv
operator|=
name|convert
argument_list|(
name|Cts
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|"]: "
argument_list|)
expr_stmt|;
name|concato
argument_list|(
operator|&
name|t
argument_list|,
name|Str
argument_list|(
name|cv
operator|=
name|convert
argument_list|(
name|Dts
argument_list|(
operator|*
name|vp
operator|++
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|len
operator|-
literal|1
condition|)
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
block|}
name|concato
argument_list|(
operator|&
name|t
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1627
argument_list|,
literal|"converting value of unknown type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|Dummy
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|INTEGRATION
end_endif

end_unit

