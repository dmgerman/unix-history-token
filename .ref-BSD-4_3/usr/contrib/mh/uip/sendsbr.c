begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sendsbr.c - routines to help WhatNow/Send along */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
name|int
name|debugsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global */
end_comment

begin_decl_stmt
name|int
name|forwsw
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inplace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pushsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unique
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|altmsg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  .. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|annotext
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|distfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|armed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getusr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|sendsbr
parameter_list|(
name|vec
parameter_list|,
name|vecp
parameter_list|,
name|drft
parameter_list|,
name|st
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|,
decl|*
name|drft
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|vecp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
name|armed
operator|++
expr_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
name|status
operator|=
name|sendaux
argument_list|(
name|vec
argument_list|,
name|vecp
argument_list|,
name|drft
argument_list|,
name|st
argument_list|)
condition|?
name|NOTOK
else|:
name|OK
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|DONE
expr_stmt|;
break|break;
block|}
name|armed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|distfile
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|distfile
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|sendaux
parameter_list|(
name|vec
parameter_list|,
name|vecp
parameter_list|,
name|drft
parameter_list|,
name|st
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|,
decl|*
name|drft
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|vecp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|child_id
decl_stmt|,
name|i
decl_stmt|,
name|status
decl_stmt|,
name|fd
decl_stmt|,
name|fd2
decl_stmt|;
name|char
name|backup
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|file
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|pushsw
condition|?
name|tmp_fd
argument_list|()
else|:
name|NOTOK
expr_stmt|;
name|fd2
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|pushsw
operator|&&
name|unique
condition|)
block|{
if|if
condition|(
name|rename
argument_list|(
name|drft
argument_list|,
name|strcpy
argument_list|(
name|file
argument_list|,
name|m_scratch
argument_list|(
name|drft
argument_list|,
name|invo_name
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|drft
argument_list|)
expr_stmt|;
name|drft
operator|=
name|file
expr_stmt|;
block|}
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|drft
expr_stmt|;
if|if
condition|(
name|annotext
condition|)
if|if
condition|(
operator|(
name|fd2
operator|=
name|tmp_fd
argument_list|()
operator|)
operator|!=
name|NOTOK
condition|)
block|{
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-idanno"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|fd2
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|buf
expr_stmt|;
block|}
else|else
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to create file for annotation list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|distfile
operator|&&
name|distout
argument_list|(
name|drft
argument_list|,
name|distfile
argument_list|,
name|backup
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
comment|/* oops */
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
comment|/* send it */
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|execvp
argument_list|(
name|postproc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|postproc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
comment|/* wait for it */
if|if
condition|(
operator|(
name|status
operator|=
name|pidwait
argument_list|(
name|child_id
argument_list|,
name|NOTOK
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|annotext
operator|&&
name|fd2
operator|!=
name|NOTOK
condition|)
name|anno
argument_list|(
name|fd2
argument_list|,
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|drft
argument_list|,
name|strcpy
argument_list|(
name|buf
argument_list|,
name|m_backup
argument_list|(
name|drft
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|buf
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|drft
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
block|{
name|alert
argument_list|(
name|drft
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"message not delivered to anyone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd2
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|distfile
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|drft
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|backup
argument_list|,
name|drft
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|drft
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|alert
argument_list|(
name|file
argument_list|,
name|out
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|child_id
decl_stmt|,
name|i
decl_stmt|,
name|in
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|fork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
comment|/* oops */
name|advise
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
comment|/* send it */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwsw
condition|)
if|if
condition|(
operator|(
name|in
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|admonish
argument_list|(
name|file
argument_list|,
literal|"unable to re-open"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|out
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\nMessage not delivered to anyone.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|out
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\n------- Unsent Draft\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|out
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cpydgst
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|file
argument_list|,
literal|"temporary file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\n------- End of Unsent Draft\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|out
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|file
argument_list|,
name|strcpy
argument_list|(
name|buf
argument_list|,
name|m_backup
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NOTOK
condition|)
name|admonish
argument_list|(
name|buf
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|out
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|out
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"send failed on %s"
argument_list|,
name|forwsw
condition|?
literal|"enclosed draft"
else|:
name|file
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|mailproc
argument_list|,
name|r1bindex
argument_list|(
name|mailproc
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|getusr
argument_list|()
argument_list|,
literal|"-subject"
argument_list|,
name|buf
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|mailproc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
comment|/* no waiting... */
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tmp_fd
parameter_list|()
block|{
name|int
name|fd
decl_stmt|;
name|char
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|tmpfil
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmpfil
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|debugsw
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"temporary file %s selected"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|tmpfil
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to remove"
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|anno
argument_list|(
argument|fd
argument_list|,
argument|st
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|child_id
decl_stmt|;
name|int
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|tstat
argument_list|)
argument_list|()
decl_stmt|;
specifier|static
name|char
modifier|*
name|cwd
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|st2
decl_stmt|;
if|if
condition|(
name|altmsg
operator|&&
operator|(
name|stat
argument_list|(
name|altmsg
argument_list|,
operator|&
name|st2
argument_list|)
operator|==
name|NOTOK
operator|||
name|st
operator|->
name|st_mtime
operator|!=
name|st2
operator|.
name|st_mtime
operator|||
name|st
operator|->
name|st_dev
operator|!=
name|st2
operator|.
name|st_dev
operator|||
name|st
operator|->
name|st_ino
operator|!=
name|st2
operator|.
name|st_ino
operator|)
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"$mhaltmsg mismatch"
argument_list|)
expr_stmt|;
return|return;
block|}
name|child_id
operator|=
name|debugsw
condition|?
name|NOTOK
else|:
name|fork
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
comment|/* oops */
if|if
condition|(
operator|!
name|debugsw
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to fork, so doing annotations by hand..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwd
operator|==
name|NULL
condition|)
name|cwd
operator|=
name|getcpy
argument_list|(
name|pwd
argument_list|()
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|tstat
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|annoaux
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_id
operator|==
name|OK
condition|)
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* no waiting... */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|annoaux
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|fd2
decl_stmt|,
name|fd3
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|folder
decl_stmt|,
modifier|*
name|maildir
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|msgs
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|(
name|folder
operator|=
name|getenv
argument_list|(
literal|"mhfolder"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|folder
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"$mhfolder not set"
argument_list|)
expr_stmt|;
return|return;
block|}
name|maildir
operator|=
name|m_maildir
argument_list|(
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|maildir
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|maildir
argument_list|,
literal|"unable to change directory to"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|mp
operator|=
name|m_gmsg
argument_list|(
name|folder
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to read folder %s"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mp
operator|->
name|hghmsg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"no messages in %s"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"mhmessages"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"$mhmessages not set"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
if|if
condition|(
operator|!
name|debugsw
comment|/* MOBY HACK... */
operator|&&
name|pushsw
operator|&&
operator|(
name|fd3
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
name|NOTOK
operator|&&
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd3
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd3
argument_list|)
expr_stmt|;
block|}
else|else
name|fd2
operator|=
name|NOTOK
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|brkstring
argument_list|(
name|cp
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|" "
argument_list|,
name|NULLCP
argument_list|)
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
operator|(
name|void
operator|)
name|m_convert
argument_list|(
name|mp
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd2
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd2
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"no messages to annotate"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to fdopen annotation list"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
name|cp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"annotate%s with %s: \"%s\""
argument_list|,
name|inplace
condition|?
literal|" inplace"
else|:
literal|""
argument_list|,
name|annotext
argument_list|,
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"annotate message %d"
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|annotate
argument_list|(
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|,
name|annotext
argument_list|,
name|cp
argument_list|,
name|inplace
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|oops
label|:
empty_stmt|;
name|m_fmsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|void
name|done
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|armed
condition|)
name|longjmp
argument_list|(
name|env
argument_list|,
name|status
condition|?
name|status
else|:
name|NOTOK
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

