begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mhlsbr.c - implement the "nifty" message lister */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* MAJOR BUG:    for a component containing addresses, ADDRFMT, if COMPRESS is also    set, then addresses get split wrong (not at the spaces between commas).    To fix this correctly, putstr() should know about "atomic" strings that    must NOT be broken across lines.  That's too difficult for right now    (it turns out that there are a number of degernate cases), so in    oneline(), instead of  		     (*onelp == '\n'&& !onelp[1])     being a terminating condition,  	 (*onelp == '\n'&& (!onelp[1] || (flags& ADDRFMT)))     is used instead.  This cuts the line prematurely, and gives us a much    better chance of getting things right.  */
end_comment

begin_define
define|#
directive|define
name|ONECOMP
value|0
end_define

begin_define
define|#
directive|define
name|TWOCOMP
value|1
end_define

begin_define
define|#
directive|define
name|adios
value|mhladios
end_define

begin_define
define|#
directive|define
name|done
value|mhldone
end_define

begin_define
define|#
directive|define
name|QUOTE
value|'\\'
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|mhlswitches
index|[]
init|=
block|{
define|#
directive|define
name|BELLSW
value|0
literal|"bell"
block|,
literal|0
block|,
define|#
directive|define
name|NBELLSW
value|1
literal|"nobell"
block|,
literal|0
block|,
define|#
directive|define
name|CLRSW
value|2
literal|"clear"
block|,
literal|0
block|,
define|#
directive|define
name|NCLRSW
value|3
literal|"noclear"
block|,
literal|0
block|,
define|#
directive|define
name|FOLDSW
value|4
literal|"folder +folder"
block|,
literal|0
block|,
define|#
directive|define
name|FORMSW
value|5
literal|"form formfile"
block|,
literal|0
block|,
define|#
directive|define
name|PROGSW
value|6
literal|"moreproc program"
block|,
literal|0
block|,
define|#
directive|define
name|NPROGSW
value|7
literal|"nomoreproc"
block|,
literal|0
block|,
define|#
directive|define
name|LENSW
value|8
literal|"length lines"
block|,
literal|0
block|,
define|#
directive|define
name|WIDSW
value|9
literal|"width columns"
block|,
literal|0
block|,
define|#
directive|define
name|HELPSW
value|10
literal|"help"
block|,
literal|4
block|,
define|#
directive|define
name|FORW1SW
value|11
literal|"forward"
block|,
operator|-
literal|7
block|,
comment|/* interface from forw */
define|#
directive|define
name|FORW2SW
value|12
literal|"forwall"
block|,
operator|-
literal|7
block|,
comment|/*   .. */
define|#
directive|define
name|DGSTSW
value|13
literal|"digest list"
block|,
operator|-
literal|6
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|mcomp
block|{
name|char
modifier|*
name|c_name
decl_stmt|;
comment|/* component name			*/
name|char
modifier|*
name|c_text
decl_stmt|;
comment|/* component text			*/
name|char
modifier|*
name|c_ovtxt
decl_stmt|;
comment|/* text overflow indicator		*/
name|char
modifier|*
name|c_nfs
decl_stmt|;
comment|/* iff FORMAT				*/
name|struct
name|format
modifier|*
name|c_fmt
decl_stmt|;
comment|/*   ..					*/
name|int
name|c_offset
decl_stmt|;
comment|/* left margin indentation		*/
name|int
name|c_ovoff
decl_stmt|;
comment|/* overflow indentation			*/
name|int
name|c_width
decl_stmt|;
comment|/* width of field			*/
name|int
name|c_cwidth
decl_stmt|;
comment|/* width of component			*/
name|int
name|c_length
decl_stmt|;
comment|/* length in lines			*/
name|short
name|c_flags
decl_stmt|;
define|#
directive|define
name|NOCOMPONENT
value|0x0001
comment|/* don't show component name            */
define|#
directive|define
name|UPPERCASE
value|0x0002
comment|/* display in all upper case            */
define|#
directive|define
name|CENTER
value|0x0004
comment|/* center line				*/
define|#
directive|define
name|CLEARTEXT
value|0x0008
comment|/* cleartext				*/
define|#
directive|define
name|EXTRA
value|0x0010
comment|/* an "extra" component			*/
define|#
directive|define
name|HDROUTPUT
value|0x0020
comment|/* already output			*/
define|#
directive|define
name|CLEARSCR
value|0x0040
comment|/* clear screen				*/
define|#
directive|define
name|LEFTADJUST
value|0x0080
comment|/* left justify multiple lines		*/
define|#
directive|define
name|COMPRESS
value|0x0100
comment|/* compress text			*/
define|#
directive|define
name|ADDRFMT
value|0x0200
comment|/* contains addresses			*/
define|#
directive|define
name|BELL
value|0x0400
comment|/* sound bell at EOP			*/
define|#
directive|define
name|DATEFMT
value|0x0800
comment|/* contains dates			*/
define|#
directive|define
name|FORMAT
value|0x1000
comment|/* parse address/date			*/
define|#
directive|define
name|INIT
value|0x2000
define|#
directive|define
name|LBITS
value|"\020\01NOCOMPONENT\02UPPERCASE\03CENTER\04CLEARTEXT\05EXTRA\06HDROUTPUT\07CLEARSCR\010LEFTADJUST\011COMPRESS\012ADDRFMT\013BELL\014DATEFMT\015FORMAT\016INIT"
define|#
directive|define
name|GFLAGS
value|(NOCOMPONENT | UPPERCASE | CENTER | LEFTADJUST | COMPRESS)
name|struct
name|mcomp
modifier|*
name|c_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|msghd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|msgtl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|fmthd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
modifier|*
name|fmttl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
name|global
init|=
block|{
name|NULL
block|,
name|NULL
block|,
literal|""
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|80
block|,
operator|-
literal|1
block|,
literal|40
block|,
name|BELL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mcomp
name|holder
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NOCOMPONENT
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|pair
block|{
name|char
modifier|*
name|p_name
decl_stmt|;
name|short
name|p_flags
decl_stmt|;
block|}
name|pairs
index|[]
init|=
block|{
literal|"Date"
block|,
name|DATEFMT
block|,
literal|"From"
block|,
name|ADDRFMT
block|,
literal|"Sender"
block|,
name|ADDRFMT
block|,
literal|"Reply-To"
block|,
name|ADDRFMT
block|,
literal|"To"
block|,
name|ADDRFMT
block|,
literal|"cc"
block|,
name|ADDRFMT
block|,
literal|"Bcc"
block|,
name|ADDRFMT
block|,
literal|"Resent-Date"
block|,
name|DATEFMT
block|,
literal|"Resent-From"
block|,
name|ADDRFMT
block|,
literal|"Resent-Sender"
block|,
name|ADDRFMT
block|,
literal|"Resent-Reply-To"
block|,
name|ADDRFMT
block|,
literal|"Resent-To"
block|,
name|ADDRFMT
block|,
literal|"Resent-cc"
block|,
name|ADDRFMT
block|,
literal|"Resent-Bcc"
block|,
name|ADDRFMT
block|,
name|NULL
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|triple
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|short
name|t_on
decl_stmt|;
name|short
name|t_off
decl_stmt|;
block|}
name|triples
index|[]
init|=
block|{
literal|"nocomponent"
block|,
name|NOCOMPONENT
block|,
literal|0
block|,
literal|"uppercase"
block|,
name|UPPERCASE
block|,
literal|0
block|,
literal|"nouppercase"
block|,
literal|0
block|,
name|UPPERCASE
block|,
literal|"center"
block|,
name|CENTER
block|,
literal|0
block|,
literal|"nocenter"
block|,
literal|0
block|,
name|CENTER
block|,
literal|"clearscreen"
block|,
name|CLEARSCR
block|,
literal|0
block|,
literal|"noclearscreen"
block|,
literal|0
block|,
name|CLEARSCR
block|,
literal|"noclear"
block|,
literal|0
block|,
name|CLEARSCR
block|,
literal|"leftadjust"
block|,
name|LEFTADJUST
block|,
literal|0
block|,
literal|"noleftadjust"
block|,
literal|0
block|,
name|LEFTADJUST
block|,
literal|"compress"
block|,
name|COMPRESS
block|,
literal|0
block|,
literal|"nocompress"
block|,
literal|0
block|,
name|COMPRESS
block|,
literal|"addrfield"
block|,
name|ADDRFMT
block|,
name|DATEFMT
block|,
literal|"bell"
block|,
name|BELL
block|,
literal|0
block|,
literal|"nobell"
block|,
literal|0
block|,
name|BELL
block|,
literal|"datefield"
block|,
name|DATEFMT
block|,
name|ADDRFMT
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|bellflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clearflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forwflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forwall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|digest
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mhldebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PITTY
value|(-1)
end_define

begin_define
define|#
directive|define
name|NOTTY
value|0
end_define

begin_define
define|#
directive|define
name|ISTTY
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|ontty
init|=
name|NOTTY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|row
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|llim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ovoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ovtxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|onelp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ignores
index|[
name|MAXARGS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|mhlenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|delim3
index|[]
init|=
comment|/* from forw.c */
literal|"\n------------------------------------------------------------\n\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|delim4
index|[]
init|=
literal|"\n------------------------------\n\n"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|FP
function_decl|(
modifier|*
name|mhl_action
function_decl|)
parameter_list|()
init|=
operator|(
name|FP
argument_list|(
operator|*
argument_list|)
operator|(
operator|)
operator|)
literal|0
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|mhladios
argument_list|()
decl_stmt|,
name|mhldone
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|intrser
argument_list|()
decl_stmt|,
name|pipeser
argument_list|()
decl_stmt|,
name|quitser
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mcomp_add
argument_list|()
decl_stmt|,
modifier|*
name|oneline
argument_list|()
decl_stmt|,
modifier|*
name|parse
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|mcomp
modifier|*
name|add_queue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clear_screen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|mhl
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|length
init|=
literal|0
decl_stmt|,
name|nomore
init|=
literal|0
decl_stmt|,
name|width
init|=
literal|0
decl_stmt|,
name|vecp
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|folder
init|=
name|NULL
decl_stmt|,
modifier|*
name|form
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|argp
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|arguments
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|files
index|[
name|MAXARGS
index|]
decl_stmt|;
name|invo_name
operator|=
name|r1bindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MHLDEBUG"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|)
name|mhldebug
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|invo_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ap
operator|=
name|brkstring
argument_list|(
name|getcpy
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|copyip
argument_list|(
name|ap
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|=
name|arguments
expr_stmt|;
operator|(
name|void
operator|)
name|copyip
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|argp
operator|=
name|arguments
expr_stmt|;
comment|/*
comment|*/
name|vecp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|argp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|mhlswitches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|mhlswitches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
case|case
name|HELPSW
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [switches] [files ...]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|mhlswitches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|BELLSW
case|:
name|bellflg
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|NBELLSW
case|:
name|bellflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
name|CLRSW
case|:
name|clearflg
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|NCLRSW
case|:
name|clearflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
name|FOLDSW
case|:
if|if
condition|(
operator|!
operator|(
name|folder
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|folder
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FORMSW
case|:
if|if
condition|(
operator|!
operator|(
name|form
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|form
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PROGSW
case|:
if|if
condition|(
operator|!
operator|(
name|moreproc
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|moreproc
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NPROGSW
case|:
name|nomore
operator|++
expr_stmt|;
continue|continue;
case|case
name|LENSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad argument %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|WIDSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|width
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad argument %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DGSTSW
case|:
if|if
condition|(
operator|!
operator|(
name|digest
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|digest
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
case|case
name|FORW2SW
case|:
name|forwall
operator|++
expr_stmt|;
comment|/* fall */
case|case
name|FORW1SW
case|:
name|forwflg
operator|++
expr_stmt|;
name|clearflg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
continue|continue;
block|}
name|files
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
comment|/*
comment|*/
if|if
condition|(
operator|!
name|folder
condition|)
name|folder
operator|=
name|getenv
argument_list|(
literal|"mhfolder"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
name|nomore
operator|&&
name|moreproc
operator|&&
operator|*
name|moreproc
condition|)
block|{
if|if
condition|(
name|mhl_action
condition|)
block|{
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setsig
argument_list|(
name|SIGQUIT
argument_list|,
name|quitser
argument_list|)
expr_stmt|;
block|}
name|m_popen
argument_list|(
name|moreproc
argument_list|)
expr_stmt|;
name|ontty
operator|=
name|PITTY
expr_stmt|;
block|}
else|else
block|{
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setsig
argument_list|(
name|SIGQUIT
argument_list|,
name|quitser
argument_list|)
expr_stmt|;
name|ontty
operator|=
name|ISTTY
expr_stmt|;
block|}
else|else
name|ontty
operator|=
name|NOTTY
expr_stmt|;
name|mhl_format
argument_list|(
name|form
condition|?
name|form
else|:
name|mhlformat
argument_list|,
name|length
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|vecp
operator|==
literal|0
condition|)
name|process
argument_list|(
name|folder
argument_list|,
name|NULLCP
argument_list|,
literal|1
argument_list|,
name|vecp
operator|=
literal|1
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vecp
condition|;
name|i
operator|++
control|)
name|process
argument_list|(
name|folder
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|vecp
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwall
condition|)
block|{
if|if
condition|(
name|digest
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|delim4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"End of %s Digest\n"
argument_list|,
name|digest
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
operator|+
name|i
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n------- End of Forwarded Message%s\n\n"
argument_list|,
name|vecp
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clearflg
operator|>
literal|0
operator|&&
name|ontty
operator|==
name|NOTTY
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
if|if
condition|(
name|ontty
operator|==
name|PITTY
condition|)
name|m_pclose
argument_list|()
expr_stmt|;
return|return
name|exitstat
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|mhl_format
argument_list|(
name|file
argument_list|,
name|length
argument_list|,
name|width
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|,
name|width
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|dev_t
name|dev
init|=
literal|0
decl_stmt|;
specifier|static
name|ino_t
name|ino
init|=
literal|0
decl_stmt|;
specifier|static
name|time_t
name|mtime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fmthd
operator|!=
name|NULL
condition|)
if|if
condition|(
name|stat
argument_list|(
name|libpath
argument_list|(
name|file
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|mtime
operator|==
name|st
operator|.
name|st_mtime
operator|&&
name|dev
operator|==
name|st
operator|.
name|st_dev
operator|&&
name|ino
operator|==
name|st
operator|.
name|st_ino
condition|)
goto|goto
name|out
goto|;
else|else
name|free_queue
argument_list|(
operator|&
name|fmthd
argument_list|,
operator|&
name|fmttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|libpath
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to open format file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
name|mtime
operator|=
name|st
operator|.
name|st_mtime
operator|,
name|dev
operator|=
name|st
operator|.
name|st_dev
operator|,
name|ino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
name|global
operator|.
name|c_ovtxt
operator|=
name|global
operator|.
name|c_nfs
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|c_fmt
operator|=
name|NULL
expr_stmt|;
name|global
operator|.
name|c_offset
operator|=
literal|0
expr_stmt|;
name|global
operator|.
name|c_ovoff
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sc_width
argument_list|()
operator|)
operator|>
literal|5
condition|)
name|global
operator|.
name|c_width
operator|=
name|i
expr_stmt|;
name|global
operator|.
name|c_cwidth
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sc_length
argument_list|()
operator|)
operator|>
literal|5
condition|)
name|global
operator|.
name|c_length
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|global
operator|.
name|c_flags
operator|=
name|BELL
expr_stmt|;
comment|/* BELL is default */
operator|*
operator|(
name|ip
operator|=
name|ignores
operator|)
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|vfgets
argument_list|(
name|fp
argument_list|,
operator|&
name|ap
argument_list|)
operator|==
name|OK
condition|)
block|{
name|bp
operator|=
name|ap
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|bp
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|':'
condition|)
block|{
name|c1
operator|=
name|add_queue
argument_list|(
operator|&
name|fmthd
argument_list|,
operator|&
name|fmttl
argument_list|,
name|NULLCP
argument_list|,
name|bp
operator|+
literal|1
argument_list|,
name|CLEARTEXT
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|parptr
operator|=
name|bp
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|parse
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|parptr
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|','
case|:
case|case
literal|'='
case|:
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"ignores"
argument_list|)
condition|)
block|{
name|ip
operator|=
name|copyip
argument_list|(
name|brkstring
argument_list|(
name|getcpy
argument_list|(
operator|++
name|parptr
argument_list|)
argument_list|,
literal|","
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
name|ip
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|parptr
operator|=
name|bp
expr_stmt|;
while|while
condition|(
operator|*
name|parptr
condition|)
block|{
if|if
condition|(
name|evalvar
argument_list|(
operator|&
name|global
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"format file syntax error: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|parptr
condition|)
name|parptr
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
literal|':'
case|:
name|c1
operator|=
name|add_queue
argument_list|(
operator|&
name|fmthd
argument_list|,
operator|&
name|fmttl
argument_list|,
name|name
argument_list|,
name|NULLCP
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|parptr
operator|==
literal|':'
operator|||
operator|*
name|parptr
operator|==
literal|','
condition|)
block|{
name|parptr
operator|++
expr_stmt|;
if|if
condition|(
name|evalvar
argument_list|(
name|c1
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"format file syntax error: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c1
operator|->
name|c_nfs
operator|&&
name|global
operator|.
name|c_nfs
condition|)
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|DATEFMT
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|DATEFMT
condition|)
name|c1
operator|->
name|c_nfs
operator|=
name|getcpy
argument_list|(
name|global
operator|.
name|c_nfs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|ADDRFMT
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|ADDRFMT
condition|)
name|c1
operator|->
name|c_nfs
operator|=
name|getcpy
argument_list|(
name|global
operator|.
name|c_nfs
argument_list|)
expr_stmt|;
block|}
continue|continue;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"format file syntax error: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhldebug
condition|)
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c1: name=\"%s\" text=\"%s\" ovtxt=\"%s\"\n"
argument_list|,
name|c1
operator|->
name|c_name
argument_list|,
name|c1
operator|->
name|c_text
argument_list|,
name|c1
operator|->
name|c_ovtxt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnfs=0x%x fmt=0x%x\n"
argument_list|,
name|c1
operator|->
name|c_nfs
argument_list|,
name|c1
operator|->
name|c_fmt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\toffset=%d ovoff=%d width=%d cwidth=%d length=%d\n"
argument_list|,
name|c1
operator|->
name|c_offset
argument_list|,
name|c1
operator|->
name|c_ovoff
argument_list|,
name|c1
operator|->
name|c_width
argument_list|,
name|c1
operator|->
name|c_cwidth
argument_list|,
name|c1
operator|->
name|c_length
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tflags=%s\n"
argument_list|,
name|sprintb
argument_list|(
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|c1
operator|->
name|c_flags
argument_list|,
name|LBITS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
empty_stmt|;
if|if
condition|(
name|clearflg
operator|==
literal|1
condition|)
name|global
operator|.
name|c_flags
operator||=
name|CLEARSCR
expr_stmt|;
elseif|else
if|if
condition|(
name|clearflg
operator|==
operator|-
literal|1
condition|)
name|global
operator|.
name|c_flags
operator|&=
operator|~
name|CLEARSCR
expr_stmt|;
switch|switch
condition|(
name|bellflg
condition|)
block|{
comment|/* command line may override format file */
case|case
literal|1
case|:
name|global
operator|.
name|c_flags
operator||=
name|BELL
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|global
operator|.
name|c_flags
operator|&=
operator|~
name|BELL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|length
condition|)
name|global
operator|.
name|c_length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|width
condition|)
name|global
operator|.
name|c_width
operator|=
name|width
expr_stmt|;
if|if
condition|(
name|global
operator|.
name|c_length
operator|<
literal|5
condition|)
name|global
operator|.
name|c_length
operator|=
literal|10000
expr_stmt|;
if|if
condition|(
name|global
operator|.
name|c_width
operator|<
literal|5
condition|)
name|global
operator|.
name|c_width
operator|=
literal|10000
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|evalvar
argument_list|(
name|c1
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
name|c1
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|parptr
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|parse
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"component"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptos
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_text
argument_list|)
condition|)
return|return
literal|1
return|;
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|NOCOMPONENT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"overflowtext"
argument_list|)
condition|)
return|return
name|ptos
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_ovtxt
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"formatfield"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptos
argument_list|(
name|name
argument_list|,
operator|&
name|cp
argument_list|)
condition|)
return|return
literal|1
return|;
name|c1
operator|->
name|c_nfs
operator|=
name|getcpy
argument_list|(
name|new_fs
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_flags
operator||=
name|FORMAT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_offset
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"overflowoffset"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_ovoff
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"width"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_width
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"compwidth"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_cwidth
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
literal|"length"
argument_list|)
condition|)
return|return
name|ptoi
argument_list|(
name|name
argument_list|,
operator|&
name|c1
operator|->
name|c_length
argument_list|)
return|;
for|for
control|(
name|ap
operator|=
name|triples
init|;
name|ap
operator|->
name|t_name
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ap
operator|->
name|t_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|c1
operator|->
name|c_flags
operator||=
name|ap
operator|->
name|t_on
expr_stmt|;
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|ap
operator|->
name|t_off
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|ptoi
parameter_list|(
name|name
parameter_list|,
name|i
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
modifier|*
name|i
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
name|parptr
operator|++
operator|!=
literal|'='
operator|||
operator|!
operator|*
operator|(
name|cp
operator|=
name|parse
argument_list|()
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|i
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ptos
parameter_list|(
name|name
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
decl|*
modifier|*
name|s
decl_stmt|;
end_function

begin_block
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
name|parptr
operator|++
operator|!=
literal|'='
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|parptr
operator|!=
literal|'"'
condition|)
for|for
control|(
name|cp
operator|=
name|parptr
init|;
operator|*
name|parptr
operator|&&
operator|*
name|parptr
operator|!=
literal|':'
operator|&&
operator|*
name|parptr
operator|!=
literal|','
condition|;
name|parptr
operator|++
control|)
continue|continue;
else|else
for|for
control|(
name|cp
operator|=
operator|++
name|parptr
init|;
operator|*
name|parptr
operator|&&
operator|*
name|parptr
operator|!=
literal|'"'
condition|;
name|parptr
operator|++
control|)
if|if
condition|(
operator|*
name|parptr
operator|==
name|QUOTE
condition|)
if|if
condition|(
operator|!
operator|*
operator|++
name|parptr
condition|)
name|parptr
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|parptr
expr_stmt|;
operator|*
name|parptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|s
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|parptr
operator|=
name|c
operator|)
operator|==
literal|'"'
condition|)
name|parptr
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|result
index|[
name|NAMESZ
index|]
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|result
init|;
name|c
operator|=
operator|*
name|parptr
condition|;
name|parptr
operator|++
control|)
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|']'
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
else|else
break|break;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|process
argument_list|(
name|folder
argument_list|,
name|fname
argument_list|,
name|ofilen
argument_list|,
name|ofilec
argument_list|)
specifier|register
name|char
operator|*
name|folder
operator|,
operator|*
name|fname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ofilen
decl_stmt|,
name|ofilec
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
if|if
condition|(
name|fname
condition|)
block|{
name|fp
operator|=
name|mhl_action
condition|?
call|(
modifier|*
name|mhl_action
call|)
argument_list|(
name|fname
argument_list|)
else|:
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|fname
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
name|exitstat
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|fname
operator|=
literal|"(stdin)"
expr_stmt|;
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
name|cp
operator|=
name|folder
condition|?
name|concat
argument_list|(
name|folder
argument_list|,
literal|":"
argument_list|,
name|fname
argument_list|,
name|NULLCP
argument_list|)
else|:
name|getcpy
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ontty
operator|!=
name|PITTY
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
name|mhlfile
argument_list|(
name|fp
argument_list|,
name|cp
argument_list|,
name|ofilen
argument_list|,
name|ofilec
argument_list|)
expr_stmt|;
comment|/* fall */
default|default:
if|if
condition|(
name|ontty
operator|!=
name|PITTY
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhl_action
operator|==
name|NULL
operator|&&
name|fp
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|holder
operator|.
name|c_text
condition|)
block|{
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
block|}
name|free_queue
argument_list|(
operator|&
name|msghd
argument_list|,
operator|&
name|msgtl
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|HDROUTPUT
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|mhlfile
argument_list|(
name|fp
argument_list|,
name|mname
argument_list|,
name|ofilen
argument_list|,
name|ofilec
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|mname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ofilen
decl_stmt|,
name|ofilec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|state
decl_stmt|;
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ip
decl_stmt|;
name|char
name|name
index|[
name|NAMESZ
index|]
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|forwall
condition|)
block|{
if|if
condition|(
name|digest
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ofilen
operator|==
literal|1
condition|?
name|delim3
else|:
name|delim4
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n-------"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofilen
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|" Forwarded Message%s"
argument_list|,
name|ofilec
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" Message %d"
argument_list|,
name|ofilen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|ontty
condition|)
block|{
case|case
name|PITTY
case|:
if|if
condition|(
name|ofilec
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|ofilen
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|global
operator|.
name|c_flags
operator|&
name|CLEARSCR
operator|)
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">>> %s\n\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ISTTY
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofilec
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|SOprintf
argument_list|(
literal|"Press<return> to list \"%s\"..."
argument_list|,
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|ofilen
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Press<return> to list \"%s\"..."
argument_list|,
name|mname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|global
operator|.
name|c_flags
operator|&
name|CLEARSCR
operator|)
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ofilec
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|ofilen
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearflg
operator|>
literal|0
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">>> %s\n\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*
comment|*/
for|for
control|(
name|state
operator|=
name|FLD
init|;
condition|;
control|)
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDPLUS
case|:
for|for
control|(
name|ip
operator|=
name|ignores
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
operator|*
name|ip
argument_list|)
condition|)
block|{
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|ip
condition|)
continue|continue;
for|for
control|(
name|c1
operator|=
name|msghd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|c1
operator|->
name|c_name
argument_list|)
condition|)
block|{
name|c1
operator|->
name|c_text
operator|=
name|mcomp_add
argument_list|(
name|c1
operator|->
name|c_flags
argument_list|,
name|buf
argument_list|,
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c1
operator|==
name|NULL
condition|)
name|c1
operator|=
name|add_queue
argument_list|(
operator|&
name|msghd
argument_list|,
operator|&
name|msgtl
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_text
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c2
operator|=
name|fmthd
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|c_next
control|)
if|if
condition|(
name|uleq
argument_list|(
name|c2
operator|->
name|c_name
argument_list|,
name|c1
operator|->
name|c_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c2
operator|==
name|NULL
condition|)
name|c1
operator|->
name|c_flags
operator||=
name|EXTRA
expr_stmt|;
continue|continue;
case|case
name|BODY
case|:
case|case
name|FILEEOF
case|:
name|row
operator|=
name|column
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|CLEARTEXT
condition|)
block|{
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c1
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|c1
operator|->
name|c_name
argument_list|,
literal|"messagename"
argument_list|)
condition|)
block|{
name|holder
operator|.
name|c_text
operator|=
name|concat
argument_list|(
literal|"(Message "
argument_list|,
name|mname
argument_list|,
literal|")\n"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|putcomp
argument_list|(
name|c1
argument_list|,
operator|&
name|holder
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|c1
operator|->
name|c_name
argument_list|,
literal|"extras"
argument_list|)
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|msghd
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|c_next
control|)
if|if
condition|(
name|c2
operator|->
name|c_flags
operator|&
name|EXTRA
condition|)
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|TWOCOMP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|c1
operator|->
name|c_name
argument_list|,
literal|"body"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|holder
operator|.
name|c_text
operator|=
name|malloc
argument_list|(
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate buffer memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|holder
operator|.
name|c_text
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|BODY
condition|)
block|{
name|putcomp
argument_list|(
name|c1
argument_list|,
operator|&
name|holder
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|holder
operator|.
name|c_text
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|c2
operator|=
name|msghd
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|c_next
control|)
if|if
condition|(
name|uleq
argument_list|(
name|c2
operator|->
name|c_name
argument_list|,
name|c1
operator|->
name|c_name
argument_list|)
condition|)
block|{
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|ONECOMP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"format error in message %s"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|exitstat
operator|++
expr_stmt|;
return|return;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"getfld() returned %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|mcomp_flags
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|pair
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|pairs
init|;
name|ap
operator|->
name|p_name
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ap
operator|->
name|p_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|ap
operator|->
name|p_flags
operator|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mcomp_add
parameter_list|(
name|flags
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|short
name|flags
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ADDRFMT
operator|)
condition|)
return|return
name|add
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
if|if
condition|(
name|s2
operator|&&
operator|*
operator|(
name|dp
operator|=
name|s2
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|dp
operator|=
name|NULL
expr_stmt|;
return|return
name|add
argument_list|(
name|s1
argument_list|,
name|add
argument_list|(
literal|",\n"
argument_list|,
name|s2
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|pqpair
block|{
name|char
modifier|*
name|pq_text
decl_stmt|;
name|char
modifier|*
name|pq_error
decl_stmt|;
name|struct
name|pqpair
modifier|*
name|pq_next
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|mcomp_format
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
name|c1
operator|,
operator|*
name|c2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|dat
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|error
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|comp
modifier|*
name|cptr
decl_stmt|;
specifier|register
name|struct
name|pqpair
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|pqpair
name|pq
decl_stmt|;
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|;
name|ap
operator|=
name|c2
operator|->
name|c_text
expr_stmt|;
name|c2
operator|->
name|c_text
operator|=
name|NULL
expr_stmt|;
name|dat
index|[
literal|0
index|]
operator|=
name|dat
index|[
literal|1
index|]
operator|=
name|dat
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|dat
index|[
literal|3
index|]
operator|=
sizeof|sizeof
name|buffer
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fmt_compile
argument_list|(
name|c1
operator|->
name|c_nfs
argument_list|,
operator|&
name|c1
operator|->
name|c_fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|DATEFMT
condition|)
block|{
name|FINDCOMP
argument_list|(
name|cptr
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|cptr
operator|->
name|c_text
operator|=
name|ap
expr_stmt|;
operator|(
name|void
operator|)
name|fmtscan
argument_list|(
name|c1
operator|->
name|c_fmt
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|dat
argument_list|)
expr_stmt|;
name|c2
operator|->
name|c_text
operator|=
name|concat
argument_list|(
name|buffer
argument_list|,
literal|"\n"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|q
operator|=
operator|&
name|pq
operator|)
operator|->
name|pq_next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|ap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|pqpair
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate pqpair memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|getm
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_NAME
argument_list|,
name|error
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|pq_text
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|pq_error
operator|=
name|getcpy
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|pq_text
operator|=
name|getcpy
argument_list|(
name|mp
operator|->
name|m_text
argument_list|)
expr_stmt|;
name|mnfree
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
operator|(
name|q
operator|->
name|pq_next
operator|=
name|p
operator|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|pq
operator|.
name|pq_next
init|;
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
name|FINDCOMP
argument_list|(
name|cptr
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|cptr
operator|->
name|c_text
operator|=
name|p
operator|->
name|pq_text
expr_stmt|;
name|FINDCOMP
argument_list|(
name|cptr
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
name|cptr
operator|->
name|c_text
operator|=
name|p
operator|->
name|pq_error
expr_stmt|;
operator|(
name|void
operator|)
name|fmtscan
argument_list|(
name|c1
operator|->
name|c_fmt
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|dat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buffer
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|c_text
condition|)
name|c2
operator|->
name|c_text
operator|=
name|add
argument_list|(
literal|",\n"
argument_list|,
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|c2
operator|->
name|c_text
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|pq_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pq_error
condition|)
name|free
argument_list|(
name|p
operator|->
name|pq_error
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|pq_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|c2
operator|->
name|c_text
operator|=
name|add
argument_list|(
literal|"\n"
argument_list|,
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|mcomp
modifier|*
name|add_queue
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|,
name|name
parameter_list|,
name|text
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|struct
name|mcomp
modifier|*
modifier|*
name|head
decl_stmt|,
decl|*
modifier|*
name|tail
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|(
name|c1
operator|=
operator|(
expr|struct
name|mcomp
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|c1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate comp memory"
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_flags
operator|=
name|flags
operator|&
operator|~
name|INIT
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_name
operator|=
name|name
condition|?
name|getcpy
argument_list|(
name|name
argument_list|)
else|:
name|NULL
condition|)
name|c1
operator|->
name|c_flags
operator||=
name|mcomp_flags
argument_list|(
name|c1
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_text
operator|=
name|text
condition|?
name|getcpy
argument_list|(
name|text
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INIT
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_ovtxt
condition|)
name|c1
operator|->
name|c_ovtxt
operator|=
name|getcpy
argument_list|(
name|global
operator|.
name|c_ovtxt
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_offset
operator|=
name|global
operator|.
name|c_offset
expr_stmt|;
name|c1
operator|->
name|c_ovoff
operator|=
name|global
operator|.
name|c_ovoff
expr_stmt|;
name|c1
operator|->
name|c_width
operator|=
name|c1
operator|->
name|c_length
operator|=
literal|0
expr_stmt|;
name|c1
operator|->
name|c_cwidth
operator|=
name|global
operator|.
name|c_cwidth
expr_stmt|;
name|c1
operator|->
name|c_flags
operator||=
name|global
operator|.
name|c_flags
operator|&
name|GFLAGS
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|head
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
name|c1
expr_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|c_next
operator|=
name|c1
expr_stmt|;
operator|*
name|tail
operator|=
name|c1
expr_stmt|;
return|return
name|c1
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|free_queue
argument_list|(
name|head
argument_list|,
name|tail
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
operator|*
name|head
operator|,
operator|*
operator|*
name|tail
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
for|for
control|(
name|c1
operator|=
operator|*
name|head
init|;
name|c1
condition|;
name|c1
operator|=
name|c2
control|)
block|{
name|c2
operator|=
name|c1
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_name
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_text
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_ovtxt
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_ovtxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_nfs
condition|)
name|free
argument_list|(
name|c1
operator|->
name|c_nfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_fmt
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c1
operator|->
name|c_fmt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c1
argument_list|)
expr_stmt|;
block|}
operator|*
name|head
operator|=
operator|*
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|putcomp
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|mcomp
operator|*
name|c1
operator|,
operator|*
name|c2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|,
name|cchdr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cchdr
operator|=
literal|0
expr_stmt|;
name|lm
operator|=
literal|0
expr_stmt|;
name|llim
operator|=
name|c1
operator|->
name|c_length
condition|?
name|c1
operator|->
name|c_length
else|:
operator|-
literal|1
expr_stmt|;
name|wid
operator|=
name|c1
operator|->
name|c_width
condition|?
name|c1
operator|->
name|c_width
else|:
name|global
operator|.
name|c_width
expr_stmt|;
name|ovoff
operator|=
operator|(
name|c1
operator|->
name|c_ovoff
operator|>=
literal|0
condition|?
name|c1
operator|->
name|c_ovoff
else|:
name|global
operator|.
name|c_ovoff
operator|)
operator|+
name|c1
operator|->
name|c_offset
expr_stmt|;
if|if
condition|(
operator|(
name|ovtxt
operator|=
name|c1
operator|->
name|c_ovtxt
condition|?
name|c1
operator|->
name|c_ovtxt
else|:
name|global
operator|.
name|c_ovtxt
operator|)
operator|==
name|NULL
condition|)
name|ovtxt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|wid
operator|<
name|ovoff
operator|+
name|strlen
argument_list|(
name|ovtxt
argument_list|)
operator|+
literal|5
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"component: %s width(%d) too small for overflow(%d)"
argument_list|,
name|c1
operator|->
name|c_name
argument_list|,
name|wid
argument_list|,
name|ovoff
operator|+
name|strlen
argument_list|(
name|ovtxt
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|onelp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|CLEARTEXT
condition|)
block|{
name|putstr
argument_list|(
name|c1
operator|->
name|c_text
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c1
operator|->
name|c_nfs
operator|&&
operator|(
name|c1
operator|->
name|c_flags
operator|&
operator|(
name|ADDRFMT
operator||
name|DATEFMT
operator|)
operator|)
condition|)
name|mcomp_format
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|CENTER
condition|)
block|{
name|count
operator|=
operator|(
name|c1
operator|->
name|c_width
condition|?
name|c1
operator|->
name|c_width
else|:
name|global
operator|.
name|c_width
operator|)
operator|-
name|c1
operator|->
name|c_offset
operator|-
name|strlen
argument_list|(
name|c2
operator|->
name|c_text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|HDROUTPUT
operator|)
operator|&&
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|NOCOMPONENT
operator|)
condition|)
name|count
operator|-=
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|lm
operator|=
name|c1
operator|->
name|c_offset
operator|+
operator|(
name|count
operator|/
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|c_offset
condition|)
name|lm
operator|=
name|c1
operator|->
name|c_offset
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|HDROUTPUT
operator|)
operator|&&
operator|!
operator|(
name|c1
operator|->
name|c_flags
operator|&
name|NOCOMPONENT
operator|)
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|UPPERCASE
condition|)
comment|/* uppercase component also */
for|for
control|(
name|cp
operator|=
operator|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
operator|)
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|c1
operator|->
name|c_flags
operator||=
name|HDROUTPUT
expr_stmt|;
name|cchdr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|c1
operator|->
name|c_cwidth
operator|-
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
operator|-
literal|2
operator|)
operator|>
literal|0
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|putstr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
name|TWOCOMP
operator|&&
operator|!
operator|(
name|c2
operator|->
name|c_flags
operator|&
name|HDROUTPUT
operator|)
operator|&&
operator|!
operator|(
name|c2
operator|->
name|c_flags
operator|&
name|NOCOMPONENT
operator|)
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|UPPERCASE
condition|)
for|for
control|(
name|cp
operator|=
name|c2
operator|->
name|c_name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|c2
operator|->
name|c_name
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|c2
operator|->
name|c_flags
operator||=
name|HDROUTPUT
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|->
name|c_flags
operator|&
name|UPPERCASE
condition|)
for|for
control|(
name|cp
operator|=
name|c2
operator|->
name|c_text
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cchdr
condition|)
name|count
operator|=
operator|(
name|c1
operator|->
name|c_cwidth
operator|>=
literal|0
operator|)
condition|?
name|c1
operator|->
name|c_cwidth
else|:
name|strlen
argument_list|(
name|c1
operator|->
name|c_text
condition|?
name|c1
operator|->
name|c_text
else|:
name|c1
operator|->
name|c_name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|count
operator|+=
name|c1
operator|->
name|c_offset
expr_stmt|;
name|putstr
argument_list|(
name|oneline
argument_list|(
name|c2
operator|->
name|c_text
argument_list|,
name|c1
operator|->
name|c_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\n'
condition|)
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|=
name|oneline
argument_list|(
name|c2
operator|->
name|c_text
argument_list|,
name|c1
operator|->
name|c_flags
argument_list|)
condition|)
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|lm
operator|=
name|count
expr_stmt|;
name|putstr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\n'
condition|)
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|term
operator|==
literal|'\n'
condition|)
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|oneline
parameter_list|(
name|stuff
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|char
modifier|*
name|stuff
decl_stmt|;
name|short
name|flags
decl_stmt|;
block|{
name|int
name|spc
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|onelp
operator|==
name|NULL
condition|)
name|onelp
operator|=
name|stuff
expr_stmt|;
if|if
condition|(
operator|*
name|onelp
operator|==
name|NULL
condition|)
return|return
operator|(
name|onelp
operator|=
name|NULL
operator|)
return|;
name|ret
operator|=
name|onelp
expr_stmt|;
name|term
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|COMPRESS
condition|)
block|{
for|for
control|(
name|spc
operator|=
literal|1
operator|,
name|cp
operator|=
name|ret
init|;
operator|*
name|onelp
condition|;
name|onelp
operator|++
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|onelp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|onelp
operator|==
literal|'\n'
operator|&&
operator|(
operator|!
name|onelp
index|[
literal|1
index|]
operator|||
operator|(
name|flags
operator|&
name|ADDRFMT
operator|)
operator|)
condition|)
block|{
name|term
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|onelp
operator|++
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|spc
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|spc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|onelp
expr_stmt|;
name|spc
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|onelp
operator|&&
operator|*
name|onelp
operator|!=
literal|'\n'
condition|)
name|onelp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|onelp
operator|==
literal|'\n'
condition|)
block|{
name|term
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|onelp
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LEFTADJUST
condition|)
while|while
condition|(
operator|*
name|ret
operator|==
literal|' '
operator|||
operator|*
name|ret
operator|==
literal|'\t'
condition|)
name|ret
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|putstr
argument_list|(
name|string
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|column
operator|&&
name|lm
operator|>
literal|0
condition|)
while|while
condition|(
name|lm
operator|>
literal|0
condition|)
if|if
condition|(
name|lm
operator|>=
literal|8
condition|)
block|{
name|putch
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|lm
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|lm
operator|--
expr_stmt|;
block|}
name|lm
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
name|putch
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|putch
argument_list|(
name|ch
argument_list|)
specifier|register
name|char
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|llim
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|llim
operator|>
literal|0
condition|)
name|llim
operator|--
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|row
operator|++
expr_stmt|;
if|if
condition|(
name|ontty
operator|!=
name|ISTTY
operator|||
name|row
operator|!=
name|global
operator|.
name|c_length
condition|)
break|break;
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|BELL
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\007'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
if|if
condition|(
name|global
operator|.
name|c_flags
operator|&
name|CLEARSCR
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|row
operator|=
name|global
operator|.
name|c_length
operator|/
literal|3
expr_stmt|;
block|}
return|return;
case|case
literal|'\t'
case|:
name|column
operator||=
literal|07
expr_stmt|;
name|column
operator|++
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|column
operator|--
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|column
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|column
operator|==
literal|0
operator|&&
name|forwflg
operator|&&
name|ch
operator|==
literal|'-'
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
operator|,
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|' '
condition|)
name|column
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|column
operator|>=
name|wid
condition|)
block|{
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovoff
operator|>
literal|0
condition|)
name|lm
operator|=
name|ovoff
expr_stmt|;
name|putstr
argument_list|(
name|ovtxt
condition|?
name|ovtxt
else|:
literal|""
argument_list|)
expr_stmt|;
name|putch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|intrser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
name|discard
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipeser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipeser
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
name|done
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|quitser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quitser
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_undef
undef|#
directive|undef
name|adios
end_undef

begin_undef
undef|#
directive|undef
name|done
end_undef

begin_decl_stmt
name|int
name|mhlsbr
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|action
argument_list|)
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|register
name|FP
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|pstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|mcomp
modifier|*
name|c1
decl_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|mhlenv
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
name|cp
operator|=
name|invo_name
expr_stmt|;
name|bellflg
operator|=
name|clearflg
operator|=
name|forwflg
operator|=
name|forwall
operator|=
name|exitstat
operator|=
literal|0
expr_stmt|;
name|digest
operator|=
name|NULL
expr_stmt|;
name|ontty
operator|=
name|NOTTY
expr_stmt|;
name|mhl_action
operator|=
name|action
expr_stmt|;
if|if
condition|(
operator|(
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|pstat
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipeser
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mhl
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* fall */
default|default:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ontty
operator|==
name|PITTY
condition|)
name|m_pclose
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pstat
argument_list|)
expr_stmt|;
name|invo_name
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|holder
operator|.
name|c_text
condition|)
block|{
name|free
argument_list|(
name|holder
operator|.
name|c_text
argument_list|)
expr_stmt|;
name|holder
operator|.
name|c_text
operator|=
name|NULL
expr_stmt|;
block|}
name|free_queue
argument_list|(
operator|&
name|msghd
argument_list|,
operator|&
name|msgtl
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|fmthd
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|c_next
control|)
name|c1
operator|->
name|c_flags
operator|&=
operator|~
name|HDROUTPUT
expr_stmt|;
return|return
name|exitstat
return|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
specifier|static
name|void
name|mhladios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_function

begin_block
block|{
name|advise
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|mhldone
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|mhldone
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|exitstat
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|mhl_action
condition|)
name|longjmp
argument_list|(
name|mhlenv
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
else|else
name|done
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|m_pid
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|m_popen
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|pd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|mhl_action
operator|&&
operator|(
name|sd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"standard output"
argument_list|,
literal|"unable to dup()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pd
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"pipe"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m_pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
index|[
literal|0
index|]
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|execlp
argument_list|(
name|name
argument_list|,
name|r1bindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
index|[
literal|1
index|]
operator|!=
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|m_pclose
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|m_pid
operator|==
name|NOTOK
condition|)
return|return;
if|if
condition|(
name|sd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|sd
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"standard output"
argument_list|,
literal|"unable to dup2()"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|sd
operator|=
name|NOTOK
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pidwait
argument_list|(
name|m_pid
argument_list|,
name|OK
argument_list|)
expr_stmt|;
name|m_pid
operator|=
name|NOTOK
expr_stmt|;
block|}
end_block

end_unit

