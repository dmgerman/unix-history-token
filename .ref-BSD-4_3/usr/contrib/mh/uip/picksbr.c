begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* picksbr.c - routines to help pick along... */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|parswit
index|[]
init|=
block|{
define|#
directive|define
name|PRAND
value|0
literal|"and"
block|,
literal|0
block|,
define|#
directive|define
name|PROR
value|1
literal|"or"
block|,
literal|0
block|,
define|#
directive|define
name|PRNOT
value|2
literal|"not"
block|,
literal|0
block|,
define|#
directive|define
name|PRLBR
value|3
literal|"lbrace"
block|,
literal|0
block|,
define|#
directive|define
name|PRRBR
value|4
literal|"rbrace"
block|,
literal|0
block|,
define|#
directive|define
name|PRCC
value|5
literal|"cc  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PRDATE
value|6
literal|"date  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PRFROM
value|7
literal|"from  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PRSRCH
value|8
literal|"search  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PRSUBJ
value|9
literal|"subject  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PRTO
value|10
literal|"to  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PROTHR
value|11
literal|"-othercomponent  pattern"
block|,
literal|15
block|,
define|#
directive|define
name|PRAFTR
value|12
literal|"after date"
block|,
literal|0
block|,
define|#
directive|define
name|PRBEFR
value|13
literal|"before date"
block|,
literal|0
block|,
define|#
directive|define
name|PRDATF
value|14
literal|"datefield field"
block|,
literal|5
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|DEFINITIONS FOR PATTERN MATCHING */
end_comment

begin_comment
comment|/* We really should be using re_comp() and re_exec() here.  Unfortunately,    pick advertises that lowercase characters matches characters of both    cases.  Since re_exec() doesn't exhibit this behavior, we are stuck    with this version.  Furthermore, we need to be able to save and restore    the state of the pattern matcher in order to do things "efficiently".     The matching power of this algorithm isn't as powerful as the re_xxx()    routines (no \(xxx\) and \n constructs).  Such is life.  */
end_comment

begin_define
define|#
directive|define
name|CCHR
value|2
end_define

begin_define
define|#
directive|define
name|CDOT
value|4
end_define

begin_define
define|#
directive|define
name|CCL
value|6
end_define

begin_define
define|#
directive|define
name|NCCL
value|8
end_define

begin_define
define|#
directive|define
name|CDOL
value|10
end_define

begin_define
define|#
directive|define
name|CEOF
value|11
end_define

begin_define
define|#
directive|define
name|STAR
value|01
end_define

begin_define
define|#
directive|define
name|LBSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|ESIZE
value|256
end_define

begin_decl_stmt
specifier|static
name|char
name|linebuf
index|[
name|LBSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cc
index|[]
init|=
block|{
comment|/* the magic array for case-independence */
literal|0000
block|,
literal|0001
block|,
literal|0002
block|,
literal|0003
block|,
literal|0004
block|,
literal|0005
block|,
literal|0006
block|,
literal|0007
block|,
literal|0010
block|,
literal|0011
block|,
literal|0012
block|,
literal|0013
block|,
literal|0014
block|,
literal|0015
block|,
literal|0016
block|,
literal|0017
block|,
literal|0020
block|,
literal|0021
block|,
literal|0022
block|,
literal|0023
block|,
literal|0024
block|,
literal|0025
block|,
literal|0026
block|,
literal|0027
block|,
literal|0030
block|,
literal|0031
block|,
literal|0032
block|,
literal|0033
block|,
literal|0034
block|,
literal|0035
block|,
literal|0036
block|,
literal|0037
block|,
literal|0040
block|,
literal|0041
block|,
literal|0042
block|,
literal|0043
block|,
literal|0044
block|,
literal|0045
block|,
literal|0046
block|,
literal|0047
block|,
literal|0050
block|,
literal|0051
block|,
literal|0052
block|,
literal|0053
block|,
literal|0054
block|,
literal|0055
block|,
literal|0056
block|,
literal|0057
block|,
literal|0060
block|,
literal|0061
block|,
literal|0062
block|,
literal|0063
block|,
literal|0064
block|,
literal|0065
block|,
literal|0066
block|,
literal|0067
block|,
literal|0070
block|,
literal|0071
block|,
literal|0072
block|,
literal|0073
block|,
literal|0074
block|,
literal|0075
block|,
literal|0076
block|,
literal|0077
block|,
literal|0100
block|,
literal|0141
block|,
literal|0142
block|,
literal|0143
block|,
literal|0144
block|,
literal|0145
block|,
literal|0146
block|,
literal|0147
block|,
literal|0150
block|,
literal|0151
block|,
literal|0152
block|,
literal|0153
block|,
literal|0154
block|,
literal|0155
block|,
literal|0156
block|,
literal|0157
block|,
literal|0160
block|,
literal|0161
block|,
literal|0162
block|,
literal|0163
block|,
literal|0164
block|,
literal|0165
block|,
literal|0166
block|,
literal|0167
block|,
literal|0170
block|,
literal|0171
block|,
literal|0172
block|,
literal|0133
block|,
literal|0134
block|,
literal|0135
block|,
literal|0136
block|,
literal|0137
block|,
literal|0140
block|,
literal|0141
block|,
literal|0142
block|,
literal|0143
block|,
literal|0144
block|,
literal|0145
block|,
literal|0146
block|,
literal|0147
block|,
literal|0150
block|,
literal|0151
block|,
literal|0152
block|,
literal|0153
block|,
literal|0154
block|,
literal|0155
block|,
literal|0156
block|,
literal|0157
block|,
literal|0160
block|,
literal|0161
block|,
literal|0162
block|,
literal|0163
block|,
literal|0164
block|,
literal|0165
block|,
literal|0166
block|,
literal|0167
block|,
literal|0170
block|,
literal|0171
block|,
literal|0172
block|,
literal|0173
block|,
literal|0174
block|,
literal|0175
block|,
literal|0176
block|,
literal|0177
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|DEFINITIONS FOR DATE MATCHING */
end_comment

begin_decl_stmt
name|struct
name|tws
modifier|*
name|tws_parse
argument_list|()
decl_stmt|,
modifier|*
name|tws_special
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|DEFINITIONS FOR NEXUS */
end_comment

begin_define
define|#
directive|define
name|nxtarg
parameter_list|()
value|(*argp ? *argp++ : NULL)
end_define

begin_define
define|#
directive|define
name|prvarg
parameter_list|()
value|argp--
end_define

begin_define
define|#
directive|define
name|padvise
value|if (!talked++) advise
end_define

begin_struct
struct|struct
name|nexus
block|{
name|int
function_decl|(
modifier|*
name|n_action
function_decl|)
parameter_list|()
function_decl|;
union|union
block|{
struct|struct
block|{
comment|/* for {OR,AND,NOT}action */
name|struct
name|nexus
modifier|*
name|un_L_child
decl_stmt|;
name|struct
name|nexus
modifier|*
name|un_R_child
decl_stmt|;
block|}
name|st1
struct|;
define|#
directive|define
name|n_L_child
value|un.st1.un_L_child
define|#
directive|define
name|n_R_child
value|un.st1.un_R_child
struct|struct
block|{
comment|/* for GREPaction */
name|int
name|un_header
decl_stmt|;
name|int
name|un_circf
decl_stmt|;
name|char
name|un_expbuf
index|[
name|ESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|un_patbuf
decl_stmt|;
block|}
name|st2
struct|;
define|#
directive|define
name|n_header
value|un.st2.un_header
define|#
directive|define
name|n_circf
value|un.st2.un_circf
define|#
directive|define
name|n_expbuf
value|un.st2.un_expbuf
define|#
directive|define
name|n_patbuf
value|un.st2.un_patbuf
struct|struct
block|{
comment|/* for TWSaction */
name|char
modifier|*
name|un_datef
decl_stmt|;
name|int
name|un_after
decl_stmt|;
name|struct
name|tws
name|un_tws
decl_stmt|;
block|}
name|st3
struct|;
define|#
directive|define
name|n_datef
value|un.st3.un_datef
define|#
directive|define
name|n_after
value|un.st3.un_after
define|#
directive|define
name|n_tws
value|un.st3.un_tws
block|}
name|un
union|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|talked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|datesw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nexus
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nexus
modifier|*
name|parse
argument_list|()
decl_stmt|,
modifier|*
name|exp1
argument_list|()
decl_stmt|,
modifier|*
name|exp2
argument_list|()
decl_stmt|,
modifier|*
name|exp3
argument_list|()
decl_stmt|,
modifier|*
name|newnexus
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ORaction
argument_list|()
decl_stmt|,
name|ANDaction
argument_list|()
decl_stmt|,
name|NOTaction
argument_list|()
decl_stmt|,
name|GREPaction
argument_list|()
decl_stmt|,
name|TWSaction
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|pcompile
parameter_list|(
name|vec
parameter_list|,
name|date
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|,
decl|*
name|date
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MHPDEBUG"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|)
name|pdebug
operator|++
expr_stmt|;
name|argp
operator|=
name|vec
expr_stmt|;
if|if
condition|(
operator|(
name|datesw
operator|=
name|date
operator|)
operator|==
name|NULL
condition|)
name|datesw
operator|=
literal|"date"
expr_stmt|;
name|talked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|head
operator|=
name|parse
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|talked
condition|?
literal|0
else|:
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|argp
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s unexpected"
argument_list|,
operator|*
name|argp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|nexus
modifier|*
name|parse
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|nexus
modifier|*
name|n
decl_stmt|,
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|exp1
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|n
return|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'-'
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s unexpected"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|'-'
condition|)
goto|goto
name|header
goto|;
switch|switch
condition|(
name|smatch
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|PROR
case|:
name|o
operator|=
name|newnexus
argument_list|(
name|ORaction
argument_list|)
expr_stmt|;
name|o
operator|->
name|n_L_child
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|n_R_child
operator|=
name|parse
argument_list|()
condition|)
return|return
name|o
return|;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing disjunctive"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|header
label|:
empty_stmt|;
default|default:
name|prvarg
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|nexus
modifier|*
name|exp1
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|nexus
modifier|*
name|n
decl_stmt|,
modifier|*
name|o
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|exp2
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|n
return|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'-'
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s unexpected"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|'-'
condition|)
goto|goto
name|header
goto|;
switch|switch
condition|(
name|smatch
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|PRAND
case|:
name|o
operator|=
name|newnexus
argument_list|(
name|ANDaction
argument_list|)
expr_stmt|;
name|o
operator|->
name|n_L_child
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|n_R_child
operator|=
name|exp1
argument_list|()
condition|)
return|return
name|o
return|;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing conjunctive"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|header
label|:
empty_stmt|;
default|default:
name|prvarg
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|nexus
modifier|*
name|exp2
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|nexus
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'-'
condition|)
block|{
name|prvarg
argument_list|()
expr_stmt|;
return|return
name|exp3
argument_list|()
return|;
block|}
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|'-'
condition|)
goto|goto
name|header
goto|;
switch|switch
condition|(
name|smatch
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|PRNOT
case|:
name|n
operator|=
name|newnexus
argument_list|(
name|NOTaction
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_L_child
operator|=
name|exp3
argument_list|()
condition|)
return|return
name|n
return|;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing negation"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|header
label|:
empty_stmt|;
default|default:
name|prvarg
argument_list|()
expr_stmt|;
return|return
name|exp3
argument_list|()
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|nexus
modifier|*
name|exp3
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|nexus
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'-'
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s unexpected"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|'-'
condition|)
block|{
name|dp
operator|=
operator|++
name|cp
expr_stmt|;
goto|goto
name|header
goto|;
block|}
switch|switch
condition|(
name|i
operator|=
name|smatch
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|talked
operator|++
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|PRLBR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|parse
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing group"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing -rbrace"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'-'
operator|&&
name|smatch
argument_list|(
name|cp
argument_list|,
name|parswit
argument_list|)
operator|==
name|PRRBR
condition|)
return|return
name|n
return|;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s unexpected"
argument_list|,
operator|--
name|cp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
name|prvarg
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|PRCC
case|:
case|case
name|PRDATE
case|:
case|case
name|PRFROM
case|:
case|case
name|PRTO
case|:
case|case
name|PRSUBJ
case|:
name|dp
operator|=
operator|*
name|brkstring
argument_list|(
name|parswit
index|[
name|i
index|]
operator|.
name|sw
argument_list|,
literal|" "
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|header
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
condition|)
block|{
comment|/* allow -xyz arguments */
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|=
name|newnexus
argument_list|(
name|GREPaction
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_header
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"^%s[ \t]*:.*%s"
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|buffer
expr_stmt|;
goto|goto
name|pattern
goto|;
case|case
name|PRSRCH
case|:
name|n
operator|=
name|newnexus
argument_list|(
name|GREPaction
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_header
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
condition|)
block|{
comment|/* allow -xyz arguments */
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dp
operator|=
name|cp
expr_stmt|;
name|pattern
label|:
empty_stmt|;
if|if
condition|(
operator|!
name|gcompile
argument_list|(
name|n
argument_list|,
name|dp
argument_list|)
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"pattern error in %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|->
name|n_patbuf
operator|=
name|getcpy
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|n
return|;
case|case
name|PROTHR
case|:
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error!"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|PRDATF
case|:
if|if
condition|(
operator|!
operator|(
name|datesw
operator|=
name|nxtarg
argument_list|()
operator|)
operator|||
operator|*
name|datesw
operator|==
literal|'-'
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|exp3
argument_list|()
return|;
case|case
name|PRAFTR
case|:
case|case
name|PRBEFR
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|nxtarg
argument_list|()
operator|)
condition|)
block|{
comment|/* allow -xyz arguments */
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|=
name|newnexus
argument_list|(
name|TWSaction
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_datef
operator|=
name|datesw
expr_stmt|;
if|if
condition|(
operator|!
name|tcompile
argument_list|(
name|cp
argument_list|,
operator|&
name|n
operator|->
name|n_tws
argument_list|,
name|n
operator|->
name|n_after
operator|=
name|i
operator|==
name|PRAFTR
argument_list|)
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to parse %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|n
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|nexus
modifier|*
name|newnexus
argument_list|(
name|action
argument_list|)
decl|register
name|int
argument_list|(
operator|*
name|action
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nexus
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|nexus
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate component storage"
argument_list|)
expr_stmt|;
name|p
operator|->
name|n_action
operator|=
name|action
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|args
parameter_list|(
name|a
parameter_list|)
value|a, fp, msgnum, start, stop
end_define

begin_define
define|#
directive|define
name|params
value|args (n)
end_define

begin_define
define|#
directive|define
name|plist
define|\
value|register struct nexus  *n; \ 	    register FILE *fp; \ 	    int	msgnum; \ 	    long    start, \ 		    stop;
end_define

begin_function
name|int
name|pmatches
parameter_list|(
name|fp
parameter_list|,
name|msgnum
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|msgnum
decl_stmt|;
name|long
name|start
decl_stmt|,
name|stop
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|head
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|talked
operator|++
operator|&&
name|pdebug
condition|)
name|PRaction
argument_list|(
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|head
operator|->
name|n_action
call|)
argument_list|(
name|args
argument_list|(
name|head
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|PRaction
argument_list|(
name|n
argument_list|,
name|level
argument_list|)
specifier|register
expr|struct
name|nexus
operator|*
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|level
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"| "
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_action
operator|==
name|ORaction
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OR\n"
argument_list|)
expr_stmt|;
name|PRaction
argument_list|(
name|n
operator|->
name|n_L_child
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|PRaction
argument_list|(
name|n
operator|->
name|n_R_child
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|->
name|n_action
operator|==
name|ANDaction
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"AND\n"
argument_list|)
expr_stmt|;
name|PRaction
argument_list|(
name|n
operator|->
name|n_L_child
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|PRaction
argument_list|(
name|n
operator|->
name|n_R_child
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|->
name|n_action
operator|==
name|NOTaction
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NOT\n"
argument_list|)
expr_stmt|;
name|PRaction
argument_list|(
name|n
operator|->
name|n_L_child
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|->
name|n_action
operator|==
name|GREPaction
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PATTERN(%s) %s\n"
argument_list|,
name|n
operator|->
name|n_header
condition|?
literal|"header"
else|:
literal|"body"
argument_list|,
name|n
operator|->
name|n_patbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|->
name|n_action
operator|==
name|TWSaction
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TEMPORAL(%s) %s: %s\n"
argument_list|,
name|n
operator|->
name|n_after
condition|?
literal|"after"
else|:
literal|"before"
argument_list|,
name|n
operator|->
name|n_datef
argument_list|,
name|dasctime
argument_list|(
operator|&
name|n
operator|->
name|n_tws
argument_list|,
name|TW_NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"UNKNOWN(0x%x)\n"
argument_list|,
operator|(
operator|*
name|n
operator|->
name|n_action
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|ORaction
parameter_list|(
name|params
parameter_list|)
function|plist
block|{
if|if
condition|(
call|(
modifier|*
name|n
operator|->
name|n_L_child
operator|->
name|n_action
call|)
argument_list|(
name|args
argument_list|(
name|n
operator|->
name|n_L_child
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
call|(
modifier|*
name|n
operator|->
name|n_R_child
operator|->
name|n_action
call|)
argument_list|(
name|args
argument_list|(
name|n
operator|->
name|n_R_child
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ANDaction
parameter_list|(
name|params
parameter_list|)
function|plist
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|n
operator|->
name|n_L_child
operator|->
name|n_action
call|)
argument_list|(
name|args
argument_list|(
name|n
operator|->
name|n_L_child
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
call|(
modifier|*
name|n
operator|->
name|n_R_child
operator|->
name|n_action
call|)
argument_list|(
name|args
argument_list|(
name|n
operator|->
name|n_R_child
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|NOTaction
parameter_list|(
name|params
parameter_list|)
function|plist
block|{
return|return
operator|(
operator|!
call|(
modifier|*
name|n
operator|->
name|n_L_child
operator|->
name|n_action
call|)
argument_list|(
name|args
argument_list|(
name|n
operator|->
name|n_L_child
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|gcompile
parameter_list|(
name|n
parameter_list|,
name|astr
parameter_list|)
specifier|register
name|struct
name|nexus
modifier|*
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|astr
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|cclcnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|lastep
decl_stmt|;
name|dp
operator|=
operator|(
name|ep
operator|=
name|n
operator|->
name|n_expbuf
operator|)
operator|+
sizeof|sizeof
name|n
operator|->
name|n_expbuf
expr_stmt|;
name|sp
operator|=
name|astr
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'^'
condition|)
block|{
name|n
operator|->
name|n_circf
operator|=
literal|1
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|n
operator|->
name|n_circf
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ep
operator|>=
name|dp
condition|)
goto|goto
name|cerror
goto|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|!=
literal|'*'
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
operator|*
name|ep
operator|++
operator|=
name|CEOF
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'.'
case|:
operator|*
name|ep
operator|++
operator|=
name|CDOT
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|lastep
operator|==
literal|0
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|lastep
operator||=
name|STAR
expr_stmt|;
continue|continue;
case|case
literal|'$'
case|:
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|ep
operator|++
operator|=
name|CDOL
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
operator|*
name|ep
operator|++
operator|=
name|CCL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
name|cclcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|ep
index|[
operator|-
literal|2
index|]
operator|=
name|NCCL
expr_stmt|;
block|}
do|do
block|{
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|ep
operator|>=
name|dp
condition|)
goto|goto
name|cerror
goto|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|!=
literal|']'
condition|)
do|;
name|lastep
index|[
literal|1
index|]
operator|=
name|cclcnt
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|==
literal|'\0'
condition|)
goto|goto
name|cerror
goto|;
name|defchar
label|:
default|default:
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
name|cerror
label|:
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|GREPaction
parameter_list|(
name|params
parameter_list|)
function|plist
block|{
name|int
name|c
decl_stmt|,
name|body
decl_stmt|,
name|lf
decl_stmt|;
name|long
name|pos
init|=
name|start
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|ebp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|;
name|char
name|ibuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|body
operator|=
literal|0
expr_stmt|;
name|ebp
operator|=
name|cbp
operator|=
name|ibuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|body
operator|&&
name|n
operator|->
name|n_header
condition|)
return|return
literal|0
return|;
name|p1
operator|=
name|linebuf
expr_stmt|;
name|p2
operator|=
name|cbp
expr_stmt|;
name|lf
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p2
operator|>=
name|ebp
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|ibuf
argument_list|,
sizeof|sizeof
name|ibuf
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|stop
operator|&&
name|pos
operator|>=
name|stop
operator|)
condition|)
block|{
if|if
condition|(
name|lf
condition|)
break|break;
return|return
literal|0
return|;
block|}
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|p2
operator|=
name|ibuf
expr_stmt|;
name|ebp
operator|=
name|ibuf
operator|+
name|strlen
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
if|if
condition|(
name|lf
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
block|{
operator|--
name|p2
expr_stmt|;
break|break;
block|}
else|else
name|lf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
if|if
condition|(
name|body
condition|)
break|break;
else|else
block|{
if|if
condition|(
name|lf
condition|)
block|{
name|body
operator|++
expr_stmt|;
break|break;
block|}
name|lf
operator|++
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|&&
name|p1
operator|<
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|1
index|]
condition|)
operator|*
name|p1
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p1
operator|++
operator|=
name|NULL
expr_stmt|;
name|cbp
operator|=
name|p2
expr_stmt|;
name|p1
operator|=
name|linebuf
expr_stmt|;
name|p2
operator|=
name|n
operator|->
name|n_expbuf
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_circf
condition|)
block|{
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p2
operator|==
name|CCHR
condition|)
block|{
name|c
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p1
operator|==
name|c
operator|||
name|cc
index|[
operator|*
name|p1
index|]
operator|==
name|c
condition|)
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
continue|continue;
block|}
do|do
block|{
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|advance
parameter_list|(
name|alp
parameter_list|,
name|aep
parameter_list|)
specifier|register
name|char
modifier|*
name|alp
decl_stmt|,
decl|*
name|aep
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|curlp
decl_stmt|;
name|lp
operator|=
name|alp
expr_stmt|;
name|ep
operator|=
name|aep
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|ep
operator|++
condition|)
block|{
case|case
name|CCHR
case|:
if|if
condition|(
operator|*
name|ep
operator|++
operator|==
operator|*
name|lp
operator|++
operator|||
name|ep
index|[
operator|-
literal|1
index|]
operator|==
name|cc
index|[
name|lp
index|[
operator|-
literal|1
index|]
index|]
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|CDOT
case|:
if|if
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|CDOL
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|0
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|CEOF
case|:
return|return
literal|1
return|;
case|case
name|CCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
literal|0
return|;
case|case
name|NCCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
literal|0
return|;
case|case
name|CDOT
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
goto|goto
name|star
goto|;
case|case
name|CCHR
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|==
operator|*
name|ep
operator|||
name|cc
index|[
name|lp
index|[
operator|-
literal|1
index|]
index|]
operator|==
operator|*
name|ep
condition|)
continue|continue;
name|ep
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCL
operator||
name|STAR
case|:
case|case
name|NCCL
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|CCL
operator||
name|STAR
operator|)
argument_list|)
condition|)
continue|continue;
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
goto|goto
name|star
goto|;
name|star
label|:
do|do
block|{
name|lp
operator|--
expr_stmt|;
if|if
condition|(
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|lp
operator|>
name|curlp
condition|)
do|;
return|return
literal|0
return|;
default|default:
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"advance() botch -- you lose big"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|cclass
parameter_list|(
name|aset
parameter_list|,
name|ac
parameter_list|,
name|af
parameter_list|)
specifier|register
name|char
modifier|*
name|aset
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|set
operator|=
name|aset
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|ac
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
operator|*
name|set
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
if|if
condition|(
operator|*
name|set
operator|++
operator|==
name|c
condition|)
return|return
operator|(
name|af
operator|)
return|;
return|return
operator|(
operator|!
name|af
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|tcompile
parameter_list|(
name|ap
parameter_list|,
name|tb
parameter_list|,
name|isafter
parameter_list|)
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
name|struct
name|tws
modifier|*
name|tb
decl_stmt|;
name|int
name|isafter
decl_stmt|;
block|{
specifier|register
name|struct
name|tws
modifier|*
name|tw
decl_stmt|;
if|if
condition|(
operator|(
name|tw
operator|=
name|tws_parse
argument_list|(
name|ap
argument_list|,
name|isafter
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|twscopy
argument_list|(
name|tb
argument_list|,
name|tw
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|tws
modifier|*
name|tws_parse
parameter_list|(
name|ap
parameter_list|,
name|isafter
parameter_list|)
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
name|int
name|isafter
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|tws
modifier|*
name|tw
decl_stmt|,
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
operator|(
name|tw
operator|=
name|tws_special
argument_list|(
name|ap
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tw
operator|->
name|tw_sec
operator|=
name|tw
operator|->
name|tw_min
operator|=
name|isafter
condition|?
literal|59
else|:
literal|0
expr_stmt|;
name|tw
operator|->
name|tw_hour
operator|=
name|isafter
condition|?
literal|23
else|:
literal|0
expr_stmt|;
return|return
name|tw
return|;
block|}
if|if
condition|(
operator|(
name|tw
operator|=
name|dparsetime
argument_list|(
name|ap
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|tw
return|;
if|if
condition|(
operator|(
name|ts
operator|=
name|dtwstime
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %s"
argument_list|,
name|ap
argument_list|,
name|dtwszone
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tw
operator|=
name|dparsetime
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|tw
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %02d:%02d:%02d %s"
argument_list|,
name|ap
argument_list|,
name|ts
operator|->
name|tw_hour
argument_list|,
name|ts
operator|->
name|tw_min
argument_list|,
name|ts
operator|->
name|tw_sec
argument_list|,
name|dtwszone
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tw
operator|=
name|dparsetime
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|tw
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%02d %s %02d %s"
argument_list|,
name|ts
operator|->
name|tw_mday
argument_list|,
name|tw_moty
index|[
name|ts
operator|->
name|tw_mon
index|]
argument_list|,
name|ts
operator|->
name|tw_year
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tw
operator|=
name|dparsetime
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|tw
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%02d %s %02d %s %s"
argument_list|,
name|ts
operator|->
name|tw_mday
argument_list|,
name|tw_moty
index|[
name|ts
operator|->
name|tw_mon
index|]
argument_list|,
name|ts
operator|->
name|tw_year
argument_list|,
name|ap
argument_list|,
name|dtwszone
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tw
operator|=
name|dparsetime
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|tw
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|tws
modifier|*
name|tws_special
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|long
name|clock
decl_stmt|;
specifier|register
name|struct
name|tws
modifier|*
name|tw
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|ap
argument_list|,
literal|"Today"
argument_list|)
condition|)
return|return
name|dlocaltime
argument_list|(
operator|&
name|clock
argument_list|)
return|;
if|if
condition|(
name|uleq
argument_list|(
name|ap
argument_list|,
literal|"Yesterday"
argument_list|)
condition|)
block|{
name|clock
operator|-=
call|(
name|long
call|)
argument_list|(
literal|60
operator|*
literal|60
operator|*
literal|24
argument_list|)
expr_stmt|;
return|return
name|dlocaltime
argument_list|(
operator|&
name|clock
argument_list|)
return|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|ap
argument_list|,
literal|"Tomorrow"
argument_list|)
condition|)
block|{
name|clock
operator|+=
call|(
name|long
call|)
argument_list|(
literal|60
operator|*
literal|60
operator|*
literal|24
argument_list|)
expr_stmt|;
return|return
name|dlocaltime
argument_list|(
operator|&
name|clock
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tw_ldotw
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ap
argument_list|,
name|tw_ldotw
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tw_ldotw
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|tw
operator|=
name|dlocaltime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|i
operator|-=
name|tw
operator|->
name|tw_wday
operator|)
operator|>
literal|0
condition|)
name|i
operator|-=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ap
operator|!=
literal|'-'
condition|)
return|return
name|NULL
return|;
else|else
comment|/* -ddd days ago */
name|i
operator|=
name|atoi
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* we should error check this */
name|clock
operator|+=
call|(
name|long
call|)
argument_list|(
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
operator|*
name|i
argument_list|)
expr_stmt|;
return|return
name|dlocaltime
argument_list|(
operator|&
name|clock
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|TWSaction
parameter_list|(
name|params
parameter_list|)
function|plist
block|{
name|int
name|state
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
specifier|register
name|struct
name|tws
modifier|*
name|tw
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|state
operator|=
name|FLD
operator|,
name|bp
operator|=
name|NULL
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDEOF
case|:
case|case
name|FLDPLUS
case|:
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bp
argument_list|)
operator|,
name|bp
operator|=
name|NULL
expr_stmt|;
name|bp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|n
operator|->
name|n_datef
argument_list|)
condition|)
break|break;
if|if
condition|(
name|state
operator|!=
name|FLDEOF
condition|)
continue|continue;
case|case
name|BODY
case|:
case|case
name|BODYEOF
case|:
case|case
name|FILEEOF
case|:
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
if|if
condition|(
name|state
operator|==
name|LENERR
operator|||
name|state
operator|==
name|FMTERR
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"format error in message %d"
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error -- you lose"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*
comment|*/
if|if
condition|(
operator|(
name|tw
operator|=
name|dparsetime
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to parse %s field in message %d, matching..."
argument_list|,
name|n
operator|->
name|n_datef
argument_list|,
name|msgnum
argument_list|)
operator|,
name|state
operator|=
literal|1
expr_stmt|;
else|else
name|state
operator|=
name|n
operator|->
name|n_after
condition|?
operator|(
name|twsort
argument_list|(
name|tw
argument_list|,
operator|&
name|n
operator|->
name|n_tws
argument_list|)
operator|>
literal|0
operator|)
else|:
operator|(
name|twsort
argument_list|(
name|tw
argument_list|,
operator|&
name|n
operator|->
name|n_tws
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|state
return|;
block|}
end_function

end_unit

