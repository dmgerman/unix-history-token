begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mshcmds.c - command handlers in msh */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/scansbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"../h/mshsbr.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BURST */
end_comment

begin_decl_stmt
specifier|static
name|char
name|delim3
index|[]
init|=
literal|"-------"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from burst.c */
end_comment

begin_comment
comment|/* SHOW */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mhlnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|mhlfp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|clear_screen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eom_action
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FP
name|mhl_action
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* SORTM */
end_comment

begin_function_decl
name|int
name|msgsort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tws
modifier|*
name|getws
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|forkcmd
argument_list|(
argument|args
argument_list|,
argument|pgm
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|,
modifier|*
name|pgm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|child_id
decl_stmt|;
name|char
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|r1bindex
argument_list|(
name|pgm
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|copyip
argument_list|(
name|args
argument_list|,
name|vec
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
operator|(
name|void
operator|)
name|m_delete
argument_list|(
name|pfolder
argument_list|)
expr_stmt|;
name|m_replace
argument_list|(
name|pfolder
argument_list|,
name|fmsh
argument_list|)
expr_stmt|;
name|m_sync
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|m_update
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OK
case|:
name|closefds
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|pgm
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|cmd_name
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fmsh
condition|)
block|{
comment|/* assume the worst case */
name|mp
operator|->
name|msgflags
operator||=
name|MODIFIED
expr_stmt|;
name|modified
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|distswit
index|[]
init|=
block|{
define|#
directive|define
name|DIANSW
value|0
literal|"annotate"
block|,
literal|0
block|,
define|#
directive|define
name|DINANSW
value|1
literal|"noannotate"
block|,
literal|0
block|,
define|#
directive|define
name|DIDFSW
value|2
literal|"draftfolder +folder"
block|,
literal|0
block|,
define|#
directive|define
name|DIDMSW
value|3
literal|"draftmessage msg"
block|,
literal|0
block|,
define|#
directive|define
name|DINDFSW
value|4
literal|"nodraftfolder"
block|,
literal|0
block|,
define|#
directive|define
name|DIEDTSW
value|5
literal|"editor editor"
block|,
literal|0
block|,
define|#
directive|define
name|DINEDSW
value|6
literal|"noedit"
block|,
literal|0
block|,
define|#
directive|define
name|DIFRMSW
value|7
literal|"form formfile"
block|,
literal|0
block|,
define|#
directive|define
name|DIINSW
value|8
literal|"inplace"
block|,
literal|0
block|,
define|#
directive|define
name|DININSW
value|9
literal|"noinplace"
block|,
literal|0
block|,
define|#
directive|define
name|DIWHTSW
value|10
literal|"whatnowproc program"
block|,
literal|0
block|,
define|#
directive|define
name|DINWTSW
value|11
literal|"nowhatnowproc"
block|,
literal|0
block|,
define|#
directive|define
name|DIHELP
value|12
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|distcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|vecp
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|args
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|distswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|distswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|DIHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|distswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|DIANSW
case|:
comment|/* not implemented */
case|case
name|DINANSW
case|:
case|case
name|DIINSW
case|:
case|case
name|DININSW
case|:
continue|continue;
case|case
name|DINDFSW
case|:
case|case
name|DINEDSW
case|:
case|case
name|DINWTSW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
continue|continue;
case|case
name|DIEDTSW
case|:
case|case
name|DIFRMSW
case|:
case|case
name|DIDFSW
case|:
case|case
name|DIDMSW
case|:
case|case
name|DIWHTSW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|msg
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one message at a time!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msg
operator|=
name|cp
expr_stmt|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
name|cmd_name
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-file"
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|msg
operator|=
literal|"cur"
expr_stmt|;
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|>
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one message at a time!"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|process
argument_list|(
name|mp
operator|->
name|hghsel
argument_list|,
name|cmd_name
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|explswit
index|[]
init|=
block|{
define|#
directive|define
name|EXINSW
value|0
literal|"inplace"
block|,
literal|0
block|,
define|#
directive|define
name|EXNINSW
value|1
literal|"noinplace"
block|,
literal|0
block|,
define|#
directive|define
name|EXQISW
value|2
literal|"quiet"
block|,
literal|0
block|,
define|#
directive|define
name|EXNQISW
value|3
literal|"noquiet"
block|,
literal|0
block|,
define|#
directive|define
name|EXVBSW
value|4
literal|"verbose"
block|,
literal|0
block|,
define|#
directive|define
name|EXNVBSW
value|5
literal|"noverbose"
block|,
literal|0
block|,
define|#
directive|define
name|EXHELP
value|6
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|explcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|inplace
init|=
literal|0
decl_stmt|,
name|quietsw
init|=
literal|0
decl_stmt|,
name|verbosw
init|=
literal|0
decl_stmt|,
name|msgp
init|=
literal|0
decl_stmt|,
name|hi
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|;
name|struct
name|Msg
modifier|*
name|smsgs
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|args
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|explswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|explswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|explswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|EXINSW
case|:
name|inplace
operator|++
expr_stmt|;
continue|continue;
case|case
name|EXNINSW
case|:
name|inplace
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|EXQISW
case|:
name|quietsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|EXNQISW
case|:
name|quietsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|EXVBSW
case|:
name|verbosw
operator|++
expr_stmt|;
continue|continue;
case|case
name|EXNVBSW
case|:
name|verbosw
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"cur"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|smsgs
operator|=
operator|(
expr|struct
name|Msg
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|MAXFOLDER
operator|+
literal|2
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|smsgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsgs
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate folder storage"
argument_list|)
expr_stmt|;
name|hi
operator|=
name|mp
operator|->
name|hghmsg
operator|+
literal|1
expr_stmt|;
name|interrupted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
operator|&&
operator|!
name|interrupted
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
if|if
condition|(
name|burst
argument_list|(
name|smsgs
argument_list|,
name|msgnum
argument_list|,
name|inplace
argument_list|,
name|quietsw
argument_list|,
name|verbosw
argument_list|)
operator|!=
name|OK
condition|)
break|break;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|smsgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|inplace
condition|)
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|lowsel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|<=
name|mp
operator|->
name|hghmsg
condition|)
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|mp
operator|->
name|msgflags
operator||=
name|MODIFIED
expr_stmt|;
name|modified
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|burst
argument_list|(
argument|smsgs
argument_list|,
argument|msgnum
argument_list|,
argument|inplace
argument_list|,
argument|quietsw
argument_list|,
argument|verbosw
argument_list|)
expr|struct
name|Msg
operator|*
name|smsgs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|msgnum
decl_stmt|,
name|inplace
decl_stmt|,
name|quietsw
decl_stmt|,
name|verbosw
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ld3
decl_stmt|,
name|wasdlm
decl_stmt|,
name|msgp
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|char
name|c
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|zp
decl_stmt|;
name|ld3
operator|=
name|strlen
argument_list|(
name|delim3
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
condition|)
block|{
name|free
argument_list|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
argument_list|)
expr_stmt|;
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
operator|=
name|NULL
expr_stmt|;
block|}
name|pos
operator|=
name|ftell
argument_list|(
name|zp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|msgp
operator|=
literal|1
init|;
name|msgp
operator|<=
name|MAXFOLDER
condition|;
control|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|zp
argument_list|)
operator|!=
name|NULL
operator|&&
name|buffer
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
condition|)
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|zp
argument_list|)
operator|||
name|pos
operator|>=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
condition|)
break|break;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|zp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smsgs
index|[
name|msgp
index|]
operator|.
name|m_start
operator|=
name|pos
expr_stmt|;
for|for
control|(
name|c
operator|=
name|NULL
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|zp
argument_list|)
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
condition|;
name|c
operator|=
name|buffer
index|[
literal|0
index|]
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
name|delim3
argument_list|,
name|ld3
argument_list|)
operator|==
literal|0
operator|&&
name|peekc
argument_list|(
name|zp
argument_list|)
operator|==
literal|'\n'
operator|&&
operator|(
name|msgp
operator|==
literal|1
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
break|break;
else|else
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|wasdlm
operator|=
name|strncmp
argument_list|(
name|buffer
argument_list|,
name|delim3
argument_list|,
name|ld3
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|smsgs
index|[
name|msgp
index|]
operator|.
name|m_start
operator|!=
name|pos
condition|)
name|smsgs
index|[
name|msgp
operator|++
index|]
operator|.
name|m_stop
operator|=
name|c
operator|==
literal|'\n'
operator|&&
name|wasdlm
condition|?
name|pos
operator|-
literal|1
else|:
name|pos
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|zp
argument_list|)
operator|||
name|pos
operator|>=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
condition|)
block|{
if|if
condition|(
name|wasdlm
condition|)
block|{
name|smsgs
index|[
name|msgp
operator|-
literal|1
index|]
operator|.
name|m_stop
operator|-=
operator|(
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|msgp
operator|++
expr_stmt|;
comment|/* fake "End of XXX Digest" */
block|}
break|break;
block|}
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|--
name|msgp
condition|)
block|{
comment|/* toss "End of XXX Digest" */
case|case
literal|0
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"burst() botch -- you lose big"
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|quietsw
condition|)
name|printf
argument_list|(
literal|"message %d not in digest format\n"
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
default|default:
if|if
condition|(
name|verbosw
condition|)
name|printf
argument_list|(
literal|"%d message%s exploded from digest %d\n"
argument_list|,
name|msgp
operator|-
literal|1
argument_list|,
name|msgp
operator|-
literal|1
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgp
operator|==
literal|2
condition|)
name|msgp
operator|++
expr_stmt|;
break|break;
block|}
name|msgp
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|msgp
operator|+
name|mp
operator|->
name|hghmsg
operator|)
operator|>
name|MAXFOLDER
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"more than %d messages"
argument_list|,
name|MAXFOLDER
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|mp
operator|=
name|m_remsg
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate folder storage"
argument_list|)
expr_stmt|;
name|j
operator|=
name|mp
operator|->
name|hghmsg
expr_stmt|;
name|mp
operator|->
name|hghmsg
operator|+=
name|msgp
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|nummsg
operator|+=
name|msgp
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|hghsel
operator|>
name|msgnum
condition|)
name|mp
operator|->
name|hghsel
operator|+=
name|msgp
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|inplace
operator|&&
name|msgp
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
name|mp
operator|->
name|hghmsg
init|;
name|j
operator|>
name|msgnum
condition|;
name|i
operator|--
operator|,
name|j
operator|--
control|)
block|{
if|if
condition|(
name|verbosw
condition|)
name|printf
argument_list|(
literal|"message %d becomes message %d\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_bboard_id
operator|=
name|Msgs
index|[
name|j
index|]
operator|.
name|m_bboard_id
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_top
operator|=
name|Msgs
index|[
name|j
index|]
operator|.
name|m_top
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
operator|=
name|Msgs
index|[
name|j
index|]
operator|.
name|m_start
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
operator|=
name|Msgs
index|[
name|j
index|]
operator|.
name|m_stop
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_scanl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Msgs
index|[
name|j
index|]
operator|.
name|m_scanl
condition|)
block|{
name|free
argument_list|(
name|Msgs
index|[
name|j
index|]
operator|.
name|m_scanl
argument_list|)
expr_stmt|;
name|Msgs
index|[
name|j
index|]
operator|.
name|m_scanl
operator|=
name|NULL
expr_stmt|;
block|}
name|mp
operator|->
name|msgstats
index|[
name|i
index|]
operator|=
name|mp
operator|->
name|msgstats
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|readid
argument_list|(
name|msgnum
argument_list|)
expr_stmt|;
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&=
operator|~
name|SELECTED
expr_stmt|;
name|i
operator|=
name|inplace
condition|?
name|msgnum
operator|+
name|msgp
operator|-
literal|1
else|:
name|mp
operator|->
name|hghmsg
expr_stmt|;
for|for
control|(
name|j
operator|=
name|msgp
init|;
name|j
operator|>=
operator|(
name|inplace
condition|?
literal|1
else|:
literal|2
operator|)
condition|;
name|i
operator|--
operator|,
name|j
operator|--
control|)
block|{
if|if
condition|(
name|verbosw
operator|&&
name|i
operator|!=
name|msgnum
condition|)
name|printf
argument_list|(
literal|"message %d of digest %d becomes message %d\n"
argument_list|,
name|j
argument_list|,
name|msgnum
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_bboard_id
operator|=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_top
operator|=
name|Msgs
index|[
name|j
index|]
operator|.
name|m_top
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
operator|=
name|smsgs
index|[
name|j
index|]
operator|.
name|m_start
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
operator|=
name|smsgs
index|[
name|j
index|]
operator|.
name|m_stop
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_scanl
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|msgstats
index|[
name|i
index|]
operator|=
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|fileswit
index|[]
init|=
block|{
define|#
directive|define
name|FIDRFT
value|0
literal|"draft"
block|,
literal|0
block|,
define|#
directive|define
name|FILINK
value|1
literal|"link"
block|,
literal|0
block|,
define|#
directive|define
name|FINLINK
value|2
literal|"nolink"
block|,
literal|0
block|,
define|#
directive|define
name|FIPRES
value|3
literal|"preserve"
block|,
literal|0
block|,
define|#
directive|define
name|FINPRES
value|4
literal|"nopreserve"
block|,
literal|0
block|,
define|#
directive|define
name|FISRC
value|5
literal|"src +folder"
block|,
literal|0
block|,
define|#
directive|define
name|FIFILE
value|6
literal|"file file"
block|,
literal|0
block|,
define|#
directive|define
name|FIHELP
value|7
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|filecmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|linksw
init|=
literal|0
decl_stmt|,
name|msgp
init|=
literal|0
decl_stmt|,
name|vecp
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|args
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|i
operator|=
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|fileswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|fileswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|FIHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s +folder... [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|fileswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|FILINK
case|:
name|linksw
operator|++
expr_stmt|;
continue|continue;
case|case
name|FINLINK
case|:
name|linksw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|FIPRES
case|:
case|case
name|FINPRES
case|:
continue|continue;
case|case
name|FISRC
case|:
case|case
name|FIDRFT
case|:
case|case
name|FIFILE
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, -%s not allowed!"
argument_list|,
name|fileswit
index|[
name|i
index|]
operator|.
name|sw
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
name|cmd_name
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-file"
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"cur"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|interrupted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
operator|&&
operator|!
name|interrupted
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
if|if
condition|(
name|process
argument_list|(
name|msgnum
argument_list|,
name|fileproc
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|)
condition|)
block|{
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&=
operator|~
name|SELECTED
expr_stmt|;
name|mp
operator|->
name|numsel
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|numsel
operator|!=
name|mp
operator|->
name|nummsg
operator|||
name|linksw
condition|)
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linksw
condition|)
name|rmm
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|filehak
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|result
decl_stmt|,
name|vecp
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cwd
decl_stmt|,
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|fileswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
case|case
name|UNKWNSW
case|:
case|case
name|FIHELP
case|:
return|return
name|NOTOK
return|;
case|case
name|FILINK
case|:
case|case
name|FINLINK
case|:
case|case
name|FIPRES
case|:
case|case
name|FINPRES
case|:
continue|continue;
case|case
name|FISRC
case|:
case|case
name|FIDRFT
case|:
case|case
name|FIFILE
case|:
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
name|cwd
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vecp
operator|=
literal|0
init|;
operator|(
name|cp
operator|=
name|vec
index|[
name|vecp
index|]
operator|)
operator|&&
name|result
operator|==
name|NOTOK
condition|;
name|vecp
operator|++
control|)
block|{
if|if
condition|(
name|cwd
operator|==
name|NULL
condition|)
name|cwd
operator|=
name|getcpy
argument_list|(
name|pwd
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|m_maildir
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|path
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|*
name|cp
operator|==
literal|'+'
condition|?
name|TFOLDER
else|:
name|TSUBCWF
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|m_maildir
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|result
operator|=
name|OK
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cwd
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|foldswit
index|[]
init|=
block|{
define|#
directive|define
name|FLALSW
value|0
literal|"all"
block|,
literal|0
block|,
define|#
directive|define
name|FLFASW
value|1
literal|"fast"
block|,
literal|0
block|,
define|#
directive|define
name|FLNFASW
value|2
literal|"nofast"
block|,
literal|0
block|,
define|#
directive|define
name|FLHDSW
value|3
literal|"header"
block|,
literal|0
block|,
define|#
directive|define
name|FLNHDSW
value|4
literal|"noheader"
block|,
literal|0
block|,
define|#
directive|define
name|FLPKSW
value|5
literal|"pack"
block|,
literal|0
block|,
define|#
directive|define
name|FLNPKSW
value|6
literal|"nopack"
block|,
literal|0
block|,
define|#
directive|define
name|FLRCSW
value|7
literal|"recurse"
block|,
literal|0
block|,
define|#
directive|define
name|FLNRCSW
value|8
literal|"norecurse"
block|,
literal|0
block|,
define|#
directive|define
name|FLTLSW
value|9
literal|"total"
block|,
literal|0
block|,
define|#
directive|define
name|FLNTLSW
value|10
literal|"nototal"
block|,
literal|0
block|,
define|#
directive|define
name|FLPRSW
value|11
literal|"print"
block|,
literal|0
block|,
define|#
directive|define
name|FLPUSW
value|12
literal|"push"
block|,
literal|0
block|,
define|#
directive|define
name|FLPOSW
value|13
literal|"pop"
block|,
literal|0
block|,
define|#
directive|define
name|FLLISW
value|14
literal|"list"
block|,
literal|0
block|,
define|#
directive|define
name|FLHELP
value|15
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|foldcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fastsw
init|=
literal|0
decl_stmt|,
name|headersw
init|=
literal|0
decl_stmt|,
name|packsw
init|=
literal|0
decl_stmt|,
name|hole
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|folder
init|=
name|NULL
decl_stmt|,
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
modifier|*
name|vec
init|=
name|args
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
goto|goto
name|fast
goto|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|foldswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|foldswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|FLHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [+folder] [msg] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|foldswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|FLALSW
case|:
comment|/* not implemented */
case|case
name|FLRCSW
case|:
case|case
name|FLNRCSW
case|:
case|case
name|FLTLSW
case|:
case|case
name|FLNTLSW
case|:
case|case
name|FLPRSW
case|:
case|case
name|FLPUSW
case|:
case|case
name|FLPOSW
case|:
case|case
name|FLLISW
case|:
continue|continue;
case|case
name|FLFASW
case|:
name|fastsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|FLNFASW
case|:
name|fastsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|FLHDSW
case|:
name|headersw
operator|++
expr_stmt|;
continue|continue;
case|case
name|FLNHDSW
case|:
name|headersw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|FLPKSW
case|:
name|packsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|FLNPKSW
case|:
name|packsw
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
if|if
condition|(
name|folder
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one folder at a time!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|folder
operator|=
name|fmsh
condition|?
name|path
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|*
name|cp
operator|==
literal|'+'
condition|?
name|TFOLDER
else|:
name|TSUBCWF
argument_list|)
else|:
name|cp
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|msg
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one message at a time!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msg
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|folder
condition|)
block|{
if|if
condition|(
operator|*
name|folder
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"null folder names are not permitted"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fmsh
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|m_maildir
argument_list|(
name|folder
argument_list|)
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|folder
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
argument_list|(
name|buf
argument_list|)
operator|==
name|NOTOK
condition|)
return|return;
name|folder
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|folder
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|folder
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|m_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|fmsh
condition|)
name|fsetup
argument_list|(
name|folder
argument_list|)
expr_stmt|;
else|else
name|setup
argument_list|(
name|folder
argument_list|)
expr_stmt|;
name|readids
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|display_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
condition|)
block|{
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|>
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one message at a time!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|packsw
condition|)
block|{
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|vec
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mp
operator|->
name|lowmsg
operator|>
literal|1
operator|&&
operator|(
name|mp
operator|=
name|m_remsg
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|hghmsg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate folder storage"
argument_list|)
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowmsg
operator|,
name|hole
operator|=
literal|1
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghmsg
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|EXISTS
condition|)
block|{
if|if
condition|(
name|msgnum
operator|!=
name|hole
condition|)
block|{
name|Msgs
index|[
name|hole
index|]
operator|.
name|m_bboard_id
operator|=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
expr_stmt|;
name|Msgs
index|[
name|hole
index|]
operator|.
name|m_top
operator|=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_top
expr_stmt|;
name|Msgs
index|[
name|hole
index|]
operator|.
name|m_start
operator|=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_start
expr_stmt|;
name|Msgs
index|[
name|hole
index|]
operator|.
name|m_stop
operator|=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
expr_stmt|;
name|Msgs
index|[
name|hole
index|]
operator|.
name|m_scanl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
condition|)
block|{
name|free
argument_list|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
argument_list|)
expr_stmt|;
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
operator|=
name|NULL
expr_stmt|;
block|}
name|mp
operator|->
name|msgstats
index|[
name|hole
index|]
operator|=
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|curmsg
operator|==
name|msgnum
condition|)
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|hole
argument_list|)
expr_stmt|;
block|}
name|hole
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|nummsg
operator|>
literal|0
condition|)
block|{
name|mp
operator|->
name|lowmsg
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|hghmsg
operator|=
name|hole
operator|-
literal|1
expr_stmt|;
block|}
name|mp
operator|->
name|msgflags
operator||=
name|MODIFIED
expr_stmt|;
name|modified
operator|++
expr_stmt|;
block|}
name|fast
label|:
empty_stmt|;
if|if
condition|(
name|fastsw
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fmsh
condition|?
name|fmsh
else|:
name|mp
operator|->
name|foldpath
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|headersw
condition|)
name|printf
argument_list|(
literal|"\t\tFolder  %*s# of messages (%*srange%*s); cur%*smsg\n"
argument_list|,
name|DMAXFOLDER
argument_list|,
literal|""
argument_list|,
name|DMAXFOLDER
operator|-
literal|2
argument_list|,
literal|""
argument_list|,
name|DMAXFOLDER
operator|-
literal|2
argument_list|,
literal|""
argument_list|,
name|DMAXFOLDER
operator|-
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|args
condition|?
literal|"%22s  "
else|:
literal|"%s "
argument_list|,
name|fmsh
condition|?
name|fmsh
else|:
name|mp
operator|->
name|foldpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|hghmsg
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"has   no messages%*s"
argument_list|,
name|mp
operator|->
name|msgflags
operator|&
name|OTHERS
condition|?
name|DMAXFOLDER
operator|*
literal|2
operator|+
literal|4
else|:
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"has %*d message%s (%*d-%*d)"
argument_list|,
name|DMAXFOLDER
argument_list|,
name|mp
operator|->
name|nummsg
argument_list|,
name|mp
operator|->
name|nummsg
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|DMAXFOLDER
argument_list|,
name|mp
operator|->
name|lowmsg
argument_list|,
name|DMAXFOLDER
argument_list|,
name|mp
operator|->
name|hghmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|curmsg
operator|>=
name|mp
operator|->
name|lowmsg
operator|&&
name|mp
operator|->
name|curmsg
operator|<=
name|mp
operator|->
name|hghmsg
condition|)
name|printf
argument_list|(
literal|"; cur=%*d"
argument_list|,
name|DMAXFOLDER
argument_list|,
name|mp
operator|->
name|curmsg
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|forwswit
index|[]
init|=
block|{
define|#
directive|define
name|FOANSW
value|0
literal|"annotate"
block|,
literal|0
block|,
define|#
directive|define
name|FONANSW
value|1
literal|"noannotate"
block|,
literal|0
block|,
define|#
directive|define
name|FODFSW
value|2
literal|"draftfolder +folder"
block|,
literal|0
block|,
define|#
directive|define
name|FODMSW
value|3
literal|"draftmessage msg"
block|,
literal|0
block|,
define|#
directive|define
name|FONDFSW
value|4
literal|"nodraftfolder"
block|,
literal|0
block|,
define|#
directive|define
name|FOEDTSW
value|5
literal|"editor editor"
block|,
literal|0
block|,
define|#
directive|define
name|FONEDSW
value|6
literal|"noedit"
block|,
literal|0
block|,
define|#
directive|define
name|FOFTRSW
value|7
literal|"filter filterfile"
block|,
literal|0
block|,
define|#
directive|define
name|FOFRMSW
value|8
literal|"form formfile"
block|,
literal|0
block|,
define|#
directive|define
name|FOFTSW
value|9
literal|"format"
block|,
literal|5
block|,
define|#
directive|define
name|FONFTSW
value|10
literal|"noformat"
block|,
literal|7
block|,
define|#
directive|define
name|FOINSW
value|11
literal|"inplace"
block|,
literal|0
block|,
define|#
directive|define
name|FONINSW
value|12
literal|"noinplace"
block|,
literal|0
block|,
define|#
directive|define
name|FOWHTSW
value|13
literal|"whatnowproc program"
block|,
literal|0
block|,
define|#
directive|define
name|FONWTSW
value|14
literal|"nowhatnow"
block|,
literal|0
block|,
define|#
directive|define
name|FOHELP
value|15
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|forwcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|msgp
init|=
literal|0
decl_stmt|,
name|vecp
init|=
literal|1
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|filter
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|args
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|forwswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|forwswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|FOHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|forwswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|FOANSW
case|:
comment|/* not implemented */
case|case
name|FONANSW
case|:
case|case
name|FOINSW
case|:
case|case
name|FONINSW
case|:
continue|continue;
case|case
name|FONDFSW
case|:
case|case
name|FONEDSW
case|:
case|case
name|FONWTSW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
continue|continue;
case|case
name|FOEDTSW
case|:
case|case
name|FOFRMSW
case|:
case|case
name|FODFSW
case|:
case|case
name|FODMSW
case|:
case|case
name|FOWHTSW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
continue|continue;
case|case
name|FOFTRSW
case|:
if|if
condition|(
operator|!
operator|(
name|filter
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|filter
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
case|case
name|FOFTSW
case|:
if|if
condition|(
name|access
argument_list|(
name|filter
operator|=
name|myfilter
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|filter
argument_list|,
literal|"unable to read default filter file"
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
case|case
name|FONFTSW
case|:
name|filter
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
comment|/* foil search of .mh_profile */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%sXXXXXX"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|mktemp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-file"
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"cur"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
argument_list|(
name|buf
argument_list|)
operator|==
name|NOTOK
condition|)
return|return;
if|if
condition|(
name|access
argument_list|(
name|filter
operator|=
name|getcpy
argument_list|(
name|libpath
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|filter
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filter
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|forw
argument_list|(
name|cmd_name
argument_list|,
name|filter
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
condition|)
name|free
argument_list|(
name|filter
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|forw
argument_list|(
argument|proc
argument_list|,
argument|filter
argument_list|,
argument|vecp
argument_list|,
argument|vec
argument_list|)
name|int
name|vecp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|proc
decl_stmt|,
modifier|*
name|filter
decl_stmt|,
modifier|*
modifier|*
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|child_id
decl_stmt|,
name|msgnum
decl_stmt|,
name|msgcnt
decl_stmt|;
name|char
name|tmpfil
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|args
index|[
name|MAXARGS
index|]
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
name|interrupted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filter
condition|)
switch|switch
condition|(
name|child_id
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OK
case|:
comment|/* "trust me" */
if|if
condition|(
name|freopen
argument_list|(
name|tmpfil
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to create "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|args
index|[
literal|0
index|]
operator|=
name|r1bindex
argument_list|(
name|mhlproc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-forwall"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|"-form"
expr_stmt|;
name|args
index|[
name|i
operator|++
index|]
operator|=
name|filter
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
name|args
index|[
name|i
operator|++
index|]
operator|=
name|getcpy
argument_list|(
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|mhlsbr
argument_list|(
name|i
argument_list|,
name|args
argument_list|,
name|mhl_action
argument_list|)
expr_stmt|;
name|m_eomsbr
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
condition|)
name|interrupted
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|tmpfil
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to create temporary file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|msgcnt
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
operator|&&
operator|!
name|interrupted
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\n-------"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgnum
operator|==
name|mp
operator|->
name|lowsel
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" Forwarded Message%s"
argument_list|,
name|mp
operator|->
name|numsel
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" Message %d"
argument_list|,
name|msgcnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|copy_digest
argument_list|(
name|msgnum
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|msgcnt
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\n------- End of Forwarded Message%s\n"
argument_list|,
name|mp
operator|->
name|numsel
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interrupted
condition|)
switch|switch
condition|(
name|child_id
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OK
case|:
name|closefds
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|tmpfil
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
name|execvp
argument_list|(
name|proc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hlpmsg
index|[]
init|=
block|{
literal|"The %s program emulates many of the commands found in the Rand MH"
block|,
literal|"system.  Instead of operating on MH folders, commands to %s concern"
block|,
literal|"a single file."
block|,
literal|""
block|,
literal|"To see the list of commands available, just type a ``?'' followed by"
block|,
literal|"the RETURN key.  To find out what switches each command takes, type"
block|,
literal|"the name of the command followed by ``-help''.  To leave %s, use the"
block|,
literal|"``quit'' command."
block|,
literal|""
block|,
literal|"Although a lot of MH commands are found in %s, not all are fully"
block|,
literal|"implemented.  %s will always recognize all legal switches for a"
block|,
literal|"given command though, and will let you know when you ask for an"
block|,
literal|"option that it is unable to perform."
block|,
literal|""
block|,
literal|"Running %s is fun, but using MH from your shell is far superior."
block|,
literal|"After you have familiarized yourself with the MH style by using %s,"
block|,
literal|"you should try using MH from the shell.  You can still use %s for"
block|,
literal|"message files that aren't in MH format, such as BBoard files."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|helpcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hlpmsg
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
name|hlpmsg
index|[
name|i
index|]
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|markswit
index|[]
init|=
block|{
define|#
directive|define
name|MADDSW
value|0
literal|"add"
block|,
literal|0
block|,
define|#
directive|define
name|MDELSW
value|1
literal|"delete"
block|,
literal|0
block|,
define|#
directive|define
name|MLSTSW
value|2
literal|"list"
block|,
literal|0
block|,
define|#
directive|define
name|MSEQSW
value|3
literal|"sequence name"
block|,
literal|0
block|,
define|#
directive|define
name|MPUBSW
value|4
literal|"public"
block|,
literal|0
block|,
define|#
directive|define
name|MNPUBSW
value|5
literal|"nopublic"
block|,
literal|0
block|,
define|#
directive|define
name|MZERSW
value|6
literal|"zero"
block|,
literal|0
block|,
define|#
directive|define
name|MNZERSW
value|7
literal|"nozero"
block|,
literal|0
block|,
define|#
directive|define
name|MHELP
value|8
literal|"help"
block|,
literal|4
block|,
define|#
directive|define
name|MDBUGSW
value|9
literal|"debug"
block|,
operator|-
literal|5
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|markcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|addsw
init|=
literal|0
decl_stmt|,
name|deletesw
init|=
literal|0
decl_stmt|,
name|debugsw
init|=
literal|0
decl_stmt|,
name|listsw
init|=
literal|0
decl_stmt|,
name|zerosw
init|=
literal|0
decl_stmt|,
name|seqp
init|=
literal|0
decl_stmt|,
name|msgp
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|seqs
index|[
name|NATTRS
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|markswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|markswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|MHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|markswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|MADDSW
case|:
name|addsw
operator|++
expr_stmt|;
name|deletesw
operator|=
name|listsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|MDELSW
case|:
name|deletesw
operator|++
expr_stmt|;
name|addsw
operator|=
name|listsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|MLSTSW
case|:
name|listsw
operator|++
expr_stmt|;
name|addsw
operator|=
name|deletesw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|MSEQSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seqp
operator|<
name|NATTRS
condition|)
name|seqs
index|[
name|seqp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
else|else
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only %d sequences allowed!"
argument_list|,
name|NATTRS
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
case|case
name|MPUBSW
case|:
comment|/* not implemented */
case|case
name|MNPUBSW
case|:
continue|continue;
case|case
name|MDBUGSW
case|:
name|debugsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|MZERSW
case|:
name|zerosw
operator|++
expr_stmt|;
continue|continue;
case|case
name|MNZERSW
case|:
name|zerosw
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addsw
operator|&&
operator|!
name|deletesw
operator|&&
operator|!
name|listsw
condition|)
if|if
condition|(
name|seqp
condition|)
name|addsw
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|debugsw
condition|)
name|listsw
operator|++
expr_stmt|;
else|else
block|{
name|seqs
index|[
name|seqp
operator|++
index|]
operator|=
literal|"unseen"
expr_stmt|;
name|deletesw
operator|++
expr_stmt|;
name|zerosw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"all"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|listsw
condition|?
literal|"all"
else|:
literal|"cur"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
if|if
condition|(
name|debugsw
condition|)
block|{
name|printf
argument_list|(
literal|"invo_name=%s mypath=%s defpath=%s\n"
argument_list|,
name|invo_name
argument_list|,
name|mypath
argument_list|,
name|defpath
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ctxpath=%s context flags=%s\n"
argument_list|,
name|ctxpath
argument_list|,
name|sprintb
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|ctxflags
argument_list|,
name|DBITS
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"foldpath=%s flags=%s\n"
argument_list|,
name|mp
operator|->
name|foldpath
argument_list|,
name|sprintb
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|mp
operator|->
name|msgflags
argument_list|,
name|FBITS
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hghmsg=%d lowmsg=%d nummsg=%d curmsg=%d\n"
argument_list|,
name|mp
operator|->
name|hghmsg
argument_list|,
name|mp
operator|->
name|lowmsg
argument_list|,
name|mp
operator|->
name|nummsg
argument_list|,
name|mp
operator|->
name|curmsg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lowsel=%d hghsel=%d numsel=%d\n"
argument_list|,
name|mp
operator|->
name|lowsel
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|,
name|mp
operator|->
name|numsel
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MTR
name|printf
argument_list|(
literal|"lowoff=%d hghoff=%d\n"
argument_list|,
name|mp
operator|->
name|lowoff
argument_list|,
name|mp
operator|->
name|hghoff
argument_list|)
expr_stmt|;
else|#
directive|else
else|MTR
name|printf
argument_list|(
literal|"lowoff=%d hghoff=%d msgbase=0x%x msgstats=0x%x\n"
argument_list|,
name|mp
operator|->
name|lowoff
argument_list|,
name|mp
operator|->
name|hghoff
argument_list|,
name|mp
operator|->
name|msgbase
argument_list|,
name|mp
operator|->
name|msgstats
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MTR
block|}
if|if
condition|(
name|seqp
operator|==
literal|0
operator|&&
operator|(
name|addsw
operator|||
name|deletesw
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s requires at least one -sequence argument"
argument_list|,
name|addsw
condition|?
literal|"add"
else|:
literal|"delete"
argument_list|)
expr_stmt|;
return|return;
block|}
name|seqs
index|[
name|seqp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|addsw
condition|)
for|for
control|(
name|seqp
operator|=
literal|0
init|;
name|seqs
index|[
name|seqp
index|]
condition|;
name|seqp
operator|++
control|)
block|{
if|if
condition|(
name|zerosw
operator|&&
operator|!
name|m_seqnew
argument_list|(
name|mp
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
if|if
condition|(
operator|!
name|m_seqadd
argument_list|(
name|mp
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|deletesw
condition|)
for|for
control|(
name|seqp
operator|=
literal|0
init|;
name|seqs
index|[
name|seqp
index|]
condition|;
name|seqp
operator|++
control|)
block|{
if|if
condition|(
name|zerosw
condition|)
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowmsg
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghmsg
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|EXISTS
condition|)
if|if
condition|(
operator|!
name|m_seqadd
argument_list|(
name|mp
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
if|if
condition|(
operator|!
name|m_seqdel
argument_list|(
name|mp
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|,
name|msgnum
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|listsw
condition|)
block|{
name|int
name|bits
init|=
name|FFATTRSLOT
decl_stmt|;
if|if
condition|(
name|seqp
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mp
operator|->
name|msgattrs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s%s: %s\n"
argument_list|,
name|mp
operator|->
name|msgattrs
index|[
name|i
index|]
argument_list|,
name|mp
operator|->
name|attrstats
operator|&
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|+
name|i
operator|)
operator|)
condition|?
literal|" (private)"
else|:
literal|""
argument_list|,
name|m_seq
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|msgattrs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|seqp
operator|=
literal|0
init|;
name|seqs
index|[
name|seqp
index|]
condition|;
name|seqp
operator|++
control|)
name|printf
argument_list|(
literal|"%s%s: %s\n"
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|,
name|m_seq
argument_list|(
name|mp
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|interrupted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
operator|&&
operator|!
name|interrupted
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
name|printf
argument_list|(
literal|"%*d: id=%d top=%d start=%ld stop=%ld %s\n"
argument_list|,
name|DMAXFOLDER
argument_list|,
name|msgnum
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_top
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_start
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
argument_list|,
name|sprintb
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
argument_list|,
name|m_seqbits
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|packswit
index|[]
init|=
block|{
define|#
directive|define
name|PAFISW
value|0
literal|"file name"
block|,
literal|0
block|,
define|#
directive|define
name|PAHELP
value|1
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|packcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|msgp
init|=
literal|0
decl_stmt|,
name|md
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|file
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|args
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|packswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|packswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|PAHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|packswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|PAFISW
case|:
if|if
condition|(
operator|!
operator|(
name|file
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|file
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
condition|)
name|file
operator|=
literal|"./msgbox"
expr_stmt|;
name|file
operator|=
name|path
argument_list|(
name|file
argument_list|,
name|TFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|advise
argument_list|(
name|file
argument_list|,
literal|"error on file"
argument_list|)
expr_stmt|;
goto|goto
name|done_pack
goto|;
block|}
name|md
operator|=
name|getanswer
argument_list|(
name|cp
operator|=
name|concat
argument_list|(
literal|"Create file \""
argument_list|,
name|file
argument_list|,
literal|"\"? "
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
goto|goto
name|done_pack
goto|;
block|}
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"all"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
goto|goto
name|done_pack
goto|;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|mbx_open
argument_list|(
name|file
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|m_gmprot
argument_list|()
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|file
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
goto|goto
name|done_pack
goto|;
block|}
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
if|if
condition|(
name|pack
argument_list|(
name|file
argument_list|,
name|md
argument_list|,
name|msgnum
argument_list|)
operator|==
name|NOTOK
condition|)
break|break;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|hghsel
operator|!=
name|mp
operator|->
name|curmsg
condition|)
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|lowsel
argument_list|)
expr_stmt|;
name|done_pack
label|:
empty_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|pack
parameter_list|(
name|mailbox
parameter_list|,
name|md
parameter_list|,
name|msgnum
parameter_list|)
name|char
modifier|*
name|mailbox
decl_stmt|;
name|int
name|md
decl_stmt|,
name|msgnum
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|zp
decl_stmt|;
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|readid
argument_list|(
name|msgnum
argument_list|)
expr_stmt|;
name|zp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|mbx_write
argument_list|(
name|mailbox
argument_list|,
name|md
argument_list|,
name|zp
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
argument_list|,
name|ftell
argument_list|(
name|zp
argument_list|)
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|packhak
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|packswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
case|case
name|UNKWNSW
case|:
case|case
name|PAHELP
case|:
return|return
name|NOTOK
return|;
case|case
name|PAFISW
case|:
if|if
condition|(
operator|!
operator|(
name|file
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|file
operator|==
literal|'-'
condition|)
return|return
name|NOTOK
return|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
return|return
name|NOTOK
return|;
block|}
name|file
operator|=
name|path
argument_list|(
name|file
condition|?
name|file
else|:
literal|"./msgbox"
argument_list|,
name|TFILE
argument_list|)
expr_stmt|;
name|result
operator|=
name|access
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|?
name|OK
else|:
name|NOTOK
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|pickswit
index|[]
init|=
block|{
define|#
directive|define
name|PIANSW
value|0
literal|"and"
block|,
literal|0
block|,
define|#
directive|define
name|PIORSW
value|1
literal|"or"
block|,
literal|0
block|,
define|#
directive|define
name|PINTSW
value|2
literal|"not"
block|,
literal|0
block|,
define|#
directive|define
name|PILBSW
value|3
literal|"lbrace"
block|,
literal|0
block|,
define|#
directive|define
name|PIRBSW
value|4
literal|"rbrace"
block|,
literal|0
block|,
define|#
directive|define
name|PICCSW
value|5
literal|"cc  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PIDASW
value|6
literal|"date  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PIFRSW
value|7
literal|"from  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PISESW
value|8
literal|"search  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PISUSW
value|9
literal|"subject  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PITOSW
value|10
literal|"to  pattern"
block|,
literal|0
block|,
define|#
directive|define
name|PIOTSW
value|11
literal|"-othercomponent  pattern"
block|,
literal|15
block|,
define|#
directive|define
name|PIAFSW
value|12
literal|"after date"
block|,
literal|0
block|,
define|#
directive|define
name|PIBFSW
value|13
literal|"before date"
block|,
literal|0
block|,
define|#
directive|define
name|PIDFSW
value|14
literal|"datefield field"
block|,
literal|5
block|,
define|#
directive|define
name|PISQSW
value|15
literal|"sequence name"
block|,
literal|0
block|,
define|#
directive|define
name|PIPUSW
value|16
literal|"public"
block|,
literal|0
block|,
define|#
directive|define
name|PINPUSW
value|17
literal|"nopublic"
block|,
literal|0
block|,
define|#
directive|define
name|PIZRSW
value|18
literal|"zero"
block|,
literal|0
block|,
define|#
directive|define
name|PINZRSW
value|19
literal|"nozero"
block|,
literal|0
block|,
define|#
directive|define
name|PILISW
value|20
literal|"list"
block|,
literal|0
block|,
define|#
directive|define
name|PINLISW
value|21
literal|"nolist"
block|,
literal|0
block|,
define|#
directive|define
name|PIHELP
value|22
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|pickcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|zerosw
init|=
literal|1
decl_stmt|,
name|msgp
init|=
literal|0
decl_stmt|,
name|seqp
init|=
literal|0
decl_stmt|,
name|vecp
init|=
literal|0
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|seqs
index|[
name|NATTRS
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|zp
decl_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|'-'
condition|)
block|{
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
goto|goto
name|pattern
goto|;
block|}
switch|switch
condition|(
name|smatch
argument_list|(
name|cp
argument_list|,
name|pickswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|pickswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|PIHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|pickswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|PICCSW
case|:
case|case
name|PIDASW
case|:
case|case
name|PIFRSW
case|:
case|case
name|PISUSW
case|:
case|case
name|PITOSW
case|:
case|case
name|PIDFSW
case|:
case|case
name|PIAFSW
case|:
case|case
name|PIBFSW
case|:
case|case
name|PISESW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
name|pattern
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
condition|)
block|{
comment|/* allow -xyz arguments */
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
continue|continue;
case|case
name|PIOTSW
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error!"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PIANSW
case|:
case|case
name|PIORSW
case|:
case|case
name|PINTSW
case|:
case|case
name|PILBSW
case|:
case|case
name|PIRBSW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
continue|continue;
case|case
name|PISQSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|seqp
operator|<
name|NATTRS
condition|)
name|seqs
index|[
name|seqp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
else|else
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only %d sequences allowed!"
argument_list|,
name|NATTRS
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
case|case
name|PIZRSW
case|:
name|zerosw
operator|++
expr_stmt|;
continue|continue;
case|case
name|PINZRSW
case|:
name|zerosw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|PIPUSW
case|:
comment|/* not implemented */
case|case
name|PINPUSW
case|:
case|case
name|PILISW
case|:
case|case
name|PINLISW
case|:
continue|continue;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"all"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|interrupted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pcompile
argument_list|(
name|vec
argument_list|,
name|NULLCP
argument_list|)
condition|)
return|return;
name|lo
operator|=
name|mp
operator|->
name|lowsel
expr_stmt|;
name|hi
operator|=
name|mp
operator|->
name|hghsel
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
operator|&&
operator|!
name|interrupted
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
name|zp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmatches
argument_list|(
name|zp
argument_list|,
name|msgnum
argument_list|,
name|fmsh
condition|?
literal|0L
else|:
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_start
argument_list|,
name|fmsh
condition|?
literal|0L
else|:
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
argument_list|)
condition|)
block|{
if|if
condition|(
name|msgnum
operator|<
name|lo
condition|)
name|lo
operator|=
name|msgnum
expr_stmt|;
if|if
condition|(
name|msgnum
operator|>
name|hi
condition|)
name|hi
operator|=
name|msgnum
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&=
operator|~
name|SELECTED
expr_stmt|;
name|mp
operator|->
name|numsel
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interrupted
condition|)
return|return;
name|mp
operator|->
name|lowsel
operator|=
name|lo
expr_stmt|;
name|mp
operator|->
name|hghsel
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|<=
literal|0
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no messages match specification"
argument_list|)
expr_stmt|;
return|return;
block|}
name|seqs
index|[
name|seqp
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|seqp
operator|=
literal|0
init|;
name|seqs
index|[
name|seqp
index|]
condition|;
name|seqp
operator|++
control|)
block|{
if|if
condition|(
name|zerosw
operator|&&
operator|!
name|m_seqnew
argument_list|(
name|mp
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
if|if
condition|(
operator|!
name|m_seqadd
argument_list|(
name|mp
argument_list|,
name|seqs
index|[
name|seqp
index|]
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
name|printf
argument_list|(
literal|"%d hit%s\n"
argument_list|,
name|mp
operator|->
name|numsel
argument_list|,
name|mp
operator|->
name|numsel
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|replswit
index|[]
init|=
block|{
define|#
directive|define
name|REANSW
value|0
literal|"annotate"
block|,
literal|0
block|,
define|#
directive|define
name|RENANSW
value|1
literal|"noannotate"
block|,
literal|0
block|,
define|#
directive|define
name|RECCSW
value|2
literal|"cc type"
block|,
literal|0
block|,
define|#
directive|define
name|RENCCSW
value|3
literal|"nocc type"
block|,
literal|0
block|,
define|#
directive|define
name|REDFSW
value|4
literal|"draftfolder +folder"
block|,
literal|0
block|,
define|#
directive|define
name|REDMSW
value|5
literal|"draftmessage msg"
block|,
literal|0
block|,
define|#
directive|define
name|RENDFSW
value|6
literal|"nodraftfolder"
block|,
literal|0
block|,
define|#
directive|define
name|REEDTSW
value|7
literal|"editor editor"
block|,
literal|0
block|,
define|#
directive|define
name|RENEDSW
value|8
literal|"noedit"
block|,
literal|0
block|,
define|#
directive|define
name|REFCCSW
value|9
literal|"fcc +folder"
block|,
literal|0
block|,
define|#
directive|define
name|REFLTSW
value|10
literal|"filter filterfile"
block|,
literal|0
block|,
define|#
directive|define
name|REFRMSW
value|11
literal|"form formfile"
block|,
literal|0
block|,
define|#
directive|define
name|REFRSW
value|12
literal|"format"
block|,
literal|5
block|,
define|#
directive|define
name|RENFRSW
value|13
literal|"noformat"
block|,
literal|7
block|,
define|#
directive|define
name|REINSW
value|14
literal|"inplace"
block|,
literal|0
block|,
define|#
directive|define
name|RENINSW
value|15
literal|"noinplace"
block|,
literal|0
block|,
define|#
directive|define
name|REQUSW
value|16
literal|"query"
block|,
literal|0
block|,
define|#
directive|define
name|RENQUSW
value|17
literal|"noquery"
block|,
literal|0
block|,
define|#
directive|define
name|REWHTSW
value|18
literal|"whatnowproc program"
block|,
literal|0
block|,
define|#
directive|define
name|RENWTSW
value|19
literal|"nowhatnow"
block|,
literal|0
block|,
define|#
directive|define
name|REWIDSW
value|20
literal|"width columns"
block|,
literal|0
block|,
define|#
directive|define
name|REHELP
value|21
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|replcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|vecp
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|args
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|replswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|replswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|REHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|replswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|REANSW
case|:
comment|/* not implemented */
case|case
name|RENANSW
case|:
case|case
name|REINSW
case|:
case|case
name|RENINSW
case|:
continue|continue;
case|case
name|REFRSW
case|:
case|case
name|RENFRSW
case|:
case|case
name|REQUSW
case|:
case|case
name|RENQUSW
case|:
case|case
name|RENDFSW
case|:
case|case
name|RENEDSW
case|:
case|case
name|RENWTSW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
continue|continue;
case|case
name|RECCSW
case|:
case|case
name|RENCCSW
case|:
case|case
name|REEDTSW
case|:
case|case
name|REFCCSW
case|:
case|case
name|REFLTSW
case|:
case|case
name|REFRMSW
case|:
case|case
name|REWIDSW
case|:
case|case
name|REDFSW
case|:
case|case
name|REDMSW
case|:
case|case
name|REWHTSW
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|msg
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one message at a time!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msg
operator|=
name|cp
expr_stmt|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
name|cmd_name
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-file"
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|msg
operator|=
literal|"cur"
expr_stmt|;
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msg
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|>
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one message at a time!"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|process
argument_list|(
name|mp
operator|->
name|hghsel
argument_list|,
name|cmd_name
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|rmmswit
index|[]
init|=
block|{
define|#
directive|define
name|RMHELP
value|0
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|rmmcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|msgp
init|=
literal|0
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|rmmswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|rmmswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|RMHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|rmmswit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"cur"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|rmm
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|rmm
argument_list|()
block|{
specifier|register
name|int
name|msgnum
block|,
name|vecp
block|;
specifier|register
name|char
operator|*
name|cp
block|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|,
operator|*
name|vec
index|[
name|MAXARGS
index|]
block|;
if|if
condition|(
name|fmsh
condition|)
block|{
if|if
condition|(
name|rmmproc
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|numsel
operator|>
name|MAXARGS
operator|-
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"more than %d messages for %s exec"
argument_list|,
name|MAXARGS
operator|-
literal|1
argument_list|,
name|rmmproc
argument_list|)
expr_stmt|;
return|return;
block|}
name|vecp
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|getcpy
argument_list|(
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|forkcmd
argument_list|(
name|vec
argument_list|,
name|rmmproc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|vecp
operator|=
literal|0
init|;
name|vec
index|[
name|vecp
index|]
condition|;
name|vecp
operator|++
control|)
name|free
argument_list|(
name|vec
index|[
name|vecp
index|]
argument_list|)
expr_stmt|;
end_for

begin_for
unit|} 	else
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|m_backup
argument_list|(
name|cp
operator|=
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|cp
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
condition|)
name|admonish
argument_list|(
name|buffer
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
unit|}      for
operator|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
expr|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
expr|;
name|msgnum
operator|++
operator|)
end_expr_stmt

begin_if
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator||=
name|DELETED
expr_stmt|;
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&=
operator|~
name|EXISTS
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|mp
operator|->
name|nummsg
operator|-=
name|mp
operator|->
name|numsel
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|fmsh
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"no messages remaining in +%s"
argument_list|,
name|fmsh
argument_list|)
expr_stmt|;
else|else
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"no messages remaining in %s"
argument_list|,
name|mp
operator|->
name|foldpath
argument_list|)
expr_stmt|;
name|mp
operator|->
name|lowmsg
operator|=
name|mp
operator|->
name|hghmsg
operator|=
name|mp
operator|->
name|nummsg
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|mp
operator|->
name|lowsel
operator|==
name|mp
operator|->
name|lowmsg
condition|)
block|{
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowmsg
operator|+
literal|1
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghmsg
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|EXISTS
condition|)
break|break;
name|mp
operator|->
name|lowmsg
operator|=
name|msgnum
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|mp
operator|->
name|hghsel
operator|==
name|mp
operator|->
name|hghmsg
condition|)
block|{
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|hghmsg
operator|-
literal|1
init|;
name|msgnum
operator|>=
name|mp
operator|->
name|lowmsg
condition|;
name|msgnum
operator|--
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|EXISTS
condition|)
break|break;
name|mp
operator|->
name|hghmsg
operator|=
name|msgnum
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|mp
operator|->
name|msgflags
operator||=
name|MODIFIED
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|modified
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_decl_stmt
unit|static
name|struct
name|swit
name|scanswit
index|[]
init|=
block|{
define|#
directive|define
name|SCCLR
value|0
literal|"clear"
block|,
literal|0
block|,
define|#
directive|define
name|SCNCLR
value|1
literal|"noclear"
block|,
literal|0
block|,
define|#
directive|define
name|SCFORM
value|2
literal|"form formatfile"
block|,
literal|0
block|,
define|#
directive|define
name|SCFMT
value|3
literal|"format string"
block|,
literal|5
block|,
define|#
directive|define
name|SCHEAD
value|4
literal|"header"
block|,
literal|0
block|,
define|#
directive|define
name|SCNHEAD
value|5
literal|"noheader"
block|,
literal|0
block|,
define|#
directive|define
name|SCWID
value|6
literal|"width columns"
block|,
literal|0
block|,
define|#
directive|define
name|SCHELP
value|7
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|scancmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|equiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a ? b&& !strcmp (a, b) : !b)
name|int
name|clearsw
init|=
literal|0
decl_stmt|,
name|headersw
init|=
literal|0
decl_stmt|,
name|width
init|=
literal|0
decl_stmt|,
name|msgp
init|=
literal|0
decl_stmt|,
name|msgnum
decl_stmt|,
name|optim
decl_stmt|,
name|state
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|form
init|=
name|NULL
decl_stmt|,
modifier|*
name|format
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|nfs
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|zp
decl_stmt|;
specifier|static
name|int
name|s_optim
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|s_form
init|=
name|NULL
decl_stmt|,
modifier|*
name|s_format
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|scanswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|scanswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|scanswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCCLR
case|:
name|clearsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|SCNCLR
case|:
name|clearsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SCHEAD
case|:
name|headersw
operator|++
expr_stmt|;
continue|continue;
case|case
name|SCNHEAD
case|:
name|headersw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SCFORM
case|:
if|if
condition|(
operator|!
operator|(
name|form
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|form
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|SCFMT
case|:
if|if
condition|(
operator|!
operator|(
name|format
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|format
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|form
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|SCWID
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|width
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"all"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|nfs
operator|=
name|new_fs
argument_list|(
name|form
argument_list|,
name|format
argument_list|,
name|FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scanl
condition|)
block|{
comment|/* force scansbr to (re)compile format */
operator|(
name|void
operator|)
name|free
argument_list|(
name|scanl
argument_list|)
expr_stmt|;
name|scanl
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s_optim
operator|==
literal|0
condition|)
block|{
name|s_optim
operator|=
name|optim
operator|=
literal|1
expr_stmt|;
name|s_form
operator|=
name|form
condition|?
name|getcpy
argument_list|(
name|form
argument_list|)
else|:
name|NULL
expr_stmt|;
name|s_format
operator|=
name|format
condition|?
name|getcpy
argument_list|(
name|format
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
else|else
name|optim
operator|=
name|equiv
argument_list|(
name|s_form
argument_list|,
name|form
argument_list|)
operator|&&
name|equiv
argument_list|(
name|s_format
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|interrupted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
operator|&&
operator|!
name|interrupted
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
if|if
condition|(
name|optim
operator|&&
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
argument_list|)
expr_stmt|;
else|else
block|{
name|zp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
operator|=
name|scan
argument_list|(
name|zp
argument_list|,
name|msgnum
argument_list|,
literal|0
argument_list|,
name|nfs
argument_list|,
name|width
argument_list|,
name|msgnum
operator|==
name|mp
operator|->
name|curmsg
argument_list|,
name|headersw
argument_list|,
name|fmsh
condition|?
literal|0L
else|:
call|(
name|long
call|)
argument_list|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
operator|-
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_start
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|SCNMSG
case|:
case|case
name|SCNERR
case|:
if|if
condition|(
name|optim
condition|)
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
operator|=
name|getcpy
argument_list|(
name|scanl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"scan() botch (%d)"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCNEOF
case|:
name|printf
argument_list|(
literal|"%*d  empty\n"
argument_list|,
name|DMAXFOLDER
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|headersw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clearsw
condition|)
name|clear_screen
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|showswit
index|[]
init|=
block|{
define|#
directive|define
name|SHDRAFT
value|0
literal|"draft"
block|,
literal|5
block|,
define|#
directive|define
name|SHFORM
value|1
literal|"form formfile"
block|,
literal|4
block|,
define|#
directive|define
name|SHPROG
value|2
literal|"moreproc program"
block|,
literal|4
block|,
define|#
directive|define
name|SHNPROG
value|3
literal|"nomoreproc"
block|,
literal|3
block|,
define|#
directive|define
name|SHLEN
value|4
literal|"length lines"
block|,
literal|4
block|,
define|#
directive|define
name|SHWID
value|5
literal|"width columns"
block|,
literal|4
block|,
define|#
directive|define
name|SHSHOW
value|6
literal|"showproc program"
block|,
literal|4
block|,
define|#
directive|define
name|SHNSHOW
value|7
literal|"noshowproc"
block|,
literal|3
block|,
define|#
directive|define
name|SHHEAD
value|8
literal|"header"
block|,
literal|4
block|,
define|#
directive|define
name|SHNHEAD
value|9
literal|"noheader"
block|,
literal|3
block|,
define|#
directive|define
name|SHHELP
value|10
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|showcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|headersw
init|=
literal|1
decl_stmt|,
name|nshow
init|=
literal|0
decl_stmt|,
name|msgp
init|=
literal|0
decl_stmt|,
name|vecp
init|=
literal|1
decl_stmt|,
name|mhl
init|=
literal|0
decl_stmt|,
name|seen
init|=
literal|0
decl_stmt|,
name|mode
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|proc
init|=
name|showproc
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|MAXARGS
index|]
decl_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|cmd_name
argument_list|,
literal|"next"
argument_list|)
condition|)
name|mode
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|uleq
argument_list|(
name|cmd_name
argument_list|,
literal|"prev"
argument_list|)
condition|)
name|mode
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|i
operator|=
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|showswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|showswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
case|case
name|SHNPROG
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
continue|continue;
case|case
name|SHHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s[switches] [switches for showproc]"
argument_list|,
name|cmd_name
argument_list|,
name|mode
condition|?
name|NULL
else|:
literal|"[msgs] "
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|showswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHFORM
case|:
case|case
name|SHPROG
case|:
case|case
name|SHLEN
case|:
case|case
name|SHWID
case|:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|--
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
continue|continue;
case|case
name|SHHEAD
case|:
name|headersw
operator|++
expr_stmt|;
continue|continue;
case|case
name|SHNHEAD
case|:
name|headersw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SHSHOW
case|:
if|if
condition|(
operator|!
operator|(
name|proc
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|proc
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|nshow
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SHNSHOW
case|:
name|nshow
operator|++
expr_stmt|;
continue|continue;
case|case
name|SHDRAFT
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, -%s not allowed!"
argument_list|,
name|showswit
index|[
name|i
index|]
operator|.
name|sw
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mode
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [switches] [switches for showproc]\n"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|mode
operator|>
literal|0
condition|?
literal|"next"
else|:
name|mode
operator|<
literal|0
condition|?
literal|"prev"
else|:
literal|"cur"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nshow
condition|)
name|proc
operator|=
literal|"cat"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|showproc
argument_list|,
literal|"mhl"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|proc
operator|=
name|mhlproc
expr_stmt|;
name|mhl
operator|++
expr_stmt|;
block|}
name|seen
operator|=
name|m_seqflag
argument_list|(
name|mp
argument_list|,
literal|"unseen"
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|r1bindex
argument_list|(
name|proc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhl
condition|)
block|{
name|msgp
operator|=
name|vecp
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|getcpy
argument_list|(
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seen
condition|)
operator|(
name|void
operator|)
name|m_seqdel
argument_list|(
name|mp
argument_list|,
literal|"unseen"
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
block|}
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|==
literal|1
operator|&&
name|headersw
condition|)
name|show
argument_list|(
name|mp
operator|->
name|lowsel
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mhlsbr
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|mhl_action
argument_list|)
expr_stmt|;
name|m_eomsbr
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|msgp
operator|<
name|vecp
condition|)
name|free
argument_list|(
name|vec
index|[
name|msgp
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|interrupted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
operator|&&
operator|!
name|interrupted
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
switch|switch
condition|(
name|ask
argument_list|(
name|msgnum
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
comment|/* QUIT */
break|break;
case|case
name|OK
case|:
comment|/* INTR */
continue|continue;
default|default:
if|if
condition|(
name|mp
operator|->
name|numsel
operator|==
literal|1
operator|&&
name|headersw
condition|)
name|show
argument_list|(
name|msgnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|nshow
condition|)
name|copy_message
argument_list|(
name|msgnum
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|process
argument_list|(
name|msgnum
argument_list|,
name|proc
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|seen
condition|)
operator|(
name|void
operator|)
name|m_seqdel
argument_list|(
name|mp
argument_list|,
literal|"unseen"
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|show
argument_list|(
argument|msgnum
argument_list|)
name|int
name|msgnum
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|readid
argument_list|(
name|msgnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(Message %d"
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|", %s: %d"
argument_list|,
name|BBoard_ID
argument_list|,
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_bboard_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|eom_action
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|ftell
argument_list|(
name|mhlfp
argument_list|)
operator|>=
name|Msgs
index|[
name|mhlnum
index|]
operator|.
name|m_stop
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|FP
name|mhl_action
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|msgnum
decl_stmt|;
if|if
condition|(
operator|(
name|msgnum
operator|=
name|m_atoi
argument_list|(
name|name
argument_list|)
operator|)
operator|<
name|mp
operator|->
name|lowmsg
operator|||
name|msgnum
operator|>
name|mp
operator|->
name|hghmsg
operator|||
operator|!
operator|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|EXISTS
operator|)
condition|)
return|return
name|NULL
return|;
name|mhlnum
operator|=
name|msgnum
expr_stmt|;
name|mhlfp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmsh
condition|)
name|m_eomsbr
argument_list|(
name|eom_action
argument_list|)
expr_stmt|;
return|return
name|mhlfp
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|ask
argument_list|(
argument|msgnum
argument_list|)
name|int
name|msgnum
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|==
literal|1
operator|||
operator|!
name|interactive
operator|||
name|redirected
condition|)
return|return
name|DONE
return|;
if|if
condition|(
name|SOprintf
argument_list|(
literal|"Press<return> to list \"%d\"..."
argument_list|,
name|msgnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|lowsel
operator|!=
name|msgnum
condition|)
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Press<return> to list \"%d\"..."
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
else|BSD42
switch|switch
condition|(
name|setjmp
argument_list|(
name|sigenv
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
name|should_intr
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
comment|/* fall... */
default|default:
name|should_intr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
endif|BSD42
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|told_to_quit
condition|)
block|{
name|told_to_quit
operator|=
name|interrupted
operator|=
literal|0
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|interrupted
condition|)
block|{
name|interrupted
operator|=
literal|0
expr_stmt|;
return|return
name|OK
return|;
block|}
return|return
name|DONE
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|sortswit
index|[]
init|=
block|{
define|#
directive|define
name|SODATE
value|0
literal|"datefield field"
block|,
literal|0
block|,
define|#
directive|define
name|SOVERB
value|1
literal|"verbose"
block|,
literal|0
block|,
define|#
directive|define
name|SONVERB
value|2
literal|"noverbose"
block|,
literal|0
block|,
define|#
directive|define
name|SOHELP
value|3
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|sortcmd
argument_list|(
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|msgp
init|=
literal|0
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|datesw
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|;
name|struct
name|tws
name|tb
decl_stmt|,
modifier|*
name|tw
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
name|forkcmd
argument_list|(
name|args
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|args
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|sortswit
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|sortswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNKWNSW
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-%s unknown\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|SOHELP
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [msgs] [switches]"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|sortswit
argument_list|)
expr_stmt|;
return|return;
case|case
name|SODATE
case|:
if|if
condition|(
name|datesw
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"only one date field at a time!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|datesw
operator|=
operator|*
name|args
operator|++
operator|)
operator|||
operator|*
name|datesw
operator|==
literal|'-'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|args
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
case|case
name|SOVERB
case|:
comment|/* not implemented */
case|case
name|SONVERB
case|:
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, no folders allowed!"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"all"
expr_stmt|;
if|if
condition|(
operator|!
name|datesw
condition|)
name|datesw
operator|=
literal|"Date"
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
return|return;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|twscopy
argument_list|(
operator|&
name|tb
argument_list|,
name|dtwstime
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
block|{
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
condition|)
block|{
name|free
argument_list|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
argument_list|)
expr_stmt|;
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_scanl
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
if|if
condition|(
operator|(
name|tw
operator|=
name|getws
argument_list|(
name|datesw
argument_list|,
name|msgnum
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tw
operator|=
name|msgnum
operator|!=
name|mp
operator|->
name|lowsel
condition|?
operator|&
name|Msgs
index|[
name|msgnum
operator|-
literal|1
index|]
operator|.
name|m_tb
else|:
operator|&
name|tb
expr_stmt|;
block|}
else|else
name|tw
operator|=
operator|&
name|tb
expr_stmt|;
name|twscopy
argument_list|(
operator|&
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_tb
argument_list|,
name|tw
argument_list|)
expr_stmt|;
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stats
operator|=
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|curmsg
operator|==
name|msgnum
condition|)
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stats
operator||=
name|CUR
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Msgs
index|[
name|mp
operator|->
name|lowsel
index|]
argument_list|,
name|mp
operator|->
name|hghsel
operator|-
name|mp
operator|->
name|lowsel
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Msg
argument_list|)
argument_list|,
name|msgsort
argument_list|)
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
block|{
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|=
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stats
operator|&
operator|~
name|CUR
expr_stmt|;
if|if
condition|(
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stats
operator|&
name|CUR
condition|)
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|msgflags
operator||=
name|MODIFIED
expr_stmt|;
name|modified
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|tws
modifier|*
name|getws
parameter_list|(
name|datesw
parameter_list|,
name|msgnum
parameter_list|)
name|char
modifier|*
name|datesw
decl_stmt|;
name|int
name|msgnum
decl_stmt|;
block|{
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
name|struct
name|tws
modifier|*
name|tw
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|state
operator|=
name|FLD
init|;
condition|;
control|)
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|zp
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDEOF
case|:
case|case
name|FLDPLUS
case|:
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|datesw
argument_list|)
condition|)
block|{
name|bp
operator|=
name|getcpy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tw
operator|=
name|dparsetime
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to parse %s field in message %d"
argument_list|,
name|datesw
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|tw
return|;
block|}
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|FLDEOF
condition|)
continue|continue;
case|case
name|BODY
case|:
case|case
name|BODYEOF
case|:
case|case
name|FILEEOF
case|:
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"no %s field in message %d"
argument_list|,
name|datesw
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"format error in message %d"
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error -- you lose"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|msgsort
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|Msg
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
name|twsort
argument_list|(
operator|&
name|a
operator|->
name|m_tb
argument_list|,
operator|&
name|b
operator|->
name|m_tb
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|process
parameter_list|(
name|msgnum
parameter_list|,
name|proc
parameter_list|,
name|vecp
parameter_list|,
name|vec
parameter_list|)
name|int
name|msgnum
decl_stmt|,
name|vecp
decl_stmt|;
name|char
modifier|*
name|proc
decl_stmt|,
decl|*
modifier|*
name|vec
decl_stmt|;
end_function

begin_block
block|{
name|int
name|child_id
decl_stmt|,
name|status
decl_stmt|;
name|char
name|tmpfil
index|[
literal|80
index|]
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_delete
argument_list|(
name|pfolder
argument_list|)
expr_stmt|;
name|m_replace
argument_list|(
name|pfolder
argument_list|,
name|fmsh
argument_list|)
expr_stmt|;
name|m_sync
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|m_update
argument_list|()
expr_stmt|;
goto|goto
name|ready
goto|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_scratch
argument_list|(
literal|""
argument_list|,
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|tmpfil
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|olderr
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|char
name|newfil
index|[
literal|80
index|]
decl_stmt|;
name|olderr
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newfil
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|newfil
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|olderr
expr_stmt|;
name|advise
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to create temporary file"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|newfil
argument_list|)
expr_stmt|;
block|}
name|copy_message
argument_list|(
name|msgnum
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|ready
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
name|status
operator|=
name|NOTOK
expr_stmt|;
break|break;
case|case
name|OK
case|:
name|closefds
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|tmpfil
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
name|execvp
argument_list|(
name|proc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
name|status
operator|=
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|fmsh
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|copy_message
argument_list|(
argument|msgnum
argument_list|,
argument|out
argument_list|)
name|int
name|msgnum
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|pos
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmsh
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|zp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
operator|&&
name|out
operator|==
name|stdout
condition|)
break|break;
block|}
block|}
else|else
block|{
name|pos
operator|=
name|ftell
argument_list|(
name|zp
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|zp
argument_list|)
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
condition|)
block|{
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
operator|&&
name|out
operator|==
name|stdout
condition|)
break|break;
block|}
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|copy_digest
argument_list|(
argument|msgnum
argument_list|,
argument|out
argument_list|)
name|int
name|msgnum
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
name|long
name|pos
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|zp
decl_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
name|zp
operator|=
name|msh_ready
argument_list|(
name|msgnum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmsh
condition|)
name|pos
operator|=
name|ftell
argument_list|(
name|zp
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|zp
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|fmsh
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|msgnum
index|]
operator|.
name|m_stop
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
operator|*
name|buffer
operator|==
literal|'-'
condition|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|c
operator|=
name|buffer
index|[
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fmsh
condition|)
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
operator|&&
name|out
operator|==
name|stdout
condition|)
break|break;
block|}
block|}
end_block

end_unit

