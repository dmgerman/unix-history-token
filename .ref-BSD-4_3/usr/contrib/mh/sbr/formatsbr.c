begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* formatsbr.c - format string interpretation */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|"../h/fmtcompile.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|NFMTS
value|MAXARGS
end_define

begin_define
define|#
directive|define
name|QUOTE
value|'\\'
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|formats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|formataddr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* hook for custom address formatting */
end_comment

begin_decl_stmt
name|int
name|fmt_norm
init|=
name|AD_NAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mailname
name|fmt_mnull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* MAJOR HACK:	See MHCHANGES for discussion */
end_comment

begin_function
name|char
modifier|*
name|new_fs
parameter_list|(
name|form
parameter_list|,
name|format
parameter_list|,
name|def
parameter_list|)
specifier|register
name|char
modifier|*
name|form
decl_stmt|,
decl|*
name|format
decl_stmt|,
modifier|*
name|def
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|formats
condition|)
name|free
argument_list|(
name|formats
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|libpath
argument_list|(
name|form
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"unable to open format file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"unable to stat format file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|formats
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|st
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"unable to allocate space for format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|formats
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|!=
name|st
operator|.
name|st_size
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"error reading format file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|formats
operator|=
name|getcpy
argument_list|(
name|format
condition|?
name|format
else|:
name|def
argument_list|)
expr_stmt|;
block|}
name|normalize
argument_list|(
name|formats
argument_list|)
expr_stmt|;
return|return
name|formats
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|normalize
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|!=
name|QUOTE
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
else|else
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
define|#
directive|define
name|grot
parameter_list|(
name|x
parameter_list|)
value|case 'x': *dp++ = '\x'; break;
name|grot
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|grot
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|grot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|grot
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|grot
argument_list|(
name|t
argument_list|)
expr_stmt|;
case|case
literal|'\n'
case|:
break|break;
case|case
name|NULL
case|:
name|cp
operator|--
expr_stmt|;
comment|/* fall */
default|default:
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
operator|*
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * test if string "sub" appears anywhere in string "str"  * (case insensitive).  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|str
parameter_list|,
name|sub
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|sub
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|;
specifier|register
name|int
name|c2
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
specifier|register
name|char
modifier|*
name|s2
decl_stmt|;
while|while
condition|(
name|c1
operator|=
operator|*
name|sub
condition|)
block|{
while|while
condition|(
operator|(
name|c2
operator|=
operator|*
name|str
operator|++
operator|)
operator|&&
operator|(
name|c1
operator||
literal|040
operator|)
operator|!=
operator|(
name|c2
operator||
literal|040
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|c2
condition|)
return|return
literal|0
return|;
name|s1
operator|=
name|sub
operator|+
literal|1
expr_stmt|;
name|s2
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|c1
operator|=
operator|*
name|s1
operator|++
operator|)
operator|&&
operator|(
name|c1
operator||
literal|040
operator|)
operator|==
operator|(
operator|*
name|s2
operator|++
operator||
literal|040
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|c1
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* macros to format data */
end_comment

begin_define
define|#
directive|define
name|PUTDF
parameter_list|(
name|cp
parameter_list|,
name|num
parameter_list|,
name|wid
parameter_list|,
name|fill
parameter_list|)
value|if (cp + wid< ep){\ 		if((i = (num))<0) i = -(num);\ 		sp = cp + wid;\ 		do {\ 		    *--sp = (i % 10) + '0';\ 		    i /= 10;\ 		} while (i> 0&& sp> cp);\ 		if (i> 0)\ 		    *sp = '?';\ 		else if ((num)< 0&& sp> cp)\ 		    *--sp = '-';\ 		while (sp> cp)\ 		    *--sp = fill;\ 		cp += wid;\ 		}
end_define

begin_define
define|#
directive|define
name|PUTD
parameter_list|(
name|cp
parameter_list|,
name|num
parameter_list|)
value|if (cp< ep){\ 		if((i = (num))==0) *cp++ = '0';\ 		else {\ 		    if((i = (num))<0) \ 			*cp++ = '-', i = -(num);\ 		    c = 10;\ 		    while (c<= i) \ 			c *= 10;\ 		    while (cp< ep&& c> 1) {\ 			c /= 10;\ 			*cp++ = (i / c) + '0';\ 			i %= c;\ 			}\ 		    }\ 		}
end_define

begin_define
define|#
directive|define
name|PUTSF
parameter_list|(
name|cp
parameter_list|,
name|str
parameter_list|,
name|wid
parameter_list|,
name|fill
parameter_list|)
value|{\ 		i = (wid);\ 		if (sp = (str)) {\ 		    while ((c = *sp)&& c<= 32)\ 			sp++;\ 		    while( (c = *sp++)&& --i>= 0&& cp< ep)\ 			if ( c> 32 ) \ 			    *cp++ = c;\ 			else {\ 			    while ( (c = *sp)&& c<= 32 )\ 				sp++;\ 			    *cp++ = ' ';\ 			}\ 		}\ 		while( --i>= 0&& cp< ep)\ 		    *cp++ = fill;\ 		}
end_define

begin_define
define|#
directive|define
name|PUTS
parameter_list|(
name|cp
parameter_list|,
name|str
parameter_list|)
value|{\ 		if (sp = (str)) {\ 		    while ((c = *sp)&& c<= 32)\ 			sp++;\ 		    while( (c = *sp++)&& cp< ep)\ 			if ( c> 32 ) \ 			    *cp++ = c;\ 			else {\ 			    while ( (c = *sp)&& c<= 32 )\ 				sp++;\ 			    *cp++ = ' ';\ 			}\ 		}\ 		}
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lmonth
index|[]
init|=
block|{
literal|"January"
block|,
literal|"February"
block|,
literal|"March"
block|,
literal|"April"
block|,
literal|"May"
block|,
literal|"June"
block|,
literal|"July"
block|,
literal|"August"
block|,
literal|"September"
block|,
literal|"October"
block|,
literal|"November"
block|,
literal|"December"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|fmtscan
argument_list|(
argument|format
argument_list|,
argument|scanl
argument_list|,
argument|width
argument_list|,
argument|dat
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|format
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|scanl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dat
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|scanl
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
init|=
name|scanl
operator|+
name|width
operator|-
literal|1
decl_stmt|;
specifier|register
name|struct
name|format
modifier|*
name|fmt
init|=
name|format
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
init|=
name|NULLCP
decl_stmt|;
specifier|register
name|int
name|value
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|comp
modifier|*
name|comp
decl_stmt|;
specifier|register
name|struct
name|tws
modifier|*
name|tws
decl_stmt|;
specifier|register
name|struct
name|mailname
modifier|*
name|mn
decl_stmt|;
name|char
modifier|*
name|savestr
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
switch|switch
condition|(
name|fmt
operator|->
name|f_type
condition|)
block|{
case|case
name|FT_COMP
case|:
name|PUTS
argument_list|(
name|cp
argument_list|,
name|fmt
operator|->
name|f_comp
operator|->
name|c_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_COMPF
case|:
name|PUTSF
argument_list|(
name|cp
argument_list|,
name|fmt
operator|->
name|f_comp
operator|->
name|c_text
argument_list|,
name|fmt
operator|->
name|f_width
argument_list|,
name|fmt
operator|->
name|f_fill
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LIT
case|:
name|sp
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|FT_LITF
case|:
name|sp
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
name|i
operator|=
name|fmt
operator|->
name|f_width
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|&&
operator|--
name|i
operator|>=
literal|0
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|fmt
operator|->
name|f_fill
expr_stmt|;
break|break;
case|case
name|FT_STR
case|:
name|PUTS
argument_list|(
name|cp
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_STRF
case|:
name|PUTSF
argument_list|(
name|cp
argument_list|,
name|str
argument_list|,
name|fmt
operator|->
name|f_width
argument_list|,
name|fmt
operator|->
name|f_fill
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_STRFW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error (FT_STRFW)"
argument_list|)
expr_stmt|;
case|case
name|FT_NUM
case|:
name|PUTD
argument_list|(
name|cp
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_NUMF
case|:
name|PUTDF
argument_list|(
name|cp
argument_list|,
name|value
argument_list|,
name|fmt
operator|->
name|f_width
argument_list|,
name|fmt
operator|->
name|f_fill
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
operator|*
name|cp
operator|++
operator|=
name|fmt
operator|->
name|f_char
expr_stmt|;
break|break;
case|case
name|FT_DONE
case|:
goto|goto
name|finished
goto|;
case|case
name|FT_IF_S
case|:
if|if
condition|(
name|str
operator|==
name|NULLCP
operator|||
operator|*
name|str
operator|==
name|NULL
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_S_NULL
case|:
if|if
condition|(
name|str
operator|!=
name|NULLCP
operator|&&
operator|*
name|str
operator|!=
name|NULL
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_V_EQ
case|:
if|if
condition|(
name|value
operator|!=
name|fmt
operator|->
name|f_value
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_V_NE
case|:
if|if
condition|(
name|value
operator|==
name|fmt
operator|->
name|f_value
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_V_GT
case|:
if|if
condition|(
name|value
operator|<=
name|fmt
operator|->
name|f_value
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_MATCH
case|:
if|if
condition|(
operator|!
name|match
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_V_MATCH
case|:
name|value
operator|=
name|match
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_IF_AMATCH
case|:
if|if
condition|(
operator|!
name|uprf
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_V_AMATCH
case|:
name|value
operator|=
name|uprf
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_S_NONNULL
case|:
name|value
operator|=
operator|(
name|str
operator|!=
name|NULLCP
operator|&&
operator|*
name|str
operator|!=
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|FT_S_NULL
case|:
name|value
operator|=
operator|(
name|str
operator|==
name|NULLCP
operator|||
operator|*
name|str
operator|==
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|FT_V_EQ
case|:
name|value
operator|=
operator|(
name|fmt
operator|->
name|f_value
operator|==
name|value
operator|)
expr_stmt|;
break|break;
case|case
name|FT_V_NE
case|:
name|value
operator|=
operator|(
name|fmt
operator|->
name|f_value
operator|!=
name|value
operator|)
expr_stmt|;
break|break;
case|case
name|FT_V_GT
case|:
name|value
operator|=
operator|(
name|fmt
operator|->
name|f_value
operator|>
name|value
operator|)
expr_stmt|;
break|break;
case|case
name|FT_GOTO
case|:
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
case|case
name|FT_NOP
case|:
break|break;
case|case
name|FT_LS_COMP
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_text
expr_stmt|;
break|break;
case|case
name|FT_LS_LIT
case|:
name|str
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
break|break;
case|case
name|FT_LV_COMPFLAG
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_flags
expr_stmt|;
break|break;
case|case
name|FT_LV_COMP
case|:
name|value
operator|=
operator|(
name|comp
operator|=
name|fmt
operator|->
name|f_comp
operator|)
operator|->
name|c_text
condition|?
name|atoi
argument_list|(
name|comp
operator|->
name|c_text
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|FT_LV_LIT
case|:
name|value
operator|=
name|fmt
operator|->
name|f_value
expr_stmt|;
break|break;
case|case
name|FT_LV_DAT
case|:
name|value
operator|=
name|dat
index|[
name|fmt
operator|->
name|f_value
index|]
expr_stmt|;
break|break;
case|case
name|FT_LV_STRLEN
case|:
name|value
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_CHAR_LEFT
case|:
name|value
operator|=
name|width
operator|-
operator|(
name|cp
operator|-
name|scanl
operator|)
expr_stmt|;
break|break;
case|case
name|FT_LV_PLUS_L
case|:
name|value
operator|+=
name|fmt
operator|->
name|f_value
expr_stmt|;
break|break;
case|case
name|FT_LV_MINUS_L
case|:
name|value
operator|=
name|fmt
operator|->
name|f_value
operator|-
name|value
expr_stmt|;
break|break;
case|case
name|FT_SAVESTR
case|:
name|savestr
operator|=
name|str
expr_stmt|;
break|break;
case|case
name|FT_LV_SEC
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_sec
expr_stmt|;
break|break;
case|case
name|FT_LV_MIN
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_min
expr_stmt|;
break|break;
case|case
name|FT_LV_HOUR
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_hour
expr_stmt|;
break|break;
case|case
name|FT_LV_MDAY
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mday
expr_stmt|;
break|break;
case|case
name|FT_LV_MON
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mon
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|FT_LS_MONTH
case|:
name|str
operator|=
name|tw_moty
index|[
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mon
index|]
expr_stmt|;
break|break;
case|case
name|FT_LS_LMONTH
case|:
name|str
operator|=
name|lmonth
index|[
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mon
index|]
expr_stmt|;
break|break;
case|case
name|FT_LS_ZONE
case|:
name|str
operator|=
name|dtwszone
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_YEAR
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_year
expr_stmt|;
break|break;
case|case
name|FT_LV_WDAY
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
name|value
operator|=
name|tws
operator|->
name|tw_wday
expr_stmt|;
break|break;
case|case
name|FT_LS_DAY
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
name|str
operator|=
name|tw_dotw
index|[
name|tws
operator|->
name|tw_wday
index|]
expr_stmt|;
break|break;
case|case
name|FT_LS_WEEKDAY
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
name|str
operator|=
name|tw_ldotw
index|[
name|tws
operator|->
name|tw_wday
index|]
expr_stmt|;
break|break;
case|case
name|FT_LV_YDAY
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_yday
expr_stmt|;
break|break;
case|case
name|FT_LV_ZONE
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_zone
expr_stmt|;
break|break;
case|case
name|FT_LV_CLOCK
case|:
if|if
condition|(
operator|(
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_clock
operator|)
operator|==
literal|0
condition|)
name|value
operator|=
name|twclock
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_RCLOCK
case|:
if|if
condition|(
operator|(
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_clock
operator|)
operator|==
literal|0
condition|)
name|value
operator|=
name|twclock
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
name|value
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
operator|-
name|value
expr_stmt|;
break|break;
case|case
name|FT_LV_DAYF
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_flags
operator|&
name|TW_SDAY
condition|)
block|{
case|case
name|TW_SEXP
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TW_SIMP
case|:
name|value
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|value
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FT_LV_TZONEF
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_flags
operator|&
name|TW_DST
expr_stmt|;
break|break;
case|case
name|FT_LS_822DATE
case|:
name|str
operator|=
name|dasctime
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|,
name|TW_ZONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LS_PRETTY
case|:
name|str
operator|=
name|dasctime
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|,
name|TW_NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LS_PERS
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_pers
expr_stmt|;
break|break;
case|case
name|FT_LS_MBOX
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_mbox
expr_stmt|;
break|break;
case|case
name|FT_LS_HOST
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_host
expr_stmt|;
break|break;
case|case
name|FT_LS_PATH
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_path
expr_stmt|;
break|break;
case|case
name|FT_LS_GNAME
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_gname
expr_stmt|;
break|break;
case|case
name|FT_LS_NOTE
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_note
expr_stmt|;
break|break;
case|case
name|FT_LS_822ADDR
case|:
name|str
operator|=
name|adrformat
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_HOSTTYPE
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_type
expr_stmt|;
break|break;
case|case
name|FT_LV_INGRPF
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_ingrp
expr_stmt|;
break|break;
case|case
name|FT_LV_NOHOSTF
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_nohost
expr_stmt|;
break|break;
case|case
name|FT_LS_FRIENDLY
case|:
ifdef|#
directive|ifdef
name|BERK
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_mbox
expr_stmt|;
else|#
directive|else
else|not BERK
name|mn
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|=
name|mn
operator|->
name|m_pers
operator|)
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|mn
operator|->
name|m_type
condition|)
block|{
case|case
name|LOCALHOST
case|:
name|str
operator|=
name|mn
operator|->
name|m_mbox
expr_stmt|;
break|break;
case|case
name|UUCPHOST
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s!%s"
argument_list|,
name|mn
operator|->
name|m_host
argument_list|,
name|mn
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
name|str
operator|=
name|buffer
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|mn
operator|->
name|m_mbox
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s@%s"
argument_list|,
name|mn
operator|->
name|m_mbox
argument_list|,
name|mn
operator|->
name|m_host
argument_list|)
expr_stmt|;
name|str
operator|=
name|buffer
expr_stmt|;
block|}
else|else
name|str
operator|=
name|mn
operator|->
name|m_text
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
endif|BERK
break|break;
case|case
name|FT_PARSEDATE
case|:
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|comp
operator|->
name|c_text
operator|)
operator|&&
operator|(
name|tws
operator|=
name|dparsetime
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
operator|*
name|comp
operator|->
name|c_tws
operator|=
operator|*
name|tws
expr_stmt|;
name|comp
operator|->
name|c_flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|->
name|c_flags
operator|>=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|comp
operator|->
name|c_tws
argument_list|,
sizeof|sizeof
expr|*
name|comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
name|comp
operator|->
name|c_flags
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|FT_FORMATADDR
case|:
comment|/* hook for custom address list formatting (see replsbr.c) */
name|str
operator|=
name|formataddr
argument_list|(
name|savestr
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_PUTADDR
case|:
comment|/* output the str register as an address component, 	     * splitting it into multiple lines if necessary.  The 	     * value reg. contains the max line length.  The lit. 	     * field may contain a string to prepend to the result 	     * (e.g., "To: ") 	     */
block|{
specifier|register
name|char
modifier|*
name|lp
init|=
name|str
decl_stmt|;
specifier|register
name|int
name|indent
decl_stmt|;
specifier|register
name|int
name|wid
init|=
name|value
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|lastb
decl_stmt|;
name|sp
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
name|indent
operator|=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|wid
operator|-=
name|indent
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|wid
condition|)
block|{
comment|/* try to break at a comma; failing that, break at a 		 * space, failing that, just split the line. 		 */
name|lastb
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|lp
operator|+
name|wid
expr_stmt|;
while|while
condition|(
name|sp
operator|>
name|lp
operator|&&
operator|(
name|c
operator|=
operator|*
operator|--
name|sp
operator|)
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|!
name|lastb
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|lastb
operator|=
name|sp
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|lp
condition|)
if|if
condition|(
operator|!
operator|(
name|sp
operator|=
name|lastb
operator|)
condition|)
name|sp
operator|=
name|lp
operator|+
name|wid
operator|-
literal|1
expr_stmt|;
name|len
operator|-=
name|sp
operator|-
name|lp
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
name|lp
operator|<=
name|sp
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indent
init|;
name|cp
operator|<
name|ep
operator|&&
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
name|lp
operator|++
operator|,
name|len
operator|--
expr_stmt|;
block|}
name|PUTS
argument_list|(
name|cp
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FT_PARSEADDR
case|:
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|c_mn
operator|!=
operator|&
name|fmt_mnull
condition|)
name|mnfree
argument_list|(
name|comp
operator|->
name|c_mn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|comp
operator|->
name|c_text
operator|)
operator|&&
operator|(
name|sp
operator|=
name|getname
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
operator|(
name|mn
operator|=
name|getm
argument_list|(
name|sp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|fmt_norm
argument_list|,
name|NULLCP
argument_list|)
operator|)
condition|)
block|{
name|comp
operator|->
name|c_mn
operator|=
name|mn
expr_stmt|;
while|while
condition|(
name|getname
argument_list|(
literal|""
argument_list|)
condition|)
empty_stmt|;
block|}
else|else
name|comp
operator|->
name|c_mn
operator|=
operator|&
name|fmt_mnull
expr_stmt|;
break|break;
case|case
name|FT_MYMBOX
case|:
comment|/* 	     * if there's no component, we say true.  Otherwise we 	     * say "true" only if we can parse the address and it 	     * matches one of our addresses. 	     */
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|c_mn
operator|!=
operator|&
name|fmt_mnull
condition|)
name|mnfree
argument_list|(
name|comp
operator|->
name|c_mn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|comp
operator|->
name|c_text
operator|)
operator|&&
operator|(
name|sp
operator|=
name|getname
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
operator|(
name|mn
operator|=
name|getm
argument_list|(
name|sp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_NAME
argument_list|,
name|NULLCP
argument_list|)
operator|)
condition|)
block|{
name|comp
operator|->
name|c_mn
operator|=
name|mn
expr_stmt|;
name|comp
operator|->
name|c_flags
operator|=
name|ismymbox
argument_list|(
name|mn
argument_list|)
expr_stmt|;
while|while
condition|(
name|getname
argument_list|(
literal|""
argument_list|)
condition|)
empty_stmt|;
block|}
else|else
block|{
name|comp
operator|->
name|c_flags
operator|=
operator|(
name|comp
operator|->
name|c_text
operator|==
literal|0
operator|)
expr_stmt|;
name|comp
operator|->
name|c_mn
operator|=
operator|&
name|fmt_mnull
expr_stmt|;
block|}
break|break;
block|}
name|fmt
operator|++
expr_stmt|;
block|}
name|finished
label|:
empty_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_block

end_unit

