begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|MFDEBUG
end_define

begin_comment
comment|/* temporarily */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"mmdf.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"mf.h"
end_include

begin_include
include|#
directive|include
file|"tws.h"
end_include

begin_comment
comment|/*  *				R M A I L . C  *  *	Developed from the Berkeley mail program of the same name  *	by Mike Obrien at RAND to run with the MMDF mail system.  *	Rewritten by Doug Kingston, US Army Ballistics Research Laboratory  *	Hacked a lot by Steve Bellovin (smb@unc)  *  *	This program runs SETUID to root so that it can set effective and  *	real [ug]ids to mmdflogin.  *  *    27-Oct-82	Marshall T. Rose<mrose%uci@rand-relay>  *		Support proper munging by using the UCI mail filtering  *		routines (enabled by #ifdef MF)  *		Also use ll_log() package (enabled by #ifdef LOG)  *  *    17-Oct-83 Marshall T. Rose<mrose%uci@rand-relay>  *		New interfacing.  Remove the #ifdef:s  */
end_comment

begin_define
define|#
directive|define
name|NAMESZ
value|64
end_define

begin_comment
comment|/* Limit on component name size         */
end_comment

begin_define
define|#
directive|define
name|ADDROK
value|0
end_define

begin_define
define|#
directive|define
name|UUCP
value|1
end_define

begin_define
define|#
directive|define
name|RETURN
value|2
end_define

begin_decl_stmt
name|int
name|Syscpy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Tmpmode
init|=
literal|0600
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Fromtmp
init|=
literal|"/tmp/rml.f.XXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Msgtmp
init|=
literal|"/tmp/rml.m.XXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Errtmp
init|=
literal|"/tmp/rml.e.XXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Okhosts
init|=
literal|"/usr/mmdf/table/rmail.ok"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Okdests
init|=
literal|"/usr/mmdf/table/rmail.okdests"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|cmddfldir
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|logdfldir
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|mmdflogin
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|pathsubmit
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|sitesignature
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|supportaddr
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ll_struct
name|chanlog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dupfpath
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwnam
argument_list|()
decl_stmt|,
modifier|*
name|getpwuid
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
name|struct
name|ll_struct
modifier|*
name|logptr
init|=
operator|&
name|chanlog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fromf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary out for colon-less UUCP "From" lines */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|msgf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary out for message text */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|mmdf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filtered mail file */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|pipef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output to "submit" or "uux" */
end_comment

begin_decl_stmt
name|char
name|date
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* date of origination from uucp header */
end_comment

begin_decl_stmt
name|char
name|from
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated path of sender */
end_comment

begin_decl_stmt
name|char
name|origsys
index|[
name|NAMESZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* originating system */
end_comment

begin_decl_stmt
name|char
name|origpath
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* path from us to originating system */
end_comment

begin_decl_stmt
name|char
name|usrfrm
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Mailsys
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pbroke
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* broken-pipe flag */
end_comment

begin_decl_stmt
name|int
name|rtnflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* note was sent back */
end_comment

begin_function_decl
name|int
name|brpipe
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|fromwhom
index|[
name|NAMESZ
index|]
decl_stmt|;
comment|/* user on remote system */
name|char
modifier|*
name|fromptr
decl_stmt|;
name|char
name|linebuf
index|[
name|LINESIZE
index|]
decl_stmt|;
comment|/* scratchpad */
name|char
name|sys
index|[
name|NAMESZ
index|]
decl_stmt|;
comment|/* an element in the uucp path */
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cpyback
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: rmail user [user ...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ll_hdinit
argument_list|(
name|logptr
argument_list|,
literal|"RM"
argument_list|)
expr_stmt|;
name|logptr
operator|->
name|ll_file
operator|=
name|dupfpath
argument_list|(
name|logptr
operator|->
name|ll_file
argument_list|,
name|logdfldir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|mmdflogin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find mmdflogin\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Mailsys
argument_list|,
literal|"%s<%s@%s>"
argument_list|,
name|sitesignature
argument_list|,
name|mmdflogin
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
comment|/*
comment|*/
block|{
comment|/* BE VERY SURE... */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
init|;
name|i
operator|<=
name|HIGHFD
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* create file to hold stderr output.  We first open some */
comment|/* null file to make sure stdout is taken.  If stdin isn't */
comment|/* open either, we've got so much trouble it isn't even worth */
comment|/* worrying about a little more */
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|Errtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|Errtmp
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s\n"
argument_list|,
name|Errtmp
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"Unable to create '%s'"
argument_list|,
name|Errtmp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dup2
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create temp file for rest of message */
name|mktemp
argument_list|(
name|Msgtmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msgf
operator|=
name|fdopen
argument_list|(
name|creat
argument_list|(
name|Msgtmp
argument_list|,
name|Tmpmode
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s\n"
argument_list|,
name|Msgtmp
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"Unable to create '%s'"
argument_list|,
name|Msgtmp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* create temp file for colon-less UUCP "From" lines */
name|mktemp
argument_list|(
name|Fromtmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fromf
operator|=
name|fdopen
argument_list|(
name|creat
argument_list|(
name|Fromtmp
argument_list|,
name|Tmpmode
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create %s\n"
argument_list|,
name|Fromtmp
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"Unable to create '%s'"
argument_list|,
name|Fromtmp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|linebuf
argument_list|,
sizeof|sizeof
name|linebuf
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|linebuf
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|linebuf
argument_list|,
literal|">From "
argument_list|,
literal|6
argument_list|)
condition|)
break|break;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|!=
literal|'>'
condition|)
name|fputs
argument_list|(
literal|">"
argument_list|,
name|fromf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|linebuf
argument_list|,
name|fromf
argument_list|)
expr_stmt|;
comment|/* Save, we may forward via UUCP */
name|cp
operator|=
name|index
argument_list|(
name|linebuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* start of name */
name|fromptr
operator|=
operator|++
name|cp
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* cp at end of name */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* term. name, cp at date */
name|strcpy
argument_list|(
name|fromwhom
argument_list|,
name|fromptr
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|date
argument_list|,
name|cp
argument_list|,
literal|24
argument_list|)
expr_stmt|;
comment|/* Mon Nov 10 23:12:09 1981 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|index
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|rindex
argument_list|(
name|fromwhom
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|fromwhom
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|origsys
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|origsys
argument_list|,
name|fromwhom
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|from
argument_list|,
name|fromwhom
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|from
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fromwhom
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|strcpy
argument_list|(
name|sys
argument_list|,
name|SystemName
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|from
argument_list|,
name|sys
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|origsys
argument_list|,
name|sys
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|from
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"remote from "
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"remote from %s"
argument_list|,
name|sys
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|from
argument_list|,
name|sys
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|origsys
argument_list|,
name|sys
argument_list|)
expr_stmt|;
comment|/* Save for quick ref. */
name|strcat
argument_list|(
name|from
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
block|}
if|if
condition|(
name|fromwhom
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* No from line, illegal */
name|exit
argument_list|(
literal|99
argument_list|)
expr_stmt|;
comment|/*
comment|*/
name|strcpy
argument_list|(
name|origpath
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|from
argument_list|,
name|fromwhom
argument_list|)
expr_stmt|;
name|mf_get_addr
argument_list|(
name|from
argument_list|,
name|usrfrm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|usrfrm
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|usrfrm
argument_list|,
operator|++
name|cp
argument_list|)
expr_stmt|;
comment|/* sigh */
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|usrfrm
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|usrfrm
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|usrfrm
argument_list|,
literal|"%s!%s%%%s@%s"
argument_list|,
name|SystemName
argument_list|()
argument_list|,
name|from
argument_list|,
name|UucpChan
argument_list|()
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"Rmail from '%s' (%s)"
argument_list|,
name|from
argument_list|,
name|usrfrm
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|linebuf
argument_list|,
name|msgf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|txtcpy
argument_list|(
name|stdin
argument_list|,
name|msgf
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"\n  *** Problem during receipt from UUCP ***\n"
argument_list|,
name|msgf
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
name|Msgtmp
argument_list|,
literal|"r"
argument_list|,
name|msgf
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
name|Fromtmp
argument_list|,
literal|"r"
argument_list|,
name|fromf
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|Msgtmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|Fromtmp
argument_list|)
expr_stmt|;
name|mmdf
operator|=
name|NULL
expr_stmt|;
name|cpyback
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|argv
operator|++
init|;
operator|--
name|argc
operator|>
literal|0
condition|;
control|)
block|{
name|rewind
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|msgf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmdf
operator|!=
name|NULL
condition|)
name|rewind
argument_list|(
name|mmdf
argument_list|)
expr_stmt|;
name|pbroke
operator|=
literal|0
expr_stmt|;
name|rtnflag
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|brpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|deliver
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
argument_list|)
operator|&&
operator|!
name|rtnflag
condition|)
name|cpyback
operator|++
expr_stmt|;
block|}
comment|/* Send back a copy if something nasty happened.  For now, we use */
comment|/* a real kludge -- we see if we noted some error, or if we find */
comment|/* anything written to stderr....  */
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpyback
condition|)
block|{
name|rcpy
argument_list|()
expr_stmt|;
name|zcpy
argument_list|()
expr_stmt|;
block|}
name|unlink
argument_list|(
name|Errtmp
argument_list|)
expr_stmt|;
name|ll_close
argument_list|(
name|logptr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  *	deliver() -- Handle all deliveries be they returns, automatic  *			copies, or the real thing.  Based on the address  *			the letter is accepted or returned with a copy  *			to the system administrators  *  *			main() has set up the "from" string and the  *			"date" string.  */
end_comment

begin_decl_stmt
name|char
name|rtnend
index|[]
init|=
literal|"  --------------- End of Returned Mail ---------------\n"
decl_stmt|;
end_decl_stmt

begin_macro
name|deliver
argument_list|(
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|replyval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|linebuf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
name|tmpbuf
index|[
name|LINESIZE
index|]
decl_stmt|;
switch|switch
condition|(
name|adrcheck
argument_list|(
name|to
argument_list|)
condition|)
block|{
case|case
name|ADDROK
case|:
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"Rmail to '%s' via MMDF"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|replyval
operator|=
name|xsubmit
argument_list|(
name|NULL
argument_list|,
name|usrfrm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|to
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|mmdf
operator|==
name|NULL
condition|)
if|if
condition|(
name|mf_get_msg
argument_list|()
operator|==
name|NOTOK
condition|)
name|mmdf
operator|=
name|msgf
expr_stmt|;
name|replyval
operator|=
name|txtcpy
argument_list|(
name|mmdf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RUNALON
name|i
operator|=
operator|(
name|pclose
argument_list|(
name|pipef
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|rp_isgood
argument_list|(
name|replyval
argument_list|)
condition|)
name|replyval
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|UUCP
case|:
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"Rmail to '%s' via UUCP"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|replyval
operator|=
name|xuucp
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
argument_list|)
condition|)
break|break;
name|replyval
operator|=
name|txtcpy
argument_list|(
name|msgf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RUNALON
name|i
operator|=
operator|(
name|pclose
argument_list|(
name|pipef
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|rp_isgood
argument_list|(
name|replyval
argument_list|)
condition|)
name|replyval
operator|=
operator|(
name|i
operator|==
literal|0
condition|?
name|RP_OK
else|:
name|RP_LIO
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/*
comment|*/
case|case
name|RETURN
case|:
name|rtnflag
operator|=
literal|1
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"Illegal Rmail to '%s'"
argument_list|,
name|to
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adrcheck
argument_list|(
name|from
argument_list|)
condition|)
block|{
case|case
name|ADDROK
case|:
case|case
name|RETURN
case|:
name|replyval
operator|=
name|xsubmit
argument_list|(
name|dtimenow
argument_list|()
argument_list|,
name|Mailsys
argument_list|,
name|from
argument_list|,
name|supportaddr
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|rtnmesg
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|txtcpy
argument_list|(
name|fromf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
name|txtcpy
argument_list|(
name|msgf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|rtnend
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RUNALON
name|i
operator|=
operator|(
name|pclose
argument_list|(
name|pipef
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|rp_isgood
argument_list|(
name|replyval
argument_list|)
condition|)
name|replyval
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|UUCP
case|:
name|replyval
operator|=
name|xuucp
argument_list|(
name|mmdflogin
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|replyval
argument_list|)
condition|)
break|break;
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"To: %s\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"Cc: %s\n"
argument_list|,
name|supportaddr
argument_list|)
expr_stmt|;
name|rtnmesg
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|txtcpy
argument_list|(
name|fromf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
name|txtcpy
argument_list|(
name|msgf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|rtnend
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RUNALON
name|i
operator|=
operator|(
name|pclose
argument_list|(
name|pipef
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|rp_isgood
argument_list|(
name|replyval
argument_list|)
condition|)
name|replyval
operator|=
operator|(
name|i
operator|==
literal|0
condition|?
name|RP_OK
else|:
name|RP_LIO
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* And now for the mail overseer's copy */
if|if
condition|(
name|Syscpy
condition|)
block|{
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"Notifying %s"
argument_list|,
name|supportaddr
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|msgf
argument_list|)
expr_stmt|;
name|replyval
operator|=
name|xsubmit
argument_list|(
name|dtimenow
argument_list|()
argument_list|,
name|Mailsys
argument_list|,
name|usrfrm
argument_list|,
name|supportaddr
argument_list|,
name|supportaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|replyval
argument_list|)
condition|)
break|break;
name|rtnmesg
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|txtcpy
argument_list|(
name|fromf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
name|txtcpy
argument_list|(
name|msgf
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|rtnend
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RUNALON
name|i
operator|=
operator|(
name|pclose
argument_list|(
name|pipef
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|rp_isgood
argument_list|(
name|replyval
argument_list|)
condition|)
name|replyval
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
operator|(
name|replyval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|adrcheck
argument_list|(
argument|adr
argument_list|)
end_macro

begin_comment
comment|/* Gateway to Arpanet? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|adr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|err
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|host
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mbox
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|adrx
modifier|*
name|adrxp
decl_stmt|;
if|if
condition|(
operator|(
name|adrxp
operator|=
name|seekadrx
argument_list|(
name|adr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|RETURN
return|;
name|strcpy
argument_list|(
name|err
argument_list|,
name|adrxp
operator|->
name|err
condition|?
name|adrxp
operator|->
name|err
else|:
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|host
argument_list|,
name|adrxp
operator|->
name|host
condition|?
name|adrxp
operator|->
name|host
else|:
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mbox
argument_list|,
name|adrxp
operator|->
name|mbox
condition|?
name|adrxp
operator|->
name|mbox
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
name|seekadrx
argument_list|(
name|NULL
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|err
index|[
literal|0
index|]
operator|||
name|mbox
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
name|RETURN
return|;
if|if
condition|(
name|index
argument_list|(
name|mbox
argument_list|,
literal|'!'
argument_list|)
operator|||
name|host
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
name|UUCP
return|;
if|if
condition|(
name|rp_isgood
argument_list|(
name|lookup
argument_list|(
name|origsys
argument_list|,
name|Okhosts
argument_list|)
argument_list|)
condition|)
return|return
name|ADDROK
return|;
if|if
condition|(
name|index
argument_list|(
name|host
argument_list|,
literal|'@'
argument_list|)
operator|||
name|rp_isbad
argument_list|(
name|okhost
argument_list|(
name|host
argument_list|)
argument_list|)
condition|)
return|return
name|RETURN
return|;
return|return
name|ADDROK
return|;
block|}
end_block

begin_macro
name|okhost
argument_list|(
argument|host
argument_list|)
end_macro

begin_comment
comment|/* Host permitted to use mail facilities? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|rp_isgood
argument_list|(
name|lookup
argument_list|(
name|origsys
argument_list|,
name|Okhosts
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|RP_OK
operator|)
return|;
comment|/* Fully privledged originator */
if|if
condition|(
name|rp_isgood
argument_list|(
name|lookup
argument_list|(
name|host
argument_list|,
name|Okhosts
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|RP_OK
operator|)
return|;
comment|/* Fully privledged dest */
if|if
condition|(
name|rp_isgood
argument_list|(
name|lookup
argument_list|(
name|host
argument_list|,
name|Okdests
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|RP_OK
operator|)
return|;
comment|/* Unrestricted Dest. Host, OK */
return|return
operator|(
name|RP_NO
operator|)
return|;
comment|/* Not permitted; must be bad */
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  *	lookup()  --	This lookup function looks for strings which  *			must be the first string on a line.  Sorry Dave (dhc)  *			but the MMDF channel functions are too specific  *			to be easily used here without much kludging.  */
end_comment

begin_comment
comment|/***************************************** ****	Can this be a call to a MMDF function?? ****	Remember I have the RHOSTs table and the OKHOSTS table. ******************************************/
end_comment

begin_macro
name|lookup
argument_list|(
argument|what
argument_list|,
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|lookf
decl_stmt|;
name|char
name|entry
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|lookf
operator|=
name|fopen
argument_list|(
name|where
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|RP_NO
operator|)
return|;
comment|/* Unknown problem */
while|while
condition|(
name|fgets
argument_list|(
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|,
name|lookf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|entry
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|what
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|lookf
argument_list|)
expr_stmt|;
return|return
operator|(
name|RP_OK
operator|)
return|;
block|}
block|}
name|fclose
argument_list|(
name|lookf
argument_list|)
expr_stmt|;
return|return
operator|(
name|RP_NO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|rtnmessage
index|[]
init|=
block|{
literal|"	Your message has been intercepted trying to access\n"
block|,
literal|"a restricted access host (e.g. an ARPANET host).  A copy\n"
block|,
literal|"of your message has been sent to the system administrators.\n"
block|,
literal|"The text of your message follows.\n\n"
block|,
literal|"  --------------- Returned Mail Follows --------------\n"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|rtnmesg
argument_list|(
argument|badadr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|badadr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"Subject:  Illegal Address (%s)\n\n"
argument_list|,
name|badadr
argument_list|)
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|rtnmessage
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
name|fputs
argument_list|(
operator|*
name|cpp
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|txtcpy
argument_list|(
argument|frm
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|frm
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
while|while
condition|(
operator|!
name|pbroke
operator|&&
operator|(
name|nread
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|,
name|BUFSIZ
argument_list|,
name|frm
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|,
name|nread
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|frm
argument_list|)
condition|?
name|RP_LIO
else|:
name|RP_OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|xsubmit
argument_list|(
argument|date
argument_list|,
argument|from
argument_list|,
argument|to
argument_list|,
argument|cc
argument_list|,
argument|realto
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|date
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|,
modifier|*
name|cc
decl_stmt|,
modifier|*
name|realto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdstr
index|[
name|LINESIZE
index|]
decl_stmt|,
name|submit
index|[
name|LINESIZE
index|]
decl_stmt|;
name|getfpath
argument_list|(
name|pathsubmit
argument_list|,
name|cmddfldir
argument_list|,
name|submit
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"%s '-mlti%s*'"
argument_list|,
name|submit
argument_list|,
name|UucpChan
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RUNALON
if|if
condition|(
operator|(
name|pipef
operator|=
name|popen
argument_list|(
name|cmdstr
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|RP_NO
operator|)
return|;
else|#
directive|else
name|pipef
operator|=
name|stdout
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"%s\n%s\n!\n"
argument_list|,
name|from
argument_list|,
name|realto
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
block|{
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"Date:     %s\n"
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"From:     %s\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|to
condition|)
block|{
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"To:       %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|to
argument_list|,
literal|'@'
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|pipef
argument_list|)
expr_stmt|;
comment|/* Explicit host specified */
else|else
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"@%s\n"
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc
condition|)
block|{
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"Cc:       %s\n"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|RP_OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|xuucp
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdstr
index|[
name|LINESIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"/etc/delivermail -r%s -ep -m -s -i %s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RUNALON
if|if
condition|(
operator|(
name|pipef
operator|=
name|popen
argument_list|(
name|cmdstr
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|RP_NO
operator|)
return|;
else|#
directive|else
name|pipef
operator|=
name|stdout
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|RP_OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|brpipe
argument_list|()
end_macro

begin_comment
comment|/* catch broken-pipe signals */
end_comment

begin_block
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|pbroke
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|oopsmessage
index|[]
init|=
block|{
literal|"\n\n\tThe system administrators (%s) have been informed of the\n"
block|,
literal|"problem, but have not been given a copy of your message.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|rcpy
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|message
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"Advising %s of failure as %s..."
argument_list|,
name|from
argument_list|,
name|usrfrm
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Problems sending mail:\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml_1adr
argument_list|(
name|NO
argument_list|,
name|NO
argument_list|,
name|sitesignature
argument_list|,
literal|"Problems sending mail"
argument_list|,
name|usrfrm
argument_list|)
operator|!=
name|OK
condition|)
goto|goto
name|ml_err
goto|;
name|ml_txt
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|Errtmp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ml_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftell
argument_list|(
name|fp
argument_list|)
operator|==
literal|0L
condition|)
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"\tunknown problem\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|ml_txt
argument_list|(
literal|"\tunknown problem\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|oopsmessage
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
name|oopsmessage
index|[
name|i
index|]
argument_list|,
name|supportaddr
argument_list|)
expr_stmt|;
name|ml_txt
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"\n\nReturned message follows:\n\n---------------\n\n"
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
name|ml_file
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|msgf
argument_list|)
expr_stmt|;
name|ml_file
argument_list|(
name|msgf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml_end
argument_list|(
name|OK
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|ml_err
label|:
empty_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"Unable to post failure notice"
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"info: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|zcpy
argument_list|()
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"Advising %s of failure..."
argument_list|,
name|supportaddr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Problems sending mail for %s (aka %s):\n\n"
argument_list|,
name|from
argument_list|,
name|usrfrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml_1adr
argument_list|(
name|NO
argument_list|,
name|NO
argument_list|,
name|sitesignature
argument_list|,
literal|"Problems sending mail"
argument_list|,
name|supportaddr
argument_list|)
operator|!=
name|OK
condition|)
goto|goto
name|ml_err
goto|;
name|ml_txt
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|Errtmp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ml_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftell
argument_list|(
name|fp
argument_list|)
operator|==
literal|0L
condition|)
name|fprintf
argument_list|(
name|pipef
argument_list|,
literal|"\tunknown problem\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|ml_txt
argument_list|(
literal|"\tunable to open error file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml_end
argument_list|(
name|OK
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|ml_err
label|:
empty_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"Unable to post failure notice"
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"info: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|mf_get_msg
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|,
name|md
decl_stmt|,
name|td
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmpfil
index|[
name|LINESIZE
index|]
decl_stmt|,
name|mmdfil
index|[
name|LINESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MFDEBUG
name|FILE
modifier|*
name|fp
decl_stmt|;
endif|#
directive|endif
endif|MFDEBUG
name|FILE
modifier|*
name|out
decl_stmt|;
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
literal|"/tmp/rmailXXXXXX"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mktemp
argument_list|(
name|tmpfil
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|tmpfil
argument_list|,
name|Tmpmode
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmpfil
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|out
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|td
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"From %s %s\n"
argument_list|,
name|from
argument_list|,
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|txtcpy
argument_list|(
name|msgf
argument_list|,
name|out
argument_list|)
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|td
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mmdfil
argument_list|,
literal|"/tmp/mmdfXXXXXX"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mktemp
argument_list|(
name|mmdfil
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|mmdfil
argument_list|,
name|Tmpmode
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|close
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|mmdfil
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|close
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|close
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/*
comment|*/
switch|switch
condition|(
name|i
operator|=
name|uucp_to_mmdf
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mmdf
operator|=
name|fdopen
argument_list|(
name|md
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
default|default:
name|close
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rmail(%d) filtering failed(%d)\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml_1adr
argument_list|(
name|NO
argument_list|,
name|NO
argument_list|,
name|sitesignature
argument_list|,
literal|"MF Failure"
argument_list|,
name|supportaddr
argument_list|)
operator|!=
name|OK
condition|)
goto|goto
name|ml_err
goto|;
name|ml_txt
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MFDEBUG
name|lseek
argument_list|(
name|td
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|dup
argument_list|(
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|ml_txt
argument_list|(
literal|"unable to dup() descriptor for message copy\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|md
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ml_txt
argument_list|(
literal|"unable to fdopen() descriptor for message copy\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ml_txt
argument_list|(
literal|"\n  --Message Follows--\n"
argument_list|)
expr_stmt|;
name|ml_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MFDEBUG
if|if
condition|(
name|ml_end
argument_list|(
name|OK
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|ml_err
label|:
empty_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"Unable to post failure notice"
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"info: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|md
operator|=
name|NOTOK
expr_stmt|;
break|break;
block|}
name|close
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|mmdfil
argument_list|)
expr_stmt|;
return|return
name|md
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|mf_get_addr
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|adrx
modifier|*
name|adrxp
decl_stmt|,
modifier|*
name|seekadrx
argument_list|()
decl_stmt|;
operator|*
name|to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|adrxp
operator|=
name|seekadrx
argument_list|(
name|from
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|addr_convert
argument_list|(
name|adrxp
argument_list|,
name|to
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
while|while
condition|(
name|seekadrx
argument_list|(
name|NULL
argument_list|)
condition|)
continue|continue;
return|return;
block|}
end_block

end_unit

