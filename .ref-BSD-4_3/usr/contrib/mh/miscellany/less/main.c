begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Entry point, initialization, miscellaneous routines.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|public
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|jmp_buf
name|main_loop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
modifier|*
name|first_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
modifier|*
name|every_first_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|new_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
name|current_file
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|ac
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|curr_ac
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|EDITOR
end_if

begin_decl_stmt
name|public
name|char
modifier|*
name|editor
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_at_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|p_nbufs
decl_stmt|,
name|f_nbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|back_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|top_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_height
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Edit a new file.  * Filename "-" means standard input.  * No filename means the "current" file, from the command line.  */
end_comment

begin_function
name|public
name|void
name|edit
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|char
name|message
index|[
literal|100
index|]
decl_stmt|;
specifier|static
name|int
name|any_edited
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|hold_scroll
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
operator|*
name|filename
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|curr_ac
operator|>=
name|ac
condition|)
block|{
name|error
argument_list|(
literal|"No current file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|av
index|[
name|curr_ac
index|]
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|f
operator|=
literal|0
expr_stmt|;
comment|/* Standard input */
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cannot open %.*s"
argument_list|,
name|error_width
argument_list|()
operator|-
literal|13
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|any_edited
condition|)
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
else|else
block|{
name|puts
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|hold_scroll
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* 		 * Not really necessary to call this an error, 		 * but if the control terminal (for commands) 		 * and the input file (for data) are the same, 		 * we get weird results at best. 		 */
name|error
argument_list|(
literal|"Can't take input from a terminal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>
literal|0
condition|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Close the current input file and set up to use the new one. 	 */
if|if
condition|(
name|file
operator|>
literal|0
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|new_file
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|current_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ispipe
operator|=
operator|(
name|f
operator|==
literal|0
operator|)
expr_stmt|;
name|file
operator|=
name|f
expr_stmt|;
name|ch_init
argument_list|(
operator|(
name|ispipe
operator|)
condition|?
name|p_nbufs
else|:
name|f_nbufs
argument_list|)
expr_stmt|;
name|init_mark
argument_list|()
expr_stmt|;
if|if
condition|(
name|every_first_cmd
operator|!=
name|NULL
condition|)
name|first_cmd
operator|=
name|every_first_cmd
expr_stmt|;
if|if
condition|(
name|is_tty
condition|)
block|{
name|any_edited
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hold_scroll
condition|)
block|{
comment|/* 			 * Before erasing the screen contents, 			 * display the file name and ask for a keystroke. 			 */
name|error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|hold_scroll
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|first_cmd
operator|==
name|NULL
operator|||
operator|*
name|first_cmd
operator|==
literal|'\0'
condition|)
block|{
comment|/*  			 * Display the first screen.  			 */
name|jump_back
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  			 * The first_cmd will hopefully redisplay the 			 * screen, so we need not display anything yet. 			 * Indicate there is nothing yet on the screen.  			 */
name|pos_clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Edit the next file in the command line list.  */
end_comment

begin_function
name|public
name|void
name|next_file
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|curr_ac
operator|+
name|n
operator|>=
name|ac
condition|)
block|{
if|if
condition|(
name|quit_at_eof
condition|)
name|quit
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"No (N-th) next file"
argument_list|)
expr_stmt|;
block|}
else|else
name|edit
argument_list|(
name|av
index|[
name|curr_ac
operator|+=
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Edit the previous file in the command line list.  */
end_comment

begin_function
name|public
name|void
name|prev_file
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|curr_ac
operator|-
name|n
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"No (N-th) previous file"
argument_list|)
expr_stmt|;
else|else
name|edit
argument_list|(
name|av
index|[
name|curr_ac
operator|-=
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy a file directly to standard output.  * Used if standard output is not a tty.  */
end_comment

begin_function
specifier|static
name|void
name|cat_file
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Entry point.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
comment|/* 	 * Process command line arguments and LESS environment arguments. 	 * Command line arguments override environment arguments. 	 */
name|init_option
argument_list|()
expr_stmt|;
name|scan_option
argument_list|(
name|getenv
argument_list|(
literal|"LESS"
argument_list|)
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|argc
operator|>
literal|0
operator|)
operator|&&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|scan_option
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
if|#
directive|if
name|EDITOR
name|editor
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
operator|==
name|NULL
operator|||
operator|*
name|editor
operator|==
literal|'\0'
condition|)
name|editor
operator|=
name|EDIT_PGM
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set up list of files to be examined. 	 */
name|ac
operator|=
name|argc
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
name|curr_ac
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up terminal, etc. 	 */
name|is_tty
operator|=
name|isatty
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_tty
condition|)
block|{
comment|/* 		 * Output is not a tty. 		 * Just copy the input file(s) to output. 		 */
if|if
condition|(
name|ac
operator|<
literal|1
condition|)
block|{
name|edit
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|cat_file
argument_list|()
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|edit
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
name|cat_file
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|curr_ac
operator|<
name|ac
condition|)
do|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|get_term
argument_list|()
expr_stmt|;
name|open_getc
argument_list|()
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|back_scroll
operator|<
literal|0
condition|)
block|{
comment|/* {{ KLUDGE }} */
name|back_scroll
operator|=
name|sc_height
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|top_scroll
condition|)
name|back_scroll
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|main_loop
argument_list|)
condition|)
name|quit
argument_list|()
expr_stmt|;
name|init_signals
argument_list|()
expr_stmt|;
comment|/* 	 * Select the first file to examine. 	 */
if|if
condition|(
name|ac
operator|<
literal|1
condition|)
name|edit
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
comment|/* Standard input */
else|else
block|{
comment|/* 		 * Try all the files named as command arguments. 		 * We are simply looking for one which can be 		 * opened without error. 		 */
do|do
block|{
name|edit
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
comment|/* We can open this file. */
break|break;
name|putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|curr_ac
operator|<
name|ac
condition|)
do|;
block|}
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
name|commands
argument_list|()
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exit the program.  */
end_comment

begin_function
name|public
name|void
name|quit
parameter_list|()
block|{
comment|/* 	 * Put cursor at bottom left corner, clear the line, 	 * reset the terminal modes, and exit. 	 */
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|deinit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

