begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * User-level command processor.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
specifier|extern
name|jmp_buf
name|main_loop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|erase_char
decl_stmt|,
name|kill_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_at_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|first_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|version
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|current_file
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|editor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cmdbuf
index|[
literal|90
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for holding a multi-char command */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer into cmdbuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmd_col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current column of the multi-char command */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The multi-char command letter (e.g. '/') */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_mcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The previous mcc */
end_comment

begin_comment
comment|/*  * Reset command buffer (to empty).  */
end_comment

begin_macro
name|cmd_reset
argument_list|()
end_macro

begin_block
block|{
name|cp
operator|=
name|cmdbuf
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Backspace in command buffer.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_erase
parameter_list|()
block|{
if|if
condition|(
name|cp
operator|==
name|cmdbuf
condition|)
comment|/* 		 * Backspace past beginning of the string: 		 * this usually means abort the command. 		 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|control_char
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
condition|)
block|{
comment|/* 		 * Erase an extra character, for the carat. 		 */
name|backspace
argument_list|()
expr_stmt|;
name|cmd_col
operator|--
expr_stmt|;
block|}
name|backspace
argument_list|()
expr_stmt|;
name|cmd_col
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the display to start a new multi-character command.  */
end_comment

begin_macro
name|start_mcc
argument_list|()
end_macro

begin_block
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|mcc
argument_list|)
expr_stmt|;
name|cmd_col
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process a single character of a multi-character command, such as  * a number, or the pattern of a search command.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
name|erase_char
condition|)
block|{
if|if
condition|(
name|cmd_erase
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|kill_char
condition|)
block|{
comment|/* {{ Could do this faster, but who cares? }} */
while|while
condition|(
name|cmd_erase
argument_list|()
operator|==
literal|0
condition|)
empty_stmt|;
block|}
else|else
block|{
comment|/* 		 * Append the character to the string, 		 * if there is room in the buffer and on the screen. 		 */
if|if
condition|(
name|cp
operator|<
operator|&
name|cmdbuf
index|[
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
operator|-
literal|1
index|]
operator|&&
name|cmd_col
operator|<
name|sc_width
operator|-
literal|3
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|cmd_col
operator|++
expr_stmt|;
name|c
operator|=
name|carat_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cmd_col
operator|++
expr_stmt|;
block|}
else|else
name|bell
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number currently in the command buffer.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_int
parameter_list|()
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|cmdbuf
expr_stmt|;
return|return
operator|(
name|atoi
argument_list|(
name|cmdbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move the cursor to lower left before executing a command.  * This looks nicer if the command takes a long time before  * updating the screen.  */
end_comment

begin_function
specifier|static
name|void
name|cmd_exec
parameter_list|()
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display the appropriate prompt.  */
end_comment

begin_function
specifier|static
name|void
name|prompt
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|first_cmd
operator|!=
name|NULL
operator|&&
operator|*
name|first_cmd
operator|!=
literal|'\0'
condition|)
comment|/* 		 * No prompt necessary if commands are from first_cmd 		 * rather than from the user. 		 */
return|return;
comment|/* 	 * Select the proper prompt and display it. 	 */
name|p
operator|=
name|pr_string
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|putc
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
else|else
block|{
name|so_enter
argument_list|()
expr_stmt|;
name|puts
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|so_exit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get command character.  * The character normally comes from the keyboard,  * but may come from the "first_cmd" string.  */
end_comment

begin_function
specifier|static
name|int
name|getcc
parameter_list|()
block|{
if|if
condition|(
name|first_cmd
operator|==
name|NULL
condition|)
return|return
operator|(
name|getc
argument_list|()
operator|)
return|;
if|if
condition|(
operator|*
name|first_cmd
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Reached end of first_cmd input. 		 */
name|first_cmd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|position
argument_list|(
name|TOP
argument_list|)
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * Command is incomplete, so try to complete it. 			 * There are only two cases: 			 * 1. We have "/string" but no newline.  Add the \n. 			 * 2. We have a number but no command.  Treat as #g. 			 * (This is all pretty hokey.) 			 */
if|if
condition|(
name|mcc
operator|!=
literal|':'
condition|)
return|return
operator|(
literal|'\n'
operator|)
return|;
else|else
return|return
operator|(
literal|'g'
operator|)
return|;
block|}
return|return
operator|(
name|getc
argument_list|()
operator|)
return|;
block|}
return|return
operator|(
operator|*
name|first_cmd
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main command processor.  * Accept and execute commands until a quit command, then return.  */
end_comment

begin_function
name|public
name|void
name|commands
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|scroll
init|=
literal|10
decl_stmt|;
name|mcc
operator|=
name|last_mcc
operator|=
literal|0
expr_stmt|;
name|setjmp
argument_list|(
name|main_loop
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Display prompt and accept a character. 		 */
name|psignals
argument_list|()
expr_stmt|;
comment|/* See if any signals need processing */
if|if
condition|(
name|quit_at_eof
operator|&&
name|hit_eof
operator|>
literal|1
condition|)
comment|/* 			 * After hitting end-of-file for the second time, 			 * automatically advance to the next file. 			 * If there are no more files, quit. 			 */
name|next_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cmd_reset
argument_list|()
expr_stmt|;
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|prompt
argument_list|()
expr_stmt|;
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
name|sigs
condition|)
continue|continue;
if|if
condition|(
name|mcc
condition|)
block|{
comment|/* 			 * We are in a multi-character command.   			 * All chars until newline go into the command buffer. 			 * (Note that mcc == ':' is a special case that 			 *  means a number is being entered.) 			 */
if|if
condition|(
name|mcc
operator|!=
literal|':'
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
operator|)
condition|)
block|{
comment|/* 				 * Execute the command. 				 */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cmd_exec
argument_list|()
expr_stmt|;
if|if
condition|(
name|mcc
operator|==
literal|'E'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 					 * Ignore leading spaces  					 * in the filename. 					 */
for|for
control|(
name|p
operator|=
name|cmdbuf
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|edit
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|SHELL_ESCAPE
block|}
elseif|else
if|if
condition|(
name|mcc
operator|==
literal|'!'
condition|)
block|{
name|lsystem
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"!done"
argument_list|)
expr_stmt|;
name|first_cmd
operator|=
literal|"r"
expr_stmt|;
comment|/* Repaint */
endif|#
directive|endif
block|}
else|else
name|search
argument_list|(
name|mcc
argument_list|,
name|cmdbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mcc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mcc
operator|==
literal|':'
operator|&&
operator|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|)
operator|&&
name|c
operator|!=
name|erase_char
operator|&&
name|c
operator|!=
name|kill_char
condition|)
block|{
comment|/* 					 * This is not part of the number 					 * we were entering.  Process 					 * it as a regular character. 					 */
name|mcc
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 				 * Append the char to the command buffer. 				 */
if|if
condition|(
name|cmd_char
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Abort the multi-char command. */
name|mcc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* 			 * First digit of a number. 			 */
name|mcc
operator|=
literal|':'
expr_stmt|;
name|start_mcc
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'f'
case|:
case|case
literal|' '
case|:
case|case
name|CONTROL
argument_list|(
literal|'F'
argument_list|)
case|:
comment|/* 			 * Forward one screen. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
name|sc_height
operator|-
literal|1
expr_stmt|;
name|forward
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
name|CONTROL
argument_list|(
literal|'B'
argument_list|)
case|:
comment|/* 			 * Backward one screen. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
name|sc_height
operator|-
literal|1
expr_stmt|;
name|backward
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'j'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
name|CONTROL
argument_list|(
literal|'E'
argument_list|)
case|:
comment|/* 			 * Forward N (default 1) line. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|forward
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'k'
case|:
case|case
name|CONTROL
argument_list|(
literal|'K'
argument_list|)
case|:
case|case
name|CONTROL
argument_list|(
literal|'Y'
argument_list|)
case|:
comment|/* 			 * Backward N (default 1) line. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|backward
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
name|CONTROL
argument_list|(
literal|'D'
argument_list|)
case|:
comment|/* 			 * Forward N lines  			 * (default same as last 'd' or 'u' command). 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|scroll
operator|=
name|n
expr_stmt|;
name|forward
argument_list|(
name|scroll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
name|CONTROL
argument_list|(
literal|'U'
argument_list|)
case|:
comment|/* 			 * Forward N lines  			 * (default same as last 'd' or 'u' command). 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|scroll
operator|=
name|n
expr_stmt|;
name|backward
argument_list|(
name|scroll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* 			 * Flush buffers, then repaint screen. 			 */
name|ch_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall thru */
case|case
literal|'r'
case|:
case|case
name|CONTROL
argument_list|(
literal|'R'
argument_list|)
case|:
case|case
name|CONTROL
argument_list|(
literal|'L'
argument_list|)
case|:
comment|/* 			 * Repaint screen. 			 */
name|repaint
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* 			 * Go to line N, default beginning of file. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|cmd_exec
argument_list|()
expr_stmt|;
name|jump_back
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'%'
case|:
comment|/* 			 * Go to a specified percentage into the file. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|100
condition|)
name|n
operator|=
literal|100
expr_stmt|;
name|cmd_exec
argument_list|()
expr_stmt|;
name|jump_percent
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* 			 * Go to line N, default end of file. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
name|cmd_exec
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|jump_forw
argument_list|()
expr_stmt|;
else|else
name|jump_back
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
case|case
name|CONTROL
argument_list|(
literal|'G'
argument_list|)
case|:
comment|/* 			 * Print file name, etc. 			 */
name|error
argument_list|(
name|eq_message
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* 			 * Print version number, without the "@(#)". 			 */
name|error
argument_list|(
name|version
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* 			 * Exit. 			 */
return|return;
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
comment|/* 			 * Search for a pattern. 			 * Accept chars of the pattern until \n. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|mcc
operator|=
name|last_mcc
operator|=
name|c
expr_stmt|;
name|start_mcc
argument_list|()
expr_stmt|;
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'n'
case|:
comment|/* 			 * Repeat previous search. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|mcc
operator|=
name|last_mcc
expr_stmt|;
name|start_mcc
argument_list|()
expr_stmt|;
name|cmd_exec
argument_list|()
expr_stmt|;
name|search
argument_list|(
name|mcc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mcc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* 			 * Help. 			 */
name|help
argument_list|()
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* 			 * Edit a new file.  Get the filename. 			 */
name|cmd_reset
argument_list|()
expr_stmt|;
name|mcc
operator|=
literal|'E'
expr_stmt|;
name|start_mcc
argument_list|()
expr_stmt|;
name|puts
argument_list|(
literal|"dit: "
argument_list|)
expr_stmt|;
comment|/* This looks nicer */
name|cmd_col
operator|+=
literal|5
expr_stmt|;
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
if|#
directive|if
name|SHELL_ESCAPE
case|case
literal|'!'
case|:
comment|/* 			 * Shell escape. 			 */
name|cmd_reset
argument_list|()
expr_stmt|;
name|mcc
operator|=
literal|'!'
expr_stmt|;
name|start_mcc
argument_list|()
expr_stmt|;
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
endif|#
directive|endif
if|#
directive|if
name|EDITOR
case|case
literal|'v'
case|:
if|if
condition|(
name|ispipe
condition|)
block|{
name|error
argument_list|(
literal|"Cannot edit standard input"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
literal|"%s %s"
argument_list|,
name|editor
argument_list|,
name|current_file
argument_list|)
expr_stmt|;
name|lsystem
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
name|first_cmd
operator|=
literal|"R"
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'N'
case|:
comment|/* 			 * Examine next file. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|next_file
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* 			 * Examine previous file. 			 */
name|n
operator|=
name|cmd_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|prev_file
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* 			 * Toggle a flag setting. 			 */
name|mcc
operator|=
literal|'-'
expr_stmt|;
name|start_mcc
argument_list|()
expr_stmt|;
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
name|mcc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|erase_char
operator|||
name|c
operator|==
name|kill_char
condition|)
break|break;
name|toggle_option
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* 			 * Set a mark. 			 */
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|puts
argument_list|(
literal|"mark: "
argument_list|)
expr_stmt|;
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|erase_char
operator|||
name|c
operator|==
name|kill_char
condition|)
break|break;
name|setmark
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* 			 * Go to a mark. 			 */
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|puts
argument_list|(
literal|"goto mark: "
argument_list|)
expr_stmt|;
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|erase_char
operator|||
name|c
operator|==
name|kill_char
condition|)
break|break;
name|gomark
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bell
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

end_unit

