begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Process command line options.  * Each option is a single letter which controls a program variable.  * The options have defaults which may be changed via  * the command line option, or toggled via the "-" command.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|((c)-'a'+'A')
end_define

begin_comment
comment|/*  * Types of options.  */
end_comment

begin_define
define|#
directive|define
name|BOOL
value|01
end_define

begin_comment
comment|/* Boolean option: 0 or 1 */
end_comment

begin_define
define|#
directive|define
name|TRIPLE
value|02
end_define

begin_comment
comment|/* Triple-valued option: 0, 1 or 2 */
end_comment

begin_define
define|#
directive|define
name|NUMBER
value|04
end_define

begin_comment
comment|/* Numeric option */
end_comment

begin_define
define|#
directive|define
name|NO_TOGGLE
value|0100
end_define

begin_comment
comment|/* Option cannot be toggled with "-" cmd */
end_comment

begin_comment
comment|/*  * Variables controlled by command line options.  */
end_comment

begin_decl_stmt
name|public
name|int
name|p_nbufs
decl_stmt|,
name|f_nbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of buffers.  There are two values, 				   one used for input from a pipe and  				   the other for input from a file. */
end_comment

begin_decl_stmt
name|public
name|int
name|clean_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can we assume the data is "clean"?  				   (That is, free of nulls, etc) */
end_comment

begin_decl_stmt
name|public
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we suppress the audible bell? */
end_comment

begin_decl_stmt
name|public
name|int
name|top_search
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should forward searches start at the top  				   of the screen? (alternative is bottom) */
end_comment

begin_decl_stmt
name|public
name|int
name|top_scroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Repaint screen from top? 				   (alternative is scroll from bottom) */
end_comment

begin_decl_stmt
name|public
name|int
name|pr_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of prompt (short, medium, long) */
end_comment

begin_decl_stmt
name|public
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to process backspaces */
end_comment

begin_decl_stmt
name|public
name|int
name|know_dumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't complain about dumb terminals */
end_comment

begin_decl_stmt
name|public
name|int
name|quit_at_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Quit after hitting end of file twice */
end_comment

begin_decl_stmt
name|public
name|int
name|squeeze
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Squeeze multiple blank lines into one */
end_comment

begin_decl_stmt
name|public
name|int
name|tabstop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tab settings */
end_comment

begin_decl_stmt
name|public
name|int
name|back_scroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Repaint screen on backwards movement */
end_comment

begin_decl_stmt
name|public
name|int
name|twiddle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Display "~" for lines after EOF */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|first_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|every_first_cmd
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEF_F_NBUFS
value|5
end_define

begin_comment
comment|/* Default for f_nbufs */
end_comment

begin_define
define|#
directive|define
name|DEF_P_NBUFS
value|12
end_define

begin_comment
comment|/* Default for p_nbufs */
end_comment

begin_struct
specifier|static
struct|struct
name|option
block|{
name|char
name|oletter
decl_stmt|;
comment|/* The controlling letter (a-z) */
name|char
name|otype
decl_stmt|;
comment|/* Type of the option */
name|int
name|odefault
decl_stmt|;
comment|/* Default value */
name|int
modifier|*
name|ovar
decl_stmt|;
comment|/* Pointer to the associated variable */
name|char
modifier|*
name|odesc
index|[
literal|3
index|]
decl_stmt|;
comment|/* Description of each value */
block|}
name|option
index|[]
init|=
block|{
block|{
literal|'c'
block|,
name|BOOL
block|,
literal|0
block|,
operator|&
name|clean_data
block|,
block|{
literal|"Don't assume data is clean"
block|,
literal|"Assume data is clean"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'d'
block|,
name|BOOL
operator||
name|NO_TOGGLE
block|,
literal|0
block|,
operator|&
name|know_dumb
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'e'
block|,
name|BOOL
block|,
literal|0
block|,
operator|&
name|quit_at_eof
block|,
block|{
literal|"Don't quit at end-of-file"
block|,
literal|"Quit at end-of-file"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'h'
block|,
name|NUMBER
block|,
operator|-
literal|1
block|,
operator|&
name|back_scroll
block|,
block|{
literal|"Backwards scroll limit is %d lines"
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'p'
block|,
name|BOOL
block|,
literal|0
block|,
operator|&
name|top_scroll
block|,
block|{
literal|"Repaint by scrolling from bottom of screen"
block|,
literal|"Repaint by painting from top of screen"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'x'
block|,
name|NUMBER
block|,
literal|8
block|,
operator|&
name|tabstop
block|,
block|{
literal|"Tab stops every %d spaces"
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'s'
block|,
name|BOOL
block|,
literal|0
block|,
operator|&
name|squeeze
block|,
block|{
literal|"Don't squeeze multiple blank lines"
block|,
literal|"Squeeze multiple blank lines"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'t'
block|,
name|BOOL
block|,
literal|1
block|,
operator|&
name|top_search
block|,
block|{
literal|"Forward search starts from bottom of screen"
block|,
literal|"Forward search starts from top of screen"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'w'
block|,
name|BOOL
block|,
literal|1
block|,
operator|&
name|twiddle
block|,
block|{
literal|"Display nothing for lines after end-of-file"
block|,
literal|"Display ~ for lines after end-of-file"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'m'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|pr_type
block|,
block|{
literal|"Prompt with a colon"
block|,
literal|"Prompt with a message"
block|,
literal|"Prompt with a verbose message"
block|}
block|}
block|,
block|{
literal|'q'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|quiet
block|,
block|{
literal|"Ring the bell for errors AND at eof/bof"
block|,
literal|"Ring the bell for errors but not at eof/bof"
block|,
literal|"Never ring the bell"
block|}
block|}
block|,
block|{
literal|'u'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|bs_mode
block|,
block|{
literal|"Underlined text displayed in underline mode"
block|,
literal|"All backspaces cause overstrike"
block|,
literal|"Backspaces print as ^H"
block|}
block|}
block|,
block|{
literal|'\0'
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|public
name|char
name|all_options
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all valid options */
end_comment

begin_comment
comment|/*  * Initialize each option to its default value.  */
end_comment

begin_function
name|public
name|void
name|init_option
parameter_list|()
block|{
specifier|register
name|struct
name|option
modifier|*
name|o
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * First do special cases, not in option table. 	 */
name|first_cmd
operator|=
name|every_first_cmd
operator|=
name|NULL
expr_stmt|;
name|f_nbufs
operator|=
name|DEF_F_NBUFS
expr_stmt|;
comment|/* -bf */
name|p_nbufs
operator|=
name|DEF_P_NBUFS
expr_stmt|;
comment|/* -bp */
name|p
operator|=
name|all_options
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'b'
expr_stmt|;
for|for
control|(
name|o
operator|=
name|option
init|;
name|o
operator|->
name|oletter
operator|!=
literal|'\0'
condition|;
name|o
operator|++
control|)
block|{
comment|/* 		 * Set each variable to its default. 		 * Also make a list of all options, in "all_options". 		 */
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|o
operator|->
name|odefault
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|o
operator|->
name|oletter
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
condition|)
operator|*
name|p
operator|++
operator|=
name|toupper
argument_list|(
name|o
operator|->
name|oletter
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Toggle command line flags from within the program.  * Used by the "-" command.  */
end_comment

begin_function
name|public
name|void
name|toggle_option
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|option
modifier|*
name|o
decl_stmt|;
name|char
name|message
index|[
literal|100
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
comment|/* 	 * First check for special cases not handled by the option table. 	 */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%d buffers"
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|o
operator|=
name|option
init|;
name|o
operator|->
name|oletter
operator|!=
literal|'\0'
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|BOOL
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
operator|&&
operator|(
name|o
operator|->
name|otype
operator|&
name|NO_TOGGLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Boolean option:  			 * just toggle it. 			 */
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|!
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
expr_stmt|;
name|error
argument_list|(
name|o
operator|->
name|odesc
index|[
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
operator|&&
operator|(
name|o
operator|->
name|otype
operator|&
name|NO_TOGGLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Triple-valued option with lower case letter: 			 * make it 1 unless already 1, then make it 0. 			 */
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|error
argument_list|(
name|o
operator|->
name|odesc
index|[
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|toupper
argument_list|(
name|o
operator|->
name|oletter
argument_list|)
operator|==
name|c
operator|)
operator|&&
operator|(
name|o
operator|->
name|otype
operator|&
name|NO_TOGGLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Triple-valued option with upper case letter: 			 * make it 2 unless already 2, then make it 0. 			 */
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|==
literal|2
operator|)
condition|?
literal|0
else|:
literal|2
expr_stmt|;
name|error
argument_list|(
name|o
operator|->
name|odesc
index|[
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|NUMBER
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
operator|&&
operator|(
name|o
operator|->
name|otype
operator|&
name|NO_TOGGLE
operator|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
name|o
operator|->
name|odesc
index|[
literal|0
index|]
argument_list|,
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"^%c"
argument_list|,
name|carat_char
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"\"-%s\": no such flag.  Use one of \"%s\""
argument_list|,
name|buf
argument_list|,
name|all_options
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan an argument (either from command line or from LESS environment   * variable) and process it.  */
end_comment

begin_function
name|public
name|void
name|scan_option
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|option
modifier|*
name|o
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|next
label|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
goto|goto
name|next
goto|;
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|every_first_cmd
operator|=
operator|++
name|s
expr_stmt|;
name|first_cmd
operator|=
name|s
expr_stmt|;
return|return;
case|case
literal|'b'
case|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'f'
case|:
name|s
operator|++
expr_stmt|;
name|f_nbufs
operator|=
name|getnum
argument_list|(
operator|&
name|s
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|s
operator|++
expr_stmt|;
name|p_nbufs
operator|=
name|getnum
argument_list|(
operator|&
name|s
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|f_nbufs
operator|=
name|p_nbufs
operator|=
name|getnum
argument_list|(
operator|&
name|s
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next
goto|;
block|}
for|for
control|(
name|o
operator|=
name|option
init|;
name|o
operator|->
name|oletter
operator|!=
literal|'\0'
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|BOOL
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|!
name|o
operator|->
name|odefault
expr_stmt|;
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
name|o
operator|->
name|odefault
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|toupper
argument_list|(
name|o
operator|->
name|oletter
argument_list|)
operator|==
name|c
operator|)
condition|)
block|{
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
name|o
operator|->
name|odefault
operator|==
literal|2
operator|)
condition|?
literal|0
else|:
literal|2
expr_stmt|;
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|NUMBER
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|getnum
argument_list|(
operator|&
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
name|printf
argument_list|(
literal|"\"-%c\": invalid flag\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Translate a string into a number.  * Like atoi(), but takes a pointer to a char *, and updates  * the char * to point after the translated number.  */
end_comment

begin_function
specifier|static
name|int
name|getnum
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|s
operator|=
operator|*
name|sp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|<
literal|'0'
operator|||
operator|*
name|s
operator|>
literal|'9'
condition|)
block|{
name|printf
argument_list|(
literal|"number is required after -%c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|sp
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

