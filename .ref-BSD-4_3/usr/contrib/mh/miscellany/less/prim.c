begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Primitives for displaying the file on the screen.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_decl_stmt
name|public
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keeps track of how many times we hit end of file */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|top_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|top_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|back_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|first_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Sound the bell to indicate he is trying to move past end of file.  */
end_comment

begin_function
specifier|static
name|void
name|eof_bell
parameter_list|()
block|{
if|if
condition|(
name|quiet
operator|==
name|NOT_QUIET
condition|)
name|bell
argument_list|()
expr_stmt|;
else|else
name|vbell
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the end of file is currently "displayed".  */
end_comment

begin_function
specifier|static
name|void
name|eof_check
parameter_list|()
block|{
name|POSITION
name|pos
decl_stmt|;
comment|/* 	 * If the bottom line is empty, we are at EOF. 	 * If the bottom line ends at the file length, 	 * we must be just at EOF. 	 */
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
operator|||
name|pos
operator|==
name|ch_length
argument_list|()
condition|)
name|hit_eof
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n lines, scrolling forward,   * starting at position pos in the input file.  * "force" means display the n lines even if we hit end of file.  * "only_last" means display only the last screenful if n> screen size.  */
end_comment

begin_function
specifier|static
name|void
name|forw
parameter_list|(
name|n
parameter_list|,
name|pos
parameter_list|,
name|force
parameter_list|,
name|only_last
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|int
name|force
decl_stmt|;
name|int
name|only_last
decl_stmt|;
block|{
name|int
name|eof
init|=
literal|0
decl_stmt|;
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|repaint_flag
decl_stmt|;
comment|/* 	 * repaint_flag tells us not to display anything till the end,  	 * then just repaint the entire screen. 	 */
name|repaint_flag
operator|=
operator|(
name|only_last
operator|&&
name|n
operator|>
name|sc_height
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|repaint_flag
condition|)
block|{
if|if
condition|(
name|top_scroll
operator|&&
name|n
operator|>=
name|sc_height
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Start a new screen. 			 * {{ This is not really desirable if we happen 			 *    to hit eof in the middle of this screen, 			 *    but we don't know if that will happen now. }} 			 */
name|clear
argument_list|()
expr_stmt|;
name|home
argument_list|()
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|!=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
condition|)
block|{
comment|/* 			 * This is not contiguous with what is 			 * currently displayed.  Clear the screen image  			 * (position table) and start a new screen. 			 */
name|pos_clear
argument_list|()
expr_stmt|;
name|add_forw_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|top_scroll
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|home
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|puts
argument_list|(
literal|"...skipping...\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Read the next line of input. 		 */
name|pos
operator|=
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * End of file: stop here unless the top line  			 * is still empty, or "force" is true. 			 */
name|eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|position
argument_list|(
name|TOP
argument_list|)
operator|!=
name|NULL_POSITION
condition|)
break|break;
name|line
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Add the position of the next line to the position table. 		 * Display the current line on the screen. 		 */
name|add_forw_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repaint_flag
condition|)
name|put_line
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|eof
condition|)
name|hit_eof
operator|++
expr_stmt|;
else|else
name|eof_check
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|eof_bell
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|repaint_flag
condition|)
name|repaint
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n lines, scrolling backward.  */
end_comment

begin_function
specifier|static
name|void
name|back
parameter_list|(
name|n
parameter_list|,
name|pos
parameter_list|,
name|force
parameter_list|,
name|only_last
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|int
name|force
decl_stmt|;
name|int
name|only_last
decl_stmt|;
block|{
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|repaint_flag
decl_stmt|;
name|repaint_flag
operator|=
operator|(
name|n
operator|>
name|back_scroll
operator|||
operator|(
name|only_last
operator|&&
name|n
operator|>
name|sc_height
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|hit_eof
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Get the previous line of input. 		 */
name|pos
operator|=
name|back_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * Beginning of file: stop here unless "force" is true. 			 */
if|if
condition|(
operator|!
name|force
condition|)
break|break;
name|line
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Add the position of the previous line to the position table. 		 * Display the line on the screen. 		 */
name|add_back_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repaint_flag
condition|)
block|{
name|home
argument_list|()
expr_stmt|;
name|add_line
argument_list|()
expr_stmt|;
name|put_line
argument_list|()
expr_stmt|;
block|}
block|}
name|eof_check
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|eof_bell
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|repaint_flag
condition|)
name|repaint
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n more lines, forward.  * Start just after the line currently displayed at the bottom of the screen.  */
end_comment

begin_function
name|public
name|void
name|forward
parameter_list|(
name|n
parameter_list|,
name|only_last
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|only_last
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
name|eof_bell
argument_list|()
expr_stmt|;
name|hit_eof
operator|++
expr_stmt|;
return|return;
block|}
name|forw
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
name|only_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display n more lines, backward.  * Start just before the line currently displayed at the top of the screen.  */
end_comment

begin_function
name|public
name|void
name|backward
parameter_list|(
name|n
parameter_list|,
name|only_last
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|only_last
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/*  		 * This will almost never happen, 		 * because the top line is almost never empty.  		 */
name|eof_bell
argument_list|()
expr_stmt|;
return|return;
block|}
name|back
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
name|only_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Repaint the screen, starting from a specified position.  */
end_comment

begin_function
specifier|static
name|void
name|prepaint
parameter_list|(
name|pos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
block|{
name|hit_eof
operator|=
literal|0
expr_stmt|;
name|forw
argument_list|(
name|sc_height
operator|-
literal|1
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Repaint the screen.  */
end_comment

begin_function
name|public
name|void
name|repaint
parameter_list|()
block|{
comment|/* 	 * Start at the line currently at the top of the screen 	 * and redisplay the screen. 	 */
name|prepaint
argument_list|(
name|position
argument_list|(
name|TOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jump to the end of the file.  * It is more convenient to paint the screen backward,  * from the end of the file toward the beginning.  */
end_comment

begin_function
name|public
name|void
name|jump_forw
parameter_list|()
block|{
name|POSITION
name|pos
decl_stmt|;
if|if
condition|(
name|ch_end_seek
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to end of file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|pos_clear
argument_list|()
expr_stmt|;
name|add_back_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|back
argument_list|(
name|sc_height
operator|-
literal|1
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jump to line n in the file.  */
end_comment

begin_function
name|public
name|void
name|jump_back
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* 	 * This is done the slow way, by starting at the beginning 	 * of the file and counting newlines. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
operator|(
name|POSITION
operator|)
literal|0
argument_list|)
condition|)
block|{
comment|/*  		 * Probably a pipe with beginning of file no longer buffered.  		 */
name|error
argument_list|(
literal|"Cannot get to beginning of file"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Start counting lines. 	 */
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|"File is not that long"
argument_list|)
expr_stmt|;
comment|/* {{ Maybe tell him how long it is? }} */
return|return;
block|}
block|}
comment|/* 	 * Finally found the place to start. 	 * Clear and redisplay the screen from there. 	 * 	 * {{ We *could* figure out if the new position is  	 *    close enough to just scroll there without clearing 	 *    the screen, but it's not worth it. }} 	 */
name|prepaint
argument_list|(
name|ch_tell
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jump to a specified percentage into the file.  * This is a poor compensation for not being able to  * quickly jump to a specific line number.  */
end_comment

begin_function
name|public
name|void
name|jump_percent
parameter_list|(
name|percent
parameter_list|)
name|int
name|percent
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * Determine the position in the file 	 * (the specified percentage of the file's length). 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|==
name|NULL_POSITION
condition|)
block|{
name|error
argument_list|(
literal|"Don't know length of file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
operator|(
name|percent
operator|*
name|len
operator|)
operator|/
literal|100
expr_stmt|;
name|jump_loc
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|void
name|jump_loc
parameter_list|(
name|pos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|nline
decl_stmt|;
name|POSITION
name|tpos
decl_stmt|;
comment|/* 	 * See if the desired line is BEFORE the currently 	 * displayed screen.  If so, see if it is close enough  	 * to scroll backwards to it. 	 */
name|tpos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|tpos
condition|)
block|{
for|for
control|(
name|nline
operator|=
literal|1
init|;
name|nline
operator|<=
name|back_scroll
condition|;
name|nline
operator|++
control|)
block|{
name|tpos
operator|=
name|back_line
argument_list|(
name|tpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpos
operator|==
name|NULL_POSITION
operator|||
name|tpos
operator|<=
name|pos
condition|)
block|{
name|back
argument_list|(
name|nline
argument_list|,
name|position
argument_list|(
name|TOP
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|nline
operator|=
name|onscreen
argument_list|(
name|pos
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * The line is currently displayed.   		 * Just scroll there. 		 */
name|forw
argument_list|(
name|nline
argument_list|,
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Line is not on screen. 	 * Back up to the beginning of the current line. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to that position"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|ch_back_get
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|ch_forw_get
argument_list|()
expr_stmt|;
comment|/* 	 * Clear and paint the screen. 	 */
name|prepaint
argument_list|(
name|ch_tell
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The table of marks.  * A mark is simply a position in the file.  */
end_comment

begin_decl_stmt
specifier|static
name|POSITION
name|marks
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the mark table to show no marks are set.  */
end_comment

begin_function
name|public
name|void
name|init_mark
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
name|marks
index|[
name|i
index|]
operator|=
name|NULL_POSITION
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if a mark letter is valid (between a and z).  */
end_comment

begin_function
specifier|static
name|int
name|badmark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
condition|)
block|{
name|error
argument_list|(
literal|"Choose a letter between 'a' and 'z'"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a mark.  */
end_comment

begin_function
name|public
name|void
name|setmark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|badmark
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|marks
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Go to a previously set mark.  */
end_comment

begin_function
name|public
name|void
name|gomark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
if|if
condition|(
name|badmark
argument_list|(
name|c
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|pos
operator|=
name|marks
index|[
name|c
operator|-
literal|'a'
index|]
operator|)
operator|==
name|NULL_POSITION
condition|)
name|error
argument_list|(
literal|"mark not set"
argument_list|)
expr_stmt|;
else|else
name|jump_loc
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Search for the n-th occurence of a specified pattern,   * either forward (direction == '/'), or backwards (direction == '?').  */
end_comment

begin_function
name|public
name|void
name|search
parameter_list|(
name|direction
parameter_list|,
name|pattern
parameter_list|,
name|n
parameter_list|)
name|int
name|direction
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|search_forward
init|=
operator|(
name|direction
operator|==
literal|'/'
operator|)
decl_stmt|;
name|POSITION
name|pos
decl_stmt|,
name|linepos
decl_stmt|;
if|#
directive|if
name|RECOMP
name|char
modifier|*
name|re_comp
parameter_list|()
function_decl|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* 	 * (re_comp handles a null pattern internally,  	 *  so there is no need to check for a null pattern here.) 	 */
if|if
condition|(
operator|(
name|errmsg
operator|=
name|re_comp
argument_list|(
name|pattern
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|#
directive|if
name|REGCMP
name|char
modifier|*
name|regcmp
parameter_list|()
function_decl|;
specifier|static
name|char
modifier|*
name|cpattern
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * A null pattern means use the previous pattern. 		 * The compiled previous pattern is in cpattern, so just use it. 		 */
if|if
condition|(
name|cpattern
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* 		 * Otherwise compile the given pattern. 		 */
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|regcmp
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid pattern"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cpattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cpattern
argument_list|)
expr_stmt|;
name|cpattern
operator|=
name|s
expr_stmt|;
block|}
else|#
directive|else
specifier|static
name|char
name|lpbuf
index|[
literal|100
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_pattern
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Null pattern means use the previous pattern. 		 */
if|if
condition|(
name|last_pattern
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pattern
operator|=
name|last_pattern
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|lpbuf
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|last_pattern
operator|=
name|lpbuf
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Figure out where to start the search. 	 */
if|if
condition|(
name|position
argument_list|(
name|TOP
argument_list|)
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 		 * Nothing is currently displayed. 		 * Start at the beginning of the file. 		 * (This case is mainly for first_cmd searches, 		 * for example, "+/xyz" on the command line.) 		 */
name|pos
operator|=
operator|(
name|POSITION
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|search_forward
condition|)
block|{
comment|/* 		 * Backward search: start just before the top line 		 * displayed on the screen. 		 */
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|top_search
condition|)
block|{
comment|/* 		 * Forward search and "start from top". 		 * Start at the second line displayed on the screen. 		 */
name|pos
operator|=
name|position
argument_list|(
name|TOP_PLUS_ONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Forward search but don't "start from top". 		 * Start just after the bottom line displayed on the screen. 		 */
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 		 * Can't find anyplace to start searching from. 		 */
name|error
argument_list|(
literal|"Nothing to search"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get lines until we find a matching one or  		 * until we hit end-of-file (or beginning-of-file  		 * if we're going backwards). 		 */
if|if
condition|(
name|sigs
condition|)
comment|/* 			 * A signal aborts the search. 			 */
return|return;
if|if
condition|(
name|search_forward
condition|)
block|{
comment|/* 			 * Read the next line, and save the  			 * starting position of that line in linepos. 			 */
name|linepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Read the previous line and save the 			 * starting position of that line in linepos. 			 */
name|pos
operator|=
name|back_raw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|linepos
operator|=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * We hit EOF/BOF without a match. 			 */
name|error
argument_list|(
literal|"Pattern not found"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Test the next line to see if we have a match. 		 * This is done in a variety of ways, depending 		 * on what pattern matching functions are available. 		 */
if|#
directive|if
name|REGCMP
if|if
condition|(
operator|(
name|regex
argument_list|(
name|cpattern
argument_list|,
name|line
argument_list|)
operator|!=
name|NULL
operator|)
else|#
directive|else
if|#
directive|if
name|RECOMP
if|if
condition|(
operator|(
name|re_exec
argument_list|(
name|line
argument_list|)
operator|==
literal|1
operator|)
else|#
directive|else
if|if
condition|(
operator|(
name|match
argument_list|(
name|pattern
argument_list|,
name|line
argument_list|)
operator|)
endif|#
directive|endif
endif|#
directive|endif
operator|&&
operator|(
operator|--
name|n
operator|<=
literal|0
operator|)
condition|)
comment|/* 			 * Found the matching line. 			 */
break|break;
block|}
name|jump_loc
argument_list|(
name|linepos
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
operator|!
name|REGCMP
operator|)
operator|&&
operator|(
operator|!
name|RECOMP
operator|)
end_if

begin_comment
comment|/*  * We have neither regcmp() nor re_comp().  * We use this function to do simple pattern matching.  * It supports no metacharacters like *, etc.  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|pattern
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
for|for
control|(
init|;
operator|*
name|buf
operator|!=
literal|'\0'
condition|;
name|buf
operator|++
control|)
block|{
for|for
control|(
name|pp
operator|=
name|pattern
operator|,
name|lp
operator|=
name|buf
init|;
operator|*
name|pp
operator|==
operator|*
name|lp
condition|;
name|pp
operator|++
operator|,
name|lp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
operator|==
literal|'\0'
operator|||
operator|*
name|lp
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|*
name|pp
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

