begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dropsbr.c - write to a mailbox */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MMDFONLY
end_ifndef

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_else
else|#
directive|else
else|MMDFONLY
end_else

begin_include
include|#
directive|include
file|"dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"strings.h"
end_include

begin_include
include|#
directive|include
file|"mmdfonly.h"
end_include

begin_endif
endif|#
directive|endif
endif|MMDFONLY
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|MMDF
value|1
end_define

begin_define
define|#
directive|define
name|UUCP
value|2
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|mbx_style
init|=
name|MMDF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_mmdf
parameter_list|()
block|{
name|int
name|style
init|=
name|mbx_style
decl_stmt|;
name|mbx_style
operator|=
name|MMDF
expr_stmt|;
return|return
name|style
return|;
block|}
end_function

begin_function
name|int
name|mbx_uucp
parameter_list|()
block|{
name|int
name|style
init|=
name|mbx_style
decl_stmt|;
name|mbx_style
operator|=
name|UUCP
expr_stmt|;
return|return
name|style
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_open
parameter_list|(
name|file
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|,
name|mode
decl_stmt|;
block|{
name|int
name|clear
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mbx_Xopen
argument_list|(
name|file
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|mode
argument_list|,
operator|&
name|clear
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|fd
return|;
if|if
condition|(
operator|!
name|clear
condition|)
switch|switch
condition|(
name|mbx_style
condition|)
block|{
case|case
name|MMDF
case|:
default|default:
if|if
condition|(
name|mbx_chk
argument_list|(
name|fd
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
break|break;
case|case
name|UUCP
case|:
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
operator|==
operator|(
name|long
operator|)
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
break|break;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_Xopen
parameter_list|(
name|file
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|,
name|mode
parameter_list|,
name|clear
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|,
name|mode
decl_stmt|,
decl|*
name|clear
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|count
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
for|for
control|(
operator|*
name|clear
operator|=
literal|0
operator|,
name|count
operator|=
literal|4
operator|,
name|j
operator|=
literal|0
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
if|if
condition|(
operator|(
name|fd
operator|=
name|lkopen
argument_list|(
name|file
argument_list|,
literal|6
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
if|if
condition|(
name|mbx_create
argument_list|(
name|file
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|mode
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
operator|*
name|clear
operator|)
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BSD42
case|case
name|EWOULDBLOCK
case|:
endif|#
directive|endif
endif|BSD42
case|case
name|ETXTBSY
case|:
name|j
operator|=
name|errno
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NOTOK
return|;
block|}
else|else
block|{
operator|*
name|clear
operator|=
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|st
operator|.
name|st_size
operator|==
literal|0L
expr_stmt|;
break|break;
block|}
name|errno
operator|=
name|j
expr_stmt|;
return|return
name|fd
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|mbx_create
parameter_list|(
name|file
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|,
name|mode
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|file
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mbx_chk
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|char
name|ldelim
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|count
operator|=
name|strlen
argument_list|(
name|mmdlm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|-
name|count
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
operator|(
name|long
operator|)
name|NOTOK
operator|||
name|read
argument_list|(
name|fd
argument_list|,
name|ldelim
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
return|return
name|NOTOK
return|;
name|ldelim
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ldelim
argument_list|,
name|mmdlm2
argument_list|)
operator|&&
name|write
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|&&
name|write
argument_list|(
name|fd
argument_list|,
name|mmdlm2
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_read
parameter_list|(
name|fp
parameter_list|,
name|pos
parameter_list|,
name|drops
parameter_list|,
name|noisy
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
name|struct
name|drop
modifier|*
modifier|*
name|drops
decl_stmt|;
name|int
name|noisy
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|size
decl_stmt|;
name|long
name|ld1
decl_stmt|,
name|ld2
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|drop
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|=
name|MAXFOLDER
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate drop storage"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ld1
operator|=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|mmdlm1
argument_list|)
expr_stmt|;
name|ld2
operator|=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|mmdlm2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|dp
operator|=
name|pp
operator|)
operator|+
name|len
operator|-
literal|1
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|;
control|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|mmdlm1
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
name|ld1
operator|,
name|dp
operator|->
name|d_start
operator|=
name|pos
expr_stmt|;
else|else
block|{
name|dp
operator|->
name|d_start
operator|=
name|pos
operator|,
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buffer
init|;
operator|*
name|bp
condition|;
name|bp
operator|++
operator|,
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|mmdlm2
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
block|{
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buffer
init|;
operator|*
name|bp
condition|;
name|bp
operator|++
operator|,
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_start
operator|!=
name|pos
condition|)
block|{
name|dp
operator|->
name|d_id
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_size
operator|=
name|size
expr_stmt|;
name|dp
operator|->
name|d_stop
operator|=
name|pos
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
name|pos
operator|+=
name|ld2
expr_stmt|;
if|if
condition|(
name|dp
operator|>=
name|ep
condition|)
block|{
specifier|register
name|int
name|curlen
init|=
name|dp
operator|-
name|pp
decl_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|drop
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|+=
name|MAXFOLDER
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate drop storage"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dp
operator|=
name|cp
operator|+
name|curlen
operator|,
name|ep
operator|=
operator|(
name|pp
operator|=
name|cp
operator|)
operator|+
name|len
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dp
operator|==
name|pp
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|)
expr_stmt|;
else|else
operator|*
name|drops
operator|=
name|pp
expr_stmt|;
return|return
operator|(
name|dp
operator|-
name|pp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_write
parameter_list|(
name|mailbox
parameter_list|,
name|md
parameter_list|,
name|fp
parameter_list|,
name|id
parameter_list|,
name|pos
parameter_list|,
name|stop
parameter_list|,
name|mapping
parameter_list|,
name|noisy
parameter_list|)
name|char
modifier|*
name|mailbox
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|md
decl_stmt|,
name|id
decl_stmt|,
name|mapping
decl_stmt|,
name|noisy
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|,
name|stop
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|size
decl_stmt|;
specifier|register
name|long
name|start
decl_stmt|,
name|off
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|off
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|mmdlm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|mmdlm1
argument_list|,
name|j
argument_list|)
operator|!=
name|j
condition|)
return|return
name|NOTOK
return|;
name|start
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|stop
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|stringdex
argument_list|(
name|mmdlm1
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|j
index|]
operator|++
control|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|stringdex
argument_list|(
name|mmdlm2
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|j
index|]
operator|++
control|)
continue|continue;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
return|return
name|NOTOK
return|;
name|pos
operator|+=
operator|(
name|long
operator|)
name|i
expr_stmt|;
if|if
condition|(
name|mapping
condition|)
for|for
control|(
name|cp
operator|=
name|buffer
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
name|stop
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|mmdlm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|mmdlm2
argument_list|,
name|j
argument_list|)
operator|!=
name|j
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|mapping
condition|)
operator|(
name|void
operator|)
name|map_write
argument_list|(
name|mailbox
argument_list|,
name|md
argument_list|,
name|id
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|noisy
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_copy
parameter_list|(
name|mailbox
parameter_list|,
name|md
parameter_list|,
name|fd
parameter_list|,
name|mapping
parameter_list|,
name|text
parameter_list|,
name|noisy
parameter_list|)
name|char
modifier|*
name|mailbox
decl_stmt|;
name|int
name|md
decl_stmt|,
name|fd
decl_stmt|,
name|mapping
decl_stmt|,
name|noisy
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|size
decl_stmt|;
specifier|register
name|long
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|pos
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mbx_style
condition|)
block|{
case|case
name|MMDF
case|:
default|default:
name|j
operator|=
name|strlen
argument_list|(
name|mmdlm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|mmdlm1
argument_list|,
name|j
argument_list|)
operator|!=
name|j
condition|)
return|return
name|NOTOK
return|;
name|start
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|text
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
return|return
name|NOTOK
return|;
for|for
control|(
name|cp
operator|=
name|buffer
init|;
operator|*
name|cp
operator|++
condition|;
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|stringdex
argument_list|(
name|mmdlm1
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|j
index|]
operator|++
control|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|stringdex
argument_list|(
name|mmdlm2
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|j
index|]
operator|++
control|)
continue|continue;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|mapping
condition|)
for|for
control|(
name|cp
operator|=
name|buffer
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
name|stop
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|mmdlm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|mmdlm2
argument_list|,
name|j
argument_list|)
operator|!=
name|j
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|mapping
condition|)
operator|(
name|void
operator|)
name|map_write
argument_list|(
name|mailbox
argument_list|,
name|md
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
name|noisy
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|!=
name|NOTOK
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
case|case
name|UUCP
case|:
comment|/* I hate this... */
if|if
condition|(
operator|(
name|j
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|j
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|j
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|start
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|text
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
return|return
name|NOTOK
return|;
for|for
control|(
name|cp
operator|=
name|buffer
init|;
operator|*
name|cp
operator|++
condition|;
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
literal|">"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|mapping
condition|)
for|for
control|(
name|cp
operator|=
name|buffer
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stop
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapping
condition|)
operator|(
name|void
operator|)
name|map_write
argument_list|(
name|mailbox
argument_list|,
name|md
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
name|noisy
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_size
parameter_list|(
name|md
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|)
name|int
name|md
decl_stmt|;
name|long
name|start
decl_stmt|,
name|stop
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|md
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
name|stop
operator|-
name|start
init|;
name|pos
operator|--
operator|>
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|mbx_close
parameter_list|(
name|mailbox
parameter_list|,
name|md
parameter_list|)
name|char
modifier|*
name|mailbox
decl_stmt|;
name|int
name|md
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|lkclose
argument_list|(
name|md
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* This function is performed implicitly by getbbent.c:  		bb -> bb_map = map_name (bb -> bb_file); */
end_comment

begin_function
name|char
modifier|*
name|map_name
parameter_list|(
name|file
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|index
argument_list|(
name|cp
operator|=
name|r1bindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|file
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|".%.*s%s"
argument_list|,
name|dp
operator|-
name|cp
argument_list|,
name|cp
argument_list|,
literal|".map"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%.*s.%.*s%s"
argument_list|,
name|cp
operator|-
name|file
argument_list|,
name|file
argument_list|,
name|dp
operator|-
name|cp
argument_list|,
name|cp
argument_list|,
literal|".map"
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|map_read
parameter_list|(
name|file
parameter_list|,
name|pos
parameter_list|,
name|drops
parameter_list|,
name|noisy
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|struct
name|drop
modifier|*
modifier|*
name|drops
decl_stmt|;
name|int
name|noisy
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|md
decl_stmt|,
name|msgp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|drop
name|d
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|mp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|open
argument_list|(
name|cp
operator|=
name|map_name
argument_list|(
name|file
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
name|map_chk
argument_list|(
name|cp
argument_list|,
name|md
argument_list|,
name|mp
operator|=
operator|&
name|d
argument_list|,
name|pos
argument_list|,
name|noisy
argument_list|)
condition|)
block|{
if|if
condition|(
name|md
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|md
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|msgp
operator|=
name|mp
operator|->
name|d_id
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|drop
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|msgp
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|md
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|md
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
expr|*
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
name|msgp
operator|*
sizeof|sizeof
expr|*
name|dp
argument_list|)
operator|)
operator|<
sizeof|sizeof
expr|*
name|dp
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|drops
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|md
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|/
sizeof|sizeof
expr|*
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|map_write
parameter_list|(
name|mailbox
parameter_list|,
name|md
parameter_list|,
name|id
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|pos
parameter_list|,
name|size
parameter_list|,
name|noisy
parameter_list|)
specifier|register
name|char
modifier|*
name|mailbox
decl_stmt|;
name|int
name|md
decl_stmt|,
name|id
decl_stmt|,
name|size
decl_stmt|,
name|noisy
decl_stmt|;
name|long
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|pos
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|clear
decl_stmt|,
name|fd
decl_stmt|,
name|td
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|dp
decl_stmt|;
name|struct
name|drop
name|d1
decl_stmt|,
name|d2
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|map_open
argument_list|(
name|file
operator|=
name|map_name
argument_list|(
name|mailbox
argument_list|)
argument_list|,
operator|&
name|clear
argument_list|,
name|md
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|!
name|clear
operator|&&
name|map_chk
argument_list|(
name|file
argument_list|,
name|fd
argument_list|,
operator|&
name|d1
argument_list|,
name|pos
argument_list|,
name|noisy
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|map_open
argument_list|(
name|file
argument_list|,
operator|&
name|clear
argument_list|,
name|md
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|clear
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|clear
condition|)
block|{
if|if
condition|(
operator|(
name|td
operator|=
name|dup
argument_list|(
name|md
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|td
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|file
argument_list|,
literal|"unable to %s"
argument_list|,
name|td
operator|!=
name|NOTOK
condition|?
literal|"fdopen"
else|:
literal|"dup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
switch|switch
condition|(
name|i
operator|=
name|mbx_read
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
operator|&
name|rp
argument_list|,
name|noisy
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
break|break;
default|default:
name|d1
operator|.
name|d_id
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|rp
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_start
operator|==
name|start
condition|)
name|dp
operator|->
name|d_id
operator|=
name|id
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|++
name|d1
operator|.
name|d_id
operator|*
sizeof|sizeof
expr|*
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
operator|!=
sizeof|sizeof
expr|*
name|dp
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|file
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|dp
operator|=
operator|&
name|d2
expr_stmt|;
name|dp
operator|->
name|d_id
operator|=
name|id
expr_stmt|;
name|dp
operator|->
name|d_size
operator|=
name|size
condition|?
name|size
else|:
name|mbx_size
argument_list|(
name|fd
argument_list|,
name|start
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_start
operator|=
name|start
expr_stmt|;
name|dp
operator|->
name|d_stop
operator|=
name|stop
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|++
name|d1
operator|.
name|d_id
operator|*
sizeof|sizeof
expr|*
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
operator|!=
sizeof|sizeof
expr|*
name|dp
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|file
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
name|dp
operator|=
operator|&
name|d1
expr_stmt|;
name|dp
operator|->
name|d_size
operator|=
name|DRVRSN
expr_stmt|;
name|dp
operator|->
name|d_start
operator|=
name|DRMAGIC
expr_stmt|;
name|dp
operator|->
name|d_stop
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
operator|!=
sizeof|sizeof
expr|*
name|dp
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|file
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|file
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|map_open
parameter_list|(
name|file
parameter_list|,
name|clear
parameter_list|,
name|md
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
modifier|*
name|clear
decl_stmt|,
name|md
decl_stmt|;
block|{
name|int
name|mode
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|mode
operator|=
name|fstat
argument_list|(
name|md
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
call|(
name|int
call|)
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
else|:
name|m_gmprot
argument_list|()
expr_stmt|;
return|return
name|mbx_Xopen
argument_list|(
name|file
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|st
operator|.
name|st_gid
argument_list|,
name|mode
argument_list|,
name|clear
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|map_chk
parameter_list|(
name|file
parameter_list|,
name|fd
parameter_list|,
name|dp
parameter_list|,
name|pos
parameter_list|,
name|noisy
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|noisy
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|dp
decl_stmt|;
name|long
name|pos
decl_stmt|;
block|{
name|long
name|count
decl_stmt|;
name|struct
name|drop
name|d
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
operator|!=
sizeof|sizeof
expr|*
name|dp
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: missing or partial index"
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_size
operator|!=
name|DRVRSN
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: version mismatch"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_start
operator|!=
name|DRMAGIC
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: bad magic number"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_stop
operator|!=
name|pos
condition|)
block|{
if|if
condition|(
name|noisy
operator|&&
name|pos
operator|!=
literal|0L
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: pointer mismatch or incomplete index (%ld!=%ld)"
argument_list|,
name|file
argument_list|,
name|dp
operator|->
name|d_stop
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
call|(
name|long
call|)
argument_list|(
operator|(
name|dp
operator|->
name|d_id
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|dp
argument_list|)
operator|!=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: corrupt index(1)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|dl
operator|=
operator|&
name|d
expr_stmt|;
name|count
operator|=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|mmdlm2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|long
call|)
argument_list|(
name|dp
operator|->
name|d_id
operator|*
sizeof|sizeof
expr|*
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dl
argument_list|,
sizeof|sizeof
expr|*
name|dl
argument_list|)
operator|!=
sizeof|sizeof
expr|*
name|dl
operator|||
operator|(
name|dl
operator|->
name|d_stop
operator|!=
name|dp
operator|->
name|d_stop
operator|&&
name|dl
operator|->
name|d_stop
operator|+
name|count
operator|!=
name|dp
operator|->
name|d_stop
operator|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: corrupt index(2)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
end_function

end_unit

