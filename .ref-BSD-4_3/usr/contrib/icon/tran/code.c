begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines for constructing and traversing parse trees and generating code.  */
end_comment

begin_include
include|#
directive|include
file|"itran.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|nextlab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next label allocated by alclab() */
end_comment

begin_comment
comment|/*  *  tree[1-7] construct parse tree nodes with specified values.  tfree  *   points at the next free word in the parse tree space.  Nodes are  *   built by copying argument values into successive locations starting  *   at tfree.  Parameters a and b are line and column information,  *   while parameters c through f are values to be assigned to n_field[0-3].  *   Note that this could be done with a single routine; a separate routine  *   for each node size is used for speed and simplicity.  */
end_comment

begin_function
name|nodeptr
name|tree1
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|nodeptr
name|t
decl_stmt|;
name|t
operator|=
name|tfree
expr_stmt|;
name|tfree
operator|=
call|(
name|nodeptr
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|tfree
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfree
operator|>
name|tend
condition|)
name|syserr
argument_list|(
literal|"out of tree space"
argument_list|)
expr_stmt|;
name|t
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|nodeptr
name|tree3
parameter_list|(
name|type
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|int
name|type
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
specifier|register
name|nodeptr
name|t
decl_stmt|;
name|t
operator|=
name|tfree
expr_stmt|;
name|tfree
operator|=
call|(
name|nodeptr
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|tfree
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfree
operator|>
name|tend
condition|)
name|syserr
argument_list|(
literal|"out of tree space"
argument_list|)
expr_stmt|;
name|t
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|n_line
operator|=
name|a
expr_stmt|;
name|t
operator|->
name|n_col
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|nodeptr
name|tree4
parameter_list|(
name|type
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|int
name|type
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|nodeptr
name|t
decl_stmt|;
name|t
operator|=
name|tfree
expr_stmt|;
name|tfree
operator|=
call|(
name|nodeptr
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|tfree
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfree
operator|>
name|tend
condition|)
name|syserr
argument_list|(
literal|"out of tree space"
argument_list|)
expr_stmt|;
name|t
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|n_line
operator|=
name|a
expr_stmt|;
name|t
operator|->
name|n_col
operator|=
name|b
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|0
index|]
operator|.
name|n_val
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|nodeptr
name|tree5
parameter_list|(
name|type
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|int
name|type
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
block|{
specifier|register
name|nodeptr
name|t
decl_stmt|;
name|t
operator|=
name|tfree
expr_stmt|;
name|tfree
operator|=
call|(
name|nodeptr
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|tfree
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfree
operator|>
name|tend
condition|)
name|syserr
argument_list|(
literal|"out of tree space"
argument_list|)
expr_stmt|;
name|t
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|n_line
operator|=
name|a
expr_stmt|;
name|t
operator|->
name|n_col
operator|=
name|b
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|0
index|]
operator|.
name|n_val
operator|=
name|c
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|1
index|]
operator|.
name|n_val
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|nodeptr
name|tree6
parameter_list|(
name|type
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
name|int
name|type
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|;
block|{
specifier|register
name|nodeptr
name|t
decl_stmt|;
name|t
operator|=
name|tfree
expr_stmt|;
name|tfree
operator|=
call|(
name|nodeptr
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|tfree
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfree
operator|>
name|tend
condition|)
name|syserr
argument_list|(
literal|"out of tree space"
argument_list|)
expr_stmt|;
name|t
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|n_line
operator|=
name|a
expr_stmt|;
name|t
operator|->
name|n_col
operator|=
name|b
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|0
index|]
operator|.
name|n_val
operator|=
name|c
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|1
index|]
operator|.
name|n_val
operator|=
name|d
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|2
index|]
operator|.
name|n_val
operator|=
name|e
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|nodeptr
name|tree7
parameter_list|(
name|type
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
name|int
name|type
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|;
block|{
specifier|register
name|nodeptr
name|t
decl_stmt|;
name|t
operator|=
name|tfree
expr_stmt|;
name|tfree
operator|=
call|(
name|nodeptr
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|tfree
operator|+
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfree
operator|>
name|tend
condition|)
name|syserr
argument_list|(
literal|"out of tree space"
argument_list|)
expr_stmt|;
name|t
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|n_line
operator|=
name|a
expr_stmt|;
name|t
operator|->
name|n_col
operator|=
name|b
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|0
index|]
operator|.
name|n_val
operator|=
name|c
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|1
index|]
operator|.
name|n_val
operator|=
name|d
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|2
index|]
operator|.
name|n_val
operator|=
name|e
expr_stmt|;
name|t
operator|->
name|n_field
index|[
literal|3
index|]
operator|.
name|n_val
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the tree space by setting the free pointer back to the first word  *  of the tree space.  */
end_comment

begin_macro
name|treeinit
argument_list|()
end_macro

begin_block
block|{
name|tfree
operator|=
name|tree
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * codegen - traverse tree t, generating code.  */
end_comment

begin_macro
name|codegen
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|nodeptr
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nextlab
operator|=
literal|1
expr_stmt|;
name|traverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * traverse - traverse tree rooted at t and generate code.  This is just  *  plug and chug code for each of the node types.  The tour goes into  *  some detail about the code generation process, in particular, Appendix  *  A describes the parse tree nodes.  */
end_comment

begin_expr_stmt
name|traverse
argument_list|(
name|t
argument_list|)
specifier|register
name|nodeptr
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|lab
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|loopstk
name|loopsave
decl_stmt|;
specifier|static
name|struct
name|loopstk
name|loopstk
index|[
name|LOOPDEPTH
index|]
decl_stmt|;
comment|/* loop stack */
specifier|static
name|struct
name|loopstk
modifier|*
name|loopsp
decl_stmt|;
specifier|static
name|struct
name|casestk
name|casestk
index|[
name|CASEDEPTH
index|]
decl_stmt|;
comment|/* case stack */
specifier|static
name|struct
name|casestk
modifier|*
name|casesp
decl_stmt|;
specifier|static
name|struct
name|creatstk
name|creatstk
index|[
name|CREATDEPTH
index|]
decl_stmt|;
comment|/* create stack */
specifier|static
name|struct
name|creatstk
modifier|*
name|creatsp
decl_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|N_ACTIVAT
case|:
comment|/* co-expression activation */
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|AUGACT
condition|)
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate result expression */
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|AUGACT
condition|)
name|emit
argument_list|(
literal|"sdup"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate activate expression */
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"coact"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|AUGACT
condition|)
name|emit
argument_list|(
literal|"asgn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ALT
case|:
comment|/* alternation */
name|lab
operator|=
name|alclab
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate first alternative */
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emit
argument_list|(
literal|"esusp"
argument_list|)
expr_stmt|;
comment|/*  and suspend with its result */
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate second alternative */
name|emitlab
argument_list|(
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_AUGOP
case|:
comment|/* augmented assignment */
case|case
name|N_BINOP
case|:
comment|/*  or a binary operator */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|N_AUGOP
condition|)
name|emit
argument_list|(
literal|"dup"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|binop
argument_list|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BAR
case|:
comment|/* repeated alternation */
name|lab
operator|=
name|alclab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fail if expr fails first time */
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate first alternative */
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emitl
argument_list|(
literal|"chfail"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
comment|/* change to loop on failure */
name|emit
argument_list|(
literal|"esusp"
argument_list|)
expr_stmt|;
comment|/* suspend result */
break|break;
case|case
name|N_BREAK
case|:
comment|/* break expression */
if|if
condition|(
name|loopsp
operator|->
name|breaklab
operator|<=
literal|0
condition|)
name|lerr
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"invalid context for break"
argument_list|)
expr_stmt|;
else|else
block|{
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
name|loopsp
operator|->
name|markcount
argument_list|)
expr_stmt|;
name|loopsave
operator|=
operator|*
name|loopsp
operator|--
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|++
name|loopsp
operator|=
name|loopsave
expr_stmt|;
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|loopsp
operator|->
name|breaklab
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_CASE
case|:
comment|/* case expression */
name|lab
operator|=
name|alclab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|casesp
operator|++
expr_stmt|;
name|casesp
operator|->
name|endlab
operator|=
name|lab
expr_stmt|;
name|casesp
operator|->
name|deftree
operator|=
name|NULL
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate control expression */
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emit
argument_list|(
literal|"eret"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do rest of case (CLIST) */
if|if
condition|(
name|casesp
operator|->
name|deftree
operator|!=
name|NULL
condition|)
block|{
comment|/* evaluate default clause */
name|emit
argument_list|(
literal|"pop"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|casesp
operator|->
name|deftree
argument_list|)
expr_stmt|;
block|}
else|else
name|emit
argument_list|(
literal|"efail"
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
comment|/* end label */
name|casesp
operator|--
expr_stmt|;
break|break;
case|case
name|N_CCLS
case|:
comment|/* case expression clause */
if|if
condition|(
name|TYPE
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|N_RES
operator|&&
comment|/* default clause */
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|DEFAULT
condition|)
block|{
if|if
condition|(
name|casesp
operator|->
name|deftree
operator|!=
name|NULL
condition|)
name|lerr
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"more than one default clause"
argument_list|)
expr_stmt|;
else|else
name|casesp
operator|->
name|deftree
operator|=
name|TREE1
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* case clause */
name|lab
operator|=
name|alclab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|emit
argument_list|(
literal|"ccase"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate selector */
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"eqv"
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"pop"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evaluate expression */
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|casesp
operator|->
name|endlab
argument_list|)
expr_stmt|;
comment|/* goto end label */
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
comment|/* label for next clause */
block|}
break|break;
case|case
name|N_CLIST
case|:
comment|/* list of case clauses */
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_CONJ
case|:
comment|/* conjunction */
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|AUGAND
condition|)
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|AUGAND
condition|)
name|emit
argument_list|(
literal|"pop"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|AUGAND
condition|)
name|emit
argument_list|(
literal|"asgn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_CREATE
case|:
comment|/* create expression */
name|creatsp
operator|++
expr_stmt|;
name|creatsp
operator|->
name|nextlab
operator|=
name|loopsp
operator|->
name|nextlab
expr_stmt|;
name|creatsp
operator|->
name|breaklab
operator|=
name|loopsp
operator|->
name|breaklab
expr_stmt|;
name|loopsp
operator|->
name|nextlab
operator|=
literal|0
expr_stmt|;
comment|/* make break and next illegal */
name|loopsp
operator|->
name|breaklab
operator|=
literal|0
expr_stmt|;
name|lab
operator|=
name|alclab
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|lab
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* skip over code for coexpression */
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
comment|/* entry point */
name|emit
argument_list|(
literal|"pop"
argument_list|)
expr_stmt|;
comment|/* pop the result from activation */
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* traverse code for coexpression */
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emit
argument_list|(
literal|"incres"
argument_list|)
expr_stmt|;
comment|/* increment number of results */
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"coret"
argument_list|)
expr_stmt|;
comment|/* return to activator */
name|emit
argument_list|(
literal|"efail"
argument_list|)
expr_stmt|;
comment|/* drive coexpression */
name|emitlab
argument_list|(
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* loop on exhaustion */
name|setline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"cofail"
argument_list|)
expr_stmt|;
comment|/* and fail each time */
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
operator|+
literal|2
argument_list|)
expr_stmt|;
name|setline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"create"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
comment|/* create entry block */
name|loopsp
operator|->
name|nextlab
operator|=
name|creatsp
operator|->
name|nextlab
expr_stmt|;
comment|/* legalize break and next */
name|loopsp
operator|->
name|breaklab
operator|=
name|creatsp
operator|->
name|breaklab
expr_stmt|;
name|creatsp
operator|--
expr_stmt|;
break|break;
case|case
name|N_CSET
case|:
comment|/* cset literal */
name|emitn
argument_list|(
literal|"cset"
argument_list|,
name|VAL0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ELIST
case|:
comment|/* expression list */
name|n
operator|=
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EMPTY
case|:
comment|/* a missing expression */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_FIELD
case|:
comment|/* field reference */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emits
argument_list|(
literal|"field"
argument_list|,
name|STR0
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_ID
case|:
comment|/* identifier */
name|emitn
argument_list|(
literal|"var"
argument_list|,
name|VAL0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_IF
case|:
comment|/* if expression */
if|if
condition|(
name|TYPE
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|N_EMPTY
condition|)
name|lab
operator|=
literal|0
expr_stmt|;
else|else
name|lab
operator|=
name|alclab
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab
operator|>
literal|0
condition|)
block|{
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_INT
case|:
comment|/* integer literal */
name|emitn
argument_list|(
literal|"int"
argument_list|,
name|VAL0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_INVOK
case|:
comment|/* procedure call, possibly MGDE */
if|if
condition|(
name|TYPE
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|N_EMPTY
condition|)
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
literal|"pushn1"
argument_list|)
expr_stmt|;
comment|/* assume -1(e1,...,en) */
name|n
operator|=
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"invoke"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|N_KEY
case|:
comment|/* keyword reference */
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"keywd"
argument_list|,
name|VAL0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_LIMIT
case|:
comment|/* limitation */
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"limit"
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emit
argument_list|(
literal|"lsusp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_LIST
case|:
comment|/* list construction */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|N_EMPTY
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"llist"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|N_LOOP
case|:
comment|/* loop */
switch|switch
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|EVERY
case|:
name|lab
operator|=
name|alclab
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|loopsp
operator|++
expr_stmt|;
name|loopsp
operator|->
name|ltype
operator|=
name|EVERY
expr_stmt|;
name|loopsp
operator|->
name|nextlab
operator|=
name|lab
expr_stmt|;
name|loopsp
operator|->
name|breaklab
operator|=
name|lab
operator|+
literal|1
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|=
literal|1
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"pop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|N_EMPTY
condition|)
block|{
comment|/* every e1 do e2 */
name|emitl
argument_list|(
literal|"mark"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|ltype
operator|=
name|N_LOOP
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|emitlab
argument_list|(
name|loopsp
operator|->
name|nextlab
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"efail"
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|loopsp
operator|->
name|breaklab
argument_list|)
expr_stmt|;
name|loopsp
operator|--
expr_stmt|;
break|break;
case|case
name|REPEAT
case|:
name|lab
operator|=
name|alclab
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|loopsp
operator|++
expr_stmt|;
name|loopsp
operator|->
name|ltype
operator|=
name|N_LOOP
expr_stmt|;
name|loopsp
operator|->
name|nextlab
operator|=
name|lab
operator|+
literal|1
expr_stmt|;
name|loopsp
operator|->
name|breaklab
operator|=
name|lab
operator|+
literal|2
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|=
literal|1
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|setline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|loopsp
operator|->
name|nextlab
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|loopsp
operator|->
name|breaklab
argument_list|)
expr_stmt|;
name|loopsp
operator|--
expr_stmt|;
break|break;
case|case
name|WHILE
case|:
name|lab
operator|=
name|alclab
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|loopsp
operator|++
expr_stmt|;
name|loopsp
operator|->
name|ltype
operator|=
name|N_LOOP
expr_stmt|;
name|loopsp
operator|->
name|nextlab
operator|=
name|lab
operator|+
literal|1
expr_stmt|;
name|loopsp
operator|->
name|breaklab
operator|=
name|lab
operator|+
literal|2
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|=
literal|1
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|setline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|N_EMPTY
condition|)
block|{
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emitlab
argument_list|(
name|loopsp
operator|->
name|nextlab
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|loopsp
operator|->
name|breaklab
argument_list|)
expr_stmt|;
name|loopsp
operator|--
expr_stmt|;
break|break;
case|case
name|UNTIL
case|:
name|lab
operator|=
name|alclab
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|loopsp
operator|++
expr_stmt|;
name|loopsp
operator|->
name|ltype
operator|=
name|N_LOOP
expr_stmt|;
name|loopsp
operator|->
name|nextlab
operator|=
name|lab
operator|+
literal|2
expr_stmt|;
name|loopsp
operator|->
name|breaklab
operator|=
name|lab
operator|+
literal|3
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|=
literal|1
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|setline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"efail"
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|loopsp
operator|->
name|nextlab
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|loopsp
operator|->
name|breaklab
argument_list|)
expr_stmt|;
name|loopsp
operator|--
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|N_NEXT
case|:
comment|/* next expression */
if|if
condition|(
name|loopsp
operator|<
name|loopstk
operator|||
name|loopsp
operator|->
name|nextlab
operator|<=
literal|0
condition|)
name|lerr
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"invalid context for next"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|loopsp
operator|->
name|ltype
operator|!=
name|EVERY
operator|&&
name|loopsp
operator|->
name|markcount
operator|>
literal|1
condition|)
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
name|loopsp
operator|->
name|markcount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"goto"
argument_list|,
name|loopsp
operator|->
name|nextlab
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_NOT
case|:
comment|/* not expression */
name|lab
operator|=
name|alclab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"efail"
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_PROC
case|:
comment|/* procedure */
name|loopsp
operator|=
name|loopstk
expr_stmt|;
name|loopsp
operator|->
name|nextlab
operator|=
literal|0
expr_stmt|;
name|loopsp
operator|->
name|breaklab
operator|=
literal|0
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|=
literal|0
expr_stmt|;
name|casesp
operator|=
name|casestk
expr_stmt|;
name|creatsp
operator|=
name|creatstk
expr_stmt|;
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"proc %s\n"
argument_list|,
name|STR0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lout
argument_list|(
name|codefile
argument_list|)
expr_stmt|;
name|cout
argument_list|(
name|codefile
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"declend"
argument_list|)
expr_stmt|;
name|emits
argument_list|(
literal|"file"
argument_list|,
operator|*
name|filep
argument_list|)
expr_stmt|;
name|setline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|N_EMPTY
condition|)
block|{
name|lab
operator|=
name|alclab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"init?"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|N_EMPTY
condition|)
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|TREE3
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"pfail"
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"end"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|silence
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s (%d/%d)\n"
argument_list|,
name|STR0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|tfree
operator|-
operator|(
name|int
operator|*
operator|)
name|tree
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_REAL
case|:
comment|/* real literal */
name|emitn
argument_list|(
literal|"real"
argument_list|,
name|VAL0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RET
case|:
comment|/* return expression */
if|if
condition|(
name|creatsp
operator|>
name|creatstk
condition|)
name|lerr
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"invalid context for return or fail"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
name|lab
operator|=
name|alclab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"pret"
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
name|setline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"pfail"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SCAN
case|:
comment|/* scanning expression */
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|SCANASGN
condition|)
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|SCANASGN
condition|)
name|emit
argument_list|(
literal|"sdup"
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"bscan"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"escan"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|SCANASGN
condition|)
name|emit
argument_list|(
literal|"asgn"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SECT
case|:
comment|/* section operation */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|PCOLON
operator|||
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|MCOLON
condition|)
name|emit
argument_list|(
literal|"dup"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE3
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|PCOLON
condition|)
name|emit
argument_list|(
literal|"plus"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|MCOLON
condition|)
name|emit
argument_list|(
literal|"minus"
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"sect"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SLIST
case|:
comment|/* semicolon separated list of expressions */
name|lab
operator|=
name|alclab
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|emitn
argument_list|(
literal|"unmark"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emitlab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_STR
case|:
comment|/* string literal */
name|emitn
argument_list|(
literal|"str"
argument_list|,
name|VAL0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SUSP
case|:
comment|/* suspension expression */
if|if
condition|(
name|creatsp
operator|>
name|creatstk
condition|)
name|lerr
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"invalid context for suspend"
argument_list|)
expr_stmt|;
name|emitl
argument_list|(
literal|"mark"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|++
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|loopsp
operator|->
name|markcount
operator|--
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"psusp"
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"efail"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_TO
case|:
comment|/* to expression */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"push1"
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"toby"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_TOBY
case|:
comment|/* to-by expression */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE2
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|emit
argument_list|(
literal|"toby"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_UNOP
case|:
comment|/* unary operator */
name|unopa
argument_list|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|traverse
argument_list|(
name|TREE1
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|setline
argument_list|(
name|LINE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|unopb
argument_list|(
name|VAL0
argument_list|(
name|TREE0
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|emitn
argument_list|(
literal|"?????"
argument_list|,
name|TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"traverse: undefined node type"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * binop emits code for binary operators.  For non-augmented operators,  *  the name of operator is emitted.  For augmented operators, an "asgn"  *  is emitted after the name of the operator.  */
end_comment

begin_macro
name|binop
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|asgn
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|asgn
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|ASSIGN
case|:
name|name
operator|=
literal|"asgn"
expr_stmt|;
break|break;
case|case
name|CARETASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|CARET
case|:
name|name
operator|=
literal|"power"
expr_stmt|;
break|break;
case|case
name|CONCATASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|CONCAT
case|:
name|name
operator|=
literal|"cat"
expr_stmt|;
break|break;
case|case
name|DIFFASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|DIFF
case|:
name|name
operator|=
literal|"diff"
expr_stmt|;
break|break;
case|case
name|AUGEQV
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|EQUIV
case|:
name|name
operator|=
literal|"eqv"
expr_stmt|;
break|break;
case|case
name|INTERASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|INTER
case|:
name|name
operator|=
literal|"inter"
expr_stmt|;
break|break;
case|case
name|LBRACK
case|:
name|name
operator|=
literal|"subsc"
expr_stmt|;
break|break;
case|case
name|LCONCATASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|LCONCAT
case|:
name|name
operator|=
literal|"lconcat"
expr_stmt|;
break|break;
case|case
name|AUGSEQ
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|LEXEQ
case|:
name|name
operator|=
literal|"lexeq"
expr_stmt|;
break|break;
case|case
name|AUGSGE
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|LEXGE
case|:
name|name
operator|=
literal|"lexge"
expr_stmt|;
break|break;
case|case
name|AUGSGT
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|LEXGT
case|:
name|name
operator|=
literal|"lexgt"
expr_stmt|;
break|break;
case|case
name|AUGSLE
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|LEXLE
case|:
name|name
operator|=
literal|"lexle"
expr_stmt|;
break|break;
case|case
name|AUGSLT
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|LEXLT
case|:
name|name
operator|=
literal|"lexlt"
expr_stmt|;
break|break;
case|case
name|AUGSNE
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|LEXNE
case|:
name|name
operator|=
literal|"lexne"
expr_stmt|;
break|break;
case|case
name|MINUSASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|MINUS
case|:
name|name
operator|=
literal|"minus"
expr_stmt|;
break|break;
case|case
name|MODASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|MOD
case|:
name|name
operator|=
literal|"mod"
expr_stmt|;
break|break;
case|case
name|AUGNEQV
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|NOTEQUIV
case|:
name|name
operator|=
literal|"neqv"
expr_stmt|;
break|break;
case|case
name|AUGEQ
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|NUMEQ
case|:
name|name
operator|=
literal|"numeq"
expr_stmt|;
break|break;
case|case
name|AUGGE
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|NUMGE
case|:
name|name
operator|=
literal|"numge"
expr_stmt|;
break|break;
case|case
name|AUGGT
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|NUMGT
case|:
name|name
operator|=
literal|"numgt"
expr_stmt|;
break|break;
case|case
name|AUGLE
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|NUMLE
case|:
name|name
operator|=
literal|"numle"
expr_stmt|;
break|break;
case|case
name|AUGLT
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|NUMLT
case|:
name|name
operator|=
literal|"numlt"
expr_stmt|;
break|break;
case|case
name|AUGNE
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|NUMNE
case|:
name|name
operator|=
literal|"numne"
expr_stmt|;
break|break;
case|case
name|PLUSASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|PLUS
case|:
name|name
operator|=
literal|"plus"
expr_stmt|;
break|break;
case|case
name|REVASSIGN
case|:
name|name
operator|=
literal|"rasgn"
expr_stmt|;
break|break;
case|case
name|REVSWAP
case|:
name|name
operator|=
literal|"rswap"
expr_stmt|;
break|break;
case|case
name|SLASHASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|SLASH
case|:
name|name
operator|=
literal|"div"
expr_stmt|;
break|break;
case|case
name|STARASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|STAR
case|:
name|name
operator|=
literal|"mult"
expr_stmt|;
break|break;
case|case
name|SWAP
case|:
name|name
operator|=
literal|"swap"
expr_stmt|;
break|break;
case|case
name|UNIONASGN
case|:
name|asgn
operator|++
expr_stmt|;
case|case
name|UNION
case|:
name|name
operator|=
literal|"unioncs"
expr_stmt|;
break|break;
default|default:
name|emitn
argument_list|(
literal|"?binop"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"binop: undefined binary operator"
argument_list|)
expr_stmt|;
block|}
name|emit
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|asgn
condition|)
name|emit
argument_list|(
literal|"asgn"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * unopa and unopb handle code emission for unary operators. unary operator  *  sequences that are the same as binary operator sequences are recognized  *  by the lexical analyzer as binary operators.  For example, ~===x means to  *  do three tab(match(...)) operations and then a cset complement, but the  *  lexical analyzer sees the operator sequence as the "neqv" binary  *  operation.  unopa and unopb unravel tokens of this form.  *  * When a N_UNOP node is encountered, unopa is called to emit the necessary  *  number of "pnull" operations to receive the intermediate results.  This  *  amounts to a pnull for each operation.  */
end_comment

begin_macro
name|unopa
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|NOTEQUIV
case|:
comment|/* unary ~ and three = operators */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
case|case
name|LEXNE
case|:
comment|/* unary ~ and two = operators */
case|case
name|EQUIV
case|:
comment|/* three unary = operators */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
case|case
name|NUMNE
case|:
comment|/* unary ~ and = operators */
case|case
name|UNION
case|:
comment|/* two unary + operators */
case|case
name|DIFF
case|:
comment|/* two unary - operators */
case|case
name|LEXEQ
case|:
comment|/* two unary = operators */
case|case
name|INTER
case|:
comment|/* two unary * operators */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
case|case
name|DOT
case|:
comment|/* unary . operator */
case|case
name|BACKSLASH
case|:
comment|/* unary \ operator */
case|case
name|BANG
case|:
comment|/* unary ! operator */
case|case
name|CARET
case|:
comment|/* unary ^ operator */
case|case
name|PLUS
case|:
comment|/* unary + operator */
case|case
name|TILDE
case|:
comment|/* unary ~ operator */
case|case
name|MINUS
case|:
comment|/* unary - operator */
case|case
name|NUMEQ
case|:
comment|/* unary = operator */
case|case
name|STAR
case|:
comment|/* unary * operator */
case|case
name|QMARK
case|:
comment|/* unary ? operator */
case|case
name|SLASH
case|:
comment|/* unary / operator */
name|emit
argument_list|(
literal|"pnull"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"unopa: undefined unary operator"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * unopb is the back-end code emitter for unary operators.  It emits  *  the operations represented by the token op.  For tokens representing  *  a single operator, the name of the operator is emitted.  For tokens  *  representing a sequence of operators, recursive calls are used.  In  *  such a case, the operator sequence is "scanned" from right to left  *  and unopb is called with the token for the appropriate operation.  *  * For example, consider the sequence of calls and code emission for "~===":  *	unopb(NOTEQUIV)		~===  *	    unopb(NUMEQ)	=  * 		emits "tabmat"  *	    unopb(NUMEQ)	=  *		emits "tabmat"  *	    unopb(NUMEQ)	=  *		emits "tabmat"  *	    emits "compl"  */
end_comment

begin_macro
name|unopb
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DOT
case|:
comment|/* unary . operator */
name|name
operator|=
literal|"value"
expr_stmt|;
break|break;
case|case
name|BACKSLASH
case|:
comment|/* unary \ operator */
name|name
operator|=
literal|"nonnull"
expr_stmt|;
break|break;
case|case
name|BANG
case|:
comment|/* unary ! operator */
name|name
operator|=
literal|"bang"
expr_stmt|;
break|break;
case|case
name|CARET
case|:
comment|/* unary ^ operator */
name|name
operator|=
literal|"refresh"
expr_stmt|;
break|break;
case|case
name|UNION
case|:
comment|/* two unary + operators */
name|unopb
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
case|case
name|PLUS
case|:
comment|/* unary + operator */
name|name
operator|=
literal|"number"
expr_stmt|;
break|break;
case|case
name|NOTEQUIV
case|:
comment|/* unary ~ and three = operators */
name|unopb
argument_list|(
name|NUMEQ
argument_list|)
expr_stmt|;
case|case
name|LEXNE
case|:
comment|/* unary ~ and two = operators */
name|unopb
argument_list|(
name|NUMEQ
argument_list|)
expr_stmt|;
case|case
name|NUMNE
case|:
comment|/* unary ~ and = operators */
name|unopb
argument_list|(
name|NUMEQ
argument_list|)
expr_stmt|;
case|case
name|TILDE
case|:
comment|/* unary ~ operator (cset compl) */
name|name
operator|=
literal|"compl"
expr_stmt|;
break|break;
case|case
name|DIFF
case|:
comment|/* two unary - operators */
name|unopb
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
case|case
name|MINUS
case|:
comment|/* unary - operator */
name|name
operator|=
literal|"neg"
expr_stmt|;
break|break;
case|case
name|EQUIV
case|:
comment|/* three unary = operators */
name|unopb
argument_list|(
name|NUMEQ
argument_list|)
expr_stmt|;
case|case
name|LEXEQ
case|:
comment|/* two unary = operators */
name|unopb
argument_list|(
name|NUMEQ
argument_list|)
expr_stmt|;
case|case
name|NUMEQ
case|:
comment|/* unary = operator */
name|name
operator|=
literal|"tabmat"
expr_stmt|;
break|break;
case|case
name|INTER
case|:
comment|/* two unary * operators */
name|unopb
argument_list|(
name|STAR
argument_list|)
expr_stmt|;
case|case
name|STAR
case|:
comment|/* unary * operator */
name|name
operator|=
literal|"size"
expr_stmt|;
break|break;
case|case
name|QMARK
case|:
comment|/* unary ? operator */
name|name
operator|=
literal|"random"
expr_stmt|;
break|break;
case|case
name|SLASH
case|:
comment|/* unary / operator */
name|name
operator|=
literal|"null"
expr_stmt|;
break|break;
default|default:
name|emitn
argument_list|(
literal|"?unop"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"unopb: undefined unary operator"
argument_list|)
expr_stmt|;
block|}
name|emit
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * setline emits a "line" instruction for line n.  A "line" instruction is not  *  emitted if the last "line" instruction was also for line n.  */
end_comment

begin_macro
name|setline
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|lastline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|lastline
condition|)
block|{
name|lastline
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|emitn
argument_list|(
literal|"line"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * The emit* routines output ucode to codefile.  The various routines are:  *  *  emitlab(l) - emit "lab" instruction for label l.  *  emit(s) - emit instruction s.  *  emitl(s,a) - emit instruction s with reference to label a.  *  emitn(s,n) - emit instruction s with numeric operand a.  *  emitnl(s,a,b) - emit instruction s with numeric operand a and label b.  *  emits(s,a) - emit instruction s with string operand a.  */
end_comment

begin_macro
name|emitlab
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"lab L%d\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emit
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\t%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitl
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\t%s\tL%d\n"
argument_list|,
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitn
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\t%s\t%d\n"
argument_list|,
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitnl
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\t%s\t%d,L%d\n"
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emits
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|codefile
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * alclab allocates n labels and returns the first.  For the interpreter,  *  labels are restarted at 1 for each procedure, while in the compiler,  *  they start at 1 and increase throughout the entire compilation.  */
end_comment

begin_macro
name|alclab
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|lab
decl_stmt|;
name|lab
operator|=
name|nextlab
expr_stmt|;
name|nextlab
operator|+=
name|n
expr_stmt|;
return|return
operator|(
name|lab
operator|)
return|;
block|}
end_block

end_unit

