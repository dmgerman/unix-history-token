begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Memory initialization and allocation; also parses arguments.  */
end_comment

begin_include
include|#
directive|include
file|"ilink.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * Memory initialization  */
end_comment

begin_decl_stmt
name|struct
name|gentry
modifier|*
modifier|*
name|ghash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash area for global table */
end_comment

begin_decl_stmt
name|struct
name|ientry
modifier|*
modifier|*
name|ihash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash area for identifier table */
end_comment

begin_decl_stmt
name|struct
name|fentry
modifier|*
modifier|*
name|fhash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash area for field table */
end_comment

begin_decl_stmt
name|struct
name|lentry
modifier|*
name|ltable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local table */
end_comment

begin_decl_stmt
name|struct
name|gentry
modifier|*
name|gtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global table */
end_comment

begin_decl_stmt
name|struct
name|centry
modifier|*
name|ctable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* constant table */
end_comment

begin_decl_stmt
name|struct
name|ientry
modifier|*
name|itable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* identifier table */
end_comment

begin_decl_stmt
name|struct
name|fentry
modifier|*
name|ftable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* field table headers */
end_comment

begin_decl_stmt
name|struct
name|rentry
modifier|*
name|rtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* field table record lists */
end_comment

begin_decl_stmt
name|char
modifier|*
name|strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string space */
end_comment

begin_decl_stmt
name|int
modifier|*
name|labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* label table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generated code space */
end_comment

begin_decl_stmt
name|struct
name|gentry
modifier|*
name|gfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free pointer for global table */
end_comment

begin_decl_stmt
name|struct
name|ientry
modifier|*
name|ifree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free pointer for identifier table */
end_comment

begin_decl_stmt
name|struct
name|fentry
modifier|*
name|ffree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free pointer for field table headers */
end_comment

begin_decl_stmt
name|struct
name|rentry
modifier|*
name|rfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free pointer for field table record lists */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free pointer for string space */
end_comment

begin_decl_stmt
name|char
modifier|*
name|codep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free pointer for code space */
end_comment

begin_decl_stmt
name|int
name|lsize
init|=
name|LSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of local table */
end_comment

begin_decl_stmt
name|int
name|gsize
init|=
name|GSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of global table */
end_comment

begin_decl_stmt
name|int
name|csize
init|=
name|CSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of constant table */
end_comment

begin_decl_stmt
name|int
name|isize
init|=
name|ISIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of identifier table */
end_comment

begin_decl_stmt
name|int
name|fsize
init|=
name|FSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of field table headers */
end_comment

begin_decl_stmt
name|int
name|rsize
init|=
name|RSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of field table record lists */
end_comment

begin_decl_stmt
name|int
name|ssize
init|=
name|SSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of string space */
end_comment

begin_decl_stmt
name|int
name|ghsize
init|=
name|GHSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of global hash table */
end_comment

begin_decl_stmt
name|int
name|ihsize
init|=
name|IHSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of identifier hash table */
end_comment

begin_decl_stmt
name|int
name|fhsize
init|=
name|FHSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of field hash table */
end_comment

begin_decl_stmt
name|int
name|maxlabels
init|=
name|MAXLABELS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of labels per procedure */
end_comment

begin_decl_stmt
name|int
name|maxcode
init|=
name|MAXCODE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum amount of code per procedure */
end_comment

begin_decl_stmt
name|int
name|gmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask for global table hash */
end_comment

begin_decl_stmt
name|int
name|imask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask for identifier table hash */
end_comment

begin_decl_stmt
name|int
name|fmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask for field table hash */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first unused location */
end_comment

begin_decl_stmt
name|char
modifier|*
name|memfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ipath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * meminit - scan the command line arguments and initialize data structures.  */
end_comment

begin_macro
name|meminit
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|aval
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
union|union
block|{
name|struct
name|gentry
modifier|*
modifier|*
name|gp
decl_stmt|;
name|struct
name|ientry
modifier|*
modifier|*
name|ip
decl_stmt|;
name|struct
name|fentry
modifier|*
modifier|*
name|fp
decl_stmt|;
block|}
name|p
union|;
specifier|extern
name|char
modifier|*
name|allocate
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|instalid
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|gentry
modifier|*
name|putglob
parameter_list|()
function_decl|;
name|memfree
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start allocating at the end of uninitialized data. */
name|lfiles
operator|=
name|NULL
expr_stmt|;
comment|/* Zero queue of files to link. */
if|if
condition|(
operator|(
name|ipath
operator|=
name|getenv
argument_list|(
literal|"IPATH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ipath
operator|=
literal|"."
expr_stmt|;
comment|/* Just look in current directory if no IPATH. */
comment|/*     * Process the command line arguments.     */
while|while
condition|(
operator|--
name|argc
condition|)
block|{
if|if
condition|(
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'m'
case|:
comment|/* -m and -u are for the translator. */
case|case
literal|'u'
case|:
continue|continue;
case|case
literal|'t'
case|:
comment|/* Set&trace to -1 when Icon starts up. */
name|trace
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
comment|/* Produce a .ux file, which is a readable 				    version of the icode file produced. */
name|Dflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
comment|/* Output file is next argument. */
name|strcpy
argument_list|(
name|outname
argument_list|,
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
comment|/* Change some table size. */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|3
index|]
operator|==
literal|'h'
condition|)
block|{
comment|/* Change hash table size. */
name|aval
operator|=
name|atoi
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aval
operator|<=
literal|0
condition|)
goto|goto
name|badarg
goto|;
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'i'
case|:
name|ihsize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
name|ghsize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
continue|continue;
case|case
literal|'f'
case|:
name|fhsize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Change symbol table size. */
name|aval
operator|=
name|atoi
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aval
operator|<=
literal|0
condition|)
goto|goto
name|badarg
goto|;
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'c'
case|:
name|csize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|isize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
name|gsize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|lsize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|ssize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
continue|continue;
case|case
literal|'f'
case|:
name|fsize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rsize
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
name|maxlabels
operator|=
name|aval
expr_stmt|;
continue|continue;
case|case
literal|'C'
case|:
name|maxcode
operator|=
name|aval
expr_stmt|;
continue|continue;
block|}
block|}
case|case
literal|'i'
case|:
block|{
name|iconx
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|argc
operator|--
expr_stmt|;
continue|continue;
block|}
default|default:
name|badarg
label|:
name|printf
argument_list|(
literal|"bad argument: %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* If not an argument, assume it's an input file. */
if|if
condition|(
name|access
argument_list|(
operator|*
name|argv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ilink: cannot open %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addlfile
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * Round sizes of hash tables for locals, globals, constants, and     *  identifiers to next larger power of two.  The corresponding     *  mask values are set to one less than the hash table size so that     *  an integer value can be&'d with the mask to produce a hash value.     *  (See [lgc]hasher in sym.h.)     */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ghsize
condition|;
name|i
operator|<<=
literal|1
control|)
empty_stmt|;
name|ghsize
operator|=
name|i
expr_stmt|;
name|gmask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ihsize
condition|;
name|i
operator|<<=
literal|1
control|)
empty_stmt|;
name|ihsize
operator|=
name|i
expr_stmt|;
name|imask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fhsize
condition|;
name|i
operator|<<=
literal|1
control|)
empty_stmt|;
name|fhsize
operator|=
name|i
expr_stmt|;
name|fmask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/*     * Allocate the various data structures that are made on a per-file     *  basis.     */
name|ghash
operator|=
operator|(
expr|struct
name|gentry
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|ghsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gentry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ihash
operator|=
operator|(
expr|struct
name|ientry
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|ihsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ientry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fhash
operator|=
operator|(
expr|struct
name|fentry
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fentry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ltable
operator|=
operator|(
expr|struct
name|lentry
operator|*
operator|)
name|allocate
argument_list|(
name|lsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lentry
argument_list|)
argument_list|)
expr_stmt|;
name|gtable
operator|=
operator|(
expr|struct
name|gentry
operator|*
operator|)
name|allocate
argument_list|(
name|gsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gentry
argument_list|)
argument_list|)
expr_stmt|;
name|ctable
operator|=
operator|(
expr|struct
name|centry
operator|*
operator|)
name|allocate
argument_list|(
name|csize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|centry
argument_list|)
argument_list|)
expr_stmt|;
name|itable
operator|=
operator|(
expr|struct
name|ientry
operator|*
operator|)
name|allocate
argument_list|(
name|isize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ientry
argument_list|)
argument_list|)
expr_stmt|;
name|ftable
operator|=
operator|(
expr|struct
name|fentry
operator|*
operator|)
name|allocate
argument_list|(
name|fsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fentry
argument_list|)
argument_list|)
expr_stmt|;
name|rtable
operator|=
operator|(
expr|struct
name|rentry
operator|*
operator|)
name|allocate
argument_list|(
name|rsize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rentry
argument_list|)
argument_list|)
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|allocate
argument_list|(
name|ssize
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|labels
operator|=
operator|(
name|int
operator|*
operator|)
name|allocate
argument_list|(
name|maxlabels
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|char
operator|*
operator|)
name|allocate
argument_list|(
name|maxcode
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     * Check to see if there was enough memory.  This assumes that the     *  allocation for strings fails if any of the other allocations     *  failed.  Apparent bug - that assumption is not necessarily valid.     */
if|if
condition|(
name|code
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"can't get enough memory"
argument_list|)
expr_stmt|;
comment|/*     * Reset the free pointer for each region.     */
name|gfree
operator|=
name|gtable
expr_stmt|;
name|ifree
operator|=
name|itable
expr_stmt|;
name|ffree
operator|=
name|ftable
expr_stmt|;
name|rfree
operator|=
name|rtable
expr_stmt|;
name|sfree
operator|=
name|strings
expr_stmt|;
name|codep
operator|=
name|code
expr_stmt|;
comment|/*     * Zero out the hash tables.     */
for|for
control|(
name|p
operator|.
name|gp
operator|=
name|ghash
init|;
name|p
operator|.
name|gp
operator|<
operator|&
name|ghash
index|[
name|ghsize
index|]
condition|;
name|p
operator|.
name|gp
operator|++
control|)
operator|*
name|p
operator|.
name|gp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|.
name|ip
operator|=
name|ihash
init|;
name|p
operator|.
name|ip
operator|<
operator|&
name|ihash
index|[
name|ihsize
index|]
condition|;
name|p
operator|.
name|ip
operator|++
control|)
operator|*
name|p
operator|.
name|ip
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|.
name|fp
operator|=
name|fhash
init|;
name|p
operator|.
name|fp
operator|<
operator|&
name|fhash
index|[
name|fhsize
index|]
condition|;
name|p
operator|.
name|fp
operator|++
control|)
operator|*
name|p
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
comment|/*     * Install "main" as a global variable in order to insure that it     *  is the first global variable.  iconx/start.s depends on main     *  being global number 0.     */
name|putglob
argument_list|(
name|instalid
argument_list|(
literal|"main"
argument_list|)
argument_list|,
name|F_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * allocate - get more memory from system.  */
end_comment

begin_function
name|char
modifier|*
name|allocate
parameter_list|(
name|n
parameter_list|,
name|size
parameter_list|)
name|int
name|n
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|need
decl_stmt|;
specifier|register
name|char
modifier|*
name|mfree
decl_stmt|;
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
name|need
operator|=
name|n
operator|*
name|size
expr_stmt|;
name|mfree
operator|=
name|memfree
expr_stmt|;
if|if
condition|(
name|brk
argument_list|(
name|memfree
operator|+=
name|need
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|mfree
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * alclfile - allocate an lfile structure for the named file, fill  *  in the name and return a pointer to it.  */
end_comment

begin_function
name|struct
name|lfile
modifier|*
name|alclfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|lfile
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
name|int
name|l
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|lfile
operator|*
operator|)
name|allocate
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|syserr
argument_list|(
literal|"not enough memory for file list"
argument_list|)
expr_stmt|;
name|p
operator|->
name|lf_link
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|=
name|allocate
argument_list|(
literal|1
argument_list|,
operator|(
name|l
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
name|syserr
argument_list|(
literal|"not enough memory for file list"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|np
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|->
name|lf_name
operator|=
name|np
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * dumplfiles - print the list of files to link.  Used for debugging only.  */
end_comment

begin_macro
name|dumplfiles
argument_list|()
end_macro

begin_block
block|{
name|struct
name|lfile
modifier|*
name|p
decl_stmt|,
modifier|*
name|lfls
decl_stmt|;
name|printf
argument_list|(
literal|"lfiles:\n"
argument_list|)
expr_stmt|;
name|lfls
operator|=
name|lfiles
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|getlfile
argument_list|(
operator|&
name|lfls
argument_list|)
condition|)
name|printf
argument_list|(
literal|"'%s'\n"
argument_list|,
name|p
operator|->
name|lf_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * addlfile - create an lfile structure for the named file and add it to the  *  end of the list of files (lfiles) to generate link instructions for.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pptr
decl_stmt|;
end_decl_stmt

begin_macro
name|addlfile
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|lfile
modifier|*
name|nlf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|file
index|[
literal|256
index|]
decl_stmt|,
name|ok
decl_stmt|;
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pptr
operator|=
name|ipath
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|trypath
argument_list|(
name|name
argument_list|,
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
name|canread
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|ok
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't resolve reference to file '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|strcpy
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nlf
operator|=
name|alclfile
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfiles
operator|==
name|NULL
condition|)
block|{
name|lfiles
operator|=
name|nlf
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|lfiles
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|lf_link
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|lf_name
argument_list|,
name|file
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|p
operator|->
name|lf_link
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|lf_name
argument_list|,
name|file
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|p
operator|->
name|lf_link
operator|=
name|nlf
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * getlfile - return a pointer (p) to the lfile structure pointed at by lptr  *  and move lptr to the lfile structure that p points at.  That is, getlfile  *  returns a pointer to the current (wrt. lptr) lfile and advances lptr.  */
end_comment

begin_function
name|struct
name|lfile
modifier|*
name|getlfile
parameter_list|(
name|lptr
parameter_list|)
name|struct
name|lfile
modifier|*
modifier|*
name|lptr
decl_stmt|;
block|{
name|struct
name|lfile
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|lptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|p
operator|=
operator|*
name|lptr
expr_stmt|;
operator|*
name|lptr
operator|=
name|p
operator|->
name|lf_link
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * canread - see if file can be read and be sure that it's just an  *  ordinary file.  */
end_comment

begin_macro
name|canread
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statb
argument_list|)
expr_stmt|;
if|if
condition|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFREG
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * trypath - form a file name in file by concatenating name onto the  *  next path element.  */
end_comment

begin_macro
name|trypath
argument_list|(
argument|name
argument_list|,
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|n
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|pptr
operator|==
literal|':'
condition|)
name|pptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pptr
condition|)
return|return
literal|0
return|;
do|do
block|{
name|c
operator|=
operator|(
operator|*
name|file
operator|++
operator|=
operator|*
name|pptr
operator|++
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|':'
operator|&&
name|c
condition|)
do|;
name|pptr
operator|--
expr_stmt|;
name|file
operator|--
expr_stmt|;
operator|*
name|file
operator|++
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|*
name|file
operator|++
operator|=
operator|*
name|name
operator|++
condition|)
empty_stmt|;
operator|*
name|file
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

