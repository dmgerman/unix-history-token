begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../h/rt.h"
end_include

begin_include
include|#
directive|include
file|"../h/gc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_define
define|#
directive|define
name|MAIN
end_define

begin_endif
endif|#
directive|endif
endif|VAX
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PORT
end_ifdef

begin_define
define|#
directive|define
name|MAIN
end_define

begin_endif
endif|#
directive|endif
endif|PORT
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_comment
comment|/*  * hneed - insure that at least bytes of space are left in the heap.  *  The amount of space needed is transmitted to the collector via  *  the global variable heapneed.  */
end_comment

begin_macro
name|hneed
argument_list|(
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|heapneed
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
name|maxheap
operator|-
name|hpfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sneed - insure that at least chars of space are left in the string  *  space.  The amount of space needed is transmitted to the collector  *  via the global variable strneed.  */
end_comment

begin_macro
name|sneed
argument_list|(
argument|chars
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|chars
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strneed
operator|=
name|chars
expr_stmt|;
if|if
condition|(
name|chars
operator|>
name|estrings
operator|-
name|sfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * esneed - insure that there is a free co-expression stack.  esfree  *  points to the linked list of free stacks.  */
end_comment

begin_macro
name|esneed
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|esfree
operator|==
name|NULL
condition|)
name|gcollect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * escollect - collect the expression stack space.  This is done after  *  the marking phase of garbage collection and the stacks that are  *  reachable have pointers to data blocks, rather than T_ESTACK,  *  in their type field.  */
end_comment

begin_macro
name|escollect
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|b_estack
modifier|*
name|sp
decl_stmt|;
comment|/*     * Reset the type for&main.     */
name|BLKLOC
argument_list|(
name|k_main
argument_list|)
operator|->
name|estack
operator|.
name|type
operator|=
name|T_ESTACK
expr_stmt|;
comment|/*     * Reset the free list pointer.     */
name|esfree
operator|=
name|NULL
expr_stmt|;
comment|/*     * The co-expression stacks start at stacks and lie contiguously.     *  ep is pointed at the low word of each stack and sp is pointed     *  at the b_estack block contained in the space for the stack.     *  (Note that the last word of the b_estack block is the last word     *  of the space for the co-expression stack.     */
for|for
control|(
name|ep
operator|=
name|stacks
init|;
name|ep
operator|<
name|estacks
condition|;
name|ep
operator|+=
name|stksize
control|)
block|{
name|sp
operator|=
operator|(
expr|struct
name|b_estack
operator|*
operator|)
operator|(
name|ep
operator|+
operator|(
name|stksize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|b_estack
argument_list|)
operator|/
name|WORDSIZE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|sp
argument_list|)
operator|==
name|T_ESTACK
condition|)
block|{
comment|/*           * This co-expression was not marked, so it can be collected.           *  The stacks are linked through the first word of the stack           *  space with esfree pointing to the last-collected stack.           */
operator|*
name|ep
operator|=
operator|(
name|int
operator|)
name|esfree
expr_stmt|;
name|esfree
operator|=
name|ep
expr_stmt|;
block|}
else|else
comment|/*           * The co-expression was marked, so just reset the type field.           */
name|blktype
argument_list|(
name|sp
argument_list|)
operator|=
name|T_ESTACK
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * collect - do a garbage collection.  esneed indicates if a co-expression  *  stack is needed.  */
end_comment

begin_macro
name|collect
argument_list|(
argument|esneed
argument_list|)
end_macro

begin_decl_stmt
name|int
name|esneed
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|extra
decl_stmt|;
specifier|register
name|char
modifier|*
name|newend
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
comment|/*     * Reset the string qualifier free list pointer.     */
name|sqfree
operator|=
name|sqlist
expr_stmt|;
comment|/*     * Mark the stacks for&main and the current co-expression.     */
name|mark
argument_list|(
operator|&
name|k_main
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
comment|/*     * Mark&subject and the cached s2 and s3 strings for map().     */
name|mark
argument_list|(
operator|&
name|k_subject
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
name|maps2
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
name|maps3
argument_list|)
expr_stmt|;
comment|/*     * Mark the tended descriptors and the global and static variables.     */
for|for
control|(
name|dp
operator|=
name|tended
init|;
name|dp
operator|<
name|etended
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|globals
init|;
name|dp
operator|<
name|eglobals
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|statics
init|;
name|dp
operator|<
name|estatics
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*     * Collect available co-expression stacks.     */
name|escollect
argument_list|()
expr_stmt|;
if|if
condition|(
name|esneed
operator|&&
name|esfree
operator|==
name|NULL
condition|)
block|{
comment|/*        * A co-expression stack is needed, but none are available.  The        *  new stack at the end of the stack space and is made available        *  by pointing esfree at it.  *estacks is zeroed to terminate the        *  (now one element) co-expression free list.        */
name|esfree
operator|=
name|estacks
expr_stmt|;
operator|*
name|estacks
operator|=
literal|0
expr_stmt|;
comment|/*        * Move back the end of the expression space by the size of a        *  stack and indicate stksize words of memory are needed.        */
name|estacks
operator|+=
name|stksize
expr_stmt|;
name|extra
operator|=
name|stksize
operator|*
name|WORDSIZE
expr_stmt|;
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
comment|/*        * This next calculation determines if there is space for the new        *  stack, but it's not clear what all's going on here.        */
if|if
condition|(
name|newend
operator|<
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|||
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
literal|0x7fffffff
operator|||
operator|(
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|&&
operator|(
operator|(
name|int
operator|)
name|brk
argument_list|(
name|newend
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
name|runerr
argument_list|(
literal|305
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*        * Another co-expression stack is not needed.        */
name|extra
operator|=
literal|0
expr_stmt|;
comment|/*     * Collect the string space, indicating that it must be moved back     *  extra bytes.     */
name|scollect
argument_list|(
name|extra
argument_list|)
expr_stmt|;
comment|/*     * sptr is post-gc value for strings.  Move back pointers for estrings     *  and sqlist according to value of extra.     */
name|sptr
operator|=
name|strings
operator|+
name|extra
expr_stmt|;
name|estrings
operator|+=
name|extra
expr_stmt|;
name|sqlist
operator|=
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
comment|/*     * Calculate a value for extra space.  The value is (the larger of     *  (twice the string space needed) or (the number of words currently     *  in the string space)) plus the unallocated string space.     */
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|strneed
argument_list|,
operator|(
name|estrings
operator|-
operator|(
name|char
operator|*
operator|)
name|estacks
operator|)
operator|/
literal|4
argument_list|)
operator|-
operator|(
name|estrings
operator|-
name|extra
operator|-
name|sfree
operator|)
operator|+
operator|(
name|GRANSIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|GRANSIZE
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/*        * Try to get extra more bytes of storage.  If it can't be gotten,        *  decrease the value by GRANSIZE and try again.  If it's gotten,        *  move back estrings and sqlist.        */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
operator|(
operator|(
name|int
operator|)
name|brk
argument_list|(
name|newend
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|estrings
operator|+=
name|extra
expr_stmt|;
name|sqlist
operator|=
operator|(
expr|struct
name|descrip
operator|*
operator|*
operator|)
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
name|GRANSIZE
expr_stmt|;
block|}
comment|/*     * Adjust the pointers in the heap.  Note that hpbase is the old base     *  of the heap and estrings will be the post-gc base of the heap.     */
name|adjust
argument_list|(
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
comment|/*     * Compact the heap.     */
name|compact
argument_list|(
name|hpbase
argument_list|)
expr_stmt|;
comment|/*     * Calculate a value for extra space.  The value is (the larger of     *  (twice the heap space needed) or (the number of words currently     *  in the heap space)) plus the unallocated heap space.     */
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|heapneed
argument_list|,
operator|(
name|maxheap
operator|-
name|hpbase
operator|)
operator|/
literal|4
argument_list|)
operator|+
name|hpfree
operator|-
name|maxheap
operator|+
operator|(
name|GRANSIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|GRANSIZE
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/*        * Try to get extra more bytes of storage.  If it can't be gotten,        *  decrease the value by GRANSIZE and try again.  If it's gotten,        *  move back sqlist.        */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
operator|(
operator|(
name|int
operator|)
name|brk
argument_list|(
name|newend
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|sqlist
operator|=
operator|(
expr|struct
name|descrip
operator|*
operator|*
operator|)
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
name|GRANSIZE
expr_stmt|;
block|}
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
if|if
condition|(
name|estrings
operator|!=
name|hpbase
condition|)
block|{
comment|/*        * estrings is not equal to hpbase and this indicates that the        *  co-expression and/or string space was expanded and thus        *  the heap must be moved.  There is an assumption here that the        *  heap always moves up in memory, i.e., the co-expression and        *  string spaces never shrink.  With this assumption in hand,        *  the heap must be moved before the string space lest the string        *  space overwrite heap data.  The assumption is valid, but beware        *  if shrinking regions are ever implemented.        */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|hpfree
operator|-
name|hpbase
argument_list|)
argument_list|,
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
name|hpfree
operator|+=
name|estrings
operator|-
name|hpbase
expr_stmt|;
name|hpbase
operator|=
name|estrings
expr_stmt|;
block|}
if|if
condition|(
name|sptr
operator|!=
name|strings
condition|)
block|{
comment|/*        * sptr is not equal to strings and this indicates that the        *  co-expression space was expanded and thus the string space        *  must be moved up in memory.        */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|sfree
operator|-
name|strings
argument_list|)
argument_list|,
name|strings
argument_list|,
name|sptr
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|sptr
operator|-
name|strings
expr_stmt|;
name|strings
operator|=
name|sptr
expr_stmt|;
block|}
comment|/*     * Expand the heap.     */
name|maxheap
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * mark - mark each accessible block in the heap and build back-list of  *  descriptors pointing to that block. (Phase I of garbage collection.)  */
end_comment

begin_macro
name|mark
argument_list|(
argument|cdesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|cdesc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|ndesc
decl_stmt|;
specifier|register
name|char
modifier|*
name|endblock
decl_stmt|,
modifier|*
name|block
decl_stmt|;
specifier|static
name|int
name|type
decl_stmt|;
specifier|static
name|int
name|fdesc
decl_stmt|;
if|if
condition|(
name|QUAL
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/*        * The descriptor is for a string, so pass the buck to marksq.        */
name|marksq
argument_list|(
name|cdesc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isptr
argument_list|(
name|cdesc
argument_list|)
condition|)
block|{
comment|/*        * The descriptor is a pointer to a block or a variable.  Point        *  block at the block referenced by the descriptor.        */
name|block
operator|=
operator|(
name|char
operator|*
operator|)
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/*           * The descriptor is a variable; point block at the start of the           *  block containing the descriptor that cdesc points to.  For           *  example, descriptors of this sort are created by subscripting           *  lists.           */
name|block
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|*
operator|)
name|block
operator|-
name|OFFSET
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|block
operator|>=
name|hpbase
operator|&&
name|block
operator|<
name|hpfree
condition|)
block|{
comment|/*           * The block is the heap (blocks outside the heap are ignored);           *  get the type of the block.           */
name|type
operator|=
name|blktype
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAXTYPE
condition|)
comment|/*              * type is a valid type, indicating that this block hasn't              *  been marked.  Point endblock at the byte past the end              *  of the block.              */
name|endblock
operator|=
name|block
operator|+
name|getsize
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/*           * Add cdesc to the back-chain for the block and point the           *  block (via the type field) at cdesc.           */
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
name|type
expr_stmt|;
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
operator|(
name|int
operator|)
name|cdesc
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|<=
name|MAXTYPE
operator|)
operator|&&
operator|(
operator|(
name|fdesc
operator|=
name|firstd
index|[
operator|(
name|int
operator|)
name|type
index|]
operator|)
operator|>
literal|0
operator|)
condition|)
comment|/*              * The block has not been marked, and it does contain descriptors.              *  Mark each descriptor.              */
for|for
control|(
name|ndesc
operator|=
operator|(
expr|struct
name|descrip
operator|*
operator|)
operator|(
name|block
operator|+
name|fdesc
operator|)
init|;
operator|(
name|char
operator|*
operator|)
name|ndesc
operator|<
name|endblock
condition|;
name|ndesc
operator|++
control|)
name|mark
argument_list|(
name|ndesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
name|TYPE
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|==
name|T_ESTACK
operator|&&
name|blktype
argument_list|(
name|block
argument_list|)
operator|<=
name|MAXTYPE
condition|)
block|{
comment|/*           * cdesc points to a co-expression block that hasn't been marked.           *  Point the block at cdesc.  Sweep the co-expression's stack           *  and mark the blocks for the activating co-expression and           *  the co-expression's refresh block.           */
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
operator|(
name|int
operator|)
name|cdesc
expr_stmt|;
name|sweep
argument_list|(
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|boundary
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|activator
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|freshblk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * adjust - adjust pointers into heap, beginning with block oblk and  *  basing the "new" heap at nblk.  (Phase II of garbage collection.)  */
end_comment

begin_macro
name|adjust
argument_list|(
argument|oblk
argument_list|,
argument|nblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|,
modifier|*
name|nblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|nxtptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
comment|/*     * Loop through to end of allocated heap space moving oblk to each     *  block in turn, using the size of a block to find the next block.     */
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|nxtptr
operator|=
operator|(
expr|struct
name|descrip
operator|*
operator|)
name|blktype
argument_list|(
name|oblk
argument_list|)
argument_list|)
operator|>
name|MAXTYPE
condition|)
block|{
comment|/*           * The type field of oblk is a back-pointer.  Work along the chain           *  of back pointers, changing each block location from oblk           *  to nblk.           */
while|while
condition|(
operator|(
name|unsigned
operator|)
name|nxtptr
operator|>
name|MAXTYPE
condition|)
block|{
name|tptr
operator|=
name|nxtptr
expr_stmt|;
name|nxtptr
operator|=
operator|(
expr|struct
name|descrip
operator|*
operator|)
name|BLKLOC
argument_list|(
operator|*
name|nxtptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|tptr
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|tptr
argument_list|)
condition|)
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|(
operator|(
name|int
operator|*
operator|)
name|nblk
operator|+
name|OFFSET
argument_list|(
operator|*
name|tptr
argument_list|)
operator|)
expr_stmt|;
else|else
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
name|nblk
expr_stmt|;
block|}
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|=
operator|(
name|unsigned
operator|)
name|nxtptr
operator||
name|MARK
expr_stmt|;
name|nblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
name|oblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * compact - compact good blocks in heap. (Phase III of garbage collection.)  */
end_comment

begin_macro
name|compact
argument_list|(
argument|oblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|nblk
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
comment|/*     * Start at oblk, which happens to be hpbase.     */
name|nblk
operator|=
name|oblk
expr_stmt|;
comment|/*     * Loop through to end of allocated heap space moving oblk to each     *  block in turn, using the size of a block to find the next block.     *  If a block has been marked, it is copied to the location pointed     *  at by nblk and nblk is pointed past the end of the block, which     *  is the location to place the next good block at.  Good blocks     *  are un-marked.     */
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
name|size
operator|=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&
name|MARK
condition|)
block|{
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&=
operator|~
name|MARK
expr_stmt|;
if|if
condition|(
name|oblk
operator|!=
name|nblk
condition|)
name|mvc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|,
name|oblk
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
name|nblk
operator|+=
name|size
expr_stmt|;
block|}
name|oblk
operator|+=
name|size
expr_stmt|;
block|}
comment|/*     * nblk is the location of the next free block, so now that compaction     *  is complete, point hpfree at that location.     */
name|hpfree
operator|=
name|nblk
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * marksq - mark a string qualifier.  Strings outside the string space  *  are ignored.  */
end_comment

begin_macro
name|marksq
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|>=
name|strings
operator|&&
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|<
name|estrings
condition|)
block|{
comment|/*        * The string is in the string space, add it to the string qualifier        *  list.  But before adding it, expand the string qualifier list        *  if necessary.        */
if|if
condition|(
name|sqfree
operator|>=
name|esqlist
condition|)
block|{
name|esqlist
operator|+=
name|SQLINC
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|brk
argument_list|(
name|esqlist
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|runerr
argument_list|(
literal|303
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|sqfree
operator|++
operator|=
name|d
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * scollect - collect the string space.  sqlist is a list of pointers to  *  descriptors for all the reachable strings in the string space.  For  *  ease of description, it is referred to as if it were composed of  *  descriptors rather than pointers to them.  */
end_comment

begin_macro
name|scollect
argument_list|(
argument|extra
argument_list|)
end_macro

begin_decl_stmt
name|int
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
specifier|extern
name|int
name|sqcmp
parameter_list|()
function_decl|;
if|if
condition|(
name|sqfree
operator|<=
name|sqlist
condition|)
block|{
comment|/*        * There are no accessible strings, thus there are none to collect        *  and the whole string space is free.        */
name|sfree
operator|=
name|strings
expr_stmt|;
return|return;
block|}
comment|/*     * Sort the sqlist in ascending order of string locations.     */
name|qsort
argument_list|(
name|sqlist
argument_list|,
name|sqfree
operator|-
name|sqlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descrip
operator|*
argument_list|)
argument_list|,
name|sqcmp
argument_list|)
expr_stmt|;
comment|/*     * The string qualifiers are now ordered by starting location.     *  The algorithm used is described in detail in one of the references     *  cited in the "tour", but briefly...     *     * The string region can be thought of as being made up of clumps,     *  where a clump is a contiguous area of strings that are referenced.     *  For example, imagine sqlist looks like:     *     *   [2,400]     *   [3,400]     *   [10,400]     *   [12,415]     *   [4,420]     *   [3,430]     *   [1,430]     *     * There are three clumps:  The first starts at location 400 and extends     *  to 409.  The second starts at 415 and extends to 426.  The third     *  starts at 430 and extends to 432.  Note that there are gaps, i.e.     *  garbage, at 410-414 and 427-429.     *     * After collection, sqlist will look like:     *     *        [2,400]     *        [3,400]     *        [10,400]     *        [12,410]     *        [4,415]     *        [3,422]     *        [1,422]     *     * Note how the gaps have been closed by moving the strings downward     *  in memory.     *     * The method used is to look at each qualifier in sqlist in turn     *  and determine which ones lie in clumps and the extent of each     *  clump.  The qualifiers referencing strings in each clump are     *  relocated and then the clump is moved down (compacted).     *     * d points to the next free location to compact into.  s is the     *  start of the current clump and e is the end.     */
name|d
operator|=
name|strings
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|sqlist
argument_list|)
expr_stmt|;
comment|/*     * Loop through qualifiers for accessible strings.     */
for|for
control|(
name|p
operator|=
name|sqlist
init|;
name|p
operator|<
name|sqfree
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
block|{
comment|/*           * p is a qualifier for a string in the next clump; the last           *  clump is moved and s and e are set for the next clump.           */
while|while
condition|(
name|s
operator|<
name|e
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
comment|/*           * p is a qualifier for a string in this clump, extend the clump.           */
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/*        * Relocate the string qualifier.        */
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+=
name|d
operator|-
name|s
operator|+
name|extra
expr_stmt|;
block|}
comment|/*     * Move the last clump.     */
while|while
condition|(
name|s
operator|<
name|e
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|sfree
operator|=
name|d
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sqcmp - compare the location fields of two string qualifiers for qsort.  */
end_comment

begin_macro
name|sqcmp
argument_list|(
argument|q1
argument_list|,
argument|q2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
modifier|*
name|q1
decl_stmt|,
modifier|*
modifier|*
name|q2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|q1
argument_list|)
operator|-
name|STRLOC
argument_list|(
operator|*
operator|*
name|q2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * mvc - move n bytes from src to dst.  */
end_comment

begin_macro
name|mvc
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|words
decl_stmt|;
specifier|register
name|int
modifier|*
name|srcw
decl_stmt|,
modifier|*
name|dstw
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|words
operator|=
name|n
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|n
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|srcw
operator|=
operator|(
name|int
operator|*
operator|)
name|s
expr_stmt|;
name|dstw
operator|=
operator|(
name|int
operator|*
operator|)
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|s
condition|)
block|{
comment|/*        * The move is from higher memory to lower memory.  (It so happens        *  that leftover bytes are not moved.)        */
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|(
name|dstw
operator|)
operator|++
operator|=
operator|*
operator|(
name|srcw
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|>
name|s
condition|)
block|{
comment|/*        * The move is from lower memory to higher memory.        */
name|s
operator|+=
name|n
expr_stmt|;
name|d
operator|+=
name|n
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
name|srcw
operator|=
operator|(
name|int
operator|*
operator|)
name|s
expr_stmt|;
name|dstw
operator|=
operator|(
name|int
operator|*
operator|)
name|d
expr_stmt|;
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|--
name|dstw
operator|=
operator|*
operator|--
name|srcw
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MAIN
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PDP11
end_ifdef

begin_comment
comment|/*  * hneed(bytes) - insure at least 'bytes' space left in heap.  */
end_comment

begin_macro
name|hneed
argument_list|(
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|heapneed
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
name|maxheap
operator|-
name|hpfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sneed(chars) - insure at least 'chars' bytes left in string space.  */
end_comment

begin_macro
name|sneed
argument_list|(
argument|chars
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|chars
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strneed
operator|=
name|chars
expr_stmt|;
if|if
condition|(
name|chars
operator|>
name|estrings
operator|-
name|sfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * esneed() - insure stack space free list is not empty.  */
end_comment

begin_macro
name|esneed
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|esfree
operator|==
name|NULL
condition|)
name|gcollect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * escollect() - collect the expression stack space after marking.  */
end_comment

begin_macro
name|escollect
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|b_estack
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
name|nxtptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|BLKLOC
argument_list|(
name|k_main
argument_list|)
operator|->
name|estack
operator|.
name|type
operator|=
name|T_ESTACK
expr_stmt|;
comment|/* must reset */
name|esfree
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|stacks
init|;
name|ep
operator|<
name|estacks
condition|;
name|ep
operator|+=
name|stksize
control|)
block|{
name|sp
operator|=
name|ep
operator|+
operator|(
name|stksize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|b_estack
argument_list|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|sp
argument_list|)
operator|==
name|T_ESTACK
condition|)
block|{
comment|/* add to free list */
operator|*
name|ep
operator|=
name|esfree
expr_stmt|;
name|esfree
operator|=
name|ep
expr_stmt|;
block|}
else|else
comment|/* adjust type field */
name|blktype
argument_list|(
name|sp
argument_list|)
operator|=
name|T_ESTACK
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * collect - call the heap garbage collector.  */
end_comment

begin_macro
name|collect
argument_list|(
argument|esneed
argument_list|)
end_macro

begin_decl_stmt
name|int
name|esneed
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|extra
decl_stmt|;
specifier|register
name|char
modifier|*
name|newend
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
name|sqfree
operator|=
name|sqlist
expr_stmt|;
comment|/* initialize string qualifier list */
name|mark
argument_list|(
operator|&
name|k_main
argument_list|)
expr_stmt|;
comment|/* mark main stack */
name|mark
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
comment|/* mark current stack */
name|mark
argument_list|(
operator|&
name|k_subject
argument_list|)
expr_stmt|;
comment|/* mark tended descriptors */
name|mark
argument_list|(
operator|&
name|maps2
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
name|maps3
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|tended
init|;
name|dp
operator|<
name|etended
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|globals
init|;
name|dp
operator|<
name|eglobals
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|statics
init|;
name|dp
operator|<
name|estatics
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|escollect
argument_list|()
expr_stmt|;
comment|/* collect available expression stacks */
if|if
condition|(
name|esneed
operator|&&
name|esfree
operator|==
name|NULL
condition|)
block|{
name|esfree
operator|=
name|estacks
expr_stmt|;
comment|/* need to make room for another stack */
operator|*
name|estacks
operator|=
literal|0
expr_stmt|;
name|estacks
operator|+=
name|stksize
expr_stmt|;
name|extra
operator|=
name|stksize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* string and heap ptrs are chars */
name|newend
operator|=
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|<
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|||
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
literal|0177700
operator|||
operator|(
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|&&
name|brk
argument_list|(
name|newend
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
name|runerr
argument_list|(
literal|305
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|extra
operator|=
literal|0
expr_stmt|;
name|scollect
argument_list|(
name|extra
argument_list|)
expr_stmt|;
comment|/* collect string space */
name|sptr
operator|=
name|strings
operator|+
name|extra
expr_stmt|;
comment|/* remember new location of string space */
name|estrings
operator|+=
name|extra
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+=
name|extra
expr_stmt|;
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|strneed
argument_list|,
operator|(
name|estrings
operator|-
name|estacks
operator|)
operator|/
literal|4
argument_list|)
operator|-
operator|(
name|estrings
operator|-
name|extra
operator|-
name|sfree
operator|)
operator|+
literal|63
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/* need breathing room? */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
literal|0177700
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
name|brk
argument_list|(
name|newend
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|estrings
operator|+=
name|extra
expr_stmt|;
name|sqlist
operator|=
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
literal|64
expr_stmt|;
block|}
name|adjust
argument_list|(
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
comment|/* adjust pointers into heap */
name|compact
argument_list|(
name|hpbase
argument_list|)
expr_stmt|;
comment|/* compact heap */
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|heapneed
argument_list|,
operator|(
name|maxheap
operator|-
name|hpbase
operator|)
operator|/
literal|4
argument_list|)
operator|+
name|hpfree
operator|-
name|maxheap
operator|+
literal|63
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/* need breathing room? */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
literal|0177700
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
name|brk
argument_list|(
name|newend
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|sqlist
operator|=
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
literal|64
expr_stmt|;
block|}
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
if|if
condition|(
name|estrings
operator|!=
name|hpbase
condition|)
block|{
comment|/* move heap */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|hpfree
operator|-
name|hpbase
argument_list|)
argument_list|,
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
name|hpfree
operator|+=
name|estrings
operator|-
name|hpbase
expr_stmt|;
name|hpbase
operator|=
name|estrings
expr_stmt|;
block|}
if|if
condition|(
name|sptr
operator|!=
name|strings
condition|)
block|{
comment|/* move string space */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|sfree
operator|-
name|strings
argument_list|)
argument_list|,
name|strings
argument_list|,
name|sptr
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|sptr
operator|-
name|strings
expr_stmt|;
name|strings
operator|=
name|sptr
expr_stmt|;
block|}
name|maxheap
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
expr_stmt|;
comment|/* expand heap */
return|return;
block|}
end_block

begin_comment
comment|/*  * mark - mark each accessible block in the heap and build back-list of  *  descriptors pointing to that block. (Phase I of garbage collection)  */
end_comment

begin_macro
name|mark
argument_list|(
argument|cdesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|cdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current descriptor */
end_comment

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|ndesc
decl_stmt|;
specifier|register
name|char
modifier|*
name|endblock
decl_stmt|,
modifier|*
name|block
decl_stmt|;
specifier|static
name|char
modifier|*
name|type
decl_stmt|;
specifier|static
name|int
name|fdesc
decl_stmt|;
if|if
condition|(
name|QUAL
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/* if descriptor is a string qualifier, */
name|marksq
argument_list|(
name|cdesc
argument_list|)
expr_stmt|;
comment|/*   mark it for scollect */
elseif|else
if|if
condition|(
name|isptr
argument_list|(
name|cdesc
argument_list|)
condition|)
block|{
comment|/* ok, descriptor is a pointer */
name|block
operator|=
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
expr_stmt|;
comment|/* get pointer to top of block */
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/* if variable, need offset */
name|block
operator|=
operator|(
name|int
operator|*
operator|)
name|block
operator|-
name|OFFSET
argument_list|(
operator|*
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|>=
name|hpbase
operator|&&
name|block
operator|<
name|hpfree
condition|)
block|{
comment|/* insure it points to heap */
name|type
operator|=
name|blktype
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/* save type and end of block */
if|if
condition|(
name|type
operator|<=
name|MAXTYPE
condition|)
name|endblock
operator|=
name|block
operator|+
name|getsize
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* add descriptor to back chain */
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
name|cdesc
expr_stmt|;
comment|/* sweep descriptors in block */
if|if
condition|(
operator|(
name|type
operator|<=
name|MAXTYPE
operator|)
operator|&&
operator|(
operator|(
name|fdesc
operator|=
name|firstd
index|[
operator|(
name|int
operator|)
name|type
index|]
operator|)
operator|>
literal|0
operator|)
condition|)
for|for
control|(
name|ndesc
operator|=
name|block
operator|+
name|fdesc
init|;
name|ndesc
operator|<
name|endblock
condition|;
name|ndesc
operator|++
control|)
name|mark
argument_list|(
name|ndesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
name|TYPE
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|==
name|T_ESTACK
operator|&&
operator|(
name|char
operator|*
operator|)
name|blktype
argument_list|(
name|block
argument_list|)
operator|<=
name|MAXTYPE
condition|)
block|{
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
name|cdesc
expr_stmt|;
comment|/* note block as visited */
name|sweep
argument_list|(
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|boundary
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|activator
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|freshblk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * adjust - adjust pointers into heap, beginning with heapblock 'oblk'.  *   (Phase II of garbage collection)  */
end_comment

begin_macro
name|adjust
argument_list|(
argument|oblk
argument_list|,
argument|nblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|,
modifier|*
name|nblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|nxtptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
comment|/* linear sweep through heap */
if|if
condition|(
operator|(
name|nxtptr
operator|=
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|)
operator|>
name|MAXTYPE
condition|)
block|{
while|while
condition|(
operator|(
name|unsigned
operator|)
name|nxtptr
operator|>
name|MAXTYPE
condition|)
block|{
name|tptr
operator|=
name|nxtptr
expr_stmt|;
name|nxtptr
operator|=
name|BLKLOC
argument_list|(
operator|*
name|nxtptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|tptr
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|tptr
argument_list|)
condition|)
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
name|nblk
operator|+
name|OFFSET
argument_list|(
operator|*
name|tptr
argument_list|)
expr_stmt|;
else|else
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
name|nblk
expr_stmt|;
block|}
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|=
operator|(
name|unsigned
operator|)
name|nxtptr
operator||
name|MARK
expr_stmt|;
name|nblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
name|oblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * compact - compact good blocks in heap, beginning with block 'oblk'.  *   (Phase III of garbage collection)  */
end_comment

begin_macro
name|compact
argument_list|(
argument|oblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|nblk
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|nblk
operator|=
name|oblk
expr_stmt|;
comment|/* linear sweep through heap */
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
name|size
operator|=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&
name|MARK
condition|)
block|{
comment|/* move good block */
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&=
operator|~
name|MARK
expr_stmt|;
comment|/* turn off mark */
if|if
condition|(
name|oblk
operator|!=
name|nblk
condition|)
name|mvc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|,
name|oblk
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
name|nblk
operator|+=
name|size
expr_stmt|;
block|}
name|oblk
operator|+=
name|size
expr_stmt|;
block|}
name|hpfree
operator|=
name|nblk
expr_stmt|;
comment|/* reset free space pointer */
block|}
end_block

begin_comment
comment|/*  * marksq - mark a string qualifier.  If it points into the  * string space, put a pointer to it in the string qualifier  * list.  */
end_comment

begin_macro
name|marksq
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|>=
name|strings
operator|&&
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|<
name|estrings
condition|)
block|{
if|if
condition|(
name|sqfree
operator|>=
name|esqlist
condition|)
block|{
name|esqlist
operator|+=
name|SQLINC
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|brk
argument_list|(
name|esqlist
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|runerr
argument_list|(
literal|303
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|sqfree
operator|++
operator|=
name|d
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * scollect - collect the string space.  * A list of string qualifiers points to all valid strings.  */
end_comment

begin_macro
name|scollect
argument_list|(
argument|extra
argument_list|)
end_macro

begin_decl_stmt
name|int
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
specifier|extern
name|int
name|sqcmp
parameter_list|()
function_decl|;
if|if
condition|(
name|sqfree
operator|<=
name|sqlist
condition|)
block|{
name|sfree
operator|=
name|strings
expr_stmt|;
return|return;
block|}
name|qsort
argument_list|(
name|sqlist
argument_list|,
name|sqfree
operator|-
name|sqlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descrip
operator|*
argument_list|)
argument_list|,
name|sqcmp
argument_list|)
expr_stmt|;
name|d
operator|=
name|strings
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|sqlist
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sqlist
init|;
name|p
operator|<
name|sqfree
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
block|{
comment|/* outside last clump */
while|while
condition|(
name|s
operator|<
name|e
condition|)
comment|/* move the clump */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* start a new clump */
block|}
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
comment|/* extend the clump */
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+=
name|d
operator|-
name|s
operator|+
name|extra
expr_stmt|;
comment|/* relocate the string qualifier */
block|}
while|while
condition|(
name|s
operator|<
name|e
condition|)
comment|/* move the last clump */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|sfree
operator|=
name|d
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sqcmp - compare the location fields of two string qualifiers for qsort.  */
end_comment

begin_macro
name|sqcmp
argument_list|(
argument|q1
argument_list|,
argument|q2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
modifier|*
name|q1
decl_stmt|,
modifier|*
modifier|*
name|q2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|q1
argument_list|)
operator|-
name|STRLOC
argument_list|(
operator|*
operator|*
name|q2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * mvc - move n bytes from src to dst.  * src and dst must be at word boundaries.  */
end_comment

begin_macro
name|mvc
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|words
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|words
operator|=
name|n
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|n
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|s
condition|)
block|{
comment|/* move back */
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|d
operator|)
operator|++
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|s
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|>
name|s
condition|)
block|{
comment|/* move forward */
name|s
operator|+=
name|n
expr_stmt|;
name|d
operator|+=
name|n
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|--
operator|(
name|int
operator|*
operator|)
name|d
operator|=
operator|*
operator|--
operator|(
name|int
operator|*
operator|)
name|s
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PDP11
end_endif

end_unit

