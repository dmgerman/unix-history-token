begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: ng.c,v 4.3.1.3 85/05/16 16:48:09 lwall Exp $  *  * $Log:	ng.c,v $  * Revision 4.3.1.3  85/05/16  16:48:09  lwall  * Fixed unsubsubscribe.  *   * Revision 4.3.1.2  85/05/13  09:29:28  lwall  * Added CUSTOMLINES option.  *   * Revision 4.3.1.1  85/05/10  11:36:00  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:43:43  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rn.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"artsrch.h"
end_include

begin_include
include|#
directive|include
file|"cheat.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"artstate.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"art.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"ngstuff.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"respond.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"backpage.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"last.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"artstate.h"
end_include

begin_comment
comment|/* somebody has to do it */
end_comment

begin_comment
comment|/* art_switch() return values */
end_comment

begin_define
define|#
directive|define
name|AS_NORM
value|0
end_define

begin_define
define|#
directive|define
name|AS_INP
value|1
end_define

begin_define
define|#
directive|define
name|AS_ASK
value|2
end_define

begin_define
define|#
directive|define
name|AS_CLEAN
value|3
end_define

begin_decl_stmt
name|ART_NUM
name|recent_art
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous article # for '-' command */
end_comment

begin_decl_stmt
name|ART_NUM
name|curr_art
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current article # */
end_comment

begin_decl_stmt
name|int
name|exit_code
init|=
name|NG_NORM
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ng_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|KILLFILES
name|open_kfile
argument_list|(
name|KF_GLOBAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CUSTOMLINES
name|init_compex
argument_list|(
operator|&
name|hide_compex
argument_list|)
expr_stmt|;
name|init_compex
argument_list|(
operator|&
name|page_compex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* do newsgroup on line ng with name ngname */
end_comment

begin_comment
comment|/* assumes that we are chdir'ed to SPOOL, and assures that that is  * still true upon return, but chdirs to SPOOL/ngname in between  *  * If you can understand this routine, you understand most of the program.  * The basic structure is:  *	for each desired article  *		for each desired page  *			for each line on page  *				if we need another line from file  *					get it  *					if it's a header line  *						do special things  *				for each column on page  *					put out a character  *				end loop  *			end loop  *		end loop  *	end loop  *  *	(Actually, the pager is in another routine.)  *  * The chief problem is deciding what is meant by "desired".  Most of  * the messiness of this routine is due to the fact that people want  * to do unstructured things all the time.  I have used a few judicious  * goto's where I thought it improved readability.  The rest of the messiness  * arises from trying to be both space and time efficient.  Have fun.  */
end_comment

begin_function
name|int
name|do_newsgroup
parameter_list|(
name|start_command
parameter_list|)
name|char
modifier|*
name|start_command
decl_stmt|;
comment|/* command to fake up first */
block|{
ifdef|#
directive|ifdef
name|SERVER
name|char
name|ser_line
index|[
literal|256
index|]
decl_stmt|;
name|char
name|artname
index|[
literal|32
index|]
decl_stmt|;
specifier|static
name|long
name|our_pid
decl_stmt|;
endif|#
directive|endif
name|char
name|oldmode
init|=
name|mode
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
comment|/* scratch */
name|int
name|skipstate
decl_stmt|;
comment|/* how many unavailable articles */
comment|/*   have we skipped already? */
name|char
modifier|*
name|whatnext
init|=
literal|"%sWhat next? [%s]"
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER
if|if
condition|(
name|our_pid
operator|==
literal|0
condition|)
comment|/* Agreed, this is gross */
name|our_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
operator|(
name|scanon
operator|&&
operator|(
operator|(
name|ART_NUM
operator|)
name|toread
index|[
name|ng
index|]
operator|)
operator|>=
name|scanon
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* did they say -S? */
endif|#
directive|endif
name|mode
operator|=
literal|'a'
expr_stmt|;
name|recent_art
operator|=
name|curr_art
operator|=
literal|0
expr_stmt|;
name|exit_code
operator|=
name|NG_NORM
expr_stmt|;
ifndef|#
directive|ifndef
name|SERVER
if|if
condition|(
name|eaccess
argument_list|(
name|ngdir
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* directory read protected? */
if|if
condition|(
name|eaccess
argument_list|(
name|ngdir
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nNewsgroup %s does not have a spool directory!\n"
argument_list|,
argument|ngname
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nNo spool for %s!\n"
argument_list|,
name|ngname
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CATCHUP
name|catch_up
argument_list|(
name|ng
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|toread
index|[
name|ng
index|]
operator|=
name|TR_NONE
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nNewsgroup %s is not currently accessible.\n"
argument_list|,
argument|ngname
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n%s not readable.\n"
argument_list|,
name|ngname
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|toread
index|[
name|ng
index|]
operator|=
name|TR_NONE
expr_stmt|;
comment|/* make this newsgroup invisible */
comment|/* (temporarily) */
block|}
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* chdir to newsgroup subdirectory */
if|if
condition|(
name|chdir
argument_list|(
name|ngdir
argument_list|)
condition|)
block|{
name|printf
argument_list|(
argument|nocd
argument_list|,
argument|ngdir
argument_list|)
name|FLUSH
expr_stmt|;
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
comment|/* SERVER */
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"GROUP %s"
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rrn: Unexpected close of server socket.\n"
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ser_line
operator|!=
name|CHAR_OK
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* SERVER */
ifdef|#
directive|ifdef
name|CACHESUBJ
name|subj_list
operator|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
comment|/* no subject list till needed */
endif|#
directive|endif
comment|/* initialize control bitmap */
if|if
condition|(
name|initctl
argument_list|()
condition|)
block|{
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* FROM HERE ON, RETURN THRU CLEANUP OR WE ARE SCREWED */
name|in_ng
operator|=
name|TRUE
expr_stmt|;
comment|/* tell the world we are here */
name|forcelast
operator|=
name|TRUE
expr_stmt|;
comment|/* if 0 unread, do not bomb out */
name|art
operator|=
name|firstart
expr_stmt|;
comment|/* remember what newsgroup we were in for sake of posterity */
name|writelast
argument_list|()
expr_stmt|;
comment|/* see if there are any special searches to do */
ifdef|#
directive|ifdef
name|KILLFILES
name|open_kfile
argument_list|(
name|KF_LOCAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|kill_unwanted
argument_list|(
name|firstart
argument_list|,
literal|"Looking for articles to kill...\n\n"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|kill_unwanted
argument_list|(
name|firstart
argument_list|,
literal|"Killing...\n\n"
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* do they want a special top line? */
name|firstline
operator|=
name|getval
argument_list|(
literal|"FIRSTLINE"
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
comment|/* custom line suppression, custom page ending */
ifdef|#
directive|ifdef
name|CUSTOMLINES
if|if
condition|(
name|hideline
operator|=
name|getval
argument_list|(
literal|"HIDELINE"
argument_list|,
name|Nullch
argument_list|)
condition|)
name|compile
argument_list|(
operator|&
name|hide_compex
argument_list|,
name|hideline
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagestop
operator|=
name|getval
argument_list|(
literal|"PAGESTOP"
argument_list|,
name|Nullch
argument_list|)
condition|)
name|compile
argument_list|(
operator|&
name|page_compex
argument_list|,
name|pagestop
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* now read each unread article */
name|rc_changed
operator|=
name|doing_ng
operator|=
name|TRUE
expr_stmt|;
comment|/* enter the twilight zone */
name|skipstate
operator|=
literal|0
expr_stmt|;
comment|/* we have not skipped anything (yet) */
name|checkcount
operator|=
literal|0
expr_stmt|;
comment|/* do not checkpoint for a while */
name|do_fseek
operator|=
name|FALSE
expr_stmt|;
comment|/* start 1st article at top */
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
name|art
operator|=
name|firstart
expr_stmt|;
comment|/* init the for loop below */
for|for
control|(
init|;
name|art
operator|<=
name|lastart
operator|+
literal|1
condition|;
control|)
block|{
comment|/* for each article */
comment|/* do we need to "grow" the newsgroup? */
if|if
condition|(
name|art
operator|>
name|lastart
operator|||
name|forcegrow
condition|)
name|grow_ctl
argument_list|()
expr_stmt|;
name|check_first
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* make sure firstart is still 1st */
if|if
condition|(
name|start_command
condition|)
block|{
comment|/* fake up an initial command? */
name|prompt
operator|=
name|whatnext
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|start_command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start_command
argument_list|)
expr_stmt|;
name|start_command
operator|=
name|Nullch
expr_stmt|;
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
goto|goto
name|article_level
goto|;
block|}
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
block|{
comment|/* are we off the end still? */
name|ART_NUM
name|ucount
init|=
literal|0
decl_stmt|;
comment|/* count of unread articles left */
for|for
control|(
name|i
operator|=
name|firstart
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ctl_read
argument_list|(
name|i
argument_list|)
operator|)
condition|)
name|ucount
operator|++
expr_stmt|;
comment|/* count the unread articles */
ifdef|#
directive|ifdef
name|DEBUGGING
comment|/*NOSTRICT*/
if|if
condition|(
name|debug
operator|&&
operator|(
operator|(
name|ART_NUM
operator|)
name|toread
index|[
name|ng
index|]
operator|)
operator|!=
name|ucount
condition|)
name|printf
argument_list|(
literal|"(toread=%ld sb %ld)"
argument_list|,
argument|(long)toread[ng]
argument_list|,
argument|(long)ucount
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
comment|/*NOSTRICT*/
name|toread
index|[
name|ng
index|]
operator|=
operator|(
name|ART_UNREAD
operator|)
name|ucount
expr_stmt|;
comment|/* this is perhaps pointless */
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
comment|/* keep bitmap references sane */
if|if
condition|(
name|art
operator|!=
name|curr_art
condition|)
block|{
name|recent_art
operator|=
name|curr_art
expr_stmt|;
comment|/* remember last article # (for '-') */
name|curr_art
operator|=
name|art
expr_stmt|;
comment|/* remember this article # */
block|}
if|if
condition|(
name|erase_screen
condition|)
name|clear
argument_list|()
expr_stmt|;
comment|/* clear the screen */
else|else
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"End of newsgroup %s."
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
comment|/* print pseudo-article */
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"End of %s"
argument_list|,
name|ngname
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ucount
condition|)
block|{
name|printf
argument_list|(
literal|"  (%ld article%s still unread)"
argument_list|,
operator|(
name|long
operator|)
name|ucount
argument_list|,
name|ucount
operator|==
literal|1
condition|?
name|nullstr
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|forcelast
condition|)
goto|goto
name|cleanup
goto|;
comment|/* actually exit newsgroup */
block|}
name|prompt
operator|=
name|whatnext
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
comment|/* no more subject search mode */
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|skipstate
operator|=
literal|0
expr_stmt|;
comment|/* back to none skipped */
block|}
elseif|else
if|if
condition|(
operator|!
name|reread
operator|&&
name|was_read
argument_list|(
name|art
argument_list|)
condition|)
block|{
comment|/* has this article been read? */
name|art
operator|++
expr_stmt|;
comment|/* then skip it */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|reread
operator|&&
operator|!
name|was_read
argument_list|(
name|art
argument_list|)
operator|&&
name|artopen
argument_list|(
name|art
argument_list|)
operator|==
name|Nullfp
condition|)
block|{
comment|/* never read it,& cannot find it? */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
comment|/* has it not been deleted? */
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\n(Article %ld exists but is unreadable.)\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n(%ld unreadable.)\n"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|skipstate
operator|=
literal|0
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|skipstate
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|clear
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"Skipping unavailable article"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"Skipping"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|just_a_sec
operator|/
literal|3
init|;
name|i
condition|;
operator|--
name|i
control|)
name|putchar
argument_list|(
name|PC
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs
argument_list|(
literal|".."
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SERVER
define|#
directive|define
name|READDIR
ifdef|#
directive|ifdef
name|READDIR
block|{
comment|/* fast skip patch */
name|ART_NUM
name|newart
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|newart
operator|=
name|getngmin
argument_list|(
literal|"."
argument_list|,
name|art
argument_list|)
operator|)
condition|)
name|newart
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|art
init|;
name|i
operator|<
name|newart
condition|;
name|i
operator|++
control|)
name|oneless
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|art
operator|=
name|newart
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
name|oneless
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* mark deleted as read */
name|art
operator|++
expr_stmt|;
comment|/* try next article */
continue|continue;
block|}
else|else
block|{
comment|/* we have a real live article */
name|skipstate
operator|=
literal|0
expr_stmt|;
comment|/* back to none skipped */
if|if
condition|(
name|art
operator|!=
name|curr_art
condition|)
block|{
name|recent_art
operator|=
name|curr_art
expr_stmt|;
comment|/* remember last article # (for '-') */
name|curr_art
operator|=
name|art
expr_stmt|;
comment|/* remember this article # */
block|}
if|if
condition|(
operator|!
name|do_fseek
condition|)
block|{
comment|/* starting at top of article? */
name|artline
operator|=
literal|0
expr_stmt|;
comment|/* start at the beginning */
name|topline
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and remember top line of screen */
comment|/*  (line # within article file) */
block|}
name|clear
argument_list|()
expr_stmt|;
comment|/* clear screen */
name|artopen
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* make sure article file is open */
if|if
condition|(
name|artfp
operator|==
name|Nullfp
condition|)
block|{
comment|/* could not find article? */
name|printf
argument_list|(
literal|"Article %ld of %s is not available.\n\n"
argument_list|,
argument|(long)art
argument_list|,
argument|ngname
argument_list|)
name|FLUSH
expr_stmt|;
name|prompt
operator|=
name|whatnext
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* found it, so print it */
switch|switch
condition|(
name|do_article
argument_list|()
condition|)
block|{
case|case
name|DA_CLEAN
case|:
comment|/* quit newsgroup */
goto|goto
name|cleanup
goto|;
case|case
name|DA_TOEND
case|:
comment|/* do not mark as read */
goto|goto
name|reask_article
goto|;
case|case
name|DA_RAISE
case|:
comment|/* reparse command at end of art */
goto|goto
name|article_level
goto|;
case|case
name|DA_NORM
case|:
comment|/* normal end of article */
break|break;
block|}
block|}
name|mark_as_read
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* mark current article as read */
name|reread
operator|=
name|FALSE
expr_stmt|;
name|do_hiding
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ROTATION
name|rotate
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* if these gotos bother you, think of this as a little state machine */
name|reask_article
label|:
ifdef|#
directive|ifdef
name|MAILCALL
name|setmail
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|setdfltcmd
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAREOL
if|if
condition|(
name|erase_screen
operator|&&
name|can_home_clear
condition|)
comment|/* PWP was here */
name|clear_rest
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|CLEAREOL
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|standout
argument_list|()
expr_stmt|;
comment|/* enter standout mode */
name|printf
argument_list|(
name|prompt
argument_list|,
name|mailcall
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
comment|/* print prompt, whatever it is */
name|un_standout
argument_list|()
expr_stmt|;
comment|/* leave standout mode */
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reinp_article
label|:
name|eat_typeahead
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PENDING
name|look_ahead
argument_list|()
expr_stmt|;
comment|/* see what we can do in advance */
if|if
condition|(
operator|!
name|input_pending
argument_list|()
condition|)
name|collect_subjects
argument_list|()
expr_stmt|;
comment|/* loads subject cache until */
comment|/* input is pending */
endif|#
directive|endif
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
block|{
if|if
condition|(
name|LINES
operator|<
literal|100
operator|&&
operator|!
name|int_count
condition|)
operator|*
name|buf
operator|=
literal|'\f'
expr_stmt|;
comment|/* on CONT fake up refresh */
else|else
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* but only on a crt */
goto|goto
name|reask_article
goto|;
block|}
block|}
name|article_level
label|:
comment|/* parse and process article level command */
switch|switch
condition|(
name|art_switch
argument_list|()
condition|)
block|{
case|case
name|AS_INP
case|:
comment|/* multichar command rubbed out */
goto|goto
name|reinp_article
goto|;
case|case
name|AS_ASK
case|:
comment|/* reprompt "End of article..." */
goto|goto
name|reask_article
goto|;
case|case
name|AS_CLEAN
case|:
comment|/* exit newsgroup */
goto|goto
name|cleanup
goto|;
case|case
name|AS_NORM
case|:
comment|/* display article art */
break|break;
block|}
block|}
comment|/* end of article selection loop */
comment|/* shut down newsgroup */
name|cleanup
label|:
ifdef|#
directive|ifdef
name|KILLFILES
name|kill_unwanted
argument_list|(
name|firstart
argument_list|,
literal|"\nCleaning up...\n\n"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* do cleanup from KILL file, if any */
endif|#
directive|endif
name|in_ng
operator|=
name|FALSE
expr_stmt|;
comment|/* leave newsgroup state */
if|if
condition|(
name|artfp
operator|!=
name|Nullfp
condition|)
block|{
comment|/* article still open? */
name|fclose
argument_list|(
name|artfp
argument_list|)
expr_stmt|;
comment|/* close it */
name|artfp
operator|=
name|Nullfp
expr_stmt|;
comment|/* and tell the world */
ifdef|#
directive|ifdef
name|SERVER
name|sprintf
argument_list|(
name|artname
argument_list|,
literal|"/tmp/rrn%ld.%ld"
argument_list|,
operator|(
name|long
operator|)
name|openart
argument_list|,
name|our_pid
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|artname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|openart
operator|=
literal|0
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|yankback
argument_list|()
expr_stmt|;
comment|/* do a Y command */
name|restore_ng
argument_list|()
expr_stmt|;
comment|/* reconstitute .newsrc line */
name|doing_ng
operator|=
name|FALSE
expr_stmt|;
comment|/* tell sig_catcher to cool it */
name|free
argument_list|(
name|ctlarea
argument_list|)
expr_stmt|;
comment|/* return the control area */
ifdef|#
directive|ifdef
name|CACHESUBJ
if|if
condition|(
name|subj_list
condition|)
block|{
for|for
control|(
name|i
operator|=
name|OFFSET
argument_list|(
name|lastart
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|subj_list
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|subj_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subj_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
block|}
endif|#
directive|endif
name|write_rc
argument_list|()
expr_stmt|;
comment|/* and update .newsrc */
name|rc_changed
operator|=
name|FALSE
expr_stmt|;
comment|/* tell sig_catcher it is ok */
if|if
condition|(
name|chdir
argument_list|(
name|spool
argument_list|)
condition|)
block|{
name|printf
argument_list|(
argument|nocd
argument_list|,
argument|spool
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KILLFILES
if|if
condition|(
name|localkfp
condition|)
block|{
name|fclose
argument_list|(
name|localkfp
argument_list|)
expr_stmt|;
name|localkfp
operator|=
name|Nullfp
expr_stmt|;
block|}
endif|#
directive|endif
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

begin_comment
comment|/* Whew! */
end_comment

begin_comment
comment|/* decide what to do at the end of an article */
end_comment

begin_function
name|int
name|art_switch
parameter_list|()
block|{
specifier|register
name|ART_NUM
name|i
decl_stmt|;
name|setdef
argument_list|(
name|buf
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* find previous unread article */
do|do
block|{
if|if
condition|(
name|art
operator|<=
name|firstart
condition|)
break|break;
name|art
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|was_read
argument_list|(
name|art
argument_list|)
operator|||
name|artopen
argument_list|(
name|art
argument_list|)
operator|==
name|Nullfp
condition|)
do|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'P'
case|:
comment|/* goto previous article */
if|if
condition|(
name|art
operator|>
name|absfirst
condition|)
name|art
operator|--
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n\ There are no articles prior to this one.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nNo previous articles\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
block|}
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'-'
case|:
if|if
condition|(
name|recent_art
condition|)
block|{
name|art
operator|=
name|recent_art
expr_stmt|;
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
operator|-
operator|(
name|srchahead
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
block|}
else|else
block|{
name|exit_code
operator|=
name|NG_MINUS
expr_stmt|;
return|return
name|AS_CLEAN
return|;
block|}
case|case
literal|'n'
case|:
comment|/* find next unread article? */
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
block|{
if|if
condition|(
name|toread
index|[
name|ng
index|]
condition|)
name|art
operator|=
name|firstart
expr_stmt|;
else|else
return|return
name|AS_CLEAN
return|;
block|}
ifdef|#
directive|ifdef
name|ARTSEARCH
elseif|else
if|if
condition|(
name|scanon
operator|&&
name|srchahead
condition|)
block|{
operator|*
name|buf
operator|=
name|Ctl
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
goto|goto
name|normal_search
goto|;
block|}
endif|#
directive|endif
else|else
name|art
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'N'
case|:
comment|/* goto next article */
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
name|art
operator|=
name|absfirst
expr_stmt|;
else|else
name|art
operator|++
expr_stmt|;
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'$'
case|:
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|forcelast
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
comment|/* goto specified article */
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
comment|/* or do something with a range */
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
name|forcelast
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|numnum
argument_list|()
condition|)
block|{
case|case
name|NN_INP
case|:
return|return
name|AS_INP
return|;
case|case
name|NN_ASK
case|:
return|return
name|AS_ASK
return|;
case|case
name|NN_REREAD
case|:
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
if|if
condition|(
name|srchahead
condition|)
name|srchahead
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NN_NORM
case|:
if|if
condition|(
name|was_read
argument_list|(
name|art
argument_list|)
condition|)
block|{
name|art
operator|=
name|firstart
expr_stmt|;
name|pad
argument_list|(
name|just_a_sec
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|AS_ASK
return|;
break|break;
block|}
return|return
name|AS_NORM
return|;
case|case
name|Ctl
argument_list|(
literal|'k'
argument_list|)
case|:
name|edit_kfile
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|'K'
case|:
case|case
literal|'k'
case|:
case|case
name|Ctl
argument_list|(
literal|'n'
argument_list|)
case|:
case|case
name|Ctl
argument_list|(
literal|'p'
argument_list|)
case|:
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
ifdef|#
directive|ifdef
name|ARTSEARCH
name|normal_search
label|:
block|{
comment|/* search for article by pattern */
name|char
name|cmd
init|=
operator|*
name|buf
decl_stmt|;
name|reread
operator|=
name|TRUE
expr_stmt|;
comment|/* assume this */
switch|switch
condition|(
name|art_search
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|SRCH_ERROR
case|:
return|return
name|AS_ASK
return|;
case|case
name|SRCH_ABORT
case|:
return|return
name|AS_INP
return|;
case|case
name|SRCH_INTR
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\n(Interrupted at article %ld)\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n(Intr at %ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|art
operator|=
name|curr_art
expr_stmt|;
comment|/* restore to current article */
return|return
name|AS_ASK
return|;
case|case
name|SRCH_DONE
case|:
name|fputs
argument_list|(
literal|"done\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|pad
argument_list|(
name|just_a_sec
operator|/
literal|3
argument_list|)
expr_stmt|;
comment|/* 1/3 second */
if|if
condition|(
name|srchahead
condition|)
name|art
operator|=
name|firstart
expr_stmt|;
else|else
name|art
operator|=
name|curr_art
expr_stmt|;
name|reread
operator|=
name|FALSE
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
name|SRCH_SUBJDONE
case|:
ifdef|#
directive|ifdef
name|UNDEF
name|fputs
argument_list|(
literal|"\n\n\n\nSubject not found.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|pad
argument_list|(
name|just_a_sec
operator|/
literal|3
argument_list|)
expr_stmt|;
comment|/* 1/3 second */
endif|#
directive|endif
name|art
operator|=
name|firstart
expr_stmt|;
name|reread
operator|=
name|FALSE
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
name|SRCH_NOTFOUND
case|:
name|fputs
argument_list|(
literal|"\n\n\n\nNot found.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|art
operator|=
name|curr_art
expr_stmt|;
comment|/* restore to current article */
return|return
name|AS_ASK
return|;
case|case
name|SRCH_FOUND
case|:
if|if
condition|(
name|cmd
operator|==
name|Ctl
argument_list|(
literal|'n'
argument_list|)
operator|||
name|cmd
operator|==
name|Ctl
argument_list|(
literal|'p'
argument_list|)
condition|)
name|oldsubject
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
return|return
name|AS_NORM
return|;
block|}
else|#
directive|else
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|notincl
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
case|case
literal|'u'
case|:
comment|/* unsubscribe from this newsgroup? */
name|rcchar
index|[
name|ng
index|]
operator|=
name|NEGCHAR
expr_stmt|;
return|return
name|AS_CLEAN
return|;
case|case
literal|'M'
case|:
ifdef|#
directive|ifdef
name|DELAYMARK
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|delay_unmark
argument_list|(
name|art
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nArticle %ld will return.\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
block|}
else|#
directive|else
name|notincl
argument_list|(
literal|"M"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
case|case
literal|'m'
case|:
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|unmark_as_read
argument_list|(
name|art
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nArticle %ld marked as still unread.\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
block|}
return|return
name|AS_ASK
return|;
case|case
literal|'c'
case|:
comment|/* catch up */
name|reask_catchup
label|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|in_char
argument_list|(
literal|"\nDo you really want to mark everything as read? [yn] "
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|in_char
argument_list|(
literal|"\nReally? [ynh] "
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|setdef
argument_list|(
name|buf
argument_list|,
literal|"y"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|buf
operator|==
literal|'h'
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\ Type y or SP to mark all articles as read.\n\ Type n to leave articles marked as they are.\n\ Type u to mark everything read and unsubscribe.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\ y or SP to mark all read.\n\ n to forget it.\n\ u to mark all and unsubscribe.\n\ "
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
goto|goto
name|reask_catchup
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'n'
operator|||
operator|*
name|buf
operator|==
literal|'q'
condition|)
block|{
return|return
name|AS_ASK
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'y'
operator|&&
operator|*
name|buf
operator|!=
literal|'u'
condition|)
block|{
name|fputs
argument_list|(
argument|hforhelp
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_catchup
goto|;
block|}
for|for
control|(
name|i
operator|=
name|firstart
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
block|{
name|ctl_set
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* mark as read */
block|}
ifdef|#
directive|ifdef
name|DELAYMARK
if|if
condition|(
name|dmfp
condition|)
name|yankback
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|buf
operator|==
literal|'u'
condition|)
block|{
name|rcchar
index|[
name|ng
index|]
operator|=
name|NEGCHAR
expr_stmt|;
return|return
name|AS_CLEAN
return|;
block|}
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|forcelast
operator|=
name|FALSE
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
literal|'Q'
case|:
name|exit_code
operator|=
name|NG_ASK
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
comment|/* go back up to newsgroup level? */
return|return
name|AS_CLEAN
return|;
case|case
literal|'j'
case|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
name|mark_as_read
argument_list|(
name|art
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|'h'
case|:
block|{
comment|/* help? */
name|int
name|cmd
decl_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|=
name|help_art
argument_list|()
operator|)
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'&'
case|:
if|if
condition|(
name|switcheroo
argument_list|()
condition|)
comment|/* get rest of command */
return|return
name|AS_INP
return|;
comment|/* if rubbed out, try something else */
return|return
name|AS_ASK
return|;
case|case
literal|'#'
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nThe last article is %ld.\n"
argument_list|,
argument|(long)lastart
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|lastart
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
case|case
literal|'='
case|:
block|{
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
name|ART_NUM
name|oldart
init|=
name|art
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|char
modifier|*
name|subjline
init|=
name|getval
argument_list|(
literal|"SUBJLINE"
argument_list|,
name|Nullch
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|CACHESUBJ
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
name|page_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHESUBJ
if|if
condition|(
operator|!
name|subj_list
condition|)
name|fetchsubj
argument_list|(
name|art
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|firstart
init|;
name|i
operator|<=
name|lastart
operator|&&
operator|!
name|int_count
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|CACHESUBJ
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
name|subj_list
index|[
name|OFFSET
argument_list|(
name|i
argument_list|)
index|]
operator|!=
name|Nullch
operator|||
name|fetchsubj
argument_list|(
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|&&
operator|*
name|subj_list
index|[
name|OFFSET
argument_list|(
name|i
argument_list|)
index|]
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%5ld "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|subjline
condition|)
block|{
name|art
operator|=
name|i
expr_stmt|;
name|interp
argument_list|(
name|tmpbuf
operator|+
literal|6
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
operator|-
literal|6
argument_list|,
name|subjline
argument_list|)
expr_stmt|;
block|}
else|else
name|safecpy
argument_list|(
name|tmpbuf
operator|+
literal|6
argument_list|,
name|subj_list
index|[
name|OFFSET
argument_list|(
name|i
argument_list|)
index|]
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
operator|-
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|=
name|print_lines
argument_list|(
name|tmpbuf
argument_list|,
name|NOMARKING
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
name|s
operator|=
name|fetchsubj
argument_list|(
name|i
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|&&
operator|*
name|s
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%5ld "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|subjline
condition|)
block|{
comment|/* probably fetches it again! */
name|art
operator|=
name|i
expr_stmt|;
name|interp
argument_list|(
name|tmpbuf
operator|+
literal|6
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
operator|-
literal|6
argument_list|,
name|subjline
argument_list|)
expr_stmt|;
block|}
else|else
name|safecpy
argument_list|(
name|tmpbuf
operator|+
literal|6
argument_list|,
name|s
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
operator|-
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|=
name|print_lines
argument_list|(
name|tmpbuf
argument_list|,
name|NOMARKING
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
name|int_count
operator|=
literal|0
expr_stmt|;
name|art
operator|=
name|oldart
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'^'
case|:
name|art
operator|=
name|firstart
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
if|#
directive|if
name|defined
argument_list|(
name|CACHESUBJ
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUGGING
argument_list|)
case|case
literal|'D'
case|:
name|printf
argument_list|(
literal|"\nFirst article: %ld\n"
argument_list|,
argument|(long)firstart
argument_list|)
name|FLUSH
expr_stmt|;
if|if
condition|(
operator|!
name|subj_list
condition|)
name|fetchsubj
argument_list|(
name|art
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|subj_list
operator|!=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastart
operator|&&
operator|!
name|int_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|subj_list
index|[
name|OFFSET
argument_list|(
name|i
argument_list|)
index|]
condition|)
name|printf
argument_list|(
literal|"%5ld %c %s\n"
argument_list|,
argument|i
argument_list|,
argument|(was_read(i)?
literal|'y'
argument|:
literal|'n'
argument|)
argument_list|,
argument|subj_list[OFFSET(i)]
argument_list|)
name|FLUSH
expr_stmt|;
block|}
block|}
name|int_count
operator|=
literal|0
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
case|case
literal|'v'
case|:
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|reread
operator|=
name|TRUE
expr_stmt|;
name|do_hiding
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|AS_NORM
return|;
ifdef|#
directive|ifdef
name|ROTATION
case|case
name|Ctl
argument_list|(
literal|'x'
argument_list|)
case|:
endif|#
directive|endif
case|case
name|Ctl
argument_list|(
literal|'r'
argument_list|)
case|:
ifdef|#
directive|ifdef
name|ROTATION
name|rotate
operator|=
operator|(
operator|*
name|buf
operator|==
name|Ctl
argument_list|(
literal|'x'
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
name|reread
operator|=
name|TRUE
expr_stmt|;
return|return
name|AS_NORM
return|;
ifdef|#
directive|ifdef
name|ROTATION
case|case
literal|'X'
case|:
name|rotate
operator|=
operator|!
name|rotate
expr_stmt|;
comment|/* FALL THROUGH */
else|#
directive|else
case|case
name|Ctl
argument_list|(
literal|'x'
argument_list|)
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|notincl
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
case|case
literal|'l'
case|:
case|case
name|Ctl
argument_list|(
literal|'l'
argument_list|)
case|:
comment|/* refresh screen */
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|reread
operator|=
name|TRUE
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|do_fseek
operator|=
name|TRUE
expr_stmt|;
name|artline
operator|=
name|topline
expr_stmt|;
if|if
condition|(
name|artline
operator|<
literal|0
condition|)
name|artline
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|AS_NORM
return|;
case|case
literal|'b'
case|:
case|case
name|Ctl
argument_list|(
literal|'b'
argument_list|)
case|:
comment|/* back up a page */
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|ART_LINE
name|target
decl_stmt|;
name|reread
operator|=
name|TRUE
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|do_fseek
operator|=
name|TRUE
expr_stmt|;
name|target
operator|=
name|topline
operator|-
operator|(
name|LINES
operator|-
literal|2
operator|)
expr_stmt|;
name|artline
operator|=
name|topline
expr_stmt|;
do|do
block|{
name|artline
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|artline
operator|>=
literal|0
operator|&&
name|artline
operator|>
name|target
operator|&&
name|vrdary
argument_list|(
name|artline
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
do|;
name|topline
operator|=
name|artline
expr_stmt|;
if|if
condition|(
name|artline
operator|<
literal|0
condition|)
name|artline
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|AS_NORM
return|;
case|case
literal|'!'
case|:
comment|/* shell escape */
if|if
condition|(
name|escapade
argument_list|()
condition|)
return|return
name|AS_INP
return|;
return|return
name|AS_ASK
return|;
case|case
literal|'C'
case|:
block|{
name|cancel_article
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
block|{
comment|/* reply? */
name|reply
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
block|{
comment|/* followup command */
name|followup
argument_list|()
expr_stmt|;
name|forcegrow
operator|=
name|TRUE
expr_stmt|;
comment|/* recalculate lastart */
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'|'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
comment|/* save command */
if|if
condition|(
name|save_article
argument_list|()
operator|==
name|SAVE_ABORT
condition|)
return|return
name|AS_INP
return|;
return|return
name|AS_ASK
return|;
ifdef|#
directive|ifdef
name|DELAYMARK
case|case
literal|'Y'
case|:
comment|/* yank back M articles */
name|yankback
argument_list|()
expr_stmt|;
name|art
operator|=
name|firstart
expr_stmt|;
comment|/* from the beginning */
return|return
name|AS_NORM
return|;
comment|/* pretend nothing happened */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRICTCR
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
argument|badcr
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
argument|hforhelp
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAILCALL
end_ifdef

begin_comment
comment|/* see if there is any mail */
end_comment

begin_function
name|void
name|setmail
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|mailcount
operator|++
operator|)
condition|)
block|{
name|char
modifier|*
name|mailfile
init|=
name|filexp
argument_list|(
name|getval
argument_list|(
literal|"MAILFILE"
argument_list|,
name|MAILFILE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|mailfile
argument_list|,
operator|&
name|filestat
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|filestat
operator|.
name|st_size
operator|||
name|filestat
operator|.
name|st_atime
operator|>
name|filestat
operator|.
name|st_mtime
condition|)
name|mailcall
operator|=
name|nullstr
expr_stmt|;
else|else
name|mailcall
operator|=
literal|"(Mail) "
expr_stmt|;
block|}
name|mailcount
operator|%=
literal|10
expr_stmt|;
comment|/* check every 10 articles */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|setdfltcmd
parameter_list|()
block|{
if|if
condition|(
name|toread
index|[
name|ng
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|ARTSEARCH
if|if
condition|(
name|srchahead
condition|)
name|dfltcmd
operator|=
literal|"^Nnpq"
expr_stmt|;
else|else
endif|#
directive|endif
name|dfltcmd
operator|=
literal|"npq"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
name|dfltcmd
operator|=
literal|"qnp"
expr_stmt|;
else|else
name|dfltcmd
operator|=
literal|"npq"
expr_stmt|;
block|}
block|}
end_function

end_unit

