begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: term.c,v 4.3.1.2 85/05/16 16:45:35 lwall Exp $  *  * $Log:	term.c,v $  * Revision 4.3.1.2  85/05/16  16:45:35  lwall  * Forced \r to \n on input.  * Fix for terminfo braindamage regarding bc emulation.  *   * Revision 4.3.1.1  85/05/10  11:41:03  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:51:10  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"cheat.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_decl_stmt
name|char
name|ERASECH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rubout character */
end_comment

begin_decl_stmt
name|char
name|KILLCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line delete character */
end_comment

begin_decl_stmt
name|char
name|tcarea
index|[
name|TCSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* area for "compiled" termcap strings */
end_comment

begin_comment
comment|/* guarantee capability pointer != Nullch */
end_comment

begin_comment
comment|/* (I believe terminfo will ignore the&tmpaddr argument.) */
end_comment

begin_define
define|#
directive|define
name|Tgetstr
parameter_list|(
name|key
parameter_list|)
value|((tmpstr = tgetstr(key,&tmpaddr)) ? tmpstr : nullstr)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_struct
struct|struct
name|keymap
block|{
name|char
name|km_type
index|[
literal|128
index|]
decl_stmt|;
union|union
name|km_union
block|{
name|struct
name|keymap
modifier|*
name|km_km
decl_stmt|;
name|char
modifier|*
name|km_str
decl_stmt|;
block|}
name|km_ptr
index|[
literal|128
index|]
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KM_NOTHIN
value|0
end_define

begin_define
define|#
directive|define
name|KM_STRING
value|1
end_define

begin_define
define|#
directive|define
name|KM_KEYMAP
value|2
end_define

begin_define
define|#
directive|define
name|KM_BOGUS
value|3
end_define

begin_define
define|#
directive|define
name|KM_TMASK
value|3
end_define

begin_define
define|#
directive|define
name|KM_GSHIFT
value|4
end_define

begin_define
define|#
directive|define
name|KM_GMASK
value|7
end_define

begin_typedef
typedef|typedef
name|struct
name|keymap
name|KEYMAP
typedef|;
end_typedef

begin_decl_stmt
name|KEYMAP
modifier|*
name|topmap
name|INIT
argument_list|(
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|mac_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|KEYMAP
modifier|*
name|newkeymap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|show_keymap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pushstring
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* terminal initialization */
end_comment

begin_function
name|void
name|term_init
parameter_list|()
block|{
name|savetty
argument_list|()
expr_stmt|;
comment|/* remember current tty state */
ifdef|#
directive|ifdef
name|TERMIO
name|ospeed
operator|=
name|_tty
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
comment|/* for tputs() */
name|ERASECH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
comment|/* for finish_command() */
name|KILLCH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
comment|/* for finish_command() */
else|#
directive|else
name|ospeed
operator|=
name|_tty
operator|.
name|sg_ospeed
expr_stmt|;
comment|/* for tputs() */
name|ERASECH
operator|=
name|_tty
operator|.
name|sg_erase
expr_stmt|;
comment|/* for finish_command() */
name|KILLCH
operator|=
name|_tty
operator|.
name|sg_kill
expr_stmt|;
comment|/* for finish_command() */
endif|#
directive|endif
comment|/* The following could be a table but I can't be sure that there isn't */
comment|/* some degree of sparsity out there in the world. */
switch|switch
condition|(
name|ospeed
condition|)
block|{
comment|/* 1 second of padding */
ifdef|#
directive|ifdef
name|BEXTA
case|case
name|BEXTA
case|:
name|just_a_sec
operator|=
literal|1920
expr_stmt|;
break|break;
else|#
directive|else
ifdef|#
directive|ifdef
name|B19200
case|case
name|B19200
case|:
name|just_a_sec
operator|=
literal|1920
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|B9600
case|:
name|just_a_sec
operator|=
literal|960
expr_stmt|;
break|break;
case|case
name|B4800
case|:
name|just_a_sec
operator|=
literal|480
expr_stmt|;
break|break;
case|case
name|B2400
case|:
name|just_a_sec
operator|=
literal|240
expr_stmt|;
break|break;
case|case
name|B1800
case|:
name|just_a_sec
operator|=
literal|180
expr_stmt|;
break|break;
case|case
name|B1200
case|:
name|just_a_sec
operator|=
literal|120
expr_stmt|;
break|break;
case|case
name|B600
case|:
name|just_a_sec
operator|=
literal|60
expr_stmt|;
break|break;
case|case
name|B300
case|:
name|just_a_sec
operator|=
literal|30
expr_stmt|;
break|break;
comment|/* do I really have to type the rest of this??? */
case|case
name|B200
case|:
name|just_a_sec
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|B150
case|:
name|just_a_sec
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|B134
case|:
name|just_a_sec
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|B110
case|:
name|just_a_sec
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|B75
case|:
name|just_a_sec
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|B50
case|:
name|just_a_sec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|just_a_sec
operator|=
literal|960
expr_stmt|;
break|break;
comment|/* if we are running detached I */
block|}
comment|/*  don't want to know about it! */
block|}
end_function

begin_comment
comment|/* set terminal characteristics */
end_comment

begin_function
name|void
name|term_set
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
comment|/* temp area for "uncompiled" termcap entry */
block|{
name|char
modifier|*
name|tmpaddr
decl_stmt|;
comment|/* must not be register */
specifier|register
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|PENDING
ifndef|#
directive|ifndef
name|FIONREAD
comment|/* do no delay reads on something that always gets closed on exit */
name|devtty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|devtty
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
argument|cantopen
argument_list|,
literal|"/dev/tty"
argument_list|)
name|FLUSH
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|devtty
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* get all that good termcap stuff */
ifdef|#
directive|ifdef
name|HAVETERMLIB
name|status
operator|=
name|tgetent
argument_list|(
name|tcbuf
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get termcap entry */
if|if
condition|(
name|status
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"No termcap %s found.\n"
argument_list|,
argument|status ?
literal|"file"
argument|:
literal|"entry"
argument_list|)
name|FLUSH
expr_stmt|;
else|#
directive|else
name|fputs
argument_list|(
literal|"Termcap botch\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
endif|#
directive|endif
name|finalize
argument_list|(
literal|1
argument_list|)
decl_stmt|;
block|}
name|tmpaddr
operator|=
name|tcarea
expr_stmt|;
comment|/* set up strange tgetstr pointer */
name|s
operator|=
name|Tgetstr
argument_list|(
literal|"pc"
argument_list|)
expr_stmt|;
comment|/* get pad character */
name|PC
operator|=
operator|*
name|s
expr_stmt|;
comment|/* get it where tputs wants it */
if|if
condition|(
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
block|{
comment|/* is backspace not used? */
name|BC
operator|=
name|Tgetstr
argument_list|(
literal|"bc"
argument_list|)
expr_stmt|;
comment|/* find out what is */
if|if
condition|(
name|BC
operator|==
name|nullstr
condition|)
comment|/* terminfo grok's 'bs' but not 'bc' */
name|BC
operator|=
name|Tgetstr
argument_list|(
literal|"le"
argument_list|)
expr_stmt|;
block|}
else|else
name|BC
operator|=
literal|"\b"
expr_stmt|;
comment|/* make a backspace handy */
name|UP
operator|=
name|Tgetstr
argument_list|(
literal|"up"
argument_list|)
expr_stmt|;
comment|/* move up a line */
if|if
condition|(
operator|!
operator|*
name|UP
condition|)
comment|/* no UP string? */
name|marking
operator|=
literal|0
expr_stmt|;
comment|/* disable any marking */
if|if
condition|(
name|muck_up_clear
condition|)
comment|/* this is for weird HPs */
name|CL
operator|=
literal|"\n\n\n\n"
expr_stmt|;
else|else
name|CL
operator|=
name|Tgetstr
argument_list|(
literal|"cl"
argument_list|)
expr_stmt|;
comment|/* get clear string */
name|CE
operator|=
name|Tgetstr
argument_list|(
literal|"ce"
argument_list|)
expr_stmt|;
comment|/* clear to end of line string */
ifdef|#
directive|ifdef
name|CLEAREOL
name|CM
operator|=
name|Tgetstr
argument_list|(
literal|"cm"
argument_list|)
expr_stmt|;
comment|/* cursor motion - PWP */
name|HO
operator|=
name|Tgetstr
argument_list|(
literal|"ho"
argument_list|)
expr_stmt|;
comment|/* home cursor if no CM - PWP */
name|CD
operator|=
name|Tgetstr
argument_list|(
literal|"cd"
argument_list|)
expr_stmt|;
comment|/* clear to end of display - PWP */
if|if
condition|(
operator|!
operator|*
name|CE
operator|||
operator|!
operator|*
name|CD
operator|||
operator|(
operator|!
operator|*
name|CM
operator|&&
operator|!
operator|*
name|HO
operator|)
condition|)
comment|/* can we CE, CD, and home? */
name|can_home_clear
operator|=
name|FALSE
expr_stmt|;
comment|/*  no, so disable use of clear eol */
endif|#
directive|endif
endif|CLEAREOL
name|SO
operator|=
name|Tgetstr
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
comment|/* begin standout */
name|SE
operator|=
name|Tgetstr
argument_list|(
literal|"se"
argument_list|)
expr_stmt|;
comment|/* end standout */
if|if
condition|(
operator|(
name|SG
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|SG
operator|=
literal|0
expr_stmt|;
comment|/* blanks left by SG, SE */
name|US
operator|=
name|Tgetstr
argument_list|(
literal|"us"
argument_list|)
expr_stmt|;
comment|/* start underline */
name|UE
operator|=
name|Tgetstr
argument_list|(
literal|"ue"
argument_list|)
expr_stmt|;
comment|/* end underline */
if|if
condition|(
operator|(
name|UG
operator|=
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|UG
operator|=
literal|0
expr_stmt|;
comment|/* blanks left by US, UE */
if|if
condition|(
operator|*
name|US
condition|)
name|UC
operator|=
name|nullstr
expr_stmt|;
comment|/* UC must not be NULL */
else|else
name|UC
operator|=
name|Tgetstr
argument_list|(
literal|"uc"
argument_list|)
expr_stmt|;
comment|/* underline a character */
if|if
condition|(
operator|!
operator|*
name|US
operator|&&
operator|!
operator|*
name|UC
condition|)
block|{
comment|/* no underline mode? */
name|US
operator|=
name|SO
expr_stmt|;
comment|/* substitute standout mode */
name|UE
operator|=
name|SE
expr_stmt|;
name|UG
operator|=
name|SG
expr_stmt|;
block|}
name|LINES
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
comment|/* lines per page */
name|COLS
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
comment|/* columns on page */
name|AM
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
comment|/* terminal wraps automatically? */
name|XN
operator|=
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
expr_stmt|;
comment|/* then eats next newline? */
name|VB
operator|=
name|Tgetstr
argument_list|(
literal|"vb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|VB
condition|)
name|VB
operator|=
literal|"\007"
expr_stmt|;
name|CR
operator|=
name|Tgetstr
argument_list|(
literal|"cr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|CR
condition|)
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"nc"
argument_list|)
operator|&&
operator|*
name|UP
condition|)
block|{
name|CR
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|strlen
argument_list|(
name|UP
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|CR
argument_list|,
literal|"%s\r"
argument_list|,
name|UP
argument_list|)
expr_stmt|;
block|}
else|else
name|CR
operator|=
literal|"\r"
expr_stmt|;
block|}
else|#
directive|else
operator|??????
comment|/* Roll your own... */
endif|#
directive|endif
if|if
condition|(
name|LINES
operator|>
literal|0
condition|)
block|{
comment|/* is this a crt? */
if|if
condition|(
operator|!
name|initlines
condition|)
comment|/* no -i? */
if|if
condition|(
name|ospeed
operator|>=
name|B9600
condition|)
comment|/* whole page at>= 9600 baud */
name|initlines
operator|=
name|LINES
expr_stmt|;
elseif|else
if|if
condition|(
name|ospeed
operator|>=
name|B4800
condition|)
comment|/* 16 lines at 4800 */
name|initlines
operator|=
literal|16
expr_stmt|;
else|else
comment|/* otherwise just header */
name|initlines
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* not a crt */
name|LINES
operator|=
literal|30000
expr_stmt|;
comment|/* so don't page */
name|CL
operator|=
literal|"\n\n"
expr_stmt|;
comment|/* put a couple of lines between */
if|if
condition|(
operator|!
name|initlines
condition|)
comment|/* make initlines reasonable */
name|initlines
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|COLS
operator|<=
literal|0
condition|)
name|COLS
operator|=
literal|80
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
comment|/* turn off echo */
name|crmode
argument_list|()
expr_stmt|;
comment|/* enter cbreak mode */
ifdef|#
directive|ifdef
name|PUSHBACK
name|mac_init
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_function
name|void
name|mac_init
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
block|{
name|char
name|tmpbuf
index|[
literal|1024
index|]
decl_stmt|;
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|getval
argument_list|(
literal|"RNMACRO"
argument_list|,
name|RNMACRO
argument_list|)
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfp
operator|!=
name|Nullfp
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|tcbuf
argument_list|,
literal|1024
argument_list|,
name|tmpfp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|mac_line
argument_list|(
name|tcbuf
argument_list|,
name|tmpbuf
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mac_line
parameter_list|(
name|line
parameter_list|,
name|tmpbuf
parameter_list|,
name|tbsize
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|int
name|tbsize
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|register
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|int
name|garbage
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|override
index|[]
init|=
literal|"\nkeymap overrides string\n"
decl_stmt|;
if|if
condition|(
name|topmap
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
name|topmap
operator|=
name|newkeymap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'#'
operator|||
operator|*
name|line
operator|==
literal|'\n'
condition|)
return|return;
if|if
condition|(
name|line
index|[
name|ch
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
name|ch
index|]
operator|=
literal|'\0'
expr_stmt|;
name|m
operator|=
name|dointerp
argument_list|(
name|tmpbuf
argument_list|,
name|tbsize
argument_list|,
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|m
condition|)
return|return;
while|while
condition|(
operator|*
name|m
operator|==
literal|' '
operator|||
operator|*
name|m
operator|==
literal|'\t'
condition|)
name|m
operator|++
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tmpbuf
operator|,
name|curmap
operator|=
name|topmap
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|ch
operator|=
operator|*
name|s
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'+'
operator|&&
name|isdigit
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|garbage
operator|=
operator|(
operator|*
name|s
operator|&
name|KM_GMASK
operator|)
operator|<<
name|KM_GSHIFT
expr_stmt|;
block|}
else|else
name|garbage
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|&
name|KM_TMASK
operator|)
operator|==
name|KM_STRING
condition|)
block|{
name|puts
argument_list|(
argument|override
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|free
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
argument_list|)
expr_stmt|;
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
operator|=
name|Nullch
expr_stmt|;
block|}
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|=
name|KM_KEYMAP
operator|+
name|garbage
expr_stmt|;
if|if
condition|(
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
operator|=
name|newkeymap
argument_list|()
expr_stmt|;
name|curmap
operator|=
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|&
name|KM_TMASK
operator|)
operator|==
name|KM_KEYMAP
condition|)
name|puts
argument_list|(
argument|override
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
else|else
block|{
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|=
name|KM_STRING
operator|+
name|garbage
expr_stmt|;
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
operator|=
name|savestr
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|KEYMAP
modifier|*
name|newkeymap
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|KEYMAP
modifier|*
name|map
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|map
operator|=
operator|(
name|KEYMAP
operator|*
operator|)
name|safemalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|KEYMAP
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|map
operator|=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
for|for
control|(
name|i
operator|=
literal|127
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|map
operator|->
name|km_ptr
index|[
name|i
index|]
operator|.
name|km_km
operator|=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
expr_stmt|;
name|map
operator|->
name|km_type
index|[
name|i
index|]
operator|=
name|KM_NOTHIN
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function

begin_function
name|void
name|show_macros
parameter_list|()
block|{
name|char
name|prebuf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|topmap
operator|!=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
block|{
name|print_lines
argument_list|(
literal|"Macros:\n"
argument_list|,
name|STANDOUT
argument_list|)
expr_stmt|;
operator|*
name|prebuf
operator|=
literal|'\0'
expr_stmt|;
name|show_keymap
argument_list|(
name|topmap
argument_list|,
name|prebuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|show_keymap
parameter_list|(
name|curmap
parameter_list|,
name|prefix
parameter_list|)
specifier|register
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
init|=
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
specifier|register
name|int
name|kt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|=
name|curmap
operator|->
name|km_type
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|' '
condition|)
name|sprintf
argument_list|(
name|next
argument_list|,
literal|"^%c"
argument_list|,
name|i
operator|+
literal|64
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|' '
condition|)
name|strcpy
argument_list|(
name|next
argument_list|,
literal|"\\040"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|127
condition|)
name|strcpy
argument_list|(
name|next
argument_list|,
literal|"^?"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|next
argument_list|,
literal|"%c"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kt
operator|>>
name|KM_GSHIFT
operator|)
operator|&
name|KM_GMASK
condition|)
block|{
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"+%d"
argument_list|,
operator|(
name|kt
operator|>>
name|KM_GSHIFT
operator|)
operator|&
name|KM_GMASK
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|next
argument_list|,
name|cmd_buf
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kt
operator|&
name|KM_TMASK
condition|)
block|{
case|case
name|KM_NOTHIN
case|:
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s	%c\n"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_lines
argument_list|(
name|cmd_buf
argument_list|,
name|NOMARKING
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_KEYMAP
case|:
name|show_keymap
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
operator|(
name|char
operator|)
name|i
index|]
operator|.
name|km_km
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_STRING
case|:
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s	%s\n"
argument_list|,
name|prefix
argument_list|,
name|curmap
operator|->
name|km_ptr
index|[
name|i
index|]
operator|.
name|km_str
argument_list|)
expr_stmt|;
name|print_lines
argument_list|(
name|cmd_buf
argument_list|,
name|NOMARKING
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_BOGUS
case|:
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s	BOGUS\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|print_lines
argument_list|(
name|cmd_buf
argument_list|,
name|STANDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* routine to pass to tputs */
end_comment

begin_function
name|char
name|putchr
parameter_list|(
name|ch
parameter_list|)
specifier|register
name|char
name|ch
decl_stmt|;
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|ch
operator|=
name|Null
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|ch
operator|=
name|ch
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* input the 2nd and succeeding characters of a multi-character command */
end_comment

begin_comment
comment|/* returns TRUE if command finished, FALSE if they rubbed out first character */
end_comment

begin_function
name|bool
name|finish_command
parameter_list|(
name|donewline
parameter_list|)
name|int
name|donewline
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|bool
name|quoteone
init|=
name|FALSE
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
name|FINISHCMD
condition|)
comment|/* someone faking up a command? */
return|return
name|TRUE
return|;
do|do
block|{
name|top
label|:
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator||
literal|64
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\177'
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* echo previous character */
name|s
operator|++
expr_stmt|;
name|re_read
label|:
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|getcmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoteone
condition|)
block|{
name|quoteone
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|errno
operator|||
operator|*
name|s
operator|==
name|Ctl
argument_list|(
literal|'l'
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
name|Ctl
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
comment|/* force rewrite on CONT */
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\033'
condition|)
block|{
comment|/* substitution desired? */
ifdef|#
directive|ifdef
name|ESCSUBS
name|char
name|tmpbuf
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|cpybuf
decl_stmt|;
name|tmpbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|read_tty
argument_list|(
operator|&
name|tmpbuf
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RAWONLY
name|tmpbuf
index|[
literal|1
index|]
operator|&=
literal|0177
expr_stmt|;
endif|#
directive|endif
name|tmpbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tmpbuf
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
operator|(
name|void
operator|)
name|help_subs
argument_list|()
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
elseif|else
if|if
condition|(
name|tmpbuf
index|[
literal|1
index|]
operator|==
literal|'\033'
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|cpybuf
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|interp
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|cpybuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpybuf
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
else|else
block|{
name|interp
argument_list|(
name|s
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
operator|-
operator|(
name|s
operator|-
name|buf
operator|)
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|s
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
goto|goto
name|re_read
goto|;
else|#
directive|else
name|notincl
argument_list|(
literal|"^["
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|ERASECH
condition|)
block|{
comment|/* they want to rubout a char? */
name|rubout
argument_list|()
expr_stmt|;
name|s
operator|--
expr_stmt|;
comment|/* discount the char rubbed out */
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\177'
condition|)
name|rubout
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|buf
condition|)
block|{
comment|/* entire string gone? */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* return to single char command mode */
return|return
name|FALSE
return|;
block|}
else|else
goto|goto
name|re_read
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|KILLCH
condition|)
block|{
comment|/* wipe out the whole line? */
while|while
condition|(
name|s
operator|--
operator|!=
name|buf
condition|)
block|{
comment|/* emulate that many ERASEs */
name|rubout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\177'
condition|)
name|rubout
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* return to single char mode */
block|}
ifdef|#
directive|ifdef
name|WORDERASE
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|Ctl
argument_list|(
literal|'w'
argument_list|)
condition|)
block|{
comment|/* wipe out one word? */
operator|*
name|s
operator|--
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|isspace
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rubout
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|--
operator|==
name|buf
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* return to single char mode */
block|}
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\177'
condition|)
name|rubout
argument_list|()
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|Ctl
argument_list|(
literal|'r'
argument_list|)
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|reprint
argument_list|()
expr_stmt|;
goto|goto
name|re_read
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|Ctl
argument_list|(
literal|'v'
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|getcmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|quoteone
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
do|;
comment|/* till a newline (not echoed) */
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate the string nicely */
if|if
condition|(
name|donewline
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* say we succeeded */
block|}
end_function

begin_comment
comment|/* discard any characters typed ahead */
end_comment

begin_function
name|void
name|eat_typeahead
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|PUSHBACK
if|if
condition|(
operator|!
name|typeahead
operator|&&
name|nextin
operator|==
name|nextout
condition|)
comment|/* cancel only keyboard stuff */
else|#
directive|else
if|if
condition|(
operator|!
name|typeahead
condition|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|PENDING
while|while
condition|(
name|input_pending
argument_list|()
condition|)
name|read_tty
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* this is probably v7 */
name|ioctl
argument_list|(
name|_tty_ch
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|settle_down
parameter_list|()
block|{
name|dingaling
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSHBACK
name|nextout
operator|=
name|nextin
expr_stmt|;
comment|/* empty circlebuf */
endif|#
directive|endif
name|eat_typeahead
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_comment
comment|/* read a character from the terminal, with multi-character pushback */
end_comment

begin_function
name|int
name|read_tty
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|nextout
operator|!=
name|nextin
condition|)
block|{
operator|*
name|addr
operator|=
name|circlebuf
index|[
name|nextout
operator|++
index|]
expr_stmt|;
name|nextout
operator|%=
name|PUSHSIZE
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|size
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RAWONLY
operator|*
name|addr
operator|&=
literal|0177
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PENDING
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|FIONREAD
end_ifndef

begin_function
name|int
name|circfill
parameter_list|()
block|{
specifier|register
name|int
name|howmany
init|=
name|read
argument_list|(
name|devtty
argument_list|,
name|circlebuf
operator|+
name|nextin
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|howmany
condition|)
block|{
name|nextin
operator|+=
name|howmany
expr_stmt|;
name|nextin
operator|%=
name|PUSHSIZE
expr_stmt|;
block|}
return|return
name|howmany
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|PENDING
end_endif

begin_endif
endif|#
directive|endif
endif|FIONREAD
end_endif

begin_function
name|void
name|pushchar
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|nextout
operator|--
expr_stmt|;
if|if
condition|(
name|nextout
operator|<
literal|0
condition|)
name|nextout
operator|=
name|PUSHSIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextout
operator|==
name|nextin
condition|)
block|{
name|fputs
argument_list|(
literal|"\npushback buffer overflow\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|circlebuf
index|[
name|nextout
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
else|PUSHBACK
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|read_tty
end_ifndef

begin_comment
comment|/* read a character from the terminal, with hacks for O_NDELAY reads */
end_comment

begin_function
name|int
name|read_tty
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|is_input
condition|)
block|{
operator|*
name|addr
operator|=
name|pending_ch
expr_stmt|;
name|is_input
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|size
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
ifdef|#
directive|ifdef
name|RAWONLY
operator|*
name|addr
operator|&=
literal|0177
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|read_tty
end_endif

begin_endif
endif|#
directive|endif
endif|PUSHBACK
end_endif

begin_comment
comment|/* print an underlined string, one way or another */
end_comment

begin_function
name|void
name|underprint
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|assert
argument_list|(
name|UC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|UC
condition|)
block|{
comment|/* char by char underline? */
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
comment|/* back up over it */
name|underchar
argument_list|()
expr_stmt|;
comment|/* and do the underline */
name|putchar
argument_list|(
operator|*
name|s
operator|+
literal|64
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
comment|/* back up over it */
name|underchar
argument_list|()
expr_stmt|;
comment|/* and do the underline */
block|}
else|else
block|{
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
comment|/* back up over it */
name|underchar
argument_list|()
expr_stmt|;
comment|/* and do the underline */
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* start and stop underline */
name|underline
argument_list|()
expr_stmt|;
comment|/* start underlining */
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|un_underline
argument_list|()
expr_stmt|;
comment|/* stop underlining */
block|}
block|}
end_function

begin_comment
comment|/* keep screen from flashing strangely on magic cookie terminals */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOFIREWORKS
end_ifdef

begin_function
name|void
name|no_sofire
parameter_list|()
block|{
if|if
condition|(
operator|*
name|UP
operator|&&
operator|*
name|SE
condition|)
block|{
comment|/* should we disable fireworks? */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|un_standout
argument_list|()
expr_stmt|;
name|up_line
argument_list|()
expr_stmt|;
name|carriage_return
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|no_ulfire
parameter_list|()
block|{
if|if
condition|(
operator|*
name|UP
operator|&&
operator|*
name|US
condition|)
block|{
comment|/* should we disable fireworks? */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|un_underline
argument_list|()
expr_stmt|;
name|up_line
argument_list|()
expr_stmt|;
name|carriage_return
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* get a character into a buffer */
end_comment

begin_function
name|void
name|getcmd
parameter_list|(
name|whatbuf
parameter_list|)
specifier|register
name|char
modifier|*
name|whatbuf
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PUSHBACK
specifier|register
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|bool
name|no_macros
decl_stmt|;
name|int
name|times
init|=
literal|0
decl_stmt|;
comment|/* loop detector */
name|char
name|scrchar
decl_stmt|;
name|tryagain
label|:
name|curmap
operator|=
name|topmap
expr_stmt|;
name|no_macros
operator|=
operator|(
name|whatbuf
operator|!=
name|buf
operator|&&
name|nextin
operator|==
name|nextout
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|int_count
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_tty
argument_list|(
name|whatbuf
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|errno
condition|)
name|errno
operator|=
name|EINTR
expr_stmt|;
if|if
condition|(
name|errno
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|perror
argument_list|(
name|readerr
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PUSHBACK
if|if
condition|(
operator|*
name|whatbuf
operator|&
literal|0200
operator|||
name|no_macros
condition|)
block|{
operator|*
name|whatbuf
operator|&=
literal|0177
expr_stmt|;
goto|goto
name|got_canonical
goto|;
block|}
if|if
condition|(
name|curmap
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
goto|goto
name|got_canonical
goto|;
for|for
control|(
name|i
operator|=
operator|(
name|curmap
operator|->
name|km_type
index|[
operator|*
name|whatbuf
index|]
operator|>>
name|KM_GSHIFT
operator|)
operator|&
name|KM_GMASK
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
name|read_tty
argument_list|(
operator|&
name|scrchar
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|curmap
operator|->
name|km_type
index|[
operator|*
name|whatbuf
index|]
operator|&
name|KM_TMASK
condition|)
block|{
case|case
name|KM_NOTHIN
case|:
comment|/* no entry? */
if|if
condition|(
name|curmap
operator|==
name|topmap
condition|)
comment|/* unmapped canonical */
goto|goto
name|got_canonical
goto|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|tryagain
goto|;
case|case
name|KM_KEYMAP
case|:
comment|/* another keymap? */
name|curmap
operator|=
name|curmap
operator|->
name|km_ptr
index|[
operator|*
name|whatbuf
index|]
operator|.
name|km_km
expr_stmt|;
name|assert
argument_list|(
name|curmap
operator|!=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_STRING
case|:
comment|/* a string? */
name|pushstring
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
operator|*
name|whatbuf
index|]
operator|.
name|km_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|times
operator|>
literal|20
condition|)
block|{
comment|/* loop? */
name|fputs
argument_list|(
literal|"\nmacro loop?\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
block|}
name|no_macros
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|RAWONLY
operator|*
name|whatbuf
operator|&=
literal|0177
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
block|}
name|got_canonical
label|:
ifndef|#
directive|ifndef
name|TERMIO
if|if
condition|(
operator|*
name|whatbuf
operator|==
literal|'\r'
condition|)
operator|*
name|whatbuf
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|whatbuf
operator|==
name|buf
condition|)
name|whatbuf
index|[
literal|1
index|]
operator|=
name|FINISHCMD
expr_stmt|;
comment|/* tell finish_command to work */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_function
name|void
name|pushstring
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tmpbuf
index|[
name|PUSHSIZE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|tmpbuf
decl_stmt|;
name|assert
argument_list|(
name|str
operator|!=
name|Nullch
argument_list|)
expr_stmt|;
name|interp
argument_list|(
name|s
argument_list|,
name|PUSHSIZE
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|s
index|[
name|i
index|]
operator|^=
literal|0200
expr_stmt|;
name|pushchar
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|get_anything
parameter_list|()
block|{
name|char
name|tmpbuf
index|[
literal|2
index|]
decl_stmt|;
name|reask_anything
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|standout
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"[Type space to continue] "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"[MORE] "
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|un_standout
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|eat_typeahead
argument_list|()
expr_stmt|;
if|if
condition|(
name|int_count
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|collect_subjects
argument_list|()
expr_stmt|;
comment|/* loads subject cache until */
comment|/* input is pending */
name|getcmd
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|tmpbuf
operator|==
literal|'\f'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* if return from stop signal */
goto|goto
name|reask_anything
goto|;
comment|/* give them a prompt again */
block|}
if|if
condition|(
operator|*
name|tmpbuf
operator|==
literal|'h'
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nType q to quit or space to continue.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nq to quit, space to continue.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
goto|goto
name|reask_anything
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tmpbuf
operator|!=
literal|' '
operator|&&
operator|*
name|tmpbuf
operator|!=
literal|'\n'
condition|)
block|{
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
return|return
operator|*
name|tmpbuf
operator|==
literal|'q'
condition|?
operator|-
literal|1
else|:
operator|*
name|tmpbuf
return|;
block|}
if|if
condition|(
operator|*
name|tmpbuf
operator|==
literal|'\n'
condition|)
block|{
name|page_line
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|page_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|erase_screen
condition|)
comment|/* -e? */
name|clear
argument_list|()
expr_stmt|;
comment|/* clear screen */
else|else
block|{
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|in_char
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
name|oldmode
init|=
name|mode
decl_stmt|;
name|reask_in_char
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|fputs
argument_list|(
name|prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|eat_typeahead
argument_list|()
expr_stmt|;
name|mode
operator|=
literal|'m'
expr_stmt|;
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* if return from stop signal */
goto|goto
name|reask_in_char
goto|;
comment|/* give them a prompt again */
block|}
name|mode
operator|=
name|oldmode
expr_stmt|;
block|}
end_function

begin_function
name|int
name|print_lines
parameter_list|(
name|what_to_print
parameter_list|,
name|hilite
parameter_list|)
name|char
modifier|*
name|what_to_print
decl_stmt|;
name|int
name|hilite
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|page_line
operator|<
literal|0
condition|)
comment|/* they do not want to see this? */
return|return
operator|-
literal|1
return|;
for|for
control|(
name|s
operator|=
name|what_to_print
init|;
operator|*
name|s
condition|;
control|)
block|{
if|if
condition|(
name|page_line
operator|>=
name|LINES
operator|||
name|int_count
condition|)
block|{
if|if
condition|(
name|i
operator|=
operator|-
literal|1
operator|,
name|int_count
operator|||
operator|(
name|i
operator|=
name|get_anything
argument_list|()
operator|)
condition|)
block|{
name|page_line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* disable further print_lines */
return|return
name|i
return|;
block|}
block|}
name|page_line
operator|++
expr_stmt|;
if|if
condition|(
name|hilite
operator|==
name|STANDOUT
condition|)
block|{
ifdef|#
directive|ifdef
name|NOFIREWORKS
if|if
condition|(
name|erase_screen
condition|)
name|no_sofire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|standout
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hilite
operator|==
name|UNDERLINE
condition|)
block|{
ifdef|#
directive|ifdef
name|NOFIREWORKS
if|if
condition|(
name|erase_screen
condition|)
name|no_ulfire
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|underline
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|s
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|>=
literal|' '
condition|)
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|i
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|=
literal|32000
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|hilite
operator|==
name|STANDOUT
condition|)
name|un_standout
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|hilite
operator|==
name|UNDERLINE
condition|)
name|un_underline
argument_list|()
expr_stmt|;
if|if
condition|(
name|AM
operator|&&
name|i
operator|==
name|COLS
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|page_init
parameter_list|()
block|{
name|page_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|erase_screen
condition|)
name|clear
argument_list|()
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pad
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
condition|;
operator|--
name|i
control|)
name|putchar
argument_list|(
name|PC
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* echo the command just typed */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VERIFY
end_ifdef

begin_function
name|void
name|printcmd
parameter_list|()
block|{
if|if
condition|(
name|verify
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
name|FINISHCMD
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|buf
operator||
literal|64
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
name|backspace
argument_list|()
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|rubout
parameter_list|()
block|{
name|backspace
argument_list|()
expr_stmt|;
comment|/* do the old backspace, */
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/*   space, */
name|backspace
argument_list|()
expr_stmt|;
comment|/*     backspace trick */
block|}
end_function

begin_function
name|void
name|reprint
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|fputs
argument_list|(
literal|"^R\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
block|{
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|s
operator||
literal|64
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CLEAREOL
end_ifdef

begin_comment
comment|/* start of additions by Paul Placeway (PWP) */
end_comment

begin_function
name|void
name|home_cursor
parameter_list|()
block|{
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
operator|*
name|HO
condition|)
block|{
comment|/* no home sequence? */
if|if
condition|(
operator|!
operator|*
name|CM
condition|)
block|{
comment|/* no cursor motion either? */
name|fputs
argument_list|(
literal|"\n\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
comment|/* forget it. */
block|}
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
comment|/* go to home via CM */
return|return;
block|}
else|else
block|{
comment|/* we have home sequence */
name|tputs
argument_list|(
name|HO
argument_list|,
literal|1
argument_list|,
name|putchr
argument_list|)
expr_stmt|;
comment|/* home via HO */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|CLEAREOL
end_endif

end_unit

