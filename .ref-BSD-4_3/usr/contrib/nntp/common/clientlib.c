begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * NNTP client routines.  *  * %W%	(Berkeley) %G%  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"response_codes.h"
end_include

begin_decl_stmt
name|FILE
modifier|*
name|ser_rd_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ser_wr_fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * server_init  Get a connection to the remote news server.  *  *	Parameters:	"machine" is the machine to connect to.  *  *	Returns:	-1 on error, 0 otherwise.  *  *	Side effects:	Connects to server.  */
end_comment

begin_macro
name|server_init
argument_list|(
argument|machine
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|machine
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sockt_rd
decl_stmt|,
name|sockt_wr
decl_stmt|;
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
name|sockt_rd
operator|=
name|getsocket
argument_list|(
name|machine
argument_list|)
expr_stmt|;
comment|/* Get a socket to the */
if|if
condition|(
name|sockt_rd
operator|<
literal|0
condition|)
comment|/* server, abort on */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Now we'll make file pointers (i.e., buffered I/O) out of 	 * the socket file descriptor.  Note that we can't just 	 * open a fp for reading and writing -- we have to open 	 * up two separate fp's, one for reading, one for writing. 	 */
if|if
condition|(
operator|(
name|ser_rd_fp
operator|=
name|fdopen
argument_list|(
name|sockt_rd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"server_init: fdopen #1"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sockt_wr
operator|=
name|dup
argument_list|(
name|sockt_rd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ser_wr_fp
operator|=
name|fdopen
argument_list|(
name|sockt_wr
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"server_init: fdopen #2"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Now get the server's signon message */
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
name|CHAR_OK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockt_rd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockt_wr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* And abort if it's not good */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * getsocket -- get us a socket connected to the news server.  *  *	Parameters:	"machine" is the machine the server is running on.  *  *	Returns:	Socket connected to the news server if  *			all is ok, else -1 on error.  *  *	Side effects:	Connects to server.  *  *	Errors:		Printed via perror.  */
end_comment

begin_macro
name|getsocket
argument_list|(
argument|machine
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|machine
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|servent
modifier|*
name|getservbyname
argument_list|()
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|gethostbyname
argument_list|()
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"nntp"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nntp/tcp: Unknown service.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|machine
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown host.\n"
argument_list|,
name|machine
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Get the socket */
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* And then connect */
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * put_server -- send a line of text to the server, terminating it  * with CR and LF, as per ARPA standard.  *  *	Parameters:	"string" is the string to be sent to the  *			server.  *  *	Returns:	Nothing.  *  *	Side effects:	Talks to the server.  *  *	Note:		This routine flushes the buffer each time  *			it is called.  For large transmissions  *			(i.e., posting news) don't use it.  Instead,  *			do the fprintf's yourself, and then a final  *			fflush.  */
end_comment

begin_function
name|void
name|put_server
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
comment|/* fprintf(stderr, ">>> %s\n", string); */
name|fprintf
argument_list|(
name|ser_wr_fp
argument_list|,
literal|"%s\r\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ser_wr_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get_server -- get a line of text from the server.  Strips  * CR's and LF's.  *  *	Parameters:	"string" has the buffer space for the  *			line received.  *			"size" is the size of the buffer.  *  *	Returns:	-1 on error, 0 otherwise.  *  *	Side effects:	Talks to server, changes contents of "string".  */
end_comment

begin_macro
name|get_server
argument_list|(
argument|string
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
name|fgets
argument_list|(
name|string
argument_list|,
name|size
argument_list|,
name|ser_rd_fp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|string
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|string
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* fprintf(stderr, "<<< %s\n", string); */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * close_server -- close the connection to the server, after sending  *		the "quit" command.  *  *	Parameters:	None.  *  *	Returns:	Nothing.  *  *	Side effects:	Closes the connection with the server.  *			You can't use "put_server" or "get_server"  *			after this routine is called.  */
end_comment

begin_function
name|void
name|close_server
parameter_list|()
block|{
name|char
name|ser_line
index|[
literal|256
index|]
decl_stmt|;
name|put_server
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ser_wr_fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ser_rd_fp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

