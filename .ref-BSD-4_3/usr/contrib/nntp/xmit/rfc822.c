begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Get header info from mail-format file. ** Return non-zero on success. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_include
include|#
directive|include
file|"llist.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|hfgets
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|errmsg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strpbrk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|cgtdate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|strlen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FROM
value|1
end_define

begin_define
define|#
directive|define
name|NEWSGROUP
value|2
end_define

begin_define
define|#
directive|define
name|TITLE
value|3
end_define

begin_define
define|#
directive|define
name|SUBMIT
value|4
end_define

begin_define
define|#
directive|define
name|RECEIVE
value|5
end_define

begin_define
define|#
directive|define
name|EXPIRE
value|6
end_define

begin_define
define|#
directive|define
name|ARTICLEID
value|7
end_define

begin_define
define|#
directive|define
name|MESSAGEID
value|8
end_define

begin_define
define|#
directive|define
name|REPLYTO
value|9
end_define

begin_define
define|#
directive|define
name|FOLLOWID
value|10
end_define

begin_define
define|#
directive|define
name|CONTROL
value|11
end_define

begin_define
define|#
directive|define
name|SENDER
value|12
end_define

begin_define
define|#
directive|define
name|FOLLOWTO
value|13
end_define

begin_define
define|#
directive|define
name|PATH
value|14
end_define

begin_define
define|#
directive|define
name|POSTVERSION
value|15
end_define

begin_define
define|#
directive|define
name|RELAYVERSION
value|16
end_define

begin_define
define|#
directive|define
name|DISTRIBUTION
value|17
end_define

begin_define
define|#
directive|define
name|ORGANIZATION
value|18
end_define

begin_define
define|#
directive|define
name|NUMLINES
value|19
end_define

begin_define
define|#
directive|define
name|KEYWORDS
value|20
end_define

begin_define
define|#
directive|define
name|APPROVED
value|21
end_define

begin_define
define|#
directive|define
name|NFID
value|22
end_define

begin_define
define|#
directive|define
name|NFFROM
value|23
end_define

begin_define
define|#
directive|define
name|XREF
value|24
end_define

begin_define
define|#
directive|define
name|SUMMARY
value|25
end_define

begin_define
define|#
directive|define
name|FULLNAME
value|26
end_define

begin_define
define|#
directive|define
name|OTHER
value|99
end_define

begin_comment
comment|/* ** This is the list of headers we recognize. ** All others get stripped before they get to inews. */
end_comment

begin_struct
struct|struct
name|htype
block|{
name|char
modifier|*
name|hname
decl_stmt|;
name|int
name|hid
decl_stmt|;
block|}
name|htype
index|[]
init|=
block|{
block|{
literal|"Approved:"
block|,
name|APPROVED
block|}
block|,
block|{
literal|"Article-I.D.:"
block|,
name|ARTICLEID
block|}
block|,
block|{
literal|"Control:"
block|,
name|CONTROL
block|}
block|,
block|{
literal|"Date-Received:"
block|,
name|RECEIVE
block|}
block|,
block|{
literal|"Date:"
block|,
name|SUBMIT
block|}
block|,
block|{
literal|"Distribution:"
block|,
name|DISTRIBUTION
block|}
block|,
block|{
literal|"Expires:"
block|,
name|EXPIRE
block|}
block|,
block|{
literal|"Followup-To:"
block|,
name|FOLLOWTO
block|}
block|,
block|{
literal|"From:"
block|,
name|FROM
block|}
block|,
comment|/*	{"Full-Name:",		FULLNAME},	*/
block|{
literal|"In-Reply-To:"
block|,
name|FOLLOWID
block|}
block|,
block|{
literal|"Keywords:"
block|,
name|KEYWORDS
block|}
block|,
block|{
literal|"Lines:"
block|,
name|NUMLINES
block|}
block|,
block|{
literal|"Message-ID:"
block|,
name|MESSAGEID
block|}
block|,
block|{
literal|"Newsgroups:"
block|,
name|NEWSGROUP
block|}
block|,
block|{
literal|"Nf-From:"
block|,
name|NFFROM
block|}
block|,
block|{
literal|"Nf-ID:"
block|,
name|NFID
block|}
block|,
block|{
literal|"Organization:"
block|,
name|ORGANIZATION
block|}
block|,
block|{
literal|"Path:"
block|,
name|PATH
block|}
block|,
block|{
literal|"Posted:"
block|,
name|SUBMIT
block|}
block|,
block|{
literal|"Posting-Version:"
block|,
name|POSTVERSION
block|}
block|,
comment|/*	{"Received:",		RECEIVE},	a bad name w.r.t. RFC822 */
block|{
literal|"References:"
block|,
name|FOLLOWID
block|}
block|,
block|{
literal|"Relay-Version:"
block|,
name|RELAYVERSION
block|}
block|,
block|{
literal|"Reply-To:"
block|,
name|REPLYTO
block|}
block|,
block|{
literal|"Sender:"
block|,
name|SENDER
block|}
block|,
block|{
literal|"Subject:"
block|,
name|TITLE
block|}
block|,
block|{
literal|"Summary:"
block|,
name|SUMMARY
block|}
block|,
block|{
literal|"Title:"
block|,
name|TITLE
block|}
block|,
block|{
literal|"Xref:"
block|,
name|XREF
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|rfc822read
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|bfr
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bfr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|type
argument_list|(
name|bfr
argument_list|)
decl_stmt|;
name|long
name|curpos
decl_stmt|;
do|do
block|{
name|curpos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|FROM
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|from
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWSGROUP
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TITLE
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|title
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|title
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBMIT
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|subdate
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPIRE
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|expdate
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|expdate
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MESSAGEID
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|ident
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLYTO
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|replyto
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|replyto
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWID
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|followid
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|followid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SENDER
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|sender
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|sender
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWTO
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|followto
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|followto
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONTROL
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|ctlmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|ctlmsg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISTRIBUTION
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|distribution
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|distribution
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORGANIZATION
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|organization
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|organization
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORDS
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|keywords
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|keywords
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|APPROVED
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|approved
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|approved
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUMMARY
case|:
name|getfield
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|summary
argument_list|,
sizeof|sizeof
argument_list|(
name|hp
operator|->
name|summary
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|i
operator|=
name|type
argument_list|(
name|hfgets
argument_list|(
name|bfr
argument_list|,
name|LBUFLEN
argument_list|,
name|fp
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|*
name|bfr
operator|!=
literal|'\n'
condition|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|its
parameter_list|(
name|type
parameter_list|)
value|(prefix(ptr, type))
end_define

begin_expr_stmt
name|type
argument_list|(
name|ptr
argument_list|)
specifier|register
name|char
operator|*
name|ptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|htype
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|space
decl_stmt|;
specifier|static
name|int
name|lasthdr
init|=
name|FALSE
decl_stmt|;
comment|/* for continuation headers */
comment|/* 	** some consistency checks (i.e. is this really a header line?) 	*/
if|if
condition|(
operator|(
name|ptr
operator|==
name|NULL
operator|)
operator|||
operator|!
name|isascii
argument_list|(
operator|*
name|ptr
argument_list|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|'\n'
operator|)
condition|)
return|return
operator|(
name|lasthdr
operator|=
name|FALSE
operator|)
return|;
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
comment|/* continuation line? */
return|return
operator|(
name|lasthdr
operator|)
return|;
name|colon
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|space
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon
operator|||
name|space
operator|&&
name|space
operator|<
name|colon
condition|)
return|return
operator|(
name|lasthdr
operator|=
name|FALSE
operator|)
return|;
for|for
control|(
name|hp
operator|=
name|htype
init|;
name|hp
operator|->
name|hname
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
name|its
argument_list|(
name|hp
operator|->
name|hname
argument_list|)
condition|)
return|return
operator|(
name|lasthdr
operator|=
name|hp
operator|->
name|hid
operator|)
return|;
block|}
return|return
operator|(
name|lasthdr
operator|=
name|OTHER
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Get the contents of the field of the header line, appending it, ** with a space delimeter if it's a continuation line. ** If there is already something in the header storage, skip this ** header line and the continuations. */
end_comment

begin_expr_stmt
name|getfield
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|size
argument_list|)
specifier|register
name|char
operator|*
name|src
operator|,
operator|*
name|dest
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* of dest (total bytes) */
end_comment

begin_block
block|{
specifier|static
name|int
name|skip
init|=
name|FALSE
decl_stmt|;
comment|/* skip the continuation lines */
if|if
condition|(
name|src
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
name|dest
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|src
argument_list|)
condition|)
block|{
comment|/* continuation line? */
if|if
condition|(
name|skip
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|size
operator|-=
name|strlen
argument_list|(
name|dest
argument_list|)
operator|)
operator|<=
literal|0
condition|)
comment|/* any space left? */
return|return
operator|(
name|FALSE
operator|)
return|;
while|while
condition|(
operator|*
name|src
operator|&&
name|isblank
argument_list|(
operator|*
name|src
argument_list|)
condition|)
comment|/* eat whitespace */
name|src
operator|++
expr_stmt|;
operator|*
operator|--
name|src
operator|=
literal|' '
expr_stmt|;
comment|/* backup& add one */
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* append to hdr */
block|}
else|else
block|{
name|skip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|dest
condition|)
comment|/* already got one? */
return|return
operator|(
name|skip
operator|=
name|TRUE
operator|)
return|;
comment|/* skip continuation */
if|if
condition|(
operator|(
name|src
operator|=
name|index
argument_list|(
name|src
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
comment|/* impossible */
return|return
operator|(
name|FALSE
operator|)
return|;
name|src
operator|++
expr_stmt|;
comment|/* skip colon */
while|while
condition|(
operator|*
name|src
operator|&&
name|isblank
argument_list|(
operator|*
name|src
argument_list|)
condition|)
comment|/* eat whitespace */
name|src
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nstrip
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Write out an RFC822 header, paying no attention to line limits. ** Ideally, we should do continuations in here... */
end_comment

begin_expr_stmt
name|rfc822write
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|path
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Path: %s\n"
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s\n"
argument_list|,
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|nbuf
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|title
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|ident
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Message-ID: %s\n"
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|subdate
index|[
literal|0
index|]
condition|)
name|t
operator|=
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
else|else
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|expdate
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Expires: %s\n"
argument_list|,
name|hp
operator|->
name|expdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followid
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"References: %s\n"
argument_list|,
name|hp
operator|->
name|followid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|ctlmsg
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Control: %s\n"
argument_list|,
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|sender
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Sender: %s\n"
argument_list|,
name|hp
operator|->
name|sender
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|replyto
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Reply-To: %s\n"
argument_list|,
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followto
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Followup-To: %s\n"
argument_list|,
name|hp
operator|->
name|followto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|distribution
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Distribution: %s\n"
argument_list|,
name|hp
operator|->
name|distribution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|organization
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Organization: %s\n"
argument_list|,
name|hp
operator|->
name|organization
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|keywords
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Keywords: %s\n"
argument_list|,
name|hp
operator|->
name|keywords
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|summary
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Summary: %s\n"
argument_list|,
name|hp
operator|->
name|summary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|approved
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Approved: %s\n"
argument_list|,
name|hp
operator|->
name|approved
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** strip leading and trailing spaces */
end_comment

begin_function
name|char
modifier|*
name|sp_strip
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|cp
operator|=
operator|&
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|--
expr_stmt|;
operator|*
operator|++
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* zap trailing spaces */
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
return|return
operator|(
name|cp
operator|)
return|;
comment|/* return pointer to first non-space */
block|}
end_function

begin_comment
comment|/* ** crack an RFC822 from header field into address and fullname. */
end_comment

begin_macro
name|crackfrom
argument_list|(
argument|addr
argument_list|,
argument|name
argument_list|,
argument|field
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|addr
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|field
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|commbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
init|=
name|addrbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
name|short
name|commfound
init|=
literal|0
decl_stmt|,
name|comment
init|=
literal|0
decl_stmt|;
name|short
name|addrfound
init|=
literal|0
decl_stmt|,
name|address
init|=
literal|0
decl_stmt|;
name|struct
name|llist
name|comm
decl_stmt|,
modifier|*
name|cp
init|=
operator|&
name|comm
decl_stmt|;
operator|*
name|name
operator|=
literal|'\0'
expr_stmt|;
comment|/* just make sure */
operator|*
name|addr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|field
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
comment|/* eat leading white space */
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|comment
operator|==
literal|0
condition|)
block|{
name|np
operator|=
name|commbuf
expr_stmt|;
operator|*
name|np
operator|=
literal|'\0'
expr_stmt|;
block|}
name|comment
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|comment
operator|>
literal|0
operator|&&
operator|--
name|comment
operator|==
literal|0
condition|)
block|{
operator|*
name|np
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* note incr; skip `)' */
operator|*
name|np
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|l_alloc
argument_list|(
name|cp
argument_list|,
name|commbuf
argument_list|,
name|strlen
argument_list|(
name|commbuf
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|commfound
condition|)
name|l_free
argument_list|(
name|comm
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|commfound
operator|++
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|address
condition|)
block|{
if|if
condition|(
name|commfound
condition|)
name|l_free
argument_list|(
name|comm
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* AWK! Abort! */
block|}
if|if
condition|(
operator|!
name|comment
condition|)
block|{
name|address
operator|++
expr_stmt|;
operator|*
name|ap
operator|=
literal|'\0'
expr_stmt|;
name|ap
operator|=
name|addr
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
operator|!
name|comment
operator|&&
name|address
condition|)
block|{
name|address
operator|--
expr_stmt|;
name|addrfound
operator|++
expr_stmt|;
operator|*
name|ap
operator|=
literal|'\0'
expr_stmt|;
name|ap
operator|=
operator|&
name|addrbuf
index|[
name|strlen
argument_list|(
name|addrbuf
argument_list|)
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* skip the `>' */
block|}
break|break;
block|}
if|if
condition|(
name|comment
condition|)
block|{
operator|*
name|np
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|address
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'<'
condition|)
operator|*
name|ap
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ap
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|ap
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|addrfound
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|sp_strip
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|addr
argument_list|,
name|strcpy
argument_list|(
name|commbuf
argument_list|,
name|sp_strip
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|addr
argument_list|,
name|sp_strip
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	** Just to be sure that we got the full name, 	** we'll take all of the comments! 	*/
if|if
condition|(
name|commfound
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|flag
init|=
operator|(
operator|*
name|name
operator|!=
literal|'\0'
condition|?
name|TRUE
else|:
name|FALSE
operator|)
decl_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|comm
init|;
name|cp
operator|->
name|l_item
condition|;
name|cp
operator|=
name|cp
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|flag
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|flag
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|l_item
index|[
name|cp
operator|->
name|l_len
operator|-
literal|2
index|]
operator|==
literal|')'
condition|)
name|cp
operator|->
name|l_item
index|[
name|cp
operator|->
name|l_len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|sp_strip
argument_list|(
operator|&
name|cp
operator|->
name|l_item
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l_free
argument_list|(
name|comm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Check on the validity of an RFC822 message-id. ** Check for enclosing `<>', an `@', and a `.' after ** the `@'. Also make sure that everything is ASCII, ** and non-control characters. */
end_comment

begin_expr_stmt
name|msgid_ok
argument_list|(
name|id
argument_list|)
specifier|register
name|char
operator|*
name|id
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|atdot
operator|=
name|FALSE
expr_stmt|;
specifier|register
name|closure
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* don't waste my time! */
if|if
condition|(
operator|*
name|id
operator|!=
literal|'<'
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* skip the first `<', cause we check for more */
for|for
control|(
name|id
operator|++
init|;
operator|*
name|id
condition|;
name|id
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|id
condition|)
block|{
case|case
literal|'<'
case|:
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* we've already got one */
case|case
literal|'>'
case|:
name|closure
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|end
goto|;
comment|/* djikstra is a wimp! */
break|break;
case|case
literal|'.'
case|:
case|case
literal|'@'
case|:
comment|/* should be a domain spec */
name|atdot
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|id
argument_list|)
operator|||
name|iscntrl
argument_list|(
operator|*
name|id
argument_list|)
operator|||
name|isspace
argument_list|(
operator|*
name|id
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* quit immediately */
break|break;
block|}
block|}
name|end
label|:
return|return
operator|(
name|atdot
operator|&&
name|closure
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** hfgets is like fgets, but deals with continuation lines. ** It also ensures that even if a line that is too long is ** received, the remainder of the line is thrown away ** instead of treated like a second line. */
end_comment

begin_function
name|char
modifier|*
name|hfgets
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|len
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|!
name|iscntrl
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|cp
operator|==
name|buf
condition|)
return|return
name|NULL
return|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Line too long - part read didn't fit into a newline */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
block|{
comment|/* Don't look for continuation of blank lines */
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* for each cont line */
comment|/* Continuation line. */
if|if
condition|(
operator|(
name|n
operator|+=
literal|2
operator|)
operator|<
name|len
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|(
operator|!
name|iscntrl
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|n
operator|++
operator|<
name|len
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
name|len
operator|-
literal|1
condition|)
name|cp
operator|=
name|buf
operator|+
name|len
operator|-
literal|2
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* push back first char of next header */
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * arpadate is like ctime(3) except that the time is returned in  * an acceptable ARPANET time format instead of ctime format.  */
end_comment

begin_function
name|char
modifier|*
name|arpadate
parameter_list|(
name|longtime
parameter_list|)
name|time_t
modifier|*
name|longtime
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|ud
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|b
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|asctime
parameter_list|()
function_decl|;
comment|/*  Get current time. This will be used resolve the timezone. */
name|ud
operator|=
name|asctime
argument_list|(
name|gmtime
argument_list|(
name|longtime
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Crack the UNIX date line in a singularly unoriginal way. */
name|q
operator|=
name|b
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* until every site installs the fix to getdate.y, the day    of the week can cause time warps */
name|p
operator|=
operator|&
name|ud
index|[
literal|0
index|]
expr_stmt|;
comment|/* Mon */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|&
name|ud
index|[
literal|8
index|]
expr_stmt|;
comment|/* 16 */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|4
index|]
expr_stmt|;
comment|/* Sep */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|22
index|]
expr_stmt|;
comment|/* 1979 */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|11
index|]
expr_stmt|;
comment|/* 01:03:52 */
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'G'
expr_stmt|;
comment|/* GMT */
operator|*
name|q
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|time_t
name|cgtdate
parameter_list|(
name|datestr
parameter_list|)
name|char
modifier|*
name|datestr
decl_stmt|;
block|{
name|char
name|junk
index|[
literal|40
index|]
decl_stmt|,
name|month
index|[
literal|40
index|]
decl_stmt|,
name|day
index|[
literal|30
index|]
decl_stmt|,
name|tod
index|[
literal|60
index|]
decl_stmt|,
name|year
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|static
name|time_t
name|lasttime
decl_stmt|;
specifier|static
name|char
name|lastdatestr
index|[
name|BUFLEN
index|]
init|=
literal|""
decl_stmt|;
specifier|extern
name|time_t
name|getdate
parameter_list|()
function_decl|;
if|if
condition|(
name|lastdatestr
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|datestr
argument_list|,
name|lastdatestr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|lasttime
operator|)
return|;
name|lasttime
operator|=
name|getdate
argument_list|(
name|datestr
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lasttime
operator|<
literal|0
operator|&&
name|sscanf
argument_list|(
name|datestr
argument_list|,
literal|"%s %s %s %s %s"
argument_list|,
name|junk
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|tod
argument_list|,
name|year
argument_list|)
operator|==
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s, %s %s"
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|year
argument_list|,
name|tod
argument_list|)
expr_stmt|;
name|lasttime
operator|=
name|getdate
argument_list|(
name|buf
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|lastdatestr
argument_list|,
name|datestr
argument_list|,
name|BUFLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|lasttime
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|errmsg
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|ebuf
index|[
literal|6
operator|+
literal|5
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|>
name|sys_nerr
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"Error %d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|ebuf
return|;
block|}
else|else
return|return
name|sys_errlist
index|[
name|code
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Strip trailing newlines, blanks, and tabs from 's'.  * Return TRUE if newline was found, else FALSE.  */
end_comment

begin_expr_stmt
name|nstrip
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|FALSE
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rc
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|s
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rc
return|;
block|}
end_block

begin_expr_stmt
name|prefix
argument_list|(
name|full
argument_list|,
name|pref
argument_list|)
specifier|register
name|char
operator|*
name|full
operator|,
operator|*
name|pref
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|fc
decl_stmt|,
name|pc
decl_stmt|;
while|while
condition|(
operator|(
name|pc
operator|=
operator|*
name|pref
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|fc
operator|=
operator|*
name|full
operator|++
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|fc
argument_list|)
condition|)
name|fc
operator|=
name|tolower
argument_list|(
name|fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|pc
argument_list|)
condition|)
name|pc
operator|=
name|tolower
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|!=
name|pc
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_function
name|char
modifier|*
name|strpbrk
parameter_list|(
name|str
parameter_list|,
name|chars
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|chars
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
do|do
block|{
name|cp
operator|=
name|chars
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
operator|*
name|cp
condition|)
return|return
name|str
return|;
block|}
block|}
do|while
condition|(
operator|*
name|str
operator|++
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USG */
end_comment

end_unit

