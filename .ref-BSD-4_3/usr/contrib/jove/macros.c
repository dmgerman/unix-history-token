begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_decl_stmt
name|struct
name|macro
modifier|*
name|macros
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros */
end_comment

begin_decl_stmt
name|data_obj
modifier|*
name|LastCmd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|add_mac
argument_list|(
argument|new
argument_list|)
expr|struct
name|macro
operator|*
name|new
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|macro
modifier|*
name|mp
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|macros
init|;
name|mp
operator|!=
literal|0
condition|;
name|prev
operator|=
name|mp
operator|,
name|mp
operator|=
name|mp
operator|->
name|m_nextm
control|)
if|if
condition|(
name|mp
operator|==
name|new
condition|)
return|return;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|m_nextm
operator|=
name|new
expr_stmt|;
else|else
name|macros
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|m_nextm
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|Type
operator|=
name|MACRO
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|del_mac
argument_list|(
argument|mac
argument_list|)
expr|struct
name|macro
operator|*
name|mac
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|macros
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
if|if
condition|(
name|m
operator|->
name|m_nextm
operator|==
name|mac
condition|)
block|{
name|m
operator|->
name|m_nextm
operator|=
name|mac
operator|->
name|m_nextm
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|mac
operator|->
name|Name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mac
operator|->
name|m_body
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mac
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|macro
name|KeyMacro
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro used for defining */
end_comment

begin_define
define|#
directive|define
name|NMACROS
value|40
end_define

begin_comment
comment|/* This is bad, bad, BAD! */
end_comment

begin_decl_stmt
name|struct
name|macro
modifier|*
name|macstack
index|[
name|NMACROS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stackp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|fix_macros
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|macro
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macstack
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|=
name|macstack
index|[
name|i
index|]
expr_stmt|;
name|macstack
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_flags
operator|=
name|mp
operator|->
name|m_offset
operator|=
literal|0
expr_stmt|;
block|}
name|stackp
operator|=
operator|-
literal|1
expr_stmt|;
name|KeyMacro
operator|.
name|m_flags
operator|=
name|KeyMacro
operator|.
name|m_offset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|mac_err
argument_list|(
argument|err
argument_list|)
name|char
operator|*
name|err
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|KeyMacro
operator|.
name|m_flags
operator|=
literal|0
expr_stmt|;
name|MacNolen
argument_list|(
operator|&
name|KeyMacro
argument_list|)
expr_stmt|;
name|complain
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|do_macro
argument_list|(
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|macro
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|mac
operator|->
name|m_flags
operator|&
name|EXECUTE
condition|)
name|mac_err
argument_list|(
literal|"[Attempt to execute macro recursively!]"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|stackp
operator|>=
name|NMACROS
condition|)
name|complain
argument_list|(
literal|"[Too many macros at once!]"
argument_list|)
expr_stmt|;
name|macstack
index|[
name|stackp
index|]
operator|=
name|mac
expr_stmt|;
name|mac
operator|->
name|m_offset
operator|=
literal|0
expr_stmt|;
name|mac
operator|->
name|m_ntimes
operator|=
name|exp
expr_stmt|;
name|mac
operator|->
name|m_flags
operator||=
name|EXECUTE
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|MacNolen
argument_list|(
argument|m
argument_list|)
expr|struct
name|macro
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_offset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|struct
name|macro
modifier|*
name|mac_exists
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|macro
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|macros
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_nextm
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|mp
operator|->
name|Name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|mac_init
argument_list|()
end_macro

begin_block
block|{
name|add_mac
argument_list|(
operator|&
name|KeyMacro
argument_list|)
expr_stmt|;
name|MacNolen
argument_list|(
operator|&
name|KeyMacro
argument_list|)
expr_stmt|;
name|KeyMacro
operator|.
name|Name
operator|=
literal|"keyboard-macro"
expr_stmt|;
name|KeyMacro
operator|.
name|m_buflen
operator|=
literal|16
expr_stmt|;
name|KeyMacro
operator|.
name|m_body
operator|=
name|emalloc
argument_list|(
name|KeyMacro
operator|.
name|m_buflen
argument_list|)
expr_stmt|;
name|KeyMacro
operator|.
name|m_ntimes
operator|=
name|KeyMacro
operator|.
name|m_flags
operator|=
literal|0
expr_stmt|;
name|fix_macros
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|mac_putc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|KeyMacro
operator|.
name|m_len
operator|>=
name|KeyMacro
operator|.
name|m_buflen
condition|)
block|{
name|KeyMacro
operator|.
name|m_buflen
operator|+=
literal|16
expr_stmt|;
name|KeyMacro
operator|.
name|m_body
operator|=
name|realloc
argument_list|(
name|KeyMacro
operator|.
name|m_body
argument_list|,
operator|(
name|unsigned
operator|)
name|KeyMacro
operator|.
name|m_buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|KeyMacro
operator|.
name|m_body
operator|==
literal|0
condition|)
name|mac_err
argument_list|(
literal|"[Can't allocate storage for keyboard macro]"
argument_list|)
expr_stmt|;
block|}
name|KeyMacro
operator|.
name|m_body
index|[
name|KeyMacro
operator|.
name|m_offset
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|KeyMacro
operator|.
name|m_len
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|in_macro
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
operator|(
name|stackp
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|macstack
index|[
name|stackp
index|]
operator|)
operator|->
name|m_flags
operator|&
name|EXECUTE
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|mac_getc
argument_list|()
end_macro

begin_block
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|stackp
operator|<
literal|0
operator|||
operator|(
operator|(
name|m
operator|=
name|macstack
index|[
name|stackp
index|]
operator|)
operator|->
name|m_flags
operator|&
name|EXECUTE
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|m
operator|->
name|m_offset
operator|==
name|m
operator|->
name|m_len
condition|)
block|{
name|m
operator|->
name|m_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|m
operator|->
name|m_ntimes
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|EXECUTE
expr_stmt|;
name|stackp
operator|--
expr_stmt|;
block|}
return|return
name|mac_getc
argument_list|()
return|;
block|}
return|return
name|m
operator|->
name|m_body
index|[
name|m
operator|->
name|m_offset
operator|++
index|]
return|;
block|}
end_block

begin_macro
name|NameMac
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|KeyMacro
operator|.
name|m_len
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No keyboard macro to name!]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|KeyMacro
operator|.
name|m_flags
operator|&
operator|(
name|DEFINE
operator||
name|EXECUTE
operator|)
condition|)
name|complain
argument_list|(
literal|"[Can't name while defining/executing]"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|mac_exists
argument_list|(
name|name
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|KeyMacro
operator|.
name|Name
argument_list|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[Can't name it that!]"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
operator|->
name|Name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
operator|->
name|m_body
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|copystr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|m
operator|->
name|Type
operator|=
name|KeyMacro
operator|.
name|Type
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|KeyMacro
operator|.
name|m_len
expr_stmt|;
name|m
operator|->
name|m_buflen
operator|=
name|KeyMacro
operator|.
name|m_buflen
expr_stmt|;
name|m
operator|->
name|m_body
operator|=
name|emalloc
argument_list|(
name|m
operator|->
name|m_buflen
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
name|KeyMacro
operator|.
name|m_body
argument_list|,
name|m
operator|->
name|m_body
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ntimes
operator|=
name|m
operator|->
name|m_offset
operator|=
literal|0
expr_stmt|;
comment|/* At the beginning */
name|m
operator|->
name|m_flags
operator|=
name|SAVE
expr_stmt|;
name|m
operator|->
name|Name
operator|=
name|name
expr_stmt|;
name|add_mac
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|RunMacro
argument_list|()
end_macro

begin_block
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|findmac
argument_list|(
name|ProcFmt
argument_list|)
condition|)
name|do_macro
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|mac_fd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|mac_io
argument_list|(
argument|fcn
argument_list|,
argument|ptr
argument_list|,
argument|nbytes
argument_list|)
name|int
argument_list|(
operator|*
name|fcn
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nio
decl_stmt|;
if|if
condition|(
operator|(
name|nio
operator|=
call|(
modifier|*
name|fcn
call|)
argument_list|(
name|mac_fd
argument_list|,
name|ptr
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|!=
name|nbytes
condition|)
name|complain
argument_list|(
literal|"[Macro %s error: %d got %d]"
argument_list|,
operator|(
name|fcn
operator|==
name|read
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|nbytes
argument_list|,
name|nio
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|WriteMacs
argument_list|()
end_macro

begin_block
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
name|int
name|namelen
decl_stmt|,
name|netl
decl_stmt|,
name|nmacs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|file
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mac_fd
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|complain
argument_list|(
name|IOerr
argument_list|(
literal|"create"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|f_mess
argument_list|(
literal|"\"%s\""
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Don't write the keyboard macro which is always the first */
for|for
control|(
name|m
operator|=
name|macros
operator|->
name|m_nextm
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
name|nmacs
operator|++
expr_stmt|;
name|netl
operator|=
name|htonl
argument_list|(
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|mac_io
argument_list|(
name|write
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|netl
argument_list|,
sizeof|sizeof
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|m
operator|->
name|Name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Including the null */
name|netl
operator|=
name|htonl
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
name|mac_io
argument_list|(
name|write
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|netl
argument_list|,
sizeof|sizeof
name|namelen
argument_list|)
expr_stmt|;
name|mac_io
argument_list|(
name|write
argument_list|,
name|m
operator|->
name|Name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|mac_io
argument_list|(
name|write
argument_list|,
name|m
operator|->
name|m_body
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|SAVE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|mac_fd
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" %d macro%n saved."
argument_list|,
name|nmacs
argument_list|,
name|nmacs
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|NEWWAY
value|1
end_define

begin_define
define|#
directive|define
name|OLDWAY
value|0
end_define

begin_decl_stmt
specifier|static
name|int
name|int_how
init|=
name|NEWWAY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Formatting int's the old way or the new "improved" way? */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_comment
comment|/* 4.2 (at least) has these functions defined. */
end_comment

begin_if
if|#
directive|if
name|vax
operator|||
name|pdp11
end_if

begin_function
name|long
name|htonl
parameter_list|(
name|x
parameter_list|)
specifier|register
name|long
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|x
operator|>>
literal|0
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|short
name|htons
parameter_list|(
name|x
parameter_list|)
specifier|register
name|short
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|x
operator|>>
literal|0
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|long
name|ntohl
parameter_list|(
name|x
parameter_list|)
specifier|register
name|long
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|x
operator|>>
literal|0
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|16
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|short
name|ntohs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|short
name|x
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|x
operator|>>
literal|0
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
operator|<<
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|long
name|htonl
parameter_list|(
name|x
parameter_list|)
specifier|register
name|long
name|x
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|short
name|htons
parameter_list|(
name|x
parameter_list|)
specifier|register
name|short
name|x
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|long
name|ntohl
parameter_list|(
name|x
parameter_list|)
specifier|register
name|long
name|x
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|short
name|ntohs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|short
name|x
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
endif|BSD4_2
end_endif

begin_macro
name|int_fmt
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|int_how
operator|==
name|NEWWAY
condition|)
return|return
name|ntohl
argument_list|(
name|i
argument_list|)
return|;
return|return
name|i
return|;
block|}
end_block

begin_macro
name|ReadMacs
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|file
decl_stmt|,
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
name|int
name|nmacs
init|=
literal|0
decl_stmt|,
name|namelen
decl_stmt|,
name|bodylen
decl_stmt|,
name|tmp
decl_stmt|,
name|he_is_sure
init|=
literal|0
decl_stmt|,
name|save_em
init|=
name|FALSE
decl_stmt|;
name|file
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mac_fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|complain
argument_list|(
name|IOerr
argument_list|(
literal|"open"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|f_mess
argument_list|(
literal|"\"%s\""
argument_list|,
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
name|mac_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|)
operator|==
operator|(
sizeof|sizeof
name|tmp
operator|)
condition|)
block|{
name|retry
label|:
name|bodylen
operator|=
name|int_fmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|he_is_sure
operator|&&
operator|(
name|bodylen
operator|<=
literal|0
operator|||
name|bodylen
operator|>
literal|10000
operator|)
condition|)
block|{
if|if
condition|(
name|int_how
operator|==
name|NEWWAY
condition|)
block|{
name|int_how
operator|=
name|OLDWAY
expr_stmt|;
name|save_em
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
block|{
name|confirm
argument_list|(
literal|"Are you sure \"%s\" is a JOVE macro file? "
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
name|he_is_sure
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|nmacs
operator|++
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|bodylen
expr_stmt|;
name|m
operator|->
name|m_buflen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|mac_io
argument_list|(
name|read
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|namelen
argument_list|,
sizeof|sizeof
name|namelen
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|int_fmt
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
name|m
operator|->
name|Name
operator|=
name|emalloc
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
name|mac_io
argument_list|(
name|read
argument_list|,
name|m
operator|->
name|Name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_body
operator|=
name|emalloc
argument_list|(
name|m
operator|->
name|m_buflen
argument_list|)
expr_stmt|;
name|mac_io
argument_list|(
name|read
argument_list|,
name|m
operator|->
name|m_body
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|add_mac
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|mac_fd
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" %d macro%n defined."
argument_list|,
name|nmacs
argument_list|,
name|nmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_em
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"OK to convert to the new format? "
decl_stmt|,
name|ibuf
index|[
name|FILESIZE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|InJoverc
condition|)
block|{
name|TOstart
argument_list|(
literal|"Warning"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Warning: your macros file is in the old format."
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Do you want me to convert \"%s\" to the new"
argument_list|,
name|pr_name
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"format?"
argument_list|)
expr_stmt|;
name|f_mess
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
name|confirm
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* WriteMacs requests a file name.  This is what it'll get. */
name|sprintf
argument_list|(
name|ibuf
argument_list|,
literal|"%s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|Inputp
operator|=
name|ibuf
expr_stmt|;
name|WriteMacs
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|Remember
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|KeyMacro
operator|.
name|m_flags
operator|&
name|EXECUTE
condition|)
comment|/* We're already executing the macro; ignore any attempts 		   to define the keyboard macro while we are executing. */
return|return;
if|if
condition|(
name|KeyMacro
operator|.
name|m_flags
operator|&
name|DEFINE
condition|)
name|message
argument_list|(
literal|"[Already remembering ... continue with definition]"
argument_list|)
expr_stmt|;
else|else
block|{
name|UpdModLine
operator|++
expr_stmt|;
name|KeyMacro
operator|.
name|m_flags
operator||=
name|DEFINE
expr_stmt|;
name|MacNolen
argument_list|(
operator|&
name|KeyMacro
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"Remembering..."
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Is `c' a prefix character */
end_comment

begin_expr_stmt
specifier|static
name|PrefChar
argument_list|(
argument|c
argument_list|)
block|{
return|return
operator|(
name|int
operator|)
name|IsPrefix
argument_list|(
name|mainmap
index|[
name|c
index|]
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|Forget
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
init|=
operator|&
name|KeyMacro
decl_stmt|;
name|UpdModLine
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|DEFINE
condition|)
block|{
name|message
argument_list|(
literal|"Keyboard macro defined."
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|DEFINE
expr_stmt|;
name|cp
operator|=
operator|&
name|m
operator|->
name|m_body
index|[
name|m
operator|->
name|m_len
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|PrefChar
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|m
operator|->
name|m_len
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|commands
index|[
operator|*
operator|++
name|cp
index|]
operator|.
name|c_proc
operator|==
name|Forget
condition|)
name|m
operator|->
name|m_len
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ExecMacro
argument_list|()
end_macro

begin_block
block|{
name|do_macro
argument_list|(
operator|&
name|KeyMacro
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|MacInter
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|Interactive
decl_stmt|;
if|if
condition|(
operator|!
name|Asking
condition|)
return|return;
name|Interactive
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|ModMacs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|macros
operator|->
name|m_nextm
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|SAVE
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|data_obj
modifier|*
name|findmac
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|strings
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|strs
init|=
name|strings
decl_stmt|;
specifier|register
name|int
name|com
decl_stmt|;
specifier|register
name|struct
name|macro
modifier|*
name|m
init|=
name|macros
decl_stmt|;
for|for
control|(
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
operator|*
name|strs
operator|++
operator|=
name|m
operator|->
name|Name
expr_stmt|;
operator|*
name|strs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|com
operator|=
name|complete
argument_list|(
name|strings
argument_list|,
name|prompt
argument_list|,
name|NOTHING
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|m
operator|=
name|macros
expr_stmt|;
while|while
condition|(
operator|--
name|com
operator|>=
literal|0
condition|)
name|m
operator|=
name|m
operator|->
name|m_nextm
expr_stmt|;
return|return
operator|(
name|data_obj
operator|*
operator|)
name|m
return|;
block|}
end_function

begin_macro
name|DelMacro
argument_list|()
end_macro

begin_block
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|findmac
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
operator|&
name|KeyMacro
condition|)
name|complain
argument_list|(
literal|"[It's illegal to delete the keyboard-macro!]"
argument_list|)
expr_stmt|;
name|del_mac
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

