begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_expr_stmt
specifier|static
name|substitute
argument_list|(
argument|query
argument_list|,
argument|l1
argument_list|,
argument|char1
argument_list|,
argument|l2
argument_list|,
argument|char2
argument_list|)
name|Line
operator|*
name|l1
operator|,
operator|*
name|l2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Line
modifier|*
name|lp
decl_stmt|;
name|int
name|numdone
init|=
literal|0
decl_stmt|,
name|offset
init|=
name|curchar
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
name|disk_line
name|UNDO_da
init|=
literal|0
decl_stmt|;
name|Line
modifier|*
name|UNDO_lp
init|=
literal|0
decl_stmt|;
name|lsave
argument_list|()
expr_stmt|;
name|REdirection
operator|=
name|FORWARD
expr_stmt|;
name|lp
operator|=
name|l1
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|l1
init|;
operator|(
name|lp
operator|!=
name|l2
operator|->
name|l_next
operator|)
operator|&&
operator|!
name|stop
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
name|offset
operator|=
operator|(
name|lp
operator|==
name|l1
operator|)
condition|?
name|char1
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|stop
operator|&&
name|re_lindex
argument_list|(
name|lp
argument_list|,
name|offset
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|lp
operator|==
name|l2
operator|&&
name|REeom
operator|>
name|char2
condition|)
comment|/* nope, leave this alone */
break|break;
name|DotTo
argument_list|(
name|lp
argument_list|,
name|REeom
argument_list|)
expr_stmt|;
name|offset
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
name|query
condition|)
block|{
name|message
argument_list|(
literal|"Replace (Type '?' for help)? "
argument_list|)
expr_stmt|;
name|reswitch
label|:
name|redisplay
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|Upper
argument_list|(
name|getchar
argument_list|()
argument_list|)
condition|)
block|{
case|case
literal|'.'
case|:
name|stop
operator|++
expr_stmt|;
comment|/* Fall into ... */
case|case
literal|' '
case|:
case|case
literal|'Y'
case|:
break|break;
case|case
name|BS
case|:
case|case
name|RUBOUT
case|:
case|case
literal|'N'
case|:
if|if
condition|(
name|linebuf
index|[
name|offset
operator|++
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|nxtline
goto|;
continue|continue;
case|case
name|CTL
argument_list|(
name|W
argument_list|)
case|:
name|re_dosub
argument_list|(
name|linebuf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|numdone
operator|++
expr_stmt|;
name|offset
operator|=
name|curchar
operator|=
name|REbom
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
comment|/* Fall into ... */
case|case
name|CTL
argument_list|(
name|R
argument_list|)
case|:
case|case
literal|'R'
case|:
name|RErecur
argument_list|()
expr_stmt|;
name|offset
operator|=
name|curchar
expr_stmt|;
name|lp
operator|=
name|curline
expr_stmt|;
continue|continue;
case|case
name|CTL
argument_list|(
name|U
argument_list|)
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|UNDO_lp
operator|==
literal|0
condition|)
continue|continue;
name|lp
operator|=
name|UNDO_lp
expr_stmt|;
name|lp
operator|->
name|l_dline
operator|=
name|UNDO_da
operator||
name|DIRTY
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|numdone
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
case|case
literal|'!'
case|:
name|query
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CR
case|:
case|case
name|LF
case|:
case|case
literal|'Q'
case|:
goto|goto
name|done
goto|;
case|case
name|CTL
argument_list|(
name|L
argument_list|)
case|:
name|RedrawDisplay
argument_list|()
expr_stmt|;
goto|goto
name|reswitch
goto|;
default|default:
name|rbell
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Space or Y, Period, Rubout or N, C-R or R, C-W, C-U or U, P or !, Return."
argument_list|)
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
block|}
name|re_dosub
argument_list|(
name|linebuf
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|numdone
operator|++
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|offset
operator|=
name|curchar
operator|=
name|REeom
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
condition|)
block|{
name|message
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
comment|/* No blinking. */
name|redisplay
argument_list|()
expr_stmt|;
comment|/* Show the change. */
block|}
name|UNDO_da
operator|=
name|curline
operator|->
name|l_dline
expr_stmt|;
name|UNDO_lp
operator|=
name|curline
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
name|offset
index|]
operator|==
literal|0
condition|)
name|nxtline
label|:
break|break;
block|}
block|}
name|SetMark
argument_list|()
expr_stmt|;
name|done
label|:
name|s_mess
argument_list|(
literal|"%d substitution%n."
argument_list|,
name|numdone
argument_list|,
name|numdone
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Prompt for search and replacement strings and do the substitution.  The    point is restored when we're done. */
end_comment

begin_expr_stmt
specifier|static
name|replace
argument_list|(
argument|query
argument_list|,
argument|inreg
argument_list|)
block|{
name|Mark
operator|*
name|save
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|FLOATER
argument_list|)
block|,
operator|*
name|m
block|;
name|char
operator|*
name|rep_ptr
block|;
name|Line
operator|*
name|l1
operator|=
name|curline
block|,
operator|*
name|l2
operator|=
name|curbuf
operator|->
name|b_last
block|;
name|int
name|char1
operator|=
name|curchar
block|,
name|char2
operator|=
name|length
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
block|;
if|if
condition|(
name|inreg
condition|)
block|{
name|m
operator|=
name|CurMark
argument_list|()
expr_stmt|;
name|l2
operator|=
name|m
operator|->
name|m_line
expr_stmt|;
name|char2
operator|=
name|m
operator|->
name|m_char
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|l1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|l2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
block|}
comment|/* Get search string. */
name|strcpy
argument_list|(
name|rep_search
argument_list|,
name|ask
argument_list|(
name|rep_search
index|[
literal|0
index|]
condition|?
name|rep_search
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|REcompile
argument_list|(
name|rep_search
argument_list|,
name|UseRE
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Now the replacement string.  Do_ask() so the user can play with 	   the default (previous) replacement string by typing C-R in ask(), 	   OR, he can just hit Return to replace with nothing. */
end_comment

begin_expr_stmt
name|rep_ptr
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
name|rep_str
argument_list|,
literal|": %f %s with "
argument_list|,
name|rep_search
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rep_ptr
operator|==
literal|0
condition|)
name|rep_ptr
operator|=
name|NullStr
expr_stmt|;
end_if

begin_expr_stmt
name|strcpy
argument_list|(
name|rep_str
argument_list|,
name|rep_ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|substitute
argument_list|(
name|query
argument_list|,
name|l1
argument_list|,
name|char1
argument_list|,
name|l2
argument_list|,
name|char2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ToMark
argument_list|(
name|save
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DelMark
argument_list|(
name|save
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  RegReplace
operator|(
operator|)
block|{
name|replace
argument_list|(
literal|0
argument_list|,
name|YES
argument_list|)
block|; }
name|QRepSearch
argument_list|()
block|{
name|replace
argument_list|(
literal|1
argument_list|,
name|NO
argument_list|)
block|; }
name|RepSearch
argument_list|()
block|{
name|replace
argument_list|(
literal|0
argument_list|,
name|NO
argument_list|)
block|; }
comment|/* C tags package. */
specifier|static
name|lookup
argument_list|(
argument|searchbuf
argument_list|,
argument|filebuf
argument_list|,
argument|tag
argument_list|,
argument|file
argument_list|)
name|char
operator|*
name|searchbuf
operator|,
operator|*
name|filebuf
operator|,
operator|*
name|tag
operator|,
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|taglen
init|=
name|strlen
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|char
name|line
index|[
literal|128
index|]
decl_stmt|,
name|pattern
index|[
literal|100
index|]
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_READ
argument_list|,
operator|!
name|COMPLAIN
argument_list|,
name|QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
return|return
literal|0
return|;
name|sprintf
argument_list|(
name|pattern
argument_list|,
literal|"^%s[^\t]*\t\\([^\t]*\\)\t[?/]\\(.*\\)[?/]$"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
while|while
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
operator|*
name|tag
operator|||
name|strncmp
argument_list|(
name|tag
argument_list|,
name|line
argument_list|,
name|taglen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|LookingAt
argument_list|(
name|pattern
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|complain
argument_list|(
literal|"I thought I saw it!"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|putmatch
argument_list|(
literal|2
argument_list|,
name|searchbuf
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|1
argument_list|,
name|filebuf
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|s_mess
argument_list|(
literal|"Can't find tag \"%s\"."
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
name|char
name|TagFile
index|[
literal|128
index|]
init|=
literal|"./tags"
decl_stmt|;
end_decl_stmt

begin_macro
name|find_tag
argument_list|(
argument|tag
argument_list|,
argument|localp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|,
name|sstr
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|Bufpos
modifier|*
name|bp
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|tagfname
decl_stmt|;
if|if
condition|(
operator|!
name|localp
condition|)
name|tagfname
operator|=
name|ask
argument_list|(
name|TagFile
argument_list|,
literal|"With tag file (%s default): "
argument_list|,
name|TagFile
argument_list|)
expr_stmt|;
else|else
name|tagfname
operator|=
name|TagFile
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|sstr
argument_list|,
name|filebuf
argument_list|,
name|tag
argument_list|,
name|tagfname
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|SetMark
argument_list|()
expr_stmt|;
name|b
operator|=
name|do_find
argument_list|(
name|curwind
argument_list|,
name|filebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbuf
operator|!=
name|b
condition|)
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|sstr
argument_list|,
name|BACKWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|WrapScan
operator|||
operator|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|sstr
argument_list|,
name|FORWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|message
argument_list|(
literal|"Well, I found the file, but the tag is missing."
argument_list|)
expr_stmt|;
else|else
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|FindTag
argument_list|()
end_macro

begin_block
block|{
name|int
name|localp
init|=
operator|!
name|exp_p
decl_stmt|;
name|char
name|tag
index|[
literal|128
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tag
argument_list|,
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
expr_stmt|;
name|find_tag
argument_list|(
name|tag
argument_list|,
name|localp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Find Tag at Dot. */
end_comment

begin_macro
name|FDotTag
argument_list|()
end_macro

begin_block
block|{
name|int
name|c1
init|=
name|curchar
decl_stmt|,
name|c2
init|=
name|c1
decl_stmt|;
name|char
name|tagname
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ismword
argument_list|(
name|linebuf
index|[
name|curchar
index|]
argument_list|)
condition|)
name|complain
argument_list|(
literal|"Not a tag!"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c1
operator|>
literal|0
operator|&&
name|ismword
argument_list|(
name|linebuf
index|[
name|c1
operator|-
literal|1
index|]
argument_list|)
condition|)
name|c1
operator|--
expr_stmt|;
while|while
condition|(
name|ismword
argument_list|(
name|linebuf
index|[
name|c2
index|]
argument_list|)
condition|)
name|c2
operator|++
expr_stmt|;
name|null_ncpy
argument_list|(
name|tagname
argument_list|,
name|linebuf
operator|+
name|c1
argument_list|,
name|c2
operator|-
name|c1
argument_list|)
expr_stmt|;
name|find_tag
argument_list|(
name|tagname
argument_list|,
operator|!
name|exp_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* I-search returns a code saying what to do:    STOP:	We found the match, so unwind the stack and leave 		where it is.    DELETE:	Rubout the last command.    BACKUP:	Back up to where the isearch was last NOT failing.     When a character is typed it is appended to the search string, and    then, isearch is called recursively.  When C-S or C-R is typed, isearch    is again called recursively. */
end_comment

begin_define
define|#
directive|define
name|STOP
value|1
end_define

begin_define
define|#
directive|define
name|DELETE
value|2
end_define

begin_define
define|#
directive|define
name|BACKUP
value|3
end_define

begin_define
define|#
directive|define
name|TOSTART
value|4
end_define

begin_decl_stmt
specifier|static
name|char
name|ISbuf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|incp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SExitChar
init|=
name|CR
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cmp_char
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) == (b) || (CaseIgnore&& (Upper(a) == Upper(b))))
end_define

begin_function
specifier|static
name|Bufpos
modifier|*
name|doisearch
parameter_list|(
name|dir
parameter_list|,
name|c
parameter_list|,
name|failing
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|dir
decl_stmt|,
name|failing
decl_stmt|;
block|{
specifier|static
name|Bufpos
name|buf
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|CTL
argument_list|(
name|S
argument_list|)
operator|||
name|c
operator|==
name|CTL
argument_list|(
name|R
argument_list|)
condition|)
goto|goto
name|dosrch
goto|;
if|if
condition|(
name|failing
condition|)
return|return
literal|0
return|;
name|DOTsave
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
if|if
condition|(
name|cmp_char
argument_list|(
name|linebuf
index|[
name|curchar
index|]
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|p_char
operator|=
name|curchar
operator|+
literal|1
expr_stmt|;
return|return
operator|&
name|buf
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|look_at
argument_list|(
name|ISbuf
argument_list|)
condition|)
return|return
operator|&
name|buf
return|;
block|}
name|dosrch
label|:
if|if
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|ISbuf
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|rbell
argument_list|()
expr_stmt|;
comment|/* ring the first time there's no match */
return|return
name|bp
return|;
block|}
end_function

begin_macro
name|IncFSearch
argument_list|()
end_macro

begin_block
block|{
name|IncSearch
argument_list|(
name|FORWARD
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|IncRSearch
argument_list|()
end_macro

begin_block
block|{
name|IncSearch
argument_list|(
name|BACKWARD
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|IncSearch
argument_list|(
argument|dir
argument_list|)
block|{
name|Bufpos
name|save_env
block|;
name|DOTsave
argument_list|(
operator|&
name|save_env
argument_list|)
block|;
name|ISbuf
index|[
literal|0
index|]
operator|=
literal|0
block|;
name|incp
operator|=
name|ISbuf
block|;
if|if
condition|(
name|isearch
argument_list|(
name|dir
argument_list|,
operator|&
name|save_env
argument_list|)
operator|==
name|TOSTART
condition|)
name|SetDot
argument_list|(
operator|&
name|save_env
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|LineDist
argument_list|(
name|curline
argument_list|,
name|save_env
operator|.
name|p_line
argument_list|)
operator|>=
name|MarkThresh
condition|)
name|DoSetMark
argument_list|(
name|save_env
operator|.
name|p_line
argument_list|,
name|save_env
operator|.
name|p_char
argument_list|)
expr_stmt|;
block|}
name|setsearch
argument_list|(
name|ISbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|message
argument_list|(
name|ISbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Nicely recursive. */
end_comment

begin_macro
unit|static
name|isearch
argument_list|(
argument|dir
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|Bufpos
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Bufpos
name|pushbp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ndir
decl_stmt|,
name|failing
decl_stmt|;
name|char
modifier|*
name|orig_incp
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|0
condition|)
block|{
comment|/* Move to the new position. */
name|pushbp
operator|.
name|p_line
operator|=
name|bp
operator|->
name|p_line
expr_stmt|;
name|pushbp
operator|.
name|p_char
operator|=
name|bp
operator|->
name|p_char
expr_stmt|;
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|failing
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DOTsave
argument_list|(
operator|&
name|pushbp
argument_list|)
expr_stmt|;
name|failing
operator|=
literal|1
expr_stmt|;
block|}
name|orig_incp
operator|=
name|incp
expr_stmt|;
name|ndir
operator|=
name|dir
expr_stmt|;
comment|/* Same direction as when we got here, unless 				   we change it with C-S or C-R. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|SetDot
argument_list|(
operator|&
name|pushbp
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|failing
condition|)
name|add_mess
argument_list|(
literal|"Failing "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|BACKWARD
condition|)
name|add_mess
argument_list|(
literal|"reverse-"
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|"I-search: %s"
argument_list|,
name|ISbuf
argument_list|)
expr_stmt|;
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
comment|/* tell me this is disgusting ... */
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SExitChar
condition|)
return|return
name|STOP
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|RUBOUT
case|:
case|case
name|BS
case|:
return|return
name|DELETE
return|;
case|case
name|CTL
argument_list|(
name|G
argument_list|)
case|:
comment|/* If we're failing, we backup until we're no longer 			   failing or we've reached the beginning; else, we 			   just about the search and go back to the start. */
if|if
condition|(
name|failing
condition|)
return|return
name|BACKUP
return|;
return|return
name|TOSTART
return|;
case|case
name|CTL
argument_list|(
operator|\
operator|\
argument_list|)
case|:
name|c
operator|=
name|CTL
argument_list|(
name|S
argument_list|)
expr_stmt|;
case|case
name|CTL
argument_list|(
name|S
argument_list|)
case|:
case|case
name|CTL
argument_list|(
name|R
argument_list|)
case|:
comment|/* If this is the first time through and we have a 			   search string left over from last time, use that 			   one now. */
if|if
condition|(
name|incp
operator|==
name|ISbuf
condition|)
block|{
name|strcpy
argument_list|(
name|ISbuf
argument_list|,
name|getsearch
argument_list|()
argument_list|)
expr_stmt|;
name|incp
operator|=
operator|&
name|ISbuf
index|[
name|strlen
argument_list|(
name|ISbuf
argument_list|)
index|]
expr_stmt|;
block|}
name|ndir
operator|=
operator|(
name|c
operator|==
name|CTL
argument_list|(
name|S
argument_list|)
operator|)
condition|?
name|FORWARD
else|:
name|BACKWARD
expr_stmt|;
comment|/* If we're failing and we're not changing our 			   direction, don't recur since there's no way 			   the search can work. */
if|if
condition|(
name|failing
operator|&&
name|ndir
operator|==
name|dir
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|incp
operator|>
operator|&
name|ISbuf
index|[
operator|(
sizeof|sizeof
name|ISbuf
operator|)
operator|-
literal|1
index|]
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|*
name|incp
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|add_mess
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
comment|/* Fall into ... */
case|case
name|CTL
argument_list|(
name|Q
argument_list|)
case|:
case|case
name|CTL
argument_list|(
operator|^
argument_list|)
case|:
name|add_mess
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
operator||
literal|0400
expr_stmt|;
comment|/* Fall into ... */
default|default:
if|if
condition|(
name|c
operator|&
literal|0400
condition|)
name|c
operator|&=
literal|0177
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|>
name|RUBOUT
operator|||
operator|(
name|c
operator|<
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
condition|)
block|{
name|Ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|STOP
return|;
block|}
block|}
if|if
condition|(
name|incp
operator|>
operator|&
name|ISbuf
index|[
operator|(
sizeof|sizeof
name|ISbuf
operator|)
operator|-
literal|1
index|]
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|*
name|incp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|incp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|add_mess
argument_list|(
literal|"%s"
argument_list|,
name|orig_incp
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" ..."
argument_list|)
expr_stmt|;
comment|/* so we know what's going on */
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
comment|/* do it now */
switch|switch
condition|(
name|isearch
argument_list|(
name|ndir
argument_list|,
name|doisearch
argument_list|(
name|ndir
argument_list|,
name|c
argument_list|,
name|failing
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TOSTART
case|:
return|return
name|TOSTART
return|;
case|case
name|STOP
case|:
return|return
name|STOP
return|;
case|case
name|BACKUP
case|:
comment|/* If we're not failing, we just continue to to the 			   for loop; otherwise we keep returning to the  			   previous levels until we find one that isn't 			   failing OR we reach the beginning. */
if|if
condition|(
name|failing
condition|)
return|return
name|BACKUP
return|;
comment|/* Fall into ... */
case|case
name|DELETE
case|:
name|incp
operator|=
name|orig_incp
expr_stmt|;
operator|*
name|incp
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_block

end_unit

