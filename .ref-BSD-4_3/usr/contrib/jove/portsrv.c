begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_comment
comment|/* This is a server for jove sub processes.  It runs the command and    signals jove when there is some output ready to send to jove. By the    time we get here, out standard output goes to jove's process input. */
end_comment

begin_include
include|#
directive|include
file|"tune.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PIPEPROCS
end_ifdef

begin_comment
comment|/* the whole file! */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|header
block|{
name|int
name|pid
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
block|}
name|header
struct|;
end_struct

begin_define
define|#
directive|define
name|HEADSIZE
value|((sizeof header.pid) + sizeof (header.nbytes))
end_define

begin_macro
name|error
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|header
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|header
operator|.
name|nbytes
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|header
operator|.
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|proc_write
argument_list|(
operator|&
name|header
argument_list|,
name|header
operator|.
name|nbytes
operator|+
literal|8
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|ppid
decl_stmt|,
name|InputFD
decl_stmt|,
name|JovesInput
decl_stmt|;
end_decl_stmt

begin_macro
name|p_inform
argument_list|()
end_macro

begin_block
block|{
name|long
name|nbytes
decl_stmt|;
name|ioctl
argument_list|(
name|JovesInput
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|ppid
argument_list|,
name|INPUT_SIG
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|proc_write
argument_list|(
argument|ptr
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|nbytes
decl_stmt|;
name|ioctl
argument_list|(
literal|1
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|kill
argument_list|(
name|ppid
argument_list|,
name|INPUT_SIG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|ptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|read_pipe
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|p_inform
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|header
operator|.
name|nbytes
operator|=
name|read
argument_list|(
name|InputFD
argument_list|,
name|header
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|header
operator|.
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|HEADSIZE
operator|+
name|header
operator|.
name|nbytes
expr_stmt|;
name|proc_write
argument_list|(
operator|&
name|header
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot pipe jove portsrv.\n"
argument_list|)
expr_stmt|;
name|ppid
operator|=
name|getppid
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"portsrv: cannot fork.\n"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
comment|/* We'll intercept childs output in p[0] */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|4
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't want this guy to read anything 				   jove sends to our soon to be created 				   child */
name|JovesInput
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Tell jove the pid of the real child as opposed to us. */
name|header
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|header
operator|.
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|header
operator|.
name|buf
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
name|pid
operator|+
name|HEADSIZE
argument_list|)
expr_stmt|;
name|p_inform
argument_list|()
expr_stmt|;
comment|/* Inform jove */
comment|/* Read proc's output and send it to jove */
name|InputFD
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|read_pipe
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|header
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|header
operator|.
name|nbytes
operator|=
name|EOF
expr_stmt|;
comment|/* Tell jove we are finished */
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
name|HEADSIZE
argument_list|)
expr_stmt|;
name|p_inform
argument_list|()
expr_stmt|;
comment|/* Try to exit like our child did ... */
block|{
name|union
name|wait
name|w
decl_stmt|;
ifndef|#
directive|ifndef
name|VMUNIX
while|while
condition|(
name|wait2
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
literal|0
argument_list|)
operator|!=
name|pid
condition|)
else|#
directive|else
while|while
condition|(
name|wait3
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|pid
condition|)
endif|#
directive|endif
empty_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
name|exit
argument_list|(
name|w
operator|.
name|w_retcode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|w
operator|.
name|w_termsig
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
else|PIPEPROCS
end_else

begin_function
name|main
parameter_list|()
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

