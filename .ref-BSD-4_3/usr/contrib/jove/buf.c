begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_comment
comment|/* Contains commands that deal with creating, selecting, killing and    listing buffers, and buffer modes, and find-file, etc. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
name|char
modifier|*
name|Mainbuf
init|=
literal|"Main"
decl_stmt|,
modifier|*
name|NoName
init|=
literal|"Sans un nom!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|world
init|=
literal|0
decl_stmt|,
comment|/* First in the list */
modifier|*
name|curbuf
init|=
literal|0
decl_stmt|,
modifier|*
name|lastbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last buffer we were in so we have a default 			   buffer during a select buffer. */
end_comment

begin_comment
comment|/* Toggle BIT in the current buffer's minor mode flags.  If argument is    supplied, a positive one always turns on the mode and zero argument    always turns it off. */
end_comment

begin_macro
name|TogMinor
argument_list|(
argument|bit
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|exp_p
condition|)
block|{
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|curbuf
operator|->
name|b_minor
operator|&=
operator|~
name|bit
expr_stmt|;
else|else
name|curbuf
operator|->
name|b_minor
operator||=
name|bit
expr_stmt|;
block|}
else|else
name|curbuf
operator|->
name|b_minor
operator|^=
name|bit
expr_stmt|;
name|UpdModLine
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Creates a new buffer, links it at the end of the buffer chain, and    returns it. */
end_comment

begin_function
specifier|static
name|Buffer
modifier|*
name|buf_alloc
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|,
modifier|*
name|lastbp
decl_stmt|;
name|lastbp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|lastbp
operator|=
name|b
operator|,
name|b
operator|=
name|b
operator|->
name|b_next
control|)
empty_stmt|;
name|b
operator|=
operator|(
name|Buffer
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastbp
condition|)
name|lastbp
operator|->
name|b_next
operator|=
name|b
expr_stmt|;
else|else
name|world
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|b_first
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b_next
operator|=
literal|0
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Makes a buffer and initializes it.  Obsolete.  Used to take two    arguments, a buffer name and a file name. */
end_comment

begin_function
specifier|static
name|Buffer
modifier|*
name|mak_buf
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|newb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|newb
operator|=
name|buf_alloc
argument_list|()
expr_stmt|;
name|newb
operator|->
name|b_fname
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_name
operator|=
name|NoName
expr_stmt|;
name|set_ino
argument_list|(
name|newb
argument_list|)
expr_stmt|;
name|newb
operator|->
name|b_marks
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_themark
operator|=
literal|0
expr_stmt|;
comment|/* Index into markring */
comment|/* No marks yet */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMARKS
condition|;
name|i
operator|++
control|)
name|newb
operator|->
name|b_markring
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_modified
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_type
operator|=
name|B_FILE
expr_stmt|;
comment|/* File until proven SCRATCH */
name|newb
operator|->
name|b_ntbf
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_minor
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_major
operator|=
name|TEXT
expr_stmt|;
name|newb
operator|->
name|b_first
operator|=
literal|0
expr_stmt|;
name|initlist
argument_list|(
name|newb
argument_list|)
expr_stmt|;
return|return
name|newb
return|;
block|}
end_function

begin_macro
name|ReNamBuf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|new
init|=
literal|0
decl_stmt|,
modifier|*
name|prompt
init|=
name|ProcFmt
decl_stmt|,
modifier|*
name|second
init|=
literal|"%s already exists; new name? "
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|new
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf_exists
argument_list|(
name|new
argument_list|)
condition|)
break|break;
name|prompt
operator|=
name|second
expr_stmt|;
block|}
name|setbname
argument_list|(
name|curbuf
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|FindFile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|name
operator|=
name|ask_file
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|do_find
argument_list|(
name|curwind
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|mkbuflist
argument_list|(
name|bnamp
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|bnamp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|->
name|b_name
operator|!=
literal|0
condition|)
operator|*
name|bnamp
operator|++
operator|=
name|b
operator|->
name|b_name
expr_stmt|;
operator|*
name|bnamp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|ask_buf
parameter_list|(
name|def
parameter_list|)
name|Buffer
modifier|*
name|def
decl_stmt|;
block|{
name|char
modifier|*
name|bnames
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bname
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
name|char
name|prompt
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|def
operator|!=
literal|0
operator|&&
name|def
operator|->
name|b_name
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|": %f (default %s) "
argument_list|,
name|def
operator|->
name|b_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
name|mkbuflist
argument_list|(
name|bnames
argument_list|)
expr_stmt|;
name|offset
operator|=
name|complete
argument_list|(
name|bnames
argument_list|,
name|prompt
argument_list|,
name|RET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|EOF
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|ORIGINAL
condition|)
name|bname
operator|=
name|Minibuf
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|==
name|NULLSTRING
condition|)
block|{
if|if
condition|(
name|def
condition|)
name|bname
operator|=
name|def
operator|->
name|b_name
expr_stmt|;
else|else
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|bname
operator|=
name|bnames
index|[
name|offset
index|]
expr_stmt|;
return|return
name|bname
return|;
block|}
end_function

begin_macro
name|BufSelect
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|bname
decl_stmt|;
name|bname
operator|=
name|ask_buf
argument_list|(
name|lastbuf
argument_list|)
expr_stmt|;
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|bname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|defb_wind
argument_list|(
name|b
argument_list|)
specifier|register
name|Buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
name|char
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|lastbuf
operator|==
name|b
operator|||
name|lastbuf
operator|==
literal|0
condition|)
block|{
name|lastbuf
operator|=
literal|0
expr_stmt|;
name|alt
operator|=
operator|(
name|b
operator|->
name|b_next
operator|!=
literal|0
operator|)
condition|?
name|b
operator|->
name|b_next
operator|->
name|b_name
else|:
name|Mainbuf
expr_stmt|;
block|}
else|else
name|alt
operator|=
name|lastbuf
operator|->
name|b_name
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_bufp
operator|==
name|b
condition|)
block|{
if|if
condition|(
name|one_windp
argument_list|()
condition|)
operator|(
name|void
operator|)
name|do_select
argument_list|(
name|w
argument_list|,
name|alt
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|Window
modifier|*
name|save
init|=
name|w
operator|->
name|w_next
decl_stmt|;
name|del_wind
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|save
operator|->
name|w_prev
expr_stmt|;
block|}
block|}
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
block|}
end_block

begin_function
name|Buffer
modifier|*
name|getNMbuf
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|delbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|bname
decl_stmt|;
name|bname
operator|=
name|ask_buf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delbuf
operator|=
name|buf_exists
argument_list|(
name|bname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No such buffer]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delbuf
operator|->
name|b_modified
condition|)
name|confirm
argument_list|(
literal|"%s modified, are you sure? "
argument_list|,
name|bname
argument_list|)
expr_stmt|;
return|return
name|delbuf
return|;
block|}
end_function

begin_macro
name|BufErase
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|delbuf
decl_stmt|;
if|if
condition|(
name|delbuf
operator|=
name|getNMbuf
argument_list|()
condition|)
block|{
name|initlist
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
name|delbuf
operator|->
name|b_modified
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|kill_buf
argument_list|(
name|delbuf
argument_list|)
specifier|register
name|Buffer
operator|*
name|delbuf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|,
modifier|*
name|lastb
init|=
literal|0
decl_stmt|;
specifier|extern
name|Buffer
modifier|*
name|perr_buf
decl_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
name|pbuftiedp
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
comment|/* Make sure buffer is not tied to a process */
endif|#
directive|endif
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|lastb
operator|=
name|b
operator|,
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|==
name|delbuf
condition|)
break|break;
if|if
condition|(
name|lastb
condition|)
name|lastb
operator|->
name|b_next
operator|=
name|delbuf
operator|->
name|b_next
expr_stmt|;
else|else
name|world
operator|=
name|delbuf
operator|->
name|b_next
expr_stmt|;
define|#
directive|define
name|okay_free
parameter_list|(
name|ptr
parameter_list|)
value|if (ptr) free(ptr)
name|lfreelist
argument_list|(
name|delbuf
operator|->
name|b_first
argument_list|)
expr_stmt|;
name|okay_free
argument_list|(
name|delbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|okay_free
argument_list|(
name|delbuf
operator|->
name|b_fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|delbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|delbuf
operator|==
name|lastbuf
condition|)
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|perr_buf
operator|==
name|delbuf
condition|)
block|{
name|ErrFree
argument_list|()
expr_stmt|;
name|perr_buf
operator|=
literal|0
expr_stmt|;
block|}
name|defb_wind
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbuf
operator|==
name|delbuf
condition|)
name|SetBuf
argument_list|(
name|curwind
operator|->
name|w_bufp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* offer to kill some buffers */
end_comment

begin_macro
name|KillSome
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|Buffer
modifier|*
name|oldb
decl_stmt|;
specifier|register
name|char
modifier|*
name|y_or_n
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|next
control|)
block|{
name|next
operator|=
name|b
operator|->
name|b_next
expr_stmt|;
name|y_or_n
operator|=
name|ask
argument_list|(
literal|"No"
argument_list|,
literal|"Kill %s? "
argument_list|,
name|b
operator|->
name|b_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Upper
argument_list|(
operator|*
name|y_or_n
argument_list|)
operator|!=
literal|'Y'
condition|)
continue|continue;
if|if
condition|(
name|IsModified
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|y_or_n
operator|=
name|ask
argument_list|(
literal|"No"
argument_list|,
literal|"%s modified; should I save it? "
argument_list|,
name|b
operator|->
name|b_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Upper
argument_list|(
operator|*
name|y_or_n
argument_list|)
operator|==
literal|'Y'
condition|)
block|{
name|oldb
operator|=
name|curbuf
expr_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|SaveFile
argument_list|()
expr_stmt|;
name|SetBuf
argument_list|(
name|oldb
argument_list|)
expr_stmt|;
block|}
block|}
name|kill_buf
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|BufKill
argument_list|()
end_macro

begin_block
block|{
name|Buffer
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|getNMbuf
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return;
name|kill_buf
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|line_cnt
parameter_list|(
name|b
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|nlines
init|=
literal|0
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|b
operator|->
name|b_first
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
operator|,
name|nlines
operator|++
control|)
empty_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|TypeNames
index|[]
init|=
block|{
literal|0
block|,
literal|"Scratch"
block|,
literal|"File"
block|,
literal|"Process"
block|,
literal|"I-process"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|BufList
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|format
init|=
literal|"%-2s %-5s %-11s %-1s %-*s  %-s"
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|int
name|bcount
init|=
literal|1
decl_stmt|,
comment|/* To give each buffer a number */
name|buf_width
init|=
literal|11
decl_stmt|;
name|char
name|nbuf
index|[
literal|10
index|]
decl_stmt|;
specifier|extern
name|int
name|ModCount
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
name|buf_width
operator|=
name|max
argument_list|(
name|buf_width
argument_list|,
name|strlen
argument_list|(
name|b
operator|->
name|b_name
argument_list|)
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Buffer list"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* true means auto-newline */
name|Typeout
argument_list|(
literal|"(* means buffer needs saving)"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"(+ means file hasn't been read yet)"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|format
argument_list|,
literal|"NO"
argument_list|,
literal|"Lines"
argument_list|,
literal|"Type"
argument_list|,
name|NullStr
argument_list|,
name|buf_width
argument_list|,
literal|"Name"
argument_list|,
literal|"File"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|format
argument_list|,
literal|"--"
argument_list|,
literal|"-----"
argument_list|,
literal|"----"
argument_list|,
name|NullStr
argument_list|,
name|buf_width
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
block|{
name|Typeout
argument_list|(
name|format
argument_list|,
name|itoa
argument_list|(
name|bcount
operator|++
argument_list|)
argument_list|,
name|line_cnt
argument_list|(
name|b
argument_list|,
name|nbuf
argument_list|)
argument_list|,
name|TypeNames
index|[
name|b
operator|->
name|b_type
index|]
argument_list|,
name|IsModified
argument_list|(
name|b
argument_list|)
condition|?
literal|"*"
else|:
name|b
operator|->
name|b_ntbf
condition|?
literal|"+"
else|:
name|NullStr
argument_list|,
name|buf_width
argument_list|,
comment|/* For the * (variable length field) */
name|b
operator|->
name|b_name
argument_list|,
name|filename
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOabort
condition|)
break|break;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bufname
argument_list|(
name|b
argument_list|)
specifier|register
name|Buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|tmp
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|try
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No file name]"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|basename
argument_list|(
name|b
operator|->
name|b_fname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf_exists
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s.%d"
argument_list|,
name|cp
argument_list|,
name|try
argument_list|)
expr_stmt|;
name|try
operator|++
expr_stmt|;
block|}
name|setbname
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|initlist
argument_list|(
name|b
argument_list|)
specifier|register
name|Buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|lfreelist
argument_list|(
name|b
operator|->
name|b_first
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_first
operator|=
name|b
operator|->
name|b_dot
operator|=
name|b
operator|->
name|b_last
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|listput
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|b_first
argument_list|)
expr_stmt|;
name|SavLine
argument_list|(
name|b
operator|->
name|b_dot
argument_list|,
name|NullStr
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_char
operator|=
literal|0
expr_stmt|;
name|AllMarkSet
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|b_dot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|curbuf
condition|)
name|getDOT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Returns pointer to buffer with name NAME, or if NAME is a string of digits    returns the buffer whose number equals those digits.  Otherwise, returns    0. */
end_comment

begin_function
name|Buffer
modifier|*
name|buf_exists
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|bp
operator|=
name|world
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|b_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bp
return|;
comment|/* Doesn't match any names.  Try for a buffer number... */
if|if
condition|(
operator|(
name|n
operator|=
name|chr_to_int
argument_list|(
name|name
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|world
init|;
name|n
operator|>
literal|1
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
break|break;
operator|--
name|n
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns buffer pointer with a file name NAME, if one exists.  Stat's the    file and compares inodes, in case NAME is a link, as well as the actual    characters that make up the file name. */
end_comment

begin_function
name|Buffer
modifier|*
name|file_exists
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|s
init|=
operator|&
name|stbuf
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
init|=
literal|0
decl_stmt|;
name|char
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|PathParse
argument_list|(
name|name
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fnamebuf
argument_list|,
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|s
operator|->
name|st_ino
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
block|{
if|if
condition|(
operator|(
name|b
operator|->
name|b_ino
operator|!=
literal|0
operator|&&
name|b
operator|->
name|b_ino
operator|==
name|s
operator|->
name|st_ino
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
return|return
name|b
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ralloc
parameter_list|(
name|obj
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|obj
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|obj
condition|)
name|new
operator|=
name|realloc
argument_list|(
name|obj
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|||
operator|!
name|obj
condition|)
name|new
operator|=
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_expr_stmt
name|setbname
argument_list|(
name|b
argument_list|,
name|name
argument_list|)
specifier|register
name|Buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UpdModLine
operator|++
expr_stmt|;
comment|/* Kludge ... but speeds things up considerably */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|b_name
operator|==
name|NoName
condition|)
name|b
operator|->
name|b_name
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b_name
operator|=
name|ralloc
argument_list|(
name|b
operator|->
name|b_name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|b
operator|->
name|b_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|->
name|b_name
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|setfname
argument_list|(
name|b
argument_list|,
name|name
argument_list|)
specifier|register
name|Buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|wholename
index|[
name|FILESIZE
index|]
decl_stmt|,
name|oldname
index|[
name|FILESIZE
index|]
decl_stmt|,
modifier|*
name|oldptr
init|=
name|oldname
decl_stmt|;
name|Buffer
modifier|*
name|save
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|UpdModLine
operator|++
expr_stmt|;
comment|/* Kludge ... but speeds things up considerably */
if|if
condition|(
name|b
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|oldptr
operator|=
literal|0
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|oldname
argument_list|,
name|b
operator|->
name|b_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|PathParse
argument_list|(
name|name
argument_list|,
name|wholename
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_fname
operator|=
name|ralloc
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|strlen
argument_list|(
name|wholename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|wholename
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|->
name|b_fname
operator|=
literal|0
expr_stmt|;
name|DoAutoExec
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|oldptr
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_mtime
operator|=
name|curbuf
operator|->
name|b_ino
operator|=
literal|0
expr_stmt|;
comment|/* until they're known. */
name|SetBuf
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|set_ino
argument_list|(
name|b
argument_list|)
specifier|register
name|Buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|b_fname
operator|==
literal|0
operator|||
name|stat
argument_list|(
name|b
operator|->
name|b_fname
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|b
operator|->
name|b_ino
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b_mtime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|b_ino
operator|=
name|stbuf
operator|.
name|st_ino
expr_stmt|;
name|b
operator|->
name|b_mtime
operator|=
name|stbuf
operator|.
name|st_mtime
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Find the file `fname' into buf and put in in window `w' */
end_comment

begin_function
name|Buffer
modifier|*
name|do_find
parameter_list|(
name|w
parameter_list|,
name|fname
parameter_list|,
name|force
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|fname
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|file_exists
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|mak_buf
argument_list|()
expr_stmt|;
name|setfname
argument_list|(
name|b
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|bufname
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|set_ino
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_ntbf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
name|Buffer
modifier|*
name|oldb
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* this'll read the file */
name|SetBuf
argument_list|(
name|oldb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|w
condition|)
name|tiewind
argument_list|(
name|w
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Set alternate buffer */
end_comment

begin_macro
name|SetABuf
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|Buffer
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|b
operator|!=
literal|0
condition|)
name|lastbuf
operator|=
name|b
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|SetBuf
argument_list|(
name|newbuf
argument_list|)
specifier|register
name|Buffer
operator|*
name|newbuf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|oldb
init|=
name|curbuf
decl_stmt|;
if|if
condition|(
name|newbuf
operator|==
name|curbuf
operator|||
name|newbuf
operator|==
literal|0
condition|)
return|return;
name|lsave
argument_list|()
expr_stmt|;
name|curbuf
operator|=
name|newbuf
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
comment|/* Do the read now ... */
if|if
condition|(
name|curbuf
operator|->
name|b_ntbf
condition|)
name|read_file
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
if|if
condition|(
name|oldb
operator|!=
literal|0
operator|&&
name|oldb
operator|->
name|b_type
operator|!=
name|curbuf
operator|->
name|b_type
condition|)
block|{
if|if
condition|(
name|curbuf
operator|->
name|b_type
operator|==
name|B_IPROCESS
condition|)
name|PushPBs
argument_list|()
expr_stmt|;
comment|/* Push process bindings */
elseif|else
if|if
condition|(
name|oldb
operator|->
name|b_type
operator|==
name|B_IPROCESS
condition|)
name|PopPBs
argument_list|()
expr_stmt|;
block|}
name|assign_p
argument_list|()
expr_stmt|;
comment|/* Set cur_proc */
endif|#
directive|endif
block|}
end_block

begin_function
name|Buffer
modifier|*
name|do_select
parameter_list|(
name|w
parameter_list|,
name|name
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|buf_exists
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|mak_buf
argument_list|()
expr_stmt|;
name|setfname
argument_list|(
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|setbname
argument_list|(
name|new
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
condition|)
name|tiewind
argument_list|(
name|w
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

end_unit

