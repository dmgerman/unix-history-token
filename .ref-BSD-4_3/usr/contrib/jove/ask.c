begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|F_COMPLETION
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|Asking
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Minibuf
index|[
name|LBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Line
modifier|*
name|CurAskPtr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points at some line in mini-buffer */
end_comment

begin_decl_stmt
name|private
name|Buffer
modifier|*
name|AskBuffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Askbuffer points to actual structure */
end_comment

begin_comment
comment|/* The way the mini-buffer works is this:  The first line of the mini-buffer    is where the user does his stuff.  The rest of the buffer contains    strings that the user often wants to use, for instance, file names, or    common search strings, etc.  If he types C-N or C-P while in ask(), we    bump the point up or down a line and extract the contents (we make sure    is somewhere in the mini-buffer). */
end_comment

begin_function
specifier|static
name|Buffer
modifier|*
name|get_minibuf
parameter_list|()
block|{
if|if
condition|(
name|AskBuffer
condition|)
return|return
name|AskBuffer
return|;
name|AskBuffer
operator|=
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
literal|"Minibuf"
argument_list|)
expr_stmt|;
name|AskBuffer
operator|->
name|b_type
operator|=
name|B_SCRATCH
expr_stmt|;
return|return
name|AskBuffer
return|;
block|}
end_function

begin_comment
comment|/* Add a string to the mini-buffer. */
end_comment

begin_macro
name|minib_add
argument_list|(
argument|str
argument_list|,
argument|movedown
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|get_minibuf
argument_list|()
argument_list|)
expr_stmt|;
name|LineInsert
argument_list|()
expr_stmt|;
name|ins_str
argument_list|(
name|str
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|movedown
condition|)
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|real_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
name|char
modifier|*
name|delim
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|d_proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|static
name|int
name|InAsk
init|=
literal|0
decl_stmt|;
name|jmp_buf
name|savejmp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|prompt_len
decl_stmt|;
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
name|int
name|abort
init|=
literal|0
decl_stmt|,
name|no_typed
init|=
literal|0
decl_stmt|;
name|data_obj
modifier|*
name|push_cmd
init|=
name|LastCmd
decl_stmt|;
name|int
name|o_exp
init|=
name|exp
decl_stmt|,
name|o_exp_p
init|=
name|exp_p
decl_stmt|;
if|if
condition|(
name|InAsk
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|push_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|InAsk
operator|++
expr_stmt|;
name|SetBuf
argument_list|(
name|get_minibuf
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inlist
argument_list|(
name|AskBuffer
operator|->
name|b_first
argument_list|,
name|CurAskPtr
argument_list|)
condition|)
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|prompt_len
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
comment|/* Beginning of buffer. */
name|linebuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
if|if
condition|(
name|InJoverc
condition|)
block|{
comment|/* this is a kludge */
name|abort
operator|++
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|exp
operator|=
literal|1
expr_stmt|;
name|exp_p
operator|=
literal|0
expr_stmt|;
name|last_cmd
operator|=
name|this_cmd
expr_stmt|;
name|init_strokes
argument_list|()
expr_stmt|;
name|cont
label|:
name|s_mess
argument_list|(
literal|"%s%s"
argument_list|,
name|prompt
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|Asking
operator|=
name|curchar
operator|+
name|prompt_len
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|EOF
operator|)
operator|||
name|index
argument_list|(
name|delim
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|d_proc
operator|==
literal|0
operator|||
call|(
modifier|*
name|d_proc
call|)
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|cleanup
goto|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTL
argument_list|(
name|G
argument_list|)
case|:
name|message
argument_list|(
literal|"[Aborted]"
argument_list|)
expr_stmt|;
name|abort
operator|++
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|CTL
argument_list|(
name|N
argument_list|)
case|:
case|case
name|CTL
argument_list|(
name|P
argument_list|)
case|:
if|if
condition|(
name|CurAskPtr
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
operator|(
name|c
operator|==
name|CTL
argument_list|(
name|P
argument_list|)
condition|?
operator|-
name|exp
else|:
name|exp
operator|)
decl_stmt|;
name|CurAskPtr
operator|=
name|next_line
argument_list|(
name|CurAskPtr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurAskPtr
operator|==
name|curbuf
operator|->
name|b_first
operator|&&
name|CurAskPtr
operator|->
name|l_next
operator|!=
literal|0
condition|)
name|CurAskPtr
operator|=
name|CurAskPtr
operator|->
name|l_next
expr_stmt|;
operator|(
name|void
operator|)
name|ltobuf
argument_list|(
name|CurAskPtr
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|this_cmd
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CTL
argument_list|(
name|R
argument_list|)
case|:
if|if
condition|(
name|def
condition|)
name|ins_str
argument_list|(
name|def
argument_list|,
name|NO
argument_list|)
expr_stmt|;
else|else
name|rbell
argument_list|()
expr_stmt|;
break|break;
default|default:
name|dispatch
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|curbuf
operator|!=
name|AskBuffer
condition|)
name|SetBuf
argument_list|(
name|AskBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|!=
name|curbuf
operator|->
name|b_first
condition|)
block|{
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|curline
operator|=
name|curbuf
operator|->
name|b_first
expr_stmt|;
comment|/* with whatever is in linebuf */
block|}
if|if
condition|(
name|this_cmd
operator|==
name|ARG_CMD
condition|)
goto|goto
name|cont
goto|;
block|}
name|cleanup
label|:
name|pop_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|LastCmd
operator|=
name|push_cmd
expr_stmt|;
name|exp_p
operator|=
name|o_exp_p
expr_stmt|;
name|exp
operator|=
name|o_exp
expr_stmt|;
name|no_typed
operator|=
operator|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|Minibuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
name|InAsk
operator|=
name|Asking
operator|=
name|Interactive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|abort
condition|)
block|{
if|if
condition|(
operator|!
name|charp
argument_list|()
condition|)
block|{
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|no_typed
condition|)
return|return
literal|0
return|;
block|}
else|else
name|complain
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
return|return
name|Minibuf
return|;
block|}
end_block

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|char
modifier|*
name|ask
parameter_list|(
name|def
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|def
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|ans
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ans
operator|=
name|real_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|0
condition|)
block|{
comment|/* Typed nothing. */
if|if
condition|(
name|def
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No default]"
argument_list|)
expr_stmt|;
return|return
name|def
return|;
block|}
return|return
name|ans
return|;
block|}
end_block

begin_comment
comment|/* VARARGS2 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|do_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|fmt
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|delim
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|d_proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|real_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|F_COMPLETION
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fc_filebase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|BadExtensions
index|[
literal|128
index|]
init|=
literal|".o"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|bad_extension
argument_list|(
argument|name
argument_list|,
argument|bads
argument_list|)
name|char
operator|*
name|name
operator|,
operator|*
name|bads
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|ip
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|,
name|ext_len
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ip
operator|=
name|index
argument_list|(
name|bads
argument_list|,
literal|' '
argument_list|)
condition|)
operator|*
name|ip
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|ip
operator|=
name|bads
operator|+
name|strlen
argument_list|(
name|bads
argument_list|)
expr_stmt|;
name|stop
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ext_len
operator|=
name|ip
operator|-
name|bads
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ext_len
operator|<
name|namelen
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|namelen
operator|-
name|ext_len
index|]
argument_list|,
name|bads
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|YES
return|;
block|}
do|while
condition|(
operator|(
name|bads
operator|=
name|ip
operator|+
literal|1
operator|)
operator|,
operator|!
name|stop
condition|)
do|;
return|return
name|NO
return|;
block|}
end_block

begin_macro
name|f_match
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|file
argument_list|,
name|fc_filebase
argument_list|,
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|isdir
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|PathParse
argument_list|(
name|name
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|stat
argument_list|(
name|filebuf
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fill_in
argument_list|(
name|dir_vec
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|dir_vec
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|minmatch
init|=
literal|0
decl_stmt|,
name|numfound
init|=
literal|0
decl_stmt|,
name|lastmatch
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|the_same
init|=
name|TRUE
decl_stmt|,
comment|/* After filling in, are we the same 				    as when we were called? */
name|is_ntdir
decl_stmt|;
comment|/* Is Newly Typed Directory name */
name|char
name|bads
index|[
literal|128
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|bads
argument_list|,
name|BadExtensions
argument_list|)
expr_stmt|;
comment|/* bad_extension() is destructive */
if|if
condition|(
name|bad_extension
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|,
name|bads
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|numfound
condition|)
name|minmatch
operator|=
name|min
argument_list|(
name|minmatch
argument_list|,
name|numcomp
argument_list|(
name|dir_vec
index|[
name|lastmatch
index|]
argument_list|,
name|dir_vec
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|minmatch
operator|=
name|strlen
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastmatch
operator|=
name|i
expr_stmt|;
name|numfound
operator|++
expr_stmt|;
block|}
comment|/* Ugh.  Beware--this is hard to get right in a reasonable 	   manner.  Please excuse this code--it's past my bedtime. */
if|if
condition|(
name|numfound
operator|==
literal|0
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|minmatch
operator|>
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
condition|)
block|{
name|the_same
operator|=
name|FALSE
expr_stmt|;
name|null_ncpy
argument_list|(
name|fc_filebase
argument_list|,
name|dir_vec
index|[
name|lastmatch
index|]
argument_list|,
name|minmatch
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
name|is_ntdir
operator|=
operator|(
operator|(
name|numfound
operator|==
literal|1
operator|)
operator|&&
operator|(
name|curchar
operator|>
literal|0
operator|)
operator|&&
operator|(
name|linebuf
index|[
name|curchar
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
name|isdir
argument_list|(
name|linebuf
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|the_same
operator|&&
operator|!
name|is_ntdir
condition|)
block|{
name|add_mess
argument_list|(
name|n
operator|==
literal|1
condition|?
literal|" [Unique]"
else|:
literal|" [Ambiguous]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_ntdir
condition|)
name|Insert
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
specifier|extern
name|int
name|alphacomp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* called from do_ask() when one of "\r\n ?" is typed.  Does the right    thing, depending on which. */
end_comment

begin_expr_stmt
specifier|static
name|f_complete
argument_list|(
argument|c
argument_list|)
block|{
name|char
name|dir
index|[
name|FILESIZE
index|]
block|,
operator|*
operator|*
name|dir_vec
block|;
name|int
name|nentries
block|,
name|i
block|;
if|if
condition|(
name|c
operator|==
name|CR
operator|||
name|c
operator|==
name|LF
condition|)
return|return
literal|0
return|;
end_expr_stmt

begin_comment
comment|/* tells ask to return now */
end_comment

begin_if
if|if
condition|(
operator|(
name|fc_filebase
operator|=
name|rindex
argument_list|(
name|linebuf
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|tmp
index|[
name|FILESIZE
index|]
decl_stmt|;
name|null_ncpy
argument_list|(
name|tmp
argument_list|,
name|linebuf
argument_list|,
operator|(
operator|++
name|fc_filebase
operator|-
name|linebuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|PathParse
argument_list|(
name|tmp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fc_filebase
operator|=
name|linebuf
expr_stmt|;
name|strcpy
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|nentries
operator|=
name|scandir
argument_list|(
name|dir
argument_list|,
operator|&
name|dir_vec
argument_list|,
name|f_match
argument_list|,
name|alphacomp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|add_mess
argument_list|(
literal|" [Unknown directory: %s]"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_if

begin_if
if|if
condition|(
name|nentries
operator|==
literal|0
condition|)
block|{
name|add_mess
argument_list|(
literal|" [No match]"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|fill_in
argument_list|(
name|dir_vec
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* we're a '?' */
name|int
name|maxlen
init|=
literal|0
decl_stmt|,
name|ncols
decl_stmt|,
name|col
decl_stmt|,
name|lines
decl_stmt|,
name|linespercol
decl_stmt|;
name|TOstart
argument_list|(
literal|"Completion"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* false means newline only on request */
name|Typeout
argument_list|(
literal|"(! means file will not be chosen unless typed explicitly)"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Possible completions (in %s):"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
name|maxlen
operator|=
name|max
argument_list|(
name|strlen
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|maxlen
operator|+=
literal|4
expr_stmt|;
comment|/* pad each column with at least 4 spaces */
name|ncols
operator|=
operator|(
name|CO
operator|-
literal|2
operator|)
operator|/
name|maxlen
expr_stmt|;
name|linespercol
operator|=
literal|1
operator|+
operator|(
name|nentries
operator|/
name|ncols
operator|)
expr_stmt|;
for|for
control|(
name|lines
operator|=
literal|0
init|;
name|lines
operator|<
name|linespercol
condition|;
name|lines
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|ncols
condition|;
name|col
operator|++
control|)
block|{
name|int
name|isbad
decl_stmt|,
name|which
decl_stmt|;
name|char
name|bads
index|[
literal|128
index|]
decl_stmt|;
name|which
operator|=
operator|(
name|col
operator|*
name|linespercol
operator|)
operator|+
name|lines
expr_stmt|;
if|if
condition|(
name|which
operator|>=
name|nentries
condition|)
break|break;
name|strcpy
argument_list|(
name|bads
argument_list|,
name|BadExtensions
argument_list|)
expr_stmt|;
name|isbad
operator|=
name|bad_extension
argument_list|(
name|dir_vec
index|[
name|which
index|]
argument_list|,
name|bads
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"%s%-*s"
argument_list|,
name|isbad
condition|?
literal|"!"
else|:
name|NullStr
argument_list|,
name|maxlen
operator|-
name|isbad
argument_list|,
name|dir_vec
index|[
name|which
index|]
argument_list|)
expr_stmt|;
block|}
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|freedir
argument_list|(
operator|&
name|dir_vec
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|1
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|char
operator|*
name|ask_file
argument_list|(
argument|def
argument_list|,
argument|buf
argument_list|)
name|char
operator|*
name|def
operator|,
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|ans
decl_stmt|,
name|prompt
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|pretty_name
init|=
name|pr_name
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
operator|!=
literal|0
operator|&&
operator|*
name|def
operator|!=
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|": %f (default %s) "
argument_list|,
name|pretty_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_COMPLETION
name|ans
operator|=
name|real_ask
argument_list|(
literal|"\r\n ?"
argument_list|,
name|f_complete
argument_list|,
name|pretty_name
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|0
operator|&&
operator|(
name|ans
operator|=
name|pretty_name
operator|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No default file name]"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ans
operator|=
name|ask
argument_list|(
name|pretty_name
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PathParse
argument_list|(
name|ans
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

end_unit

