begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_comment
comment|/* Contains the main loop initializations, and some system dependent    type things, e.g. putting terminal in CBREAK mode, etc. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV
end_ifndef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
endif|SYSV
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSLTC
end_ifdef

begin_decl_stmt
name|struct
name|ltchars
name|ls1
decl_stmt|,
name|ls2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|TIOCSLTC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGETC
end_ifdef

begin_decl_stmt
name|struct
name|tchars
name|tc1
decl_stmt|,
name|tc2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BRLUNIX
end_ifdef

begin_decl_stmt
name|struct
name|sg_brl
name|sg1
decl_stmt|,
name|sg2
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_decl_stmt
name|struct
name|termio
name|sg1
decl_stmt|,
name|sg2
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|SYSV
end_else

begin_decl_stmt
name|struct
name|sgttyb
name|sg1
decl_stmt|,
name|sg2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|SYSV
end_endif

begin_endif
endif|#
directive|endif
endif|BRLUNIX
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BIFF
end_ifdef

begin_decl_stmt
name|private
name|struct
name|stat
name|tt_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for biff */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_decl_stmt
name|private
name|char
modifier|*
name|tt_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the control tty */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* for systems w/o fchmod ... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|int
name|dw_biff
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not to fotz at all */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|time_t
name|time0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when jove started up */
end_comment

begin_decl_stmt
name|int
name|errormsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|NullStr
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_macro
name|finish
argument_list|(
argument|code
argument_list|)
end_macro

begin_block
block|{
name|int
name|CoreDump
init|=
operator|(
name|code
operator|!=
literal|0
operator|&&
name|code
operator|!=
name|SIGHUP
operator|)
decl_stmt|,
name|DelTmps
init|=
literal|1
decl_stmt|;
comment|/* Usually we delete them. */
ifdef|#
directive|ifdef
name|LSRHS
if|if
condition|(
name|CoreDump
condition|)
name|setdump
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
name|SIGINT
condition|)
block|{
name|char
name|c
decl_stmt|;
ifndef|#
directive|ifndef
name|MENLO_JCL
operator|(
name|void
operator|)
name|signal
argument_list|(
name|code
argument_list|,
name|finish
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f_mess
argument_list|(
literal|"Abort (Type 'n' if you're not sure)? "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0377
operator|)
operator|!=
literal|'y'
condition|)
block|{
name|redisplay
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|ttyset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|UnsetTerm
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Crashing
condition|)
block|{
name|Crashing
operator|++
expr_stmt|;
name|lsave
argument_list|()
expr_stmt|;
name|SyncRec
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"JOVE CRASH!! (code %d)\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|ModBufs
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Your buffers have been saved.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use \"jove_recover\" or \"jove -r\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"to have a look at them.\n"
argument_list|)
expr_stmt|;
name|DelTmps
operator|=
literal|0
expr_stmt|;
comment|/* Don't delete anymore. */
block|}
else|else
name|printf
argument_list|(
literal|"You didn't lose any work.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\r\nYou may have lost your work!\n"
argument_list|)
expr_stmt|;
block|}
name|flusho
argument_list|()
expr_stmt|;
if|if
condition|(
name|DelTmps
condition|)
block|{
name|tmpclose
argument_list|()
expr_stmt|;
name|recclose
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|CoreDump
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILING
name|exit
argument_list|(
name|exp_p
argument_list|)
expr_stmt|;
else|#
directive|else
name|_exit
argument_list|(
name|exp_p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|private
name|char
name|smbuf
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|bp
init|=
name|smbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|nchars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|peekbuf
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|peekp
init|=
name|peekbuf
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_function
name|void
name|setblock
parameter_list|(
name|fd
parameter_list|,
name|on
parameter_list|)
comment|/* turn blocking on or off */
specifier|register
name|int
name|fd
decl_stmt|,
name|on
decl_stmt|;
block|{
specifier|static
name|int
name|blockf
decl_stmt|,
name|nonblockf
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|blockf
operator|=
name|flags
operator|&
operator|~
name|O_NDELAY
expr_stmt|;
comment|/* make sure O_NDELAY is off */
name|nonblockf
operator|=
name|flags
operator||
name|O_NDELAY
expr_stmt|;
comment|/* make sure O_NDELAY is on */
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|on
condition|?
name|blockf
else|:
name|nonblockf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|SYSV
end_endif

begin_macro
name|Peekc
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|peekp
operator|==
name|peekbuf
condition|)
name|c
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
operator|*
operator|--
name|peekp
operator|&
literal|0377
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_macro
name|Ungetc
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|peekp
operator|==
operator|&
name|peekbuf
index|[
operator|(
sizeof|sizeof
name|peekbuf
operator|)
operator|-
literal|1
index|]
condition|)
return|return;
comment|/* Sorry, can't oblige you ... */
operator|*
name|peekp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|Inputp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|PIPEPROCS
end_ifdef

begin_macro
name|getchar
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
block|{
do|do
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|smbuf
argument_list|,
sizeof|sizeof
name|smbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
do|while
condition|(
name|nchars
operator|==
literal|0
operator|||
operator|(
name|nchars
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
if|if
condition|(
name|nchars
operator|<
literal|0
condition|)
else|#
directive|else
while|while
condition|(
name|nchars
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
endif|#
directive|endif
endif|SYSV
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|bp
operator|=
name|smbuf
expr_stmt|;
name|InputPending
operator|=
name|nchars
operator|>
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|)
operator|&
literal|0200
operator|)
operator|&&
name|MetaKey
operator|!=
literal|0
condition|)
block|{
operator|*
name|bp
operator|=
operator|(
name|c
operator|&
literal|0177
operator|)
expr_stmt|;
return|return
literal|'\033'
return|;
block|}
name|nchars
operator|--
expr_stmt|;
return|return
operator|(
operator|*
name|bp
operator|++
operator|&
literal|0177
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
else|PIPEPROCS
end_else

begin_macro
name|getchar
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|global_fd
decl_stmt|,
name|NumProcs
decl_stmt|,
name|errno
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|,
name|nfds
decl_stmt|;
name|int
name|reads
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
block|{
comment|/* Get a character from the keyboard, first checking for 		   any input from a process.  Handle that first, and then 		   deal with the terminal input. */
if|if
condition|(
name|NumProcs
operator|>
literal|0
condition|)
block|{
do|do
block|{
do|do
block|{
name|reads
operator|=
name|global_fd
expr_stmt|;
name|nfds
operator|=
name|select
argument_list|(
literal|32
argument_list|,
operator|&
name|reads
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nfds
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
switch|switch
condition|(
name|nfds
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|printf
argument_list|(
literal|"\rerror %d in select %d"
argument_list|,
name|errno
argument_list|,
name|global_fd
argument_list|)
expr_stmt|;
name|global_fd
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|reads
operator|&
literal|01
condition|)
block|{
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|smbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|smbuf
argument_list|)
argument_list|)
expr_stmt|;
name|reads
operator|&=
operator|~
literal|01
expr_stmt|;
operator|--
name|nfds
expr_stmt|;
block|}
while|while
condition|(
name|nfds
operator|--
condition|)
block|{
name|tmp
operator|=
name|ffs
argument_list|(
name|reads
argument_list|)
operator|-
literal|1
expr_stmt|;
name|read_proc
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|reads
operator|&=
operator|~
name|tmp
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
name|nchars
operator|<=
literal|0
condition|)
do|;
block|}
else|else
block|{
do|do
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|smbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|smbuf
argument_list|)
argument_list|)
expr_stmt|;
do|while
condition|(
name|nchars
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|bp
operator|=
name|smbuf
expr_stmt|;
name|InputPending
operator|=
operator|(
name|nchars
operator|>
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|)
operator|&
literal|0200
operator|)
operator|&&
name|MetaKey
operator|!=
literal|0
condition|)
block|{
operator|*
name|bp
operator|=
operator|(
name|c
operator|&
literal|0177
operator|)
expr_stmt|;
return|return
literal|'\033'
return|;
block|}
name|nchars
operator|--
expr_stmt|;
return|return
operator|*
name|bp
operator|++
operator|&
literal|0377
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PIPEPROCS
end_endif

begin_else
else|#
directive|else
else|IPROCS
end_else

begin_macro
name|getchar
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
block|{
do|do
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|smbuf
argument_list|,
sizeof|sizeof
name|smbuf
argument_list|)
expr_stmt|;
do|while
condition|(
name|nchars
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|nchars
operator|<=
literal|0
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|bp
operator|=
name|smbuf
expr_stmt|;
name|InputPending
operator|=
name|nchars
operator|>
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|)
operator|&
literal|0200
operator|)
operator|&&
name|MetaKey
operator|!=
literal|0
condition|)
block|{
operator|*
name|bp
operator|=
operator|(
name|c
operator|&
literal|0177
operator|)
expr_stmt|;
return|return
literal|'\033'
return|;
block|}
name|nchars
operator|--
expr_stmt|;
return|return
operator|*
name|bp
operator|++
operator|&
literal|0377
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|IPROCS
end_endif

begin_decl_stmt
name|int
name|InputPending
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns non-zero if a character waiting */
end_comment

begin_macro
name|charp
argument_list|()
end_macro

begin_block
block|{
name|int
name|some
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|InJoverc
operator|!=
literal|0
operator|||
name|nchars
operator|>
literal|0
operator|||
name|Inputp
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|BRLUNIX
block|{
specifier|static
name|struct
name|sg_brl
name|gttyBuf
decl_stmt|;
name|gtty
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gttyBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|gttyBuf
operator|.
name|sg_xflags
operator|&
name|INWAIT
condition|)
name|some
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FIONREAD
block|{
name|long
name|c
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|c
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|c
operator|=
literal|0
expr_stmt|;
name|some
operator|=
operator|(
name|c
operator|>
literal|0
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|FIONREAD
ifdef|#
directive|ifdef
name|SYSV
name|setblock
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* turn blocking off */
name|nchars
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|smbuf
argument_list|,
sizeof|sizeof
name|smbuf
argument_list|)
expr_stmt|;
comment|/* Is anything there? */
name|setblock
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn blocking on */
if|if
condition|(
name|nchars
operator|>
literal|0
condition|)
comment|/* something was there */
name|bp
operator|=
name|smbuf
expr_stmt|;
comment|/* make sure bp points to it */
name|some
operator|=
operator|(
name|nchars
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* just say we found something */
endif|#
directive|endif
endif|SYSV
ifdef|#
directive|ifdef
name|c70
name|some
operator|=
operator|!
name|empty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|some
return|;
block|}
end_block

begin_macro
name|ResetTerm
argument_list|()
end_macro

begin_block
block|{
name|putpad
argument_list|(
name|TI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|VS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|KS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIFF
if|if
condition|(
name|BiffChk
operator|!=
name|dw_biff
condition|)
name|biff_init
argument_list|()
expr_stmt|;
comment|/* just in case we changed our minds about whether to deal with 	   biff */
endif|#
directive|endif
name|chkmail
argument_list|(
name|YES
argument_list|)
expr_stmt|;
comment|/* force it to check to we can be accurate */
name|do_sgtty
argument_list|()
expr_stmt|;
comment|/* this is so if you change baudrate or stuff 			   like that, JOVE will notice. */
name|ttyset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|UnsetTerm
argument_list|(
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ttyset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|KE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|VE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|TE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|JOB_CONTROL
end_ifdef

begin_macro
name|PauseJove
argument_list|()
end_macro

begin_block
block|{
name|UnsetTerm
argument_list|(
name|ModBufs
argument_list|(
literal|0
argument_list|)
condition|?
literal|"[There are modified buffers]"
else|:
name|NullStr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|ResetTerm
argument_list|()
expr_stmt|;
name|ClAndRedraw
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|Push
argument_list|()
end_macro

begin_block
block|{
name|int
name|pid
decl_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|complain
argument_list|(
literal|"[Fork failed]"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|UnsetTerm
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|Shell
argument_list|,
name|basename
argument_list|(
name|Shell
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"[Execl failed]"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
block|{
name|int
function_decl|(
modifier|*
name|old_int
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|old_quit
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
ifdef|#
directive|ifdef
name|IPROCS
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dowait
argument_list|(
name|pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ResetTerm
argument_list|()
expr_stmt|;
name|ClAndRedraw
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_int
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|old_quit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|int
name|OKXonXoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^S and ^Q initially DON'T work */
end_comment

begin_macro
name|ttsize
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|win
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|win
operator|.
name|ws_col
condition|)
name|CO
operator|=
name|win
operator|.
name|ws_col
expr_stmt|;
if|if
condition|(
name|win
operator|.
name|ws_row
condition|)
name|LI
operator|=
name|win
operator|.
name|ws_row
expr_stmt|;
block|}
else|#
directive|else
else|TIOCGWINSZ
ifdef|#
directive|ifdef
name|BTL_BLIT
include|#
directive|include
file|<sys/jioctl.h>
name|struct
name|jwinsize
name|jwin
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|JWINSIZE
argument_list|,
operator|&
name|jwin
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|jwin
operator|.
name|bytesx
condition|)
name|CO
operator|=
name|jwin
operator|.
name|bytesx
expr_stmt|;
if|if
condition|(
name|jwin
operator|.
name|bytesy
condition|)
name|LI
operator|=
name|jwin
operator|.
name|bytesy
expr_stmt|;
block|}
endif|#
directive|endif
endif|BTL_BLIT
endif|#
directive|endif
endif|TIOCGWINSZ
name|ILI
operator|=
name|LI
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BIFF
end_ifdef

begin_macro
name|biff_init
argument_list|()
end_macro

begin_block
block|{
name|dw_biff
operator|=
operator|(
operator|(
name|BiffChk
operator|)
operator|&&
ifndef|#
directive|ifndef
name|BSD4_2
operator|(
operator|(
name|tt_name
operator|!=
literal|0
operator|)
operator|||
operator|(
name|tt_name
operator|=
name|ttyname
argument_list|(
literal|0
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|stat
argument_list|(
name|tt_name
argument_list|,
operator|&
name|tt_stat
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
else|#
directive|else
operator|(
name|fstat
argument_list|(
literal|0
argument_list|,
operator|&
name|tt_stat
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
endif|#
directive|endif
operator|(
name|tt_stat
operator|.
name|st_mode
operator|&
name|S_IEXEC
operator|)
operator|)
expr_stmt|;
comment|/* he's using biff */
block|}
end_block

begin_macro
name|biff
argument_list|(
argument|on
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|dw_biff
operator|==
name|NO
condition|)
return|return;
ifndef|#
directive|ifndef
name|BSD4_2
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tt_name
argument_list|,
name|on
condition|?
name|tt_stat
operator|.
name|st_mode
else|:
operator|(
name|tt_stat
operator|.
name|st_mode
operator|&
operator|~
name|S_IEXEC
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fchmod
argument_list|(
literal|0
argument_list|,
name|on
condition|?
name|tt_stat
operator|.
name|st_mode
else|:
operator|(
name|tt_stat
operator|.
name|st_mode
operator|&
operator|~
name|S_IEXEC
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|ttinit
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BIFF
name|biff_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCSLTC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|ls1
argument_list|)
expr_stmt|;
name|ls2
operator|=
name|ls1
expr_stmt|;
name|ls2
operator|.
name|t_suspc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|ls2
operator|.
name|t_dsuspc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|ls2
operator|.
name|t_flushc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|ls2
operator|.
name|t_lnextc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGETC
comment|/* Change interupt and quit. */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|tc1
argument_list|)
expr_stmt|;
name|tc2
operator|=
name|tc1
expr_stmt|;
name|tc2
operator|.
name|t_intrc
operator|=
name|CTL
argument_list|(])
expr_stmt|;
name|tc2
operator|.
name|t_quitc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|OKXonXoff
condition|)
block|{
name|tc2
operator|.
name|t_stopc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
name|tc2
operator|.
name|t_startc
operator|=
operator|(
name|char
operator|)
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
endif|TIOCGETC
name|do_sgtty
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|private
name|int
name|done_ttinit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|do_sgtty
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SYSV
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCGETA
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sg1
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|sg1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SYSV
name|sg2
operator|=
name|sg1
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|TABS
operator|=
operator|!
operator|(
operator|(
name|sg1
operator|.
name|c_oflag
operator|&
name|TAB3
operator|)
operator|==
name|TAB3
operator|)
expr_stmt|;
name|ospeed
operator|=
name|sg1
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
name|sg2
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|INLCR
operator||
name|ICRNL
operator||
name|IGNCR
operator|)
expr_stmt|;
name|sg2
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
name|sg2
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OCRNL
operator||
name|ONLCR
operator|)
expr_stmt|;
name|sg2
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
sizeof|sizeof
name|smbuf
expr_stmt|;
name|sg2
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|TABS
operator|=
operator|!
operator|(
name|sg1
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
expr_stmt|;
name|ospeed
operator|=
name|sg1
operator|.
name|sg_ospeed
expr_stmt|;
ifdef|#
directive|ifdef
name|BRLUNIX
name|sg2
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator|)
expr_stmt|;
name|sg2
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
comment|/* VT100 Kludge: leave STALL on for flow control if DC3DC1 (Yuck.) */
name|sg2
operator|.
name|sg_xflags
operator|&=
operator|~
operator|(
operator|(
name|sg2
operator|.
name|sg_xflags
operator|&
name|DC3DC1
condition|?
literal|0
else|:
name|STALL
operator|)
operator||
name|PAGE
operator|)
expr_stmt|;
else|#
directive|else
name|sg2
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator|)
expr_stmt|;
endif|#
directive|endif
endif|BRLUNIX
ifdef|#
directive|ifdef
name|EUNICE
name|sg2
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
comment|/* Eunice needs RAW mode last I heard. */
else|#
directive|else
ifdef|#
directive|ifdef
name|PURDUE_EE
ifdef|#
directive|ifdef
name|pdp11
name|sg2
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
else|#
directive|else
name|sg2
operator|.
name|sg_flags
operator||=
operator|(
name|MetaKey
condition|?
name|RAW
else|:
name|CBREAK
operator|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|sg2
operator|.
name|sg_flags
operator||=
operator|(
name|MetaKey
condition|?
name|RAW
else|:
name|CBREAK
operator|)
expr_stmt|;
endif|#
directive|endif
endif|PURDUE_EE
endif|#
directive|endif
endif|EUNICE
endif|#
directive|endif
endif|SYSV
block|}
end_block

begin_macro
name|tty_reset
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|done_ttinit
condition|)
return|return;
name|ttyset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/* go back to original modes */
name|ttinit
argument_list|()
expr_stmt|;
name|ttyset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If n is OFF reset to original modes */
end_comment

begin_macro
name|ttyset
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|done_ttinit
operator|&&
name|n
operator|==
literal|0
condition|)
comment|/* Try to reset before we've set! */
return|return;
ifdef|#
directive|ifdef
name|SYSV
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETAW
argument_list|,
name|n
operator|==
literal|0
condition|?
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|sg1
else|:
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|sg2
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BRLUNIX
operator|(
name|void
operator|)
name|stty
argument_list|(
literal|0
argument_list|,
name|n
operator|==
literal|0
condition|?
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|sg1
else|:
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|sg2
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
name|n
operator|==
literal|0
condition|?
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|sg1
else|:
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|sg2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BRLUNIX
endif|#
directive|endif
endif|SYSV
ifdef|#
directive|ifdef
name|TIOCSETC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
name|n
operator|==
literal|0
condition|?
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|tc1
else|:
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|tc2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TIOCSETC
ifdef|#
directive|ifdef
name|TIOCSLTC
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
name|n
operator|==
literal|0
condition|?
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|ls1
else|:
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|ls2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TIOCSLTC
name|done_ttinit
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BIFF
name|biff
argument_list|(
operator|!
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|int
name|this_cmd
decl_stmt|,
name|last_cmd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|dispatch
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|data_obj
modifier|*
name|cp
decl_stmt|;
name|this_cmd
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|mainmap
index|[
name|c
operator|&
literal|0177
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
name|exp_p
operator|=
name|errormsg
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
return|return;
block|}
name|ExecCmd
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|LastKeyStruck
decl_stmt|,
name|MetaKey
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|getch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|peekc
decl_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
specifier|extern
name|int
name|NumProcs
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|int
name|ModCount
decl_stmt|,
name|Interactive
decl_stmt|;
if|if
condition|(
name|Inputp
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|Inputp
operator|++
operator|)
operator|!=
literal|0
condition|)
return|return
name|LastKeyStruck
operator|=
name|c
return|;
name|Inputp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|InJoverc
condition|)
return|return
name|EOF
return|;
comment|/* somethings wrong if Inputp runs out while 				   we're reading a .joverc file. */
if|if
condition|(
name|ModCount
operator|>=
name|SyncFreq
condition|)
block|{
name|ModCount
operator|=
literal|0
expr_stmt|;
name|SyncRec
argument_list|()
expr_stmt|;
block|}
comment|/* If we're not interactive and we're not executing a macro, 	   AND there are no ungetc'd characters, we read from the 	   terminal (i.e., getch()).  And characters only get put 	   in macros from inside this if. */
if|if
condition|(
operator|(
operator|(
name|peekc
operator|=
name|c
operator|=
name|Peekc
argument_list|()
operator|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|Interactive
operator|||
operator|(
operator|(
name|c
operator|=
name|mac_getc
argument_list|()
operator|)
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* So messages that aren't error messages don't 		   hang around forever. */
if|if
condition|(
operator|!
name|UpdMesg
operator|&&
operator|!
name|Asking
condition|)
block|{
comment|/* Don't erase if we are asking */
if|if
condition|(
name|mesgbuf
index|[
literal|0
index|]
operator|&&
operator|!
name|errormsg
condition|)
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
block|}
name|redisplay
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
ifdef|#
directive|ifdef
name|PIPEPROCS
if|if
condition|(
name|NumProcs
operator|>
literal|0
condition|)
block|{
name|sigrelse
argument_list|(
name|INPUT_SIG
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|inIOread
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
name|finish
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|inIOread
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
ifdef|#
directive|ifdef
name|PIPEPROCS
if|if
condition|(
name|NumProcs
operator|>
literal|0
condition|)
block|{
name|sighold
argument_list|(
name|INPUT_SIG
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|Interactive
operator|&&
operator|(
name|KeyMacro
operator|.
name|m_flags
operator|&
name|DEFINE
operator|)
condition|)
name|mac_putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peekc
operator|==
operator|-
literal|1
condition|)
comment|/* Don't add_stroke peekc's */
name|add_stroke
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|LastKeyStruck
operator|=
name|c
return|;
block|}
end_block

begin_macro
name|dorecover
argument_list|()
end_macro

begin_block
block|{
name|execl
argument_list|(
name|RECOVER
argument_list|,
literal|"jove_recover"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: execl failed!\n"
argument_list|,
name|RECOVER
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ShowVersion
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
name|s_mess
argument_list|(
literal|"Jonathan's Own Version of Emacs (%s)"
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|UNIX_cmdline
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lineno
init|=
literal|0
decl_stmt|,
name|nwinds
init|=
literal|1
decl_stmt|;
name|Buffer
modifier|*
name|b
decl_stmt|;
name|ShowVersion
argument_list|()
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'+'
condition|)
block|{
name|int
name|force
init|=
operator|(
name|nwinds
operator|>
literal|0
operator|||
name|lineno
operator|!=
literal|0
operator|)
decl_stmt|;
name|minib_add
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|force
condition|?
name|YES
else|:
name|NO
argument_list|)
expr_stmt|;
name|b
operator|=
name|do_find
argument_list|(
name|nwinds
operator|>
literal|0
condition|?
name|curwind
else|:
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|curbuf
operator|->
name|b_first
argument_list|,
name|lineno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwinds
operator|>
literal|1
condition|)
name|NextWindow
argument_list|()
expr_stmt|;
if|if
condition|(
name|nwinds
condition|)
name|nwinds
operator|--
expr_stmt|;
block|}
name|lineno
operator|=
literal|0
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* Ignore .joverc in HOME */
break|break;
case|case
literal|'p'
case|:
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
name|SetBuf
argument_list|(
name|do_find
argument_list|(
name|curwind
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ParseAll
argument_list|()
expr_stmt|;
name|nwinds
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
name|exp_p
operator|=
literal|1
expr_stmt|;
name|find_tag
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|YES
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|nwinds
operator|++
expr_stmt|;
else|else
name|nwinds
operator|+=
operator|-
literal|1
operator|+
name|chr_to_int
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
literal|10
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|div_wind
argument_list|(
name|curwind
argument_list|,
name|nwinds
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|lineno
operator|=
name|chr_to_int
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_macro
name|Ignore
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_function_decl
name|Ignorf
function_decl|(
name|a
function_decl|)
name|int
argument_list|(
argument|*a
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_macro
name|Ignorl
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|long
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|error
argument_list|(
argument|fmt
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|mesgbuf
argument_list|,
sizeof|sizeof
name|mesgbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|UpdMesg
operator|++
expr_stmt|;
block|}
name|rbell
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|longjmp
argument_list|(
name|mainjmp
argument_list|,
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|complain
argument_list|(
argument|fmt
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|fmt
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|mesgbuf
argument_list|,
sizeof|sizeof
name|mesgbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|UpdMesg
operator|++
expr_stmt|;
block|}
name|rbell
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|longjmp
argument_list|(
name|mainjmp
argument_list|,
name|COMPLAIN
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|confirm
argument_list|(
argument|fmt
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
modifier|*
name|yorn
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|mesgbuf
argument_list|,
sizeof|sizeof
name|mesgbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yorn
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|mesgbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|yorn
operator|!=
literal|'Y'
operator|&&
operator|*
name|yorn
operator|!=
literal|'y'
condition|)
operator|(
name|void
operator|)
name|longjmp
argument_list|(
name|mainjmp
argument_list|,
name|COMPLAIN
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|RecDepth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|Recur
argument_list|()
end_macro

begin_block
block|{
name|char
name|bname
index|[
literal|128
index|]
decl_stmt|;
name|Mark
modifier|*
name|m
decl_stmt|;
name|sprintf
argument_list|(
name|bname
argument_list|,
literal|"%s"
argument_list|,
name|curbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|m
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|FLOATER
argument_list|)
expr_stmt|;
name|RecDepth
operator|++
expr_stmt|;
name|UpdModLine
operator|++
expr_stmt|;
name|DoKeys
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 means not first time */
name|UpdModLine
operator|++
expr_stmt|;
name|RecDepth
operator|--
expr_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|bname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp_p
condition|)
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|jmp_buf
name|mainjmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|iniargc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* main sets these for DoKeys() */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|iniargv
decl_stmt|;
end_decl_stmt

begin_macro
name|DoKeys
argument_list|(
argument|nocmdline
argument_list|)
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
name|jmp_buf
name|savejmp
decl_stmt|;
name|push_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|nocmdline
condition|)
name|UNIX_cmdline
argument_list|(
name|iniargc
argument_list|,
name|iniargv
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUIT
case|:
if|if
condition|(
name|RecDepth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ModMacs
argument_list|()
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
if|if
condition|(
name|Upper
argument_list|(
operator|*
name|ask
argument_list|(
literal|"No"
argument_list|,
literal|"Some MACROS haven't been saved; leave anyway? "
argument_list|)
argument_list|)
operator|!=
literal|'Y'
condition|)
break|break;
block|}
if|if
condition|(
name|ModBufs
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
if|if
condition|(
name|Upper
argument_list|(
operator|*
name|ask
argument_list|(
literal|"No"
argument_list|,
literal|"Some buffers haven't been saved; leave anyway? "
argument_list|)
argument_list|)
operator|!=
literal|'Y'
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|IPROCS
name|KillProcs
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|pop_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
return|return;
case|case
name|ERROR
case|:
name|getDOT
argument_list|()
expr_stmt|;
comment|/* God knows what state linebuf was in */
case|case
name|COMPLAIN
case|:
name|gc_openfiles
argument_list|()
expr_stmt|;
comment|/* close any files we left open */
name|errormsg
operator|++
expr_stmt|;
name|fix_macros
argument_list|()
expr_stmt|;
name|Asking
operator|=
literal|0
expr_stmt|;
name|curwind
operator|->
name|w_bufp
operator|=
name|curbuf
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
break|break;
block|}
name|this_cmd
operator|=
name|last_cmd
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|this_cmd
operator|!=
name|ARG_CMD
condition|)
block|{
name|exp
operator|=
literal|1
expr_stmt|;
name|exp_p
operator|=
literal|0
expr_stmt|;
name|last_cmd
operator|=
name|this_cmd
expr_stmt|;
name|init_strokes
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|dispatch
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|int
name|Crashing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
modifier|*
name|scanvec
parameter_list|(
name|args
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|args
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|args
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|args
return|;
name|args
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
name|int
name|UpdFreq
init|=
literal|30
decl_stmt|,
name|inIOread
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|updmode
argument_list|()
end_macro

begin_block
block|{
name|UpdModLine
operator|++
expr_stmt|;
if|if
condition|(
name|inIOread
condition|)
name|redisplay
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|JOB_CONTROL
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|updmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|UpdFreq
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_extern
extern|extern win_reshape(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_macro
name|win_reshape
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|diff
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* 	 * Save old number of lines. 	 */
name|diff
operator|=
name|LI
expr_stmt|;
comment|/* 	 * Get new line/col info. 	 */
name|ttsize
argument_list|()
expr_stmt|;
comment|/* 	 * LI has changed, and now holds the 	 * new value.  See how much the size 	 * changed. 	 */
name|diff
operator|=
name|LI
operator|-
name|diff
expr_stmt|;
comment|/* 	 * Change the size of the current window 	 * only.  If they shrank by more than 	 * the window size, tough. 	 */
if|if
condition|(
operator|(
name|curwind
operator|->
name|w_height
operator|+
name|diff
operator|)
operator|<
literal|2
condition|)
name|curwind
operator|->
name|w_height
operator|=
literal|2
expr_stmt|;
else|else
name|curwind
operator|->
name|w_height
operator|+=
name|diff
expr_stmt|;
name|make_scr
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|win_reshape
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|ttbuf
index|[
literal|512
index|]
decl_stmt|,
ifndef|#
directive|ifndef
name|VMUNIX
name|s_iobuff
index|[
name|LBSIZE
index|]
decl_stmt|,
name|s_genbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|s_linebuf
index|[
name|LBSIZE
index|]
decl_stmt|,
endif|#
directive|endif
modifier|*
name|cp
decl_stmt|;
ifndef|#
directive|ifndef
name|VMUNIX
comment|/* The way I look at it, there ain't no way I is gonna run 	   out of stack space UNLESS I have some kind of infinite 	   recursive bug.  So why use up some valuable memory, when 	   there is plenty of space on the stack?  (This only matters 	   on wimpy pdp11's, of course.) */
name|iobuff
operator|=
name|s_iobuff
expr_stmt|;
name|genbuf
operator|=
name|s_genbuf
expr_stmt|;
name|linebuf
operator|=
name|s_linebuf
expr_stmt|;
endif|#
directive|endif
name|errormsg
operator|=
literal|0
expr_stmt|;
name|iniargc
operator|=
name|argc
expr_stmt|;
name|iniargv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\rAck! I can't deal with error \"%s\" now.\n\r"
argument_list|,
name|mesgbuf
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-r"
argument_list|)
condition|)
name|dorecover
argument_list|()
expr_stmt|;
name|getTERM
argument_list|()
expr_stmt|;
comment|/* Get terminal. */
if|if
condition|(
name|getenv
argument_list|(
literal|"METAKEY"
argument_list|)
condition|)
name|MetaKey
operator|=
literal|1
expr_stmt|;
name|ttsize
argument_list|()
expr_stmt|;
name|InitCM
argument_list|()
expr_stmt|;
name|tmpinit
argument_list|()
expr_stmt|;
comment|/* Init temp file. */
if|if
condition|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|Shell
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|make_scr
argument_list|()
expr_stmt|;
name|mac_init
argument_list|()
expr_stmt|;
comment|/* Initialize Macros */
name|winit
argument_list|()
expr_stmt|;
comment|/* Initialize Window */
ifdef|#
directive|ifdef
name|IPROCS
name|pinit
argument_list|()
expr_stmt|;
comment|/* Pipes/process initialization */
endif|#
directive|endif
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|Mainbuf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHDIR
block|{
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
operator|(
name|argp
operator|=
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-d"
argument_list|)
operator|)
operator|&&
operator|(
name|argp
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
condition|)
name|setCWD
argument_list|(
name|argp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|getCWD
argument_list|()
expr_stmt|;
comment|/* After we setup curbuf in case we have to getwd() */
block|}
endif|#
directive|endif
name|HomeDir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HomeDir
operator|==
literal|0
condition|)
name|HomeDir
operator|=
literal|"/"
expr_stmt|;
name|HomeLen
operator|=
name|strlen
argument_list|(
name|HomeDir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|joverc
argument_list|(
name|JOVERC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-j"
argument_list|)
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s/.joverc"
argument_list|,
name|HomeDir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|joverc
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYSV
name|sprintf
argument_list|(
name|MailBox
argument_list|,
literal|"/usr/mail/%s"
argument_list|,
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|Mailbox
argument_list|,
literal|"/usr/spool/mail/%s"
argument_list|,
name|getenv
argument_list|(
literal|"USER"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SYSV
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|time0
argument_list|)
expr_stmt|;
name|ttinit
argument_list|()
expr_stmt|;
comment|/* initialize terminal (after ~/.joverc) */
name|settout
argument_list|(
name|ttbuf
argument_list|)
expr_stmt|;
comment|/* not until we know baudrate */
name|ResetTerm
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
ifdef|#
directive|ifdef
name|SIGWINCH
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|win_reshape
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* set things up to update the modeline every UpdFreq seconds */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|updmode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|UpdFreq
argument_list|)
expr_stmt|;
name|cl_scr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|RedrawDisplay
argument_list|()
expr_stmt|;
comment|/* start the redisplay process. */
name|DoKeys
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

