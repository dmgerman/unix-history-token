begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
name|long
name|io_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of chars in this open_file */
end_comment

begin_decl_stmt
name|int
name|io_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines in this open_file */
end_comment

begin_decl_stmt
name|private
name|int
name|tellall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display file io info? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_decl_stmt
name|char
name|iobuff
index|[
name|LBSIZE
index|]
decl_stmt|,
name|genbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|linebuf
index|[
name|LBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|iobuff
decl_stmt|,
modifier|*
name|genbuf
decl_stmt|,
modifier|*
name|linebuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BACKUPFILES
end_ifdef

begin_decl_stmt
name|int
name|BkupOnWrite
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|close_file
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|File
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fp
condition|)
block|{
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tellall
operator|!=
name|QUIET
condition|)
name|add_mess
argument_list|(
literal|" %d lines, %D characters."
argument_list|,
name|io_lines
argument_list|,
name|io_chars
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Write the region from line1/char1 to line2/char2 to FP.  This    never CLOSES the file since we don't know if we want to. */
end_comment

begin_decl_stmt
name|int
name|EndWNewline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|putreg
argument_list|(
name|fp
argument_list|,
name|line1
argument_list|,
name|char1
argument_list|,
name|line2
argument_list|,
name|char2
argument_list|,
name|makesure
argument_list|)
specifier|register
name|File
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Line
modifier|*
name|line1
decl_stmt|,
modifier|*
name|line2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|makesure
condition|)
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|line1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|line2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
while|while
condition|(
name|line1
operator|!=
name|line2
operator|->
name|l_next
condition|)
block|{
name|lp
operator|=
name|lcontents
argument_list|(
name|line1
argument_list|)
operator|+
name|char1
expr_stmt|;
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
name|fputnchar
argument_list|(
name|lp
argument_list|,
operator|(
name|char2
operator|-
name|char1
operator|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|c
operator|=
operator|*
name|lp
operator|++
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|io_chars
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|line1
operator|!=
name|line2
condition|)
block|{
name|io_lines
operator|++
expr_stmt|;
name|io_chars
operator|++
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|line1
operator|=
name|line1
operator|->
name|l_next
expr_stmt|;
name|char1
operator|=
literal|0
expr_stmt|;
block|}
name|flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|read_file
argument_list|(
argument|file
argument_list|,
argument|is_insert
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Bufpos
name|save
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|is_insert
condition|)
block|{
name|curbuf
operator|->
name|b_ntbf
operator|=
literal|0
expr_stmt|;
name|set_ino
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_READ
argument_list|,
operator|!
name|COMPLAIN
argument_list|,
operator|!
name|QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
block|{
if|if
condition|(
operator|!
name|is_insert
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
name|s_mess
argument_list|(
literal|"(new file)"
argument_list|)
expr_stmt|;
else|else
name|s_mess
argument_list|(
name|IOerr
argument_list|(
literal|"open"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|dofread
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_insert
operator|&&
name|io_chars
operator|>
literal|0
condition|)
name|modify
argument_list|()
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dofread
argument_list|(
name|fp
argument_list|)
specifier|register
name|File
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|end
index|[
name|LBSIZE
index|]
decl_stmt|;
name|int
name|xeof
init|=
literal|0
decl_stmt|;
name|Line
modifier|*
name|savel
init|=
name|curline
decl_stmt|;
name|int
name|savec
init|=
name|curchar
decl_stmt|;
name|strcpy
argument_list|(
name|end
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|)
expr_stmt|;
name|xeof
operator|=
name|f_gets
argument_list|(
name|fp
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|,
name|LBSIZE
operator|-
name|curchar
argument_list|)
expr_stmt|;
name|SavLine
argument_list|(
name|curline
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xeof
condition|)
do|do
block|{
name|xeof
operator|=
name|f_gets
argument_list|(
name|fp
argument_list|,
name|linebuf
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
name|curline
operator|=
name|listput
argument_list|(
name|curbuf
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|curline
operator|->
name|l_dline
operator|=
name|putline
argument_list|(
name|linebuf
argument_list|)
operator||
name|DIRTY
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|xeof
condition|)
do|;
name|linecopy
argument_list|(
name|linebuf
argument_list|,
operator|(
name|curchar
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|)
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|SavLine
argument_list|(
name|curline
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|IFixMarks
argument_list|(
name|savel
argument_list|,
name|savec
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SaveFile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|IsModified
argument_list|(
name|curbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|curbuf
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|WriteFile
argument_list|()
expr_stmt|;
else|else
block|{
name|filemunge
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|)
expr_stmt|;
name|chk_mtime
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
literal|"save"
argument_list|)
expr_stmt|;
name|file_write
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unmodify
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|message
argument_list|(
literal|"No changes need to be written."
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|HomeDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* home directory */
end_comment

begin_decl_stmt
name|int
name|HomeLen
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of home directory string */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHDIR
end_ifndef

begin_function
name|char
modifier|*
name|pr_name
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|fname
argument_list|,
name|HomeDir
argument_list|,
name|HomeLen
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|name_buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"~%s"
argument_list|,
name|fname
operator|+
name|HomeLen
argument_list|)
expr_stmt|;
return|return
name|name_buf
return|;
block|}
return|return
name|fname
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NDIRS
value|5
end_define

begin_decl_stmt
name|private
name|char
modifier|*
name|DirStack
index|[
name|NDIRS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|DirSP
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory stack pointer */
end_comment

begin_define
define|#
directive|define
name|PWD
value|(DirStack[DirSP])
end_define

begin_function
name|char
modifier|*
name|pwd
parameter_list|()
block|{
return|return
name|PWD
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|pr_name
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|numcomp
argument_list|(
name|fname
argument_list|,
name|PWD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PWD
index|[
name|n
index|]
operator|==
literal|0
operator|)
operator|&&
comment|/* Matched to end of PWD */
operator|(
name|fname
index|[
name|n
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|fname
operator|+
name|n
operator|+
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|HomeDir
argument_list|,
literal|"/"
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|fname
argument_list|,
name|HomeDir
argument_list|,
name|HomeLen
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|name_buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"~%s"
argument_list|,
name|fname
operator|+
name|HomeLen
argument_list|)
expr_stmt|;
return|return
name|name_buf
return|;
block|}
return|return
name|fname
return|;
comment|/* return entire path name */
block|}
end_function

begin_macro
name|Chdir
argument_list|()
end_macro

begin_block
block|{
name|char
name|dirbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|ask_file
argument_list|(
name|PWD
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dirbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|s_mess
argument_list|(
literal|"cd: cannot change into %s."
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|UpdModLine
operator|++
expr_stmt|;
name|setCWD
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|JOB_CONTROL
end_ifndef

begin_function
name|char
modifier|*
name|getwd
parameter_list|()
block|{
name|Buffer
modifier|*
name|old
init|=
name|curbuf
decl_stmt|;
name|char
modifier|*
name|ret_val
decl_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
literal|"pwd-output"
argument_list|)
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_type
operator|=
name|B_PROCESS
expr_stmt|;
operator|(
name|void
operator|)
name|UnixToBuf
argument_list|(
literal|"pwd-output"
argument_list|,
name|NO
argument_list|,
literal|0
argument_list|,
name|YES
argument_list|,
literal|"/bin/pwd"
argument_list|,
literal|"pwd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
name|ret_val
operator|=
name|sprint
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|setCWD
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|PWD
operator|==
literal|0
condition|)
name|PWD
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|d
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
specifier|extern
name|char
modifier|*
name|ralloc
parameter_list|()
function_decl|;
name|PWD
operator|=
name|ralloc
argument_list|(
name|PWD
argument_list|,
name|strlen
argument_list|(
name|d
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|PWD
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getCWD
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|cwd
init|=
name|getenv
argument_list|(
literal|"CWD"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|JOB_CONTROL
specifier|extern
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
name|char
name|pathname
index|[
name|FILESIZE
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cwd
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|JOB_CONTROL
name|cwd
operator|=
name|getwd
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
else|#
directive|else
name|cwd
operator|=
name|getwd
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|setCWD
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prDIRS
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|s_mess
argument_list|(
literal|": %f "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DirSP
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|add_mess
argument_list|(
literal|"%s "
argument_list|,
name|pr_name
argument_list|(
name|DirStack
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prCWD
argument_list|()
end_macro

begin_block
block|{
name|s_mess
argument_list|(
literal|": %f => \"%s\""
argument_list|,
name|PWD
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Pushd
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|newdir
decl_stmt|,
name|dirbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|newdir
operator|=
name|ask_file
argument_list|(
name|NullStr
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
comment|/* Parses directories ... */
name|UpdModLine
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|newdir
operator|==
literal|0
condition|)
block|{
comment|/* Wants to swap top two entries */
name|char
modifier|*
name|old_top
decl_stmt|;
if|if
condition|(
name|DirSP
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"pushd: no other directory."
argument_list|)
expr_stmt|;
name|old_top
operator|=
name|PWD
expr_stmt|;
name|DirStack
index|[
name|DirSP
index|]
operator|=
name|DirStack
index|[
name|DirSP
operator|-
literal|1
index|]
expr_stmt|;
name|DirStack
index|[
name|DirSP
operator|-
literal|1
index|]
operator|=
name|old_top
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|PWD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chdir
argument_list|(
name|dirbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|s_mess
argument_list|(
literal|"pushd: cannot change into %s."
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DirSP
operator|+
literal|1
operator|>=
name|NDIRS
condition|)
name|complain
argument_list|(
literal|"pushd: full stack; max of %d pushes."
argument_list|,
name|NDIRS
argument_list|)
expr_stmt|;
name|DirSP
operator|++
expr_stmt|;
name|setCWD
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
block|}
name|prDIRS
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|Popd
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|DirSP
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"popd: directory stack is empty."
argument_list|)
expr_stmt|;
name|UpdModLine
operator|++
expr_stmt|;
name|free
argument_list|(
name|PWD
argument_list|)
expr_stmt|;
name|PWD
operator|=
literal|0
expr_stmt|;
name|DirSP
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|PWD
argument_list|)
expr_stmt|;
comment|/* If this doesn't work, we's in deep shit. */
name|prDIRS
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|private
name|char
modifier|*
name|dbackup
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|base
decl_stmt|,
decl|*
name|offset
decl_stmt|,
name|c
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|offset
operator|>
name|base
operator|&&
operator|*
operator|--
name|offset
operator|!=
name|c
condition|)
empty_stmt|;
return|return
name|offset
return|;
block|}
end_block

begin_macro
name|dfollow
argument_list|(
argument|file
argument_list|,
argument|into
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|into
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'/'
condition|)
block|{
comment|/* Absolute pathname */
name|strcpy
argument_list|(
name|into
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|file
operator|++
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|into
argument_list|,
name|PWD
argument_list|)
expr_stmt|;
name|dp
operator|=
name|into
operator|+
name|strlen
argument_list|(
name|into
argument_list|)
expr_stmt|;
name|sp
operator|=
name|file
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|file
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sp
operator|=
name|index
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* So it will get to the end of the loop */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|dp
operator|=
name|dbackup
argument_list|(
name|into
argument_list|,
name|dp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|into
condition|)
name|strcpy
argument_list|(
name|into
argument_list|,
literal|"/"
argument_list|)
operator|,
name|dp
operator|=
name|into
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|into
index|[
name|strlen
argument_list|(
name|into
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|into
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|into
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* stay at the end */
block|}
name|file
operator|=
name|sp
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
literal|0
condition|)
do|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|CHDIR
end_endif

begin_expr_stmt
name|get_hdir
argument_list|(
name|user
argument_list|,
name|buf
argument_list|)
specifier|register
name|char
operator|*
name|user
operator|,
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|fbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|pattern
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|int
name|u_len
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|u_len
operator|=
name|strlen
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
literal|"/etc/passwd"
argument_list|,
name|fbuf
argument_list|,
name|F_READ
argument_list|,
name|COMPLAIN
argument_list|,
name|QUIET
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pattern
argument_list|,
literal|"%s:[^:]*:[^:]*:[^:]*:[^:]*:\\([^:]*\\):"
argument_list|,
name|user
argument_list|)
expr_stmt|;
while|while
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
name|LBSIZE
argument_list|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|genbuf
argument_list|,
name|user
argument_list|,
name|u_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|LookingAt
argument_list|(
name|pattern
argument_list|,
name|genbuf
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|putmatch
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|FILESIZE
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[unknown user: %s]"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PathParse
argument_list|(
argument|name
argument_list|,
argument|intobuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|intobuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|localbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|intobuf
index|[
literal|0
index|]
operator|=
name|localbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
operator|*
name|name
operator|==
literal|'~'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|localbuf
argument_list|,
name|HomeDir
argument_list|)
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|uendp
init|=
name|index
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|,
name|unamebuf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|uendp
operator|==
literal|0
condition|)
name|uendp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|name
operator|+
literal|1
expr_stmt|;
name|null_ncpy
argument_list|(
name|unamebuf
argument_list|,
name|name
argument_list|,
name|uendp
operator|-
name|name
argument_list|)
expr_stmt|;
name|get_hdir
argument_list|(
name|unamebuf
argument_list|,
name|localbuf
argument_list|)
expr_stmt|;
name|name
operator|=
name|uendp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'\\'
condition|)
name|name
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|localbuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHDIR
name|dfollow
argument_list|(
name|localbuf
argument_list|,
name|intobuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|intobuf
argument_list|,
name|localbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|filemunge
argument_list|(
argument|newname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|newname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|newname
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|stat
argument_list|(
name|newname
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_ino
operator|!=
name|curbuf
operator|->
name|b_ino
operator|)
operator|&&
operator|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|newname
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|confirm
argument_list|(
literal|"\"%s\" already exists; overwrite it? "
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|WrtReg
argument_list|()
end_macro

begin_block
block|{
name|DoWriteReg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|AppReg
argument_list|()
end_macro

begin_block
block|{
name|DoWriteReg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|CreatMode
init|=
name|DFLT_MODE
decl_stmt|;
end_decl_stmt

begin_macro
name|DoWriteReg
argument_list|(
argument|app
argument_list|)
end_macro

begin_block
block|{
name|char
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|Mark
modifier|*
name|mp
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
comment|/* Won't get here if there isn't a Mark */
name|fname
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKUPFILES
if|if
condition|(
operator|!
name|app
condition|)
block|{
name|filemunge
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|BkupOnWrite
condition|)
name|file_backup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|app
condition|)
name|filemunge
argument_list|(
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
name|iobuff
argument_list|,
name|app
condition|?
name|F_APPEND
else|:
name|F_WRITE
argument_list|,
name|COMPLAIN
argument_list|,
operator|!
name|QUIET
argument_list|)
expr_stmt|;
name|putreg
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|m_line
argument_list|,
name|mp
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|OkayBadChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|WriteFile
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|fname
decl_stmt|,
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|fname
operator|=
name|ask_file
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
comment|/* Don't allow bad characters when creating new files. */
if|if
condition|(
operator|!
name|OkayBadChars
operator|&&
name|strcmp
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|static
name|char
modifier|*
name|badchars
init|=
literal|"!$^&*()~`{}\"'\\|<>? "
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|fnamebuf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|==
literal|'\177'
operator|||
name|index
argument_list|(
name|badchars
argument_list|,
name|c
argument_list|)
condition|)
name|complain
argument_list|(
literal|"'%p': bad character in filename."
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|chk_mtime
argument_list|(
name|fname
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
name|filemunge
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbuf
operator|->
name|b_type
operator|!=
name|B_IPROCESS
condition|)
name|curbuf
operator|->
name|b_type
operator|=
name|B_FILE
expr_stmt|;
comment|/* In case it wasn't before. */
name|setfname
argument_list|(
name|curbuf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|file_write
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unmodify
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|File
modifier|*
name|open_file
parameter_list|(
name|fname
parameter_list|,
name|buf
parameter_list|,
name|how
parameter_list|,
name|ifbad
parameter_list|,
name|loudness
parameter_list|)
specifier|register
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|how
decl_stmt|;
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|io_chars
operator|=
literal|0
expr_stmt|;
name|io_lines
operator|=
literal|0
expr_stmt|;
name|tellall
operator|=
name|loudness
expr_stmt|;
name|fp
operator|=
name|f_open
argument_list|(
name|fname
argument_list|,
name|how
argument_list|,
name|buf
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
block|{
name|message
argument_list|(
name|IOerr
argument_list|(
operator|(
name|how
operator|==
name|F_READ
operator|)
condition|?
literal|"open"
else|:
literal|"create"
argument_list|,
name|fname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifbad
operator|==
name|COMPLAIN
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|readonly
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|fname
argument_list|,
name|W_OK
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|readonly
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|loudness
operator|!=
name|QUIET
condition|)
name|f_mess
argument_list|(
literal|"\"%s\"%s"
argument_list|,
name|pr_name
argument_list|(
name|fname
argument_list|)
argument_list|,
name|readonly
condition|?
literal|" [Read only]"
else|:
name|NullStr
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the file has been modified since it was    last written.  If so, make sure they know what they're    doing.     I hate to use another stat(), but to use confirm we gotta    do this before we open the file. */
end_comment

begin_macro
name|chk_mtime
argument_list|(
argument|fname
argument_list|,
argument|how
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|,
modifier|*
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|Buffer
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|mesg
init|=
literal|"Shall I go ahead and %s anyway? "
decl_stmt|;
if|if
condition|(
operator|(
name|curbuf
operator|->
name|b_mtime
operator|!=
literal|0
operator|)
operator|&&
comment|/* if we care ... */
operator|(
name|b
operator|=
name|file_exists
argument_list|(
name|fname
argument_list|)
operator|)
operator|&&
comment|/* we already have this file */
operator|(
name|b
operator|==
name|curbuf
operator|)
operator|&&
comment|/* and it's the current buffer */
operator|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
comment|/* and we can stat it */
operator|(
name|stbuf
operator|.
name|st_mtime
operator|!=
name|b
operator|->
name|b_mtime
operator|)
condition|)
block|{
comment|/* and there's trouble. */
name|rbell
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
comment|/* Ring that bell! */
name|TOstart
argument_list|(
literal|"Warning"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"\"%s\" now saved on disk is not what you last"
argument_list|,
name|pr_name
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"visited or saved.  Probably someone else is editing"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"your file at the same time.  Type \"y\" if I should"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"%s anyway."
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|f_mess
argument_list|(
name|mesg
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
name|confirm
argument_list|(
name|mesg
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|file_write
argument_list|(
argument|fname
argument_list|,
argument|app
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|File
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|BACKUPFILES
if|if
condition|(
operator|!
name|app
operator|&&
name|BkupOnWrite
condition|)
name|file_backup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
name|iobuff
argument_list|,
name|app
condition|?
name|F_APPEND
else|:
name|F_WRITE
argument_list|,
name|COMPLAIN
argument_list|,
operator|!
name|QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|EndWNewline
condition|)
block|{
comment|/* Make sure file ends with a newLine */
name|Bufpos
name|save
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|ToLast
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
argument_list|(
name|curline
argument_list|)
condition|)
comment|/* Not a blank Line */
name|DoTimes
argument_list|(
name|LineInsert
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make it blank */
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
block|}
name|putreg
argument_list|(
name|fp
argument_list|,
name|curbuf
operator|->
name|b_first
argument_list|,
literal|0
argument_list|,
name|curbuf
operator|->
name|b_last
argument_list|,
name|length
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|set_ino
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ReadFile
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|fname
decl_stmt|,
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|fname
operator|=
name|ask_file
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
name|chk_mtime
argument_list|(
name|fname
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsModified
argument_list|(
name|curbuf
argument_list|)
condition|)
block|{
name|char
modifier|*
name|y_or_n
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|y_or_n
operator|=
name|ask
argument_list|(
name|NullStr
argument_list|,
literal|"Shall I make your changes to \"%s\" permanent? "
argument_list|,
name|curbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|c
operator|=
name|Upper
argument_list|(
operator|*
name|y_or_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'Y'
operator|||
name|c
operator|==
literal|'N'
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'Y'
condition|)
name|SaveFile
argument_list|()
expr_stmt|;
block|}
name|unmodify
argument_list|()
expr_stmt|;
name|initlist
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|setfname
argument_list|(
name|curbuf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|read_file
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|InsFile
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|fname
decl_stmt|,
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|fname
operator|=
name|ask_file
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
name|read_file
argument_list|(
name|fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|"temp.h"
end_include

begin_decl_stmt
name|int
name|DOLsave
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do Lsave flag.  If lines aren't being save 			   when you think they should have been, this 			   flag is probably not being set, or is being 			   cleared before lsave() was called. */
end_comment

begin_decl_stmt
name|int
name|nleft
decl_stmt|,
comment|/* Number of good characters left in current block */
name|tmpfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|disk_line
name|tline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to end of tmp file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tfname
decl_stmt|;
end_decl_stmt

begin_macro
name|tmpinit
argument_list|()
end_macro

begin_block
block|{
name|tfname
operator|=
name|mktemp
argument_list|(
name|TMPFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|tfname
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
name|open
argument_list|(
name|tfname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfd
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s?\n"
argument_list|,
name|tfname
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|block_init
argument_list|()
expr_stmt|;
name|tline
operator|=
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|tmpclose
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Get a line at `tl' in the tmp file into `buf' which should be LBSIZE    long. */
end_comment

begin_decl_stmt
name|int
name|Jr_Len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of Just Read Line. */
end_comment

begin_function
name|char
modifier|*
name|getline
parameter_list|(
name|tl
parameter_list|,
name|buf
parameter_list|)
name|disk_line
name|tl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|READ
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|tl
operator|&=
operator|~
name|OFFMSK
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|bp
operator|++
condition|)
block|{
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
comment|/* += INCRMT moves tl to the next block in 			   the tmp file. */
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|INCRMT
argument_list|,
name|READ
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
name|Jr_Len
operator|=
operator|(
name|lp
operator|-
name|buf
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Put `buf' and return the disk address */
end_comment

begin_decl_stmt
name|int
name|nretries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|disk_line
name|putline
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
name|disk_line
name|tl
decl_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
name|tl
operator|=
name|tline
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|tl
operator|&=
operator|~
name|OFFMSK
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|=
operator|*
name|lp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
name|tline
operator|=
operator|(
name|tl
operator|+=
name|INCRMT
operator|)
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
comment|/* start over ... */
name|nretries
operator|++
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
name|tl
operator|=
name|tline
expr_stmt|;
name|tline
operator|+=
operator|(
operator|(
operator|(
name|lp
operator|-
name|buf
operator|)
operator|+
name|BNDRY
operator|-
literal|1
operator|)
operator|>>
name|SHFT
operator|)
operator|&
literal|077776
expr_stmt|;
return|return
name|tl
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|block
block|{
name|short
name|b_dirty
decl_stmt|,
name|b_bno
decl_stmt|;
name|char
name|b_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|block
modifier|*
name|b_LRUnext
decl_stmt|,
modifier|*
name|b_LRUprev
decl_stmt|,
modifier|*
name|b_HASHnext
decl_stmt|;
block|}
name|Block
typedef|;
end_typedef

begin_define
define|#
directive|define
name|HASHSIZE
value|7
end_define

begin_comment
comment|/* Primes work best (so I'm told) */
end_comment

begin_define
define|#
directive|define
name|B_HASH
parameter_list|(
name|bno
parameter_list|)
value|(bno % HASHSIZE)
end_define

begin_decl_stmt
name|private
name|Block
name|b_cache
index|[
name|NBUF
index|]
decl_stmt|,
modifier|*
name|bht
index|[
name|HASHSIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|,
comment|/* Block hash table */
modifier|*
name|f_block
init|=
literal|0
decl_stmt|,
modifier|*
name|l_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|max_bno
init|=
operator|-
literal|1
decl_stmt|,
name|NBlocks
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|block_init
parameter_list|()
block|{
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|,
comment|/* Block pointer */
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* Hash pointer */
specifier|register
name|short
name|bno
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|b_cache
operator|,
name|bno
operator|=
name|NBUF
init|;
operator|--
name|bno
operator|>=
literal|0
condition|;
name|bp
operator|++
control|)
block|{
name|NBlocks
operator|++
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bno
operator|=
name|bno
expr_stmt|;
if|if
condition|(
name|l_block
operator|==
literal|0
condition|)
name|l_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUprev
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_LRUnext
operator|=
name|f_block
expr_stmt|;
if|if
condition|(
name|f_block
operator|!=
literal|0
condition|)
name|f_block
operator|->
name|b_LRUprev
operator|=
name|bp
expr_stmt|;
name|f_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_HASHnext
operator|=
operator|*
operator|(
name|hp
operator|=
operator|&
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
operator|)
expr_stmt|;
operator|*
name|hp
operator|=
name|bp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|Block
modifier|*
name|lookup
parameter_list|(
name|bno
parameter_list|)
specifier|register
name|short
name|bno
decl_stmt|;
block|{
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_HASHnext
control|)
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|==
name|bno
condition|)
break|break;
return|return
name|bp
return|;
block|}
end_function

begin_function
name|private
name|LRUunlink
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Block
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|->
name|b_LRUprev
operator|==
literal|0
condition|)
name|f_block
operator|=
name|b
operator|->
name|b_LRUnext
expr_stmt|;
else|else
name|b
operator|->
name|b_LRUprev
operator|->
name|b_LRUnext
operator|=
name|b
operator|->
name|b_LRUnext
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|b_LRUnext
operator|==
literal|0
condition|)
name|l_block
operator|=
name|b
operator|->
name|b_LRUprev
expr_stmt|;
else|else
name|b
operator|->
name|b_LRUnext
operator|->
name|b_LRUprev
operator|=
name|b
operator|->
name|b_LRUprev
expr_stmt|;
block|}
end_function

begin_function
name|private
name|Block
modifier|*
name|b_unlink
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|Block
modifier|*
name|hp
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|LRUunlink
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Now that we have the block, we remove it from its position 	   in the hash table, so we can THEN put it somewhere else with 	   it's new block assignment. */
for|for
control|(
name|hp
operator|=
name|bht
index|[
name|B_HASH
argument_list|(
name|bp
operator|->
name|b_bno
argument_list|)
index|]
init|;
name|hp
operator|!=
literal|0
condition|;
name|prev
operator|=
name|hp
operator|,
name|hp
operator|=
name|hp
operator|->
name|b_HASHnext
control|)
if|if
condition|(
name|hp
operator|==
name|bp
condition|)
break|break;
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\rBlock %d missing!"
argument_list|,
name|bp
operator|->
name|b_bno
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|b_HASHnext
operator|=
name|hp
operator|->
name|b_HASHnext
expr_stmt|;
else|else
name|bht
index|[
name|B_HASH
argument_list|(
name|bp
operator|->
name|b_bno
argument_list|)
index|]
operator|=
name|hp
operator|->
name|b_HASHnext
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dirty
condition|)
block|{
comment|/* Do, now, the delayed write */
name|blkio
argument_list|(
name|bp
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* Get a block which contains at least part of the line with the address    atl.  Returns a pointer to the block and sets the global variable    nleft (number of good characters left in the buffer). */
end_comment

begin_function
name|char
modifier|*
name|getblock
parameter_list|(
name|atl
parameter_list|,
name|iof
parameter_list|)
name|disk_line
name|atl
decl_stmt|;
block|{
specifier|register
name|int
name|bno
decl_stmt|,
name|off
decl_stmt|;
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|;
specifier|static
name|Block
modifier|*
name|lastb
init|=
literal|0
decl_stmt|;
name|bno
operator|=
operator|(
name|atl
operator|>>
name|OFFBTS
operator|)
operator|&
name|BLKMSK
expr_stmt|;
name|off
operator|=
operator|(
name|atl
operator|<<
name|SHFT
operator|)
operator|&
name|LBTMSK
expr_stmt|;
if|if
condition|(
name|bno
operator|>=
name|NMBLKS
condition|)
name|error
argument_list|(
literal|"Tmp file too large.  Get help!"
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|BUFSIZ
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|lastb
operator|!=
literal|0
operator|&&
name|lastb
operator|->
name|b_bno
operator|==
name|bno
condition|)
return|return
name|lastb
operator|->
name|b_buf
operator|+
name|off
return|;
comment|/* The requested block already lives in memory, so we move 	   it to the end of the LRU list (making it Most Recently Used) 	   and then return a pointer to it. */
if|if
condition|(
name|bp
operator|=
name|lookup
argument_list|(
name|bno
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|l_block
condition|)
block|{
name|LRUunlink
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_block
operator|==
literal|0
condition|)
name|f_block
operator|=
name|l_block
operator|=
name|bp
expr_stmt|;
else|else
name|l_block
operator|->
name|b_LRUnext
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUprev
operator|=
name|l_block
expr_stmt|;
name|l_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUnext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|>
name|max_bno
condition|)
name|max_bno
operator|=
name|bp
operator|->
name|b_bno
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator||=
name|iof
expr_stmt|;
name|lastb
operator|=
name|bp
expr_stmt|;
return|return
name|bp
operator|->
name|b_buf
operator|+
name|off
return|;
block|}
comment|/* The block we want doesn't reside in memory so we take the 	   least recently used clean block (if there is one) and use 	   it.  */
name|bp
operator|=
name|f_block
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dirty
condition|)
comment|/* The best block is dirty ... */
name|SyncTmp
argument_list|()
expr_stmt|;
name|bp
operator|=
name|b_unlink
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_block
operator|==
literal|0
condition|)
name|l_block
operator|=
name|f_block
operator|=
name|bp
expr_stmt|;
else|else
name|l_block
operator|->
name|b_LRUnext
operator|=
name|bp
expr_stmt|;
comment|/* Place it at the end ... */
name|bp
operator|->
name|b_LRUprev
operator|=
name|l_block
expr_stmt|;
name|l_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUnext
operator|=
literal|0
expr_stmt|;
comment|/* so it's Most Recently Used */
name|bp
operator|->
name|b_dirty
operator|=
name|iof
expr_stmt|;
name|bp
operator|->
name|b_bno
operator|=
name|bno
expr_stmt|;
name|bp
operator|->
name|b_HASHnext
operator|=
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
expr_stmt|;
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
operator|=
name|bp
expr_stmt|;
comment|/* Get the current contents of the block UNLESS this is a new 	   block that's never been looked at before, i.e., it's past 	   the end of the tmp file. */
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|<=
name|max_bno
condition|)
name|blkio
argument_list|(
name|bp
argument_list|,
name|read
argument_list|)
expr_stmt|;
else|else
name|max_bno
operator|=
name|bno
expr_stmt|;
name|lastb
operator|=
name|bp
expr_stmt|;
return|return
name|bp
operator|->
name|b_buf
operator|+
name|off
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|lbptr
parameter_list|(
name|line
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
block|{
return|return
name|getblock
argument_list|(
name|line
operator|->
name|l_dline
argument_list|,
name|READ
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|private
name|blkio
argument_list|(
name|b
argument_list|,
name|iofcn
argument_list|)
decl|register
name|Block
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|register
name|int
function_decl|(
modifier|*
name|iofcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|tmpfd
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|b
operator|->
name|b_bno
argument_list|)
operator|*
name|BUFSIZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|iofcn
call|)
argument_list|(
name|tmpfd
argument_list|,
name|b
operator|->
name|b_buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|!=
name|BUFSIZ
condition|)
name|error
argument_list|(
literal|"Tmp file %s error."
argument_list|,
operator|(
name|iofcn
operator|==
name|read
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SyncTmp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Block
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|f_block
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_LRUnext
control|)
if|if
condition|(
name|b
operator|->
name|b_dirty
condition|)
block|{
name|blkio
argument_list|(
name|b
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* save the current contents of linebuf, if it has changed */
end_comment

begin_macro
name|lsave
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|curbuf
operator|==
literal|0
operator|||
operator|!
name|DOLsave
condition|)
comment|/* Nothing modified recently */
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|lbptr
argument_list|(
name|curline
argument_list|)
argument_list|,
name|linebuf
argument_list|)
operator|!=
literal|0
condition|)
name|SavLine
argument_list|(
name|curline
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
comment|/* Put linebuf on the disk. */
name|DOLsave
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BACKUPFILES
end_ifdef

begin_macro
name|file_backup
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|char
name|tmp1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmp2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tmp1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|rindex
argument_list|(
name|tmp1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|tmp2
argument_list|,
literal|"#%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|s
operator|++
operator|=
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|tmp2
argument_list|,
literal|"%s/#%s"
argument_list|,
name|tmp1
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|fd2
operator|=
name|creat
argument_list|(
name|tmp2
argument_list|,
name|CreatMode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd1
argument_list|,
name|tmp1
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp1
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fd2
argument_list|,
name|tmp1
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

