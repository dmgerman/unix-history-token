begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_comment
comment|/* Recovers JOVE files after a system/editor crash.    Usage: recover [-d directory] [-syscrash]    The -syscrash option is specified in /etc/rc and what it does it    move all the jove tmp files from TMP_DIR to REC_DIR.     The -d option lets you specify the directory to search for tmp files when    the default isn't the right one.     Look in Makefile to change the default directories. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Do stdio first so it doesn't override OUR 			   definitions. */
end_comment

begin_undef
undef|#
directive|undef
name|EOF
end_undef

begin_undef
undef|#
directive|undef
name|BUFSIZ
end_undef

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"temp.h"
end_include

begin_include
include|#
directive|include
file|"rec.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|L_SET
end_ifndef

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_define
define|#
directive|define
name|L_INCR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|blk_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ptrs_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|data_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rec_head
name|Header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|datafile
index|[
literal|40
index|]
decl_stmt|,
name|pntrfile
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Nchars
decl_stmt|,
name|Nlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tty
index|[]
init|=
literal|"/dev/tty"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|UserID
decl_stmt|,
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|file_pair
block|{
name|char
modifier|*
name|file_data
decl_stmt|,
modifier|*
name|file_rec
decl_stmt|;
define|#
directive|define
name|INSPECTED
value|01
name|int
name|file_flags
decl_stmt|;
name|struct
name|file_pair
modifier|*
name|file_next
decl_stmt|;
block|}
modifier|*
name|First
init|=
literal|0
struct|,
modifier|*
name|Last
init|=
literal|0
struct|;
end_struct

begin_decl_stmt
name|struct
name|rec_entry
modifier|*
name|buflist
index|[
literal|100
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|d_fd
decl_stmt|;
comment|/* File descriptor for this directory */
block|}
name|DIR
typedef|;
end_typedef

begin_function
name|DIR
modifier|*
name|opendir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dp
init|=
operator|(
name|DIR
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|d_fd
operator|=
name|open
argument_list|(
name|dir
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
return|return
name|dp
return|;
block|}
end_function

begin_macro
name|closedir
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|DIR
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|dp
operator|->
name|d_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|direct
modifier|*
name|readdir
parameter_list|(
name|dp
parameter_list|)
name|DIR
modifier|*
name|dp
decl_stmt|;
block|{
specifier|static
name|struct
name|direct
name|dir
decl_stmt|;
do|do
if|if
condition|(
name|read
argument_list|(
name|dp
operator|->
name|d_fd
argument_list|,
operator|&
name|dir
argument_list|,
sizeof|sizeof
name|dir
argument_list|)
operator|!=
sizeof|sizeof
name|dir
condition|)
return|return
name|NULL
return|;
do|while
condition|(
name|dir
operator|.
name|d_ino
operator|==
literal|0
condition|)
do|;
return|return
operator|&
name|dir
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|BSD4_2
end_endif

begin_comment
comment|/* Get a line at `tl' in the tmp file into `buf' which should be LBSIZE    long. */
end_comment

begin_function
name|char
modifier|*
name|getline
parameter_list|(
name|tl
parameter_list|,
name|buf
parameter_list|)
name|disk_line
name|tl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|tl
operator|&=
operator|~
name|OFFMSK
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|bp
operator|++
condition|)
block|{
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
comment|/* += INCRMT moves tl to the next block in 			   the tmp file. */
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|INCRMT
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|getblock
parameter_list|(
name|atl
parameter_list|)
name|disk_line
name|atl
decl_stmt|;
block|{
name|int
name|bno
decl_stmt|,
name|off
decl_stmt|;
specifier|static
name|int
name|curblock
init|=
operator|-
literal|1
decl_stmt|;
name|bno
operator|=
operator|(
name|atl
operator|>>
name|OFFBTS
operator|)
operator|&
name|BLKMSK
expr_stmt|;
name|off
operator|=
operator|(
name|atl
operator|<<
name|SHFT
operator|)
operator|&
name|LBTMSK
expr_stmt|;
name|nleft
operator|=
name|BUFSIZ
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|bno
operator|!=
name|curblock
condition|)
block|{
name|lseek
argument_list|(
name|data_fd
argument_list|,
operator|(
name|long
operator|)
name|bno
operator|*
name|BUFSIZ
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|data_fd
argument_list|,
name|blk_buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|curblock
operator|=
name|bno
expr_stmt|;
block|}
return|return
name|blk_buf
operator|+
name|off
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|copystr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Scandir returns the number of entries or -1 if the directory cannoot    be opened or malloc fails. */
end_comment

begin_macro
name|scandir
argument_list|(
argument|dir
argument_list|,
argument|nmptr
argument_list|,
argument|qualify
argument_list|,
argument|sorter
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|direct
modifier|*
modifier|*
modifier|*
name|nmptr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|qualify
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|direct
modifier|*
function_decl|(
modifier|*
name|sorter
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|direct
modifier|*
name|entry
decl_stmt|,
modifier|*
modifier|*
name|ourarray
decl_stmt|;
name|int
name|nalloc
init|=
literal|10
decl_stmt|,
name|nentries
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|ourarray
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direct
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qualify
operator|!=
literal|0
operator|&&
call|(
modifier|*
name|qualify
call|)
argument_list|(
name|entry
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nentries
operator|==
name|nalloc
condition|)
block|{
name|ourarray
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|ourarray
argument_list|,
operator|(
name|nalloc
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourarray
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|ourarray
index|[
name|nentries
index|]
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|entry
argument_list|)
expr_stmt|;
operator|*
name|ourarray
index|[
name|nentries
index|]
operator|=
operator|*
name|entry
expr_stmt|;
name|nentries
operator|++
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentries
operator|!=
name|nalloc
condition|)
name|ourarray
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|ourarray
argument_list|,
operator|(
name|nentries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorter
operator|!=
literal|0
condition|)
name|qsort
argument_list|(
name|ourarray
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
operator|*
operator|*
argument_list|)
argument_list|,
name|sorter
argument_list|)
expr_stmt|;
operator|*
name|nmptr
operator|=
name|ourarray
expr_stmt|;
return|return
name|nentries
return|;
block|}
end_block

begin_macro
name|alphacomp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|direct
modifier|*
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|d_name
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|d_name
argument_list|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|CurDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan the DIRNAME directory for jove tmp files, and make a linked list    out of them. */
end_comment

begin_macro
name|get_files
argument_list|(
argument|dirname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dirname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|add_name
parameter_list|()
function_decl|;
name|struct
name|direct
modifier|*
modifier|*
name|nmptr
decl_stmt|;
name|CurDir
operator|=
name|dirname
expr_stmt|;
name|scandir
argument_list|(
name|dirname
argument_list|,
operator|&
name|nmptr
argument_list|,
name|add_name
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|add_name
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dfile
index|[
literal|128
index|]
decl_stmt|,
name|rfile
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
name|struct
name|rec_head
name|header
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|REC_BASE
argument_list|,
name|strlen
argument_list|(
name|REC_BASE
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we get here, we found a "recover" tmp file, so now 	   we look for the corresponding "data" tmp file.  First, 	   though, we check to see whether there is anything in 	   the "recover" file.  If it's 0 length, there's no point 	   in saving its name. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rfile
argument_list|,
literal|"%s/%s"
argument_list|,
name|CurDir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dfile
argument_list|,
literal|"%s/jove%s"
argument_list|,
name|CurDir
argument_list|,
name|dp
operator|->
name|d_name
operator|+
name|strlen
argument_list|(
name|REC_BASE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|rfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
name|header
argument_list|)
operator|!=
sizeof|sizeof
name|header
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|access
argument_list|(
name|dfile
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: can't find the data file for %s/%s\n"
argument_list|,
name|TMP_DIR
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"so deleting...\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|dfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we get here, we've found both files, so we put them 	   in the list. */
name|fp
operator|=
operator|(
expr|struct
name|file_pair
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot malloc for file_pair.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|file_data
operator|=
name|copystr
argument_list|(
name|dfile
argument_list|)
expr_stmt|;
name|fp
operator|->
name|file_rec
operator|=
name|copystr
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
name|fp
operator|->
name|file_flags
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|file_next
operator|=
name|First
expr_stmt|;
name|First
operator|=
name|fp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|options
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"Options are:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	?		list options.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	get		get a buffer to a file.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	list		list known buffers.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	print		print a buffer to terminal.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	quit		quit and delete jove tmp files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	restore		restore all buffers.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Returns a legitimate buffer # */
end_comment

begin_function
name|struct
name|rec_entry
modifier|*
modifier|*
name|getsrc
parameter_list|()
block|{
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|int
name|number
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tellme
argument_list|(
literal|"Which buffer ('?' for list)? "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|list
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|number
operator|=
name|atoi
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|number
operator|<=
name|Header
operator|.
name|Nbuffers
condition|)
return|return
operator|&
name|buflist
index|[
name|number
index|]
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|buflist
index|[
name|i
index|]
return|;
name|printf
argument_list|(
literal|"%s: unknown buffer.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a destination file name. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getdest
parameter_list|()
block|{
specifier|static
name|char
name|filebuf
index|[
literal|256
index|]
decl_stmt|;
name|tellme
argument_list|(
literal|"Output file: "
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|filebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
name|filebuf
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_function
name|char
modifier|*
name|readword
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
while|while
condition|(
name|index
argument_list|(
literal|" \t\n"
argument_list|,
name|c
operator|=
name|getchar
argument_list|()
argument_list|)
condition|)
empty_stmt|;
do|do
block|{
if|if
condition|(
name|index
argument_list|(
literal|" \t\n"
argument_list|,
name|c
argument_list|)
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
do|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_macro
name|tellme
argument_list|(
argument|quest
argument_list|,
argument|answer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|quest
decl_stmt|,
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|stdin
operator|->
name|_cnt
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|quest
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|readword
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print the specified file to strandard output. */
end_comment

begin_decl_stmt
name|jmp_buf
name|int_env
decl_stmt|;
end_decl_stmt

begin_macro
name|catch
argument_list|()
end_macro

begin_block
block|{
name|longjmp
argument_list|(
name|int_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|restore
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tofile
index|[
literal|100
index|]
decl_stmt|,
name|answer
index|[
literal|30
index|]
decl_stmt|;
name|int
name|nrecovered
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tofile
argument_list|,
literal|"#%s"
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|)
expr_stmt|;
name|tryagain
label|:
name|printf
argument_list|(
literal|"Restoring %s to %s, okay?"
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|,
name|tofile
argument_list|)
expr_stmt|;
name|tellme
argument_list|(
literal|" "
argument_list|,
name|answer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|answer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'n'
case|:
continue|continue;
default|default:
name|tellme
argument_list|(
literal|"What file should I use instead? "
argument_list|,
name|tofile
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|get
argument_list|(
operator|&
name|buflist
index|[
name|i
index|]
argument_list|,
name|tofile
argument_list|)
expr_stmt|;
name|nrecovered
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Recovered %d buffers.\n"
argument_list|,
name|nrecovered
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|get
argument_list|(
argument|src
argument_list|,
argument|dest
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rec_entry
modifier|*
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|outfile
decl_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
operator|||
name|dest
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|int_env
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|outfile
operator|=
name|fopen
argument_list|(
name|dest
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"recover: cannot create %s.\n"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return;
block|}
name|seekto
argument_list|(
name|src
operator|-
name|buflist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|tty
condition|)
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dump_file
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\nAborted!\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|tty
condition|)
name|printf
argument_list|(
literal|" %ld lines, %ld characters.\n"
argument_list|,
name|Nlines
argument_list|,
name|Nchars
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
modifier|*
name|scanvec
parameter_list|(
name|args
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|args
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|args
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|args
return|;
name|args
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|read_rec
argument_list|(
argument|recptr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rec_entry
modifier|*
name|recptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recptr
argument_list|,
sizeof|sizeof
expr|*
name|recptr
argument_list|,
literal|1
argument_list|,
name|ptrs_fp
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot read record.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|seekto
argument_list|(
argument|which
argument_list|)
end_macro

begin_block
block|{
name|struct
name|rec_entry
name|rec
decl_stmt|;
name|fseek
argument_list|(
name|ptrs_fp
argument_list|,
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
name|Header
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|which
operator|--
operator|>
literal|1
condition|)
block|{
name|read_rec
argument_list|(
operator|&
name|rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|ptrs_fp
argument_list|,
operator|(
name|long
operator|)
name|rec
operator|.
name|r_nlines
operator|*
sizeof|sizeof
argument_list|(
name|disk_line
argument_list|)
argument_list|,
name|L_INCR
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"recover: improper fseek!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|makblist
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
block|{
name|seekto
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflist
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|buflist
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|rec_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rec_entry
argument_list|)
argument_list|)
expr_stmt|;
name|read_rec
argument_list|(
name|buflist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buflist
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buflist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buflist
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
name|disk_line
name|getaddr
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
sizeof|sizeof
argument_list|(
name|disk_line
argument_list|)
decl_stmt|;
name|disk_line
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_macro
name|dump_file
argument_list|(
argument|out
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rec_entry
name|record
decl_stmt|;
specifier|register
name|int
name|nlines
decl_stmt|;
specifier|register
name|disk_line
name|daddr
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|read_rec
argument_list|(
operator|&
name|record
argument_list|)
expr_stmt|;
name|nlines
operator|=
name|record
operator|.
name|r_nlines
expr_stmt|;
name|Nchars
operator|=
name|Nlines
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
operator|--
name|nlines
operator|>=
literal|0
condition|)
block|{
name|daddr
operator|=
name|getaddr
argument_list|(
name|ptrs_fp
argument_list|)
expr_stmt|;
name|getline
argument_list|(
name|daddr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Nlines
operator|++
expr_stmt|;
name|Nchars
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* List all the buffers. */
end_comment

begin_macro
name|list
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d) buffer %s  \"%s\" (%d lines)\n"
argument_list|,
name|i
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_fname
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_nlines
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|doit
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|answer
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|datafile
init|=
name|fp
operator|->
name|file_data
decl_stmt|,
modifier|*
name|pntrfile
init|=
name|fp
operator|->
name|file_rec
decl_stmt|;
name|ptrs_fp
operator|=
name|fopen
argument_list|(
name|pntrfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrs_fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot read rec file (%s).\n"
argument_list|,
name|pntrfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Header
argument_list|,
sizeof|sizeof
name|Header
argument_list|,
literal|1
argument_list|,
name|ptrs_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Header
operator|.
name|Uid
operator|!=
name|UserID
condition|)
return|return
literal|0
return|;
comment|/* Don't ask about JOVE's that are still running ... */
ifdef|#
directive|ifdef
name|KILL0
if|if
condition|(
name|kill
argument_list|(
name|Header
operator|.
name|Pid
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|LSRHS
if|if
condition|(
name|pexist
argument_list|(
name|Header
operator|.
name|Pid
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
endif|LSRHS
endif|#
directive|endif
endif|KILL0
if|if
condition|(
name|Header
operator|.
name|Nbuffers
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"There are no modified buffers in %s; should I delete the tmp file?"
argument_list|,
name|pntrfile
argument_list|)
expr_stmt|;
name|ask_del
argument_list|(
literal|" "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|Header
operator|.
name|Nbuffers
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: %s doesn't look like a jove file.\n"
argument_list|,
name|pntrfile
argument_list|)
expr_stmt|;
name|ask_del
argument_list|(
literal|"Should I delete it? "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* We'll, we sort of found something. */
block|}
name|printf
argument_list|(
literal|"Found %d buffer%s last updated: %s"
argument_list|,
name|Header
operator|.
name|Nbuffers
argument_list|,
name|Header
operator|.
name|Nbuffers
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|ctime
argument_list|(
operator|&
name|Header
operator|.
name|UpdTime
argument_list|)
argument_list|)
expr_stmt|;
name|data_fd
operator|=
name|open
argument_list|(
name|datafile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: but I can't read the data file (%s).\n"
argument_list|,
name|datafile
argument_list|)
expr_stmt|;
name|ask_del
argument_list|(
literal|"Should I delete the tmp files? "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|makblist
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tellme
argument_list|(
literal|"(Type '?' for options): "
argument_list|,
name|answer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|answer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
continue|continue;
case|case
literal|'?'
case|:
name|options
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|get
argument_list|(
name|getsrc
argument_list|()
argument_list|,
name|tty
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|ask_del
argument_list|(
literal|"Shall I delete the tmp files? "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'g'
case|:
block|{
comment|/* So it asks for src first. */
name|char
modifier|*
name|dest
decl_stmt|;
name|struct
name|rec_entry
modifier|*
modifier|*
name|src
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|=
name|getsrc
argument_list|()
operator|)
operator|==
literal|0
condition|)
break|break;
name|dest
operator|=
name|getdest
argument_list|()
expr_stmt|;
name|get
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'r'
case|:
name|restore
argument_list|()
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"I don't know how to \"%s\"!\n"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_macro
name|ask_del
argument_list|(
argument|prompt
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|yorn
index|[
literal|20
index|]
decl_stmt|;
name|tellme
argument_list|(
name|prompt
argument_list|,
name|yorn
argument_list|)
expr_stmt|;
if|if
condition|(
name|yorn
index|[
literal|0
index|]
operator|==
literal|'y'
condition|)
name|del_files
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|del_files
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fp
operator|->
name|file_data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fp
operator|->
name|file_rec
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|savetmps
argument_list|()
end_macro

begin_block
block|{
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
name|int
name|status
decl_stmt|,
name|pid
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TMP_DIR
argument_list|,
name|REC_DIR
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Files are moved to the same place. */
name|get_files
argument_list|(
name|TMP_DIR
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|First
init|;
name|fp
operator|!=
literal|0
condition|;
name|fp
operator|=
name|fp
operator|->
name|file_next
control|)
block|{
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: can't fork\n!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|execl
argument_list|(
literal|"/bin/cp"
argument_list|,
literal|"cp"
argument_list|,
name|fp
operator|->
name|file_data
argument_list|,
name|fp
operator|->
name|file_rec
argument_list|,
name|REC_DIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot execl /bin/cp.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: non-zero status (%d) returned from copy.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|lookup
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
name|struct
name|rec_head
name|header
decl_stmt|;
name|char
name|yorn
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nfound
init|=
literal|0
decl_stmt|,
name|this_one
decl_stmt|;
name|get_files
argument_list|(
name|dir
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|First
init|;
name|fp
operator|!=
literal|0
condition|;
name|fp
operator|=
name|fp
operator|->
name|file_next
control|)
block|{
name|nfound
operator|+=
name|doit
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrs_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ptrs_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_fd
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|data_fd
argument_list|)
expr_stmt|;
block|}
return|return
name|nfound
return|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|nfound
decl_stmt|;
name|char
modifier|*
modifier|*
name|argvp
decl_stmt|;
name|UserID
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-help"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"recover: usage: recover [-d directory] [-syscrash]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use \"recover\" after JOVE has died for some\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unknown reason.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use \"recover -syscrash\" when the system is in the process\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"of rebooting.  This is done automatically at reboot time\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"and so most of you don't have to worry about that.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use \"recover -d directory\" when the tmp files are store\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"in DIRECTORY instead of the default one (%s).\n"
argument_list|,
name|TMP_DIR
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-v"
argument_list|)
condition|)
name|Verbose
operator|++
expr_stmt|;
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-syscrash"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Recovering jove files ... "
argument_list|)
expr_stmt|;
name|savetmps
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argvp
operator|=
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-uid"
argument_list|)
condition|)
name|UserID
operator|=
name|atoi
argument_list|(
name|argvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvp
operator|=
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-d"
argument_list|)
condition|)
name|nfound
operator|=
name|lookup
argument_list|(
name|argvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|nfound
operator|=
name|lookup
argument_list|(
name|REC_DIR
argument_list|)
operator|)
operator|||
operator|(
name|nfound
operator|=
name|lookup
argument_list|(
name|TMP_DIR
argument_list|)
operator|)
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"There's nothing to recover.\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

