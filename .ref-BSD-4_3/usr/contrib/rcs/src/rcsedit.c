begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS stream editor  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: rcsedit.c,v 3.8 86/05/15 02:15:43 lepreau Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************************************************************************  *                       edits the input file according to a  *                       script from stdin, generated by diff -n  *                       performs keyword expansion  **********************************************************************************  *  * Copyright (C) 1982 by Walter F. Tichy  *                       Purdue University  *                       Computer Science Department  *                       West Lafayette, IN 47907  *  * All rights reserved. No part of this software may be sold or distributed  * in any form or by any means without the prior written permission of the  * author.  * Report problems and direct all inquiries to Tichy@purdue (ARPA net).  */
end_comment

begin_comment
comment|/* $Log:	rcsedit.c,v $  * Revision 3.8  86/05/15  02:15:43  lepreau  * Use "Locked" instead of state in $Head expansion if locked.  *   * Revision 3.7  83/05/12  13:04:39  wft  * *** empty log message ***  *   * Revision 3.7  83/05/12  13:04:39  wft  * Added retry to expandline to resume after failed match which ended in $.  * Fixed truncation problem for $19chars followed by@@.  * Log no longer expands full path of RCS file.  *   * Revision 3.5  82/12/04  13:20:56  wft  * Added expansion of keyword Locker.  *   * Revision 3.4  82/12/03  12:26:54  wft  * Added line number correction in case editing does not start at the  * beginning of the file.  * Changed keyword expansion to always print a space before closing KDELIM;  * Expansion for Header shortened.  *  * Revision 3.3  82/11/14  14:49:30  wft  * removed Suffix from keyword expansion. Replaced fclose with ffclose.  * keyreplace() gets log message from delta, not from curlogmsg.  * fixed expression overflow in while(c=putc(GETC....  * checked nil printing.  *  * Revision 3.2  82/10/18  21:13:39  wft  * I added checks for write errors during the co process, and renamed  * expandstring() to xpandstring().  *  * Revision 3.1  82/10/13  15:52:55  wft  * changed type of result of getc() from char to int.  * made keyword expansion loop in expandline() portable to machines  * without sign-extension.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktempfile
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|,
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfullRCSname
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|RCSfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fcopy
decl_stmt|,
modifier|*
name|fedit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result and edit file descriptors                */
end_comment

begin_decl_stmt
name|char
modifier|*
name|resultfile
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file name                                */
end_comment

begin_decl_stmt
name|char
modifier|*
name|editfile
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit   file name                                */
end_comment

begin_decl_stmt
name|int
name|editline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*line counter in fedit; starts with 1, is always #lines+1   */
end_comment

begin_decl_stmt
name|int
name|linecorr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*contains #adds - #deletes in each edit run.                */
end_comment

begin_comment
comment|/*used to correct editline in case file is not rewound after */
end_comment

begin_comment
comment|/* applying one delta                                        */
end_comment

begin_macro
name|initeditfiles
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Initializes resultfile and editfile with temporary filenames  * in directory dir. Opens resultfile for reading and writing, with fcopy  * as file descriptor. fedit is set to nil.  */
end_comment

begin_block
block|{
name|resultfile
operator|=
name|mktempfile
argument_list|(
name|dir
argument_list|,
name|TMPFILE1
argument_list|)
expr_stmt|;
name|editfile
operator|=
name|mktempfile
argument_list|(
name|dir
argument_list|,
name|TMPFILE2
argument_list|)
expr_stmt|;
name|fedit
operator|=
name|nil
expr_stmt|;
if|if
condition|(
operator|(
name|fcopy
operator|=
name|fopen
argument_list|(
name|resultfile
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open working file %s"
argument_list|,
name|resultfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|swapeditfiles
argument_list|(
argument|tostdout
argument_list|)
end_macro

begin_comment
comment|/* Function: swaps resultfile and editfile, assigns fedit=fcopy,  * rewinds fedit for reading, and opens resultfile for reading and  * writing, using fcopy. If tostdout, fcopy is set to stdout.  */
end_comment

begin_block
block|{
name|char
modifier|*
name|tmpptr
decl_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fcopy
argument_list|)
condition|)
name|faterror
argument_list|(
literal|"write failed on %s -- file system full?"
argument_list|,
name|resultfile
argument_list|)
expr_stmt|;
name|fedit
operator|=
name|fcopy
expr_stmt|;
name|rewind
argument_list|(
name|fedit
argument_list|)
expr_stmt|;
name|editline
operator|=
literal|1
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
name|tmpptr
operator|=
name|editfile
expr_stmt|;
name|editfile
operator|=
name|resultfile
expr_stmt|;
name|resultfile
operator|=
name|tmpptr
expr_stmt|;
if|if
condition|(
name|tostdout
condition|)
name|fcopy
operator|=
name|stdout
expr_stmt|;
name|elsif
argument_list|(
argument|(fcopy=fopen(resultfile,
literal|"w+"
argument|))==NULL
argument_list|)
block|{
name|faterror
argument_list|(
literal|"Can't open working file %s"
argument_list|,
name|resultfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|finishedit
argument_list|(
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* copy the rest of the edit file and close it (if it exists).  * if delta!=nil, perform keyword substitution at the same time.  */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|fedit
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|delta
operator|!=
name|nil
condition|)
block|{
while|while
condition|(
name|expandline
argument_list|(
name|fedit
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
name|editline
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fedit
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|editline
operator|++
expr_stmt|;
block|}
block|}
name|ffclose
argument_list|(
name|fedit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|copylines
argument_list|(
name|line
argument_list|,
name|delta
argument_list|)
specifier|register
name|int
name|line
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: copies input lines editline..line-1 from fedit to fcopy.  * If delta != nil, keyword expansion is done simultaneously.  * editline is updated. Rewinds a file only if necessary.  */
end_comment

begin_block
block|{
if|if
condition|(
name|editline
operator|>
name|line
condition|)
block|{
comment|/* swap files */
name|finishedit
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|swapeditfiles
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* assumes edit only during last pass, from the beginning*/
block|}
while|while
condition|(
name|editline
operator|<
name|line
condition|)
block|{
comment|/*copy another line*/
if|if
condition|(
name|delta
condition|)
name|expandline
argument_list|(
name|fedit
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|putc
argument_list|(
name|getc
argument_list|(
name|fedit
argument_list|)
argument_list|,
name|fcopy
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|editline
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xpandstring
argument_list|(
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Reads a string terminated by SDELIM from finptr and writes it  * to fcopy. Double SDELIM is replaced with single SDELIM.  * Keyword expansion is performed with data from delta.  * If rewriteflag==true, the string is also copied unchanged to frewrite.  * editline is updated.  */
end_comment

begin_block
block|{
name|editline
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|expandline
argument_list|(
name|finptr
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
name|rewriteflag
argument_list|)
condition|)
name|editline
operator|++
expr_stmt|;
name|nextc
operator|=
literal|'\n'
expr_stmt|;
block|}
end_block

begin_macro
name|copystring
argument_list|()
end_macro

begin_comment
comment|/* Function: copies a string terminated with a single SDELIM from finptr to  * fcopy, replacing all double SDELIM with a single SDELIM.  * If rewriteflag==true, the string also copied unchanged to frewrite.  * editline is set to (number of lines copied)+1.  * Assumption: next character read is first string character.  */
end_comment

begin_block
block|{
specifier|register
name|c
operator|,
name|write
expr_stmt|;
name|write
operator|=
name|rewriteflag
expr_stmt|;
name|editline
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
name|SDELIM
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|SDELIM
operator|)
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|fcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|editline
operator|++
expr_stmt|;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|serror
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|editstring
argument_list|(
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: reads an edit script from finptr and applies it to  * file fedit; the result is written to fcopy.  * If delta!=nil, keyword expansion is performed simultaneously.  * If frewrite==true, the edit script is also copied verbatim to frewrite.  * Assumes that all these files are open.  * If running out of lines in fedit, fedit and fcopy are swapped.  * resultfile and editfile are the names of the files that go with fcopy  * and fedit, respectively.  * Assumes the next input character from finptr is the first character of  * the edit script. Resets nextc on exit.  */
end_comment

begin_block
block|{
name|int
name|ed
decl_stmt|;
comment|/* editor command */
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|write
decl_stmt|,
name|i
decl_stmt|;
name|int
name|line
decl_stmt|,
name|length
decl_stmt|;
name|editline
operator|+=
name|linecorr
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
comment|/*correct line number*/
name|write
operator|=
name|rewriteflag
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* read next command and decode */
comment|/* assume next non-white character is command name*/
while|while
condition|(
operator|(
name|ed
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|==
literal|'\n'
operator|||
name|ed
operator|==
literal|' '
operator|||
name|ed
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|ed
operator|==
name|SDELIM
condition|)
break|break;
comment|/* now attempt to read numbers. */
comment|/* fscanf causes trouble because of the required echoing */
while|while
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/*skip spaces*/
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"missing line number in edit script"
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|line
operator|=
name|line
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"incorrect range in edit script"
argument_list|)
expr_stmt|;
break|break;
block|}
name|length
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|length
operator|=
name|length
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
comment|/* skip to end of line */
switch|switch
condition|(
name|ed
condition|)
block|{
case|case
literal|'d'
case|:
name|copylines
argument_list|(
name|line
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* skip over unwanted lines */
for|for
control|(
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/*skip next line*/
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fedit
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|faterror
argument_list|(
literal|"EOF during edit"
argument_list|)
expr_stmt|;
name|editline
operator|++
expr_stmt|;
block|}
name|linecorr
operator|-=
name|length
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|copylines
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/*copy only; no delete*/
for|for
control|(
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/*copy next line from script*/
if|if
condition|(
name|delta
operator|!=
name|nil
condition|)
name|expandline
argument_list|(
name|finptr
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
name|write
argument_list|)
expr_stmt|;
else|else
block|{
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
while|while
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|fcopy
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
name|SDELIM
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|SDELIM
operator|)
condition|)
block|{
name|serror
argument_list|(
literal|"Missing string delimiter in edit script"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fcopy
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|linecorr
operator|+=
name|length
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"unknown command in edit script: %c"
argument_list|,
name|ed
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nextc
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The rest if for keyword expansion */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|keyword
decl_stmt|;
name|enum
name|markers
name|marker
decl_stmt|;
block|}
name|markertable
index|[]
init|=
block|{
block|{
name|AUTHOR
block|,
name|Author
block|}
block|,
block|{
name|DATE
block|,
name|Date
block|}
block|,
block|{
name|HEADER
block|,
name|Header
block|}
block|,
block|{
name|LOCKER
block|,
name|Locker
block|}
block|,
block|{
name|LOG
block|,
name|Log
block|}
block|,
block|{
name|REVISION
block|,
name|Revision
block|}
block|,
block|{
name|SOURCE
block|,
name|Source
block|}
block|,
block|{
name|STATE
block|,
name|State
block|}
block|,
block|{
name|nil
block|,
name|Nomatch
block|}
block|}
struct|;
end_struct

begin_function
name|enum
name|markers
name|trymatch
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* function: Checks whether string is a keyword.  * If so, returns the appropriate marker, otherwise Nomatch.  */
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|markertable
index|[
name|j
index|]
operator|.
name|keyword
operator|!=
name|nil
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|markertable
index|[
name|j
index|]
operator|.
name|keyword
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|markertable
index|[
name|j
index|]
operator|.
name|marker
operator|)
return|;
block|}
return|return
operator|(
name|Nomatch
operator|)
return|;
block|}
end_function

begin_macro
name|expandline
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|delta
argument_list|,
argument|delimstuffed
argument_list|,
argument|write
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|delimstuffed
decl_stmt|,
name|write
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Reads a line from in and writes it to out.  * If delimstuffed==true, double SDELIM is replaced with single SDELIM.  * Keyword expansion is performed with data from delta.  * If write==true, the string is also copied unchanged to frewrite.  * Returns false if end-of-string or end-of-line is detected, true otherwise.  */
end_comment

begin_block
block|{
specifier|register
name|c
operator|,
name|j
expr_stmt|;
name|char
name|keystring
index|[
name|keylength
index|]
decl_stmt|;
name|char
name|keyval
index|[
name|keyvallength
index|]
decl_stmt|;
name|enum
name|markers
name|matchresult
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|delimstuffed
condition|)
block|{
name|error
argument_list|(
literal|"unterminated string"
argument_list|)
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|delimstuffed
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|true
return|;
comment|/* end of line */
name|retry
label|:
if|if
condition|(
name|c
operator|==
name|KDELIM
condition|)
block|{
comment|/* check for keyword */
comment|/* first, copy a long enough string into keystring */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|j
operator|<
name|keylength
operator|-
literal|1
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|KDELIM
operator|)
operator|&&
operator|(
name|c
operator|!=
name|VDELIM
operator|)
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|keystring
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|delimstuffed
condition|)
block|{
comment|/*skip next SDELIM */
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
comment|/* Can't be at end of string -- always a '\n' before*/
comment|/* closing SDELIM */
block|}
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|==
name|KDELIM
operator|)
operator|||
operator|(
name|c
operator|==
name|VDELIM
operator|)
operator|)
condition|)
block|{
comment|/* no match */
comment|/* can get SDELIM here if have $...keylength-1 chars...@@ */
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|delimstuffed
condition|)
block|{
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|true
return|;
comment|/* end of line */
block|}
else|else
block|{
comment|/* no we have something that looks like a  */
comment|/* keyword, and is terminated with K/VDELIM*/
name|keystring
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|matchresult
operator|=
name|trymatch
argument_list|(
name|keystring
argument_list|)
operator|)
operator|==
name|Nomatch
condition|)
block|{
comment|/* no match */
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|KDELIM
condition|)
goto|goto
name|retry
goto|;
block|}
name|elsif
argument_list|(
argument|c==VDELIM
argument_list|)
block|{
comment|/* try to find closing KDELIM, and replace value */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|KDELIM
operator|)
operator|&&
operator|(
name|j
operator|<
name|keyvallength
operator|-
literal|2
operator|)
condition|)
block|{
name|keyval
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|delimstuffed
condition|)
block|{
comment|/*skip next SDELIM */
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frewrite
argument_list|,
name|write
argument_list|)
expr_stmt|;
comment|/* Can't be at end of string -- always a '\n' before*/
comment|/* closing SDELIM */
block|}
block|}
name|keyval
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|KDELIM
condition|)
block|{
comment|/* couldn't find closing KDELIM -- give up */
name|putc
argument_list|(
name|VDELIM
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|keyval
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fputs
argument_list|(
name|keyval
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|true
return|;
comment|/* end of line */
block|}
else|else
block|{
comment|/* found complete pattern -- replace */
name|keyreplace
argument_list|(
name|matchresult
argument_list|,
name|delta
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* string of the form $keyword$ */
name|keyreplace
argument_list|(
name|matchresult
argument_list|,
name|delta
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end for */
block|}
end_block

begin_expr_stmt
name|keyreplace
argument_list|(
name|marker
argument_list|,
name|delta
argument_list|,
name|out
argument_list|)
expr|enum
name|markers
name|marker
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function: ouputs the keyword value(s) corresponding to marker.  * Attributes are derived from delta.  */
end_comment

begin_block
block|{
name|char
modifier|*
name|date
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|date
operator|=
name|delta
operator|->
name|date
expr_stmt|;
switch|switch
condition|(
name|marker
condition|)
block|{
case|case
name|Author
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
break|break;
case|case
name|Date
case|:
name|putc
argument_list|(
name|VDELIM
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|PRINTDATE
argument_list|(
name|out
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|PRINTTIME
argument_list|(
name|out
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|KDELIM
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Header
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %s "
argument_list|,
name|VDELIM
argument_list|,
name|bindex
argument_list|(
name|RCSfilename
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|PRINTDATE
argument_list|(
name|out
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|PRINTTIME
argument_list|(
name|out
argument_list|,
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|lockedby
operator|==
name|nil
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s %s "
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|delta
operator|->
name|state
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s Locked "
argument_list|,
name|delta
operator|->
name|lockedby
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|KDELIM
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Locker
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|lockedby
operator|==
name|nil
condition|?
literal|""
else|:
name|delta
operator|->
name|lockedby
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
break|break;
case|case
name|Log
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c\t%s %c\n%sRevision %s  "
argument_list|,
name|VDELIM
argument_list|,
name|bindex
argument_list|(
name|RCSfilename
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|KDELIM
argument_list|,
name|Comment
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|PRINTDATE
argument_list|(
name|out
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|PRINTTIME
argument_list|(
name|out
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  %s\n%s"
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|Comment
argument_list|)
expr_stmt|;
comment|/* do not include state here because it may change and is not updated*/
name|sp
operator|=
name|delta
operator|->
name|log
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
if|if
condition|(
name|putc
argument_list|(
operator|*
name|sp
operator|++
argument_list|,
name|out
argument_list|)
operator|==
literal|'\n'
condition|)
name|fputs
argument_list|(
name|Comment
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Comment is the comment leader */
break|break;
case|case
name|Revision
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
break|break;
case|case
name|Source
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
break|break;
case|case
name|State
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|state
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
break|break;
case|case
name|Nomatch
case|:
name|putc
argument_list|(
name|KDELIM
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

