begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS file input  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/wft/RCS/SRC/RCS/rcssyn.c,v 3.6 83/01/15 17:46:50 wft Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************************  *                       Syntax Analysis.  *                       Keyword table  *                       Testprogram: define SYNDB  *                       Compatibility with Release 2: define COMPAT2  *********************************************************************************  *  * Copyright (C) 1982 by Walter F. Tichy  *                       Purdue University  *                       Computer Science Department  *                       West Lafayette, IN 47907  *  * All rights reserved. No part of this software may be sold or distributed  * in any form or by any means without the prior written permission of the  * author.  * Report problems and direct all inquiries to Tichy@purdue (ARPA net).  */
end_comment

begin_comment
comment|/* $Log:	rcssyn.c,v $  * Revision 3.6  83/01/15  17:46:50  wft  * Changed readdelta() to initialize selector and log-pointer.  * Changed puttree to check for selector==DELETE; putdtext() uses DELNUMFORM.  *   * Revision 3.5  82/12/08  21:58:58  wft  * renamed Commentleader to Commleader.  *  * Revision 3.4  82/12/04  13:24:40  wft  * Added routine gettree(), which updates keeplock after reading the  * delta tree.  *  * Revision 3.3  82/11/28  21:30:11  wft  * Reading and printing of Suffix removed; version COMPAT2 skips the  * Suffix for files of release 2 format. Fixed problems with printing nil.  *  * Revision 3.2  82/10/18  21:18:25  wft  * renamed putdeltatext to putdtext.  *  * Revision 3.1  82/10/11  19:45:11  wft  * made sure getc() returns into an integer.  */
end_comment

begin_comment
comment|/* #define COMPAT2 /* version COMPAT2 reads files of the format of release 2 and 3, but  * generates files of release 3 format. Need not be defined if no  * old RCS files generated with release 2 exist.  */
end_comment

begin_comment
comment|/* #define SYNDB /* version SYNDB is for debugging the syntax analysis for RCS files.  * SYNDB performs additional error checks.  */
end_comment

begin_comment
comment|/* #define SYNTEST /* version SYNTEST inputs a RCS file and then prints out its internal  * data structures. */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*RCS input file*/
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|getkey
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|getlex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern        readstring(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|int
name|savestring
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* forward */
end_comment

begin_function_decl
name|char
modifier|*
name|getkeyval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|delta
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* keyword table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Kaccess
init|=
literal|"access"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Kauthor
init|=
literal|"author"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Kbranches
init|=
literal|"branches"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Kcomment
init|=
literal|"comment"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Kdate
init|=
literal|"date"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Kdesc
init|=
literal|"desc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Khead
init|=
literal|"head"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Klocks
init|=
literal|"locks"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Klog
init|=
literal|"log"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Knext
init|=
literal|"next"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Kstate
init|=
literal|"state"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Kstrict
init|=
literal|"strict"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Ksuffix
init|=
literal|"suffix"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Ksymbols
init|=
literal|"symbols"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Ktext
init|=
literal|"text"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMMLENGTH
value|20
end_define

begin_decl_stmt
name|char
name|Commleader
index|[
name|COMMLENGTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Comment
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|access
modifier|*
name|AccessList
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|access
modifier|*
name|LastAccess
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|assoc
modifier|*
name|Symbols
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|assoc
modifier|*
name|LastSymbol
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lock
modifier|*
name|Locks
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lock
modifier|*
name|LastLock
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|StrictLocks
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|Head
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TotalDeltas
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|getadmin
argument_list|()
end_macro

begin_comment
comment|/* Function: Reads an<admin> and initializes the globals  * AccessList, LastAccess, Symbols, LastSymbol,  * Locks, LastLock, StrictLocks, Head, Comment, TotalDeltas;  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|id
decl_stmt|;
name|struct
name|access
modifier|*
name|newaccess
decl_stmt|;
name|struct
name|assoc
modifier|*
name|newassoc
decl_stmt|;
name|struct
name|lock
modifier|*
name|newlock
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|Comment
operator|=
literal|""
expr_stmt|;
name|AccessList
operator|=
name|LastAccess
operator|=
name|nil
expr_stmt|;
name|Symbols
operator|=
name|LastSymbol
operator|=
name|nil
expr_stmt|;
name|Locks
operator|=
name|LastLock
operator|=
name|nil
expr_stmt|;
name|Head
operator|=
name|nil
expr_stmt|;
name|TotalDeltas
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Khead
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"Missing head"
argument_list|)
expr_stmt|;
name|Head
operator|=
name|getnum
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYNDB
if|if
condition|(
name|Head
operator|&&
operator|(
operator|(
name|countnumflds
argument_list|(
name|Head
operator|->
name|num
argument_list|)
operator|%
literal|2
operator|)
operator|!=
literal|0
operator|)
condition|)
name|serror
argument_list|(
literal|"Delta number required for head"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after head"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT2
comment|/* read suffix. Only in release 2 format */
if|if
condition|(
name|getkey
argument_list|(
name|Ksuffix
argument_list|)
condition|)
block|{
if|if
condition|(
name|nexttok
operator|==
name|STRING
condition|)
block|{
name|readstring
argument_list|()
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
comment|/*through away the suffix*/
block|}
name|elsif
argument_list|(
argument|nexttok==ID
argument_list|)
block|{
name|nextlex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after %s"
argument_list|,
name|Ksuffix
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Kaccess
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"Missing access list"
argument_list|)
expr_stmt|;
while|while
condition|(
name|id
operator|=
name|getid
argument_list|()
condition|)
block|{
name|newaccess
operator|=
operator|(
expr|struct
name|access
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|access
argument_list|)
argument_list|)
expr_stmt|;
name|newaccess
operator|->
name|login
operator|=
name|id
expr_stmt|;
name|newaccess
operator|->
name|nextaccess
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|AccessList
operator|==
name|nil
condition|)
block|{
name|AccessList
operator|=
name|LastAccess
operator|=
name|newaccess
expr_stmt|;
block|}
else|else
block|{
name|LastAccess
operator|=
name|LastAccess
operator|->
name|nextaccess
operator|=
name|newaccess
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after access list"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Ksymbols
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"Missing symbols"
argument_list|)
expr_stmt|;
while|while
condition|(
name|id
operator|=
name|getid
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|COLON
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ':' in symbolic name definition"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
name|serror
argument_list|(
literal|"Missing number in symbolic name definition"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*add new pair to association list*/
name|newassoc
operator|=
operator|(
expr|struct
name|assoc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
name|newassoc
operator|->
name|symbol
operator|=
name|id
expr_stmt|;
name|newassoc
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
name|newassoc
operator|->
name|nextassoc
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|Symbols
operator|==
name|nil
condition|)
block|{
name|Symbols
operator|=
name|LastSymbol
operator|=
name|newassoc
expr_stmt|;
block|}
else|else
block|{
name|LastSymbol
operator|=
name|LastSymbol
operator|->
name|nextassoc
operator|=
name|newassoc
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after symbolic names"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Klocks
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing locks"
argument_list|)
expr_stmt|;
while|while
condition|(
name|id
operator|=
name|getid
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|COLON
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ':' in lock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
name|serror
argument_list|(
literal|"Missing number in lock"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*add new pair to lock list*/
ifdef|#
directive|ifdef
name|SYNDB
if|if
condition|(
operator|(
name|countnumflds
argument_list|(
name|delta
operator|->
name|num
argument_list|)
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
name|serror
argument_list|(
literal|"Delta number required for lock"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newlock
operator|=
operator|(
expr|struct
name|lock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|newlock
operator|->
name|login
operator|=
name|id
expr_stmt|;
name|newlock
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
name|newlock
operator|->
name|nextlock
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|Locks
operator|==
name|nil
condition|)
block|{
name|Locks
operator|=
name|LastLock
operator|=
name|newlock
expr_stmt|;
block|}
else|else
block|{
name|LastLock
operator|=
name|LastLock
operator|->
name|nextlock
operator|=
name|newlock
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after locks"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Kstrict
argument_list|)
condition|)
block|{
name|StrictLocks
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|StrictLocks
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after keyword %s"
argument_list|,
name|Kstrict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getkey
argument_list|(
name|Kcomment
argument_list|)
operator|&&
operator|(
name|nexttok
operator|==
name|STRING
operator|)
condition|)
block|{
name|savestring
argument_list|(
name|Commleader
argument_list|,
name|COMMLENGTH
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
name|Comment
operator|=
name|Commleader
expr_stmt|;
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after %s"
argument_list|,
name|Kcomment
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|getdelta
argument_list|()
end_macro

begin_comment
comment|/* Function: reads a delta block.  * returns false if the current block does not start with a number.  */
end_comment

begin_block
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|,
modifier|*
name|num
decl_stmt|;
name|struct
name|branchhead
modifier|*
name|LastBranch
decl_stmt|,
modifier|*
name|NewBranch
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|SYNDB
if|if
condition|(
operator|(
name|countnumflds
argument_list|(
name|Delta
operator|->
name|num
argument_list|)
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
name|serror
argument_list|(
literal|"Delta number required"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hshenter
operator|=
name|false
expr_stmt|;
comment|/*Don't enter dates into hashtable*/
name|Delta
operator|->
name|date
operator|=
name|getkeyval
argument_list|(
name|Kdate
argument_list|,
name|NUM
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|hshenter
operator|=
name|true
expr_stmt|;
comment|/*reset hshenter for revision numbers.*/
name|Delta
operator|->
name|author
operator|=
name|getkeyval
argument_list|(
name|Kauthor
argument_list|,
name|ID
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|state
operator|=
name|getkeyval
argument_list|(
name|Kstate
argument_list|,
name|ID
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Kbranches
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"Missing branches"
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|branches
operator|=
name|LastBranch
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|num
operator|=
name|getnum
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|SYNDB
if|if
condition|(
operator|(
name|countnumflds
argument_list|(
name|num
operator|->
name|num
argument_list|)
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
name|serror
argument_list|(
literal|"Delta number required"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|NewBranch
operator|=
operator|(
expr|struct
name|branchhead
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|branchhead
argument_list|)
argument_list|)
expr_stmt|;
name|NewBranch
operator|->
name|hsh
operator|=
name|num
expr_stmt|;
name|NewBranch
operator|->
name|nextbranch
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|LastBranch
operator|==
name|nil
condition|)
block|{
name|Delta
operator|->
name|branches
operator|=
name|LastBranch
operator|=
name|NewBranch
expr_stmt|;
block|}
else|else
block|{
name|LastBranch
operator|=
name|LastBranch
operator|->
name|nextbranch
operator|=
name|NewBranch
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after branches"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Knext
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"Missing next"
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|next
operator|=
name|num
operator|=
name|getnum
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYNDB
if|if
condition|(
name|num
operator|&&
operator|(
operator|(
name|countnumflds
argument_list|(
name|num
operator|->
name|num
argument_list|)
operator|%
literal|2
operator|)
operator|!=
literal|0
operator|)
condition|)
name|serror
argument_list|(
literal|"Delta number required"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after next"
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|log
operator|=
name|Delta
operator|->
name|lockedby
operator|=
name|nil
expr_stmt|;
name|Delta
operator|->
name|selector
operator|=
literal|'\0'
expr_stmt|;
name|TotalDeltas
operator|++
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_block

begin_macro
name|gettree
argument_list|()
end_macro

begin_comment
comment|/* Function: Reads in the delta tree with getdelta(), then  * updates the lockedby fields. Returns the total number of deltas read.  */
end_comment

begin_block
block|{
name|struct
name|lock
modifier|*
name|currlock
decl_stmt|;
while|while
condition|(
name|getdelta
argument_list|()
condition|)
empty_stmt|;
name|currlock
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|currlock
condition|)
block|{
name|currlock
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|currlock
operator|->
name|login
expr_stmt|;
name|currlock
operator|=
name|currlock
operator|->
name|nextlock
expr_stmt|;
block|}
return|return
name|TotalDeltas
return|;
block|}
end_block

begin_macro
name|getdesc
argument_list|(
argument|prdesc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|prdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: read in descriptive text  * nexttok is not advanced afterwards.  * if prdesc==true, the text is printed to stdout.  */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Kdesc
argument_list|)
operator|||
operator|(
name|nexttok
operator|!=
name|STRING
operator|)
condition|)
name|fatserror
argument_list|(
literal|"Missing descriptive text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prdesc
condition|)
name|printstring
argument_list|()
expr_stmt|;
comment|/*echo string*/
else|else
name|readstring
argument_list|()
expr_stmt|;
comment|/*skip string*/
block|}
end_block

begin_function
name|char
modifier|*
name|getkeyval
parameter_list|(
name|keyword
parameter_list|,
name|token
parameter_list|,
name|optional
parameter_list|)
name|enum
name|tokens
name|token
decl_stmt|;
name|char
modifier|*
name|keyword
decl_stmt|;
name|int
name|optional
decl_stmt|;
comment|/* reads a pair of the form  *<keyword><token> ;  * where token is one of<id> or<num>. optional indicates whether  *<token> is optional. A pointer to  * the acutal character string of<id> or<num) is returned.  * Getkeyval terminates the program on missing keyword or token, continues  * on missing ;.  */
block|{
specifier|register
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|keyword
argument_list|)
condition|)
block|{
name|fatserror
argument_list|(
literal|"Missing %s"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nexttok
operator|==
name|token
condition|)
block|{
name|val
operator|=
name|NextString
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|optional
condition|)
block|{
name|fatserror
argument_list|(
literal|"Missing %s"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|nil
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after %s"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|putadmin
argument_list|(
name|fout
argument_list|)
specifier|register
name|FILE
operator|*
name|fout
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Function: Print the<admin> node read with getadmin() to file fout.  * Assumption: Variables AccessList, Symbols, Locks, StrictLocks,  * and Head have been set.  */
end_comment

begin_block
block|{
name|struct
name|assoc
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|lock
modifier|*
name|curlock
decl_stmt|;
name|struct
name|access
modifier|*
name|curaccess
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|fputs
argument_list|(
name|Khead
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"     "
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|Head
condition|)
name|fputs
argument_list|(
name|Head
operator|->
name|num
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s  "
argument_list|,
name|Kaccess
argument_list|)
expr_stmt|;
name|curaccess
operator|=
name|AccessList
expr_stmt|;
if|if
condition|(
name|curaccess
operator|==
name|nil
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
name|curaccess
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|curaccess
operator|->
name|login
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|curaccess
operator|=
name|curaccess
operator|->
name|nextaccess
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s "
argument_list|,
name|Ksymbols
argument_list|)
expr_stmt|;
name|curassoc
operator|=
name|Symbols
expr_stmt|;
if|if
condition|(
name|curassoc
operator|==
name|nil
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
name|curassoc
condition|)
block|{
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|" %s:%s"
argument_list|,
name|curassoc
operator|->
name|symbol
argument_list|,
name|curassoc
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|curassoc
operator|=
name|curassoc
operator|->
name|nextassoc
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s   "
argument_list|,
name|Klocks
argument_list|)
expr_stmt|;
name|curlock
operator|=
name|Locks
expr_stmt|;
if|if
condition|(
name|curlock
operator|==
name|nil
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
name|curlock
condition|)
block|{
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|" %s:%s"
argument_list|,
name|curlock
operator|->
name|login
argument_list|,
name|curlock
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|curlock
operator|=
name|curlock
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|StrictLocks
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"; %s"
argument_list|,
name|Kstrict
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s  %c"
argument_list|,
name|Kcomment
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|Comment
operator|)
operator|!=
name|nil
condition|)
block|{
while|while
condition|(
operator|*
name|sp
condition|)
if|if
condition|(
name|putc
argument_list|(
operator|*
name|sp
operator|++
argument_list|,
name|fout
argument_list|)
operator|==
name|SDELIM
condition|)
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%c;\n\n"
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putdelta
argument_list|(
name|node
argument_list|,
name|fout
argument_list|)
specifier|register
expr|struct
name|hshentry
operator|*
name|node
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: prints a<delta> node to fout;  */
end_comment

begin_block
block|{
name|struct
name|branchhead
modifier|*
name|nextbranch
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|nil
condition|)
return|return;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"\n%s\n"
argument_list|,
name|node
operator|->
name|num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s     %s;  %s %s;  %s "
argument_list|,
name|Kdate
argument_list|,
name|node
operator|->
name|date
argument_list|,
name|Kauthor
argument_list|,
name|node
operator|->
name|author
argument_list|,
name|Kstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|state
operator|!=
name|nil
condition|)
name|fputs
argument_list|(
name|node
operator|->
name|state
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";\nbranches"
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|node
operator|->
name|branches
expr_stmt|;
if|if
condition|(
name|nextbranch
operator|==
name|nil
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextbranch
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|nextbranch
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|nextbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s     "
argument_list|,
name|Knext
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next
operator|!=
name|nil
condition|)
name|fputs
argument_list|(
name|node
operator|->
name|next
operator|->
name|num
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";\n"
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|puttree
argument_list|(
argument|root
argument_list|,
argument|fout
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: prints the delta tree in preorder to fout, starting with root.  */
end_comment

begin_block
block|{
name|struct
name|branchhead
modifier|*
name|nextbranch
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|nil
condition|)
return|return;
if|if
condition|(
name|root
operator|->
name|selector
operator|!=
name|DELETE
condition|)
name|putdelta
argument_list|(
name|root
argument_list|,
name|fout
argument_list|)
expr_stmt|;
comment|/* selector DELETE means deleted; set by rcs -o */
name|puttree
argument_list|(
name|root
operator|->
name|next
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|nextbranch
condition|)
block|{
name|puttree
argument_list|(
name|nextbranch
operator|->
name|hsh
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|nextbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|putdtext
parameter_list|(
name|num
parameter_list|,
name|log
parameter_list|,
name|srcfilename
parameter_list|,
name|fout
parameter_list|)
name|char
modifier|*
name|num
decl_stmt|,
decl|*
name|log
decl_stmt|,
modifier|*
name|srcfilename
decl_stmt|;
end_function

begin_decl_stmt
name|FILE
modifier|*
name|fout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: write a deltatext-node to fout.  * num points to the deltanumber, log to the logmessage, and  * sourcefile contains the text. Doubles up all SDELIMs in both the  * log and the text; Makes sure the log message ends in \n.  * returns false on error.  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fin
decl_stmt|;
name|fprintf
argument_list|(
name|fout
argument_list|,
name|DELNUMFORM
argument_list|,
name|num
argument_list|,
name|Klog
argument_list|)
expr_stmt|;
comment|/* put log */
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|sp
operator|=
name|log
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
if|if
condition|(
name|putc
argument_list|(
operator|*
name|sp
operator|++
argument_list|,
name|fout
argument_list|)
operator|==
name|SDELIM
condition|)
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
comment|/*append \n if necessary*/
comment|/* put text */
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%c\n%s\n%c"
argument_list|,
name|SDELIM
argument_list|,
name|Ktext
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|fopen
argument_list|(
name|srcfilename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Can't open source file %s"
argument_list|,
name|srcfilename
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|fin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|fout
argument_list|)
expr_stmt|;
comment|/*double up SDELIM*/
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SYNTEST
end_ifdef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|cmdid
operator|=
literal|"syntest"
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fputs
argument_list|(
literal|"No input file\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open input file %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
name|putadmin
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gettree
argument_list|()
expr_stmt|;
name|puttree
argument_list|(
name|Head
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|getdesc
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextlex
argument_list|()
operator|,
name|nexttok
operator|!=
name|EOFILE
condition|)
block|{
name|fatserror
argument_list|(
literal|"Syntax error"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/*dummy*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

