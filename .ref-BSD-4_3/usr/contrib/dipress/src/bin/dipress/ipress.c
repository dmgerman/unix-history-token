begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-----------------------------------------------------------------------------  *  ipress - most of the code directly dependent on interpress used by dipress  *	     to produce an interpress file from device independent troff  *	     intermediate code.    *  *  William LeFebvre  *  * Copyright (c) 1984, 1985 Xerox Corp.  *  * History:  *	John Mellor-Crummey 28-aug-1985 restructuring and minor modifications  *  *	ed flint 10-may-1985	coerce device.num_char_wid to unsigned char, change  *				ch argument in outputChar to unsigned int   *				since we now have> 128 special characters  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"deviceinfo.h"
end_include

begin_comment
comment|/* typesetter characteristics */
end_comment

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_comment
comment|/* \					*/
end_comment

begin_include
include|#
directive|include
file|"literal.h"
end_include

begin_comment
comment|/*> interface levels for interpress	*/
end_comment

begin_include
include|#
directive|include
file|"operator.h"
end_include

begin_comment
comment|/* /					*/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* constant and macro definitions */
end_comment

begin_include
include|#
directive|include
file|"externs.h"
end_include

begin_comment
comment|/* declarations for global variables */
end_comment

begin_comment
comment|/* initialize device */
end_comment

begin_macro
name|initDevice
argument_list|()
end_macro

begin_block
block|{
name|int
name|lines
init|=
literal|0
decl_stmt|;
name|int
name|timapf
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ipp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|trp
decl_stmt|;
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"initDevice called\n"
argument_list|)
expr_stmt|;
comment|/* start the preamble */
name|ip_select
argument_list|(
name|outputfile
argument_list|)
expr_stmt|;
comment|/* special master instructions go here... */
name|Op
argument_list|(
name|beginBlock
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|beginBody
argument_list|)
expr_stmt|;
comment|/* save scaling transform that uses a mica co-ordinate system */
name|AppendRational
argument_list|(
literal|1L
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|F_transform
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|fset
argument_list|)
expr_stmt|;
comment|/* select file that holds page bodies */
name|ip_select
argument_list|(
name|pagebodyfile
argument_list|)
expr_stmt|;
comment|/* open file that maps troff names to interpress names */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/interpress-fonts"
argument_list|,
name|fontdirectory
argument_list|,
name|devicename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|timapf
operator|=
name|open
argument_list|(
name|temp
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|reportError
argument_list|(
name|QUIT
argument_list|,
literal|"can't open %s (%s)"
argument_list|,
name|temp
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
comment|/* read in the whole thing */
name|ret
operator|=
name|fstat
argument_list|(
name|timapf
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"stat returned %d, errno %d\n"
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|timap
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|stbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"reading %d bytes from timapf\n"
argument_list|,
name|stbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|timapf
argument_list|,
name|timap
argument_list|,
operator|(
name|int
operator|)
name|stbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"read returned %d, errno %d, timapf %d\n"
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|,
name|timapf
argument_list|)
expr_stmt|;
name|timap
index|[
operator|(
name|int
operator|)
name|stbuf
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|timapf
argument_list|)
expr_stmt|;
comment|/* count the newlines */
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"pointer starts at %08x ... "
argument_list|,
name|timap
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|timap
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
name|lines
operator|++
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"ends at %08x\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"found %d lines\n"
argument_list|,
name|lines
argument_list|)
expr_stmt|;
comment|/* allocate the mapping arrays */
name|trp
operator|=
name|trname
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|lines
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ipp
operator|=
name|ipname
operator|=
name|trname
operator|+
name|lines
expr_stmt|;
comment|/* break out the strings and store pointers in the arrays */
name|ptr
operator|=
name|timap
expr_stmt|;
name|mapcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"loop: ptr = %08x, *ptr = %c\n"
argument_list|,
name|ptr
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|trp
operator|++
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|!
name|white
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|white
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|ipp
operator|++
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|ptr
operator|!=
literal|'\n'
condition|)
comment|/* nothing */
empty_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|mapcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dbg
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s\t%s\n"
argument_list|,
name|trname
index|[
name|i
index|]
argument_list|,
name|ipname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* reset vertical and horizontal positions */
name|hor_pos
operator|=
name|ver_pos
operator|=
name|old_hor
operator|=
name|old_ver
operator|=
literal|0
expr_stmt|;
comment|/* reset the font information */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|currfonts
argument_list|,
sizeof|sizeof
argument_list|(
name|currfonts
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setScale
argument_list|(
argument|spi
argument_list|)
end_macro

begin_comment
comment|/* set resolution */
end_comment

begin_decl_stmt
name|int
name|spi
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* set the scaling variable used in all x and y calculations */
name|scale
operator|=
name|floor
argument_list|(
literal|2540.0
operator|/
operator|(
name|double
operator|)
name|spi
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"setScale(%d) sets scale to %e\n"
argument_list|,
name|spi
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* 	     *  Set the drawing scale based on the scale.  This factor is applied to 	     *	all points drawn in the bitmap for graphical objects.  It is scaled 	     *	down from micas to 508 dpi so that the bitmaps aren't of unwieldy 	     *	size, but still retain enough information to look decent on a good 	     *	device.  508/2540 == 0.2 	     */
name|drawscale
operator|=
name|scale
operator|*
literal|.2
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"setScale(%d) sets drawscale to %e\n"
argument_list|,
name|spi
argument_list|,
name|drawscale
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pushCurrentEnv
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
name|statep
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
name|statep
operator|->
name|sfont
operator|=
name|font
expr_stmt|;
name|statep
operator|->
name|shorig
operator|=
name|hor_orig
expr_stmt|;
name|statep
operator|->
name|svorig
operator|=
name|ver_orig
expr_stmt|;
name|statep
operator|->
name|shpos
operator|=
name|hor_pos
expr_stmt|;
name|statep
operator|->
name|svpos
operator|=
name|ver_pos
expr_stmt|;
name|hor_orig
operator|=
name|hor_pos
expr_stmt|;
name|ver_orig
operator|=
name|ver_pos
expr_stmt|;
name|hor_pos
operator|=
name|ver_pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|statep
operator|++
operator|>=
name|state
operator|+
name|MAXSTATE
condition|)
block|{
name|reportError
argument_list|(
name|QUIT
argument_list|,
literal|"{ nested too deep"
argument_list|)
expr_stmt|;
block|}
name|hor_pos
operator|=
name|ver_pos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|popSavedEnv
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
if|if
condition|(
operator|--
name|statep
operator|<
name|state
condition|)
block|{
name|reportError
argument_list|(
name|QUIT
argument_list|,
literal|"extra }"
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|statep
operator|->
name|ssize
expr_stmt|;
name|font
operator|=
name|statep
operator|->
name|sfont
expr_stmt|;
name|hor_pos
operator|=
name|statep
operator|->
name|shpos
expr_stmt|;
name|ver_pos
operator|=
name|statep
operator|->
name|svpos
expr_stmt|;
name|hor_orig
operator|=
name|statep
operator|->
name|shorig
expr_stmt|;
name|ver_orig
operator|=
name|statep
operator|->
name|svorig
expr_stmt|;
block|}
end_block

begin_macro
name|newpage
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* new page */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|buff
index|[
literal|15
index|]
decl_stmt|;
comment|/* print any pending bitmap */
comment|/* terminate previous page if outputting */
if|if
condition|(
name|outputflag
condition|)
block|{
name|print_bitmap
argument_list|()
expr_stmt|;
name|Op
argument_list|(
name|endBody
argument_list|)
expr_stmt|;
block|}
else|else
name|flush_bitmap
argument_list|()
expr_stmt|;
comment|/* reset vertical positions */
name|ver_pos
operator|=
name|old_ver
operator|=
literal|0
expr_stmt|;
comment|/* check new page number against those found in the nPageRanges */
if|if
condition|(
name|nPageRanges
operator|==
literal|0
condition|)
block|{
comment|/* no -o specified -- do all pages */
name|outputflag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* see if new page has been selected for output */
name|outputflag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nPageRanges
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|>=
name|pagerange
index|[
name|i
index|]
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|n
operator|<=
name|pagerange
index|[
name|i
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|outputflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* start new page */
if|if
condition|(
name|outputflag
condition|)
block|{
name|Op
argument_list|(
name|beginBody
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Page %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|AppendComment
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|Fget
argument_list|(
name|F_transform
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|concatt
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|2L
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|I_strokeEnd
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|iset
argument_list|)
expr_stmt|;
block|}
comment|/* font/size no longer valid -- force a new assignment */
name|oldftsz
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|newLine
argument_list|()
end_macro

begin_comment
comment|/* new line (no vertical motion implied) */
end_comment

begin_block
block|{
if|if
condition|(
name|dbg
operator|==
literal|3
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flushbuff
argument_list|()
expr_stmt|;
name|endcorrect
argument_list|()
expr_stmt|;
name|hor_pos
operator|=
literal|0
expr_stmt|;
name|virgin_line
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|internalSize
argument_list|(
argument|number
argument_list|)
end_macro

begin_comment
comment|/* convert integer to internal size number */
end_comment

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|index
decl_stmt|;
if|if
condition|(
name|number
operator|>=
name|pointsizeTab
index|[
name|device
operator|.
name|num_sizes
operator|-
literal|1
index|]
condition|)
block|{
comment|/* larger than largest -- use largest */
return|return
operator|(
name|device
operator|.
name|num_sizes
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|number
operator|<=
name|pointsizeTab
index|[
literal|0
index|]
condition|)
block|{
comment|/* smaller than smallest -- use smallest */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else find the size in pointsizeTab and return index */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|number
operator|>
name|pointsizeTab
index|[
name|index
index|]
condition|;
name|index
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|index
operator|)
return|;
block|}
end_block

begin_comment
comment|/* handle device stop command */
end_comment

begin_macro
name|resetDevice
argument_list|()
end_macro

begin_block
block|{
name|int
name|amt
decl_stmt|;
specifier|static
name|int
name|is_reset
init|=
literal|0
decl_stmt|;
name|char
name|bigbuff
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|is_reset
condition|)
return|return;
comment|/* ignore multiple resets */
name|print_bitmap
argument_list|()
expr_stmt|;
comment|/* this is the absolute last thing that we do */
comment|/* wrap up the preamble and the body */
name|ip_select
argument_list|(
name|outputfile
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|endBody
argument_list|)
expr_stmt|;
name|ip_select
argument_list|(
name|pagebodyfile
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|endBody
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|endBlock
argument_list|)
expr_stmt|;
name|ip_close
argument_list|()
expr_stmt|;
comment|/* close the body */
comment|/* 	     *  Reopen the body and copy it onto the end of the real file (which is 	     *	where we have been building the preamble).  We don't need to ip_flush 	     *	the preamble since that is done everytime we ip_select the body. 	     *	Conveniently enough, "tempfilename" still holds the name of the body 	     *	temporary. 	     */
name|pagebodyfile
operator|=
name|open
argument_list|(
name|tempfilename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|amt
operator|=
name|read
argument_list|(
name|pagebodyfile
argument_list|,
name|bigbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|bigbuff
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|outputfile
argument_list|,
name|bigbuff
argument_list|,
name|amt
argument_list|)
expr_stmt|;
block|}
comment|/* close and unlink the body temporary file */
operator|(
name|void
operator|)
name|close
argument_list|(
name|pagebodyfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempfilename
argument_list|)
expr_stmt|;
comment|/* send the file off to the printer */
name|tempfilename
index|[
name|strlen
argument_list|(
name|tempfilename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|outputfile
operator|!=
literal|1
condition|)
block|{
name|IPprint
argument_list|(
name|tempfilename
argument_list|)
expr_stmt|;
block|}
comment|/* we are now reset */
name|is_reset
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|outputString
argument_list|(
argument|character
argument_list|)
end_macro

begin_comment
comment|/* print a "funny" character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|outputflag
condition|)
return|return;
if|if
condition|(
name|dbg
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\\(%s"
argument_list|,
name|character
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|3
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|device
operator|.
name|spec_char_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|specCharStrTab
index|[
name|specCharTab
index|[
name|i
index|]
index|]
argument_list|,
name|character
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|device
operator|.
name|spec_char_num
condition|)
block|{
comment|/*	printf(" i = %d so i+128 = %d\n", i, i+128);	*/
name|outputChar
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|i
operator|+
literal|128
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dbg
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"-- character not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbg
operator|>
literal|2
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|outputChar
argument_list|(
argument|character
argument_list|)
end_macro

begin_comment
comment|/* put a character */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|widp
decl_stmt|;
comment|/* pointer to appropriate width table */
specifier|register
name|char
modifier|*
name|codep
decl_stmt|;
comment|/* pointer to appropriate table of codes */
specifier|register
name|int
name|i
decl_stmt|,
name|old_font
decl_stmt|,
name|fnt_index
decl_stmt|;
name|int
name|j
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|outputflag
condition|)
return|return;
if|if
condition|(
name|character
operator|<=
literal|32
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"non-existent character 0%o\n"
argument_list|,
name|character
argument_list|)
expr_stmt|;
name|charw
operator|=
name|charWidthTab
index|[
name|font
index|]
index|[
literal|0
index|]
operator|*
name|pointsizeTab
index|[
name|size
operator|-
literal|1
index|]
operator|/
name|device
operator|.
name|width_units
expr_stmt|;
return|return;
block|}
name|character
operator|-=
literal|32
expr_stmt|;
name|old_font
operator|=
name|font
expr_stmt|;
name|i
operator|=
name|fontIndexTab
index|[
name|font
index|]
index|[
name|character
index|]
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
comment|/* it's on this font */
block|{
name|codep
operator|=
name|charCodeTab
index|[
name|font
index|]
expr_stmt|;
name|widp
operator|=
name|charWidthTab
index|[
name|font
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specFontPos
operator|>
literal|0
condition|)
comment|/* on special (we hope) */
block|{
comment|/* assertion:  i == 0 */
name|fnt_index
operator|=
name|specFontPos
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|device
operator|.
name|num_fonts
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|font_entry
modifier|*
name|fb
decl_stmt|;
name|fnt_index
operator|=
operator|(
name|fnt_index
operator|+
literal|1
operator|)
operator|%
operator|(
name|device
operator|.
name|num_fonts
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|fb
operator|=
name|fontPtr
index|[
name|fnt_index
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fb
operator|->
name|special_flag
operator|&&
operator|(
name|i
operator|=
name|fontIndexTab
index|[
name|fnt_index
index|]
index|[
name|character
index|]
operator|&
literal|255
operator|)
operator|!=
literal|0
condition|)
block|{
name|codep
operator|=
name|charCodeTab
index|[
name|fnt_index
index|]
expr_stmt|;
name|widp
operator|=
name|charWidthTab
index|[
name|fnt_index
index|]
expr_stmt|;
name|setFont
argument_list|(
name|fnt_index
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* assertion:  if j> device.num_fonts then i == 0 and character was not found */
block|}
name|value
operator|=
name|codep
index|[
name|i
index|]
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"character not found 0%o\n"
argument_list|,
name|character
operator|+
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* remember this character's width */
comment|/* This MUST be done before calling showchar */
name|charw
operator|=
operator|(
name|widp
index|[
name|i
index|]
operator|*
name|pointsizeTab
index|[
name|size
operator|-
literal|1
index|]
operator|+
name|device
operator|.
name|width_units
operator|/
literal|2
operator|)
operator|/
name|device
operator|.
name|width_units
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|character
operator|+
literal|32
argument_list|)
condition|)
name|putchar
argument_list|(
name|character
operator|+
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbg
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|character
operator|+
literal|32
argument_list|)
condition|)
name|printf
argument_list|(
literal|"character %c %d\n"
argument_list|,
name|character
operator|+
literal|32
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"character %03o %d\n"
argument_list|,
name|character
operator|+
literal|32
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
literal|0377
condition|)
block|{
comment|/* special escape to an extended code */
name|value
operator|=
name|getexcode
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbg
operator|<
literal|6
condition|)
name|showchar
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|!=
name|old_font
condition|)
block|{
name|setFont
argument_list|(
name|old_font
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setPointSize
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set point size to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal value:  index into pointsizeTab */
end_comment

begin_block
block|{
name|size
operator|=
name|n
expr_stmt|;
name|ftsz
operator|=
operator|(
operator|(
name|long
operator|)
name|font
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|size
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|setFont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set font to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal index */
end_comment

begin_block
block|{
name|font
operator|=
name|n
expr_stmt|;
name|ftsz
operator|=
operator|(
operator|(
name|long
operator|)
name|font
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|size
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	reportError	an error reporting hack that uses dummy parameters   *			as place holders for arguments that may or may not   *			exist, fprintf will sort out how many should be there  */
end_comment

begin_comment
comment|/*VARARGS 2*/
end_comment

begin_macro
name|reportError
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|,
argument|arg6
argument_list|,
argument|arg7
argument_list|,
argument|arg8
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|,
modifier|*
name|arg5
decl_stmt|,
modifier|*
name|arg6
decl_stmt|,
modifier|*
name|arg7
decl_stmt|,
modifier|*
name|arg8
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dipress: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|,
name|arg8
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nerror encountered near line %d\n"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|QUIT
condition|)
name|goodbye
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Graphics drawing primitives.  These use the vector drawing capabilities of  *  interpress to draw straight lines.  All other primitive objects (circle,  *  ellipse, etc.) are built in a bitmap and printed with a pixel vector.  */
end_comment

begin_macro
name|drawline
argument_list|(
argument|dh
argument_list|,
argument|dv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dh
decl_stmt|,
name|dv
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|outputflag
condition|)
return|return;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|curr_strokewidth
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|I_strokeWidth
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|iset
argument_list|)
expr_stmt|;
name|Moveto
argument_list|(
name|xloc
argument_list|(
name|hor_pos
argument_list|)
argument_list|,
name|yloc
argument_list|(
name|ver_pos
argument_list|)
argument_list|)
expr_stmt|;
name|hor_pos
operator|+=
name|dh
expr_stmt|;
name|ver_pos
operator|+=
name|dv
expr_stmt|;
name|Lineto
argument_list|(
name|xloc
argument_list|(
name|hor_pos
argument_list|)
argument_list|,
name|yloc
argument_list|(
name|ver_pos
argument_list|)
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|maskstroke
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* routines used by interpress dependent routines */
end_comment

begin_decl_stmt
name|char
name|showbuff
index|[
name|Showbuff_size
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|showp
init|=
name|showbuff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|showcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|showchar
argument_list|(
argument|ch
argument_list|)
end_macro

begin_comment
comment|/* buffer "ch" for use in a "show" command */
end_comment

begin_decl_stmt
name|int
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|framep
decl_stmt|;
specifier|register
name|int
name|hdiff
decl_stmt|,
name|vdiff
decl_stmt|;
comment|/* set correct position */
name|vdiff
operator|=
name|ver_pos
operator|-
name|old_ver
expr_stmt|;
name|hdiff
operator|=
name|hor_pos
operator|-
name|old_hor
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"old_hor %d, hor_pos %d, hdiff %d;  old_ver %d, ver_pos %d, vdiff %d %s\n"
argument_list|,
name|old_hor
argument_list|,
name|hor_pos
argument_list|,
name|hdiff
argument_list|,
name|old_ver
argument_list|,
name|ver_pos
argument_list|,
name|vdiff
argument_list|,
name|virgin_line
condition|?
literal|"(virgin)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* NOTE:  this expression depends on boolean true being 1! */
comment|/* See K&R, Appendix A, section 7.7, page 190 */
if|if
condition|(
name|ch
operator|==
literal|'_'
condition|)
goto|goto
name|underbar
goto|;
switch|switch
condition|(
operator|(
operator|(
name|vdiff
operator|!=
literal|0
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|hdiff
operator|!=
literal|0
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* no change */
break|break;
default|default:
name|underbar
label|:
name|flushbuff
argument_list|()
expr_stmt|;
name|Setxy
argument_list|(
name|xloc
argument_list|(
name|hor_pos
argument_list|)
argument_list|,
name|yloc
argument_list|(
name|ver_pos
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	     *  Update old_hor and old_ver.  Account for character width in old_hor but not in 	     *	hor_pos.  If the next hInc call is for the width of the character, the 	     *	next time showchar gets called, old_hor will equal hor_pos. 	     */
name|old_ver
operator|=
name|ver_pos
expr_stmt|;
name|old_hor
operator|=
name|hor_pos
operator|+
name|charw
expr_stmt|;
comment|/* line is no longer virgin */
name|virgin_line
operator|=
literal|0
expr_stmt|;
comment|/* font and point still the same? */
if|if
condition|(
name|ftsz
operator|!=
name|oldftsz
condition|)
block|{
name|flushbuff
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|framep
operator|=
name|currfonts
index|[
name|font
index|]
operator|->
name|frames
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* previously unused -- give it a frame table */
name|framep
operator|=
name|currfonts
index|[
name|font
index|]
operator|->
name|frames
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|device
operator|.
name|num_sizes
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|framep
argument_list|,
name|device
operator|.
name|num_sizes
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|framep
index|[
name|size
index|]
operator|==
literal|0
condition|)
block|{
comment|/* make a new font */
name|ip_select
argument_list|(
name|outputfile
argument_list|)
expr_stmt|;
name|SetupFont
argument_list|(
name|currfonts
index|[
name|font
index|]
operator|->
name|uname
argument_list|,
name|floor
argument_list|(
name|pointsizeTab
index|[
name|size
operator|-
literal|1
index|]
operator|*
literal|35.28
operator|+
literal|.5
argument_list|)
argument_list|,
name|frameindex
argument_list|)
expr_stmt|;
name|ip_select
argument_list|(
name|pagebodyfile
argument_list|)
expr_stmt|;
name|framep
index|[
name|size
index|]
operator|=
name|frameindex
operator|++
expr_stmt|;
block|}
comment|/* switch to new font/size combo */
name|Setfont
argument_list|(
name|framep
index|[
name|size
index|]
argument_list|)
expr_stmt|;
name|oldftsz
operator|=
name|ftsz
expr_stmt|;
block|}
comment|/* adjust for character codes> 0377 */
if|if
condition|(
name|ch
operator|>
literal|0377
condition|)
block|{
if|if
condition|(
name|dbg
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"processing large code: 0%o (%d)\n"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|showcnt
operator|+
literal|5
operator|>
name|Showbuff_size
condition|)
block|{
name|flushbuff
argument_list|()
expr_stmt|;
block|}
operator|*
name|showp
operator|++
operator|=
literal|'\377'
expr_stmt|;
operator|*
name|showp
operator|++
operator|=
operator|(
name|ch
operator|&
literal|0177400
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|showp
operator|++
operator|=
name|ch
operator|&
literal|255
expr_stmt|;
operator|*
name|showp
operator|++
operator|=
literal|'\377'
expr_stmt|;
operator|*
name|showp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|showcnt
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
operator|*
name|showp
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|++
name|showcnt
operator|>
name|Showbuff_size
condition|)
block|{
name|flushbuff
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *  getexcode(findex) - get the extended code for the character "findex"  */
end_comment

begin_macro
name|getexcode
argument_list|(
argument|findex
argument_list|)
end_macro

begin_decl_stmt
name|int
name|findex
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|extfd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|tab
decl_stmt|;
name|char
name|temp
index|[
literal|132
index|]
decl_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"getexcode(%d)\n"
argument_list|,
name|findex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tab
operator|=
name|currfonts
index|[
name|font
index|]
operator|->
name|extab
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* load in the extended code table */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/%s.out.ext"
argument_list|,
name|fontdirectory
argument_list|,
name|devicename
argument_list|,
name|currfonts
index|[
name|font
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"opening and reading %s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|extfd
operator|=
name|open
argument_list|(
name|temp
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|reportError
argument_list|(
name|CONTINUE
argument_list|,
literal|"can't open %s (%s)"
argument_list|,
name|temp
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|currfonts
index|[
name|font
index|]
operator|->
name|extab
operator|=
name|tab
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|=
operator|(
name|device
operator|.
name|spec_char_num
operator|+
literal|128
operator|-
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|extfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* should test result! */
operator|(
name|void
operator|)
name|close
argument_list|(
name|extfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbg
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"getexcode returning %.7o\n"
argument_list|,
name|tab
index|[
name|findex
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tab
index|[
name|findex
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|flushbuff
argument_list|()
end_macro

begin_comment
comment|/* flush and reset "showbuff" */
end_comment

begin_block
block|{
if|if
condition|(
name|showcnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|in_correct
condition|)
block|{
name|startcorrect
argument_list|()
expr_stmt|;
block|}
comment|/* we must do the append_Sequence explicitly, */
comment|/* because showbuff might have nulls in it.   */
name|append_Sequence
argument_list|(
name|sequenceString
argument_list|,
name|showcnt
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|showbuff
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|show
argument_list|)
expr_stmt|;
name|showp
operator|=
name|showbuff
expr_stmt|;
name|showcnt
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|hstart
decl_stmt|;
end_decl_stmt

begin_macro
name|startcorrect
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|CORRECT_BLOCKS
name|Op
argument_list|(
name|correct
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|beginBody
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in_correct
operator|=
literal|1
expr_stmt|;
name|hstart
operator|=
name|hor_pos
expr_stmt|;
block|}
end_block

begin_macro
name|endcorrect
argument_list|()
end_macro

begin_block
block|{
comment|/* append a Setcorrectmeasure operation */
comment|/* "hor_pos" or "old_hor"???  Make it "old_hor" for now */
ifdef|#
directive|ifdef
name|CORRECT_BLOCKS
name|Setcorrectmeasure
argument_list|(
name|xloc
argument_list|(
name|old_hor
argument_list|)
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|endBody
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in_correct
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  IPprint(filename) - send the file "filename" to the interpress printer.  *			 This routine is *very* dependent on local  *			 environments.  */
end_comment

begin_macro
name|IPprint
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dbg
condition|)
block|{
name|printf
argument_list|(
literal|"interpress file saved in %s.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vfork
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* is child */
name|execl
argument_list|(
literal|"/usr/local/bin/qip"
argument_list|,
literal|"qip"
argument_list|,
literal|"-nc"
argument_list|,
literal|"-nk"
argument_list|,
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* bitmap graphics object sizing functions */
end_comment

begin_macro
name|g_sizearc
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|xc
argument_list|,
argument|yc
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|xc
decl_stmt|,
name|yc
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|minx
decl_stmt|;
name|int
name|miny
decl_stmt|;
name|int
name|maxx
decl_stmt|;
name|int
name|maxy
decl_stmt|;
name|int
name|quad1
decl_stmt|;
name|int
name|quad2
decl_stmt|;
name|int
name|radius
decl_stmt|;
name|int
name|axc
decl_stmt|;
name|int
name|ayc
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* the center and the second point are offsets from the first */
comment|/* calculate actual center and radius */
name|axc
operator|=
name|x1
operator|+
name|xc
expr_stmt|;
name|ayc
operator|=
name|y1
operator|+
name|yc
expr_stmt|;
name|radius
operator|=
call|(
name|int
call|)
argument_list|(
name|hypot
argument_list|(
operator|(
name|double
operator|)
name|xc
argument_list|,
operator|(
name|double
operator|)
name|yc
argument_list|)
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"g_sizearc(%d, %d, %d, %d, %d, %d): radius is %d\n"
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|radius
argument_list|)
expr_stmt|;
block|}
comment|/* preset the minmal and maximal points -- this is our first guess */
if|if
condition|(
operator|(
name|minx
operator|=
name|x1
operator|+
name|xc
operator|+
name|x2
operator|)
operator|>
name|x1
condition|)
block|{
name|maxx
operator|=
name|minx
expr_stmt|;
name|minx
operator|=
name|x1
expr_stmt|;
block|}
else|else
block|{
name|maxx
operator|=
name|x1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|miny
operator|=
name|y1
operator|+
name|yc
operator|+
name|y2
operator|)
operator|>
name|y1
condition|)
block|{
name|maxy
operator|=
name|miny
expr_stmt|;
name|miny
operator|=
name|y1
expr_stmt|;
block|}
else|else
block|{
name|maxy
operator|=
name|y1
expr_stmt|;
block|}
comment|/* calculate the offset from the center to the first point */
name|x1
operator|=
operator|-
name|xc
expr_stmt|;
name|y1
operator|=
operator|-
name|yc
expr_stmt|;
comment|/* now all three arguments are offsets */
comment|/* calculate the quadrant of each endpoint */
name|quad1
operator|=
name|quadrant
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|quad2
operator|=
name|quadrant
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"(%d, %d) in quadrant %d ... "
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|quad1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%d, %d) in quadrant %d\n"
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|quad2
argument_list|)
expr_stmt|;
block|}
comment|/* insure that quad1< quad2 */
if|if
condition|(
name|quad2
operator|<
name|quad1
condition|)
block|{
name|quad2
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* compensate for arc at each quadrant boundary */
for|for
control|(
name|i
operator|=
name|quad1
operator|+
literal|1
init|;
name|i
operator|<=
name|quad2
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|/* 1st quadrant */
name|maxx
operator|=
name|axc
operator|+
name|radius
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 2nd quadrant */
name|miny
operator|=
name|ayc
operator|-
name|radius
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 3rd quadrant */
name|minx
operator|=
name|axc
operator|-
name|radius
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 4th quadrant */
name|maxy
operator|=
name|ayc
operator|+
name|radius
expr_stmt|;
break|break;
block|}
block|}
comment|/* now set the extremes */
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"extremes are %d, %d, %d, %d\n"
argument_list|,
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
argument_list|,
name|maxy
argument_list|)
expr_stmt|;
block|}
name|gobj_size
argument_list|(
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
argument_list|,
name|maxy
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|quadrant
argument_list|(
argument|dx
argument_list|,
argument|dy
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|yplus
decl_stmt|;
name|yplus
operator|=
name|dy
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|yplus
condition|?
literal|3
else|:
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|yplus
condition|?
literal|2
else|:
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|g_sizeWigglyLine
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|minx
decl_stmt|;
name|int
name|miny
decl_stmt|;
name|int
name|maxx
decl_stmt|;
name|int
name|maxy
decl_stmt|;
name|int
name|currx
decl_stmt|;
name|int
name|curry
decl_stmt|;
name|int
name|incx
decl_stmt|;
name|int
name|incy
decl_stmt|;
name|currx
operator|=
name|minx
operator|=
name|maxx
operator|=
name|hor_pos
expr_stmt|;
name|curry
operator|=
name|miny
operator|=
name|maxy
operator|=
name|ver_pos
expr_stmt|;
while|while
condition|(
name|white
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
comment|/* trim leading white space */
while|while
condition|(
operator|*
name|str
condition|)
block|{
operator|(
name|void
operator|)
name|readNumber
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|incx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|readNumber
argument_list|(
operator|&
name|str
argument_list|,
operator|&
name|incy
argument_list|)
expr_stmt|;
name|currx
operator|+=
name|incx
expr_stmt|;
name|curry
operator|+=
name|incy
expr_stmt|;
if|if
condition|(
name|currx
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|currx
expr_stmt|;
elseif|else
if|if
condition|(
name|currx
operator|<
name|minx
condition|)
name|minx
operator|=
name|currx
expr_stmt|;
if|if
condition|(
name|curry
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|curry
expr_stmt|;
elseif|else
if|if
condition|(
name|curry
operator|<
name|miny
condition|)
name|miny
operator|=
name|curry
expr_stmt|;
block|}
name|gobj_size
argument_list|(
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
argument_list|,
name|maxy
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

