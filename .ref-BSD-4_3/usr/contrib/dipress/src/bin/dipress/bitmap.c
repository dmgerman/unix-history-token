begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  bitmap - routines that help build a bitmap of a graphical image  *  *  These are primarily used to implement all of the drawing primitives  *  (except for lines)  *  *  History:  *28-aug-85 John Mellor-Crummey	added flush_bitmap which is used instead  *				of print_bitmap if current page is not outputted  *  *	17-jun-85  ed flint	bitmap width(bm_width) must be multiple of 32  *				bits for print services 12 (?)  *  * Copyright (c) 1984, 1985 Xerox Corp.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_include
include|#
directive|include
file|"literal.h"
end_include

begin_include
include|#
directive|include
file|"operator.h"
end_include

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_define
define|#
directive|define
name|No
value|0
end_define

begin_define
define|#
directive|define
name|Yes
value|1
end_define

begin_define
define|#
directive|define
name|INCH
value|2540
end_define

begin_comment
comment|/* micas per inch */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|drawidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|drawscale
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|local
name|int
name|minx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|miny
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|maxx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|maxy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|bm_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in real bytes */
end_comment

begin_decl_stmt
name|local
name|int
name|bm_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|char
modifier|*
name|bitmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|char
modifier|*
name|bm_prelude
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|char
name|bm_active
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|scale_x
parameter_list|(
name|x
parameter_list|)
value|x = (double)x * drawscale
end_define

begin_define
define|#
directive|define
name|scale_y
parameter_list|(
name|y
parameter_list|)
value|y = (double)y * drawscale
end_define

begin_comment
comment|/*  *  new_bitmap(x1, y1, x2, y2) - prepare for a new bitmap, the extreme x and y  *				 values are x1, y1, x2, and y2.  */
end_comment

begin_macro
name|new_bitmap
argument_list|(
argument|stroke
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|stroke
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|new_size
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"new_bitmap(%d, %d, %d, %d, %d)\n"
argument_list|,
name|stroke
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|drawidth
operator|=
name|stroke
operator|*
name|drawscale
expr_stmt|;
name|scale_x
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|scale_y
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|scale_x
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|scale_y
argument_list|(
name|y2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"after scaling: width %d: %d, %d and %d, %d\n"
argument_list|,
name|drawidth
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* insure that x1, y1 is the lower left */
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exchanging pairs ... "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|x1
expr_stmt|;
comment|/* exchange x1 and x2 */
name|x1
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|y1
expr_stmt|;
comment|/* exchange y1 and y2 */
name|y1
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|temp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"now %d, %d and %d, %d\n"
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* adjust the extremes to allow for pen thickness */
name|temp
operator|=
operator|(
name|drawidth
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|x1
operator|-=
name|temp
expr_stmt|;
name|y1
operator|-=
name|temp
expr_stmt|;
name|x2
operator|+=
name|temp
expr_stmt|;
name|y2
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|bm_active
operator|||
operator|!
operator|(
name|x1
operator|>=
name|minx
operator|&&
name|y1
operator|>=
name|miny
operator|&&
name|x2
operator|<=
name|maxx
operator|&&
name|y2
operator|<=
name|maxy
operator|)
condition|)
block|{
comment|/* we need to set up a new map */
comment|/* but first, print the old one if it is still active */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setting up new map, bm_active is %d\n"
argument_list|,
name|bm_active
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_bitmap
argument_list|()
expr_stmt|;
name|minx
operator|=
name|x1
expr_stmt|;
name|miny
operator|=
name|y1
expr_stmt|;
name|maxx
operator|=
name|x2
expr_stmt|;
name|maxy
operator|=
name|y2
expr_stmt|;
name|bm_width
operator|=
operator|(
name|y2
operator|-
name|y1
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* print services 12 (?) wants packed pixel vectors to produce each */
comment|/* scan line as a mutliple of 32 bits, this is backward compatible  */
comment|/* with previous versions of services				    */
comment|/* (the previous version of bitmap produced 16 bit multiples which  */
comment|/* will NOT work with services 12 (?) and beyond)		    */
if|if
condition|(
name|bm_width
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
name|bm_width
operator|=
name|bm_width
operator|+
operator|(
literal|4
operator|-
name|bm_width
operator|%
literal|4
operator|)
expr_stmt|;
block|}
name|new_size
operator|=
operator|(
name|x2
operator|-
name|x1
operator|)
operator|*
name|bm_width
expr_stmt|;
if|if
condition|(
name|new_size
operator|>
name|bm_size
condition|)
block|{
comment|/* need to allocate a larger area for the bitmap */
if|if
condition|(
name|bitmap
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
block|}
comment|/* leave space for the ppv prelude (leading 4 bytes) */
name|bm_prelude
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|new_size
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap
operator|=
name|bm_prelude
operator|+
literal|4
expr_stmt|;
name|bm_size
operator|=
name|new_size
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bm_width %d, bm_size %d\n"
argument_list|,
name|bm_width
argument_list|,
name|bm_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|bitmap
argument_list|,
name|bm_size
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|set_pixel
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mask
decl_stmt|;
name|int
name|half_drawidth
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ybit
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|scale_x
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|scale_y
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|bm_active
operator|=
name|Yes
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|x
operator|<
name|minx
operator|||
name|x
operator|>
name|maxx
operator|||
name|y
operator|<
name|miny
operator|||
name|y
operator|>
name|maxy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"point off map: (%d, %d)\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|x
operator|-=
name|minx
expr_stmt|;
name|y
operator|=
name|maxy
operator|-
name|y
expr_stmt|;
comment|/* yes, it works */
name|half_drawidth
operator|=
name|drawidth
operator|>>
literal|1
expr_stmt|;
comment|/* Remember the bitmap is built in increasing y */
comment|/* draw the "x" line vertically */
name|mask
operator|=
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|007
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|x
operator|-
name|half_drawidth
operator|)
operator|*
name|bm_width
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
operator|+
name|bitmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|drawidth
condition|;
name|i
operator|++
operator|,
name|ptr
operator|+=
name|bm_width
control|)
block|{
operator|*
name|ptr
operator||=
name|mask
expr_stmt|;
block|}
comment|/* draw the "y" line horizontally */
name|y
operator|-=
name|half_drawidth
expr_stmt|;
name|ptr
operator|=
operator|(
name|x
operator|*
name|bm_width
operator|)
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
operator|+
name|bitmap
expr_stmt|;
name|ybit
operator|=
name|y
operator|&
literal|007
expr_stmt|;
name|temp
operator|=
name|ybit
operator|+
name|drawidth
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|8
condition|)
block|{
comment|/* special case -- less than one byte */
operator|*
name|ptr
operator||=
operator|(
literal|0xff
operator|>>
name|ybit
operator|)
operator|^
operator|(
literal|0xff
operator|>>
name|temp
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator||=
operator|(
literal|0xff
operator|>>
name|ybit
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|drawidth
operator|-
literal|8
operator|+
name|ybit
init|;
name|i
operator|>
literal|8
condition|;
name|i
operator|-=
literal|8
control|)
block|{
operator|*
operator|++
name|ptr
operator||=
literal|0xff
expr_stmt|;
block|}
operator|*
operator|++
name|ptr
operator||=
operator|~
operator|(
literal|0xff
operator|>>
name|i
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|flush_bitmap
argument_list|()
end_macro

begin_block
block|{
name|bm_active
operator|=
name|No
expr_stmt|;
block|}
end_block

begin_macro
name|print_bitmap
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|prelude
init|=
name|bm_prelude
decl_stmt|;
name|int
name|totalbits
decl_stmt|,
name|size
decl_stmt|,
name|bm_xdelta
decl_stmt|,
name|bm_x
init|=
name|minx
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bm_active
condition|)
block|{
comment|/* don't bother */
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG2
comment|/* debugging version for now */
name|ptr
operator|=
name|bitmap
expr_stmt|;
for|for
control|(
name|x
operator|=
name|minx
init|;
name|x
operator|<=
name|maxx
condition|;
name|x
operator|++
control|)
block|{
for|for
control|(
name|y
operator|=
name|miny
init|;
name|y
operator|<=
name|maxy
condition|;
name|y
operator|+=
literal|8
operator|,
name|ptr
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0x80
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|&
name|i
condition|)
block|{
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* The following is conservative (might actually be twice as big) */
define|#
directive|define
name|MAXPPVSAMPS
value|262144
name|bm_xdelta
operator|=
name|maxx
operator|-
name|minx
expr_stmt|;
name|bits
operator|=
name|bm_width
operator|<<
literal|3
expr_stmt|;
comment|/* (* 8) */
name|totalbits
operator|=
name|bits
operator|*
name|bm_xdelta
expr_stmt|;
if|if
condition|(
name|totalbits
operator|>
name|MAXPPVSAMPS
condition|)
block|{
name|bm_xdelta
operator|=
name|MAXPPVSAMPS
operator|/
name|bits
expr_stmt|;
block|}
while|while
condition|(
name|bm_x
operator|<
name|maxx
condition|)
block|{
comment|/* Check for last time through loop */
if|if
condition|(
name|bm_xdelta
operator|>
operator|(
name|maxx
operator|-
name|bm_x
operator|)
condition|)
block|{
name|bm_xdelta
operator|=
name|maxx
operator|-
name|bm_x
expr_stmt|;
block|}
name|size
operator|=
operator|(
name|bits
operator|*
name|bm_xdelta
operator|)
operator|>>
literal|3
expr_stmt|;
comment|/* Could hand optimize! */
comment|/* inside a dosavesimplebody to preserve transform */
name|Op
argument_list|(
name|dosavesimplebody
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|beginBody
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|bm_xdelta
argument_list|)
expr_stmt|;
comment|/* xPixels */
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|bits
argument_list|)
expr_stmt|;
comment|/* yPixels */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* samplesPerPixel */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* maxSampleValue */
name|AppendInteger
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
comment|/* samplesInterleaved */
name|Translate
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
comment|/* (null) transform */
comment|/* spew out the packed pixel vector */
name|prelude
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prelude
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|prelude
index|[
literal|2
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|bits
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* high order byte */
name|prelude
index|[
literal|3
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|bits
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
comment|/* low  order byte */
name|append_Sequence
argument_list|(
name|sequencePackedPixelVector
argument_list|,
name|size
operator|+
literal|4
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|prelude
argument_list|)
expr_stmt|;
comment|/* make the pixel array */
name|Op
argument_list|(
name|makepixelarray
argument_list|)
expr_stmt|;
comment|/* set the transform to the right scale and position */
comment|/* transform must scale back to micas and position bitmap */
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|bm_x
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
call|(
name|long
call|)
argument_list|(
operator|(
literal|11
operator|*
name|INCH
operator|*
name|drawscale
operator|)
operator|-
name|maxy
argument_list|)
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|translate
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|5L
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|concat
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|concatt
argument_list|)
expr_stmt|;
comment|/* mask it and finish the simple-body */
name|Op
argument_list|(
name|maskpixel
argument_list|)
expr_stmt|;
name|Op
argument_list|(
name|endBody
argument_list|)
expr_stmt|;
name|prelude
operator|+=
name|size
expr_stmt|;
name|bm_x
operator|+=
name|bm_xdelta
expr_stmt|;
block|}
comment|/* no longer active, now is it? */
name|bm_active
operator|=
name|No
expr_stmt|;
block|}
end_block

end_unit

