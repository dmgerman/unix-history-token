begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)addnode.c	8.1 (down!honey) 86/01/19"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_decl_stmt
specifier|extern
name|void
name|lowercase
argument_list|()
decl_stmt|,
name|rehash
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|node
modifier|*
name|isprivate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|hash
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * these numbers are chosen because:  *	-> they are prime,  *	-> they are monotonic increasing,  *	-> each is a tad smaller than a multiple of 1024,  *	-> they form a fibonacci sequence (almost).  * the first point yields good hash functions, the second is used for the  * standard re-hashing implementation of open addressing, the third  * optimizes for quirks in some mallocs i have seen, and the fourth simply  * appeals to me.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Primes
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|SQUANDER
literal|1021
block|,
literal|2039
block|,
literal|3067
block|,
literal|5113
block|,
literal|8179
block|,
endif|#
directive|endif
literal|13309
block|,
literal|21499
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Tabindex
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Collision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mark host name collisions in hash() */
end_comment

begin_function
name|node
modifier|*
name|addnode
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|Iflag
condition|)
name|lowercase
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* is it a private host? */
name|n
operator|=
name|isprivate
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|i
operator|=
name|hash
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|i
index|]
condition|)
return|return
operator|(
name|Table
index|[
name|i
index|]
operator|)
return|;
name|n
operator|=
name|newnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|n_name
operator|=
name|strsave
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Table
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|i
expr_stmt|;
comment|/* essentially a back link to the table */
if|if
condition|(
name|Collision
condition|)
name|n
operator|->
name|n_flag
operator||=
name|COLLISION
expr_stmt|;
comment|/* name collision with private host */
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_macro
name|alias
argument_list|(
argument|n1
argument_list|,
argument|n2
argument_list|)
end_macro

begin_decl_stmt
name|node
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|;
specifier|extern
name|link
modifier|*
name|addlink
parameter_list|()
function_decl|;
name|l
operator|=
name|addlink
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
operator|(
name|Cost
operator|)
literal|0
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|LALIAS
expr_stmt|;
name|l
operator|=
name|addlink
argument_list|(
name|n2
argument_list|,
name|n1
argument_list|,
operator|(
name|Cost
operator|)
literal|0
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|LALIAS
expr_stmt|;
if|if
condition|(
name|Tflag
condition|)
name|atrace
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * fold a string into a long int.  this algorithm ignores all but the last  * eight bytes, which affects< 15% of all host names, many of which have  * common prefixes anyway.  */
end_comment

begin_function
name|STATIC
name|long
name|fold
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|long
name|sum
decl_stmt|;
name|sum
operator|=
operator|*
name|str
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
name|sum
operator|<<=
literal|4
expr_stmt|;
name|sum
operator|+=
operator|*
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|<
literal|0
condition|)
name|sum
operator|=
operator|-
name|sum
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HASH1
parameter_list|(
name|n
parameter_list|)
value|((n) % Tabsize);
end_define

begin_define
define|#
directive|define
name|HASH2
parameter_list|(
name|n
parameter_list|)
value|(Tabsize - 2 - ((n) % (Tabsize-2)))
end_define

begin_comment
comment|/* princeton!rs */
end_comment

begin_comment
comment|/*  * with a 0.75 high water mark, probes per access should be 1.84.  * use long constant to force promotion.  */
end_comment

begin_define
define|#
directive|define
name|HIGHWATER
value|75L
end_define

begin_define
define|#
directive|define
name|isfull
parameter_list|(
name|n
parameter_list|,
name|size
parameter_list|)
value|((n)> ((size) * HIGHWATER) / 100)
end_define

begin_function
name|STATIC
name|long
name|hash
parameter_list|(
name|name
parameter_list|,
name|unique
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|long
name|probe
decl_stmt|,
name|hash2
decl_stmt|;
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|Tabindex
operator|<
literal|0
condition|)
block|{
comment|/* first time */
name|Tabindex
operator|=
literal|0
expr_stmt|;
name|Tabsize
operator|=
name|Primes
index|[
literal|0
index|]
expr_stmt|;
name|Table
operator|=
name|newtable
argument_list|(
name|Tabsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isfull
argument_list|(
name|Ncount
argument_list|,
name|Tabsize
argument_list|)
condition|)
name|rehash
argument_list|()
expr_stmt|;
comment|/* more, more! */
name|probe
operator|=
name|fold
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* don't change the order of the next two lines */
name|hash2
operator|=
name|HASH2
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|probe
operator|=
name|HASH1
argument_list|(
name|probe
argument_list|)
expr_stmt|;
comment|/* thank you! */
comment|/* 	 * probe the hash table. 	 * if unique is set, we require a fresh slot. 	 * otherwise, use double hashing to find either 	 *  (1) an empty slot, or 	 *  (2) a non-private copy of this host name 	 * 	 * as a side effect, if we notice a collision with a private host 	 * we mark the other so that it is skipped at output time. 	 */
name|Collision
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|Table
index|[
name|probe
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|n
operator|->
name|n_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|unique
condition|)
name|n
operator|->
name|n_flag
operator||=
name|COLLISION
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|n_flag
operator|&
name|ISPRIVATE
condition|)
name|Collision
operator|++
expr_stmt|;
else|else
break|break;
comment|/* this is it! */
block|}
name|probe
operator|-=
name|hash2
expr_stmt|;
if|if
condition|(
name|probe
operator|<
literal|0
condition|)
name|probe
operator|+=
name|Tabsize
expr_stmt|;
block|}
return|return
operator|(
name|probe
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|rehash
parameter_list|()
block|{
specifier|register
name|node
modifier|*
modifier|*
name|otable
decl_stmt|,
modifier|*
modifier|*
name|optr
decl_stmt|;
specifier|register
name|long
name|probe
decl_stmt|;
name|long
name|osize
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hashanalyze
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|optr
operator|=
name|Table
operator|+
name|Tabsize
operator|-
literal|1
expr_stmt|;
comment|/* ptr to last */
name|otable
operator|=
name|Table
expr_stmt|;
name|osize
operator|=
name|Tabsize
expr_stmt|;
name|Tabsize
operator|=
name|Primes
index|[
operator|++
name|Tabindex
index|]
expr_stmt|;
if|if
condition|(
name|Tabsize
operator|==
literal|0
condition|)
block|{
comment|/* need more prime numbers */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:> %d hosts\n"
argument_list|,
name|ProgName
argument_list|,
name|Primes
index|[
name|Tabindex
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"rehash into %d\n"
argument_list|,
name|Tabsize
argument_list|)
expr_stmt|;
name|Table
operator|=
name|newtable
argument_list|(
name|Tabsize
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|optr
operator|==
literal|0
condition|)
continue|continue;
comment|/* empty slot in old table */
name|probe
operator|=
name|hash
argument_list|(
operator|(
operator|*
name|optr
operator|)
operator|->
name|n_name
argument_list|,
operator|(
operator|*
name|optr
operator|)
operator|->
name|n_flag
operator|&
name|ISPRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|probe
index|]
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: rehash error\n"
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Table
index|[
name|probe
index|]
operator|=
operator|*
name|optr
expr_stmt|;
operator|(
operator|*
name|optr
operator|)
operator|->
name|n_tloc
operator|=
name|probe
expr_stmt|;
block|}
do|while
condition|(
name|optr
operator|--
operator|>
name|otable
condition|)
do|;
name|freetable
argument_list|(
name|otable
argument_list|,
name|osize
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|hashanalyze
argument_list|()
end_macro

begin_block
block|{
name|long
name|probe
decl_stmt|,
name|hash2
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|collision
index|[
literal|8
index|]
decl_stmt|;
name|int
name|longest
init|=
literal|0
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|,
name|slots
init|=
literal|0
decl_stmt|;
name|int
name|nslots
init|=
sizeof|sizeof
argument_list|(
name|collision
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|collision
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Vflag
condition|)
return|return;
name|strclear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|collision
argument_list|,
sizeof|sizeof
argument_list|(
name|collision
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Tabsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Table
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* private hosts too hard to account for ... */
if|if
condition|(
name|Table
index|[
name|i
index|]
operator|->
name|n_flag
operator|&
name|ISPRIVATE
condition|)
continue|continue;
name|count
operator|=
literal|1
expr_stmt|;
name|probe
operator|=
name|fold
argument_list|(
name|Table
index|[
name|i
index|]
operator|->
name|n_name
argument_list|)
expr_stmt|;
comment|/* don't change the order of the next two lines */
name|hash2
operator|=
name|HASH2
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|probe
operator|=
name|HASH1
argument_list|(
name|probe
argument_list|)
expr_stmt|;
comment|/* thank you! */
while|while
condition|(
name|Table
index|[
name|probe
index|]
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|Table
index|[
name|probe
index|]
operator|->
name|n_name
argument_list|,
name|Table
index|[
name|i
index|]
operator|->
name|n_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|probe
operator|-=
name|hash2
expr_stmt|;
if|if
condition|(
name|probe
operator|<
literal|0
condition|)
name|probe
operator|+=
name|Tabsize
expr_stmt|;
block|}
if|if
condition|(
name|Table
index|[
name|probe
index|]
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: impossible hash error for %s\n"
argument_list|,
name|ProgName
argument_list|,
name|Table
index|[
name|i
index|]
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|total
operator|+=
name|count
expr_stmt|;
name|slots
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|longest
condition|)
name|longest
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|nslots
condition|)
name|count
operator|=
literal|0
expr_stmt|;
name|collision
index|[
name|count
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nslots
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|collision
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d chains: %d (%ld%%)\n"
argument_list|,
name|i
argument_list|,
name|collision
index|[
name|i
index|]
argument_list|,
operator|(
name|collision
index|[
name|i
index|]
operator|*
literal|100L
operator|)
operator|/
name|slots
argument_list|)
expr_stmt|;
if|if
condition|(
name|collision
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"> %d chains: %d (%ld%%)\n"
argument_list|,
name|nslots
operator|-
literal|1
argument_list|,
name|collision
index|[
literal|0
index|]
argument_list|,
operator|(
name|collision
index|[
literal|0
index|]
operator|*
literal|100L
operator|)
operator|/
name|slots
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2.2f probes per access, longest chain: %d\n"
argument_list|,
operator|(
name|double
operator|)
name|total
operator|/
name|slots
argument_list|,
name|longest
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|STATIC
name|void
name|lowercase
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|-=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
comment|/* assumes ASCII */
block|}
do|while
condition|(
operator|*
name|s
operator|++
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * this might have to be recoded for performance if privates catch on  */
end_comment

begin_function
name|STATIC
name|node
modifier|*
name|isprivate
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|Private
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|=
name|n
operator|->
name|n_private
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|n
operator|->
name|n_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|fixprivate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
for|for
control|(
name|n
operator|=
name|Private
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|=
name|next
control|)
block|{
name|n
operator|->
name|n_flag
operator||=
name|ISPRIVATE
expr_stmt|;
comment|/* overkill, but safe */
name|i
operator|=
name|hash
argument_list|(
name|n
operator|->
name|n_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: impossible private node error on %s\n"
argument_list|,
name|ProgName
argument_list|,
name|n
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Table
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|i
expr_stmt|;
comment|/* essentially a back link to the table */
name|next
operator|=
name|n
operator|->
name|n_private
expr_stmt|;
name|n
operator|->
name|n_private
operator|=
literal|0
expr_stmt|;
comment|/* clear for later use */
block|}
name|Private
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|node
modifier|*
name|addprivate
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|Iflag
condition|)
name|lowercase
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|isprivate
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|n
operator|=
name|newnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|n_name
operator|=
name|strsave
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_private
operator|=
name|Private
expr_stmt|;
name|Private
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

