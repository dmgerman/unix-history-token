begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header$ */
end_comment

begin_comment
comment|/*  * Author: Peter J. Nicklin  */
end_comment

begin_comment
comment|/*  * pdtparse() translates an infix project directory boolean type label  * expression to postfix, using operator-precedence parsing. An adjacency  * matrix augments the parsing method by detecting tokens that must not  * be adjacent to one another. Returns NO if syntax error or out of memory,  * otherwise YES.  *  * The maximum size of the input stack used by the parser determines the  * size of the postfix expression evaluation stack.  */
end_comment

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"pdtyp.h"
end_include

begin_include
include|#
directive|include
file|"truefalse.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_define
define|#
directive|define
name|INCRISTAK
value|20
end_define

begin_comment
comment|/* amount to increase input stack */
end_comment

begin_define
define|#
directive|define
name|MAXISTAK
value|20
end_define

begin_comment
comment|/* initial size of input stack */
end_comment

begin_define
define|#
directive|define
name|INCRPEXP
value|40
end_define

begin_comment
comment|/* amount to increase postfix expr */
end_comment

begin_define
define|#
directive|define
name|MAXPEXP
value|40
end_define

begin_comment
comment|/* initial size of postfix expr */
end_comment

begin_define
define|#
directive|define
name|TOKTABSIZE
value|256
end_define

begin_comment
comment|/* token lookup table size */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current type label */
end_comment

begin_decl_stmt
specifier|static
name|int
name|intok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input token */
end_comment

begin_decl_stmt
specifier|static
name|int
name|typlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of current type label */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|istak
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean expression input stack */
end_comment

begin_decl_stmt
specifier|static
name|short
name|toktab
index|[
name|TOKTABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token lookup table */
end_comment

begin_decl_stmt
specifier|static
name|short
name|opr
index|[
literal|7
index|]
index|[
literal|7
index|]
init|=
comment|/* operator precedence relations */
block|{
comment|/*id   !&    |    (    )    B_EOS	*/
block|{
literal|0
block|,
literal|0
block|,
literal|'>'
block|,
literal|'>'
block|,
literal|0
block|,
literal|'>'
block|,
literal|'>'
block|}
block|,
comment|/* id */
block|{
literal|'<'
block|,
literal|0
block|,
literal|'>'
block|,
literal|'>'
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'>'
block|}
block|,
comment|/* ! */
block|{
literal|'<'
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'>'
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'>'
block|}
block|,
comment|/*& */
block|{
literal|'<'
block|,
literal|'<'
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'>'
block|}
block|,
comment|/* | */
block|{
literal|'<'
block|,
literal|'<'
block|,
literal|'<'
block|,
literal|'<'
block|,
literal|'<'
block|,
literal|'='
block|,
literal|0
block|}
block|,
comment|/* ( */
block|{
literal|0
block|,
literal|0
block|,
literal|'>'
block|,
literal|'>'
block|,
literal|0
block|,
literal|'>'
block|,
literal|'>'
block|}
block|,
comment|/* ) */
block|{
literal|'<'
block|,
literal|'<'
block|,
literal|'<'
block|,
literal|'<'
block|,
literal|'<'
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* B_EOS */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|adj
index|[
literal|7
index|]
index|[
literal|7
index|]
init|=
comment|/* token adjacency matrix */
block|{
comment|/*id   !&    |    (    )    B_EOS	*/
block|{
name|NO
block|,
name|NO
block|,
name|YES
block|,
name|YES
block|,
name|NO
block|,
name|YES
block|,
name|YES
block|}
block|,
comment|/* id */
block|{
name|YES
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|}
block|,
comment|/* ! */
block|{
name|YES
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|}
block|,
comment|/*& */
block|{
name|YES
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|}
block|,
comment|/* | */
block|{
name|YES
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|}
block|,
comment|/* ( */
block|{
name|NO
block|,
name|NO
block|,
name|YES
block|,
name|YES
block|,
name|NO
block|,
name|YES
block|,
name|YES
block|}
block|,
comment|/* ) */
block|{
name|YES
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|,
name|YES
block|,
name|NO
block|,
name|NO
block|}
block|,
comment|/* B_EOS */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|pdtparse
argument_list|(
argument|typexpr
argument_list|,
argument|postfix
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|typexpr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean type expression */
end_comment

begin_decl_stmt
name|PDTYP
modifier|*
name|postfix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* postfix expression struct */
end_comment

begin_block
block|{
specifier|register
name|int
name|lastok
decl_stmt|;
comment|/* previous input token */
specifier|register
name|int
name|maxestak
decl_stmt|;
comment|/* maximum size of evaluation stack */
specifier|register
name|int
name|poptok
decl_stmt|;
comment|/* token most recently popped */
specifier|register
name|int
name|pp
decl_stmt|;
comment|/* postfix expression pointer */
specifier|register
name|int
name|toi
decl_stmt|;
comment|/* top-of-input-stack pointer */
specifier|register
name|int
name|toitok
decl_stmt|;
comment|/* topmost token on stack */
name|char
modifier|*
name|getnextok
parameter_list|()
function_decl|;
comment|/* get next type expression token */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* memory allocator */
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
comment|/* reallocate memory block */
name|int
name|maxistak
decl_stmt|;
comment|/* maximum size of input stack */
name|int
name|maxpexp
decl_stmt|;
comment|/* maximum size of postfix expression */
comment|/* initialize token lookup table */
name|toktab
index|[
literal|'\0'
index|]
operator|=
name|B_EOS
expr_stmt|;
name|toktab
index|[
literal|'\t'
index|]
operator|=
name|B_WHITE
expr_stmt|;
name|toktab
index|[
literal|' '
index|]
operator|=
name|B_WHITE
expr_stmt|;
name|toktab
index|[
literal|'&'
index|]
operator|=
name|B_AND
expr_stmt|;
name|toktab
index|[
literal|'|'
index|]
operator|=
name|B_OR
expr_stmt|;
name|toktab
index|[
literal|'!'
index|]
operator|=
name|B_NOT
expr_stmt|;
name|toktab
index|[
literal|'('
index|]
operator|=
name|B_LPAREN
expr_stmt|;
name|toktab
index|[
literal|')'
index|]
operator|=
name|B_RPAREN
expr_stmt|;
comment|/* the rest of the lookup table is B_ID which is 0 */
comment|/* initialize boolean type expression input stack */
name|maxistak
operator|=
name|MAXISTAK
expr_stmt|;
if|if
condition|(
operator|(
name|istak
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|maxistak
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nomemory
goto|;
name|maxestak
operator|=
name|toi
operator|=
literal|0
expr_stmt|;
name|istak
index|[
name|toi
index|]
operator|=
name|B_EOS
expr_stmt|;
comment|/* initialize postfix type expression */
name|maxpexp
operator|=
name|MAXPEXP
expr_stmt|;
if|if
condition|(
operator|(
name|postfix
operator|->
name|pfx
operator|=
operator|(
name|POSTFIX
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|maxpexp
operator|*
sizeof|sizeof
argument_list|(
name|POSTFIX
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nomemory
goto|;
name|pp
operator|=
literal|0
expr_stmt|;
comment|/* get first token */
name|lastok
operator|=
name|B_EOS
expr_stmt|;
name|typexpr
operator|=
name|getnextok
argument_list|(
name|typexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj
index|[
name|lastok
index|]
index|[
name|intok
index|]
operator|==
name|NO
condition|)
goto|goto
name|badsyntax
goto|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|toi
operator|==
literal|0
operator|&&
name|intok
operator|==
name|B_EOS
condition|)
break|break;
comment|/* ACCEPT */
name|toitok
operator|=
name|istak
index|[
name|toi
index|]
expr_stmt|;
if|if
condition|(
name|opr
index|[
name|toitok
index|]
index|[
name|intok
index|]
operator|==
literal|'<'
operator|||
name|opr
index|[
name|toitok
index|]
index|[
name|intok
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* SHIFT current input token onto the stack */
name|toi
operator|++
expr_stmt|;
name|maxestak
operator|=
name|MAX
argument_list|(
name|maxestak
argument_list|,
name|toi
argument_list|)
expr_stmt|;
if|if
condition|(
name|toi
operator|>=
name|maxistak
condition|)
block|{
comment|/* increase input stack size */
name|maxistak
operator|+=
name|INCRISTAK
expr_stmt|;
if|if
condition|(
operator|(
name|istak
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|istak
argument_list|,
operator|(
name|unsigned
operator|)
name|maxistak
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nomemory
goto|;
block|}
name|istak
index|[
name|toi
index|]
operator|=
name|lastok
operator|=
name|intok
expr_stmt|;
name|typexpr
operator|=
name|getnextok
argument_list|(
name|typexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|adj
index|[
name|lastok
index|]
index|[
name|intok
index|]
operator|==
name|NO
condition|)
goto|goto
name|badsyntax
goto|;
block|}
elseif|else
if|if
condition|(
name|opr
index|[
name|toitok
index|]
index|[
name|intok
index|]
operator|==
literal|'>'
condition|)
do|do
block|{
comment|/* REDUCE */
if|if
condition|(
name|pp
operator|>=
name|maxpexp
condition|)
block|{
comment|/* increase postfix expression size */
name|maxpexp
operator|+=
name|INCRPEXP
expr_stmt|;
if|if
condition|(
operator|(
name|postfix
operator|->
name|pfx
operator|=
operator|(
name|POSTFIX
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|postfix
operator|->
name|pfx
argument_list|,
operator|(
name|unsigned
operator|)
name|maxpexp
operator|*
sizeof|sizeof
argument_list|(
name|POSTFIX
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nomemory
goto|;
block|}
switch|switch
condition|(
name|toitok
condition|)
block|{
case|case
name|B_ID
case|:
name|type
index|[
name|typlen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|postfix
operator|->
name|pfx
operator|)
index|[
name|pp
index|]
operator|.
name|p_id
operator|=
name|type
expr_stmt|;
case|case
name|B_AND
case|:
case|case
name|B_OR
case|:
case|case
name|B_NOT
case|:
operator|(
name|postfix
operator|->
name|pfx
operator|)
index|[
name|pp
index|]
operator|.
name|p_class
operator|=
name|toitok
expr_stmt|;
name|pp
operator|++
expr_stmt|;
break|break;
block|}
name|toi
operator|--
expr_stmt|;
name|poptok
operator|=
name|toitok
expr_stmt|;
name|toitok
operator|=
name|istak
index|[
name|toi
index|]
expr_stmt|;
block|}
do|while
condition|(
name|opr
index|[
name|toitok
index|]
index|[
name|poptok
index|]
operator|!=
literal|'<'
condition|)
do|;
else|else
block|{
goto|goto
name|badsyntax
goto|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|istak
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|postfix
operator|->
name|eval
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|maxestak
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nomemory
goto|;
name|postfix
operator|->
name|pfxsize
operator|=
name|pp
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
name|badsyntax
label|:
name|warn
argument_list|(
literal|"type expression syntax error"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|istak
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|postfix
operator|->
name|pfx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
name|nomemory
label|:
name|warn
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * getnextok() identifies the next token in the boolean type expression  * and returns an updated pointer to the expression. `type' points to  * the current type label in the boolean expression.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getnextok
parameter_list|(
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
comment|/* current pointer to type expr */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* type label buffer index */
while|while
condition|(
name|WHITESPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
name|intok
operator|=
name|toktab
index|[
operator|*
name|t
index|]
expr_stmt|;
if|if
condition|(
name|intok
operator|==
name|B_ID
condition|)
block|{
name|type
operator|=
name|t
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|toktab
index|[
operator|*
name|t
index|]
operator|==
name|B_ID
condition|;
name|i
operator|++
operator|,
name|t
operator|++
control|)
continue|continue;
name|typlen
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intok
operator|!=
name|B_EOS
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

end_unit

