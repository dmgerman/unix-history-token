begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header$ */
end_comment

begin_comment
comment|/*  * Author: Peter J. Nicklin  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"path.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_comment
comment|/*  * ispdt() returns 1 if project directory type label is legal,  * otherwise zero.  */
end_comment

begin_macro
name|ispdt
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type label */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* type label pointer */
specifier|register
name|int
name|body
init|=
name|NO
decl_stmt|;
comment|/* does type label have a body? */
for|for
control|(
name|tp
operator|=
name|type
init|;
operator|*
name|tp
operator|!=
literal|'\0'
operator|&&
operator|*
name|tp
operator|!=
literal|'.'
condition|;
name|tp
operator|++
control|)
switch|switch
condition|(
operator|*
name|tp
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
default|default:
name|body
operator|=
name|YES
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|body
operator|==
name|NO
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|tp
operator|==
literal|'.'
condition|)
block|{
name|tp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tp
operator|==
literal|'-'
operator|||
operator|*
name|tp
operator|==
literal|'+'
condition|)
name|tp
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|tp
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|tp
operator|==
literal|'\0'
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * pdtcpy() copies a project directory type pointed to by tb, to type.  * Returns type.  */
end_comment

begin_function
name|char
modifier|*
name|pdtcpy
parameter_list|(
name|type
parameter_list|,
name|tb
parameter_list|)
specifier|register
name|char
modifier|*
name|type
decl_stmt|;
comment|/* receiving type buffer */
specifier|register
name|char
modifier|*
name|tb
decl_stmt|;
comment|/* type pointer */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* type buffer index */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|tb
operator|!=
name|_PDTSC
operator|&&
operator|*
name|tb
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|type
index|[
name|i
index|]
operator|=
operator|*
name|tb
operator|++
expr_stmt|;
name|type
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pdtfind() compares project directory type label type with the type  * labels stored in type label buffer tb and returns a pointer to the  * position of the type label in the buffer if found, otherwise NULL.  */
end_comment

begin_function
name|char
modifier|*
name|pdtfind
parameter_list|(
name|type
parameter_list|,
name|tb
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
comment|/* type label */
specifier|register
name|char
modifier|*
name|tb
decl_stmt|;
comment|/* type label buffer */
block|{
name|char
modifier|*
name|tskip
parameter_list|()
function_decl|;
comment|/* skip to next type label */
name|int
name|tcmp
parameter_list|()
function_decl|;
comment|/* compare type labels */
for|for
control|(
init|;
operator|*
name|tb
operator|!=
literal|'\0'
condition|;
name|tb
operator|=
name|tskip
argument_list|(
name|tb
argument_list|)
control|)
block|{
if|if
condition|(
name|tcmp
argument_list|(
name|type
argument_list|,
name|tb
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tb
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pdtinsert() inserts a type in type label buffer tb. The type labels  * within tb are assumed to be sorted into ascending order. tb must  * be big enough to hold type.  */
end_comment

begin_function
name|void
name|pdtinsert
parameter_list|(
name|type
parameter_list|,
name|tb
parameter_list|)
specifier|register
name|char
modifier|*
name|type
decl_stmt|;
comment|/* type label */
name|char
modifier|*
name|tb
decl_stmt|;
comment|/* type label buffer */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* type label buffer pointer */
name|char
modifier|*
name|tskip
parameter_list|()
function_decl|;
comment|/* skip to next type label */
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
comment|/* string copy */
name|int
name|strlen
parameter_list|()
function_decl|;
comment|/* string length */
name|int
name|typlen
decl_stmt|;
comment|/* type label length */
name|int
name|tcmp
parameter_list|()
function_decl|;
comment|/* compare type labels */
name|void
name|tstretch
parameter_list|()
function_decl|;
comment|/* stretch type label buffer */
for|for
control|(
name|tp
operator|=
name|tb
init|;
operator|*
name|tp
operator|!=
literal|'\0'
condition|;
name|tp
operator|=
name|tskip
argument_list|(
name|tp
argument_list|)
control|)
if|if
condition|(
name|tcmp
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|typlen
operator|=
name|strlen
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tp
operator|==
literal|'\0'
condition|)
comment|/* append to the buffer */
if|if
condition|(
name|tp
operator|>
name|tb
condition|)
block|{
name|tstretch
argument_list|(
name|tp
argument_list|,
name|typlen
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|_PDTSC
expr_stmt|;
name|strcpy
argument_list|(
name|tp
operator|+
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* empty buffer */
name|tstretch
argument_list|(
name|tp
argument_list|,
name|typlen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* insert in the buffer */
name|tstretch
argument_list|(
name|tp
argument_list|,
name|typlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|tp
index|[
name|typlen
index|]
operator|=
name|_PDTSC
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pdtrm() removes type label type from type label buffer tb.  */
end_comment

begin_function
name|void
name|pdtrm
parameter_list|(
name|type
parameter_list|,
name|tb
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
comment|/* type label to be removed */
specifier|register
name|char
modifier|*
name|tb
decl_stmt|;
comment|/* type label buffer */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* type label buffer pointer */
name|char
modifier|*
name|tskip
parameter_list|()
function_decl|;
comment|/* skip to next type label */
name|int
name|tcmp
parameter_list|()
function_decl|;
comment|/* compare type labels */
name|int
name|tlen
parameter_list|()
function_decl|;
comment|/* length of type label */
name|int
name|typlen
decl_stmt|;
comment|/* type label length */
name|void
name|tstretch
parameter_list|()
function_decl|;
comment|/* stretch type label buffer */
for|for
control|(
name|tp
operator|=
name|tb
init|;
operator|*
name|tp
operator|!=
literal|'\0'
condition|;
name|tp
operator|=
name|tskip
argument_list|(
name|tp
argument_list|)
control|)
if|if
condition|(
name|tcmp
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|typlen
operator|=
name|tlen
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
index|[
name|typlen
index|]
operator|==
name|_PDTSC
condition|)
name|tstretch
argument_list|(
name|tp
argument_list|,
operator|-
operator|(
name|typlen
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|tstretch
argument_list|(
name|tp
argument_list|,
operator|-
name|typlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|>
name|tb
operator|&&
name|tp
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|tp
index|[
operator|-
literal|1
index|]
operator|==
name|_PDTSC
condition|)
name|tp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * tcmp() compares project directory type labels and returns an integer  * greater than, equal to, or less than 0, depending on whether type is  * lexicographically greater than, equal to, or less than the type  * pointed to by tp.  */
end_comment

begin_function
specifier|static
name|int
name|tcmp
parameter_list|(
name|type
parameter_list|,
name|tp
parameter_list|)
specifier|register
name|char
modifier|*
name|type
decl_stmt|;
comment|/* type label to be compared */
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* type pointer */
block|{
for|for
control|(
init|;
operator|*
name|tp
operator|==
operator|*
name|type
operator|&&
operator|*
name|type
operator|!=
literal|'\0'
condition|;
name|tp
operator|++
operator|,
name|type
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|type
operator|==
literal|'\0'
operator|&&
operator|(
operator|*
name|tp
operator|==
name|_PDTSC
operator|||
operator|*
name|tp
operator|==
literal|'.'
operator|||
operator|*
name|tp
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|*
name|type
operator|-
operator|*
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tlen() returns the length of the type label pointed to by type label  * buffer pointer tp.  */
end_comment

begin_function
specifier|static
name|int
name|tlen
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* type label buffer pointer */
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* length counter */
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|tp
operator|!=
name|_PDTSC
operator|&&
operator|*
name|tp
operator|!=
literal|'\0'
condition|;
name|tp
operator|++
operator|,
name|n
operator|++
control|)
continue|continue;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tskip() advances type pointer, tp, to the next project directory type  * label.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tskip
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* type label pointer */
block|{
while|while
condition|(
operator|*
name|tp
operator|!=
name|_PDTSC
operator|&&
operator|*
name|tp
operator|!=
literal|'\0'
condition|)
name|tp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tp
operator|==
name|_PDTSC
condition|)
name|tp
operator|++
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tstretch() stretches type label buffer by n characters just before the point  * marked by type pointer tp. Negative n shrinks buffer by n characters.  */
end_comment

begin_function
specifier|static
name|void
name|tstretch
parameter_list|(
name|tp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* type label buffer pointer */
name|int
name|n
decl_stmt|;
comment|/* stretch amount */
block|{
specifier|register
name|char
modifier|*
name|lowertp
decl_stmt|;
comment|/* lower roving type label buffer ptr */
specifier|register
name|char
modifier|*
name|uppertp
decl_stmt|;
comment|/* upper roving type label buffer ptr */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|lowertp
operator|=
name|tp
init|;
operator|*
name|lowertp
operator|!=
literal|'\0'
condition|;
name|lowertp
operator|++
control|)
continue|continue;
name|uppertp
operator|=
name|lowertp
operator|+
name|n
expr_stmt|;
while|while
condition|(
name|lowertp
operator|>=
name|tp
condition|)
operator|*
name|uppertp
operator|--
operator|=
operator|*
name|lowertp
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|uppertp
operator|=
name|tp
init|;
operator|*
name|uppertp
operator|!=
literal|'\0'
condition|;
name|uppertp
operator|++
control|)
continue|continue;
name|lowertp
operator|=
name|tp
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|lowertp
operator|>=
name|uppertp
condition|)
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|lowertp
operator|<=
name|uppertp
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|lowertp
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

