begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header$ */
end_comment

begin_comment
comment|/*  * Author: Peter J. Nicklin  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"path.h"
end_include

begin_include
include|#
directive|include
file|"pdb.h"
end_include

begin_include
include|#
directive|include
file|"pdset.h"
end_include

begin_include
include|#
directive|include
file|"pdlist.h"
end_include

begin_include
include|#
directive|include
file|"pdtyp.h"
end_include

begin_include
include|#
directive|include
file|"pld.h"
end_include

begin_include
include|#
directive|include
file|"slist.h"
end_include

begin_include
include|#
directive|include
file|"slslist.h"
end_include

begin_include
include|#
directive|include
file|"spms.h"
end_include

begin_include
include|#
directive|include
file|"truefalse.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_define
define|#
directive|define
name|INCRPDIRS
value|50
end_define

begin_comment
comment|/* amount to increase pdir ptr array */
end_comment

begin_define
define|#
directive|define
name|MAXPDIRS
value|100
end_define

begin_comment
comment|/* initial size of proj dir ptr array */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|PGN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name */
end_comment

begin_decl_stmt
specifier|extern
name|PDTYP
name|PDIRTYP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project directory type labels list */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Ipdirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* attribute block array index */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Maxpdirs
init|=
name|MAXPDIRS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum no. of project dirs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Ntypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of unique type labels */
end_comment

begin_decl_stmt
specifier|static
name|PDSET
modifier|*
modifier|*
name|Pdarray
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project dir attribute block array */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|Maptyp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unique type label mapping array */
end_comment

begin_decl_stmt
specifier|static
name|TYPES
modifier|*
name|Typstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type label statistics */
end_comment

begin_comment
comment|/*  * add_pdset() adds a project directory to the set of project directories  * which satisfy a boolean project directory type label expression. Only  * those type labels which satisfy the boolean expression are included with  * the project directory. To determine which type labels qualify, the  * postfix expression is scanned from right to left. Type labels within a  * negated expression are ignored. For example, in the postfix equivalent  * of expression "src& !(cmd | lib)" (that is: src cmd lib | !&),  * even if both "src" and "cmd" are found, "src" is the only type label  * which could qualify.  */
end_comment

begin_function
name|void
name|add_pdset
parameter_list|(
name|postfix
parameter_list|,
name|ppathname
parameter_list|,
name|pathname
parameter_list|,
name|project
parameter_list|)
specifier|register
name|PDTYP
modifier|*
name|postfix
decl_stmt|;
comment|/* postfix expression struct */
name|char
modifier|*
name|ppathname
decl_stmt|;
comment|/* project directory project pathname */
name|char
modifier|*
name|pathname
decl_stmt|;
comment|/* project directory pathname */
name|char
modifier|*
name|project
decl_stmt|;
comment|/* project directory's project */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* postfix expression index */
specifier|register
name|int
name|opcount
decl_stmt|;
comment|/* count of expected operands */
name|char
modifier|*
name|pdtcpy
parameter_list|()
function_decl|;
comment|/* copy project directory type label */
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
comment|/* reallocate memory block */
name|char
name|type
index|[
name|TYPESIZE
index|]
decl_stmt|;
comment|/* project dir type label buffer */
name|PDSET
modifier|*
name|savepdir
parameter_list|()
function_decl|;
comment|/* save pdir attribute blk somewhere */
name|void
name|savetype
parameter_list|()
function_decl|;
comment|/* save type label */
if|if
condition|(
name|Ipdirs
operator|>=
name|Maxpdirs
condition|)
block|{
name|Maxpdirs
operator|+=
name|INCRPDIRS
expr_stmt|;
if|if
condition|(
operator|(
name|Pdarray
operator|=
operator|(
name|PDSET
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Pdarray
argument_list|,
operator|(
name|unsigned
operator|)
name|Maxpdirs
operator|*
sizeof|sizeof
argument_list|(
name|PDSET
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomorecore
argument_list|()
expr_stmt|;
block|}
name|Pdarray
index|[
name|Ipdirs
index|]
operator|=
name|savepdir
argument_list|(
name|ppathname
argument_list|,
name|pathname
argument_list|,
name|project
argument_list|)
expr_stmt|;
name|opcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|postfix
operator|->
name|pfxsize
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
name|postfix
operator|->
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_class
condition|)
block|{
case|case
name|B_ID
case|:
if|if
condition|(
operator|(
name|postfix
operator|->
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_sw
operator|==
name|TRUE
condition|)
block|{
name|pdtcpy
argument_list|(
name|type
argument_list|,
operator|(
name|postfix
operator|->
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_label
argument_list|)
expr_stmt|;
name|savetype
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|B_OR
case|:
case|case
name|B_AND
case|:
if|if
condition|(
operator|(
name|postfix
operator|->
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_sw
operator|==
name|FALSE
condition|)
name|opcount
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|B_NOT
case|:
comment|/* always skip !subexpr */
name|opcount
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* skip false subexpression */
for|for
control|(
operator|--
name|i
init|;
name|opcount
operator|>
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
operator|(
name|postfix
operator|->
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_class
condition|)
block|{
case|case
name|B_ID
case|:
name|opcount
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|B_OR
case|:
case|case
name|B_AND
case|:
name|opcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|B_NOT
case|:
break|break;
block|}
block|}
name|Ipdirs
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * build_pdset() builds a set of project directories which satisfy a boolean  * project directory type label expression.  */
end_comment

begin_macro
name|build_pdset
argument_list|(
argument|ppathname
argument_list|,
argument|pathname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ppathname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project root dir project pathname */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pathname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regular project root dir pathname */
end_comment

begin_block
block|{
specifier|extern
name|int
name|ERRSTATUS
decl_stmt|;
comment|/* pexec error status */
specifier|extern
name|SLIST
modifier|*
name|ENVLIST
decl_stmt|;
comment|/* project environment variable list */
name|char
name|ppathbuf
index|[
name|PPATHSIZE
index|]
decl_stmt|;
comment|/* project pathname buffer */
name|char
modifier|*
name|ppathcat
parameter_list|()
function_decl|;
comment|/* project pathname concatenation */
name|char
modifier|*
name|pv
decl_stmt|;
comment|/* PROJECT environment variable */
name|char
modifier|*
name|slprepend
parameter_list|()
function_decl|;
comment|/* prepend key */
name|char
modifier|*
name|slsprepend
parameter_list|()
function_decl|;
comment|/* prepend key+string */
name|int
name|closepdb
parameter_list|()
function_decl|;
comment|/* close database */
name|int
name|errpdb
parameter_list|()
function_decl|;
comment|/* print database error message */
name|int
name|pdtmatch
parameter_list|()
function_decl|;
comment|/* match project dir type label expr */
name|int
name|status
init|=
literal|0
decl_stmt|;
comment|/* return status */
name|PATH
modifier|*
name|pd
decl_stmt|;
comment|/* pathname struct pointer */
name|PATH
modifier|*
name|readpld
parameter_list|()
function_decl|;
comment|/* read project link directory entry */
name|PDB
modifier|*
name|openpdb
parameter_list|()
function_decl|;
comment|/* open database */
name|PDB
modifier|*
name|pldp
decl_stmt|;
comment|/* project link directory stream */
name|SLSBLK
modifier|*
name|pblk
decl_stmt|;
comment|/* project list block */
name|SLSLIST
modifier|*
name|plist
decl_stmt|;
comment|/* project list */
name|SLSLIST
modifier|*
name|slsinit
parameter_list|()
function_decl|;
comment|/* initialize list */
name|void
name|add_pdset
parameter_list|()
function_decl|;
comment|/* add to set of project dirs */
name|void
name|slsrm
parameter_list|()
function_decl|;
comment|/* remove list item */
if|if
condition|(
operator|(
name|pv
operator|=
name|slprepend
argument_list|(
name|pathname
argument_list|,
name|ENVLIST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pxexit
argument_list|()
expr_stmt|;
name|plist
operator|=
name|slsinit
argument_list|()
expr_stmt|;
comment|/* read PLDNAME project link directory */
if|if
condition|(
operator|(
name|pldp
operator|=
name|openpdb
argument_list|(
name|PLDNAME
argument_list|,
name|pathname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|errpdb
argument_list|(
operator|(
name|PDB
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
while|while
condition|(
operator|(
name|pd
operator|=
name|readpld
argument_list|(
name|pldp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|EQUAL
argument_list|(
name|pd
operator|->
name|p_alias
argument_list|,
name|PARENTPROJECT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|EQUAL
argument_list|(
name|pd
operator|->
name|p_alias
argument_list|,
name|CURPROJECT
argument_list|)
condition|)
block|{
if|if
condition|(
name|pdtmatch
argument_list|(
operator|&
name|PDIRTYP
argument_list|,
name|pd
operator|->
name|p_type
argument_list|)
operator|==
name|YES
condition|)
name|add_pdset
argument_list|(
operator|&
name|PDIRTYP
argument_list|,
name|ppathname
argument_list|,
name|pd
operator|->
name|p_path
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pd
operator|->
name|p_mode
operator|==
name|P_IFPROOT
condition|)
block|{
if|if
condition|(
name|slsprepend
argument_list|(
name|pd
operator|->
name|p_alias
argument_list|,
name|pd
operator|->
name|p_path
argument_list|,
name|plist
argument_list|)
operator|==
name|NULL
condition|)
name|pxexit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdtmatch
argument_list|(
operator|&
name|PDIRTYP
argument_list|,
name|pd
operator|->
name|p_type
argument_list|)
operator|==
name|YES
condition|)
block|{
name|ppathcat
argument_list|(
name|ppathbuf
argument_list|,
name|ppathname
argument_list|,
name|pd
operator|->
name|p_alias
argument_list|)
expr_stmt|;
name|add_pdset
argument_list|(
operator|&
name|PDIRTYP
argument_list|,
name|ppathbuf
argument_list|,
name|pd
operator|->
name|p_path
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|closepdb
argument_list|(
name|pldp
argument_list|)
operator|!=
literal|0
condition|)
name|status
operator|=
name|ERRSTATUS
expr_stmt|;
comment|/* build project directory type label tree for subprojects */
for|for
control|(
name|pblk
operator|=
name|plist
operator|->
name|head
init|;
name|pblk
operator|!=
name|NULL
condition|;
name|pblk
operator|=
name|pblk
operator|->
name|next
control|)
block|{
name|ppathcat
argument_list|(
name|ppathbuf
argument_list|,
name|ppathname
argument_list|,
name|pblk
operator|->
name|key
argument_list|)
expr_stmt|;
name|status
operator||=
name|build_pdset
argument_list|(
name|ppathbuf
argument_list|,
name|pblk
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|slsrm
argument_list|(
name|CNULL
argument_list|,
name|plist
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * check_pdset() detects conflicting type label priorities by  * checking that project directories are sorted into ascending  * order according to priority. An error message is printed and  * 1 returned on conflict, otherwise zero.  */
end_comment

begin_macro
name|check_pdset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|iPd
decl_stmt|;
comment|/* proj dir block array index */
specifier|register
name|int
name|ityp
decl_stmt|;
comment|/* type label block index */
specifier|register
name|int
name|lastpr
decl_stmt|;
comment|/* previous type label priority */
specifier|register
name|int
name|prior
decl_stmt|;
comment|/* project dir type label priority */
specifier|register
name|PDSET
modifier|*
modifier|*
name|ptrPd
decl_stmt|;
comment|/* Pdarray block array pointer */
name|int
name|nsortyp
decl_stmt|;
comment|/* no. type label categories to sort */
name|nsortyp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ityp
operator|=
literal|0
init|;
name|ityp
operator|<
name|Ntypes
condition|;
name|ityp
operator|++
control|)
if|if
condition|(
name|Typstat
index|[
name|ityp
index|]
operator|.
name|t_sort
condition|)
name|nsortyp
operator|++
expr_stmt|;
if|if
condition|(
name|nsortyp
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|ityp
operator|=
literal|0
init|;
name|ityp
operator|<
name|Ntypes
condition|;
name|ityp
operator|++
control|)
if|if
condition|(
name|Typstat
index|[
name|ityp
index|]
operator|.
name|t_sort
condition|)
block|{
for|for
control|(
name|ptrPd
operator|=
name|Pdarray
operator|,
name|iPd
operator|=
name|Ipdirs
init|;
name|iPd
operator|>
literal|0
condition|;
name|ptrPd
operator|++
operator|,
name|iPd
operator|--
control|)
if|if
condition|(
operator|(
operator|*
name|ptrPd
operator|)
operator|->
name|typblk
index|[
name|ityp
index|]
operator|.
name|t_exist
condition|)
block|{
name|lastpr
operator|=
operator|(
operator|*
name|ptrPd
operator|)
operator|->
name|typblk
index|[
name|ityp
index|]
operator|.
name|t_prior
expr_stmt|;
break|break;
block|}
for|for
control|(
name|ptrPd
operator|++
operator|,
name|iPd
operator|--
init|;
name|iPd
operator|>
literal|0
condition|;
name|ptrPd
operator|++
operator|,
name|iPd
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|ptrPd
operator|)
operator|->
name|typblk
index|[
name|ityp
index|]
operator|.
name|t_exist
condition|)
block|{
name|prior
operator|=
operator|(
operator|*
name|ptrPd
operator|)
operator|->
name|typblk
index|[
name|ityp
index|]
operator|.
name|t_prior
expr_stmt|;
if|if
condition|(
name|prior
operator|<
name|lastpr
condition|)
goto|goto
name|conflict
goto|;
name|lastpr
operator|=
name|prior
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|conflict
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|PGN
argument_list|)
expr_stmt|;
for|for
control|(
name|ityp
operator|=
name|Ntypes
operator|-
literal|1
init|;
name|ityp
operator|>=
literal|0
condition|;
name|ityp
operator|--
control|)
if|if
condition|(
name|Typstat
index|[
name|ityp
index|]
operator|.
name|t_sort
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
name|nsortyp
operator|--
operator|>
literal|1
operator|)
condition|?
literal|" %s,"
else|:
literal|" %s: conflicting type label priorities\n"
argument_list|,
name|Typstat
index|[
name|ityp
index|]
operator|.
name|t_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * debug_pdset() prints the sorted project directories together with  * the type labels that satisfy the boolean expression.  */
end_comment

begin_function
name|void
name|debug_pdset
parameter_list|()
block|{
name|int
name|iPd
decl_stmt|;
comment|/* project dir block array index */
name|int
name|ityp
decl_stmt|;
comment|/* type label statistics array index */
for|for
control|(
name|iPd
operator|=
literal|0
init|;
name|iPd
operator|<
name|Ipdirs
condition|;
name|iPd
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|Pdarray
index|[
name|iPd
index|]
operator|->
name|ppath
argument_list|)
expr_stmt|;
for|for
control|(
name|ityp
operator|=
literal|0
init|;
name|ityp
operator|<
name|Ntypes
condition|;
name|ityp
operator|++
control|)
if|if
condition|(
name|Pdarray
index|[
name|iPd
index|]
operator|->
name|typblk
index|[
name|ityp
index|]
operator|.
name|t_exist
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s.%d"
argument_list|,
name|Typstat
index|[
name|ityp
index|]
operator|.
name|t_name
argument_list|,
name|Pdarray
index|[
name|iPd
index|]
operator|->
name|typblk
index|[
name|ityp
index|]
operator|.
name|t_prior
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * exec_pdset() executes a set of project directories. Returns non-zero  * error status if error.  */
end_comment

begin_macro
name|exec_pdset
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|ERRSTATUS
decl_stmt|;
comment|/* pexec error status */
specifier|extern
name|int
name|EXECUTE
decl_stmt|;
comment|/* execute command? */
specifier|extern
name|int
name|PRINT_HEADING
decl_stmt|;
comment|/* print headings for project dirs */
name|int
name|ch_dir
parameter_list|()
function_decl|;
comment|/* change current working directory */
name|int
name|execcmd
parameter_list|()
function_decl|;
comment|/* execute command in directory */
name|int
name|iPd
decl_stmt|;
comment|/* project dir block array index */
name|int
name|status
init|=
literal|0
decl_stmt|;
comment|/* return status */
name|void
name|print_title
parameter_list|()
function_decl|;
comment|/* print project directory title */
for|for
control|(
name|iPd
operator|=
literal|0
init|;
name|iPd
operator|<
name|Ipdirs
condition|;
name|iPd
operator|++
control|)
block|{
if|if
condition|(
name|PRINT_HEADING
operator|==
name|YES
condition|)
name|print_title
argument_list|(
name|Pdarray
index|[
name|iPd
index|]
operator|->
name|ppath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch_dir
argument_list|(
name|Pdarray
index|[
name|iPd
index|]
operator|->
name|rpath
argument_list|)
operator|==
name|NO
condition|)
name|status
operator|=
name|ERRSTATUS
expr_stmt|;
elseif|else
if|if
condition|(
name|EXECUTE
operator|==
name|YES
condition|)
name|status
operator||=
name|execcmd
argument_list|(
name|Pdarray
index|[
name|iPd
index|]
operator|->
name|project
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * init_pdset() allocates an array of pointers (Pdarray) to project  * directory attribute blocks, and calculates the maximum number of type  * labels to be stored with each project directory based on the number of  * unique type labels in the boolean postfix type expression. An array  * (Typstat) is also created to maintain statistics on each brand of  * label.  *  * Hash table lookup is used in forming unique type labels and a  * mapping array is used to map the labels from the boolean postfix  * type label expression to the unique representation.  */
end_comment

begin_define
define|#
directive|define
name|UNIQTYPHASHSIZE
value|41
end_define

begin_function
name|void
name|init_pdset
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* postfix type expression index */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* memory allocator */
name|char
modifier|*
name|pfxcpy
parameter_list|()
function_decl|;
comment|/* copy string prefix */
name|char
name|type
index|[
name|TYPESIZE
index|]
decl_stmt|;
comment|/* project dir type label buffer */
name|HASH
modifier|*
name|htinit
parameter_list|()
function_decl|;
comment|/* initialize hash table */
name|HASH
modifier|*
name|uniqtyp
decl_stmt|;
comment|/* hash table of unique type labels */
name|HASHBLK
modifier|*
name|htb
decl_stmt|;
comment|/* hash table block pointer */
name|HASHBLK
modifier|*
name|htinstall
parameter_list|()
function_decl|;
comment|/* install hash table entry */
name|HASHBLK
modifier|*
name|htlookup
parameter_list|()
function_decl|;
comment|/* find hash table entry */
name|int
name|nid
decl_stmt|;
comment|/* no. of ids in boolean expression */
comment|/* project directory attribute block pointer array */
if|if
condition|(
operator|(
name|Pdarray
operator|=
operator|(
name|PDSET
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|Maxpdirs
operator|*
sizeof|sizeof
argument_list|(
name|PDSET
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomorecore
argument_list|()
expr_stmt|;
comment|/* create postfix expression -> unique type label mapping array */
if|if
condition|(
operator|(
name|Maptyp
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|PDIRTYP
operator|.
name|pfxsize
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomorecore
argument_list|()
expr_stmt|;
comment|/* create type label statistics array (estimate size first) */
name|nid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|PDIRTYP
operator|.
name|pfxsize
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|PDIRTYP
operator|.
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_class
operator|==
name|B_ID
condition|)
name|nid
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|Typstat
operator|=
operator|(
name|TYPES
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nid
operator|*
sizeof|sizeof
argument_list|(
name|TYPES
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomorecore
argument_list|()
expr_stmt|;
comment|/* unique type label determination */
name|uniqtyp
operator|=
name|htinit
argument_list|(
name|UNIQTYPHASHSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|PDIRTYP
operator|.
name|pfxsize
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|PDIRTYP
operator|.
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_class
operator|!=
name|B_ID
condition|)
continue|continue;
name|pfxcpy
argument_list|(
name|type
argument_list|,
operator|(
name|PDIRTYP
operator|.
name|pfx
operator|)
index|[
name|i
index|]
operator|.
name|p_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|htb
operator|=
name|htlookup
argument_list|(
name|type
argument_list|,
name|uniqtyp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Maptyp
index|[
name|i
index|]
operator|=
name|htb
operator|->
name|h_val
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|htb
operator|=
name|htinstall
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|Ntypes
argument_list|,
name|uniqtyp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomorecore
argument_list|()
expr_stmt|;
name|Maptyp
index|[
name|i
index|]
operator|=
name|Ntypes
expr_stmt|;
name|Typstat
index|[
name|Ntypes
index|]
operator|.
name|t_name
operator|=
name|htb
operator|->
name|h_key
expr_stmt|;
name|Typstat
index|[
name|Ntypes
index|]
operator|.
name|t_ntl
operator|=
name|Typstat
index|[
name|Ntypes
index|]
operator|.
name|t_sort
operator|=
literal|0
expr_stmt|;
name|Ntypes
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * pdbcmp() compares the type label priorities and project pathnames  * for two project directories. Type label priorities override the  * lexicographical relationship of the project pathnames. Conflicting  * priorities are not detected. For example, a conflict occurs if the  * first directory has type labels print.1 and update.2, whereas the  * second directory has type labels print.2 and update.1. Returns  * an integer less than, equal to, or greater than zero, depending on  * the relative priorities of the type labels or lexicographical ordering  * of the project pathnames.  */
end_comment

begin_macro
name|pdbcmp
argument_list|(
argument|b1
argument_list|,
argument|b2
argument_list|)
end_macro

begin_decl_stmt
name|PDSET
modifier|*
modifier|*
name|b1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project directory block pointer */
end_comment

begin_decl_stmt
name|PDSET
modifier|*
modifier|*
name|b2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* project directory block pointer */
end_comment

begin_block
block|{
specifier|register
name|TYPBLK
modifier|*
name|t1
decl_stmt|;
comment|/* type label block pointer */
specifier|register
name|TYPBLK
modifier|*
name|t2
decl_stmt|;
comment|/* type label block pointer */
specifier|register
name|TYPES
modifier|*
name|ty
decl_stmt|;
comment|/* type statistics array pointer */
specifier|register
name|int
name|comp
decl_stmt|;
comment|/* block comparison */
specifier|register
name|int
name|ityp
decl_stmt|;
comment|/* type label block index */
specifier|register
name|int
name|ntypes
decl_stmt|;
comment|/* number of unique type labels */
name|int
name|strcmp
parameter_list|()
function_decl|;
comment|/* string comparison */
name|comp
operator|=
literal|0
expr_stmt|;
name|ntypes
operator|=
name|Ntypes
expr_stmt|;
name|t1
operator|=
operator|(
operator|*
name|b1
operator|)
operator|->
name|typblk
expr_stmt|;
name|t2
operator|=
operator|(
operator|*
name|b2
operator|)
operator|->
name|typblk
expr_stmt|;
name|ty
operator|=
name|Typstat
expr_stmt|;
for|for
control|(
name|ityp
operator|=
literal|0
init|;
name|ityp
operator|<
name|ntypes
condition|;
name|ityp
operator|++
control|)
block|{
if|if
condition|(
name|ty
operator|->
name|t_sort
operator|&&
name|t1
operator|->
name|t_exist
operator|&&
name|t2
operator|->
name|t_exist
condition|)
if|if
condition|(
operator|(
name|comp
operator|=
name|t1
operator|->
name|t_prior
operator|-
name|t2
operator|->
name|t_prior
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|comp
operator|)
return|;
name|t1
operator|++
operator|,
name|t2
operator|++
operator|,
name|ty
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|*
name|b1
operator|)
operator|->
name|ppath
argument_list|,
operator|(
operator|*
name|b2
operator|)
operator|->
name|ppath
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * savepdir() saves a block of project directory attributes somewhere  * and returns a pointer to the somewhere, or dies if out of memory.  */
end_comment

begin_function
name|PDSET
modifier|*
name|savepdir
parameter_list|(
name|ppathname
parameter_list|,
name|pathname
parameter_list|,
name|project
parameter_list|)
name|char
modifier|*
name|ppathname
decl_stmt|;
comment|/* project directory project pathname */
name|char
modifier|*
name|pathname
decl_stmt|;
comment|/* project directory regular pathname */
name|char
modifier|*
name|project
decl_stmt|;
comment|/* project directory's project */
block|{
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
comment|/* initialize memory to zero */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* memory allocator */
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
comment|/* string copy */
name|int
name|strlen
parameter_list|()
function_decl|;
comment|/* string length */
name|PDSET
modifier|*
name|pdbptr
decl_stmt|;
comment|/* pointer to proj directory block */
if|if
condition|(
operator|(
name|pdbptr
operator|=
operator|(
name|PDSET
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PDSET
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pdbptr
operator|->
name|ppath
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|ppathname
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pdbptr
operator|->
name|rpath
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|pdbptr
operator|->
name|typblk
operator|=
operator|(
name|TYPBLK
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|Ntypes
argument_list|,
sizeof|sizeof
argument_list|(
name|TYPBLK
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomorecore
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|pdbptr
operator|->
name|rpath
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pdbptr
operator|->
name|ppath
argument_list|,
name|ppathname
argument_list|)
expr_stmt|;
name|pdbptr
operator|->
name|project
operator|=
name|project
expr_stmt|;
return|return
operator|(
name|pdbptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * savetype() records the priorities of the type labels attached to each  * directory, and also the total number of each type label.  */
end_comment

begin_function
name|void
name|savetype
parameter_list|(
name|type
parameter_list|,
name|idx
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
comment|/* project dir type label */
name|int
name|idx
decl_stmt|;
comment|/* boolean type expression id index */
block|{
specifier|register
name|char
modifier|*
name|ptyptr
decl_stmt|;
comment|/* pointer to type label priority */
specifier|register
name|int
name|priority
decl_stmt|;
comment|/* type label priority */
specifier|register
name|int
name|uniqid
decl_stmt|;
comment|/* unique type label number */
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
comment|/* first occurrence of character */
name|int
name|atoi
parameter_list|()
function_decl|;
comment|/* string to decimal integer */
name|uniqid
operator|=
name|Maptyp
index|[
name|idx
index|]
expr_stmt|;
name|ptyptr
operator|=
name|index
argument_list|(
name|type
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|priority
operator|=
operator|(
name|ptyptr
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|atoi
argument_list|(
operator|++
name|ptyptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Typstat
index|[
name|uniqid
index|]
operator|.
name|t_ntl
operator|==
literal|0
condition|)
block|{
name|Typstat
index|[
name|uniqid
index|]
operator|.
name|t_itlp
operator|=
name|priority
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|priority
operator|!=
name|Typstat
index|[
name|uniqid
index|]
operator|.
name|t_itlp
condition|)
name|Typstat
index|[
name|uniqid
index|]
operator|.
name|t_sort
operator|=
literal|1
expr_stmt|;
block|}
name|Typstat
index|[
name|uniqid
index|]
operator|.
name|t_ntl
operator|++
expr_stmt|;
name|Pdarray
index|[
name|Ipdirs
index|]
operator|->
name|typblk
index|[
name|uniqid
index|]
operator|.
name|t_exist
operator|++
expr_stmt|;
name|Pdarray
index|[
name|Ipdirs
index|]
operator|->
name|typblk
index|[
name|uniqid
index|]
operator|.
name|t_prior
operator|=
name|priority
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sort_pdset() sorts the set of project directories alpahabetically  * and by type label priorities.  */
end_comment

begin_function
name|void
name|sort_pdset
parameter_list|()
block|{
name|int
name|pdbcmp
parameter_list|()
function_decl|;
comment|/* compare project dir blocks */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Pdarray
argument_list|,
name|Ipdirs
argument_list|,
sizeof|sizeof
argument_list|(
name|PDSET
operator|*
argument_list|)
argument_list|,
name|pdbcmp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

