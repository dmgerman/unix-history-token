begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)if_ddn.c	7.1 (Berkeley) 6/5/86 */
end_comment

begin_comment
comment|/************************************************************************\       ________________________________________________________     /                                                        \    |          AAA          CCCCCCCCCCCCCC    CCCCCCCCCCCCCC   |    |         AAAAA        CCCCCCCCCCCCCCCC  CCCCCCCCCCCCCCCC  |    |        AAAAAAA       CCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCC |    |       AAAA AAAA      CCCC              CCCC              |    |      AAAA   AAAA     CCCC              CCCC              |    |     AAAA     AAAA    CCCC              CCCC              |    |    AAAA       AAAA   CCCC              CCCC              |    |   AAAA  AAAAAAAAAAA  CCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCC |    |  AAAA    AAAAAAAAAAA CCCCCCCCCCCCCCCC  CCCCCCCCCCCCCCCC  |    | AAAA      AAAAAAAAA   CCCCCCCCCCCCCC    CCCCCCCCCCCCCC   |     \________________________________________________________/  	Copyright (c) 1985 by Advanced Computer Communications 	720 Santa Barbara Street, Santa Barbara, California  93101 	(805) 963-9431  	This software may be duplicated and used on systems 	which are licensed to run U.C. Berkeley versions of 	the UNIX operating system.  Any duplication of any 	part of this software must include a copy of ACC's 	copyright notice.   File: 		if_ddn.c  Author: 		Art Berggreen  Project: 		4.2 DDN X.25 network driver  Function: 		This is a network device driver for BSD 4.2 UNIX which 		provides an interface between IP and ACC's ACP625 		(IF-11/X25) for connecting to the Defense Data Network.  Components:  Revision History: 		16-May-1985:	V1.0 - First release. 				Art Berggreen.  \************************************************************************/
end_comment

begin_escape
end_escape

begin_comment
comment|/*	if_ddn.c	 V1.0	5/16/85	*/
end_comment

begin_comment
comment|/*  * ACC ACP625 DDN/X.25 Network device driver  */
end_comment

begin_comment
comment|/* #define DDNDEBUG 1		/* Enable definition for Debug code */
end_comment

begin_include
include|#
directive|include
file|"ddn.h"
end_include

begin_if
if|#
directive|if
name|NDDN
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"vmmac.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../vax/cpu.h"
end_include

begin_include
include|#
directive|include
file|"../vax/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"if_ddnreg.h"
end_include

begin_include
include|#
directive|include
file|"if_ddnvar.h"
end_include

begin_include
include|#
directive|include
file|"if_uba.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubareg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxuba/ubavar.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* declare global functions */
end_comment

begin_function_decl
name|int
name|ddnprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ddnattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ddnreset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ddninit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ddnoutput
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ddntimer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ddnioctl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ddnintr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* declare local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|x25_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ddn_cb
modifier|*
name|locate_x25_lcn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|convert_ip_addr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|convert_x25_addr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|make_x25_call
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ddn_start
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ddn_iorq
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_chn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ddn_data
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ddn_supr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|supr_msg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean
name|decode_ring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_lcn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_restart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_supr
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DDNDEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|prt_addr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prt_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|DDNDEBUG
end_endif

begin_escape
end_escape

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ddninfo
index|[
name|NDDN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptrs to device info */
end_comment

begin_decl_stmt
name|u_short
name|ddnstd
index|[]
init|=
block|{
literal|0766740
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* standard addresses */
end_comment

begin_decl_stmt
name|struct
name|uba_driver
name|ddndriver
init|=
comment|/* device driver info */
block|{
name|ddnprobe
block|,
comment|/* device probe routine */
literal|0
block|,
comment|/* slave probe routine */
name|ddnattach
block|,
comment|/* device attach routine */
literal|0
block|,
comment|/* "dmago" routine */
name|ddnstd
block|,
comment|/* device address */
literal|"ddn"
block|,
comment|/* device name */
name|ddninfo
comment|/* ptr to device info ptrs */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|init_msg
index|[]
init|=
block|{
name|LINE_CNTL
block|,
comment|/* set command code */
literal|0x00
block|,
comment|/* not used */
literal|0x00
block|,
comment|/* not used */
literal|0x00
block|,
comment|/* extension length (set at runtime) */
name|LINK_DISABLE
block|,
comment|/* link disable */
comment|/*    LINK_LOOPBACK,			/* loopback mode */
comment|/*    LOOP_INTERNAL,			/*   = internal loopback */
name|PKT_SIZE
block|,
comment|/* packet size */
literal|0x80
block|,
comment|/*   128 - LSB */
literal|0x00
block|,
comment|/*   128 - MSB */
name|PKT_WINDOW
block|,
comment|/* packet window */
literal|0x02
block|,
comment|/*   = 2 */
name|LINK_ENABLE
comment|/* link enable */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|cb_cmnd
index|[
literal|4
index|]
init|=
block|{
name|CALL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|cb_called_addr
index|[
literal|16
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|cb_calling_addr
index|[
literal|16
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|cb_facilities
index|[
literal|64
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|cb_protocol
index|[
literal|5
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|cb_user_data
index|[
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDNDEBUG
end_ifdef

begin_decl_stmt
name|int
name|ddn_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* values 0-8 cause increasing verbosity */
end_comment

begin_endif
endif|#
directive|endif
endif|DDNDEBUG
end_endif

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *									* *	Information for each device unit is maintained in an array	* *	of structures named ddn_softc[].  The array is indexed by	* *	unit number.  Each entry includes the network interface		* *	structure (ddn_if) used by the routing code to locate the	* *	interface,  an array of Logical	Channel control blocks which	* *	maintain information about each of the Logical Channels (LCNs)	* *	through which X.25 virtual calls are established, a queue of	* *	I/O requests pending for the UMC, the UNIBUS interrupt vector	* *	for the unit and misc flags.  The Logical Channel Control	* *	blocks maintain information about the state of each LCN,	* *	a queue of outbound data, Half Duplex Channel (HDX) blocks	* *	used for queuing I/O requests to the UMC and an ifuba		* *	structure which records the UNIBUS resources being held by	* *	the LCN.							* *									* \***********************************************************************/
end_comment

begin_struct
struct|struct
name|sioq
comment|/* Start I/O queue head */
block|{
name|struct
name|hdx_chan
modifier|*
name|sq_head
decl_stmt|;
comment|/* queue head */
name|struct
name|hdx_chan
modifier|*
name|sq_tail
decl_stmt|;
comment|/* queue tail */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hdx_chan
comment|/* HDX channel block */
block|{
name|struct
name|hdx_chan
modifier|*
name|hc_next
decl_stmt|;
comment|/* link to next HDX channel */
name|u_char
name|hc_chan
decl_stmt|;
comment|/* HDX channel number */
name|u_char
name|hc_adx
decl_stmt|;
comment|/* address bits 17-16 */
name|u_short
name|hc_addr
decl_stmt|;
comment|/* address bits 15-00 */
name|u_short
name|hc_cnt
decl_stmt|;
comment|/* byte count */
name|u_char
name|hc_func
decl_stmt|;
comment|/* I/O function */
name|u_char
name|hc_sbfc
decl_stmt|;
comment|/* I/O subfunction */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ddn_cb
comment|/* Logical Channel control block */
block|{
name|struct
name|in_addr
name|dc_inaddr
decl_stmt|;
comment|/* remote Internet address */
name|u_char
name|dc_lcn
decl_stmt|;
comment|/* LCN number */
name|u_char
name|dc_state
decl_stmt|;
comment|/* LCN state */
name|u_short
name|dc_timer
decl_stmt|;
comment|/* LCN timer */
name|struct
name|ifqueue
name|dc_oq
decl_stmt|;
comment|/* LCN output queue */
name|struct
name|hdx_chan
name|dc_rchan
decl_stmt|;
comment|/* LCN read HDX channel */
name|struct
name|hdx_chan
name|dc_wchan
decl_stmt|;
comment|/* LCN write HDX channel */
name|struct
name|ifuba
name|dc_ifuba
decl_stmt|;
comment|/* UNIBUS resources */
name|u_short
name|dc_flags
decl_stmt|;
comment|/* misc flags */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ddn_softc
comment|/* device control structure */
block|{
name|struct
name|ifnet
name|ddn_if
decl_stmt|;
comment|/* network-visible interface */
name|struct
name|ddn_cb
name|ddn_cb
index|[
name|NDDNCH
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Logical Channel cntl blks */
name|struct
name|sioq
name|ddn_sioq
decl_stmt|;
comment|/* start I/O queue */
name|int
name|ddn_vector
decl_stmt|;
comment|/* UNIBUS interrupt vector */
name|u_short
name|ddn_flags
decl_stmt|;
comment|/* misc flags */
name|struct
name|in_addr
name|ddn_ipaddr
decl_stmt|;
comment|/* local IP address */
block|}
name|ddn_softc
index|[
name|NDDN
index|]
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddnprobe()				* ************************************************************************* *									* *	This routine probes the device to obtain the UNIBUS interrupt	* *	vector.  Since the UMC is a soft vector device, we obtain	* *	an unused vector from the uba structure and return that.	* *	The UMC is given the vector and the board is reset.		* *	In order to save the vector in the device info structure, we	* *	place it in a static temporary where the attach routine can	* *	find it and save it in the device info structure.  This is	* *	necessary because probe only provides a pointer to the device	* *	and we have no idea which unit is being referenced.  This	* *	works in 4.2 because the attach routine is called immediately	* *	after a successful probe.					* *									* \***********************************************************************/
end_comment

begin_define
define|#
directive|define
name|INIT_DELAY
value|(100 * 2)
end_define

begin_comment
comment|/* time for board initialization */
end_comment

begin_comment
comment|/*   ( in 10 millisecond ticks) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|savevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static variable for vector */
end_comment

begin_macro
name|ddnprobe
argument_list|(
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|reg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|br
decl_stmt|,
name|cvec
decl_stmt|;
comment|/* r11, r10 value-result */
specifier|register
name|struct
name|ddnregs
modifier|*
name|addr
init|=
operator|(
expr|struct
name|ddnregs
operator|*
operator|)
name|reg
decl_stmt|;
specifier|register
name|int
name|delay_time
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|br
operator|=
literal|0
expr_stmt|;
name|cvec
operator|=
name|br
expr_stmt|;
name|br
operator|=
name|cvec
expr_stmt|;
name|ddnintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvec
operator|=
name|savevec
operator|=
operator|(
name|uba_hd
index|[
name|numuba
index|]
operator|.
name|uh_lastiv
operator|-=
literal|4
operator|)
expr_stmt|;
comment|/* return vector */
name|br
operator|=
literal|0x15
expr_stmt|;
comment|/* return bus level */
name|addr
operator|->
name|ioini
operator|=
literal|0
expr_stmt|;
comment|/* clear handshake flags */
name|addr
operator|->
name|ionmi
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|staack
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|xfrgnt
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|iovect
operator|=
name|cvec
operator|>>
literal|2
expr_stmt|;
comment|/* pass vector to UMC */
name|addr
operator|->
name|csr
operator|=
name|DDN_RST
expr_stmt|;
comment|/* reset the board */
name|delay_time
operator|=
name|mfpr
argument_list|(
name|TODR
argument_list|)
operator|+
name|INIT_DELAY
expr_stmt|;
while|while
condition|(
name|delay_time
operator|>
name|mfpr
argument_list|(
name|TODR
argument_list|)
condition|)
comment|/* wait */
empty_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ddnregs
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddnattach				* ************************************************************************* *									* *	This routine attaches the device to the network software.	* *	The network interface structure is filled in.  The device	* *	will be initialized when the system is ready to accept packets.	* *									* \***********************************************************************/
end_comment

begin_macro
name|ddnattach
argument_list|(
argument|ui
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
init|=
operator|&
name|ddn_softc
index|[
name|ui
operator|->
name|ui_unit
index|]
decl_stmt|;
name|ds
operator|->
name|ddn_vector
operator|=
name|savevec
expr_stmt|;
comment|/* save vector from probe() */
name|ds
operator|->
name|ddn_if
operator|.
name|if_unit
operator|=
name|ui
operator|->
name|ui_unit
expr_stmt|;
comment|/* set unit number */
name|ds
operator|->
name|ddn_if
operator|.
name|if_name
operator|=
literal|"ddn"
expr_stmt|;
comment|/* set device name */
name|ds
operator|->
name|ddn_if
operator|.
name|if_mtu
operator|=
name|DDNMTU
expr_stmt|;
comment|/* set max msg size */
name|ds
operator|->
name|ddn_if
operator|.
name|if_init
operator|=
name|ddninit
expr_stmt|;
comment|/* set init routine addr */
name|ds
operator|->
name|ddn_if
operator|.
name|if_ioctl
operator|=
name|ddnioctl
expr_stmt|;
comment|/* set ioctl routine addr */
name|ds
operator|->
name|ddn_if
operator|.
name|if_output
operator|=
name|ddnoutput
expr_stmt|;
comment|/* set output routine addr */
name|ds
operator|->
name|ddn_if
operator|.
name|if_reset
operator|=
name|ddnreset
expr_stmt|;
comment|/* set reset routine addr */
name|ds
operator|->
name|ddn_if
operator|.
name|if_watchdog
operator|=
name|ddntimer
expr_stmt|;
comment|/* set timer routine addr */
name|if_attach
argument_list|(
operator|&
name|ds
operator|->
name|ddn_if
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddnreset()				* ************************************************************************* *									* *	Reset of interface after UNIBUS reset.				* *	If interface is on specified uba, reset its state.		* *									* \***********************************************************************/
end_comment

begin_macro
name|ddnreset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
decl_stmt|;
specifier|register
name|struct
name|ddnregs
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|delay_time
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDDN
operator|||
operator|(
name|ui
operator|=
name|ddninfo
index|[
name|unit
index|]
operator|)
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_alive
operator|==
literal|0
operator|||
name|ui
operator|->
name|ui_ubanum
operator|!=
name|uban
condition|)
return|return;
name|printf
argument_list|(
literal|" ddn%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|ddnregs
operator|*
operator|)
name|ui
operator|->
name|ui_addr
expr_stmt|;
name|addr
operator|->
name|ioini
operator|=
literal|0
expr_stmt|;
comment|/* clear handshake flags */
name|addr
operator|->
name|ionmi
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|staack
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|xfrgnt
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|iovect
operator|=
name|ddn_softc
index|[
name|unit
index|]
operator|.
name|ddn_vector
operator|>>
literal|2
expr_stmt|;
comment|/* pass vector to UMC */
name|addr
operator|->
name|csr
operator|=
name|DDN_RST
expr_stmt|;
comment|/* reset the board */
name|delay_time
operator|=
name|mfpr
argument_list|(
name|TODR
argument_list|)
operator|+
name|INIT_DELAY
expr_stmt|;
while|while
condition|(
name|delay_time
operator|>
name|mfpr
argument_list|(
name|TODR
argument_list|)
condition|)
comment|/* wait */
empty_stmt|;
name|ddninit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddninit()				* ************************************************************************* *									* *	This routine initializes the interface for operation.  The	* *	device control blocks are initialized, UNIBUS resources are	* *	allocated and an X.25 initialization message is sent to the	* *	UMC.								* *									* \***********************************************************************/
end_comment

begin_macro
name|ddninit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
init|=
operator|&
name|ddn_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|struct
name|uba_device
modifier|*
name|ui
init|=
name|ddninfo
index|[
name|unit
index|]
decl_stmt|;
name|int
name|lcn
decl_stmt|,
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ddn%d: ddninit()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
if|if
condition|(
name|ds
operator|->
name|ddn_if
operator|.
name|if_addrlist
operator|==
literal|0
condition|)
comment|/* if we have no internet addr */
return|return;
comment|/*   don't init yet */
name|dc
operator|=
name|ds
operator|->
name|ddn_cb
expr_stmt|;
comment|/* setup ptr to first LCN cntl block */
for|for
control|(
name|lcn
operator|=
literal|0
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/* for all LCN's ... */
block|{
name|dc
operator|->
name|dc_lcn
operator|=
name|lcn
expr_stmt|;
comment|/* record LCN */
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
comment|/* clear remote internet addr */
name|dc
operator|->
name|dc_state
operator|=
name|LC_DOWN
expr_stmt|;
comment|/* init LCN state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_OFF
expr_stmt|;
comment|/* turn LCN timer off */
comment|/* init LCN output queue */
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_head
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_tail
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_len
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_maxlen
operator|=
name|DDN_OQMAX
expr_stmt|;
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_drops
operator|=
literal|0
expr_stmt|;
comment|/* init HDX channels */
name|dc
operator|->
name|dc_rchan
operator|.
name|hc_next
operator|=
operator|(
expr|struct
name|hdx_chan
operator|*
operator|)
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_rchan
operator|.
name|hc_chan
operator|=
name|lcn
operator|*
literal|2
expr_stmt|;
name|dc
operator|->
name|dc_wchan
operator|.
name|hc_next
operator|=
operator|(
expr|struct
name|hdx_chan
operator|*
operator|)
literal|0
expr_stmt|;
name|dc
operator|->
name|dc_wchan
operator|.
name|hc_chan
operator|=
operator|(
name|lcn
operator|*
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* init UNIBUS resources */
if|if
condition|(
name|if_ubainit
argument_list|(
operator|&
name|dc
operator|->
name|dc_ifuba
argument_list|,
name|ui
operator|->
name|ui_ubanum
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|btoc
argument_list|(
name|DDNMTU
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ddn%d: failed getting UBA resources for lcn %d\n"
argument_list|,
name|unit
argument_list|,
name|lcn
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ddn_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
expr_stmt|;
return|return;
block|}
name|dc
operator|->
name|dc_flags
operator|=
literal|0
expr_stmt|;
comment|/* initialize flags */
name|dc
operator|++
expr_stmt|;
comment|/* point at next cntl blk */
block|}
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
operator|=
operator|(
expr|struct
name|hdx_chan
operator|*
operator|)
literal|0
expr_stmt|;
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_tail
operator|=
operator|(
expr|struct
name|hdx_chan
operator|*
operator|)
literal|0
expr_stmt|;
name|ds
operator|->
name|ddn_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|dc
operator|=
name|ds
operator|->
name|ddn_cb
expr_stmt|;
comment|/* setup ptr to first LCN cntl block */
for|for
control|(
name|lcn
operator|=
literal|0
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/* issue reads on all LCNs */
block|{
name|ddn_iorq
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|DDNMTU
argument_list|,
name|DDNRDB
operator|+
name|DDNSTR
argument_list|)
expr_stmt|;
name|dc
operator|++
expr_stmt|;
block|}
name|x25_init
argument_list|(
name|ds
argument_list|)
expr_stmt|;
comment|/* init the X.25 board */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ddntimer
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* start timers */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddnoutput()				* ************************************************************************* *									* *	This routine is called by the network software when it has	* *	an IP datagram to send out this interface.  An attempt is	* *	made to find a LCN which has a virtual circuit open to the	* *	indicated host.  If an LCN is found the packet is queued for	* *	output on that LCN.						* *									* \***********************************************************************/
end_comment

begin_macro
name|ddnoutput
argument_list|(
argument|ifp
argument_list|,
argument|m0
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
init|=
operator|&
name|ddn_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|oq
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|ds
operator|->
name|ddn_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
switch|switch
condition|(
name|dst
operator|->
name|sin_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
break|break;
endif|#
directive|endif
endif|INET
default|default:
name|printf
argument_list|(
literal|"ddn%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sin_family
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"ddnoutput(): dst = "
argument_list|)
expr_stmt|;
name|prt_addr
argument_list|(
name|dst
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* try to find an LCN */
if|if
condition|(
name|dc
operator|=
name|locate_x25_lcn
argument_list|(
name|ds
argument_list|,
name|dst
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
comment|/* if found */
name|oq
operator|=
operator|&
operator|(
name|dc
operator|->
name|dc_oq
operator|)
expr_stmt|;
comment|/*   point to output queue */
name|dc
operator|->
name|dc_state
operator|=
name|LC_DATA_IDLE
expr_stmt|;
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_DATA_IDLE
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|oq
argument_list|)
condition|)
comment|/*   if q full */
block|{
name|IF_DROP
argument_list|(
name|oq
argument_list|)
expr_stmt|;
comment|/*     drop the data */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*   otherwise queue it */
name|ddn_start
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/*   and try to output */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
comment|/* if no circuit available */
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/*   drop the data */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddntimer()				* ************************************************************************* *									* *	This routine is entered once a second to perform timer		* *	managment.  The LCN table is scanned for active timers,		* *	(nonzero) which are decremented.  If a timer expires		* *	(becomes zero), the proper action is taken.			* *									* \***********************************************************************/
end_comment

begin_function
name|int
name|ddntimer
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
init|=
operator|&
name|ddn_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|lcn
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"ddntimer()\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|ds
operator|->
name|ddn_if
operator|.
name|if_timer
operator|=
name|DDN_TIMEOUT
expr_stmt|;
comment|/* restart timer */
name|dc
operator|=
name|ds
operator|->
name|ddn_cb
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|lcn
operator|=
literal|0
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/* scan all LCN's */
block|{
if|if
condition|(
name|dc
operator|->
name|dc_timer
operator|&&
operator|(
operator|--
operator|(
name|dc
operator|->
name|dc_timer
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* if a timer expired */
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|==
name|LC_RESTART
condition|)
block|{
comment|/*   if a restart was out */
name|send_restart
argument_list|(
name|ds
argument_list|)
expr_stmt|;
comment|/*     send another one */
break|break;
block|}
else|else
comment|/*   otherwise */
block|{
name|clear_lcn
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/*     clear the LCN */
block|}
block|}
name|dc
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddnioctl()				* ************************************************************************* *									* *	This routine processes device dependent ioctl's.  Currently,	* *	the only ioctl supported is used to set the host's internet	* *	address for this network interface.				* *									* \***********************************************************************/
end_comment

begin_expr_stmt
name|ddnioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ddninit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ddn_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|ddn_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddnintr()				* ************************************************************************* *									* *	This is the interrupt handler for UNIBUS interrupts from the	* *	UMC.  The interrupting HDX channel and interrupt type are	* *	obtained from the completion comm regs.  If the interrupt is	* *	an I/O request acknowledge, the next I/O request is passed	* *	to the UMC.  If the interrupt is an I/O completion, the		* *	completion is processed depending on whether it is for the	* *	supervisor or a data channel.					* *									* \***********************************************************************/
end_comment

begin_macro
name|ddnintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
init|=
operator|&
name|ddn_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|hdx_chan
modifier|*
name|hc
decl_stmt|;
specifier|register
name|struct
name|ddnregs
modifier|*
name|addr
init|=
operator|(
expr|struct
name|ddnregs
operator|*
operator|)
name|ddninfo
index|[
name|unit
index|]
operator|->
name|ui_addr
decl_stmt|;
name|int
name|chan
decl_stmt|,
name|type
decl_stmt|,
name|cc
decl_stmt|,
name|cnt
decl_stmt|;
comment|/*      * Check for hardware errors.      */
if|if
condition|(
name|addr
operator|->
name|csr
operator|&
name|DDN_UER
condition|)
block|{
name|printf
argument_list|(
literal|"ddn%d: hard error csr=%b\n"
argument_list|,
name|unit
argument_list|,
name|addr
operator|->
name|csr
argument_list|,
name|DDN_BITS
argument_list|)
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
literal|0
expr_stmt|;
comment|/* disable i/f */
return|return;
block|}
comment|/*      * Get logical channel info.      */
if|if
condition|(
operator|(
name|chan
operator|=
name|addr
operator|->
name|stachn
operator|)
operator|>=
operator|(
operator|(
name|NDDNCH
operator|+
literal|1
operator|)
operator|*
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ddn%d: unknown channel, chan=%d\n"
argument_list|,
name|unit
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chan
operator|&
literal|0x01
condition|)
name|hc
operator|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
name|chan
operator|/
literal|2
index|]
operator|.
name|dc_wchan
operator|)
expr_stmt|;
else|else
name|hc
operator|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
name|chan
operator|/
literal|2
index|]
operator|.
name|dc_rchan
operator|)
expr_stmt|;
name|type
operator|=
name|addr
operator|->
name|statyp
expr_stmt|;
name|cc
operator|=
name|addr
operator|->
name|stacc
expr_stmt|;
name|cnt
operator|=
name|hc
operator|->
name|hc_cnt
operator|-
name|addr
operator|->
name|stacnt
expr_stmt|;
comment|/* Figure out what kind of interrupt it was */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DDNSACK
case|:
comment|/* start i/o accepted */
if|if
condition|(
name|hc
operator|!=
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
condition|)
comment|/* does ack match waiting req? */
block|{
name|printf
argument_list|(
literal|"ddn%d: STARTIO error chan=%d hc=%x sq=%x\n"
argument_list|,
name|unit
argument_list|,
name|chan
argument_list|,
name|hc
argument_list|,
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
argument_list|)
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
literal|0
expr_stmt|;
comment|/* disable UMC */
return|return;
block|}
comment|/* dequeue old request by copying link to queue head */
comment|/*   and start next I/O request if queue has not gone empty */
if|if
condition|(
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
operator|=
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
operator|->
name|hc_next
condition|)
block|{
name|start_chn
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DDNDONE
case|:
comment|/* i/o completion */
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
name|DDNIOCABT
case|:
comment|/* probably VCN flush */
break|break;
case|case
name|DDNIOCERR
case|:
name|printf
argument_list|(
literal|"ddn%d: program error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|daterr
goto|;
case|case
name|DDNIOCOVR
case|:
name|printf
argument_list|(
literal|"ddn%d: overrun error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|daterr
goto|;
case|case
name|DDNIOCUBE
case|:
name|printf
argument_list|(
literal|"ddn%d: NXM timeout or UB parity error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|daterr
label|:
name|printf
argument_list|(
literal|"chan=%d func=%x\n"
argument_list|,
name|chan
argument_list|,
name|hc
operator|->
name|hc_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|hc
operator|->
name|hc_func
operator|&
name|DDNRDB
condition|)
name|ds
operator|->
name|ddn_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
else|else
name|ds
operator|->
name|ddn_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
comment|/* was it supervisor or data traffic? */
if|if
condition|(
name|chan
operator|>
literal|1
condition|)
name|ddn_data
argument_list|(
name|unit
argument_list|,
name|chan
argument_list|,
name|cc
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|ddn_supr
argument_list|(
name|unit
argument_list|,
name|chan
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/*      * Ack the interrupt      */
name|addr
operator|->
name|staack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|addr
operator|->
name|ionmi
operator|)
condition|)
block|{
name|addr
operator|->
name|ionmi
operator|=
literal|1
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DDN_DMA
operator||
name|DDN_WRT
operator||
name|DDN_IEN
operator||
name|DDN_NMI
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				x25_init()				* ************************************************************************* *									* *	This routine builds and sends an X.25 initialization msg	* *	to the UMC.							* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|x25_init
parameter_list|(
name|ds
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ddn%d: x25_init()\n"
argument_list|,
name|ds
operator|->
name|ddn_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* try to get X25 init buffer */
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ddn%d: couldn't get X25 init buffer\n"
argument_list|,
name|ds
operator|->
name|ddn_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|init_msg
index|[
literal|3
index|]
operator|=
sizeof|sizeof
argument_list|(
name|init_msg
argument_list|)
operator|-
literal|4
expr_stmt|;
comment|/* set cmnd ext length */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|init_msg
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|init_msg
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|init_msg
argument_list|)
expr_stmt|;
comment|/* set msg length */
name|IF_ENQUEUE
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|.
name|dc_oq
operator|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ddn_start
argument_list|(
name|ds
argument_list|,
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *			locate_x25_lcn()				* ************************************************************************* *									* *	This routine tries to locate an X25 LCN associated with a	* *	remote internet address.  A linear search of the LCN table	* *	is made for a matching address.  If the search succeeds, the	* *	LCN is returned.  If the search fails, the LCN table is		* *	searched for an unused table entry.  If an unused table entry	* *	is found, an X25 call is generated to the host specified in	* *	the destination internet address.  If no LCN is available,	* *	zero is returned.						* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|struct
name|ddn_cb
modifier|*
name|locate_x25_lcn
parameter_list|(
name|ds
parameter_list|,
name|ip_addr
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
name|struct
name|in_addr
name|ip_addr
decl_stmt|;
block|{
specifier|register
name|int
name|lcn
decl_stmt|;
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"locate_x25_lcn()\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|1
index|]
operator|)
expr_stmt|;
for|for
control|(
name|lcn
operator|=
literal|1
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/* scan LCN table for addr match */
block|{
if|if
condition|(
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|==
name|ip_addr
operator|.
name|s_addr
condition|)
comment|/* if found */
return|return
operator|(
name|dc
operator|)
return|;
comment|/*   return LCN */
name|dc
operator|++
expr_stmt|;
block|}
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|1
index|]
operator|)
expr_stmt|;
for|for
control|(
name|lcn
operator|=
literal|1
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/* scan LCN table for free entry */
block|{
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|==
name|LC_IDLE
condition|)
break|break;
name|dc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lcn
operator|>
name|NDDNCH
condition|)
comment|/* if we didn't find a free entry */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*   return empty handed */
if|if
condition|(
name|convert_ip_addr
argument_list|(
name|ip_addr
argument_list|,
name|cb_called_addr
argument_list|)
operator|&&
name|make_x25_call
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
condition|)
block|{
comment|/*  addr can be converted */
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|=
name|ip_addr
operator|.
name|s_addr
expr_stmt|;
return|return
operator|(
name|dc
operator|)
return|;
comment|/*   and return the LCN */
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* give up */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *			convert_ip_addr()				* ************************************************************************* *									* *	This routine accepts an internet address and attempts to	* *	translate to an equivalent X25 address.  For DDN this follows	* *	the guidelines in the DDN X25 interface spec.  The resultant	* *	X25 address is stored in the X25 called addr buffer.  The	* *	routine returns TRUE if successfull, FALSE otherwise.		* *									* *	NOTE: Although IF-11/X25 was designed to accept ASCII coded	* *	digits for the address fields, we only supply the binary	* *	values.  The front-end only uses the low four bits to extract	* *	the binary value from the ASCII digits, so this works out.	* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|boolean
name|convert_ip_addr
parameter_list|(
name|ip_addr
parameter_list|,
name|x25addr
parameter_list|)
name|struct
name|in_addr
name|ip_addr
decl_stmt|;
name|u_char
name|x25addr
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
union|union
block|{
name|struct
name|in_addr
name|ip
decl_stmt|;
struct|struct
block|{
comment|/*   (assumes Class A network number) */
name|u_char
name|s_net
decl_stmt|;
name|u_char
name|s_host
decl_stmt|;
name|u_char
name|s_lh
decl_stmt|;
name|u_char
name|s_impno
decl_stmt|;
block|}
name|imp
struct|;
block|}
name|imp_addr
union|;
name|imp_addr
operator|.
name|ip
operator|=
name|ip_addr
expr_stmt|;
name|x25addr
index|[
literal|0
index|]
operator|=
literal|14
expr_stmt|;
comment|/* set addr length */
name|x25addr
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* clear DNIC */
name|x25addr
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|x25addr
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|x25addr
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|imp_addr
operator|.
name|imp
operator|.
name|s_host
operator|<
literal|64
condition|)
comment|/* Physical:  0000 0 IIIHH00 [SS] */
block|{
comment|/*   s_impno -> III, s_host -> HH */
name|x25addr
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* set flag bit */
name|x25addr
index|[
literal|6
index|]
operator|=
name|imp_addr
operator|.
name|imp
operator|.
name|s_impno
operator|/
literal|100
expr_stmt|;
name|x25addr
index|[
literal|7
index|]
operator|=
operator|(
name|imp_addr
operator|.
name|imp
operator|.
name|s_impno
operator|%
literal|100
operator|)
operator|/
literal|10
expr_stmt|;
name|x25addr
index|[
literal|8
index|]
operator|=
name|imp_addr
operator|.
name|imp
operator|.
name|s_impno
operator|%
literal|10
expr_stmt|;
name|x25addr
index|[
literal|9
index|]
operator|=
name|imp_addr
operator|.
name|imp
operator|.
name|s_host
operator|/
literal|10
expr_stmt|;
name|x25addr
index|[
literal|10
index|]
operator|=
name|imp_addr
operator|.
name|imp
operator|.
name|s_host
operator|%
literal|10
expr_stmt|;
block|}
else|else
comment|/* Logical:   0000 1 RRRRR00 [SS]	*/
block|{
comment|/*   s_host * 256 + s_impno -> RRRRR	*/
name|temp
operator|=
operator|(
name|imp_addr
operator|.
name|imp
operator|.
name|s_host
operator|<<
literal|8
operator|)
operator|+
name|imp_addr
operator|.
name|imp
operator|.
name|s_impno
expr_stmt|;
name|x25addr
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
name|x25addr
index|[
literal|6
index|]
operator|=
name|temp
operator|/
literal|10000
expr_stmt|;
name|x25addr
index|[
literal|7
index|]
operator|=
operator|(
name|temp
operator|%
literal|10000
operator|)
operator|/
literal|1000
expr_stmt|;
name|x25addr
index|[
literal|8
index|]
operator|=
operator|(
name|temp
operator|%
literal|1000
operator|)
operator|/
literal|100
expr_stmt|;
name|x25addr
index|[
literal|9
index|]
operator|=
operator|(
name|temp
operator|%
literal|100
operator|)
operator|/
literal|10
expr_stmt|;
name|x25addr
index|[
literal|10
index|]
operator|=
name|temp
operator|%
literal|10
expr_stmt|;
block|}
name|x25addr
index|[
literal|11
index|]
operator|=
literal|0
expr_stmt|;
comment|/* clear rest of addr */
name|x25addr
index|[
literal|12
index|]
operator|=
literal|0
expr_stmt|;
name|x25addr
index|[
literal|13
index|]
operator|=
literal|0
expr_stmt|;
name|x25addr
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"convert_ip_addr():  "
argument_list|)
expr_stmt|;
name|prt_addr
argument_list|(
name|ip_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ==> "
argument_list|)
expr_stmt|;
name|prt_bytes
argument_list|(
name|x25addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *			convert_x25_addr()				* ************************************************************************* *									* *	This routine accepts an X25 address and attempts to translate	* *	to an equivalent internet address.  For DDN this follows the	* *	guidelines in the DDN X25 interface spec.  The resultant	* *	internet address is returned to the caller.			* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|convert_x25_addr
parameter_list|(
name|x25addr
parameter_list|)
name|u_char
name|x25addr
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
decl_stmt|,
name|temp
decl_stmt|;
union|union
block|{
name|struct
name|in_addr
name|ip
decl_stmt|;
struct|struct
block|{
comment|/*   (assumes Class A network number) */
name|u_char
name|s_net
decl_stmt|;
name|u_char
name|s_host
decl_stmt|;
name|u_char
name|s_lh
decl_stmt|;
name|u_char
name|s_impno
decl_stmt|;
block|}
name|imp
struct|;
block|}
name|imp_addr
union|;
if|if
condition|(
operator|(
operator|(
name|cnt
operator|=
name|x25addr
index|[
literal|0
index|]
operator|)
operator|<
literal|12
operator|)
operator|||
operator|(
name|cnt
operator|>
literal|14
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"DDN: illegal X25 address length!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|x25addr
index|[
literal|5
index|]
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|0
case|:
comment|/* Physical:  0000 0 IIIHH00 [SS]	*/
name|imp_addr
operator|.
name|imp
operator|.
name|s_impno
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|6
index|]
operator|&
literal|0x0f
argument_list|)
operator|*
literal|100
operator|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|7
index|]
operator|&
literal|0x0f
argument_list|)
operator|*
literal|10
operator|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|8
index|]
operator|&
literal|0x0f
argument_list|)
operator|)
expr_stmt|;
name|imp_addr
operator|.
name|imp
operator|.
name|s_host
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|9
index|]
operator|&
literal|0x0f
argument_list|)
operator|*
literal|10
operator|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|10
index|]
operator|&
literal|0x0f
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Logical:   0000 1 RRRRR00 [SS]	*/
name|temp
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|6
index|]
operator|&
literal|0x0f
argument_list|)
operator|*
literal|10000
operator|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|7
index|]
operator|&
literal|0x0f
argument_list|)
operator|*
literal|1000
operator|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|8
index|]
operator|&
literal|0x0f
argument_list|)
operator|*
literal|100
operator|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|9
index|]
operator|&
literal|0x0f
argument_list|)
operator|*
literal|10
operator|)
operator|+
operator|(
call|(
name|int
call|)
argument_list|(
name|x25addr
index|[
literal|10
index|]
operator|&
literal|0x0f
argument_list|)
operator|)
expr_stmt|;
name|imp_addr
operator|.
name|imp
operator|.
name|s_host
operator|=
name|temp
operator|>>
literal|8
expr_stmt|;
name|imp_addr
operator|.
name|imp
operator|.
name|s_impno
operator|=
name|temp
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"DDN: illegal X25 address format!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|imp_addr
operator|.
name|imp
operator|.
name|s_lh
operator|=
literal|0
expr_stmt|;
name|imp_addr
operator|.
name|imp
operator|.
name|s_net
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"convert_x25_addr():  "
argument_list|)
expr_stmt|;
name|prt_bytes
argument_list|(
operator|&
name|x25addr
index|[
literal|1
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ==> "
argument_list|)
expr_stmt|;
name|prt_addr
argument_list|(
name|imp_addr
operator|.
name|ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
return|return
operator|(
name|imp_addr
operator|.
name|ip
operator|.
name|s_addr
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *			make_x25_call()					* ************************************************************************* *									* *	This routine places an X25 call using the X25 Call Msg		* *	buffer.  The calling LCN is placed in the appropriate state	* *	and a timer is started.						* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|boolean
name|make_x25_call
parameter_list|(
name|ds
parameter_list|,
name|dc
parameter_list|)
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m_callbfr
decl_stmt|;
specifier|register
name|caddr_t
name|cb
decl_stmt|;
name|MGET
argument_list|(
name|m_callbfr
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* try to get call cmnd buffer */
if|if
condition|(
name|m_callbfr
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cb
operator|=
name|mtod
argument_list|(
name|m_callbfr
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|convert_ip_addr
argument_list|(
name|ds
operator|->
name|ddn_ipaddr
argument_list|,
name|cb_calling_addr
argument_list|)
expr_stmt|;
name|cb_protocol
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
name|cb_protocol
index|[
literal|1
index|]
operator|=
name|X25_PROTO_IP
expr_stmt|;
comment|/* protocol = IP */
name|cb_protocol
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cb_protocol
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cb_protocol
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|cb_facilities
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
comment|/* number facility bytes */
name|cb_facilities
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  options marker */
name|cb_facilities
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cb_facilities
index|[
literal|3
index|]
operator|=
name|X25_FACIL_DDN
expr_stmt|;
comment|/*  DDN standard mode */
name|cb_facilities
index|[
literal|4
index|]
operator|=
name|FAC_DDNSTD
expr_stmt|;
name|cb_user_data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no user data */
name|cb_cmnd
index|[
literal|0
index|]
operator|=
name|CALL
expr_stmt|;
comment|/* set command code */
name|cb_cmnd
index|[
literal|1
index|]
operator|=
name|dc
operator|->
name|dc_lcn
operator|<<
literal|1
expr_stmt|;
comment|/* set channel id */
name|cb_cmnd
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cb_cmnd
index|[
literal|3
index|]
operator|=
operator|(
name|cb_called_addr
index|[
literal|0
index|]
operator|+
literal|1
operator|)
operator|+
comment|/* tally up cmnd ext length */
operator|(
name|cb_calling_addr
index|[
literal|0
index|]
operator|+
literal|1
operator|)
operator|+
operator|(
name|cb_protocol
index|[
literal|0
index|]
operator|+
literal|1
operator|)
operator|+
operator|(
name|cb_facilities
index|[
literal|0
index|]
operator|+
literal|1
operator|)
operator|+
operator|(
name|cb_user_data
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|m_callbfr
operator|->
name|m_len
operator|=
name|cb_cmnd
index|[
literal|3
index|]
operator|+
literal|4
expr_stmt|;
comment|/* copy command header */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb_cmnd
argument_list|,
name|cb
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cb
operator|+=
literal|4
expr_stmt|;
comment|/* copy called address */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb_called_addr
argument_list|,
name|cb
argument_list|,
name|cb_called_addr
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|+=
operator|(
name|cb_called_addr
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy calling address */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb_calling_addr
argument_list|,
name|cb
argument_list|,
name|cb_calling_addr
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|+=
operator|(
name|cb_calling_addr
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy protocol */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb_protocol
argument_list|,
name|cb
argument_list|,
name|cb_protocol
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|+=
operator|(
name|cb_protocol
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy facilities */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb_facilities
argument_list|,
name|cb
argument_list|,
name|cb_facilities
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|+=
operator|(
name|cb_facilities
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy user data */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cb_user_data
argument_list|,
name|cb
argument_list|,
name|cb_user_data
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|+=
operator|(
name|cb_user_data
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|dc
operator|->
name|dc_state
operator|=
name|LC_CALL_PENDING
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_CALL_PENDING
expr_stmt|;
comment|/* start call timeout */
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"make_x25_call(): call_bfr = "
argument_list|)
expr_stmt|;
name|prt_bytes
argument_list|(
name|mtod
argument_list|(
name|m_callbfr
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m_callbfr
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|IF_ENQUEUE
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|.
name|dc_oq
operator|)
argument_list|,
name|m_callbfr
argument_list|)
expr_stmt|;
name|ddn_start
argument_list|(
name|ds
argument_list|,
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddn_start()				* ************************************************************************* *									* *	This routine attempts to start output of data queued on	a	* *	specific LCN.  If the LCN was not already busy and data is	* *	available for output, the data is copied into the LCN's I/O	* *	buffer and an I/O request queued to the UMC.			* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ddn_start
parameter_list|(
name|ds
parameter_list|,
name|dc
parameter_list|)
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*      * If output isn't active, attempt to      * start sending a new packet.      */
if|if
condition|(
operator|(
name|dc
operator|->
name|dc_flags
operator|&
name|DC_OBUSY
operator|)
operator|||
operator|(
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|dc
operator|->
name|dc_lcn
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dc
operator|->
name|dc_state
operator|!=
name|LC_DATA_IDLE
operator|)
operator|)
condition|)
block|{
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|dc
operator|->
name|dc_oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|len
operator|=
name|if_wubaput
argument_list|(
operator|&
name|dc
operator|->
name|dc_ifuba
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* copy data to mapped mem */
name|dc
operator|->
name|dc_flags
operator||=
name|DC_OBUSY
expr_stmt|;
name|ddn_iorq
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|len
argument_list|,
name|DDNWRT
operator|+
name|DDNEOS
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddn_iorq()				* ************************************************************************* *									* *	This routine builds UMC I/O requests and queues them for	* *	delivery to the UMC. If the UMC I/O request comm regs are	* *	not busy, the I/O request is passed to the UMC.			* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ddn_iorq
parameter_list|(
name|ds
parameter_list|,
name|dc
parameter_list|,
name|len
parameter_list|,
name|func
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
name|int
name|len
decl_stmt|,
name|func
decl_stmt|;
block|{
specifier|register
name|struct
name|hdx_chan
modifier|*
name|hc
decl_stmt|;
specifier|register
name|int
name|info
decl_stmt|;
comment|/* get appropriate UNIBUS mapping info */
if|if
condition|(
name|func
operator|&
name|DDNRDB
condition|)
comment|/* read or write? */
block|{
name|hc
operator|=
operator|&
name|dc
operator|->
name|dc_rchan
expr_stmt|;
name|info
operator|=
name|dc
operator|->
name|dc_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_info
expr_stmt|;
block|}
else|else
block|{
name|hc
operator|=
operator|&
name|dc
operator|->
name|dc_wchan
expr_stmt|;
name|info
operator|=
name|dc
operator|->
name|dc_ifuba
operator|.
name|ifu_w
operator|.
name|ifrw_info
expr_stmt|;
block|}
comment|/* set channel info */
name|hc
operator|->
name|hc_adx
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|info
operator|&
literal|0x30000
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_addr
operator|=
call|(
name|u_short
call|)
argument_list|(
name|info
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_cnt
operator|=
name|len
expr_stmt|;
name|hc
operator|->
name|hc_func
operator|=
operator|(
name|u_char
operator|)
name|func
expr_stmt|;
name|hc
operator|->
name|hc_sbfc
operator|=
literal|0
expr_stmt|;
comment|/*      * If UMC comm regs busy, queue start i/o for later.      */
if|if
condition|(
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
condition|)
block|{
operator|(
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_tail
operator|)
operator|->
name|hc_next
operator|=
name|hc
expr_stmt|;
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_tail
operator|=
name|hc
expr_stmt|;
name|hc
operator|->
name|hc_next
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* start i/o on channel now */
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
operator|=
name|hc
expr_stmt|;
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_tail
operator|=
name|hc
expr_stmt|;
name|hc
operator|->
name|hc_next
operator|=
literal|0
expr_stmt|;
name|start_chn
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				start_chn()				* ************************************************************************* *									* *	This routine copies UMC I/O requests into the UMC comm regs	* *	and notifies the UMC.						* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|start_chn
parameter_list|(
name|ds
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
block|{
specifier|register
name|struct
name|hdx_chan
modifier|*
name|hc
init|=
name|ds
operator|->
name|ddn_sioq
operator|.
name|sq_head
decl_stmt|;
specifier|register
name|struct
name|ddnregs
modifier|*
name|addr
init|=
operator|(
expr|struct
name|ddnregs
operator|*
operator|)
name|ddninfo
index|[
name|ds
operator|->
name|ddn_if
operator|.
name|if_unit
index|]
operator|->
name|ui_addr
decl_stmt|;
comment|/*      * Set up comm regs.      */
name|addr
operator|->
name|iochn
operator|=
name|hc
operator|->
name|hc_chan
expr_stmt|;
name|addr
operator|->
name|ioadx
operator|=
name|hc
operator|->
name|hc_adx
expr_stmt|;
name|addr
operator|->
name|ioadl
operator|=
name|hc
operator|->
name|hc_addr
expr_stmt|;
name|addr
operator|->
name|iocnt
operator|=
name|hc
operator|->
name|hc_cnt
expr_stmt|;
name|addr
operator|->
name|iofcn
operator|=
name|hc
operator|->
name|hc_func
expr_stmt|;
name|addr
operator|->
name|iosbf
operator|=
name|hc
operator|->
name|hc_sbfc
expr_stmt|;
name|addr
operator|->
name|ioini
operator|=
literal|1
expr_stmt|;
comment|/* signal UMC if necessary */
if|if
condition|(
operator|!
operator|(
name|addr
operator|->
name|ionmi
operator|)
condition|)
block|{
name|addr
operator|->
name|ionmi
operator|=
literal|1
expr_stmt|;
name|addr
operator|->
name|csr
operator|=
name|DDN_DMA
operator||
name|DDN_WRT
operator||
name|DDN_IEN
operator||
name|DDN_NMI
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddn_data()				* ************************************************************************* *									* *	This routine is called when a data channel I/O completes.	* *	If the completion was for a write, an attempt is made to	* *	start output on the next packet waiting for output on that	* *	LCN.  If the completion was for a read, the received packet	* *	is sent to the IP input queue (if no error) and another read	* *	is started on the LCN.						* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ddn_data
parameter_list|(
name|unit
parameter_list|,
name|chan
parameter_list|,
name|cc
parameter_list|,
name|rcnt
parameter_list|)
name|int
name|unit
decl_stmt|,
name|chan
decl_stmt|,
name|cc
decl_stmt|,
name|rcnt
decl_stmt|;
block|{
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
init|=
operator|&
name|ddn_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
init|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
name|chan
operator|/
literal|2
index|]
operator|)
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
init|=
operator|&
name|ipintrq
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|chan
operator|&
literal|0x01
condition|)
comment|/* was it read or write? */
block|{
comment|/*   write, fire up next output */
name|ds
operator|->
name|ddn_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|dc
operator|->
name|dc_flags
operator|&=
operator|~
name|DC_OBUSY
expr_stmt|;
name|ddn_start
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*   read, process rcvd packet */
block|{
if|if
condition|(
name|cc
operator|==
name|DDNIOCOK
condition|)
block|{
comment|/* Queue good packet for input */
name|ds
operator|->
name|ddn_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|dc
operator|->
name|dc_state
operator|=
name|LC_DATA_IDLE
expr_stmt|;
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_DATA_IDLE
expr_stmt|;
name|m
operator|=
name|if_rubaget
argument_list|(
operator|&
operator|(
name|dc
operator|->
name|dc_ifuba
operator|)
argument_list|,
name|rcnt
argument_list|,
literal|0
argument_list|,
operator|&
name|ds
operator|->
name|ddn_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* hang a new data read */
name|ddn_iorq
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|,
name|DDNMTU
argument_list|,
name|DDNRDB
operator|+
name|DDNSTR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				ddn_supr()				* ************************************************************************* *									* *	This routine is called when a supervisor I/O completes.		* *	If the completion was for a write, an attempt is made to	* *	start output on the next supervisor command waiting for		* *	output.  If the completion was for a read, the received		* *	supervisor message is processed and another read is started.	* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ddn_supr
parameter_list|(
name|unit
parameter_list|,
name|chan
parameter_list|,
name|cc
parameter_list|)
name|int
name|unit
decl_stmt|,
name|chan
decl_stmt|,
name|cc
decl_stmt|;
block|{
specifier|register
name|struct
name|ddn_softc
modifier|*
name|ds
init|=
operator|&
name|ddn_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
comment|/* was it read or write? */
if|if
condition|(
name|chan
operator|&
literal|0x01
condition|)
block|{
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|.
name|dc_flags
operator|&=
operator|~
name|DC_OBUSY
expr_stmt|;
name|ddn_start
argument_list|(
name|ds
argument_list|,
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cc
operator|==
name|DDNIOCOK
condition|)
block|{
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|.
name|dc_ifuba
operator|.
name|ifu_r
operator|.
name|ifrw_addr
operator|)
expr_stmt|;
comment|/* process supervisor message */
name|supr_msg
argument_list|(
name|ds
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* hang a new supr read */
name|ddn_iorq
argument_list|(
name|ds
argument_list|,
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|)
argument_list|,
name|DDNMTU
argument_list|,
name|DDNRDB
operator|+
name|DDNSTR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				supr_msg()				* ************************************************************************* *									* *	This routine processes received supervisor messages.		* *	Depending on the message type, the appropriate action is	* *	taken. *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|supr_msg
parameter_list|(
name|ds
parameter_list|,
name|p
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
name|u_char
name|p
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|int
name|lcn
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"supr_msg():  "
argument_list|)
expr_stmt|;
name|prt_bytes
argument_list|(
name|p
argument_list|,
literal|4
operator|+
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LINE_STATUS
case|:
comment|/*   link status msg */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
name|LINK_UP
condition|)
comment|/*   if link came up */
block|{
name|send_restart
argument_list|(
name|ds
argument_list|)
expr_stmt|;
comment|/*     send restart msg */
block|}
else|else
comment|/*   if link went down */
block|{
name|ds
operator|->
name|ddn_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|dc
operator|=
name|ds
operator|->
name|ddn_cb
expr_stmt|;
for|for
control|(
name|lcn
operator|=
literal|0
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/*    for all LCN's */
block|{
name|dc
operator|->
name|dc_state
operator|=
name|LC_DOWN
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_OFF
expr_stmt|;
comment|/* stop timer */
name|dc
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RESTART
case|:
comment|/* restart received */
if|if
condition|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|.
name|dc_state
operator|!=
name|LC_RESTART
condition|)
comment|/* if not restarting */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|RSTRT_ACK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*   send restart ack */
comment|/* fall thru */
case|case
name|RSTRT_ACK
case|:
comment|/* restart ack */
name|ds
operator|->
name|ddn_if
operator|.
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|dc
operator|=
name|ds
operator|->
name|ddn_cb
expr_stmt|;
for|for
control|(
name|lcn
operator|=
literal|0
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/* for all LCN's */
block|{
name|dc
operator|->
name|dc_state
operator|=
name|LC_IDLE
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_OFF
expr_stmt|;
comment|/* stop timer */
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
comment|/* forget address */
while|while
condition|(
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_len
condition|)
comment|/* drop pending data */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|dc
operator|->
name|dc_oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|dc
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ANSWER
case|:
comment|/* call answered */
name|lcn
operator|=
name|p
index|[
literal|1
index|]
operator|/
literal|2
expr_stmt|;
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
name|lcn
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|==
name|LC_CALL_PENDING
condition|)
comment|/* if a call pending */
block|{
name|dc
operator|->
name|dc_state
operator|=
name|LC_DATA_IDLE
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_DATA_IDLE
expr_stmt|;
comment|/* start timer */
name|ddn_start
argument_list|(
name|ds
argument_list|,
name|dc
argument_list|)
expr_stmt|;
comment|/* try to send data */
block|}
break|break;
case|case
name|RING
case|:
comment|/* incoming call */
for|for
control|(
name|lcn
operator|=
name|NDDNCH
init|;
name|lcn
operator|>
literal|0
condition|;
name|lcn
operator|--
control|)
comment|/* search LCN's */
block|{
if|if
condition|(
name|ds
operator|->
name|ddn_cb
index|[
name|lcn
index|]
operator|.
name|dc_state
operator|==
name|LC_IDLE
condition|)
comment|/* unused? */
break|break;
block|}
if|if
condition|(
name|lcn
operator|&&
name|decode_ring
argument_list|(
name|p
argument_list|)
condition|)
comment|/* if a free LCN found */
comment|/*   and ring looks ok */
block|{
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
name|lcn
index|]
operator|)
expr_stmt|;
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|=
name|convert_x25_addr
argument_list|(
name|cb_calling_addr
argument_list|)
expr_stmt|;
name|dc
operator|->
name|dc_state
operator|=
name|LC_DATA_IDLE
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_DATA_IDLE
expr_stmt|;
comment|/* start timer */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|ANSWER
argument_list|,
name|lcn
operator|*
literal|2
argument_list|,
operator|(
name|int
operator|)
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* send answer */
block|}
else|else
comment|/* if no free LCN's */
block|{
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARVC
argument_list|,
operator|(
name|int
operator|)
name|p
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear call */
block|}
break|break;
case|case
name|CLEARLC
case|:
comment|/* clear by LCN */
name|lcn
operator|=
name|p
index|[
literal|1
index|]
operator|/
literal|2
expr_stmt|;
comment|/* get LCN */
name|dc
operator|=
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
name|lcn
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|dc_state
operator|!=
name|LC_CLR_PENDING
condition|)
comment|/* if no clear pending */
block|{
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARLC
argument_list|,
operator|(
name|int
operator|)
name|p
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*   ack the clear */
block|}
name|dc
operator|->
name|dc_state
operator|=
name|LC_IDLE
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_OFF
expr_stmt|;
comment|/* stop timer */
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
comment|/* forget address */
while|while
condition|(
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_len
condition|)
comment|/* drop pending data */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|dc
operator|->
name|dc_oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLEARVC
case|:
comment|/* clear by VCN */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARVC
argument_list|,
operator|(
name|int
operator|)
name|p
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send clear ack */
break|break;
case|case
name|RESET
case|:
comment|/* X25 reset */
name|send_supr
argument_list|(
name|ds
argument_list|,
name|RESET_ACK
argument_list|,
operator|(
name|int
operator|)
name|p
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send reset ack */
name|printf
argument_list|(
literal|"X25 RESET on lcn = %d\n"
argument_list|,
name|p
index|[
literal|1
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* log it */
break|break;
case|case
name|INTERRUPT
case|:
comment|/* X25 interrupt */
name|printf
argument_list|(
literal|"X25 INTERRUPT on lcn = %d, code = %d\n"
argument_list|,
comment|/* log it */
name|p
index|[
literal|1
index|]
operator|/
literal|2
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ddn%d: supervisor error, code=%x\n"
argument_list|,
name|ds
operator|->
name|ddn_if
operator|.
name|if_unit
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				decode_ring()				* ************************************************************************* *									* *	This routine parses and validates the incoming call msg.	* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|boolean
name|decode_ring
parameter_list|(
name|p
parameter_list|)
specifier|register
name|u_char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"decode_ring()\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|p
operator|+=
literal|3
expr_stmt|;
comment|/* skip to cmnd ext length */
if|if
condition|(
operator|*
name|p
operator|++
operator|<
literal|5
condition|)
comment|/* is count appropriate */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*   return false if not */
comment|/* called address */
if|if
condition|(
operator|(
name|cnt
operator|=
operator|*
name|p
operator|+
literal|1
operator|)
operator|>
literal|16
condition|)
comment|/* is called addr len legal? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*   return false if not */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|cb_called_addr
argument_list|,
operator|(
name|unsigned
operator|)
name|cnt
argument_list|)
expr_stmt|;
comment|/* copy field */
name|p
operator|+=
name|cnt
expr_stmt|;
comment|/* calling address */
if|if
condition|(
operator|(
name|cnt
operator|=
operator|*
name|p
operator|+
literal|1
operator|)
operator|>
literal|16
condition|)
comment|/* is calling addr len legal? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*   return false if not */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|cb_calling_addr
argument_list|,
operator|(
name|unsigned
operator|)
name|cnt
argument_list|)
expr_stmt|;
comment|/* copy field */
name|p
operator|+=
name|cnt
expr_stmt|;
comment|/* protocol part of user data */
if|if
condition|(
operator|(
name|cnt
operator|=
operator|*
name|p
operator|+
literal|1
operator|)
operator|>
literal|5
condition|)
comment|/* is protocol len legal? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*   return false if not */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|cb_protocol
argument_list|,
operator|(
name|unsigned
operator|)
name|cnt
argument_list|)
expr_stmt|;
comment|/* copy field */
name|p
operator|+=
name|cnt
expr_stmt|;
comment|/* facilities */
if|if
condition|(
operator|(
name|cnt
operator|=
operator|*
name|p
operator|+
literal|1
operator|)
operator|>
literal|64
condition|)
comment|/* is facilities len legal? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*   return false if not */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|cb_facilities
argument_list|,
operator|(
name|unsigned
operator|)
name|cnt
argument_list|)
expr_stmt|;
comment|/* copy field */
name|p
operator|+=
name|cnt
expr_stmt|;
comment|/* ignore rest of user data for now */
if|if
condition|(
operator|(
name|cb_protocol
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|cb_protocol
index|[
literal|1
index|]
operator|!=
name|X25_PROTO_IP
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* bad if not IP */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* looks ok */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				clear_lcn()				* ************************************************************************* *									* *	This routine clears an X25 circuit and releases any buffers	* *	queued for transmission.					* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|clear_lcn
parameter_list|(
name|ds
parameter_list|,
name|dc
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"clear_lcn(%d)\n"
argument_list|,
name|dc
operator|->
name|dc_lcn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|dc
operator|->
name|dc_state
operator|=
name|LC_CLR_PENDING
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_CLR_PENDING
expr_stmt|;
comment|/* start clear timer */
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
comment|/* clear associated address */
while|while
condition|(
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_len
condition|)
comment|/* drop any pending data */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|dc
operator|->
name|dc_oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|send_supr
argument_list|(
name|ds
argument_list|,
name|CLEARLC
argument_list|,
operator|(
name|int
operator|)
name|dc
operator|->
name|dc_lcn
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send clear msg */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				send_restart()				* ************************************************************************* *									* *	This routine marks all LCNs as being in a restarting state	* *	and sends a restart command to X25.				* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|send_restart
parameter_list|(
name|ds
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
block|{
specifier|register
name|struct
name|ddn_cb
modifier|*
name|dc
decl_stmt|;
specifier|register
name|int
name|lcn
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"send_restart()\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|dc
operator|=
name|ds
operator|->
name|ddn_cb
expr_stmt|;
for|for
control|(
name|lcn
operator|=
literal|0
init|;
name|lcn
operator|<=
name|NDDNCH
condition|;
name|lcn
operator|++
control|)
comment|/* for all LCN's */
block|{
name|dc
operator|->
name|dc_state
operator|=
name|LC_RESTART
expr_stmt|;
comment|/* set state */
name|dc
operator|->
name|dc_timer
operator|=
name|TMO_RESTART
expr_stmt|;
comment|/* start restart timeout */
name|dc
operator|->
name|dc_inaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
comment|/* forget address */
while|while
condition|(
name|dc
operator|->
name|dc_oq
operator|.
name|ifq_len
condition|)
comment|/* drop any pending data */
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|dc
operator|->
name|dc_oq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|dc
operator|++
expr_stmt|;
block|}
name|send_supr
argument_list|(
name|ds
argument_list|,
name|RESTART
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send restart msg */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\ *				send_supr()				* ************************************************************************* *									* *	This routine is used to send short (4 bytes only) supervisor	* *	commands.							* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|send_supr
parameter_list|(
name|ds
parameter_list|,
name|cmd
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|)
name|struct
name|ddn_softc
modifier|*
name|ds
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|DDNDEBUG
if|if
condition|(
name|ddn_debug
operator|>
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"send_supr():  %x %x %x\n"
argument_list|,
name|cmd
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DDNDEBUG
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ddn%d: failed to get supr msg bfr!\n"
argument_list|,
name|ds
operator|->
name|ddn_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
comment|/* build supervisor message */
operator|*
name|cp
operator|++
operator|=
operator|(
name|byte
operator|)
name|cmd
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|byte
operator|)
name|p1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|byte
operator|)
name|p2
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|4
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|.
name|dc_oq
operator|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ddn_start
argument_list|(
name|ds
argument_list|,
operator|&
operator|(
name|ds
operator|->
name|ddn_cb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DDNDEBUG
end_ifdef

begin_comment
comment|/***********************************************************************\ *				prt_addr()				* ************************************************************************* *									* *	This routine is used to print internet addresses in the		* *	standard A.B.C.D format.					* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|prt_addr
parameter_list|(
name|addr
parameter_list|)
name|struct
name|in_addr
name|addr
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%d.%d.%d.%d"
argument_list|,
name|addr
operator|.
name|s_net
argument_list|,
name|addr
operator|.
name|s_host
argument_list|,
name|addr
operator|.
name|s_lh
argument_list|,
name|addr
operator|.
name|s_impno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************\ *				prt_bytes()				* ************************************************************************* *									* *	This routine is used to print a string of bytes in hex.		* *									* \***********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|prt_bytes
parameter_list|(
name|bp
parameter_list|,
name|cnt
parameter_list|)
name|u_char
modifier|*
name|bp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|*
name|bp
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|DDNDEBUG
end_endif

begin_endif
endif|#
directive|endif
endif|NDDN
end_endif

end_unit

