begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  *  *	@(#)hpmaptype.c	7.1 (Berkeley) 6/5/86  */
end_comment

begin_comment
comment|/*  * RP??/RM?? drive type mapping routine.  */
end_comment

begin_include
include|#
directive|include
file|"../machine/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/fs.h"
end_include

begin_include
include|#
directive|include
file|"../vaxmba/hpreg.h"
end_include

begin_include
include|#
directive|include
file|"../vaxmba/mbareg.h"
end_include

begin_include
include|#
directive|include
file|"saio.h"
end_include

begin_include
include|#
directive|include
file|"savax.h"
end_include

begin_comment
comment|/* THIS SHOULD BE READ IN OFF THE PACK, PER DRIVE */
end_comment

begin_decl_stmt
name|short
name|rp06_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|38
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|118
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rm03_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|100
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|309
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rm05_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|27
block|,
literal|0
block|,
literal|562
block|,
literal|589
block|,
literal|681
block|,
literal|562
block|,
literal|82
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rm80_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|37
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|115
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rp07_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|10
block|,
literal|0
block|,
literal|235
block|,
literal|245
block|,
literal|437
block|,
literal|235
block|,
literal|52
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ml_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|cdc9775_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|13
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|294
block|,
literal|66
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|cdc9730_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|155
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|capricorn_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|32
block|,
literal|0
block|,
literal|668
block|,
literal|723
block|,
literal|778
block|,
literal|668
block|,
literal|98
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|eagle_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|17
block|,
literal|0
block|,
literal|391
block|,
literal|408
block|,
literal|728
block|,
literal|391
block|,
literal|87
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|fj2361_off
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|13
block|,
literal|0
block|,
literal|294
block|,
literal|307
block|,
literal|547
block|,
literal|294
block|,
literal|66
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* END SHOULD BE READ IN */
end_comment

begin_comment
comment|/*  * hptypes is used to translate Massbus drive type and other information  * into an index in hpst.  The indices of hptypes and hpst must therefore agree.  */
end_comment

begin_decl_stmt
name|short
name|hptypes
index|[]
init|=
block|{
name|MBDT_RM03
block|,
name|MBDT_RM05
block|,
name|MBDT_RP06
block|,
name|MBDT_RM80
block|,
name|MBDT_RP05
block|,
name|MBDT_RP07
block|,
name|MBDT_ML11A
block|,
name|MBDT_ML11B
block|,
operator|-
literal|1
block|,
comment|/* 9755 */
operator|-
literal|1
block|,
comment|/* 9730 */
operator|-
literal|1
block|,
comment|/* Capricorn */
operator|-
literal|1
block|,
comment|/* Eagle */
name|MBDT_RM02
block|,
comment|/* actually something else */
operator|-
literal|1
block|,
comment|/* 9300 */
operator|-
literal|1
block|,
comment|/* 9766 */
operator|-
literal|1
block|,
comment|/* 2361 */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|st
name|hpst
index|[]
init|=
block|{
define|#
directive|define
name|HPDT_RM03
value|0
literal|32
block|,
literal|5
block|,
literal|32
operator|*
literal|5
block|,
literal|823
block|,
name|rm03_off
block|,
comment|/* RM03 */
define|#
directive|define
name|HPDT_RM05
value|1
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|823
block|,
name|rm05_off
block|,
comment|/* RM05 */
define|#
directive|define
name|HPDT_RP06
value|2
literal|22
block|,
literal|19
block|,
literal|22
operator|*
literal|19
block|,
literal|815
block|,
name|rp06_off
block|,
comment|/* RP06 */
define|#
directive|define
name|HPDT_RM80
value|3
literal|31
block|,
literal|14
block|,
literal|31
operator|*
literal|14
block|,
literal|559
block|,
name|rm80_off
block|,
comment|/* RM80 */
define|#
directive|define
name|HPDT_RP05
value|4
literal|22
block|,
literal|19
block|,
literal|22
operator|*
literal|19
block|,
literal|411
block|,
name|rp06_off
block|,
comment|/* RP05 */
define|#
directive|define
name|HPDT_RP07
value|5
literal|50
block|,
literal|32
block|,
literal|50
operator|*
literal|32
block|,
literal|630
block|,
name|rp07_off
block|,
comment|/* RP07 */
define|#
directive|define
name|HPDT_ML11A
value|6
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|ml_off
block|,
comment|/* ML11A */
define|#
directive|define
name|HPDT_ML11B
value|7
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|ml_off
block|,
comment|/* ML11B */
define|#
directive|define
name|HPDT_9775
value|8
literal|32
block|,
literal|40
block|,
literal|32
operator|*
literal|40
block|,
literal|843
block|,
name|cdc9775_off
block|,
comment|/* 9775 */
define|#
directive|define
name|HPDT_9730
value|9
literal|32
block|,
literal|10
block|,
literal|32
operator|*
literal|10
block|,
literal|823
block|,
name|cdc9730_off
block|,
comment|/* 9730 */
define|#
directive|define
name|HPDT_CAP
value|10
literal|32
block|,
literal|16
block|,
literal|32
operator|*
literal|16
block|,
literal|1024
block|,
name|capricorn_off
block|,
comment|/* Ampex capricorn */
define|#
directive|define
name|HPDT_EAGLE
value|11
literal|48
block|,
literal|20
block|,
literal|48
operator|*
literal|20
block|,
literal|842
block|,
name|eagle_off
block|,
comment|/* Fuji Eagle */
define|#
directive|define
name|HPDT_RM02
value|12
literal|32
block|,
literal|5
block|,
literal|32
operator|*
literal|5
block|,
literal|823
block|,
name|rm03_off
block|,
comment|/* rm02 - not used */
define|#
directive|define
name|HPDT_9300
value|13
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|815
block|,
name|rm05_off
block|,
comment|/* Ampex 9300 */
define|#
directive|define
name|HPDT_9766
value|14
literal|32
block|,
literal|19
block|,
literal|32
operator|*
literal|19
block|,
literal|823
block|,
name|rm05_off
block|,
comment|/* CDC 9766 */
define|#
directive|define
name|HPDT_2361
value|15
literal|64
block|,
literal|20
block|,
literal|64
operator|*
literal|20
block|,
literal|842
block|,
name|fj2361_off
block|,
comment|/* Fuji 2361 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NTYPES
value|(sizeof(hpst) / sizeof(hpst[0]))
end_define

begin_define
define|#
directive|define
name|MASKREG
parameter_list|(
name|reg
parameter_list|)
value|((reg)&0xffff)
end_define

begin_expr_stmt
name|hpmaptype
argument_list|(
name|hpaddr
argument_list|,
name|type
argument_list|,
name|unit
argument_list|)
specifier|register
expr|struct
name|hpdevice
operator|*
name|hpaddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|hpsn
decl_stmt|;
comment|/* 	 * Handle SI model byte stuff when 	 * we think it's an RM03 or RM05. 	 */
if|if
condition|(
name|type
operator|==
name|HPDT_RM03
operator|||
name|type
operator|==
name|HPDT_RM05
condition|)
block|{
name|hpsn
operator|=
name|hpaddr
operator|->
name|hpsn
expr_stmt|;
if|if
condition|(
operator|(
name|hpsn
operator|&
name|SIMB_LU
operator|)
operator|!=
name|unit
condition|)
return|return
operator|(
name|type
operator|)
return|;
switch|switch
condition|(
operator|(
name|hpsn
operator|&
name|SIMB_MB
operator|)
operator|&
operator|~
operator|(
name|SIMB_S6
operator||
name|SIRM03
operator||
name|SIRM05
operator|)
condition|)
block|{
case|case
name|SI9775D
case|:
return|return
operator|(
name|HPDT_9775
operator|)
return|;
case|case
name|SI9730D
case|:
return|return
operator|(
name|HPDT_9730
operator|)
return|;
case|case
name|SI9766
case|:
return|return
operator|(
name|HPDT_9766
operator|)
return|;
case|case
name|SI9762
case|:
return|return
operator|(
name|HPDT_RM03
operator|)
return|;
case|case
name|SICAPD
case|:
return|return
operator|(
name|HPDT_CAP
operator|)
return|;
case|case
name|SI9751D
case|:
return|return
operator|(
name|HPDT_EAGLE
operator|)
return|;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
comment|/* 	 * RM02: EMULEX controller.  Map to correct 	 * drive type by checking the holding 	 * register for the disk geometry. 	 */
if|if
condition|(
name|type
operator|==
name|HPDT_RM02
condition|)
block|{
name|int
name|newtype
decl_stmt|,
name|nsectors
decl_stmt|,
name|ntracks
decl_stmt|,
name|ncyl
decl_stmt|;
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_NOP
expr_stmt|;
name|hpaddr
operator|->
name|hphr
operator|=
name|HPHR_MAXTRAK
expr_stmt|;
name|ntracks
operator|=
name|MASKREG
argument_list|(
name|hpaddr
operator|->
name|hphr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_NOP
expr_stmt|;
name|hpaddr
operator|->
name|hphr
operator|=
name|HPHR_MAXSECT
expr_stmt|;
name|nsectors
operator|=
name|MASKREG
argument_list|(
name|hpaddr
operator|->
name|hphr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_NOP
expr_stmt|;
name|hpaddr
operator|->
name|hphr
operator|=
name|HPHR_MAXCYL
expr_stmt|;
name|ncyl
operator|=
name|MASKREG
argument_list|(
name|hpaddr
operator|->
name|hphr
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|newtype
operator|=
literal|0
init|;
name|newtype
operator|<
name|NTYPES
condition|;
name|newtype
operator|++
control|)
if|if
condition|(
name|hpst
index|[
name|newtype
index|]
operator|.
name|nsect
operator|==
name|nsectors
operator|&&
name|hpst
index|[
name|newtype
index|]
operator|.
name|ntrak
operator|==
name|ntracks
operator|&&
name|hpst
index|[
name|newtype
index|]
operator|.
name|ncyl
operator|==
name|ncyl
condition|)
break|break;
if|if
condition|(
name|newtype
operator|>=
name|NTYPES
condition|)
block|{
name|printf
argument_list|(
literal|"RM02 with %d sectors, %d tracks, %d cylinders?\n"
argument_list|,
name|nsectors
argument_list|,
name|ntracks
argument_list|,
name|ncyl
argument_list|)
expr_stmt|;
name|newtype
operator|=
name|type
expr_stmt|;
block|}
name|done
label|:
name|hpaddr
operator|->
name|hpcs1
operator|=
name|HP_DCLR
operator||
name|HP_GO
expr_stmt|;
return|return
operator|(
name|newtype
operator|)
return|;
block|}
comment|/* 	 * ML11's all map to the same type. 	 */
if|if
condition|(
name|type
operator|==
name|HPDT_ML11A
operator|||
name|type
operator|==
name|HPDT_ML11B
condition|)
return|return
operator|(
name|HPDT_ML11A
operator|)
return|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_block

end_unit

