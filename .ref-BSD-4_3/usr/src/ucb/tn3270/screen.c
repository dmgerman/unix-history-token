begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright 1984, 1985 by the Regents of the University of  *	California and by Gregory Glenn Minshall.  *  *	Permission to use, copy, modify, and distribute these  *	programs and their documentation for any purpose and  *	without fee is hereby granted, provided that this  *	copyright and permission appear on all copies and  *	supporting documentation, the name of the Regents of  *	the University of California not be used in advertising  *	or publicity pertaining to distribution of the programs  *	without specific prior permission, and notice be given in  *	supporting documentation that copying and distribution is  *	by permission of the Regents of the University of California  *	and by Gregory Glenn Minshall.  Neither the Regents of the  *	University of California nor Gregory Glenn Minshall make  *	representations about the suitability of this software  *	for any purpose.  It is provided "as is" without  *	express or implied warranty.  */
end_comment

begin_comment
comment|/* this file implements primitives to drive the screen. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)screen.c	2.1	4/11/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"3270.h"
end_include

begin_decl_stmt
name|char
name|CIABuffer
index|[
literal|64
index|]
init|=
block|{
literal|0x40
block|,
literal|0xc1
block|,
literal|0xc2
block|,
literal|0xc3
block|,
literal|0xc4
block|,
literal|0xc5
block|,
literal|0xc6
block|,
literal|0xc7
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0x4a
block|,
literal|0x4b
block|,
literal|0x4c
block|,
literal|0x4d
block|,
literal|0x4e
block|,
literal|0x4f
block|,
literal|0x50
block|,
literal|0xd1
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0x5a
block|,
literal|0x5b
block|,
literal|0x5c
block|,
literal|0x5d
block|,
literal|0x5e
block|,
literal|0x5f
block|,
literal|0x60
block|,
literal|0x61
block|,
literal|0xe2
block|,
literal|0xe3
block|,
literal|0xe4
block|,
literal|0xe5
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xe8
block|,
literal|0xe9
block|,
literal|0x6a
block|,
literal|0x6b
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0x6e
block|,
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xf1
block|,
literal|0xf2
block|,
literal|0xf3
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf6
block|,
literal|0xf7
block|,
literal|0xf8
block|,
literal|0xf9
block|,
literal|0x7a
block|,
literal|0x7b
block|,
literal|0x7c
block|,
literal|0x7d
block|,
literal|0x7e
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the routines compiled if we are using a parallel array to hold 	the field information...  */
end_comment

begin_comment
comment|/* What is the screen address of the attribute byte for the terminal */
end_comment

begin_expr_stmt
name|WhereTermAttrByte
argument_list|(
name|p
argument_list|)
specifier|register
name|int
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|p
expr_stmt|;
do|do
block|{
if|if
condition|(
name|TermIsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
block|}
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|p
condition|)
do|;
return|return
operator|(
name|LowestScreen
argument_list|()
operator|)
return|;
comment|/* unformatted screen... */
block|}
end_block

begin_comment
comment|/* What we know is that table is of size SCREENSIZE */
end_comment

begin_expr_stmt
name|FieldFind
argument_list|(
name|table
argument_list|,
name|position
argument_list|,
name|failure
argument_list|)
specifier|register
name|char
operator|*
name|table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* which table of bytes to use */
end_comment

begin_decl_stmt
specifier|register
name|int
name|position
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what position to start from */
end_comment

begin_decl_stmt
name|int
name|failure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if unformatted, what value to return */
end_comment

begin_block
block|{
specifier|register
name|int
name|ourp
decl_stmt|;
name|ourp
operator|=
name|position
operator|+
literal|1
operator|+
name|bskip
argument_list|(
name|table
operator|+
name|position
operator|+
literal|1
argument_list|,
name|SCREENSIZE
operator|-
name|position
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourp
operator|<
name|SCREENSIZE
condition|)
block|{
return|return
operator|(
name|ourp
operator|)
return|;
block|}
comment|/* No fields in table after position.  Look for fields from beginning      * of table.      */
name|ourp
operator|=
name|bskip
argument_list|(
name|table
argument_list|,
name|position
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourp
operator|<=
name|position
condition|)
block|{
return|return
operator|(
name|ourp
operator|)
return|;
block|}
return|return
operator|(
name|failure
operator|)
return|;
block|}
end_block

end_unit

