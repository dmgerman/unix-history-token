begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright 1984, 1985 by the Regents of the University of  *	California and by Gregory Glenn Minshall.  *  *	Permission to use, copy, modify, and distribute these  *	programs and their documentation for any purpose and  *	without fee is hereby granted, provided that this  *	copyright and permission appear on all copies and  *	supporting documentation, the name of the Regents of  *	the University of California not be used in advertising  *	or publicity pertaining to distribution of the programs  *	without specific prior permission, and notice be given in  *	supporting documentation that copying and distribution is  *	by permission of the Regents of the University of California  *	and by Gregory Glenn Minshall.  Neither the Regents of the  *	University of California nor Gregory Glenn Minshall make  *	representations about the suitability of this software  *	for any purpose.  It is provided "as is" without  *	express or implied warranty.  */
end_comment

begin_comment
comment|/* test stub for DataFrom3270, etc. */
end_comment

begin_define
define|#
directive|define
name|DEFINEAIDS
end_define

begin_include
include|#
directive|include
file|"m4.out"
end_include

begin_comment
comment|/* output of termcodes.m4 */
end_comment

begin_include
include|#
directive|include
file|"ascebc.h"
end_include

begin_include
include|#
directive|include
file|"3270.h"
end_include

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"ectype.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)keyboard.c	2.6	4/4/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef lint */
end_comment

begin_define
define|#
directive|define
name|EmptyChar
value|(ourPTail == ourBuffer)
end_define

begin_define
define|#
directive|define
name|FullChar
value|(ourPTail == ourBuffer+sizeof ourBuffer)
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|char
name|ascebc
index|[
name|NASCEBC
index|]
index|[
name|NASCII
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ourBuffer
index|[
literal|4000
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ourPHead
init|=
name|ourBuffer
decl_stmt|,
modifier|*
name|ourPTail
init|=
name|ourBuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trTbl
init|=
name|AE_IN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which ascii->ebcdic tr table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|HadAid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Had an AID haven't sent */
end_comment

begin_comment
comment|/* the following are global variables */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|UnLocked
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyboard is UnLocked? */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Tab() - sets cursor to the start of the next unprotected field */
end_comment

begin_function
specifier|static
name|void
name|Tab
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
name|CursorAddress
expr_stmt|;
name|j
operator|=
name|WhereAttrByte
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
operator|&&
name|IsUnProtected
argument_list|(
name|ScreenInc
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|i
operator|=
name|FieldInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
operator|&&
name|IsUnProtected
argument_list|(
name|ScreenInc
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* BackTab() - sets cursor to the start of the most recent field */
end_comment

begin_function
specifier|static
name|void
name|BackTab
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|ScreenDec
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EraseEndOfField - erase all characters to the end of a field */
end_comment

begin_expr_stmt
specifier|static
name|EraseEndOfField
argument_list|()
block|{
specifier|register
name|int
name|i
block|;
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|TurnOnMdt
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
name|i
operator|=
name|CursorAddress
expr_stmt|;
do|do
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|!=
name|CursorAddress
operator|)
operator|&&
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
do|;
block|}
end_else

begin_comment
unit|}
comment|/* Delete() - deletes a character from the screen  *  *	What we want to do is delete the section  *	[where, from-1] from the screen,  *	filling in with what comes at from.  *  *	The deleting continues to the end of the field (or  *	until the cursor wraps).  *  *	From can be a start of a field.  We  *	check for that.  However, there can't be any  *	fields that start between where and from.  *	We don't check for that.  *  *	Also, we assume that the protection status of  *	everything has been checked by the caller.  *  */
end_comment

begin_expr_stmt
unit|static
name|Delete
argument_list|(
name|where
argument_list|,
name|from
argument_list|)
specifier|register
name|int
name|where
operator|,
comment|/* Where to start deleting from */
name|from
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Where to pull back from */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TurnOnMdt
argument_list|(
name|where
argument_list|)
expr_stmt|;
comment|/* Only do this once in this field */
name|i
operator|=
name|where
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stick the edge at the start field */
block|}
else|else
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
name|GetHost
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|ScreenInc
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* Move the edge */
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|IsStartField
argument_list|(
name|i
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|!=
name|where
operator|)
condition|)
do|;
block|}
end_block

begin_macro
name|ColBak
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|OptColTabs
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|CursorAddress
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ColTab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|LINESIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|OptColTabs
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|LINESIZE
condition|)
block|{
name|i
operator|=
name|LINESIZE
operator|-
literal|1
expr_stmt|;
block|}
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|CursorAddress
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|Home
argument_list|()
block|{
specifier|register
name|int
name|i
block|;
specifier|register
name|int
name|j
block|;
name|i
operator|=
name|SetBufferAddress
argument_list|(
name|OptHome
argument_list|,
literal|0
argument_list|)
block|;
name|j
operator|=
name|WhereLowByte
argument_list|(
name|i
argument_list|)
block|;
do|do
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
return|return;
block|}
comment|/* the following could be a problem if we got here with an 	     * unformatted screen.  However, this is "impossible", since 	     * with an unformatted screen, the IsUnProtected(i) above 	     * should be true. 	     */
name|i
operator|=
name|ScreenInc
argument_list|(
name|FieldInc
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} while
operator|(
name|i
operator|!=
name|j
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CursorAddress
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  static
name|LastOfField
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* position to start from */
end_comment

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|k
operator|=
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|IsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
block|{
break|break;
block|}
block|}
comment|/* We are now IN a word IN an unprotected field (or wrapped) */
while|while
condition|(
operator|!
name|IsProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|k
operator|=
name|i
expr_stmt|;
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|FlushChar
argument_list|()
block|{
name|ourPTail
operator|=
name|ourPHead
operator|=
name|ourBuffer
block|; }
specifier|static
name|AddChar
argument_list|(
argument|character
argument_list|)
name|char
name|character
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|ourPHead
operator|++
operator|=
name|character
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|SendUnformatted
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|Nulls
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* look for start of field */
name|Nulls
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
do|do
block|{
name|c
operator|=
name|GetHost
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|Nulls
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|Nulls
condition|)
block|{
name|Nulls
operator|--
expr_stmt|;
name|AddChar
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* put in blanks */
block|}
name|AddChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
block|}
end_function

begin_expr_stmt
specifier|static
name|SendField
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* where we saw MDT bit */
end_comment

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|Nulls
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* look for start of field */
name|i
operator|=
name|j
operator|=
name|WhereLowByte
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|ORDER_SBA
argument_list|)
expr_stmt|;
comment|/* set start field */
name|AddChar
argument_list|(
name|BufferTo3270_0
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set address of this field */
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsStartField
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|Nulls
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|ScreenInc
argument_list|(
name|WhereHighByte
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|c
operator|=
name|GetHost
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|Nulls
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|Nulls
condition|)
block|{
name|Nulls
operator|--
expr_stmt|;
name|AddChar
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* put in blanks */
block|}
name|AddChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|ScreenInc
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|j
operator|!=
name|k
operator|)
operator|&&
operator|(
name|j
operator|!=
name|i
operator|)
condition|)
do|;
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Various types of reads... */
end_comment

begin_macro
name|DoReadModified
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|AidByte
condition|)
block|{
name|AddChar
argument_list|(
name|AidByte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AddChar
argument_list|(
literal|0x60
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|AidByte
operator|!=
name|AID_PA1
operator|)
operator|&&
operator|(
name|AidByte
operator|!=
name|AID_PA2
operator|)
operator|&&
operator|(
name|AidByte
operator|!=
name|AID_PA3
operator|)
operator|&&
operator|(
name|AidByte
operator|!=
name|AID_CLEAR
operator|)
condition|)
block|{
name|AddChar
argument_list|(
name|BufferTo3270_0
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
operator|=
name|WhereAttrByte
argument_list|(
name|LowestScreen
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Is this an unformatted screen? */
if|if
condition|(
operator|!
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* yes, handle separate */
name|SendUnformatted
argument_list|()
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|HasMdt
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|i
operator|=
name|SendField
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|FieldInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
block|}
block|}
name|ourPTail
operator|+=
name|DataToNetwork
argument_list|(
name|ourPTail
argument_list|,
name|ourPHead
operator|-
name|ourPTail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourPTail
operator|==
name|ourPHead
condition|)
block|{
name|FlushChar
argument_list|()
expr_stmt|;
name|HadAid
operator|=
literal|0
expr_stmt|;
comment|/* killed that buffer */
block|}
block|}
end_block

begin_comment
comment|/* A read buffer operation... */
end_comment

begin_macro
name|DoReadBuffer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|AidByte
condition|)
block|{
name|AddChar
argument_list|(
name|AidByte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AddChar
argument_list|(
literal|0x60
argument_list|)
expr_stmt|;
block|}
name|AddChar
argument_list|(
name|BufferTo3270_0
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|AddChar
argument_list|(
name|ORDER_SF
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|FieldAttributes
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AddChar
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
name|ourPTail
operator|+=
name|DataToNetwork
argument_list|(
name|ourPTail
argument_list|,
name|ourPHead
operator|-
name|ourPTail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourPTail
operator|==
name|ourPHead
condition|)
block|{
name|FlushChar
argument_list|()
expr_stmt|;
name|HadAid
operator|=
literal|0
expr_stmt|;
comment|/* killed that buffer */
block|}
block|}
end_block

begin_comment
comment|/* Try to send some data to host */
end_comment

begin_macro
name|SendToIBM
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|TransparentClock
decl_stmt|,
name|OutputClock
decl_stmt|;
if|if
condition|(
name|TransparentClock
operator|==
name|OutputClock
condition|)
block|{
if|if
condition|(
name|HadAid
condition|)
block|{
name|AddChar
argument_list|(
name|AidByte
argument_list|)
expr_stmt|;
name|HadAid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|AddChar
argument_list|(
literal|0xe8
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|ourPTail
operator|+=
name|DataToNetwork
argument_list|(
name|ourPTail
argument_list|,
name|ourPHead
operator|-
name|ourPTail
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ourPTail
operator|!=
name|ourPHead
condition|)
do|;
name|FlushChar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HadAid
condition|)
block|{
name|DoReadModified
argument_list|()
expr_stmt|;
block|}
name|netflush
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This takes in one character from the keyboard and places it on the  * screen.  */
end_comment

begin_expr_stmt
specifier|static
name|OneCharacter
argument_list|(
argument|c
argument_list|,
argument|insert
argument_list|)
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* character (Ebcdic) to be shoved in */
end_comment

begin_decl_stmt
name|int
name|insert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are we in insert mode? */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|insert
condition|)
block|{
comment|/* is the last character in the field a blank or null? */
name|i
operator|=
name|ScreenDec
argument_list|(
name|FieldInc
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
name|GetHost
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Eisspace
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|!=
name|CursorAddress
condition|;
name|j
operator|=
name|ScreenDec
argument_list|(
name|j
argument_list|)
operator|,
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
control|)
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
name|GetHost
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|AddHost
argument_list|(
name|CursorAddress
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|TurnOnMdt
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsStartField
argument_list|(
name|CursorAddress
argument_list|)
operator|&&
operator|(
operator|(
name|FieldAttributes
argument_list|(
name|CursorAddress
argument_list|)
operator|&
name|ATTR_AUTO_SKIP_MASK
operator|)
operator|==
name|ATTR_AUTO_SKIP_VALUE
operator|)
condition|)
block|{
name|Tab
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* go through data until an AID character is hit, then generate an interrupt */
end_comment

begin_macro
name|DataFrom3270
argument_list|(
argument|buffer
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where the data is */
end_comment

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how much data there is */
end_comment

begin_block
block|{
name|int
name|origCount
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|static
name|int
name|InsertMode
init|=
literal|0
decl_stmt|;
comment|/* is the terminal in insert mode? */
specifier|extern
name|int
name|OutputClock
decl_stmt|,
name|TransparentClock
decl_stmt|;
if|if
condition|(
operator|!
name|UnLocked
operator|||
name|HadAid
condition|)
block|{
if|if
condition|(
name|HadAid
condition|)
block|{
name|SendToIBM
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|EmptyChar
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to do */
block|}
block|}
if|if
condition|(
operator|!
name|HadAid
operator|&&
operator|(
operator|(
operator|(
operator|*
name|buffer
operator|&
literal|0xff
operator|)
operator|==
name|TC_RESET
operator|)
operator|||
operator|(
operator|(
operator|*
name|buffer
operator|&
literal|0xff
operator|)
operator|==
name|TC_MASTER_RESET
operator|)
operator|)
operator|&&
name|EmptyChar
condition|)
block|{
name|UnLocked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|UnLocked
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* now, either empty, or haven't seen aid yet */
name|origCount
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|TransparentClock
operator|==
name|OutputClock
condition|)
block|{
while|while
condition|(
name|count
condition|)
block|{
name|c
operator|=
operator|(
operator|*
name|buffer
operator|++
operator|)
operator|&
literal|0xff
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|IsAid
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|UnLocked
operator|=
literal|0
expr_stmt|;
name|InsertMode
operator|=
literal|0
expr_stmt|;
name|AidByte
operator|=
name|TCtoAid
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|HadAid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TC_ESCAPE
case|:
name|Stop3270
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ConnectScreen
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_RESET
case|:
case|case
name|TC_MASTER_RESET
case|:
name|UnLocked
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|origCount
operator|-
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
return|;
block|}
block|}
block|}
block|}
while|while
condition|(
name|count
condition|)
block|{
name|c
operator|=
operator|(
operator|*
name|buffer
operator|++
operator|)
operator|&
literal|0xff
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|IsTc
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Add the character to the buffer */
name|OneCharacter
argument_list|(
name|ascebc
index|[
name|trTbl
index|]
index|[
name|c
index|]
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsAid
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* got Aid */
if|if
condition|(
name|c
operator|==
name|TC_CLEAR
condition|)
block|{
name|LocalClear3270
argument_list|()
expr_stmt|;
block|}
name|UnLocked
operator|=
literal|0
expr_stmt|;
name|InsertMode
operator|=
literal|0
expr_stmt|;
comment|/* just like a 3278 */
name|AidByte
operator|=
name|TCtoAid
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|HadAid
operator|=
literal|1
expr_stmt|;
name|SendToIBM
argument_list|()
expr_stmt|;
return|return
operator|(
name|origCount
operator|-
name|count
operator|)
return|;
block|}
else|else
block|{
comment|/* non-AID TC character */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TC_ERASE
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|CursorAddress
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|CursorAddress
argument_list|,
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TC_WERASE
case|:
name|j
operator|=
name|CursorAddress
expr_stmt|;
name|i
operator|=
name|ScreenDec
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
operator|!
name|IsProtected
argument_list|(
name|i
argument_list|)
operator|&&
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|!=
name|j
operator|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* we are pointing at a character in a word, or 		     * at a protected position 		     */
while|while
condition|(
operator|(
operator|!
name|IsProtected
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|!=
name|j
operator|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* we are pointing at a space, or at a protected 		     * position 		     */
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|CursorAddress
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TC_FERASE
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
comment|/* for btab */
name|BackTab
argument_list|()
expr_stmt|;
name|EraseEndOfField
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TC_RESET
case|:
name|InsertMode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TC_MASTER_RESET
case|:
name|InsertMode
operator|=
literal|0
expr_stmt|;
name|RefreshScreen
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_UP
case|:
name|CursorAddress
operator|=
name|ScreenUp
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|TC_LEFT
case|:
name|CursorAddress
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|TC_RIGHT
case|:
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|TC_DOWN
case|:
name|CursorAddress
operator|=
name|ScreenDown
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|TC_DELETE
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Delete
argument_list|(
name|CursorAddress
argument_list|,
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TC_INSRT
case|:
name|InsertMode
operator|=
operator|!
name|InsertMode
expr_stmt|;
break|break;
case|case
name|TC_HOME
case|:
name|Home
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_NL
case|:
comment|/* The algorithm is to look for the first unprotected 		 * column after column 0 of the following line.  Having 		 * found that unprotected column, we check whether the 		 * cursor-address-at-entry is at or to the right of the 		 * LeftMargin AND the LeftMargin column of the found line 		 * is unprotected.  If this conjunction is true, then 		 * we set the found pointer to the address of the LeftMargin 		 * column in the found line. 		 * Then, we set the cursor address to the found address. 		 */
name|i
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|ScreenDown
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
name|ScreenInc
argument_list|(
name|WhereAttrByte
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* Again (see comment in Home()), this COULD be a problem 		     * with an unformatted screen. 		     */
comment|/* If there was a field with only an attribute byte, 		     * we may be pointing to the attribute byte of the NEXT 		     * field, so just look at the next byte. 		     */
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|FieldInc
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
if|if
condition|(
operator|!
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* couldn't find unprotected */
name|i
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OptLeftMargin
operator|<=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|OptLeftMargin
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|OptLeftMargin
argument_list|)
expr_stmt|;
block|}
block|}
name|CursorAddress
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|TC_EINP
case|:
name|i
operator|=
name|j
operator|=
name|ScreenInc
argument_list|(
name|WhereAttrByte
argument_list|(
name|LowestScreen
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TurnOnMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FieldInc() puts us at the start of the next 			     * field. 			     * 			     * We don't want to skip to the start of the 			     * next field if we are on the attribute byte, 			     * since we may be skipping over an otherwise 			     * unprotected field. 			     * 			     * Also, j points at the first byte of the first 			     * field on the screen, unprotected or not.  If 			     * we never point there, we might loop here for 			     * ever. 			     */
if|if
condition|(
operator|!
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|i
operator|=
name|FieldInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
name|Home
argument_list|()
expr_stmt|;
comment|/* get to home position */
break|break;
case|case
name|TC_EEOF
case|:
name|EraseEndOfField
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_FM
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|OneCharacter
argument_list|(
name|EBCDIC_FM
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
comment|/* Add field mark */
block|}
break|break;
case|case
name|TC_DP
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
break|break;
block|}
name|OneCharacter
argument_list|(
name|EBCDIC_DUP
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
comment|/* Add dup character */
name|Tab
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_TAB
case|:
name|Tab
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_BTAB
case|:
name|BackTab
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|NOTUSED
comment|/* Actually, this is superseded by unix flow 				 * control. 				 */
case|case
name|TC_XOFF
case|:
name|Flow
operator|=
literal|0
expr_stmt|;
comment|/* stop output */
break|break;
case|case
name|TC_XON
case|:
if|if
condition|(
operator|!
name|Flow
condition|)
block|{
name|Flow
operator|=
literal|1
expr_stmt|;
comment|/* turn it back on */
name|DoTerminalOutput
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* NOTUSED */
case|case
name|TC_ESCAPE
case|:
comment|/* FlushChar(); do we want to flush characters from before? */
name|Stop3270
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ConnectScreen
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_DISC
case|:
name|Stop3270
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|suspend
argument_list|()
expr_stmt|;
name|ConnectScreen
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_RESHOW
case|:
name|RefreshScreen
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_SETTAB
case|:
name|OptColTabs
index|[
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TC_DELTAB
case|:
name|OptColTabs
index|[
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TC_CLRTAB
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|OptColTabs
condition|;
name|i
operator|++
control|)
block|{
name|OptColTabs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|TC_COLTAB
case|:
name|ColTab
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_COLBAK
case|:
name|ColBak
argument_list|()
expr_stmt|;
break|break;
case|case
name|TC_INDENT
case|:
name|ColTab
argument_list|()
expr_stmt|;
name|OptLeftMargin
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|TC_UNDENT
case|:
name|ColBak
argument_list|()
expr_stmt|;
name|OptLeftMargin
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|TC_SETMRG
case|:
name|OptLeftMargin
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|TC_SETHOM
case|:
name|OptHome
operator|=
name|ScreenLine
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Point to first character of next unprotected word on 		 * screen. 		 */
case|case
name|TC_WORDTAB
case|:
name|i
operator|=
name|CursorAddress
expr_stmt|;
while|while
condition|(
operator|!
name|IsProtected
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
comment|/* i is either protected, a space (blank or null), 		 * or wrapped 		 */
while|while
condition|(
name|IsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
name|CursorAddress
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|TC_WORDBACKTAB
case|:
name|i
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
while|while
condition|(
name|IsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
comment|/* i is pointing to a character IN an unprotected word 		     * (or i wrapped) 		     */
while|while
condition|(
operator|!
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
comment|/* Point to last non-blank character of this/next 			 * unprotected word. 			 */
case|case
name|TC_WORDEND
case|:
name|i
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
while|while
condition|(
name|IsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
comment|/* we are pointing at a character IN an 			 * unprotected word (or we wrapped) 			 */
while|while
condition|(
operator|!
name|Eisspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
name|CursorAddress
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
comment|/* Get to last non-blank of this/next unprotected 			 * field. 			 */
case|case
name|TC_FIELDEND
case|:
name|i
operator|=
name|LastOfField
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|CursorAddress
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
comment|/* We moved; take this */
block|}
else|else
block|{
name|j
operator|=
name|FieldInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
comment|/* Move to next field */
name|i
operator|=
name|LastOfField
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
comment|/* We moved; take this */
block|}
comment|/* else - nowhere else on screen to be; stay here */
block|}
break|break;
default|default:
name|RingBell
argument_list|()
expr_stmt|;
comment|/* We don't handle this yet */
block|}
block|}
block|}
return|return
operator|(
name|origCount
operator|-
name|count
operator|)
return|;
block|}
end_block

end_unit

