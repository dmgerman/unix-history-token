begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1985 Regents of the University of California.  *   * Use and reproduction of this software are granted  in  accordance  with  * the terms and conditions specified in  the  Berkeley  Software  License  * Agreement (in particular, this entails acknowledgement of the programs'  * source, and inclusion of this notice) with the additional understanding  * that  all  recipients  should regard themselves as participants  in  an  * ongoing  research  project and hence should  feel  obligated  to report  * their  experiences (good or bad) with these elementary function  codes,  * using "sendbug 4bsd-bugs@BERKELEY", to the authors.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)atan2.c	1.3 (Berkeley) 8/21/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/* ATAN2(Y,X)  * RETURN ARG (X+iY)  * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)  * CODED IN C BY K.C. NG, 1/8/85;   * REVISED BY K.C. NG on 2/7/85, 2/13/85, 3/7/85, 3/30/85, 6/29/85.  *  * Required system supported functions :  *	copysign(x,y)  *	scalb(x,y)  *	logb(x)  *	  * Method :  *	1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).  *	2. Reduce x to positive by (if x and y are unexceptional):   *		ARG (x+iy) = arctan(y/x)   	   ... if x> 0,  *		ARG (x+iy) = pi - arctan[y/(-x)]   ... if x< 0,  *	3. According to the integer k=4t+0.25 truncated , t=y/x, the argument   *	   is further reduced to one of the following intervals and the   *	   arctangent of y/x is evaluated by the corresponding formula:  *  *         [0,7/16]	   atan(y/x) = t - t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)  *	   [7/16,11/16]    atan(y/x) = atan(1/2) + atan( (y-x/2)/(x+y/2) )  *	   [11/16.19/16]   atan(y/x) = atan( 1 ) + atan( (y-x)/(x+y) )  *	   [19/16,39/16]   atan(y/x) = atan(3/2) + atan( (y-1.5x)/(x+1.5y) )  *	   [39/16,INF]     atan(y/x) = atan(INF) + atan( -x/y )  *  * Special cases:  * Notations: atan2(y,x) == ARG (x+iy) == ARG(x,y).  *  *	ARG( NAN , (anything) ) is NaN;  *	ARG( (anything), NaN ) is NaN;  *	ARG(+(anything but NaN), +-0) is +-0  ;  *	ARG(-(anything but NaN), +-0) is +-PI ;  *	ARG( 0, +-(anything but 0 and NaN) ) is +-PI/2;  *	ARG( +INF,+-(anything but INF and NaN) ) is +-0 ;  *	ARG( -INF,+-(anything but INF and NaN) ) is +-PI;  *	ARG( +INF,+-INF ) is +-PI/4 ;  *	ARG( -INF,+-INF ) is +-3PI/4;  *	ARG( (anything but,0,NaN, and INF),+-INF ) is +-PI/2;  *  * Accuracy:  *	atan2(y,x) returns (PI/pi) * the exact ARG (x+iy) nearly rounded,   *	where  *  *	in decimal:  *		pi = 3.141592653589793 23846264338327 .....   *    53 bits   PI = 3.141592653589793 115997963 ..... ,  *    56 bits   PI = 3.141592653589793 227020265 ..... ,    *  *	in hexadecimal:  *		pi = 3.243F6A8885A308D313198A2E....  *    53 bits   PI = 3.243F6A8885A30  =  2 * 1.921FB54442D18	error=.276ulps  *    56 bits   PI = 3.243F6A8885A308 =  4 * .C90FDAA22168C2    error=.206ulps  *	  *	In a test run with 356,000 random argument on [-1,1] * [-1,1] on a  *	VAX, the maximum observed error was 1.41 ulps (units of the last place)  *	compared with (PI/pi)*(the exact ARG(x+iy)).  *  * Note:  *	We use machine PI (the true pi rounded) in place of the actual  *	value of pi for all the trig and inverse trig functions. In general,   *	if trig is one of sin, cos, tan, then computed trig(y) returns the   *	exact trig(y*pi/PI) nearly rounded; correspondingly, computed arctrig   *	returns the exact arctrig(y)*PI/pi nearly rounded. These guarantee the   *	trig functions have period PI, and trig(arctrig(x)) returns x for  *	all critical values x.  *	  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  */
end_comment

begin_decl_stmt
specifier|static
name|double
ifdef|#
directive|ifdef
name|VAX
comment|/* VAX D format */
name|athfhi
init|=
literal|4.6364760900080611433E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -1   *  .ED63382B0DDA7B */
name|athflo
init|=
literal|1.9338828231967579916E
operator|-
literal|19
decl_stmt|,
comment|/*Hex  2^-62   *  .E450059CFE92C0 */
name|PIo4
init|=
literal|7.8539816339744830676E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^  0   *  .C90FDAA22168C2 */
name|at1fhi
init|=
literal|9.8279372324732906796E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^  0   *  .FB985E940FB4D9 */
name|at1flo
init|=
operator|-
literal|3.5540295636764633916E
operator|-
literal|18
decl_stmt|,
comment|/*Hex  2^-57   * -.831EDC34D6EAEA */
name|PIo2
init|=
literal|1.5707963267948966135E0
decl_stmt|,
comment|/*Hex  2^  1   *  .C90FDAA22168C2 */
name|PI
init|=
literal|3.1415926535897932270E0
decl_stmt|,
comment|/*Hex  2^  2   *  .C90FDAA22168C2 */
name|a1
init|=
literal|3.3333333333333473730E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -1   *  .AAAAAAAAAAAB75 */
name|a2
init|=
operator|-
literal|2.0000000000017730678E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -2   * -.CCCCCCCCCD946E */
name|a3
init|=
literal|1.4285714286694640301E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -2   *  .92492492744262 */
name|a4
init|=
operator|-
literal|1.1111111135032672795E
operator|-
literal|1
decl_stmt|,
comment|/*Hex  2^ -3   * -.E38E38EBC66292 */
name|a5
init|=
literal|9.0909091380563043783E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -3   *  .BA2E8BB31BD70C */
name|a6
init|=
operator|-
literal|7.6922954286089459397E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -3   * -.9D89C827C37F18 */
name|a7
init|=
literal|6.6663180891693915586E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -3   *  .8886B4AE379E58 */
name|a8
init|=
operator|-
literal|5.8772703698290408927E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -4   * -.F0BBA58481A942 */
name|a9
init|=
literal|5.2170707402812969804E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -4   *  .D5B0F3A1AB13AB */
name|a10
init|=
operator|-
literal|4.4895863157820361210E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -4   * -.B7E4B97FD1048F */
name|a11
init|=
literal|3.3006147437343875094E
operator|-
literal|2
decl_stmt|,
comment|/*Hex  2^ -4   *  .8731743CF72D87 */
name|a12
init|=
operator|-
literal|1.4614844866464185439E
operator|-
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Hex  2^ -6   * -.EF731A2F3476D9 */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IEEE double */
end_comment

begin_expr_stmt
name|athfhi
operator|=
literal|4.6364760900080609352E
operator|-
literal|1
operator|,
comment|/*Hex  2^ -2   *  1.DAC670561BB4F */
name|athflo
operator|=
literal|4.6249969567426939759E
operator|-
literal|18
operator|,
comment|/*Hex  2^-58   *  1.5543B8F253271 */
name|PIo4
operator|=
literal|7.8539816339744827900E
operator|-
literal|1
operator|,
comment|/*Hex  2^ -1   *  1.921FB54442D18 */
name|at1fhi
operator|=
literal|9.8279372324732905408E
operator|-
literal|1
operator|,
comment|/*Hex  2^ -1   *  1.F730BD281F69B */
name|at1flo
operator|=
operator|-
literal|2.4407677060164810007E
operator|-
literal|17
operator|,
comment|/*Hex  2^-56   * -1.C23DFEFEAE6B5 */
name|PIo2
operator|=
literal|1.5707963267948965580E0
operator|,
comment|/*Hex  2^  0   *  1.921FB54442D18 */
name|PI
operator|=
literal|3.1415926535897931160E0
operator|,
comment|/*Hex  2^  1   *  1.921FB54442D18 */
name|a1
operator|=
literal|3.3333333333333942106E
operator|-
literal|1
operator|,
comment|/*Hex  2^ -2   *  1.55555555555C3 */
name|a2
operator|=
operator|-
literal|1.9999999999979536924E
operator|-
literal|1
operator|,
comment|/*Hex  2^ -3   * -1.9999999997CCD */
name|a3
operator|=
literal|1.4285714278004377209E
operator|-
literal|1
operator|,
comment|/*Hex  2^ -3   *  1.24924921EC1D7 */
name|a4
operator|=
operator|-
literal|1.1111110579344973814E
operator|-
literal|1
operator|,
comment|/*Hex  2^ -4   * -1.C71C7059AF280 */
name|a5
operator|=
literal|9.0908906105474668324E
operator|-
literal|2
operator|,
comment|/*Hex  2^ -4   *  1.745CE5AA35DB2 */
name|a6
operator|=
operator|-
literal|7.6919217767468239799E
operator|-
literal|2
operator|,
comment|/*Hex  2^ -4   * -1.3B0FA54BEC400 */
name|a7
operator|=
literal|6.6614695906082474486E
operator|-
literal|2
operator|,
comment|/*Hex  2^ -4   *  1.10DA924597FFF */
name|a8
operator|=
operator|-
literal|5.8358371008508623523E
operator|-
literal|2
operator|,
comment|/*Hex  2^ -5   * -1.DE125FDDBD793 */
name|a9
operator|=
literal|4.9850617156082015213E
operator|-
literal|2
operator|,
comment|/*Hex  2^ -5   *  1.9860524BDD807 */
name|a10
operator|=
operator|-
literal|3.6700606902093604877E
operator|-
literal|2
operator|,
comment|/*Hex  2^ -5   * -1.2CA6C04C6937A */
name|a11
operator|=
literal|1.6438029044759730479E
operator|-
literal|2
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*Hex  2^ -6   *  1.0D52174A1BB54 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
name|atan2
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
name|double
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
specifier|static
name|double
name|zero
init|=
literal|0
decl_stmt|,
name|one
init|=
literal|1
decl_stmt|,
name|small
init|=
literal|1.0E
operator|-
literal|9
decl_stmt|,
name|big
init|=
literal|1.0E18
decl_stmt|;
name|double
name|copysign
argument_list|()
decl_stmt|,
name|logb
argument_list|()
decl_stmt|,
name|scalb
argument_list|()
decl_stmt|,
name|t
decl_stmt|,
name|z
decl_stmt|,
name|signy
decl_stmt|,
name|signx
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|int
name|finite
argument_list|()
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|;
comment|/* if x or y is NAN */
if|if
condition|(
name|x
operator|!=
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|y
operator|!=
name|y
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* copy down the sign of y and x */
name|signy
operator|=
name|copysign
argument_list|(
name|one
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|signx
operator|=
name|copysign
argument_list|(
name|one
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* if x is 1.0, goto begin */
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|y
operator|=
name|copysign
argument_list|(
name|y
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|t
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|finite
argument_list|(
name|t
argument_list|)
condition|)
goto|goto
name|begin
goto|;
block|}
comment|/* when y = 0 */
if|if
condition|(
name|y
operator|==
name|zero
condition|)
return|return
operator|(
operator|(
name|signx
operator|==
name|one
operator|)
condition|?
name|y
else|:
name|copysign
argument_list|(
name|PI
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* when x = 0 */
if|if
condition|(
name|x
operator|==
name|zero
condition|)
return|return
operator|(
name|copysign
argument_list|(
name|PIo2
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* when x is INF */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
operator|!
name|finite
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|==
name|one
operator|)
condition|?
name|PIo4
else|:
literal|3
operator|*
name|PIo4
argument_list|,
name|signy
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|==
name|one
operator|)
condition|?
name|zero
else|:
name|PI
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* when y is INF */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|copysign
argument_list|(
name|PIo2
argument_list|,
name|signy
argument_list|)
operator|)
return|;
comment|/* compute y/x */
name|x
operator|=
name|copysign
argument_list|(
name|x
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|y
operator|=
name|copysign
argument_list|(
name|y
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|k
operator|=
name|logb
argument_list|(
name|y
argument_list|)
operator|)
operator|-
name|logb
argument_list|(
name|x
argument_list|)
operator|)
operator|>
literal|60
condition|)
name|t
operator|=
name|big
operator|+
name|big
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|<
operator|-
literal|80
condition|)
name|t
operator|=
name|y
operator|/
name|x
expr_stmt|;
else|else
block|{
name|t
operator|=
name|y
operator|/
name|x
expr_stmt|;
name|y
operator|=
name|scalb
argument_list|(
name|y
argument_list|,
operator|-
name|k
argument_list|)
expr_stmt|;
name|x
operator|=
name|scalb
argument_list|(
name|x
argument_list|,
operator|-
name|k
argument_list|)
expr_stmt|;
block|}
comment|/* begin argument reduction */
name|begin
label|:
if|if
condition|(
name|t
operator|<
literal|2.4375
condition|)
block|{
comment|/* truncate 4(t+1/16) to integer for branching */
name|k
operator|=
literal|4
operator|*
operator|(
name|t
operator|+
literal|0.0625
operator|)
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
comment|/* t is in [0,7/16] */
case|case
literal|0
case|:
case|case
literal|1
case|:
if|if
condition|(
name|t
operator|<
name|small
condition|)
block|{
name|big
operator|+
name|small
expr_stmt|;
comment|/* raise inexact flag */
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|>
name|zero
operator|)
condition|?
name|t
else|:
name|PI
operator|-
name|t
argument_list|,
name|signy
argument_list|)
operator|)
return|;
block|}
name|hi
operator|=
name|zero
expr_stmt|;
name|lo
operator|=
name|zero
expr_stmt|;
break|break;
comment|/* t is in [7/16,11/16] */
case|case
literal|2
case|:
name|hi
operator|=
name|athfhi
expr_stmt|;
name|lo
operator|=
name|athflo
expr_stmt|;
name|z
operator|=
name|x
operator|+
name|x
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|y
operator|+
name|y
operator|)
operator|-
name|x
operator|)
operator|/
operator|(
name|z
operator|+
name|y
operator|)
expr_stmt|;
break|break;
comment|/* t is in [11/16,19/16] */
case|case
literal|3
case|:
case|case
literal|4
case|:
name|hi
operator|=
name|PIo4
expr_stmt|;
name|lo
operator|=
name|zero
expr_stmt|;
name|t
operator|=
operator|(
name|y
operator|-
name|x
operator|)
operator|/
operator|(
name|x
operator|+
name|y
operator|)
expr_stmt|;
break|break;
comment|/* t is in [19/16,39/16] */
default|default:
name|hi
operator|=
name|at1fhi
expr_stmt|;
name|lo
operator|=
name|at1flo
expr_stmt|;
name|z
operator|=
name|y
operator|-
name|x
expr_stmt|;
name|y
operator|=
name|y
operator|+
name|y
operator|+
name|y
expr_stmt|;
name|t
operator|=
name|x
operator|+
name|x
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|z
operator|+
name|z
operator|)
operator|-
name|x
operator|)
operator|/
operator|(
name|t
operator|+
name|y
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* end of if (t< 2.4375) */
else|else
block|{
name|hi
operator|=
name|PIo2
expr_stmt|;
name|lo
operator|=
name|zero
expr_stmt|;
comment|/* t is in [2.4375, big] */
if|if
condition|(
name|t
operator|<=
name|big
condition|)
name|t
operator|=
operator|-
name|x
operator|/
name|y
expr_stmt|;
comment|/* t is in [big, INF] */
else|else
block|{
name|big
operator|+
name|small
expr_stmt|;
comment|/* raise inexact flag */
name|t
operator|=
name|zero
expr_stmt|;
block|}
block|}
comment|/* end of argument reduction */
comment|/* compute atan(t) for t in [-.4375, .4375] */
name|z
operator|=
name|t
operator|*
name|t
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
name|z
operator|=
name|t
operator|*
operator|(
name|z
operator|*
operator|(
name|a1
operator|+
name|z
operator|*
operator|(
name|a2
operator|+
name|z
operator|*
operator|(
name|a3
operator|+
name|z
operator|*
operator|(
name|a4
operator|+
name|z
operator|*
operator|(
name|a5
operator|+
name|z
operator|*
operator|(
name|a6
operator|+
name|z
operator|*
operator|(
name|a7
operator|+
name|z
operator|*
operator|(
name|a8
operator|+
name|z
operator|*
operator|(
name|a9
operator|+
name|z
operator|*
operator|(
name|a10
operator|+
name|z
operator|*
operator|(
name|a11
operator|+
name|z
operator|*
name|a12
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* IEEE double */
name|z
operator|=
name|t
operator|*
operator|(
name|z
operator|*
operator|(
name|a1
operator|+
name|z
operator|*
operator|(
name|a2
operator|+
name|z
operator|*
operator|(
name|a3
operator|+
name|z
operator|*
operator|(
name|a4
operator|+
name|z
operator|*
operator|(
name|a5
operator|+
name|z
operator|*
operator|(
name|a6
operator|+
name|z
operator|*
operator|(
name|a7
operator|+
name|z
operator|*
operator|(
name|a8
operator|+
name|z
operator|*
operator|(
name|a9
operator|+
name|z
operator|*
operator|(
name|a10
operator|+
name|z
operator|*
name|a11
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|z
operator|=
name|lo
operator|-
name|z
expr_stmt|;
name|z
operator|+=
name|t
expr_stmt|;
name|z
operator|+=
name|hi
expr_stmt|;
return|return
operator|(
name|copysign
argument_list|(
operator|(
name|signx
operator|>
name|zero
operator|)
condition|?
name|z
else|:
name|PI
operator|-
name|z
argument_list|,
name|signy
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

