begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mail.c	4.25 (Berkeley) 5/1/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_define
define|#
directive|define
name|SENDMAIL
value|"/usr/lib/sendmail"
end_define

begin_comment
comment|/* copylet flags */
end_comment

begin_define
define|#
directive|define
name|REMOTE
value|1
end_define

begin_comment
comment|/* remote mail, add rmtmsg */
end_comment

begin_define
define|#
directive|define
name|ORDINARY
value|2
end_define

begin_define
define|#
directive|define
name|ZAP
value|3
end_define

begin_comment
comment|/* zap header and trailing empty line */
end_comment

begin_define
define|#
directive|define
name|FORWARD
value|4
end_define

begin_define
define|#
directive|define
name|LSIZE
value|256
end_define

begin_define
define|#
directive|define
name|MAXLET
value|300
end_define

begin_comment
comment|/* maximum number of letters */
end_comment

begin_define
define|#
directive|define
name|MAILMODE
value|0600
end_define

begin_comment
comment|/* mode of created mail */
end_comment

begin_decl_stmt
name|char
name|line
index|[
name|LSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|resp
index|[
name|LSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|let
block|{
name|long
name|adr
decl_stmt|;
name|char
name|change
decl_stmt|;
block|}
name|let
index|[
name|MAXLET
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|nlet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|iop
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|lettmp
index|[]
init|=
literal|"/tmp/maXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|maildir
index|[]
init|=
literal|"/usr/spool/mail/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mailfile
index|[]
init|=
literal|"/usr/spool/mail/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dead
index|[]
init|=
literal|"dead.letter"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|forwmsg
index|[]
init|=
literal|" forwarded\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|tmpf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|malf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|my_name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forward
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|from
index|[]
init|=
literal|"From "
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|delex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|flgf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flgp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hseqno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rmail
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|my_name
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|my_name
operator|==
name|NULL
operator|||
operator|*
name|my_name
operator|==
literal|'\0'
condition|)
block|{
name|pwent
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
operator|==
name|NULL
condition|)
name|my_name
operator|=
literal|"???"
expr_stmt|;
else|else
name|my_name
operator|=
name|pwent
operator|->
name|pw_name
expr_stmt|;
block|}
else|else
block|{
name|pwent
operator|=
name|getpwnam
argument_list|(
name|my_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|!=
name|pwent
operator|->
name|pw_uid
condition|)
block|{
name|pwent
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|my_name
operator|=
name|pwent
operator|->
name|pw_name
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
name|done
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIGHUP
init|;
name|i
operator|<=
name|SIGTERM
condition|;
name|i
operator|++
control|)
name|setsig
argument_list|(
name|i
argument_list|,
name|delex
argument_list|)
expr_stmt|;
name|i
operator|=
name|mkstemp
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|fdopen
argument_list|(
name|i
argument_list|,
literal|"r+w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|tmpf
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"mail: %s: cannot open for writing"
argument_list|,
name|lettmp
argument_list|)
expr_stmt|;
comment|/* 	 * This protects against others reading mail from temp file and 	 * if we exit, the file will be deleted already. 	 */
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
name|rmail
operator|++
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
comment|/* no favors for rmail*/
operator|(
name|argc
operator|==
literal|1
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|any
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
literal|"rhd"
argument_list|)
operator|)
condition|)
name|printmail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|bulkmail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|setsig
argument_list|(
argument|i
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|any
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|str
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|str
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|printmail
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flg
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|print
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|getarg
argument_list|()
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|mailfile
argument_list|,
name|maildir
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|stat
argument_list|(
name|mailfile
argument_list|,
operator|&
name|statb
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|strcat
argument_list|(
name|mailfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mailfile
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|argc
operator|>
literal|1
condition|;
name|argv
operator|++
operator|,
name|argc
operator|--
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'p'
case|:
name|flgp
operator|++
expr_stmt|;
comment|/* fall thru... */
case|case
literal|'q'
case|:
name|delflg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|argc
operator|>=
literal|3
condition|)
block|{
name|strcpy
argument_list|(
name|mailfile
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
name|forward
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown option %c"
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|malf
operator|=
name|fopen
argument_list|(
name|mailfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No mail.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|flock
argument_list|(
name|fileno
argument_list|(
name|malf
argument_list|)
argument_list|,
name|LOCK_SH
argument_list|)
expr_stmt|;
name|copymt
argument_list|(
name|malf
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
comment|/* implicit unlock */
name|fseek
argument_list|(
name|tmpf
argument_list|,
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|print
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlet
condition|;
control|)
block|{
name|j
operator|=
name|forward
condition|?
name|i
else|:
name|nlet
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
block|{
name|print
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|print
condition|)
name|copylet
argument_list|(
name|j
argument_list|,
name|stdout
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|print
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flgp
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"? "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|resp
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|resp
index|[
literal|0
index|]
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"usage\n"
argument_list|)
expr_stmt|;
case|case
literal|'?'
case|:
name|print
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"q\tquit\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x\texit without changing mail\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"p\tprint\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"s[file]\tsave (default mbox)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"w[file]\tsame without header\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-\tprint previous\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"d\tdelete\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"+\tnext (no delete)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"m user\tmail to user\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"! cmd\texecute cmd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'n'
case|:
case|case
literal|'\n'
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|changed
operator|=
literal|0
expr_stmt|;
case|case
literal|'q'
case|:
goto|goto
name|donep
goto|;
case|case
literal|'p'
case|:
break|break;
case|case
literal|'^'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
case|case
literal|'s'
case|:
name|flg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|!=
literal|'\n'
operator|&&
name|resp
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"illegal\n"
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|resp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
name|cat
argument_list|(
name|resp
operator|+
literal|1
argument_list|,
name|p
argument_list|,
literal|"/mbox"
argument_list|)
expr_stmt|;
else|else
name|cat
argument_list|(
name|resp
operator|+
literal|1
argument_list|,
literal|""
argument_list|,
literal|"mbox"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|resp
operator|+
literal|1
init|;
operator|(
name|p
operator|=
name|getarg
argument_list|(
name|lfil
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|malf
operator|=
name|fopen
argument_list|(
name|lfil
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mail: %s: cannot append\n"
argument_list|,
name|lfil
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
continue|continue;
block|}
name|copylet
argument_list|(
name|j
argument_list|,
name|malf
argument_list|,
name|resp
index|[
literal|0
index|]
operator|==
literal|'w'
condition|?
name|ZAP
else|:
name|ORDINARY
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flg
condition|)
name|print
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
name|flg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|resp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"invalid command\n"
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|p
operator|=
name|resp
operator|+
literal|1
init|;
operator|(
name|p
operator|=
name|getarg
argument_list|(
name|lfil
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|!
name|sendmail
argument_list|(
name|j
argument_list|,
name|lfil
argument_list|,
name|my_name
argument_list|)
condition|)
name|flg
operator|++
expr_stmt|;
if|if
condition|(
name|flg
condition|)
name|print
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
name|system
argument_list|(
name|resp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"!\n"
argument_list|)
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'q'
condition|)
goto|goto
name|donep
goto|;
break|break;
block|}
block|}
name|donep
label|:
if|if
condition|(
name|changed
condition|)
name|copyback
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* copy temp or whatever back to /usr/spool/mail */
end_comment

begin_macro
name|copyback
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|c
expr_stmt|;
name|int
name|fd
decl_stmt|,
name|new
init|=
literal|0
decl_stmt|,
name|oldmask
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
define|#
directive|define
name|mask
parameter_list|(
name|s
parameter_list|)
value|(1<< ((s) - 1))
name|oldmask
operator|=
name|sigblock
argument_list|(
name|mask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|mask
argument_list|(
name|SIGHUP
argument_list|)
operator||
name|mask
argument_list|(
name|SIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|mask
name|fd
operator|=
name|open
argument_list|(
name|mailfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|MAILMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
name|malf
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|malf
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"can't rewrite %s"
argument_list|,
name|lfil
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_size
operator|!=
name|let
index|[
name|nlet
index|]
operator|.
name|adr
condition|)
block|{
comment|/* new mail has arrived */
name|fseek
argument_list|(
name|malf
argument_list|,
name|let
index|[
name|nlet
index|]
operator|.
name|adr
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|tmpf
argument_list|,
name|let
index|[
name|nlet
index|]
operator|.
name|adr
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|malf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|let
index|[
operator|++
name|nlet
index|]
operator|.
name|adr
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
name|fseek
argument_list|(
name|malf
argument_list|,
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
block|}
name|ftruncate
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlet
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|let
index|[
name|i
index|]
operator|.
name|change
operator|!=
literal|'d'
condition|)
name|copylet
argument_list|(
name|i
argument_list|,
name|malf
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
comment|/* implict unlock */
if|if
condition|(
name|new
condition|)
name|printf
argument_list|(
literal|"New mail has arrived.\n"
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* copy mail (f1) to temp (f2) */
end_comment

begin_macro
name|copymt
argument_list|(
argument|f1
argument_list|,
argument|f2
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|nextadr
decl_stmt|;
name|nlet
operator|=
name|nextadr
operator|=
literal|0
expr_stmt|;
name|let
index|[
literal|0
index|]
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|f1
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isfrom
argument_list|(
name|line
argument_list|)
condition|)
name|let
index|[
name|nlet
operator|++
index|]
operator|.
name|adr
operator|=
name|nextadr
expr_stmt|;
name|nextadr
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|f2
argument_list|)
expr_stmt|;
block|}
name|let
index|[
name|nlet
index|]
operator|.
name|adr
operator|=
name|nextadr
expr_stmt|;
comment|/* last plus 1 */
block|}
end_block

begin_macro
name|copylet
argument_list|(
argument|n
argument_list|,
argument|f
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ch
decl_stmt|;
name|long
name|k
decl_stmt|;
name|char
name|hostname
index|[
literal|32
index|]
decl_stmt|;
name|fseek
argument_list|(
name|tmpf
argument_list|,
name|let
index|[
name|n
index|]
operator|.
name|adr
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|k
operator|=
name|let
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|adr
operator|-
name|let
index|[
name|n
index|]
operator|.
name|adr
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
operator|&&
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|tmpf
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|type
operator|!=
name|ZAP
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|REMOTE
case|:
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" remote from %s\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORWARD
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|forwmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDINARY
case|:
name|putc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZAP
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"Bad letter type %d to copylet."
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|k
operator|--
operator|>
literal|1
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|ZAP
operator|||
name|ch
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
name|getc
argument_list|(
name|tmpf
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|isfrom
argument_list|(
name|lp
argument_list|)
specifier|register
name|char
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|from
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|lp
operator|++
operator|!=
operator|*
name|p
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|bulkmail
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|truename
index|[
literal|100
index|]
decl_stmt|;
name|int
name|first
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|gaver
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|newargv
index|[
literal|1000
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|int
name|dflag
decl_stmt|;
name|dflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"puke\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|vp
operator|=
name|argv
operator|,
name|ap
operator|=
name|newargv
operator|+
literal|1
init|;
operator|(
operator|*
name|ap
operator|=
operator|*
name|vp
operator|++
operator|)
operator|!=
literal|0
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|ap
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ap
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
name|dflag
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
condition|)
block|{
comment|/* give it to sendmail, rah rah! */
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|ap
operator|=
name|newargv
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rmail
condition|)
operator|*
name|ap
operator|--
operator|=
literal|"-s"
expr_stmt|;
operator|*
name|ap
operator|=
literal|"-sendmail"
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|SENDMAIL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|SENDMAIL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
name|truename
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * When we fall out of this, argv[1] should be first name, 	 * argc should be number of names + 1. 	 */
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|argc
operator|--
expr_stmt|;
switch|switch
condition|(
name|cp
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|gaver
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|truename
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmpn
argument_list|(
literal|"From"
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|hseqno
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|gaver
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|truename
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmpf
argument_list|,
literal|"%s%s %s"
argument_list|,
name|from
argument_list|,
name|truename
argument_list|,
name|ctime
argument_list|(
operator|&
name|iop
argument_list|)
argument_list|)
expr_stmt|;
name|iop
operator|=
name|ftell
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|flgf
operator|=
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
operator|&&
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
operator|&&
name|line
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isfrom
argument_list|(
name|line
argument_list|)
condition|)
name|putc
argument_list|(
literal|'>'
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|flgf
operator|=
literal|0
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|nlet
operator|=
literal|1
expr_stmt|;
name|let
index|[
literal|0
index|]
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
name|let
index|[
literal|1
index|]
operator|.
name|adr
operator|=
name|ftell
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flgf
condition|)
return|return;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|sendmail
argument_list|(
literal|0
argument_list|,
operator|*
operator|++
name|argv
argument_list|,
name|truename
argument_list|)
condition|)
name|error
operator|++
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|safefile
argument_list|(
name|dead
argument_list|)
condition|)
block|{
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|malf
operator|=
name|fopen
argument_list|(
name|dead
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mail: cannot open %s\n"
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
return|return;
block|}
name|copylet
argument_list|(
literal|0
argument_list|,
name|malf
argument_list|,
name|ZAP
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Mail saved in %s\n"
argument_list|,
name|dead
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sendrmt
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|rmf
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|rsys
index|[
literal|64
index|]
decl_stmt|,
name|cmd
index|[
literal|64
index|]
decl_stmt|;
specifier|register
name|pid
expr_stmt|;
name|int
name|sts
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|any
argument_list|(
literal|'^'
argument_list|,
name|name
argument_list|)
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'!'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"researc"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|rsys
argument_list|,
literal|"research"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'!'
condition|)
operator|--
name|name
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|rsys
init|;
operator|*
name|name
operator|!=
literal|'!'
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|name
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* local address, no '!' */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"null name\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|skip
label|:
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: can't create proc for remote\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pid
condition|)
block|{
while|while
condition|(
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|!
name|sts
operator|)
return|;
block|}
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
literal|'!'
argument_list|,
name|name
operator|+
literal|1
argument_list|)
condition|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"uux - %s!rmail \\(%s\\)"
argument_list|,
name|rsys
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"uux - %s!rmail %s"
argument_list|,
name|rsys
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rmf
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copylet
argument_list|(
name|n
argument_list|,
name|rmf
argument_list|,
name|REMOTE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|pclose
argument_list|(
name|rmf
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: mail [ -f ] people . . .\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EX_USAGE
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_macro
name|notifybiff
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
specifier|static
name|int
name|f
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|addr
operator|.
name|sin_family
operator|==
literal|0
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|gethostbyname
argument_list|(
literal|"localhost"
argument_list|)
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
init|=
name|getservbyname
argument_list|(
literal|"biff"
argument_list|,
literal|"udp"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hp
operator|&&
name|sp
condition|)
block|{
name|addr
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|addr
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addr
operator|.
name|sin_family
condition|)
block|{
if|if
condition|(
name|f
operator|<
literal|0
condition|)
name|f
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sendto
argument_list|(
name|f
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|sendmail
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|,
argument|fromaddr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|fromaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|file
index|[
literal|256
index|]
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|struct
name|stat
name|statb
decl_stmt|;
endif|#
directive|endif
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'!'
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
literal|'!'
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|sendrmt
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mail: can't send to %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cat
argument_list|(
name|file
argument_list|,
name|maildir
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statb
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|strcat
argument_list|(
name|file
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|safefile
argument_list|(
name|file
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
name|MAILMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
name|malf
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|malf
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mail: %s: cannot append\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fchown
argument_list|(
name|fd
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s@%d\n"
argument_list|,
name|name
argument_list|,
name|ftell
argument_list|(
name|malf
argument_list|)
argument_list|)
expr_stmt|;
name|copylet
argument_list|(
name|n
argument_list|,
name|malf
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|notifybiff
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|delex
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|setsig
argument_list|(
name|i
argument_list|,
name|delex
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|delflg
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cat
argument_list|(
argument|to
argument_list|,
argument|from1
argument_list|,
argument|from2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from1
decl_stmt|,
modifier|*
name|from2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|cp
operator|=
name|to
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|from1
init|;
operator|*
name|cp
operator|=
operator|*
name|dp
operator|++
condition|;
name|cp
operator|++
control|)
empty_stmt|;
for|for
control|(
name|dp
operator|=
name|from2
init|;
operator|*
name|cp
operator|++
operator|=
operator|*
name|dp
operator|++
condition|;
control|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/* copy p... into s, update p */
end_comment

begin_function
name|char
modifier|*
name|getarg
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|safefile
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|f
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|statb
operator|.
name|st_nlink
operator|!=
literal|1
operator|||
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: %s has more than one link or is a symbolic link\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|panic
argument_list|(
argument|msg
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

