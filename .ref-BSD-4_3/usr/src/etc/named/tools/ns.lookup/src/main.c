begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *******************************************************************************  *    *   main.c --  *    *  	Main routine and some action routines for the name server  *	lookup program.  *  *	Copyright (c) 1985 Regents of the University of California.  *	All rights reserved.  The Berkeley software License Agreement  *	specifies the terms and conditions for redistribution.  *  *  	Andrew Cherenson 	CS298-26  Fall 1985  *    *******************************************************************************  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1985 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	5.7 (Berkeley) 5/6/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"res.h"
end_include

begin_comment
comment|/*  *  Location of the help file.  */
end_comment

begin_define
define|#
directive|define
name|HELPFILE
value|"/usr/local/nslookup.help"
end_define

begin_comment
comment|/*  *  Internet address of the current host.  */
end_comment

begin_define
define|#
directive|define
name|LOCALHOST
value|"127.0.0.1"
end_define

begin_comment
comment|/*  * Name of a top-level name server. Can be changed with   * the "set root" command.  */
end_comment

begin_define
define|#
directive|define
name|ROOT_SERVER
value|"sri-nic.arpa"
end_define

begin_decl_stmt
name|char
name|rootServerName
index|[
name|NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Import the state information from the resolver library.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|state
name|_res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Info about the most recently queried host.  */
end_comment

begin_decl_stmt
name|HostInfo
name|curHostInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curHostValid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Info about the default name server.  */
end_comment

begin_decl_stmt
name|HostInfo
modifier|*
name|defaultPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|defaultServer
index|[
name|NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|defaultAddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Initial name server query type is Address.  */
end_comment

begin_decl_stmt
name|int
name|queryType
init|=
name|T_A
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Stuff for Interrupt (control-C) signal handler.  *  SockFD is the file descriptor for sockets used to  *  connect with the name servers. It has to be global to  *  allow the interrupt handler can close open sockets.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|IntrHandler
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|sockFD
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|filePtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  *******************************************************************************  *  *  main --  *  *	Initializes the resolver library and determines the address  *	of the initial name server. The yylex routine is used to  *	read and perform commands.  *  *******************************************************************************  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
name|hostName
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|find
decl_stmt|;
name|int
name|useLocalServer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
comment|/*      *  Initialize the resolver library routines.      */
if|if
condition|(
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find initialize resolver.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Allocate space for the default server's host info and      *  find the server's address and name. If the resolver library      *  already has some addresses for a potential name server,      *  then use them. Otherwise, see if the current host has a server.      *  Command line arguments may override the choice of initial server.       */
name|defaultPtr
operator|=
operator|(
name|HostInfo
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HostInfo
argument_list|)
argument_list|)
expr_stmt|;
name|useLocalServer
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
name|find
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
comment|/*              *	Set explicit name server address.              *              */
name|_res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|hperror
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|_res
operator|.
name|nscount
operator|=
literal|0
expr_stmt|;
name|useLocalServer
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
operator|&
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|useLocalServer
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: nslookup findhost { servername | address }\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_res
operator|.
name|nscount
operator|>
literal|0
operator|&&
operator|!
name|useLocalServer
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|useLocalServer
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|result
operator|=
name|FindHostInfo
argument_list|(
operator|&
operator|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
operator|)
argument_list|,
operator|&
operator|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find server name for address %s: %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defaultAddr
operator|=
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 *  If we have exhausted the list, tell the user about the 	 *  command line argument to specify an address. 	 */
if|if
condition|(
name|i
operator|==
name|_res
operator|.
name|nscount
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Default servers are not available\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|useLocalServer
condition|)
block|{
name|defaultAddr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|LOCALHOST
argument_list|)
expr_stmt|;
name|gethostname
argument_list|(
name|hostName
argument_list|,
sizeof|sizeof
argument_list|(
name|hostName
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|&
name|defaultAddr
argument_list|,
name|T_A
argument_list|,
name|hostName
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find initialize address for server %s: %s\n"
argument_list|,
name|defaultServer
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|defaultServer
argument_list|,
name|defaultPtr
operator|->
name|name
argument_list|)
expr_stmt|;
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Default Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rootServerName
argument_list|,
name|ROOT_SERVER
argument_list|)
expr_stmt|;
comment|/*     _res.options |= (RES_DEBUG | RES_DEBUG2);     _res.options |= RES_DEBUG;     _res.retry    = 2; */
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEFNAMES
expr_stmt|;
if|if
condition|(
name|find
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|hperror
argument_list|(
name|h_errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printanswer
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Setup the environment to allow the interrupt handler to return here.      */
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/*       * Return here after a longjmp.      */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|IntrHandler
argument_list|)
expr_stmt|;
comment|/*      * Read and evaluate commands. Yylex returns 0 when ^D or 'exit'      * is typed.      */
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
while|while
condition|(
name|yylex
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *******************************************************************************  *  *  SetDefaultServer --  *  *	Changes the default name server to the one specified by  *	the first argument. The command "server name" uses the current   *	default server to lookup the info for "name". The command  *	"lserver name" uses the original server to lookup "name".  *  *  Side effects:  *	This routine will cause a core dump if the allocation requests fail.  *  *  Results:  *	SUCCESS 	The default server was changed successfully.  *	NONAUTH		The server was changed but addresses of  *			other servers who know about the requested server  *			were returned.  *	Errors		No info about the new server was found or  *			requests to the current server timed-out.  *  *******************************************************************************  */
end_comment

begin_function
name|int
name|SetDefaultServer
parameter_list|(
name|string
parameter_list|,
name|local
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
specifier|register
name|HostInfo
modifier|*
name|newDefPtr
decl_stmt|;
name|char
name|newServer
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      *  Parse the command line. It maybe of the form "server name",      *  "lserver name" or just "name".      */
if|if
condition|(
name|local
condition|)
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" lserver %s"
argument_list|,
name|newServer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" server %s"
argument_list|,
name|newServer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %s"
argument_list|,
name|newServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SetDefaultServer: invalid name: %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
comment|/*      * Allocate space for a HostInfo variable for the new server. Don't      * overwrite the old HostInfo struct because info about the new server      * might not be found and we need to have valid default server info.      */
name|newDefPtr
operator|=
operator|(
name|HostInfo
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HostInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      *	A 'local' lookup uses the original server that the program was      *  initialized with.      */
if|if
condition|(
name|local
condition|)
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|&
name|defaultAddr
argument_list|,
name|T_A
argument_list|,
name|newServer
argument_list|,
name|newDefPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 *  Check to see if we have the address of the server or the 	 *	address of a server who knows about this domain. 	 * 	 *  For now, just use the first address in the list. 	 */
if|if
condition|(
name|defaultPtr
operator|->
name|addrList
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|T_A
argument_list|,
name|newServer
argument_list|,
name|newDefPtr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|T_A
argument_list|,
name|newServer
argument_list|,
name|newDefPtr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|SUCCESS
operator|||
name|result
operator|==
name|NONAUTH
condition|)
block|{
comment|/* 	     *  Found info about the new server. Free the resources for 	     *  the old server. 	     */
name|FreeHostInfoPtr
argument_list|(
name|defaultPtr
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|defaultPtr
argument_list|)
expr_stmt|;
name|defaultPtr
operator|=
name|newDefPtr
expr_stmt|;
name|strcpy
argument_list|(
name|defaultServer
argument_list|,
name|defaultPtr
operator|->
name|name
argument_list|)
expr_stmt|;
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Default Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find address for server %s: %s\n"
argument_list|,
name|newServer
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newDefPtr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *******************************************************************************  *  *  LookupHost --  *  *	Asks the default name server for information about the  *	specified host or domain. The information is printed  *	if the lookup was successful.  *  *  Results:  *	SUCCESS		- the lookup was successful.  *	ERROR		- the output file could not be opened.  *	Misc. Errors	- an error message is printed if the lookup failed.  *  *******************************************************************************  */
end_comment

begin_function
name|int
name|LookupHost
parameter_list|(
name|string
parameter_list|,
name|putToFile
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|putToFile
decl_stmt|;
block|{
name|char
name|host
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|file
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/*      *  Invalidate the current host information to prevent Finger       *  from using bogus info.      */
name|curHostValid
operator|=
name|FALSE
expr_stmt|;
comment|/*      *	 Parse the command string into the host and      *	 optional output file name.      *      */
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/* removes white space */
if|if
condition|(
operator|!
name|putToFile
condition|)
block|{
name|filePtr
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|filePtr
operator|=
name|OpenFile
argument_list|(
name|string
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't open %s for writing\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|filePtr
argument_list|,
literal|"> %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
comment|/*      *  Check to see if we have the address of the server or the      *	address of a server who knows about this domain.      *      *  For now, just use the first address in the list.      */
if|if
condition|(
name|defaultPtr
operator|->
name|addrList
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|queryType
argument_list|,
name|host
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|queryType
argument_list|,
name|host
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|SUCCESS
case|:
comment|/* 	     *  If the query was for an address, then the curHostInfo 	     *  variable can be used by Finger. 	     *  There's no need to print anything for other query types 	     *  because the info has already been printed. 	     */
if|if
condition|(
name|queryType
operator|==
name|T_A
condition|)
block|{
name|curHostValid
operator|=
name|TRUE
expr_stmt|;
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Name:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * No Authoritative answer was available but we got names 	 * of servers who know about the host. 	 */
case|case
name|NONAUTH
case|:
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Name:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_INFO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** No %s information is available for %s\n"
argument_list|,
name|DecodeType
argument_list|(
name|queryType
argument_list|)
argument_list|,
name|host
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIME_OUT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Request to %s timed-out\n"
argument_list|,
name|defaultServer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** %s can't find %s: %s\n"
argument_list|,
name|defaultServer
argument_list|,
name|host
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|putToFile
condition|)
block|{
name|fclose
argument_list|(
name|filePtr
argument_list|)
expr_stmt|;
name|filePtr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *******************************************************************************  *  *  LookupHostWithServer --  *  *	Asks the name server specified in the second argument for   *	information about the host or domain specified in the first  *	argument. The information is printed if the lookup was successful.  *  *	Address info about the requested name server is obtained  *	from the default name server. This routine will return an  *	error if the default server doesn't have info about the   *	requested server. Thus an error return status might not  *	mean the requested name server doesn't have info about the  *	requested host.  *  *	Comments from LookupHost apply here, too.  *  *  Results:  *	SUCCESS		- the lookup was successful.  *	ERROR		- the output file could not be opened.  *	Misc. Errors	- an error message is printed if the lookup failed.  *  *******************************************************************************  */
end_comment

begin_function
name|int
name|LookupHostWithServer
parameter_list|(
name|string
parameter_list|,
name|putToFile
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|putToFile
decl_stmt|;
block|{
name|char
name|file
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|host
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|server
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|static
name|HostInfo
name|serverInfo
decl_stmt|;
name|curHostValid
operator|=
name|FALSE
expr_stmt|;
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %s %s"
argument_list|,
name|host
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putToFile
condition|)
block|{
name|filePtr
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|filePtr
operator|=
name|OpenFile
argument_list|(
name|string
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|filePtr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't open %s for writing\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|filePtr
argument_list|,
literal|"> %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultPtr
operator|->
name|addrList
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|T_A
argument_list|,
name|server
argument_list|,
operator|&
name|serverInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|defaultPtr
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|T_A
argument_list|,
name|server
argument_list|,
operator|&
name|serverInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Can't find address for server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Server:"
argument_list|,
operator|&
name|serverInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|serverInfo
operator|.
name|addrList
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|serverInfo
operator|.
name|servers
index|[
literal|0
index|]
operator|->
name|addrList
index|[
literal|0
index|]
argument_list|,
name|queryType
argument_list|,
name|host
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|GetHostInfo
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|serverInfo
operator|.
name|addrList
index|[
literal|0
index|]
argument_list|,
name|queryType
argument_list|,
name|host
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|SUCCESS
case|:
if|if
condition|(
name|queryType
operator|==
name|T_A
condition|)
block|{
name|curHostValid
operator|=
name|TRUE
expr_stmt|;
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Name:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NONAUTH
case|:
name|PrintHostInfo
argument_list|(
name|filePtr
argument_list|,
literal|"Name:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_INFO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** No %s information is available for %s\n"
argument_list|,
name|DecodeType
argument_list|(
name|queryType
argument_list|)
argument_list|,
name|host
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIME_OUT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Request to %s timed-out\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** %s can't find %s: %s\n"
argument_list|,
name|server
argument_list|,
name|host
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|putToFile
condition|)
block|{
name|fclose
argument_list|(
name|filePtr
argument_list|)
expr_stmt|;
name|filePtr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *******************************************************************************  *  *  SetOption --   *  *	This routine is used to change the state information  *	that affect the lookups. The command format is  *	   set keyword[=value]  *	Most keywords can be abbreviated. Parsing is very simplistic--  *	A value must not be separated from its keyword by white space.  *  *	Valid keywords:		Meaning:  *	[no]aaonly	  	authoritative query only or not (hidden).  *	all			lists current values of options.  *	ALL			lists current values of options, including  *				  hidden options.  *	[no]d2			turn on/off extra debugging mode (hidden).  *	[no]debug 		turn on/off debugging mode.  *	[no]defname	  	use/don't use default domain name.  *	domain=NAME		set default domain name to NAME.  *	[no]ignore		ignore/don't ignore trunc. errors (hidden).  *	[no]primary 		use/don't use primary server (hidden).  *	query=value		set default query type to value,  *				value is one of the query types in RFC883  *				without the leading T_.	(e.g. A, HINFO)  *	[no]recurse		use/don't use recursive lookup.  *	retry=#			set number of retries to #.  *	root=NAME		change root server to NAME.  *	time=#			set timeout length to #.  *	[no]vc			use/don't use virtual circuit.  *  *  Results:  *	SUCCESS		the command was parsed correctly.  *	ERROR		the command was not parsed correctly.  *  *******************************************************************************  */
end_comment

begin_function
name|int
name|SetOption
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|option
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|type
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" set %s"
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Invalid option: %s\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShowOptions
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ALL"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ShowOptions
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"aa"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* aaonly */
name|_res
operator|.
name|options
operator||=
name|RES_AAONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noaa"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_AAONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"deb"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* debug */
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodeb"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"d2"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* d2 (more debug) */
name|_res
operator|.
name|options
operator||=
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nod2"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"def"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* defname */
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"do"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* domain */
name|ptr
operator|=
name|index
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"i"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ignore */
name|_res
operator|.
name|options
operator||=
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noi"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"p"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* primary */
name|_res
operator|.
name|options
operator||=
name|RES_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nop"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"q"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* querytype */
name|ptr
operator|=
name|index
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|queryType
operator|=
name|StringToType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"rec"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* recurse */
name|_res
operator|.
name|options
operator||=
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"norec"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ret"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* retry */
name|ptr
operator|=
name|index
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|_res
operator|.
name|retry
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ro"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* root */
name|ptr
operator|=
name|index
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|rootServerName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"t"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* timeout */
name|ptr
operator|=
name|index
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|_res
operator|.
name|retrans
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"v"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* vc */
name|_res
operator|.
name|options
operator||=
name|RES_USEVC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nov"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_USEVC
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Invalid option: %s\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *******************************************************************************  *  *  ShowOptions --  *  *	Prints out the state information used by the resolver  *	library and other options set by the user.  *  *******************************************************************************  */
end_comment

begin_function
name|void
name|ShowOptions
parameter_list|(
name|special
parameter_list|)
name|int
name|special
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Default Server:"
argument_list|,
name|defaultPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|curHostValid
condition|)
block|{
name|PrintHostInfo
argument_list|(
name|stdout
argument_list|,
literal|"Host:"
argument_list|,
operator|&
name|curHostInfo
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Set options:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %sdebug\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %sdefname\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEFNAMES
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %srecurse\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_RECURSE
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %svc\n"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_USEVC
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|special
condition|)
block|{
name|printf
argument_list|(
literal|"  %saa\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_AAONLY
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %sd2\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG2
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %signoretc\t"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_IGNTC
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %sprimary\n"
argument_list|,
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_PRIMARY
operator|)
condition|?
literal|""
else|:
literal|"no"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  querytype=%s\t"
argument_list|,
name|p_type
argument_list|(
name|queryType
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  timeout=%d\t"
argument_list|,
name|_res
operator|.
name|retrans
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  retry=%d\n"
argument_list|,
name|_res
operator|.
name|retry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  domain=%s\n"
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  root=%s\n"
argument_list|,
name|rootServerName
argument_list|)
expr_stmt|;
if|if
condition|(
name|special
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"State info:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  current packet id:       %d\n"
argument_list|,
name|_res
operator|.
name|id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  number of name servers:  %d\n"
argument_list|,
name|_res
operator|.
name|nscount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  name server addresses:   %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr_list
index|[
literal|0
index|]
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"                           %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *******************************************************************************  *  *  PrintHelp --  *  *	Prints out the help file. *	(Code taken from Mail.)  *  *******************************************************************************  */
end_comment

begin_function
name|void
name|PrintHelp
parameter_list|()
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|filePtr
decl_stmt|;
if|if
condition|(
operator|(
name|filePtr
operator|=
name|fopen
argument_list|(
name|HELPFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|HELPFILE
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|filePtr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|filePtr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

