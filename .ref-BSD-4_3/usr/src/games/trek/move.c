begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)move.c	5.1 (Berkeley) 5/30/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"trek.h"
end_include

begin_comment
comment|/* **  Move Under Warp or Impulse Power ** **	`Ramflag' is set if we are to be allowed to ram stars, **	Klingons, etc.  This is passed from warp(), which gets it from **	either play() or ram().  Course is the course (0 -> 360) at **	which we want to move.  `Speed' is the speed we **	want to go, and `time' is the expected time.  It **	can get cut short if a long range tractor beam is to occur.  We **	cut short the move so that the user doesn't get docked time and **	energy for distance which he didn't travel. ** **	We check the course through the current quadrant to see that he **	doesn't run into anything.  After that, though, space sort of **	bends around him.  Note that this puts us in the awkward posi- **	tion of being able to be dropped into a sector which is com- **	pletely surrounded by stars.  Oh Well. ** **	If the SINS (Space Inertial Navigation System) is out, we ran- **	domize the course accordingly before ever starting to move. **	We will still move in a straight line. ** **	Note that if your computer is out, you ram things anyway.  In **	other words, if your computer and sins are both out, you're in **	potentially very bad shape. ** **	Klingons get a chance to zap you as you leave the quadrant. **	By the way, they also try to follow you (heh heh). ** **	Return value is the actual amount of time used. ** ** **	Uses trace flag 4. */
end_comment

begin_function
name|double
name|move
parameter_list|(
name|ramflag
parameter_list|,
name|course
parameter_list|,
name|time
parameter_list|,
name|speed
parameter_list|)
name|int
name|ramflag
decl_stmt|;
name|int
name|course
decl_stmt|;
name|double
name|time
decl_stmt|;
name|double
name|speed
decl_stmt|;
block|{
name|double
name|angle
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
specifier|register
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
name|double
name|bigger
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|double
name|dist
decl_stmt|;
name|double
name|sectsize
decl_stmt|;
name|double
name|xn
decl_stmt|;
name|double
name|evtime
decl_stmt|;
ifdef|#
directive|ifdef
name|xTRACE
if|if
condition|(
name|Trace
condition|)
name|printf
argument_list|(
literal|"move: ramflag %d course %d time %.2f speed %.2f\n"
argument_list|,
name|ramflag
argument_list|,
name|course
argument_list|,
name|time
argument_list|,
name|speed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sectsize
operator|=
name|NSECTS
expr_stmt|;
comment|/* initialize delta factors for move */
name|angle
operator|=
name|course
operator|*
literal|0.0174532925
expr_stmt|;
if|if
condition|(
name|damaged
argument_list|(
name|SINS
argument_list|)
condition|)
name|angle
operator|+=
name|Param
operator|.
name|navigcrud
index|[
literal|1
index|]
operator|*
operator|(
name|franf
argument_list|()
operator|-
literal|0.5
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Ship
operator|.
name|sinsbad
condition|)
name|angle
operator|+=
name|Param
operator|.
name|navigcrud
index|[
literal|0
index|]
operator|*
operator|(
name|franf
argument_list|()
operator|-
literal|0.5
operator|)
expr_stmt|;
name|dx
operator|=
operator|-
name|cos
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|dy
operator|=
name|sin
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|bigger
operator|=
name|fabs
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|dist
operator|=
name|fabs
argument_list|(
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|>
name|bigger
condition|)
name|bigger
operator|=
name|dist
expr_stmt|;
name|dx
operator|/=
name|bigger
expr_stmt|;
name|dy
operator|/=
name|bigger
expr_stmt|;
comment|/* check for long range tractor beams */
comment|/****  TEMPORARY CODE == DEBUGGING  ****/
name|evtime
operator|=
name|Now
operator|.
name|eventptr
index|[
name|E_LRTB
index|]
operator|->
name|date
operator|-
name|Now
operator|.
name|date
expr_stmt|;
ifdef|#
directive|ifdef
name|xTRACE
if|if
condition|(
name|Trace
condition|)
name|printf
argument_list|(
literal|"E.ep = %u, ->evcode = %d, ->date = %.2f, evtime = %.2f\n"
argument_list|,
name|Now
operator|.
name|eventptr
index|[
name|E_LRTB
index|]
argument_list|,
name|Now
operator|.
name|eventptr
index|[
name|E_LRTB
index|]
operator|->
name|evcode
argument_list|,
name|Now
operator|.
name|eventptr
index|[
name|E_LRTB
index|]
operator|->
name|date
argument_list|,
name|evtime
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|time
operator|>
name|evtime
operator|&&
name|Etc
operator|.
name|nkling
operator|<
literal|3
condition|)
block|{
comment|/* then we got a LRTB */
name|evtime
operator|+=
literal|0.005
expr_stmt|;
name|time
operator|=
name|evtime
expr_stmt|;
block|}
else|else
name|evtime
operator|=
operator|-
literal|1.0e50
expr_stmt|;
name|dist
operator|=
name|time
operator|*
name|speed
expr_stmt|;
comment|/* move within quadrant */
name|Sect
index|[
name|Ship
operator|.
name|sectx
index|]
index|[
name|Ship
operator|.
name|secty
index|]
operator|=
name|EMPTY
expr_stmt|;
name|x
operator|=
name|Ship
operator|.
name|sectx
operator|+
literal|0.5
expr_stmt|;
name|y
operator|=
name|Ship
operator|.
name|secty
operator|+
literal|0.5
expr_stmt|;
name|xn
operator|=
name|NSECTS
operator|*
name|dist
operator|*
name|bigger
expr_stmt|;
name|n
operator|=
name|xn
operator|+
literal|0.5
expr_stmt|;
ifdef|#
directive|ifdef
name|xTRACE
if|if
condition|(
name|Trace
condition|)
name|printf
argument_list|(
literal|"dx = %.2f, dy = %.2f, xn = %.2f, n = %d\n"
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|xn
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Move
operator|.
name|free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ix
operator|=
operator|(
name|x
operator|+=
name|dx
operator|)
expr_stmt|;
name|iy
operator|=
operator|(
name|y
operator|+=
name|dy
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xTRACE
if|if
condition|(
name|Trace
condition|)
name|printf
argument_list|(
literal|"ix = %d, x = %.2f, iy = %d, y = %.2f\n"
argument_list|,
name|ix
argument_list|,
name|x
argument_list|,
name|iy
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|<
literal|0.0
operator|||
name|y
operator|<
literal|0.0
operator|||
name|x
operator|>=
name|sectsize
operator|||
name|y
operator|>=
name|sectsize
condition|)
block|{
comment|/* enter new quadrant */
name|dx
operator|=
name|Ship
operator|.
name|quadx
operator|*
name|NSECTS
operator|+
name|Ship
operator|.
name|sectx
operator|+
name|dx
operator|*
name|xn
expr_stmt|;
name|dy
operator|=
name|Ship
operator|.
name|quady
operator|*
name|NSECTS
operator|+
name|Ship
operator|.
name|secty
operator|+
name|dy
operator|*
name|xn
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0.0
condition|)
name|ix
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|ix
operator|=
name|dx
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|dy
operator|<
literal|0.0
condition|)
name|iy
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|iy
operator|=
name|dy
operator|+
literal|0.5
expr_stmt|;
ifdef|#
directive|ifdef
name|xTRACE
if|if
condition|(
name|Trace
condition|)
name|printf
argument_list|(
literal|"New quad: ix = %d, iy = %d\n"
argument_list|,
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Ship
operator|.
name|sectx
operator|=
name|x
expr_stmt|;
name|Ship
operator|.
name|secty
operator|=
name|y
expr_stmt|;
name|compkldist
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Move
operator|.
name|newquad
operator|=
literal|2
expr_stmt|;
name|attack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checkcond
argument_list|()
expr_stmt|;
name|Ship
operator|.
name|quadx
operator|=
name|ix
operator|/
name|NSECTS
expr_stmt|;
name|Ship
operator|.
name|quady
operator|=
name|iy
operator|/
name|NSECTS
expr_stmt|;
name|Ship
operator|.
name|sectx
operator|=
name|ix
operator|%
name|NSECTS
expr_stmt|;
name|Ship
operator|.
name|secty
operator|=
name|iy
operator|%
name|NSECTS
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
operator|||
name|Ship
operator|.
name|quadx
operator|>=
name|NQUADS
operator|||
name|iy
operator|<
literal|0
operator|||
name|Ship
operator|.
name|quady
operator|>=
name|NQUADS
condition|)
if|if
condition|(
operator|!
name|damaged
argument_list|(
name|COMPUTER
argument_list|)
condition|)
block|{
name|dumpme
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|lose
argument_list|(
name|L_NEGENB
argument_list|)
expr_stmt|;
name|initquad
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Sect
index|[
name|ix
index|]
index|[
name|iy
index|]
operator|!=
name|EMPTY
condition|)
block|{
comment|/* we just hit something */
if|if
condition|(
operator|!
name|damaged
argument_list|(
name|COMPUTER
argument_list|)
operator|&&
name|ramflag
operator|<=
literal|0
condition|)
block|{
name|ix
operator|=
name|x
operator|-
name|dx
expr_stmt|;
name|iy
operator|=
name|y
operator|-
name|dy
expr_stmt|;
name|printf
argument_list|(
literal|"Computer reports navigation error; %s stopped at %d,%d\n"
argument_list|,
name|Ship
operator|.
name|shipname
argument_list|,
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
name|Ship
operator|.
name|energy
operator|-=
name|Param
operator|.
name|stopengy
operator|*
name|speed
expr_stmt|;
break|break;
block|}
comment|/* test for a black hole */
if|if
condition|(
name|Sect
index|[
name|ix
index|]
index|[
name|iy
index|]
operator|==
name|HOLE
condition|)
block|{
comment|/* get dumped elsewhere in the galaxy */
name|dumpme
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|initquad
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ram
argument_list|(
name|ix
argument_list|,
name|iy
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|dx
operator|=
name|Ship
operator|.
name|sectx
operator|-
name|ix
expr_stmt|;
name|dy
operator|=
name|Ship
operator|.
name|secty
operator|-
name|iy
expr_stmt|;
name|dist
operator|=
name|sqrt
argument_list|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
argument_list|)
operator|/
name|NSECTS
expr_stmt|;
name|time
operator|=
name|dist
operator|/
name|speed
expr_stmt|;
if|if
condition|(
name|evtime
operator|>
name|time
condition|)
name|time
operator|=
name|evtime
expr_stmt|;
comment|/* spring the LRTB trap */
name|Ship
operator|.
name|sectx
operator|=
name|ix
expr_stmt|;
name|Ship
operator|.
name|secty
operator|=
name|iy
expr_stmt|;
block|}
name|Sect
index|[
name|Ship
operator|.
name|sectx
index|]
index|[
name|Ship
operator|.
name|secty
index|]
operator|=
name|Ship
operator|.
name|ship
expr_stmt|;
name|compkldist
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|time
operator|)
return|;
block|}
end_function

end_unit

