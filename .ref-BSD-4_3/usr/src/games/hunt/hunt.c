begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  *  *  Copyright (c) 1985 Regents of the University of California.  *  All rights reserved.  The Berkeley software License Agreement  *  specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
name|FLAG
name|Last_player
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MONITOR
end_ifdef

begin_decl_stmt
name|FLAG
name|Am_monitor
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|MONITOR
end_endif

begin_decl_stmt
name|FLAG
name|Query_driver
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Master_pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Socket
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|Sock_host
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_decl_stmt
name|SOCKET
name|Daemon
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_define
define|#
directive|define
name|DAEMON_SIZE
value|(sizeof Daemon)
end_define

begin_else
else|#
directive|else
else|INTERNET
end_else

begin_define
define|#
directive|define
name|DAEMON_SIZE
value|(sizeof Daemon - 1)
end_define

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_decl_stmt
name|char
name|map_key
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what to map keys to */
end_comment

begin_decl_stmt
specifier|static
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cur_row
decl_stmt|,
name|cur_col
decl_stmt|,
name|_putchar
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * main:  *	Main program for local process  */
end_comment

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|char
modifier|*
name|term
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|int
name|Otto_mode
decl_stmt|;
name|int
name|dumpit
argument_list|()
decl_stmt|,
name|intr
argument_list|()
decl_stmt|,
name|sigterm
argument_list|()
decl_stmt|,
name|sigemt
argument_list|()
decl_stmt|,
name|tstp
argument_list|()
decl_stmt|;
for|for
control|(
name|ac
operator|--
operator|,
name|av
operator|++
init|;
name|ac
operator|>
literal|0
operator|&&
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|ac
operator|--
operator|,
name|av
operator|++
control|)
block|{
switch|switch
condition|(
name|av
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* rsh compatibility */
case|case
literal|'n'
case|:
if|if
condition|(
name|ac
operator|<=
literal|1
condition|)
goto|goto
name|usage
goto|;
name|ac
operator|--
operator|,
name|av
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
ifndef|#
directive|ifndef
name|OTTO
name|fputs
argument_list|(
literal|"The -o flag is reserved for future use.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
else|#
directive|else
else|OTTO
name|Otto_mode
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
endif|OTTO
ifdef|#
directive|ifdef
name|MONITOR
case|case
literal|'m'
case|:
name|Am_monitor
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
endif|MONITOR
ifdef|#
directive|ifdef
name|INTERNET
case|case
literal|'q'
case|:
comment|/* query whether hunt is running */
name|Query_driver
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|ac
operator|<=
literal|1
condition|)
goto|goto
name|usage
goto|;
name|ac
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|Sock_host
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
endif|INTERNET
default|default:
name|usage
label|:
ifdef|#
directive|ifdef
name|INTERNET
ifdef|#
directive|ifdef
name|MONITOR
define|#
directive|define
name|USAGE
value|"usage: hunt [-q] [-n name] [-h host] [-m]\n"
else|#
directive|else
else|MONITOR
define|#
directive|define
name|USAGE
value|"usage: hunt [-q] [-n name] [-h host]\n"
endif|#
directive|endif
endif|MONITOR
else|#
directive|else
else|INTERNET
ifdef|#
directive|ifdef
name|MONITOR
define|#
directive|define
name|USAGE
value|"usage: hunt [-n name] [-m]\n"
else|#
directive|else
else|MONITOR
define|#
directive|define
name|USAGE
value|"usage: hunt [-n name]\n"
endif|#
directive|endif
endif|MONITOR
endif|#
directive|endif
endif|INTERNET
name|fputs
argument_list|(
name|USAGE
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|USAGE
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
goto|goto
name|usage
goto|;
elseif|else
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
name|Sock_host
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
else|INTERNET
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
goto|goto
name|usage
goto|;
endif|#
directive|endif
endif|INTERNET
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|Query_driver
condition|)
block|{
name|find_driver
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Daemon
operator|.
name|sin_port
operator|!=
literal|0
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|&
name|Daemon
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
name|Daemon
operator|.
name|sin_addr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HUNT!! found on %s\n"
argument_list|,
name|hp
operator|!=
name|NULL
condition|?
name|hp
operator|->
name|h_name
else|:
name|inet_ntoa
argument_list|(
name|Daemon
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|Daemon
operator|.
name|sin_port
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|INTERNET
ifdef|#
directive|ifdef
name|OTTO
if|if
condition|(
name|Otto_mode
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"otto"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|OTTO
name|env_init
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
operator|||
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no terminal type\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|_tty_ch
operator|=
literal|0
expr_stmt|;
name|gettmode
argument_list|()
expr_stmt|;
name|setterm
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|_puts
argument_list|(
name|TI
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|VS
argument_list|)
expr_stmt|;
name|clear_screen
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|sigemt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|dumpit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstp
argument_list|)
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|INTERNET
name|find_driver
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|msg
decl_stmt|;
ifndef|#
directive|ifndef
name|OLDIPC
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
else|OLDIPC
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OLDIPC
if|if
condition|(
name|Socket
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OLDIPC
name|msg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|Socket
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_USELOOPBACK
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"setsockopt loopback"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OLDIPC
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|Socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECONNREFUSED
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"connect"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|close
argument_list|(
name|Socket
argument_list|)
operator|==
literal|0
condition|)
do|;
else|#
directive|else
else|INTERNET
comment|/* 		 * set up a socket 		 */
if|if
condition|(
operator|(
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * attempt to connect the socket to a name; if it fails that 		 * usually means that the driver isn't running, so we start 		 * up the driver. 		 */
name|Daemon
operator|.
name|sun_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Daemon
operator|.
name|sun_path
argument_list|,
name|Sock_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|Socket
argument_list|,
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"connect2"
argument_list|)
expr_stmt|;
block|}
name|start_driver
argument_list|()
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|Socket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|connect
argument_list|(
name|Socket
argument_list|,
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
do|;
block|}
endif|#
directive|endif
endif|INTERNET
name|do_connect
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|playit
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|quit
argument_list|()
condition|)
do|;
name|leave
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BROADCAST
end_ifdef

begin_macro
name|broadcast_vec
argument_list|(
argument|s
argument_list|,
argument|vector
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
modifier|*
name|vector
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|if_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|vec_cnt
decl_stmt|;
operator|*
name|vector
operator|=
name|NULL
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|if_buf
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|if_buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|vec_cnt
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
operator|*
name|vector
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|ifr
operator|++
control|)
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFBRDADDR
argument_list|,
name|ifr
argument_list|)
operator|>=
literal|0
condition|)
name|bcopy
argument_list|(
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|,
operator|&
operator|(
operator|*
name|vector
operator|)
index|[
name|vec_cnt
operator|++
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|vec_cnt
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|BROADCAST
end_endif

begin_macro
name|find_driver
argument_list|(
argument|do_startup
argument_list|)
end_macro

begin_decl_stmt
name|FLAG
name|do_startup
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|msg
decl_stmt|;
specifier|static
name|SOCKET
name|test
decl_stmt|;
name|int
name|test_socket
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|char
name|local_name
index|[
literal|80
index|]
decl_stmt|;
specifier|static
name|initial
operator|=
name|TRUE
expr_stmt|;
specifier|static
name|struct
name|in_addr
name|local_address
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
argument_list|(
operator|*
name|oldsigalrm
argument_list|)
argument_list|()
decl_stmt|,
name|sigalrm
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|BROADCAST
specifier|static
name|int
name|brdc
decl_stmt|;
specifier|static
name|SOCKET
modifier|*
name|brdv
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
endif|BROADCAST
if|if
condition|(
name|Sock_host
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|initial
condition|)
return|return;
comment|/* Daemon address already valid */
name|initial
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|Sock_host
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Unknown host"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|Daemon
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|Daemon
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Sock_port
argument_list|)
expr_stmt|;
name|Daemon
operator|.
name|sin_addr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|Query_driver
condition|)
return|return;
block|}
if|if
condition|(
name|initial
condition|)
block|{
comment|/* do one time initialization */
ifndef|#
directive|ifndef
name|BROADCAST
name|sethostent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* don't bother to close host file */
endif|#
directive|endif
endif|BROADCAST
if|if
condition|(
name|gethostname
argument_list|(
name|local_name
argument_list|,
sizeof|sizeof
name|local_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Sorry, I have no name."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|local_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Can't find myself."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|local_address
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
expr_stmt|;
name|test
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|test
operator|.
name|sin_addr
operator|=
name|local_address
expr_stmt|;
name|test
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Test_port
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|OLDIPC
name|test_socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
else|OLDIPC
name|test_socket
operator|=
name|socket
argument_list|(
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OLCIPC
if|if
condition|(
name|test_socket
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"socket system call failed"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|msg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Query_driver
operator|&&
name|Sock_host
operator|!=
name|NULL
condition|)
block|{
name|test
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|test
operator|.
name|sin_addr
operator|=
name|Daemon
operator|.
name|sin_addr
expr_stmt|;
name|test
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Test_port
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OLDIPC
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
else|OLDIPC
operator|(
name|void
operator|)
name|send
argument_list|(
name|test_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OLDIPC
goto|goto
name|get_response
goto|;
block|}
if|if
condition|(
operator|!
name|initial
condition|)
block|{
comment|/* favor host of previous session by broadcasting to it first */
name|test
operator|.
name|sin_addr
operator|=
name|Daemon
operator|.
name|sin_addr
expr_stmt|;
name|test
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Test_port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BROADCAST
if|if
condition|(
name|initial
condition|)
name|brdc
operator|=
name|broadcast_vec
argument_list|(
name|test_socket
argument_list|,
operator|&
name|brdv
argument_list|)
expr_stmt|;
if|if
condition|(
name|brdc
operator|<=
literal|0
condition|)
block|{
name|Daemon
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|Daemon
operator|.
name|sin_addr
operator|=
name|local_address
expr_stmt|;
name|Daemon
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Sock_port
argument_list|)
expr_stmt|;
name|initial
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|test_socket
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|int
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"setsockopt broadcast"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"setsockopt broadcast"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* send broadcast packets on all interfaces */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|brdc
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
operator|&
name|brdv
index|[
name|i
index|]
argument_list|,
operator|&
name|test
argument_list|,
sizeof|sizeof
argument_list|(
name|SOCKET
argument_list|)
argument_list|)
expr_stmt|;
name|test
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Test_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"sendto"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|#
directive|else
else|BROADCAST
comment|/* loop thru all hosts on local net and send msg to them. */
name|sethostent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* rewind host file */
while|while
condition|(
name|hp
operator|=
name|gethostent
argument_list|()
condition|)
block|{
if|if
condition|(
name|inet_netof
argument_list|(
name|test
operator|.
name|sin_addr
argument_list|)
operator|==
name|inet_netof
argument_list|(
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
argument_list|)
condition|)
block|{
name|test
operator|.
name|sin_addr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OLDIPC
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
else|OLDIPC
operator|(
name|void
operator|)
name|send
argument_list|(
name|test_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|OLDIPC
block|}
block|}
endif|#
directive|endif
endif|BROADCAST
name|get_response
label|:
name|namelen
operator|=
name|DAEMON_SIZE
expr_stmt|;
name|oldsigalrm
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OLDIPC
if|if
condition|(
name|recvfrom
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
operator|&
name|namelen
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
else|OLDIPC
if|if
condition|(
name|receive
argument_list|(
name|test_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
endif|OLDIPC
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|perror
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"recvfrom"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|oldsigalrm
argument_list|)
expr_stmt|;
name|Daemon
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|Daemon
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Sock_port
argument_list|)
expr_stmt|;
name|Daemon
operator|.
name|sin_addr
operator|=
name|local_address
expr_stmt|;
if|if
condition|(
operator|!
name|do_startup
condition|)
name|Daemon
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
else|else
name|start_driver
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|oldsigalrm
argument_list|)
expr_stmt|;
name|Daemon
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Sock_port
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|test_socket
argument_list|)
expr_stmt|;
name|initial
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_macro
name|start_driver
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|procid
decl_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|Am_monitor
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"No one playing."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
endif|MONITOR
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|Sock_host
operator|!=
name|NULL
condition|)
block|{
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
endif|INTERNET
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Starting..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|procid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|procid
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"fork failed."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|procid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|Socket
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|Driver
argument_list|,
literal|"HUNT"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* only get here if exec failed */
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGEMT
argument_list|)
expr_stmt|;
comment|/* tell mom */
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Connecting..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * bad_con:  *	We had a bad connection.  For the moment we assume that this  *	means the game is full.  */
end_comment

begin_macro
name|bad_con
argument_list|()
end_macro

begin_block
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"The game is full.  Sorry."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * dumpit:  *	Handle a core dump signal by not dumping core, just leaving,  *	so we end up with a core dump from the driver  */
end_comment

begin_macro
name|dumpit
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|kill
argument_list|(
name|Master_pid
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|"coredump"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sigterm:  *	Handle a terminate signal  */
end_comment

begin_macro
name|sigterm
argument_list|()
end_macro

begin_block
block|{
name|leave
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * sigemt:  *	Handle a emt signal - shouldn't happen on vaxes(?)  */
end_comment

begin_macro
name|sigemt
argument_list|()
end_macro

begin_block
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Unable to start driver.  Try again."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_comment
comment|/*  * sigalrm:  *	Handle an alarm signal  */
end_comment

begin_macro
name|sigalrm
argument_list|()
end_macro

begin_block
block|{
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_comment
comment|/*  * rmnl:  *	Remove a '\n' at the end of a string if there is one  */
end_comment

begin_macro
name|rmnl
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
name|cp
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * intr:  *	Handle a interrupt signal  */
end_comment

begin_macro
name|intr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|int
name|explained
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|y
operator|=
name|cur_row
expr_stmt|;
name|x
operator|=
name|cur_col
expr_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Really quit? "
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|explained
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|Socket
argument_list|,
literal|"q"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|Socket
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cur_row
operator|=
name|y
expr_stmt|;
name|cur_col
operator|=
name|x
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|put_str
argument_list|(
literal|"(Y or N) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|explained
operator|=
name|TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|CTRL
argument_list|(
name|G
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * leave:  *	Leave the game somewhat gracefully, restoring all current  *	tty stats.  */
end_comment

begin_macro
name|leave
argument_list|(
argument|eval
argument_list|,
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|eval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesg
operator|==
name|NULL
condition|)
name|clear_eol
argument_list|()
expr_stmt|;
else|else
block|{
name|put_str
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* flush in case VE changes pages */
block|}
name|resetty
argument_list|()
expr_stmt|;
name|_puts
argument_list|(
name|VE
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|TE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * tstp:  *	Handle stop and start signals  */
end_comment

begin_macro
name|tstp
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|struct
name|sgttyb
name|tty
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|tty
operator|=
name|_tty
expr_stmt|;
name|y
operator|=
name|cur_row
expr_stmt|;
name|x
operator|=
name|cur_col
expr_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|_puts
argument_list|(
name|VE
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|TE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstp
argument_list|)
expr_stmt|;
name|_tty
operator|=
name|tty
expr_stmt|;
operator|(
name|void
operator|)
name|stty
argument_list|(
name|_tty_ch
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|TI
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|VS
argument_list|)
expr_stmt|;
name|cur_row
operator|=
name|y
expr_stmt|;
name|cur_col
operator|=
name|x
expr_stmt|;
name|_puts
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
name|cur_row
argument_list|,
name|cur_col
argument_list|)
argument_list|)
expr_stmt|;
name|redraw_screen
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|env_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|envp
decl_stmt|,
modifier|*
name|envname
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|map_key
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
name|envname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|envp
operator|=
name|getenv
argument_list|(
literal|"HUNT"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"name="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|envname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
comment|/* must be last option */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"mapkey="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|s
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|+=
literal|2
control|)
block|{
name|map_key
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
operator|=
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"unknown option %s\n"
argument_list|,
name|envp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|envp
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|envname
operator|==
name|NULL
condition|)
name|envname
operator|=
name|envp
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown option %s\n"
argument_list|,
name|envp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envname
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|envname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Entering as '%s'\n"
argument_list|,
name|envname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Enter your code name: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rmnl
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

