begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"whoami"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PI
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_comment
comment|/*  * Convert a p1 into a p2.  * Mostly used for different  * length integers and "to real" conversions.  */
end_comment

begin_macro
name|convert
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p1
operator|==
name|NIL
operator|||
name|p2
operator|==
name|NIL
condition|)
return|return;
switch|switch
condition|(
name|width
argument_list|(
name|p1
argument_list|)
operator|-
name|width
argument_list|(
name|p2
argument_list|)
condition|)
block|{
case|case
operator|-
literal|7
case|:
case|case
operator|-
literal|6
case|:
name|put1
argument_list|(
name|O_STOD
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|4
case|:
name|put1
argument_list|(
name|O_ITOD
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|3
case|:
case|case
operator|-
literal|2
case|:
name|put1
argument_list|(
name|O_STOI
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|1
case|:
case|case
literal|0
case|:
case|case
literal|1
case|:
return|return;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|put1
argument_list|(
name|O_ITOS
argument_list|)
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"convert"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Compat tells whether  * p1 and p2 are compatible  * types for an assignment like  * context, i.e. value parameters,  * indicies for 'in', etc.  */
end_comment

begin_macro
name|compat
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c1
operator|,
name|c2
expr_stmt|;
name|c1
operator|=
name|classify
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|c2
operator|=
name|classify
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
switch|switch
condition|(
name|c1
condition|)
block|{
case|case
name|TBOOL
case|:
case|case
name|TCHAR
case|:
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|TINT
case|:
if|if
condition|(
name|c2
operator|==
name|TINT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TDOUBLE
case|:
if|if
condition|(
name|c2
operator|==
name|TDOUBLE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c2
operator|==
name|TINT
operator|&&
name|divflg
operator|==
literal|0
condition|)
block|{
name|divchk
operator|=
literal|1
expr_stmt|;
name|c1
operator|=
name|classify
argument_list|(
name|rvalue
argument_list|(
name|t
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
name|divchk
operator|=
name|NIL
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|TINT
condition|)
block|{
name|error
argument_list|(
literal|"Type clash: real is incompatible with integer"
argument_list|)
expr_stmt|;
name|cerror
argument_list|(
literal|"This resulted because you used '/' which always returns real rather"
argument_list|)
expr_stmt|;
name|cerror
argument_list|(
literal|"than 'div' which divides integers and returns integers"
argument_list|)
expr_stmt|;
name|divflg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|TSCAL
case|:
if|if
condition|(
name|c2
operator|!=
name|TSCAL
condition|)
break|break;
if|if
condition|(
name|scalar
argument_list|(
name|p1
argument_list|)
operator|!=
name|scalar
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Type clash: non-identical scalar types"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TSTR
case|:
if|if
condition|(
name|c2
operator|!=
name|TSTR
condition|)
break|break;
if|if
condition|(
name|width
argument_list|(
name|p1
argument_list|)
operator|!=
name|width
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Type clash: unequal length strings"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TNIL
case|:
if|if
condition|(
name|c2
operator|!=
name|TPTR
condition|)
break|break;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TFILE
case|:
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
name|error
argument_list|(
literal|"Type clash: files not allowed in this context"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
default|default:
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
if|if
condition|(
name|p1
operator|!=
name|p2
condition|)
block|{
name|error
argument_list|(
literal|"Type clash: non-identical %s types"
argument_list|,
name|clnames
index|[
name|c1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|nl_flags
operator|&
name|NFILES
condition|)
block|{
name|error
argument_list|(
literal|"Type clash: %ss with file components not allowed in this context"
argument_list|,
name|clnames
index|[
name|c1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
argument_list|(
literal|"Type clash: %s is incompatible with %s"
argument_list|,
name|clnames
index|[
name|c1
index|]
argument_list|,
name|clnames
index|[
name|c2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Rangechk generates code to  * check if the type p on top  * of the stack is in range for  * assignment to a variable  * of type q.  */
end_comment

begin_macro
name|rangechk
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|rp
decl_stmt|;
specifier|register
name|op
expr_stmt|;
name|int
name|wq
decl_stmt|,
name|wrp
decl_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'t'
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|rp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NIL
condition|)
return|return;
if|if
condition|(
name|q
operator|==
name|NIL
condition|)
return|return;
comment|/* 	 * When op is 1 we are checking length 	 * 4 numbers against length 2 bounds, 	 * and adding it to the opcode forces 	 * generation of appropriate tests. 	 */
name|op
operator|=
literal|0
expr_stmt|;
name|wq
operator|=
name|width
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|wrp
operator|=
name|width
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|op
operator|=
name|wq
operator|!=
name|wrp
operator|&&
operator|(
name|wq
operator|==
literal|4
operator|||
name|wrp
operator|==
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|class
operator|==
name|TYPE
condition|)
name|rp
operator|=
name|rp
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|rp
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
if|if
condition|(
name|rp
operator|->
name|range
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|wrp
operator|<=
literal|2
condition|)
name|put3
argument_list|(
name|O_RANG2
operator|+
name|op
argument_list|,
name|rp
operator|->
name|value
index|[
literal|1
index|]
argument_list|,
name|rp
operator|->
name|value
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|nl
operator|+
name|T4INT
condition|)
name|put
argument_list|(
literal|5
argument_list|,
name|O_RANG4
operator|+
name|op
argument_list|,
name|rp
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Range whose lower bounds are 			 * zero can be treated as scalars. 			 */
case|case
name|SCAL
case|:
if|if
condition|(
name|wrp
operator|<=
literal|2
condition|)
name|put2
argument_list|(
name|O_RSNG2
operator|+
name|op
argument_list|,
name|rp
operator|->
name|value
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|put3
argument_list|(
name|O_RSNG4
operator|+
name|op
argument_list|,
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rangechk"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

