begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  * Version 1.0 August 1977  */
end_comment

begin_include
include|#
directive|include
file|"whoami"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_comment
comment|/*  * This array tells the type  * returned by an arithmetic  * operation.  It is indexed  * by the logarithm of the  * lengths base 2.  */
end_comment

begin_decl_stmt
name|char
name|arret
index|[]
block|{
name|T4INT
operator|,
name|T4INT
operator|,
name|T4INT
operator|,
name|TDOUBLE
operator|,
name|T4INT
operator|,
name|T4INT
operator|,
name|T4INT
operator|,
name|TDOUBLE
operator|,
name|T4INT
operator|,
name|T4INT
operator|,
name|T4INT
operator|,
name|TDOUBLE
operator|,
name|TDOUBLE
operator|,
name|TDOUBLE
operator|,
name|TDOUBLE
operator|,
name|TDOUBLE
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * These array of arithmetic and set  * operators are indexed by the  * tree nodes and is highly dependent  * on their order.  They thus take  * on the flavor of magic.  */
end_comment

begin_decl_stmt
name|int
name|arop
index|[]
block|{
literal|0
operator|,
name|O_NEG2
operator|,
name|O_MOD2
operator|,
name|O_DIV2
operator|,
name|O_DVD2
operator|,
name|O_MUL2
operator|,
name|O_ADD2
operator|,
name|O_SUB2
operator|,
name|O_REL2
operator|,
name|O_REL2
operator|,
name|O_REL2
operator|,
name|O_REL2
operator|,
name|O_REL2
operator|,
name|O_REL2
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|setop
index|[]
block|{
name|O_MULT
operator|,
name|O_ADDT
operator|,
name|O_SUBT
operator|,
name|O_RELT
operator|,
name|O_RELT
operator|,
name|O_RELT
operator|,
name|O_RELT
operator|,
name|O_RELT
operator|,
name|O_RELT
operator|,
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * The following array is  * used when operating on  * two reals since they are  * shoved off in a corner in  * the interpreter table.  */
end_comment

begin_decl_stmt
name|int
name|ar8op
index|[]
block|{
name|O_DVD8
operator|,
name|O_MUL8
operator|,
name|O_ADD8
operator|,
name|O_SUB8
operator|,
name|O_REL8
operator|,
name|O_REL8
operator|,
name|O_REL8
operator|,
name|O_REL8
operator|,
name|O_REL8
operator|,
name|O_REL8
operator|,
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * The following arrays, which are linearizations  * of two dimensional arrays, are the offsets for  * arithmetic, relational and assignment operations  * indexed by the logarithms of the argument widths.  */
end_comment

begin_decl_stmt
name|char
name|artab
index|[]
block|{
name|O_ADD2
operator|-
name|O_ADD2
operator|,
name|O_ADD2
operator|-
name|O_ADD2
operator|,
name|O_ADD42
operator|-
name|O_ADD2
operator|,
name|O_ADD82
operator|-
name|O_ADD2
operator|,
name|O_ADD2
operator|-
name|O_ADD2
operator|,
name|O_ADD2
operator|-
name|O_ADD2
operator|,
name|O_ADD42
operator|-
name|O_ADD2
operator|,
name|O_ADD82
operator|-
name|O_ADD2
operator|,
name|O_ADD24
operator|-
name|O_ADD2
operator|,
name|O_ADD24
operator|-
name|O_ADD2
operator|,
name|O_ADD4
operator|-
name|O_ADD2
operator|,
name|O_ADD84
operator|-
name|O_ADD2
operator|,
name|O_ADD28
operator|-
name|O_ADD2
operator|,
name|O_ADD28
operator|-
name|O_ADD2
operator|,
name|O_ADD48
operator|-
name|O_ADD2
operator|,
operator|-
literal|1
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
name|reltab
index|[]
block|{
name|O_REL2
operator|-
name|O_REL2
operator|,
name|O_REL2
operator|-
name|O_REL2
operator|,
name|O_REL42
operator|-
name|O_REL2
operator|,
name|O_REL82
operator|-
name|O_REL2
operator|,
name|O_REL2
operator|-
name|O_REL2
operator|,
name|O_REL2
operator|-
name|O_REL2
operator|,
name|O_REL42
operator|-
name|O_REL2
operator|,
name|O_REL82
operator|-
name|O_REL2
operator|,
name|O_REL24
operator|-
name|O_REL2
operator|,
name|O_REL24
operator|-
name|O_REL2
operator|,
name|O_REL4
operator|-
name|O_REL2
operator|,
name|O_REL84
operator|-
name|O_REL2
operator|,
name|O_REL28
operator|-
name|O_REL2
operator|,
name|O_REL28
operator|-
name|O_REL2
operator|,
name|O_REL48
operator|-
name|O_REL2
operator|,
name|O_REL8
operator|-
name|O_REL2
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
name|asgntab
index|[]
block|{
name|O_AS21
operator|-
name|O_AS2
operator|,
name|O_AS21
operator|-
name|O_AS2
operator|,
name|O_AS41
operator|-
name|O_AS2
operator|,
operator|-
literal|1
operator|,
name|O_AS2
operator|-
name|O_AS2
operator|,
name|O_AS2
operator|-
name|O_AS2
operator|,
name|O_AS42
operator|-
name|O_AS2
operator|,
operator|-
literal|1
operator|,
name|O_AS24
operator|-
name|O_AS2
operator|,
name|O_AS24
operator|-
name|O_AS2
operator|,
name|O_AS4
operator|-
name|O_AS2
operator|,
operator|-
literal|1
operator|,
name|O_AS28
operator|-
name|O_AS2
operator|,
name|O_AS28
operator|-
name|O_AS2
operator|,
name|O_AS48
operator|-
name|O_AS2
operator|,
name|O_AS8
operator|-
name|O_AS2
operator|,
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Gen generates code for assignments,  * and arithmetic and string operations  * and comparisons.  */
end_comment

begin_macro
name|gen
argument_list|(
argument|p
argument_list|,
argument|o
argument_list|,
argument|w1
argument_list|,
argument|w2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p
decl_stmt|,
name|o
decl_stmt|,
name|w1
decl_stmt|,
name|w2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|int
name|op
decl_stmt|,
name|off
decl_stmt|;
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|O_AS2
case|:
case|case
name|NIL
case|:
name|i
operator|=
name|j
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 			 * Take the log2 of the widths 			 * and linearize them for indexing. 			 * width for indexing. 			 */
do|do
name|i
operator|++
expr_stmt|;
do|while
condition|(
name|w1
operator|=
operator|>>
literal|1
condition|)
do|;
do|do
name|j
operator|++
expr_stmt|;
do|while
condition|(
name|w2
operator|=
operator|>>
literal|1
condition|)
do|;
name|i
operator|=
operator|<<
literal|2
expr_stmt|;
name|i
operator|=
operator||
name|j
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|O_AS2
condition|)
block|{
name|put1
argument_list|(
name|O_AS2
operator|+
name|asgntab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|op
operator|=
name|arop
index|[
name|o
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_REL2
condition|)
block|{
name|put1
argument_list|(
operator|(
name|op
operator|+
name|reltab
index|[
name|i
index|]
operator|)
operator||
operator|(
name|o
operator|-
name|T_EQ
operator|)
operator|<<
literal|9
argument_list|)
expr_stmt|;
return|return
operator|(
name|nl
operator|+
name|TBOOL
operator|)
return|;
block|}
name|put1
argument_list|(
name|i
operator|==
literal|15
condition|?
name|ar8op
index|[
name|o
operator|-
name|T_DIVD
index|]
else|:
name|op
operator||
name|artab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|op
operator|==
name|O_DVD2
operator|&&
operator|!
name|divchk
condition|?
name|nl
operator|+
name|TDOUBLE
else|:
name|nl
operator|+
name|arret
index|[
name|i
index|]
operator|)
return|;
case|case
name|TSTR
case|:
name|put2
argument_list|(
name|O_RELG
operator||
operator|(
name|o
operator|-
name|T_EQ
operator|)
operator|<<
literal|9
argument_list|,
name|w1
argument_list|)
expr_stmt|;
return|return
operator|(
name|nl
operator|+
name|TBOOL
operator|)
return|;
case|case
name|TSET
case|:
name|op
operator|=
name|setop
index|[
name|o
operator|-
name|T_MULT
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_RELT
condition|)
name|op
operator|=
operator||
operator|(
name|o
operator|-
name|T_EQ
operator|)
operator|<<
literal|9
expr_stmt|;
name|put2
argument_list|(
name|op
argument_list|,
name|w1
argument_list|)
expr_stmt|;
return|return
operator|(
name|o
operator|>=
name|T_EQ
condition|?
name|nl
operator|+
name|TBOOL
else|:
name|nl
operator|+
name|TSET
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"gen"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

