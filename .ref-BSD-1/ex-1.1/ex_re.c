begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_re.h"
end_include

begin_comment
comment|/*  * Ex - a text editor  * Bill Joy UCB June/September 1977  */
end_comment

begin_macro
name|compile
argument_list|(
argument|eof
argument_list|,
argument|oknl
argument_list|)
end_macro

begin_decl_stmt
name|int
name|eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|oknl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|lastep
decl_stmt|;
name|char
name|bracket
index|[
name|NBRA
index|]
decl_stmt|,
modifier|*
name|bracketp
decl_stmt|,
modifier|*
name|rhsp
decl_stmt|;
name|int
name|cclcnt
decl_stmt|;
if|if
condition|(
name|letter
argument_list|(
name|eof
argument_list|)
operator|||
name|digit
argument_list|(
name|eof
argument_list|)
condition|)
name|error
argument_list|(
literal|"Re delimiter must not be letter or digit|Regular expressions cannot be delimited by letters or digits"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|expbuf
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|eof
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|scanre
operator|.
name|sexpbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|noscanre
label|:
name|error
argument_list|(
literal|"No previous scan re|No previous scanning regular expression"
argument_list|)
expr_stmt|;
name|resre
argument_list|(
operator|&
name|scanre
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|subre
operator|.
name|sexpbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|nosubre
label|:
name|error
argument_list|(
literal|"No previous substitute re|No previous substitute regular expression"
argument_list|)
expr_stmt|;
name|resre
argument_list|(
operator|&
name|subre
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"Badly formed re|Regular expression \\ must be followed by /, ?, or&"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|eof
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|*
name|ep
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous re|No previous regular expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|oknl
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Missing closing delimiter@for regular expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|eof
operator|)
return|;
block|}
name|bracketp
operator|=
name|bracket
expr_stmt|;
name|nbra
operator|=
literal|0
expr_stmt|;
name|circfl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|circfl
operator|++
expr_stmt|;
block|}
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
operator|-
literal|2
index|]
condition|)
name|complex
label|:
name|cerror
argument_list|(
literal|"Re too complex|Regular expression too complicated"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|eof
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|bracketp
operator|!=
name|bracket
condition|)
name|cerror
argument_list|(
literal|"Unmatched \\(|More \\('s than \\)'s in regular expression"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CEOF
expr_stmt|;
return|return
operator|(
name|eof
operator|)
return|;
block|}
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|||
name|ep
operator|==
name|expbuf
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\\'
operator|||
name|peekchar
argument_list|()
operator|!=
literal|'*'
operator|||
name|ep
operator|==
name|expbuf
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|nbra
operator|>=
name|NBRA
condition|)
name|cerror
argument_list|(
literal|"Awash in \\('s!|Too many \\('d subexressions in a regular expression"
argument_list|)
expr_stmt|;
operator|*
name|bracketp
operator|++
operator|=
name|nbra
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CBRA
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|nbra
operator|++
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
if|if
condition|(
name|bracketp
operator|<=
name|bracket
condition|)
name|cerror
argument_list|(
literal|"Extra \\)|More \\)'s than \\('s in regular expression"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CKET
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
operator|--
name|bracketp
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
operator|*
name|ep
operator|++
operator|=
name|CBRC
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
operator|*
name|ep
operator|++
operator|=
name|CLET
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
operator|==
literal|0
condition|)
name|magic
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
operator|*
name|ep
operator|++
operator|=
name|CDOT
expr_stmt|;
continue|continue;
case|case
literal|'~'
case|:
name|rhsp
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
operator|*
name|rhsp
condition|)
block|{
if|if
condition|(
operator|*
name|rhsp
operator|&
name|QUOTE
condition|)
block|{
name|c
operator|=
operator|*
name|rhsp
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|error
argument_list|(
literal|"Replacement pattern contains&@- cannot use in re"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'1'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|error
argument_list|(
literal|"Replacement pattern contains \\d@- cannot use in re"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
operator|-
literal|2
index|]
condition|)
goto|goto
name|complex
goto|;
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
name|rhsp
operator|++
operator|&
literal|0177
expr_stmt|;
block|}
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|ep
operator|==
name|expbuf
condition|)
break|break;
if|if
condition|(
operator|*
name|lastep
operator|==
name|CBRA
operator|||
operator|*
name|lastep
operator|==
name|CKET
condition|)
name|cerror
argument_list|(
literal|"Illegal *|Can't * a \\( ... \\) in regular expression"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lastep
operator|==
name|CCHR
operator|&&
operator|(
name|lastep
index|[
literal|1
index|]
operator|&
name|QUOTE
operator|)
condition|)
name|cerror
argument_list|(
literal|"Illegal *|Can't * a \\n in regular expression"
argument_list|)
expr_stmt|;
operator|*
name|lastep
operator|=
operator||
name|STAR
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
operator|*
name|ep
operator|++
operator|=
name|CCL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
name|cclcnt
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|ep
index|[
operator|-
literal|2
index|]
operator|=
name|NCCL
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
name|cerror
argument_list|(
literal|"Bad character class|Empty character class '[]' or '[^]' cannot match"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|any
argument_list|(
name|peekchar
argument_list|()
argument_list|,
literal|"]-^\\"
argument_list|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
operator||
name|QUOTE
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
name|cerror
argument_list|(
literal|"Missing ]"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
index|]
condition|)
goto|goto
name|complex
goto|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|lastep
index|[
literal|1
index|]
operator|=
name|cclcnt
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|ungetchar
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
goto|goto
name|defchar
goto|;
block|}
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|cerror
argument_list|(
literal|"No newlines in re's|Can't escape newlines into regular expressions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|'1'
operator|||
name|c
operator|>
name|NBRA
operator|+
literal|'1'
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|-
literal|'1'
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|nbra
condition|)
name|cerror
argument_list|(
literal|"Bad \\n|\\n in regular expression with n greater than the number of \\('s"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
operator||
name|QUOTE
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
if|if
condition|(
name|oknl
condition|)
block|{
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CEOF
expr_stmt|;
return|return
operator|(
name|eof
operator|)
return|;
block|}
name|cerror
argument_list|(
literal|"Badly formed re|Missing closing delimiter for regular expression"
argument_list|)
expr_stmt|;
case|case
literal|'$'
case|:
if|if
condition|(
name|peekchar
argument_list|()
operator|==
name|eof
operator|||
name|peekchar
argument_list|()
operator|==
name|EOF
operator|||
name|oknl
operator|&&
name|peekchar
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
name|CDOL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|defchar
goto|;
case|case
literal|'.'
case|:
case|case
literal|'~'
case|:
case|case
literal|'*'
case|:
case|case
literal|'['
case|:
if|if
condition|(
name|value
argument_list|(
name|MAGIC
argument_list|)
condition|)
goto|goto
name|magic
goto|;
name|defchar
label|:
default|default:
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_block

begin_macro
name|cerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|expbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|same
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|int
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|a
operator|==
name|b
operator|||
name|value
argument_list|(
name|IGNORECASE
argument_list|)
operator|&&
operator|(
name|a
operator|^
name|b
operator|)
operator|==
literal|' '
operator|&&
name|letter
argument_list|(
name|a
argument_list|)
operator|==
name|letter
argument_list|(
name|b
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|execute
argument_list|(
argument|gf
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|gf
condition|)
block|{
if|if
condition|(
name|circfl
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locs
operator|=
name|p1
operator|=
name|loc2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addr
operator|==
name|zero
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p1
operator|=
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|locs
operator|=
literal|0
expr_stmt|;
block|}
name|p2
operator|=
name|expbuf
expr_stmt|;
if|if
condition|(
name|circfl
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|)
return|;
block|}
comment|/* fast check for first character */
if|if
condition|(
operator|*
name|p2
operator|==
name|CCHR
condition|)
block|{
name|c
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|!=
operator|*
name|p1
operator|&&
operator|(
operator|!
name|value
argument_list|(
name|IGNORECASE
argument_list|)
operator|||
operator|(
name|c
operator|^
operator|*
name|p1
operator|)
operator|!=
literal|' '
operator|||
name|letter
argument_list|(
name|c
argument_list|)
operator|!=
name|letter
argument_list|(
operator|*
name|p1
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* regular algorithm */
do|do
block|{
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|uletter
parameter_list|(
name|c
parameter_list|)
value|(letter(c) || c == '_')
end_define

begin_expr_stmt
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
specifier|register
name|char
operator|*
name|lp
operator|,
operator|*
name|ep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|curlp
decl_stmt|;
name|char
modifier|*
name|nextep
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp1
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|ep
operator|++
condition|)
block|{
case|case
name|CCHR
case|:
if|if
condition|(
operator|*
name|ep
operator|&
name|QUOTE
condition|)
block|{
name|c
operator|=
operator|*
name|ep
operator|++
operator|&
literal|0177
expr_stmt|;
name|sp
operator|=
name|braslist
index|[
name|c
index|]
expr_stmt|;
name|sp1
operator|=
name|braelist
index|[
name|c
index|]
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|sp1
condition|)
block|{
if|if
condition|(
operator|!
name|same
argument_list|(
operator|*
name|sp
argument_list|,
operator|*
name|lp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|++
operator|,
name|lp
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|same
argument_list|(
operator|*
name|ep
argument_list|,
operator|*
name|lp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ep
operator|++
operator|,
name|lp
operator|++
expr_stmt|;
continue|continue;
case|case
name|CDOT
case|:
if|if
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOL
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|0
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CEOF
case|:
name|loc2
operator|=
name|lp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|CCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ep
operator|=
operator|+
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NCCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ep
operator|=
operator|+
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBRA
case|:
name|braslist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CKET
case|:
name|braelist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CDOT
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
goto|goto
name|star
goto|;
case|case
name|CCHR
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|same
argument_list|(
operator|*
name|lp
argument_list|,
operator|*
name|ep
argument_list|)
condition|)
name|lp
operator|++
expr_stmt|;
name|lp
operator|++
expr_stmt|;
name|ep
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCL
operator||
name|STAR
case|:
case|case
name|NCCL
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|CCL
operator||
name|STAR
operator|)
argument_list|)
condition|)
continue|continue;
name|ep
operator|=
operator|+
operator|*
name|ep
expr_stmt|;
goto|goto
name|star
goto|;
name|star
label|:
do|do
block|{
name|lp
operator|--
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|locs
condition|)
break|break;
if|if
condition|(
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|lp
operator|>
name|curlp
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBRC
case|:
if|if
condition|(
name|lp
operator|==
name|expbuf
condition|)
continue|continue;
if|if
condition|(
name|uletter
argument_list|(
operator|*
name|lp
argument_list|)
operator|&&
operator|!
name|uletter
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|digit
argument_list|(
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CLET
case|:
if|if
condition|(
operator|!
name|uletter
argument_list|(
operator|*
name|lp
argument_list|)
operator|&&
operator|!
name|digit
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"Re internal error@- if possible remember what you did and tell system staff"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|cclass
argument_list|(
name|set
argument_list|,
name|c
argument_list|,
name|af
argument_list|)
specifier|register
name|char
operator|*
name|set
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|af
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|value
argument_list|(
name|IGNORECASE
argument_list|)
operator|&&
name|ucletter
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|letter
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|set
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
if|if
condition|(
name|n
operator|>
literal|2
operator|&&
name|set
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|c
operator|>=
operator|(
name|set
index|[
literal|0
index|]
operator|&
literal|0177
operator|)
operator|&&
name|c
operator|<=
operator|(
name|set
index|[
literal|2
index|]
operator|&
literal|0177
operator|)
condition|)
return|return
operator|(
name|af
operator|)
return|;
name|set
operator|=
operator|+
literal|3
expr_stmt|;
name|n
operator|=
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|set
operator|++
operator|&
literal|0177
operator|)
operator|==
name|c
condition|)
return|return
operator|(
name|af
operator|)
return|;
return|return
operator|(
operator|!
name|af
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|copy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|char
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
do|do
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|size
operator|>
literal|0
condition|)
do|;
block|}
end_block

end_unit

