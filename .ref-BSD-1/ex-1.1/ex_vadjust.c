begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VISUAL
end_ifdef

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Ex - a text editor  * Bill Joy UCB September 1977  */
end_comment

begin_expr_stmt
name|vback
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Candidate for first line is tp. 	 * To take tp-1 instead he must fit in 	 * the remaining space and obviously must 	 * exit, hence need "tp> one". 	 */
for|for
control|(
name|tp
operator|=
name|dot
init|;
name|tp
operator|>
name|one
condition|;
name|tp
operator|--
control|)
block|{
name|getline
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|vdepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|i
condition|)
break|break;
name|i
operator|=
operator|-
name|j
expr_stmt|;
block|}
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|listchar
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|Putchar
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the depth of the line in linebuf.  * Note that VCOLUMNS are always completely usable.  * The last line on a terminal with automargins is not  * normally used; if the terminal does not have an addressible  * cursor, then we use the last line but not the last column.  */
end_comment

begin_macro
name|vdepth
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|column
argument_list|(
literal|0
argument_list|)
operator|+
name|VCOLUMNS
operator|-
literal|1
operator|+
operator|(
name|Putchar
operator|==
operator|&
name|listchar
operator|)
operator|)
operator|/
name|VCOLUMNS
expr_stmt|;
return|return
operator|(
name|i
operator|==
literal|0
condition|?
literal|1
else|:
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Open the line tp at line l on the physical screen.  * The rest of the lines are shifted down as necessary.  * The caller is responsible for adjusting vcline as he/she sees fit.  * We return the number of lines occupied by this line on the screen.  */
end_comment

begin_macro
name|vopen
argument_list|(
argument|tp
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|tp
decl_stmt|,
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * If we are doing an open command then we start anew with 	 * each opened line. 	 */
if|if
condition|(
operator|!
name|visual
condition|)
name|vcnt
operator|=
literal|0
operator|,
name|vcline
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|vcline
operator|>
name|vcnt
operator|||
name|vcline
operator|<
literal|0
operator|||
name|vcnt
operator|<
literal|0
operator|||
name|vcnt
operator|>
name|TUBELINES
condition|)
name|error
argument_list|(
literal|"Internal error: vopen@- please tell someone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|<
name|one
operator|||
name|tp
operator|>
name|dol
condition|)
name|error
argument_list|(
literal|"Internal error: vopen tp@- please tell someone"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Have to be very careful before calling vreopen. 	 * Note that as a consequence of this reopen, the screen 	 * may roll up, invalidating our value for l. 	 * Thus we must put this l into the vliny array so it 	 * will be adjusted properly. 	 */
for|for
control|(
name|j
operator|=
name|vcnt
init|;
name|j
operator|>=
name|vcline
condition|;
name|j
operator|--
control|)
name|vliny
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|vliny
index|[
name|j
index|]
expr_stmt|;
name|vliny
index|[
name|vcline
index|]
operator|=
name|l
expr_stmt|;
comment|/* 	 * Get the line to be opened and "reopen" it on the screen. 	 * Reopen returns the number of screen lines occupied. 	 */
name|vcnt
operator|++
expr_stmt|;
name|getline
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|i
operator|=
name|vreopen
argument_list|(
name|l
argument_list|,
name|tp
operator|-
name|zero
argument_list|)
expr_stmt|;
comment|/* 	 * If this is the last line on the screen, then there is 	 * not much to do here. 	 */
if|if
condition|(
name|vcline
operator|+
literal|1
operator|==
name|vcnt
condition|)
block|{
name|vliny
index|[
name|vcnt
index|]
operator|=
name|vliny
index|[
name|vcline
index|]
operator|+
name|i
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* 	 * There are lines on the screen which appeared after the place 	 * where this one was opened and they have a chance to remain. 	 * If there is not enough space between the new line and the 	 * one following it then the screen tail will have to be redrawn 	 * to reflect the new line's presence. 	 */
name|vfixopen
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|vfixopen
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|need
decl_stmt|;
specifier|extern
name|int
argument_list|(
operator|*
name|Pline
argument_list|)
argument_list|()
decl_stmt|,
name|numbline
argument_list|()
decl_stmt|;
if|if
condition|(
name|LINES
operator|!=
name|VLINES
condition|)
block|{
name|need
operator|=
name|vliny
index|[
name|vcline
index|]
operator|+
name|i
operator|-
name|vliny
index|[
name|vcline
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|need
operator|>
literal|0
condition|)
name|vopenup
argument_list|(
name|need
argument_list|)
expr_stmt|;
block|}
name|vsync
argument_list|(
name|vliny
index|[
name|vcline
index|]
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Guts of the open of the line in linebuf at  * line l on the physical screen.  We first check  * that the line will fit on the screen.  We then  * goto the beginning of the line, put out the  * characters of the line and clear to the end of  * the line, returning the number of lines we used.  */
end_comment

begin_macro
name|vreopen
argument_list|(
argument|l
argument_list|,
argument|lineno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|,
name|lineno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|vigoto
argument_list|(
name|l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|vdepth
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|CA
operator|&&
name|i
operator|>
literal|1
operator|)
operator|||
name|i
operator|>
name|LINES
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Line too long@for open"
argument_list|)
expr_stmt|;
name|pline
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|Putchar
operator|==
operator|&
name|listchar
condition|)
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the number of new screen lines required  * to make i lines starting at t fit on the screen.  */
end_comment

begin_macro
name|vfit
argument_list|(
argument|i
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|getline
argument_list|(
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
operator|+
name|vdepth
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Account for the free space 	 * at the bottom. 	 */
name|j
operator|=
operator|-
name|VLINES
operator|-
name|vlast
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Roll a specified number of lines onto the screen.  * If more than one line is being rolled, switch to  * cooked mode so that the user can stop or interrupt the output.  */
end_comment

begin_macro
name|vroll
argument_list|(
argument|ocnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ocnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
name|ocnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
name|vcook
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|--
control|)
block|{
name|dot
operator|++
expr_stmt|;
name|vcline
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|CA
condition|)
block|{
name|vup1
argument_list|()
expr_stmt|;
name|vscroll
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vlast
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
block|}
name|vopen
argument_list|(
name|dot
argument_list|,
name|vlast
argument_list|)
expr_stmt|;
name|vcsync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ocnt
operator|>
literal|1
condition|)
block|{
name|flusho
argument_list|()
expr_stmt|;
name|vraw
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Roll the screen up.  The argument is by reference because  * it may be used in subsequent computation and therefore must  * be changed to reflect this call.  We make the argument line  * be the last line of the screen.  */
end_comment

begin_macro
name|vrollup
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|*
name|ip
operator|-
name|LINES
operator|+
literal|2
expr_stmt|;
name|vscroll
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|*
name|ip
operator|=
operator|-
name|i
expr_stmt|;
name|vmoveitup
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Move the screen up i lines physically  */
end_comment

begin_macro
name|vmoveitup
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Internal error: vmoveitup@- please tell someone"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return;
name|destline
operator|=
name|LINES
operator|+
name|i
operator|-
literal|1
expr_stmt|;
name|destcol
operator|=
name|outcol
operator|%
name|COLUMNS
expr_stmt|;
name|fgoto
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Move the screen up i lines logically  */
end_comment

begin_expr_stmt
name|vscroll
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|tlines
index|[
name|TUBELINES
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|TUBELINES
condition|)
name|error
argument_list|(
literal|"Internal error: vscroll@- please tell someone"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return;
name|copy
argument_list|(
name|tlines
argument_list|,
name|vtube
argument_list|,
sizeof|sizeof
name|vtube
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|vtube
argument_list|,
operator|&
name|tlines
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
name|vtube
operator|-
name|i
operator|*
sizeof|sizeof
name|vtube
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|vtube
index|[
name|TUBELINES
operator|-
name|i
index|]
argument_list|,
name|tlines
argument_list|,
name|i
operator|*
sizeof|sizeof
name|vtube
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|TUBELINES
operator|-
name|i
init|;
name|j
operator|<
name|TUBELINES
condition|;
name|j
operator|++
control|)
name|vclrbyte
argument_list|(
name|vtube
index|[
name|j
index|]
argument_list|,
name|VCOLUMNS
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|vcnt
condition|;
name|j
operator|++
control|)
name|vliny
index|[
name|j
index|]
operator|=
operator|-
name|i
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Discard logical lines due to physical  * wandering off the screen.  */
end_comment

begin_macro
name|vscrap
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|vcnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|vliny
index|[
name|j
index|]
operator|>=
name|ZERO
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
break|break;
comment|/* 			 * Discard the first j physical lines off the top 			 */
name|vcnt
operator|=
operator|-
name|j
expr_stmt|;
name|vcline
operator|=
operator|-
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|vcnt
condition|;
name|i
operator|++
control|)
name|vliny
index|[
name|i
index|]
operator|=
name|vliny
index|[
name|i
operator|+
name|j
index|]
expr_stmt|;
break|break;
block|}
comment|/* 	 * Discard lines off the bottom 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|vcnt
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|vliny
index|[
name|j
index|]
operator|>=
name|VLINES
condition|)
name|vcnt
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|vcnt
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No lines fit@on screen!"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Open blank lines on the screen  */
end_comment

begin_macro
name|vopenup
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|visual
operator|&&
operator|!
name|CA
condition|)
block|{
name|vsave
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Line too long@for open"
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|LINES
operator|-
name|vliny
index|[
name|vcline
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Internal error: vopenup@- please tell someone"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
name|j
condition|)
name|i
operator|=
name|j
expr_stmt|;
for|for
control|(
name|l
operator|=
name|vcline
operator|+
literal|1
init|;
name|l
operator|<=
name|vcnt
condition|;
name|l
operator|++
control|)
name|vliny
index|[
name|l
index|]
operator|=
operator|+
name|i
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Synchronize the screen.  Vredraw is more ambitious than vsync  * but correspondingly may take more resources to do its deed.  */
end_comment

begin_expr_stmt
name|vredraw
argument_list|(
name|p
argument_list|)
specifier|register
name|int
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
name|temp
index|[
name|LBSIZE
index|]
decl_stmt|;
name|int
name|ovcline
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|p
operator|<
literal|0
operator|||
name|p
operator|>
name|VLINES
condition|)
name|error
argument_list|(
literal|"Internal error: vredraw@- please tell someone"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|temp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|dot
operator|-
name|vcline
expr_stmt|;
while|while
condition|(
name|l
operator|<
name|vcnt
operator|&&
name|vliny
index|[
name|l
index|]
operator|<
name|p
condition|)
name|l
operator|++
operator|,
name|tp
operator|++
expr_stmt|;
for|for
control|(
init|;
name|l
operator|<
name|vcnt
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|==
name|vcline
condition|)
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|getline
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|vliny
index|[
name|l
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|=
operator|+
name|vreopen
argument_list|(
name|p
argument_list|,
name|tp
operator|-
name|zero
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
name|ovcline
operator|=
name|vcline
expr_stmt|;
name|vcline
operator|=
name|l
expr_stmt|;
for|for
control|(
init|;
name|tp
operator|<=
name|dol
condition|;
name|tp
operator|++
control|)
block|{
name|getline
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|vdepth
argument_list|()
operator|>
name|VLINES
condition|)
break|break;
name|p
operator|=
operator|+
name|vopen
argument_list|(
name|tp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vcline
operator|++
expr_stmt|;
block|}
name|vcline
operator|=
name|ovcline
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|LINES
operator|-
literal|1
condition|;
name|p
operator|++
control|)
name|vclrlin
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vsync
argument_list|(
name|p
argument_list|)
specifier|register
name|int
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|,
name|lim
decl_stmt|;
name|char
name|temp
index|[
name|LBSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIMP
if|if
condition|(
name|allredraw
condition|)
block|{
name|vredraw
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|strcpy
argument_list|(
name|temp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l
operator|<
name|vcnt
operator|&&
name|vliny
index|[
name|l
index|]
operator|<
name|p
condition|)
name|l
operator|++
expr_stmt|;
name|lim
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|visual
operator|&&
operator|!
name|CA
condition|)
name|lim
operator|++
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|lim
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|l
operator|<
name|vcnt
operator|&&
name|vliny
index|[
name|l
index|]
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|l
operator|==
name|vcline
condition|)
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|getline
argument_list|(
name|dot
index|[
name|l
operator|-
name|vcline
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
operator|+
name|vreopen
argument_list|(
name|p
argument_list|,
operator|(
name|dot
operator|-
name|zero
operator|)
operator|+
operator|(
name|l
operator|-
name|vcline
operator|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
else|else
name|vclrlin
argument_list|(
name|p
argument_list|,
name|dot
operator|+
operator|(
name|l
operator|-
name|vcline
operator|)
argument_list|)
expr_stmt|;
name|strcLIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Remove (up to) cnt lines from the screen  * starting with the line at vfirst as the  * result of a delete or join.  */
end_comment

begin_macro
name|velide
argument_list|(
argument|cnt
argument_list|,
argument|vfirst
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cnt
decl_stmt|,
name|vfirst
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Can't delete more lines than there are. 	 */
if|if
condition|(
name|vcnt
operator|-
name|vfirst
operator|<
name|cnt
condition|)
name|cnt
operator|=
name|vcnt
operator|-
name|vfirst
expr_stmt|;
comment|/* 	 * Shift the rest of the lines up in the array. 	 */
for|for
control|(
name|i
operator|=
name|vfirst
operator|+
name|cnt
init|;
name|i
operator|<=
name|vcnt
condition|;
name|i
operator|++
control|)
name|vliny
index|[
name|i
operator|-
name|cnt
index|]
operator|=
name|vliny
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Lost cnt lines. 	 */
name|vcnt
operator|=
operator|-
name|cnt
expr_stmt|;
block|}
end_block

begin_macro
name|vup1
argument_list|()
end_macro

begin_block
block|{
name|vmoveitup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

