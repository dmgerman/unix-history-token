begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_comment
comment|/*  * Ex - a text editor  * Bill Joy UCB June 1977  */
end_comment

begin_expr_stmt
name|STATIC
name|char
name|line
index|[
literal|66
index|]
literal|"Error message file not available\n/usr/lib/ex1.1strings"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STATIC
name|char
operator|*
name|linp
name|line
operator|+
literal|33
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern	char *erpath line + 33;
end_extern

begin_decl_stmt
specifier|extern
name|char
name|pfast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|phadnl
decl_stmt|;
end_decl_stmt

begin_macro
name|termchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pfast
operator|==
literal|0
operator|&&
name|phadnl
condition|)
name|pstart
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|phadnl
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|linp
operator|>=
operator|&
name|line
index|[
literal|63
index|]
condition|)
name|flush1
argument_list|()
expr_stmt|;
operator|*
name|linp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|pfast
operator|==
literal|0
condition|)
block|{
name|fgoto
argument_list|()
expr_stmt|;
name|flush1
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|flush
argument_list|()
end_macro

begin_block
block|{
name|flush1
argument_list|()
expr_stmt|;
name|flush2
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|flush1
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
operator|*
name|linp
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|lp
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|lp
operator|++
condition|)
block|{
case|case
literal|'\r'
case|:
name|destline
operator|=
operator|+
name|destcol
operator|/
name|COLUMNS
expr_stmt|;
name|destcol
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'\013'
case|:
name|destline
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'\b'
case|:
if|if
condition|(
name|value
argument_list|(
name|PRINTALL
argument_list|)
condition|)
goto|goto
name|printit
goto|;
if|if
condition|(
name|destcol
condition|)
name|destcol
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'\032'
case|:
if|if
condition|(
name|CLEAR
condition|)
block|{
name|putS
argument_list|(
name|CLEAR
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
name|outline
operator|=
literal|0
expr_stmt|;
name|destcol
operator|=
literal|0
expr_stmt|;
name|destline
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
case|case
literal|' '
case|:
if|if
condition|(
name|value
argument_list|(
name|PRINTALL
argument_list|)
condition|)
goto|goto
name|printit
goto|;
name|destcol
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
if|if
condition|(
name|value
argument_list|(
name|PRINTALL
argument_list|)
condition|)
goto|goto
name|printit
goto|;
name|destcol
operator|=
operator|+
literal|8
expr_stmt|;
name|destcol
operator|=
operator|&
operator|~
literal|7
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
name|destline
operator|=
operator|+
name|destcol
operator|/
name|COLUMNS
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|destcol
operator|!=
literal|0
operator|&&
name|destcol
operator|%
name|COLUMNS
operator|==
literal|0
condition|)
name|destline
operator|--
expr_stmt|;
name|destcol
operator|=
literal|0
expr_stmt|;
continue|continue;
default|default:
name|printit
label|:
name|fgoto
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|AM
operator|==
literal|0
operator|&&
name|outcol
operator|==
name|COLUMNS
condition|)
name|fgoto
argument_list|()
expr_stmt|;
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
name|outcol
operator|--
expr_stmt|;
name|destcol
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|!=
literal|0177
condition|)
block|{
name|outcol
operator|++
expr_stmt|;
name|destcol
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|' '
condition|)
break|break;
block|}
operator|--
name|lp
expr_stmt|;
continue|continue;
block|}
name|linp
operator|=
name|line
expr_stmt|;
block|}
end_block

begin_macro
name|putS
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
return|return;
while|while
condition|(
operator|*
name|cp
condition|)
name|putch
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|flush2
argument_list|()
end_macro

begin_block
block|{
name|fgoto
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|pstop
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Goto destline, destcol from outline, outcol.  * We must be cognizant of the capabilities of the terminal  * and (if its a crt) the possibly finite size of its screen.  * The following capability variables are considered:  *  *	NOCR	if true, can't CR  *	BS	if true, can BS  *	CA	if true, can cursor address  *	NDSPACE	non-destructive space sequence (cursor right)  *	UPLINE	up line sequence (reverse line-feed)  *	AM	if true, terminal has automatic return at right margin  */
end_comment

begin_macro
name|fgoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|,
name|c
decl_stmt|;
comment|/* 	 * Adjust the destination column to be 	 * non-virtual by performing line folding. 	 */
if|if
condition|(
name|destcol
operator|>
name|COLUMNS
operator|-
literal|1
condition|)
block|{
name|destline
operator|=
operator|+
name|destcol
operator|/
name|COLUMNS
expr_stmt|;
name|destcol
operator|=
operator|%
name|COLUMNS
expr_stmt|;
block|}
if|if
condition|(
name|outcol
operator|>
name|COLUMNS
operator|-
literal|1
condition|)
block|{
name|l
operator|=
operator|(
name|outcol
operator|+
literal|1
operator|)
operator|/
name|COLUMNS
expr_stmt|;
name|outline
operator|=
operator|+
name|l
expr_stmt|;
name|outcol
operator|=
operator|%
name|COLUMNS
expr_stmt|;
if|if
condition|(
name|AM
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Software automatic margins 			 */
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfast
condition|)
name|putch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|l
operator|--
expr_stmt|;
block|}
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Outline has to be a real line... 		 * rounding outline and destline down corresponds 		 * to "rolling" the screen up. 		 */
if|if
condition|(
name|outline
operator|>
name|LINES
operator|-
literal|1
condition|)
block|{
name|destline
operator|=
operator|-
name|outline
operator|-
operator|(
name|LINES
operator|-
literal|1
operator|)
expr_stmt|;
name|outline
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If destination line is off the screen 	 * provide an appropriate "on screen" target, 	 * call ourselves recursively to get it, 	 * and then roll the screen up. 	 */
if|if
condition|(
name|destline
operator|>
name|LINES
operator|-
literal|1
condition|)
block|{
name|l
operator|=
name|destline
expr_stmt|;
name|destline
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|outline
operator|<
name|LINES
operator|-
literal|1
condition|)
block|{
name|c
operator|=
name|destcol
expr_stmt|;
if|if
condition|(
name|pfast
operator|==
literal|0
operator|&&
operator|!
name|CA
condition|)
name|destcol
operator|=
literal|0
expr_stmt|;
name|fgoto
argument_list|()
expr_stmt|;
name|destcol
operator|=
name|c
expr_stmt|;
block|}
while|while
condition|(
name|l
operator|>
name|LINES
operator|-
literal|1
condition|)
block|{
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|l
operator|--
expr_stmt|;
if|if
condition|(
name|pfast
operator|==
literal|0
condition|)
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|destline
operator|<
name|outline
operator|&&
operator|!
operator|(
name|CA
operator|||
name|UPLINE
operator|)
condition|)
comment|/* 		 * If can't CA or UPLINE 		 * we have no hope of reducing outline. 		 */
name|destline
operator|=
name|outline
expr_stmt|;
comment|/* 	 * Try to do the move with very local cursor motions, 	 * perhaps using a carriage return to move to 	 * the left margin. 	 */
if|if
condition|(
name|motion
argument_list|()
condition|)
return|return;
if|if
condition|(
name|CA
operator|&&
operator|!
name|value
argument_list|(
name|PRINTALL
argument_list|)
condition|)
block|{
name|putS
argument_list|(
name|cgoto
argument_list|()
argument_list|)
expr_stmt|;
name|outline
operator|=
name|destline
expr_stmt|;
name|outcol
operator|=
name|destcol
expr_stmt|;
block|}
else|else
name|plod
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setcol
argument_list|(
argument|col
argument_list|)
end_macro

begin_decl_stmt
name|int
name|col
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|del
decl_stmt|;
name|flush1
argument_list|()
expr_stmt|;
name|del
operator|=
name|col
operator|-
name|outcol
expr_stmt|;
name|destcol
operator|=
name|col
expr_stmt|;
if|if
condition|(
name|destcol
operator|<
literal|0
condition|)
name|destcol
operator|=
literal|0
expr_stmt|;
comment|/* off the line may not work on 3a here */
name|fgoto
argument_list|()
expr_stmt|;
comment|/* 	 * ADM3A special - fix tabs 	 */
if|if
condition|(
name|TTY
operator|==
literal|'ca'
operator|&&
operator|(
name|del
operator|<=
operator|-
literal|4
operator|||
name|del
operator|>=
literal|4
operator|)
condition|)
block|{
name|del
operator|=
operator|-
literal|3
expr_stmt|;
name|del
operator|=
operator|&
literal|07
expr_stmt|;
if|if
condition|(
name|del
operator|<
literal|0
condition|)
name|del
operator|=
operator|+
literal|8
expr_stmt|;
while|while
condition|(
name|del
operator|>
literal|0
condition|)
block|{
comment|/* 			 * A tip of the hatlo hat here too! 			 */
name|putch
argument_list|(
literal|'\033'
argument_list|)
expr_stmt|;
name|putch
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
name|del
operator|--
expr_stmt|;
block|}
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * v is vertical distance, then cost with cr  * h is horizontal distance, then direct move cost  */
end_comment

begin_macro
name|motion
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|v
decl_stmt|,
name|h
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|BS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|v
operator|=
name|destline
operator|-
name|outline
expr_stmt|;
if|if
condition|(
name|v
operator|<
literal|0
condition|)
if|if
condition|(
name|CA
operator|||
name|UPLINE
condition|)
name|v
operator|=
operator|-
name|v
expr_stmt|;
else|else
name|destline
operator|=
name|outline
expr_stmt|;
name|h
operator|=
name|destcol
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|||
name|pfast
condition|)
block|{
name|h
operator|=
operator|-
name|outcol
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|h
operator|=
operator|-
name|h
expr_stmt|;
block|}
name|h
operator|=
operator|+
name|v
expr_stmt|;
if|if
condition|(
name|pfast
operator|||
operator|!
name|NOCR
condition|)
block|{
if|if
condition|(
name|outcol
condition|)
name|v
operator|++
expr_stmt|;
name|v
operator|=
operator|+
name|destcol
expr_stmt|;
block|}
else|else
name|v
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|v
operator|>=
literal|4
operator|&&
name|h
operator|>=
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|plod
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|plod
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
name|outline
operator|<
name|destline
condition|)
block|{
name|outline
operator|++
expr_stmt|;
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOCR
operator|||
name|pfast
operator|==
literal|0
condition|)
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NOCR
operator|&&
operator|(
name|outcol
operator|-
name|destcol
operator|>
name|destcol
operator|+
literal|1
operator|||
name|outcol
operator|>
name|destcol
operator|&&
operator|!
name|BS
operator|)
condition|)
block|{
name|putch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|outcol
operator|>
name|destcol
condition|)
block|{
name|outcol
operator|--
expr_stmt|;
name|putch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|outline
operator|>
name|destline
condition|)
block|{
name|outline
operator|--
expr_stmt|;
name|putS
argument_list|(
name|UPLINE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CA
operator|&&
name|PT
condition|)
while|while
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
name|outcol
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
operator|<
name|destcol
condition|)
block|{
name|putch
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|outcol
operator|=
name|i
expr_stmt|;
block|}
while|while
condition|(
name|outcol
operator|<
name|destcol
condition|)
block|{
if|if
condition|(
name|inopen
condition|)
block|{
if|if
condition|(
operator|!
name|NDSPACE
condition|)
block|{
comment|/* 				 * What a feat of engineering! 				 * A terminal with cursor addressibility 				 * but no cursor move 1 char right sequence! 				 */
name|putS
argument_list|(
name|cgoto
argument_list|()
argument_list|)
expr_stmt|;
name|outcol
operator|=
name|destcol
expr_stmt|;
return|return;
block|}
name|putS
argument_list|(
name|NDSPACE
argument_list|)
expr_stmt|;
block|}
else|else
name|putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|partinp
argument_list|()
end_macro

begin_block
block|{
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|noteinp
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|noteinp
argument_list|()
end_macro

begin_block
block|{
name|outline
operator|++
expr_stmt|;
if|if
condition|(
name|outline
operator|>
name|LINES
operator|-
literal|1
condition|)
name|outline
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
name|destline
operator|=
name|outline
expr_stmt|;
name|destcol
operator|=
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|notech
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outcol
operator|=
operator|+
name|i
expr_stmt|;
name|destcol
operator|=
operator|+
name|i
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|ECHO
value|010
end_define

begin_define
define|#
directive|define
name|CRLF
value|020
end_define

begin_macro
name|pstart
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|NOCR
operator|||
operator|!
name|value
argument_list|(
name|OPTIMIZE
argument_list|)
operator|||
name|value
argument_list|(
name|PRINTALL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ruptible
operator|==
literal|0
condition|)
return|return;
name|fgoto
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
if|if
condition|(
name|pfast
condition|)
return|return;
name|pfast
operator|=
literal|1
expr_stmt|;
name|gTTY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|normtty
operator|=
literal|1
expr_stmt|;
name|normf
operator|=
name|tty
index|[
literal|2
index|]
expr_stmt|;
name|tty
index|[
literal|2
index|]
operator|=
operator|&
operator|~
operator|(
name|ECHO
operator||
name|CRLF
operator|)
expr_stmt|;
name|sTTY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pstop
argument_list|()
end_macro

begin_block
block|{
name|phadnl
operator|=
literal|0
expr_stmt|;
name|linp
operator|=
name|line
expr_stmt|;
name|draino
argument_list|()
expr_stmt|;
name|normal
argument_list|()
expr_stmt|;
if|if
condition|(
name|pfast
operator|!=
literal|1
condition|)
return|return;
name|pfast
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|termreset
argument_list|()
end_macro

begin_block
block|{
name|destcol
operator|=
literal|0
expr_stmt|;
name|destline
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|value
argument_list|(
name|PRINTALL
argument_list|)
condition|)
if|if
condition|(
name|CA
condition|)
block|{
name|outcol
operator|=
operator|-
literal|20
expr_stmt|;
name|outline
operator|=
operator|-
literal|20
expr_stmt|;
block|}
else|else
block|{
name|outcol
operator|=
name|destcol
expr_stmt|;
name|outline
operator|=
name|destline
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|draino
argument_list|()
end_macro

begin_block
block|{
name|obuf
operator|.
name|fildes
operator|=
literal|1
expr_stmt|;
name|obuf
operator|.
name|nunused
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|xfree
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|ostart
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|intty
condition|)
name|error
argument_list|(
literal|"Open and visual must be used interactively"
argument_list|)
expr_stmt|;
name|gTTY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|normtty
operator|=
literal|1
expr_stmt|;
name|normf
operator|=
name|tty
index|[
literal|2
index|]
expr_stmt|;
name|tty
index|[
literal|2
index|]
operator|=
operator|(
name|tty
index|[
literal|2
index|]
operator|&
operator|~
operator|(
name|ECHO
operator||
name|CRLF
operator|)
operator|)
operator||
name|RAW
expr_stmt|;
name|sTTY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pfast
operator|=
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|ostop
argument_list|()
end_macro

begin_block
block|{
name|pfast
operator|=
literal|0
expr_stmt|;
name|normal
argument_list|()
expr_stmt|;
name|termreset
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|flusho
argument_list|()
end_macro

begin_block
block|{
name|fflush
argument_list|(
operator|&
name|obuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putnl
argument_list|()
end_macro

begin_block
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gTTY
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|gtty
argument_list|(
name|i
argument_list|,
name|tty
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sTTY
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|stty
argument_list|(
name|i
argument_list|,
name|tty
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putch
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|putc
argument_list|(
name|c
argument_list|,
operator|&
name|obuf
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

