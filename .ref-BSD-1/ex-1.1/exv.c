begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_comment
comment|/*  * Ex - a text editor  * Bill Joy UCB June 1977  */
end_comment

begin_macro
name|vop
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|VISUAL
name|error
argument_list|(
literal|"No visual in this version"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VISUAL
end_ifdef

begin_decl_stmt
specifier|register
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|atube
index|[
name|TUBESIZE
operator|+
name|LBSIZE
index|]
decl_stmt|,
modifier|*
name|ic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lines
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|CA
condition|)
name|error
argument_list|(
literal|"Visual requires addressible cursor"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|CLEAR
condition|)
name|error
argument_list|(
literal|"Visual requires clear screen capability"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|value
argument_list|(
name|OPEN
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't use visual mode unless open option is set"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|VLINES
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vok
argument_list|(
name|atube
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|visual
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VCOLUMNS
operator|=
name|COLUMNS
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setdot
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|addr2
operator|==
name|zero
operator|&&
name|dol
operator|>
name|zero
condition|)
name|addr1
operator|=
name|one
operator|,
name|addr2
operator|=
name|one
expr_stmt|;
end_if

begin_expr_stmt
name|nonzero
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
if|if
condition|(
name|addr2
operator|==
name|one
condition|)
name|error
argument_list|(
literal|"At TOP|At top-of-file"
argument_list|)
expr_stmt|;
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
name|vch
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|addr2
operator|==
name|dol
condition|)
name|error
argument_list|(
literal|"At EOF|At end-of-file"
argument_list|)
expr_stmt|;
name|addr2
operator|++
expr_stmt|;
name|vch
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|vch
operator|=
literal|0
expr_stmt|;
break|break;
block|}
end_switch

begin_expr_stmt
name|skipwh
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZERO
operator|=
name|VLINES
operator|-
operator|(
name|digit
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|?
name|getnum
argument_list|()
else|:
name|value
argument_list|(
name|WINDOW
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ZERO
operator|>=
name|VLINES
condition|)
name|ZERO
operator|=
name|VLINES
operator|-
literal|1
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ZERO
operator|<
literal|0
condition|)
name|ZERO
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Outchar
operator|=
operator|&
name|vputchar
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|inglobal
condition|)
name|saveall
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|lines
operator|=
name|dol
operator|-
name|zero
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dot
operator|=
name|addr2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmoving
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|value
argument_list|(
name|VISUALMESSAGE
argument_list|)
operator|&&
name|TMODE
operator|&
literal|077
condition|)
block|{
name|chmod
argument_list|(
name|TTYNAM
argument_list|,
name|TMODE
operator|&
operator|~
literal|077
argument_list|)
expr_stmt|;
name|diddle
operator|++
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|ostart
argument_list|()
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
name|ic
operator|=
name|vinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcnt
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Can't fit any complete lines on screen"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|vmain
argument_list|(
name|ic
argument_list|)
operator|==
literal|1
condition|)
do|;
end_do

begin_expr_stmt
name|splitw
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vigoto
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|value
argument_list|(
name|PROMPT
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vclreol
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splitw
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ostop
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setoutt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|inopen
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|netchHAD
argument_list|(
name|lines
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|undiddle
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  vinit
operator|(
operator|)
block|{
specifier|register
name|int
operator|*
name|tp
block|;
specifier|register
name|int
name|voy
block|,
name|vny
block|;
name|char
operator|*
name|ic
block|;
name|int
name|nvc
block|;
name|vcook
argument_list|()
block|;
name|holdat
operator|=
literal|1
block|;
name|vclear
argument_list|()
block|;
name|getDOT
argument_list|()
block|;
switch|switch
condition|(
name|vch
condition|)
block|{
case|case
literal|'^'
case|:
name|dot
operator|=
name|vback
argument_list|(
operator|(
name|VLINES
operator|-
name|ZERO
operator|)
operator|-
name|vdepth
argument_list|()
argument_list|)
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
case|case
literal|'-'
case|:
name|tp
operator|=
name|vback
argument_list|(
operator|(
name|VLINES
operator|-
name|ZERO
operator|)
operator|-
name|vdepth
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|tp
operator|=
name|vback
argument_list|(
operator|(
name|VLINES
operator|-
name|ZERO
operator|)
operator|/
literal|2
operator|-
name|vdepth
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tp
operator|=
name|dot
expr_stmt|;
block|}
name|vcline
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vcnt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vny
operator|=
name|ZERO
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|tp
operator|<=
name|dol
condition|;
name|tp
operator|++
control|)
block|{
name|voy
operator|=
name|vny
expr_stmt|;
name|getline
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|dot
condition|)
block|{
name|nvc
operator|=
name|vcline
expr_stmt|;
name|ic
operator|=
name|vskipwh
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
name|vny
operator|=
name|voy
operator|+
name|vdepth
argument_list|()
expr_stmt|;
if|if
condition|(
name|vny
operator|>
name|VLINES
condition|)
break|break;
name|vopen
argument_list|(
name|tp
argument_list|,
name|voy
argument_list|)
expr_stmt|;
name|vcline
operator|++
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|vcline
operator|=
name|nvc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flusho
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|holdat
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vsync
argument_list|(
name|vlast
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vraw
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ic
operator|)
return|;
end_return

begin_expr_stmt
unit|}  vcook
operator|(
operator|)
block|{
name|gTTY
argument_list|(
literal|1
argument_list|)
block|;
name|tty
index|[
literal|2
index|]
operator|=
operator|&
operator|~
name|RAW
block|;
name|sTTY
argument_list|(
literal|1
argument_list|)
block|; }
name|vraw
argument_list|()
block|{
name|gTTY
argument_list|(
literal|1
argument_list|)
block|;
name|tty
index|[
literal|2
index|]
operator|=
operator||
name|RAW
block|;
name|sTTY
argument_list|(
literal|1
argument_list|)
block|; }
name|vok
argument_list|(
name|atube
argument_list|)
specifier|register
name|char
operator|*
name|atube
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|COLUMNS
operator|==
literal|1000
condition|)
name|error
argument_list|(
literal|"Don't know enough about your terminal to use %s"
argument_list|,
name|Command
argument_list|)
expr_stmt|;
if|if
condition|(
name|COLUMNS
operator|>
name|TUBECOLS
condition|)
name|error
argument_list|(
literal|"Terminal too wide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINES
operator|>
name|TUBELINES
operator|||
name|COLUMNS
operator|*
name|LINES
operator|>
name|TUBESIZE
condition|)
name|error
argument_list|(
literal|"Screen too large for my buffer"
argument_list|)
expr_stmt|;
name|vtube0
operator|=
name|atube
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TUBELINES
condition|;
name|i
operator|++
control|)
block|{
name|vtube
index|[
name|i
index|]
operator|=
name|atube
expr_stmt|;
name|atube
operator|=
operator|+
name|COLUMNS
expr_stmt|;
block|}
name|vutmp
operator|=
name|atube
expr_stmt|;
name|vundkind
operator|=
name|VNONE
expr_stmt|;
name|ZERO
operator|=
literal|0
expr_stmt|;
name|inopen
operator|=
literal|1
expr_stmt|;
name|vmoving
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
name|nextic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vSCROLL
operator|==
literal|0
condition|)
name|vSCROLL
operator|=
name|value
argument_list|(
name|SCROLL
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|undiddle
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|diddle
condition|)
name|chmod
argument_list|(
name|TTYNAM
argument_list|,
name|TMODE
argument_list|)
expr_stmt|;
name|diddle
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

