begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_decl_stmt
name|int
name|gimme
argument_list|()
decl_stmt|,
name|normal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|chngd
argument_list|()
decl_stmt|,
name|shift
argument_list|()
decl_stmt|,
name|doset
argument_list|()
decl_stmt|,
name|goodbye
argument_list|()
decl_stmt|,
name|await
argument_list|()
decl_stmt|,
name|dozip
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rewind
argument_list|()
decl_stmt|,
name|doalias
argument_list|()
decl_stmt|,
name|unalias
argument_list|()
decl_stmt|,
name|dotimes
argument_list|()
decl_stmt|,
name|doalloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dointerp
argument_list|()
decl_stmt|,
name|uninterp
argument_list|()
decl_stmt|,
name|noquit
argument_list|()
decl_stmt|,
name|quit
argument_list|()
decl_stmt|,
name|abort
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INF
value|127
end_define

begin_define
define|#
directive|define
name|FRET
value|1
end_define

begin_struct
specifier|static
struct|struct
name|biltins
block|{
name|char
modifier|*
name|bname
decl_stmt|;
name|int
function_decl|(
modifier|*
name|bfunct
function_decl|)
parameter_list|()
function_decl|;
name|char
name|minargs
decl_stmt|,
name|maxargs
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
name|bfunc
index|[]
block|{
literal|"chdir"
operator|,
operator|&
name|chngd
operator|,
literal|0
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"wait"
operator|,
operator|&
name|await
operator|,
literal|0
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"shift"
operator|,
operator|&
name|shift
operator|,
literal|0
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"rewind"
operator|,
operator|&
name|rewind
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"set"
operator|,
operator|&
name|doset
operator|,
literal|0
operator|,
name|INF
operator|,
literal|0
operator|,
literal|"unset"
operator|,
operator|&
name|unset
operator|,
literal|1
operator|,
name|INF
operator|,
literal|0
operator|,
literal|"alias"
operator|,
operator|&
name|doalias
operator|,
literal|0
operator|,
literal|2
operator|,
literal|0
operator|,
literal|"unalias"
operator|,
operator|&
name|unalias
operator|,
literal|1
operator|,
name|INF
operator|,
literal|0
operator|,
literal|"interp"
operator|,
operator|&
name|dointerp
operator|,
literal|0
operator|,
literal|2
operator|,
literal|0
operator|,
literal|"uninterp"
operator|,
operator|&
name|uninterp
operator|,
literal|1
operator|,
name|INF
operator|,
literal|0
operator|,
literal|"logout"
operator|,
operator|&
name|goodbye
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"quit"
operator|,
operator|&
name|quit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"noquit"
operator|,
operator|&
name|noquit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"alloc"
operator|,
operator|&
name|doalloc
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"abort"
operator|,
operator|&
name|abort
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|":"
operator|,
operator|&
name|dozip
operator|,
literal|0
operator|,
name|INF
operator|,
literal|0
operator|,
comment|/* "verbose" */
literal|"tyme"
operator|,
operator|&
name|dotimes
operator|,
literal|0
operator|,
name|INF
operator|,
name|FRET
operator|,
comment|/* "nohup" */
comment|/* "repeat" */
comment|/* "if" */
comment|/* "goto" */
comment|/* "exit" */
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bname
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|func
argument_list|(
name|t
argument_list|)
specifier|register
name|int
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|biltins
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bp
operator|=
name|bfunc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|bname
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bname
argument_list|,
name|t
index|[
name|DCOM
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|bp
operator|++
expr_stmt|;
block|}
name|bname
operator|=
name|bp
operator|->
name|bname
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|t
index|[
name|DCOM
operator|+
literal|1
index|]
init|;
operator|*
name|tp
condition|;
name|tp
operator|++
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|bp
operator|->
name|minargs
condition|)
block|{
name|bferr
argument_list|(
literal|": Too few arguments"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|>
name|bp
operator|->
name|maxargs
condition|)
block|{
name|bferr
argument_list|(
literal|": Too many arguments"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|i
operator|=
call|(
modifier|*
name|bp
operator|->
name|bfunct
call|)
argument_list|(
operator|&
name|t
index|[
name|DCOM
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|->
name|flags
operator|&
name|FRET
condition|?
name|i
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|noquit
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|QUIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|quit
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|QUIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|abort
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|dozip
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_expr_stmt
name|chngd
argument_list|(
name|vp
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|vp
operator|++
expr_stmt|;
name|dp
operator|=
operator|*
name|vp
operator|++
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
name|dp
operator|=
name|globone
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return;
block|}
else|else
block|{
name|dp
operator|=
name|value
argument_list|(
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|0
condition|)
block|{
name|bferr
argument_list|(
literal|": No home"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|chdir
argument_list|(
name|dp
argument_list|)
operator|<
literal|0
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTDIR
case|:
name|bferr2
argument_list|(
name|dp
argument_list|,
literal|": Not a directory"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ENOENT
case|:
name|bferr2
argument_list|(
name|dp
argument_list|,
literal|": No such file or directory"
argument_list|)
expr_stmt|;
return|return;
case|case
name|EACCES
case|:
name|bferr2
argument_list|(
name|dp
argument_list|,
literal|": No execute access"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|prs
argument_list|(
literal|"errno = "
argument_list|)
expr_stmt|;
name|prn
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bferr2
argument_list|(
name|dp
argument_list|,
literal|": bad directory !?!"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_macro
name|prvars
argument_list|()
end_macro

begin_block
block|{
name|plist
argument_list|(
operator|&
name|shvhed
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prvars() { 	register struct shvar *vp; 	register char *cp; 	register int col;  	vp = shvhed.next; 	if (vp == 0) 		return; 	col = 0; 	cp = unquote(vp->value); 	for(;;) { 		prs(vp->name); 		col =+ strlen(vp->name); 		if (cp[0]) { 			prs("="); 			prs(cp); 			col =+ strlen(cp) + 1; 		} 		xfree(cp); 		col++; 		vp = vp->next; 		if (vp == 0) 			break; 		cp = unquote(vp->value); 		if (col + strlen(vp->name) + strlen(cp) + 1> 79) { 			prs("\n"); 			col = 0; 		} else 			prs(" "); 	} 	if (col) 		prs("\n"); } */
end_comment

begin_macro
name|unquote
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|s2
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
operator|(
operator|*
name|cp
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|&&
operator|(
name|c
operator|&
name|QUOTE
operator|)
condition|)
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|s2
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|s2
operator|,
name|cp
operator|=
name|s
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
operator|(
operator|*
name|cp
operator|&
name|QUOTE
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|dp
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|&&
operator|(
name|c
operator|&
name|QUOTE
operator|)
condition|)
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
return|return
operator|(
name|s2
operator|)
return|;
block|}
end_block

begin_macro
name|setname
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bname
operator|=
name|cp
expr_stmt|;
block|}
end_block

begin_macro
name|bferr
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prs
argument_list|(
name|bname
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bferr2
argument_list|(
argument|cp
argument_list|,
argument|cp2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doalias
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
name|v
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar
modifier|*
name|vp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|v
operator|++
expr_stmt|;
name|p
operator|=
operator|*
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|plist
argument_list|(
operator|&
name|aliases
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|value1
argument_list|(
name|p
argument_list|,
operator|&
name|aliases
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|set1
argument_list|(
name|p
argument_list|,
name|savestr
argument_list|(
operator|*
name|v
argument_list|)
argument_list|,
operator|&
name|aliases
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|unalias
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
name|v
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unset1
argument_list|(
name|v
argument_list|,
operator|&
name|aliases
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|dointerp
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
name|v
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|v
operator|++
expr_stmt|;
name|p
operator|=
operator|*
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|plist
argument_list|(
operator|&
name|interps
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|v
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|value1
argument_list|(
name|p
argument_list|,
operator|&
name|interps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|i
operator|=
name|getn
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return;
name|set1
argument_list|(
name|p
argument_list|,
name|savestr
argument_list|(
operator|*
name|v
argument_list|)
argument_list|,
operator|&
name|interps
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|uninterp
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
name|v
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unset1
argument_list|(
name|v
argument_list|,
operator|&
name|interps
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|interp
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|int
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar
modifier|*
name|vp
decl_stmt|;
for|for
control|(
name|vp
operator|=
name|interps
operator|.
name|next
init|;
name|vp
operator|!=
literal|0
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
if|if
condition|(
name|getn
argument_list|(
name|vp
operator|->
name|name
argument_list|)
operator|==
name|w
condition|)
return|return
operator|(
name|vp
operator|->
name|value
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|plist
argument_list|(
name|vp
argument_list|)
specifier|register
expr|struct
name|shvar
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|vp
operator|=
name|vp
operator|->
name|next
init|;
name|vp
operator|!=
literal|0
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
name|prs
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|value
index|[
literal|0
index|]
condition|)
block|{
name|cp
operator|=
name|unquote
argument_list|(
name|vp
operator|->
name|value
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|alias
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|aliases
operator|.
name|next
init|;
name|ap
operator|!=
literal|0
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ap
operator|->
name|name
argument_list|,
operator|*
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|value
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|bferr2
argument_list|(
operator|*
name|t
argument_list|,
literal|": Restricted"
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
literal|":"
expr_stmt|;
block|}
else|else
operator|*
name|t
operator|=
name|savestr
argument_list|(
name|ap
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|char
name|end
index|[]
decl_stmt|;
end_decl_stmt

begin_macro
name|doalloc
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|prn
argument_list|(
name|cp
operator|-
operator|&
name|end
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

