begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_comment
comment|/*  * Shell:  *	Lexical and argument processing routines  *  *	lex   - driver for lexical analysis  *	word  - reads next word into line and pointer thereto via args  *	getc  - gets a character from the logical input stream  *	readc - reads a character from the 'input device'  *	setargs - sets up the parameter variables initially  *	rewind - backs up the shell arguments to their original values  *	setnargs - resets nargs variable after changes to arg list  *	shift - manipulates the shell parameters  */
end_comment

begin_function_decl
name|struct
name|shvar2
modifier|*
name|word
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * lex is the driver routine for the lexical input of the shell.  * Basic strategy is to read a logical line into linebuf  * with successive words pointed to by successive elements of args.  * Termination condition is a newline.  * Returns a pointer to a linked list of the words.  */
end_comment

begin_expr_stmt
name|lex
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|shvar2
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar2
modifier|*
name|wdp
decl_stmt|;
name|wdp
operator|=
name|hp
expr_stmt|;
do|do
block|{
name|wdp
operator|->
name|next
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|wdp
argument_list|)
expr_stmt|;
name|wdp
operator|->
name|next
operator|->
name|prev
operator|=
name|wdp
expr_stmt|;
name|wdp
operator|=
name|wdp
operator|->
name|next
expr_stmt|;
name|wdp
operator|->
name|value
operator|=
name|word
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|wdp
operator|->
name|value
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
do|;
name|hp
operator|->
name|prev
operator|=
name|wdp
expr_stmt|;
name|wdp
operator|->
name|next
operator|=
name|hp
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|freelex
argument_list|(
name|vp
argument_list|)
specifier|register
expr|struct
name|shvar
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar
modifier|*
name|fp
decl_stmt|;
while|while
condition|(
name|vp
operator|->
name|next
operator|!=
name|vp
condition|)
block|{
name|fp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
name|vp
operator|->
name|next
operator|=
name|fp
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|fp
operator|->
name|value
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|prev
operator|=
name|vp
expr_stmt|;
block|}
end_block

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|char
name|peekc
decl_stmt|,
name|peekx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * word breaks the input character stream into words.  * Blanks and tabs in the input are ignored, the characters  *&;<>()|^ and \n  * are considered to be separators.  * Characters may be escaped here by surrounding them with  * 's or "s.  This causes the QUOTE (high order) bit of the  * corresponding character to be set so the character will  * fail subsequent comparisons.  The quoting is eventually  * stripped off.  More quoting by QUOTE is also done in readc.  * Note importantly that quoted character strings do not undergo  * parameter substitution!  * Return value is a pointer to a structure containing the word.  */
end_comment

begin_function
name|struct
name|shvar2
modifier|*
name|word
parameter_list|()
block|{
specifier|register
name|c
expr_stmt|;
name|char
name|c1
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
name|char
name|lbuf
index|[
literal|514
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lp
operator|=
name|lbuf
expr_stmt|;
name|i
operator|=
literal|512
expr_stmt|;
comment|/* 	 * Loop to get something solid 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
name|c1
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|echo
argument_list|(
name|readc
argument_list|()
argument_list|)
operator|)
operator|!=
name|c1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|seterr
argument_list|(
literal|"Unmatched ' or \""
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
name|peekc
operator|=
name|c
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
operator|--
name|i
operator|==
literal|0
condition|)
goto|goto
name|toochars
goto|;
operator|*
name|lp
operator|++
operator|=
name|c
operator||
name|QUOTE
expr_stmt|;
block|}
break|break;
case|case
literal|'&'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'|'
case|:
case|case
literal|'^'
case|:
case|case
literal|'\n'
case|:
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|ret
goto|;
default|default:
name|peekc
operator|=
name|c
expr_stmt|;
break|break;
block|}
comment|/* 		 * We have discovered something solid (not a separator). 		 * We want to gather in as many characters 		 * as possible but don't want to grab a separator. 		 * If we find another quotation in this word we go back to 		 * the top to take it. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|()
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
name|c
argument_list|,
literal|" '\"\t;&<>()|^\n"
argument_list|)
condition|)
block|{
name|peekc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
name|c
argument_list|,
literal|"\"'"
argument_list|)
condition|)
break|break;
operator|*
name|lp
operator|++
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
operator|--
name|i
operator|==
literal|0
condition|)
goto|goto
name|toochars
goto|;
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
name|toochars
label|:
name|seterr
argument_list|(
literal|"Too many characters"
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ret
label|:
return|return
operator|(
name|savestr
argument_list|(
name|lbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dolp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|struct
name|shvar2
name|paramhd
decl_stmt|,
modifier|*
name|paramp
decl_stmt|,
modifier|*
name|dolnxt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|int
name|dolc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * setargs sets up the initial argument linked list.  * paramp is a working pointer to the front of the list (actually  * one before the front), paramhd the actual origin which contains  * the true value of $0.  *  * dolnxt is used in expanding $*.  * dolc is maintained by setnargs who also maintains the nargs variable  * dolp is the pointer into the expanding string in getc  */
end_comment

begin_macro
name|setargs
argument_list|(
argument|c
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|v
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar2
modifier|*
name|vp
decl_stmt|,
modifier|*
name|lvp
decl_stmt|;
name|vp
operator|=
operator|&
name|paramhd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|vp
operator|->
name|value
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|lvp
operator|=
name|vp
expr_stmt|;
name|vp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|vp
argument_list|)
expr_stmt|;
name|lvp
operator|->
name|next
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|prev
operator|=
name|lvp
expr_stmt|;
block|}
name|rewind
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * rewind the shell arguments  */
end_comment

begin_macro
name|rewind
argument_list|()
end_macro

begin_block
block|{
name|paramp
operator|=
operator|&
name|paramhd
expr_stmt|;
name|setnargs
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * set up nargs variable after a parameter list change  */
end_comment

begin_macro
name|setnargs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|shvar2
modifier|*
name|vp
decl_stmt|;
name|dolc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|paramp
init|;
name|vp
operator|!=
literal|0
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
name|dolc
operator|++
expr_stmt|;
name|set
argument_list|(
name|n_args
argument_list|,
name|putn
argument_list|(
name|dolc
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolc
operator|==
literal|1
condition|)
name|unsetv
argument_list|(
name|n_args
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * shift the shell arguments  */
end_comment

begin_expr_stmt
name|shift
argument_list|(
name|v
argument_list|)
specifier|register
name|char
operator|*
name|v
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|shvar2
modifier|*
name|vp
decl_stmt|;
name|v
operator|++
expr_stmt|;
name|n
operator|=
operator|*
name|v
operator|==
literal|0
condition|?
literal|1
else|:
name|getn
argument_list|(
operator|*
name|v
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|paramp
init|;
name|vp
operator|&&
name|n
condition|;
control|)
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|n
operator|--
expr_stmt|;
name|vp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|n
operator|++
expr_stmt|;
name|vp
operator|=
name|vp
operator|->
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|||
name|vp
operator|==
literal|0
condition|)
block|{
name|bferr
argument_list|(
literal|": Count too large"
argument_list|)
expr_stmt|;
return|return;
block|}
name|paramp
operator|=
name|vp
expr_stmt|;
name|setnargs
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
name|char
name|dol2bra
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * getc gets a character from the logical input stream.  * It handles parameter expansion via $[0-9], all parameters  * via $*, shell variables via $[A-Za-z], and the process number via $$.  * Also handled is the trimming of the sufficies from expanded  * names via the . notation.  For example if $1 is "foo.p" then  * $.1 will be "foo".  *  * The variable dol2bra's value has the following meaning:  *  *	2	echo characters to : or }, if : discard chars to }  *	1	echo characters to :  *     -1	discard characters to }  *     -2	discard characters to : or }, if : echo to }  *  * This handles the constructs  *  *	${name?str1:str2}	name set -> str1 ; t -> str2  *	${name:default}		name set -> $name ; t -> default  *	${name?string}		name set -> strings ; t -> ""  */
end_comment

begin_macro
name|getc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|static
name|char
name|doldot
decl_stmt|;
if|if
condition|(
name|peekc
condition|)
block|{
name|c
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dolp
condition|)
block|{
name|c
operator|=
operator|*
name|dolp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|(
name|c
operator|!=
literal|'.'
operator|||
operator|!
name|doldot
operator|||
name|any
argument_list|(
literal|'.'
argument_list|,
name|dolp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|echo
argument_list|(
name|c
argument_list|)
operator|)
return|;
if|if
condition|(
name|dolnxt
operator|&&
operator|(
name|dolnxt
operator|=
name|dolnxt
operator|->
name|next
operator|)
condition|)
block|{
name|dolp
operator|=
name|dolnxt
operator|->
name|value
expr_stmt|;
return|return
operator|(
name|echo
argument_list|(
literal|' '
argument_list|)
operator|)
return|;
block|}
name|dolp
operator|=
literal|0
expr_stmt|;
name|echo
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|peekx
condition|)
block|{
name|c
operator|=
name|peekx
expr_stmt|;
name|peekx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
else|else
name|c
operator|=
operator||
name|QUOTE
expr_stmt|;
block|}
if|if
condition|(
name|dol2bra
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'}'
case|:
if|if
condition|(
name|dol2bra
operator|>
literal|0
condition|)
name|echo
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|dol2bra
operator|=
literal|0
expr_stmt|;
name|echo
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
name|dol2bra
operator|=
literal|0
expr_stmt|;
name|seterr
argument_list|(
literal|"Missing }"
argument_list|)
expr_stmt|;
return|return
operator|(
name|echo
argument_list|(
literal|'\n'
argument_list|)
operator|)
return|;
case|case
literal|':'
case|:
switch|switch
condition|(
name|dol2bra
condition|)
block|{
case|case
literal|2
case|:
name|dol2bra
operator|=
operator|-
literal|1
expr_stmt|;
name|echo
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|echo
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
continue|continue;
case|case
operator|-
literal|2
case|:
name|dol2bra
operator|=
literal|1
expr_stmt|;
name|echo
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|echo
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
continue|continue;
block|}
default|default:
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dol2bra
operator|<
literal|0
condition|)
continue|continue;
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|doldot
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|doldot
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|dolp
operator|=
name|rgadrof
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolp
operator|==
literal|0
condition|)
continue|continue;
name|dolp
operator|=
name|dolp
operator|->
name|value
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|letter
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|dolp
operator|=
name|dolvbl
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolp
operator|||
name|dol2bra
operator|>
literal|0
condition|)
break|break;
continue|continue;
block|}
return|return
operator|(
name|c
operator|&
literal|0177
operator|)
return|;
case|case
literal|'$'
case|:
name|dolp
operator|=
name|value
argument_list|(
name|pid
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|dolc
operator|<=
literal|1
condition|)
break|break;
name|dolnxt
operator|=
name|paramp
operator|->
name|next
expr_stmt|;
name|dolp
operator|=
name|dolnxt
operator|->
name|value
expr_stmt|;
break|break;
block|}
name|echo
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|dolvbl
argument_list|(
argument|sc
argument_list|)
end_macro

begin_decl_stmt
name|char
name|sc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|shvar
modifier|*
name|vp
decl_stmt|;
name|char
name|name
index|[
literal|20
index|]
decl_stmt|,
name|c
decl_stmt|;
name|np
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
literal|'{'
condition|)
operator|*
name|np
operator|++
operator|=
name|sc
expr_stmt|;
for|for
control|(
name|c
operator|=
name|readc
argument_list|()
init|;
name|letter
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
name|readc
argument_list|()
control|)
if|if
condition|(
name|np
operator|<
operator|&
name|name
index|[
sizeof|sizeof
name|name
operator|-
literal|1
index|]
condition|)
block|{
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|np
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|np
operator|++
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|adrof
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
literal|'{'
condition|)
name|peekx
operator|=
name|c
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
if|if
condition|(
name|vp
condition|)
name|dol2bra
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|dol2bra
operator|=
operator|-
literal|2
expr_stmt|;
name|peekx
operator|=
literal|':'
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|peekx
operator|=
name|c
expr_stmt|;
name|dol2bra
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|echo
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
name|dol2bra
operator|=
literal|2
expr_stmt|;
else|else
name|dol2bra
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|echo
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|seterr
argument_list|(
literal|"Variable syntax"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vp
operator|==
literal|0
condition|)
block|{
name|seterr
argument_list|(
literal|"Undefined variable"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|vp
operator|->
name|value
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * read a character from the input device.  * this may be an argument e.g. for sh -c.  * also for sh -t stop after one line.  */
end_comment

begin_macro
name|readc
argument_list|()
end_macro

begin_block
block|{
name|char
name|cc
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|again
label|:
if|if
condition|(
name|arginp
condition|)
block|{
if|if
condition|(
name|arginp
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|arginp
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|arginp
operator|=
literal|1
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|onelflg
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|doneinp
operator|=
literal|1
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|cc
operator|)
operator|==
literal|'\n'
operator|&&
name|onelflg
condition|)
name|onelflg
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
goto|goto
name|again
goto|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rgadrof
argument_list|(
name|r
argument_list|)
specifier|register
name|int
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|digit
argument_list|(
name|r
argument_list|)
operator|||
operator|(
name|r
operator|=
operator|-
literal|'0'
operator|)
operator|>
name|dolc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
name|paramhd
operator|)
return|;
for|for
control|(
name|tp
operator|=
name|paramp
init|;
name|r
operator|>
literal|0
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
name|r
operator|--
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_block

begin_macro
name|rgvalue
argument_list|(
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|int
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shvar
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|rgadrof
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
condition|?
name|tp
operator|->
name|value
else|:
literal|""
operator|)
return|;
block|}
end_block

end_unit

