begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * Rout - rout out the shit in /tmp  * Bill Joy UCB October 12, 1977  */
end_comment

begin_comment
comment|/* Current definition of shit is anything not accessed for 3 hours */
end_comment

begin_define
define|#
directive|define
name|SHITTIME
value|60 * 60 * 3
end_define

begin_function
name|main
parameter_list|()
block|{
struct|struct
block|{
name|int
name|inum
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
block|}
name|dirent
struct|;
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
name|long
name|tvec
decl_stmt|;
struct|struct
block|{
name|char
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|int
name|inumber
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
name|nlinks
decl_stmt|;
name|char
name|uid
decl_stmt|,
name|gid
decl_stmt|;
name|char
name|size0
decl_stmt|;
name|int
name|size1
decl_stmt|;
name|int
name|addr
index|[
literal|8
index|]
decl_stmt|;
name|long
name|actime
decl_stmt|,
name|modtime
decl_stmt|;
block|}
name|stbuff
struct|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/tmp"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|open
argument_list|(
literal|"."
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|tvec
argument_list|)
expr_stmt|;
name|dirent
operator|.
name|name
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|dirent
argument_list|,
sizeof|sizeof
name|dirent
operator|-
literal|2
argument_list|)
operator|==
sizeof|sizeof
name|dirent
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|dirent
operator|.
name|inum
operator|==
literal|0
condition|)
continue|continue;
define|#
directive|define
name|eq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strcmp(a, b) == 0
if|if
condition|(
name|eq
argument_list|(
name|dirent
operator|.
name|name
argument_list|,
literal|"."
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|eq
argument_list|(
name|dirent
operator|.
name|name
argument_list|,
literal|".."
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|eq
argument_list|(
name|dirent
operator|.
name|name
argument_list|,
literal|".q"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|stat
argument_list|(
name|dirent
operator|.
name|name
argument_list|,
operator|&
name|stbuff
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|stbuff
operator|.
name|flags
operator|&
literal|060000
operator|)
operator|==
literal|040000
condition|)
continue|continue;
if|if
condition|(
name|tvec
operator|-
name|stbuff
operator|.
name|actime
operator|>=
name|SHITTIME
condition|)
block|{
name|psecs
argument_list|(
name|tvec
operator|-
name|stbuff
operator|.
name|actime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|dirent
operator|.
name|name
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|dirent
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|psecs
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|long
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|l
operator|/
literal|3600.0
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|p2dig
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|i
operator|=
name|l
operator|%
literal|3600
expr_stmt|;
name|p2dig
argument_list|(
name|i
operator|/
literal|60
argument_list|)
expr_stmt|;
goto|goto
name|minsec
goto|;
block|}
name|i
operator|=
name|l
expr_stmt|;
name|p2dig
argument_list|(
name|i
operator|/
literal|60
argument_list|)
expr_stmt|;
name|minsec
label|:
name|i
operator|=
operator|%
literal|60
expr_stmt|;
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|p2dig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2dig
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prn
argument_list|(
name|i
operator|/
literal|10
argument_list|)
expr_stmt|;
name|prn
argument_list|(
name|i
operator|%
literal|10
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prn
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|a
expr_stmt|;
name|a
operator|=
name|n
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|a
operator|!=
literal|0
condition|)
name|prn
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|putchar
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|strcmp
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
specifier|register
name|char
operator|*
name|cp
operator|,
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|cp
index|[
literal|0
index|]
operator|&&
name|dp
index|[
literal|0
index|]
operator|&&
operator|*
name|cp
operator|==
operator|*
name|dp
condition|)
name|cp
operator|++
operator|,
name|dp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
operator|&&
operator|*
name|dp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

