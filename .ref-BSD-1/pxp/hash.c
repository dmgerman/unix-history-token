begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  * Version 1.0 August 1977  *  *  * pxp - Pascal execution profiler  *  * Bill Joy UCB  * Version 1.0 August 1977  */
end_comment

begin_include
include|#
directive|include
file|"whoami"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_comment
comment|/*  * The definition for the segmented hash tables.  */
end_comment

begin_struct
struct|struct
name|ht
block|{
name|int
modifier|*
name|ht_low
decl_stmt|;
name|int
modifier|*
name|ht_high
decl_stmt|;
name|int
name|ht_used
decl_stmt|;
block|}
name|htab
index|[
name|MAXHASH
index|]
struct|;
end_struct

begin_comment
comment|/*  * This is the array of keywords and their  * token values, which are hashed into the table  * by inithash.  */
end_comment

begin_struct
struct|struct
name|kwtab
name|yykey
index|[]
block|{
literal|"and"
operator|,
name|YAND
operator|,
literal|"array"
operator|,
name|YARRAY
operator|,
literal|"assert"
operator|,
name|YASSERT
operator|,
literal|"begin"
operator|,
name|YBEGIN
operator|,
literal|"case"
operator|,
name|YCASE
operator|,
literal|"const"
operator|,
name|YCONST
operator|,
literal|"div"
operator|,
name|YDIV
operator|,
literal|"do"
operator|,
name|YDO
operator|,
literal|"downto"
operator|,
name|YDOWNTO
operator|,
literal|"else"
operator|,
name|YELSE
operator|,
literal|"end"
operator|,
name|YEND
operator|,
literal|"file"
operator|,
name|YFILE
operator|,
literal|"for"
operator|,
name|YFOR
operator|,
literal|"forward"
operator|,
name|YFORWARD
operator|,
literal|"function"
operator|,
name|YFUNCTION
operator|,
literal|"goto"
operator|,
name|YGOTO
operator|,
literal|"if"
operator|,
name|YIF
operator|,
literal|"in"
operator|,
name|YIN
operator|,
literal|"label"
operator|,
name|YLABEL
operator|,
literal|"mod"
operator|,
name|YMOD
operator|,
literal|"nil"
operator|,
name|YNIL
operator|,
literal|"not"
operator|,
name|YNOT
operator|,
literal|"of"
operator|,
name|YOF
operator|,
literal|"or"
operator|,
name|YOR
operator|,
literal|"packed"
operator|,
name|YPACKED
operator|,
literal|"procedure"
operator|,
name|YPROCEDURE
operator|,
literal|"program"
operator|,
name|YPROG
operator|,
literal|"record"
operator|,
name|YRECORD
operator|,
literal|"repeat"
operator|,
name|YREPEAT
operator|,
literal|"set"
operator|,
name|YSET
operator|,
literal|"then"
operator|,
name|YTHEN
operator|,
literal|"to"
operator|,
name|YTO
operator|,
literal|"type"
operator|,
name|YTYPE
operator|,
literal|"until"
operator|,
name|YUNTIL
operator|,
literal|"var"
operator|,
name|YVAR
operator|,
literal|"while"
operator|,
name|YWHILE
operator|,
literal|"with"
operator|,
name|YWITH
operator|,
literal|"oct"
operator|,
name|YOCT
operator|,
comment|/* non-standard Pascal */
literal|"hex"
operator|,
name|YHEX
operator|,
comment|/* non-standard Pascal */
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|lastkey
modifier|&
name|yykey
index|[
sizeof|sizeof
name|yykey
operator|/
sizeof|sizeof
name|yykey
index|[
literal|0
index|]
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Inithash initializes the hash table routines  * by allocating the first hash table segment using  * an already existing memory slot.  */
end_comment

begin_macro
name|inithash
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
specifier|static
name|int
name|hshtab
index|[
name|HASHINC
index|]
decl_stmt|;
name|htab
index|[
literal|0
index|]
operator|.
name|ht_low
operator|=
name|hshtab
expr_stmt|;
name|htab
index|[
literal|0
index|]
operator|.
name|ht_high
operator|=
operator|&
name|hshtab
index|[
name|HASHINC
index|]
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|yykey
init|;
operator|*
name|ip
condition|;
name|ip
operator|=
operator|+
literal|2
control|)
name|hash
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|=
name|ip
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Hash looks up the s(ymbol) argument  * in the string table, entering it if  * it is not found. If save is 0, then  * the argument string is already in  * a safe place. Otherwise, if hash is  * entering the symbol for the first time  * it will save the symbol in the string  * table using savestr.  */
end_comment

begin_function
name|int
modifier|*
name|hash
parameter_list|(
name|s
parameter_list|,
name|save
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|save
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|h
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
modifier|*
name|sym
decl_stmt|;
name|struct
name|ht
modifier|*
name|htp
decl_stmt|;
name|int
name|sh
decl_stmt|;
comment|/* 	 * The hash function is a modular hash of 	 * the sum of the characters with the sum 	 * doubled before each successive character 	 * is added. 	 */
name|cp
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|cp
operator|=
name|token
expr_stmt|;
comment|/* default symbol to be hashed */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|i
operator|=
name|i
operator|*
literal|2
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
name|sh
operator|=
operator|(
name|i
operator|&
literal|077777
operator|)
operator|%
name|HASHINC
expr_stmt|;
name|cp
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|cp
operator|=
name|token
expr_stmt|;
comment|/* 	 * There are as many as MAXHASH active 	 * hash tables at any given point in time. 	 * The search starts with the first table 	 * and continues through the active tables 	 * as necessary. 	 */
for|for
control|(
name|htp
operator|=
name|htab
init|;
name|htp
operator|<
operator|&
name|htab
index|[
name|MAXHASH
index|]
condition|;
name|htp
operator|++
control|)
block|{
if|if
condition|(
name|htp
operator|->
name|ht_low
operator|==
name|NIL
condition|)
block|{
name|cp
operator|=
name|calloc
argument_list|(
literal|2
argument_list|,
name|HASHINC
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|-
literal|1
condition|)
block|{
name|yerror
argument_list|(
literal|"Ran out of memory (hash)"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|htp
operator|->
name|ht_low
operator|=
name|cp
expr_stmt|;
name|htp
operator|->
name|ht_high
operator|=
name|htp
operator|->
name|ht_low
operator|+
name|HASHINC
expr_stmt|;
name|cp
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|cp
operator|=
name|token
expr_stmt|;
block|}
name|h
operator|=
name|htp
operator|->
name|ht_low
operator|+
name|sh
expr_stmt|;
comment|/* 		 * quadratic rehash increment 		 * starts at 1 and incremented 		 * by two each rehash. 		 */
name|i
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|h
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|htp
operator|->
name|ht_used
operator|>
operator|(
name|HASHINC
operator|*
literal|3
operator|)
operator|/
literal|4
condition|)
break|break;
name|htp
operator|->
name|ht_used
operator|++
expr_stmt|;
if|if
condition|(
name|save
operator|!=
literal|0
condition|)
block|{
operator|*
name|h
operator|=
name|savestr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|h
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
name|sym
operator|=
operator|*
name|h
expr_stmt|;
if|if
condition|(
name|sym
operator|<
name|lastkey
operator|&&
name|sym
operator|>=
name|yykey
condition|)
name|sym
operator|=
operator|*
name|sym
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|pchar
operator|==
operator|*
name|cp
operator|&&
name|strcmp
argument_list|(
name|sym
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|h
operator|)
return|;
name|h
operator|=
operator|+
name|i
expr_stmt|;
name|i
operator|=
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|h
operator|>=
name|htp
operator|->
name|ht_high
condition|)
name|h
operator|=
operator|-
name|HASHINC
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|HASHINC
condition|)
do|;
block|}
name|yerror
argument_list|(
literal|"Ran out of hash tables"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

