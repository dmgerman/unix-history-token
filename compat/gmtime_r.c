begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Taken from FreeBSD src / lib / libc / stdtime / localtime.c 1.43 revision.  * localtime.c 7.78.  * tzfile.h 1.8  * adapted to be replacement gmtime_r.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MONSPERYEAR
value|12
end_define

begin_define
define|#
directive|define
name|DAYSPERNYEAR
value|365
end_define

begin_define
define|#
directive|define
name|DAYSPERLYEAR
value|366
end_define

begin_define
define|#
directive|define
name|SECSPERMIN
value|60
end_define

begin_define
define|#
directive|define
name|SECSPERHOUR
value|(60*60)
end_define

begin_define
define|#
directive|define
name|SECSPERDAY
value|(24*60*60)
end_define

begin_define
define|#
directive|define
name|DAYSPERWEEK
value|7
end_define

begin_define
define|#
directive|define
name|TM_SUNDAY
value|0
end_define

begin_define
define|#
directive|define
name|TM_MONDAY
value|1
end_define

begin_define
define|#
directive|define
name|TM_TUESDAY
value|2
end_define

begin_define
define|#
directive|define
name|TM_WEDNESDAY
value|3
end_define

begin_define
define|#
directive|define
name|TM_THURSDAY
value|4
end_define

begin_define
define|#
directive|define
name|TM_FRIDAY
value|5
end_define

begin_define
define|#
directive|define
name|TM_SATURDAY
value|6
end_define

begin_define
define|#
directive|define
name|TM_YEAR_BASE
value|1900
end_define

begin_define
define|#
directive|define
name|EPOCH_YEAR
value|1970
end_define

begin_define
define|#
directive|define
name|EPOCH_WDAY
value|TM_THURSDAY
end_define

begin_define
define|#
directive|define
name|isleap
parameter_list|(
name|y
parameter_list|)
value|(((y) % 4) == 0&& (((y) % 100) != 0 || ((y) % 400) == 0))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|mon_lengths
index|[
literal|2
index|]
index|[
name|MONSPERYEAR
index|]
init|=
block|{
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|,
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|year_lengths
index|[
literal|2
index|]
init|=
block|{
name|DAYSPERNYEAR
block|,
name|DAYSPERLYEAR
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|timesub
parameter_list|(
name|timep
parameter_list|,
name|offset
parameter_list|,
name|tmp
parameter_list|)
specifier|const
name|time_t
modifier|*
specifier|const
name|timep
decl_stmt|;
specifier|const
name|long
name|offset
decl_stmt|;
name|struct
name|tm
modifier|*
specifier|const
name|tmp
decl_stmt|;
block|{
name|long
name|days
decl_stmt|;
name|long
name|rem
decl_stmt|;
name|long
name|y
decl_stmt|;
name|int
name|yleap
decl_stmt|;
specifier|const
name|int
modifier|*
name|ip
decl_stmt|;
name|days
operator|=
operator|*
name|timep
operator|/
name|SECSPERDAY
expr_stmt|;
name|rem
operator|=
operator|*
name|timep
operator|%
name|SECSPERDAY
expr_stmt|;
name|rem
operator|+=
operator|(
name|offset
operator|)
expr_stmt|;
while|while
condition|(
name|rem
operator|<
literal|0
condition|)
block|{
name|rem
operator|+=
name|SECSPERDAY
expr_stmt|;
operator|--
name|days
expr_stmt|;
block|}
while|while
condition|(
name|rem
operator|>=
name|SECSPERDAY
condition|)
block|{
name|rem
operator|-=
name|SECSPERDAY
expr_stmt|;
operator|++
name|days
expr_stmt|;
block|}
name|tmp
operator|->
name|tm_hour
operator|=
call|(
name|int
call|)
argument_list|(
name|rem
operator|/
name|SECSPERHOUR
argument_list|)
expr_stmt|;
name|rem
operator|=
name|rem
operator|%
name|SECSPERHOUR
expr_stmt|;
name|tmp
operator|->
name|tm_min
operator|=
call|(
name|int
call|)
argument_list|(
name|rem
operator|/
name|SECSPERMIN
argument_list|)
expr_stmt|;
comment|/* 	** A positive leap second requires a special 	** representation.  This uses "... ??:59:60" et seq. 	*/
name|tmp
operator|->
name|tm_sec
operator|=
call|(
name|int
call|)
argument_list|(
name|rem
operator|%
name|SECSPERMIN
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tm_wday
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|EPOCH_WDAY
operator|+
name|days
operator|)
operator|%
name|DAYSPERWEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|tm_wday
operator|<
literal|0
condition|)
name|tmp
operator|->
name|tm_wday
operator|+=
name|DAYSPERWEEK
expr_stmt|;
name|y
operator|=
name|EPOCH_YEAR
expr_stmt|;
define|#
directive|define
name|LEAPS_THRU_END_OF
parameter_list|(
name|y
parameter_list|)
value|((y) / 4 - (y) / 100 + (y) / 400)
while|while
condition|(
name|days
operator|<
literal|0
operator|||
name|days
operator|>=
operator|(
name|long
operator|)
name|year_lengths
index|[
name|yleap
operator|=
name|isleap
argument_list|(
name|y
argument_list|)
index|]
condition|)
block|{
name|long
name|newy
decl_stmt|;
name|newy
operator|=
name|y
operator|+
name|days
operator|/
name|DAYSPERNYEAR
expr_stmt|;
if|if
condition|(
name|days
operator|<
literal|0
condition|)
operator|--
name|newy
expr_stmt|;
name|days
operator|-=
operator|(
name|newy
operator|-
name|y
operator|)
operator|*
name|DAYSPERNYEAR
operator|+
name|LEAPS_THRU_END_OF
argument_list|(
name|newy
operator|-
literal|1
argument_list|)
operator|-
name|LEAPS_THRU_END_OF
argument_list|(
name|y
operator|-
literal|1
argument_list|)
expr_stmt|;
name|y
operator|=
name|newy
expr_stmt|;
block|}
name|tmp
operator|->
name|tm_year
operator|=
name|y
operator|-
name|TM_YEAR_BASE
expr_stmt|;
name|tmp
operator|->
name|tm_yday
operator|=
operator|(
name|int
operator|)
name|days
expr_stmt|;
name|ip
operator|=
name|mon_lengths
index|[
name|yleap
index|]
expr_stmt|;
for|for
control|(
name|tmp
operator|->
name|tm_mon
operator|=
literal|0
init|;
name|days
operator|>=
operator|(
name|long
operator|)
name|ip
index|[
name|tmp
operator|->
name|tm_mon
index|]
condition|;
operator|++
operator|(
name|tmp
operator|->
name|tm_mon
operator|)
control|)
name|days
operator|=
name|days
operator|-
operator|(
name|long
operator|)
name|ip
index|[
name|tmp
operator|->
name|tm_mon
index|]
expr_stmt|;
name|tmp
operator|->
name|tm_mday
operator|=
call|(
name|int
call|)
argument_list|(
name|days
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tm_isdst
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * Re-entrant version of gmtime. */
end_comment

begin_function
name|struct
name|tm
modifier|*
name|gmtime_r
parameter_list|(
specifier|const
name|time_t
modifier|*
name|timep
parameter_list|,
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
name|timesub
argument_list|(
name|timep
argument_list|,
literal|0L
argument_list|,
name|tm
argument_list|)
expr_stmt|;
return|return
name|tm
return|;
block|}
end_function

end_unit

