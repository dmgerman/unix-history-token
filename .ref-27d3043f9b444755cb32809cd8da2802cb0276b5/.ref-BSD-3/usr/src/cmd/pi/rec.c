begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  * Version 1.2 Novmeber 1978  */
end_comment

begin_include
include|#
directive|include
file|"whoami"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_comment
comment|/*  * Build a record namelist entry.  * Some of the processing here is somewhat involved.  * The basic structure we are building is as follows.  *  * Each record has a main RECORD entry, with an attached  * chain of fields as ->chain;  these include all the fields in all  * the variants of this record.  *  * Attached to NL_VARNT is a chain of VARNT structures  * describing each of the variants.  These are further linked  * through ->chain.  Each VARNT has, in ->range[0] the value of  * the associated constant, and each points at a RECORD describing  * the subrecord through NL_VTOREC.  These pointers are not unique,  * more than one VARNT may reference the same RECORD.  *  * The involved processing here is in computing the NL_OFFS entry  * by maxing over the variants.  This works as follows.  *  * Each RECORD has two size counters.  NL_OFFS is the maximum size  * so far of any variant of this record;  NL_FLDSZ gives the size  * of just the FIELDs to this point as a base for further variants.  *  * As we process each variant record, we start its size with the  * NL_FLDSZ we have so far.  After processing it, if its NL_OFFS  * is the largest so far, we update the NL_OFFS of this subrecord.  * This will eventually propagate back and update the NL_OFFS of the  * entire record.  */
end_comment

begin_comment
comment|/*  * P0 points to the outermost RECORD for name searches.  */
end_comment

begin_decl_stmt
name|struct
name|nl
modifier|*
name|P0
decl_stmt|;
end_decl_stmt

begin_macro
name|tyrec
argument_list|(
argument|r
argument_list|,
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|r
decl_stmt|,
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|tyrec1
argument_list|(
name|r
argument_list|,
name|off
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Define a record namelist entry.  * R is the tree for the record to be built.  * Off is the offset for the first item in this (sub)record.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|tyrec1
parameter_list|(
name|r
parameter_list|,
name|off
parameter_list|,
name|first
parameter_list|)
specifier|register
name|int
modifier|*
name|r
decl_stmt|;
name|int
name|off
decl_stmt|;
name|char
name|first
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|,
modifier|*
name|P0was
decl_stmt|;
name|p
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|RECORD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|P0was
operator|=
name|P0
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|P0
operator|=
name|p
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|p
operator|->
name|value
index|[
name|NL_FLDSZ
index|]
operator|=
name|p
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|=
name|off
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
name|NIL
condition|)
block|{
name|fields
argument_list|(
name|p
argument_list|,
name|r
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|variants
argument_list|(
name|p
argument_list|,
name|r
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|P0
operator|=
name|P0was
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define the fixed part fields for p.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|fields
parameter_list|(
name|p
parameter_list|,
name|r
parameter_list|)
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|fp
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|struct
name|nl
modifier|*
name|jp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|r
init|;
name|fp
operator|!=
name|NIL
condition|;
name|fp
operator|=
name|fp
index|[
literal|2
index|]
control|)
block|{
name|tp
operator|=
name|fp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NIL
condition|)
continue|continue;
name|jp
operator|=
name|gtype
argument_list|(
name|tp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|line
operator|=
name|tp
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|tp
index|[
literal|2
index|]
init|;
name|ip
operator|!=
name|NIL
condition|;
name|ip
operator|=
name|ip
index|[
literal|2
index|]
control|)
name|deffld
argument_list|(
name|p
argument_list|,
name|ip
index|[
literal|1
index|]
argument_list|,
name|jp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Define the variants for RECORD p.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|variants
parameter_list|(
name|p
parameter_list|,
name|r
parameter_list|)
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|vc
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|int
modifier|*
name|vr
decl_stmt|;
name|struct
name|nl
modifier|*
name|ct
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NIL
condition|)
return|return;
name|ct
operator|=
name|gtype
argument_list|(
name|r
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|line
operator|=
name|r
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Want it even if r[2] is NIL so 	 * we check its type in "new" and "dispose" 	 * calls -- link it to NL_TAG. 	 */
name|p
operator|->
name|ptr
index|[
name|NL_TAG
index|]
operator|=
name|deffld
argument_list|(
name|p
argument_list|,
name|r
index|[
literal|2
index|]
argument_list|,
name|ct
argument_list|)
expr_stmt|;
for|for
control|(
name|vc
operator|=
name|r
index|[
literal|4
index|]
init|;
name|vc
operator|!=
name|NIL
condition|;
name|vc
operator|=
name|vc
index|[
literal|2
index|]
control|)
block|{
name|v
operator|=
name|vc
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NIL
condition|)
continue|continue;
name|vr
operator|=
name|tyrec1
argument_list|(
name|v
index|[
literal|3
index|]
argument_list|,
name|p
operator|->
name|value
index|[
name|NL_FLDSZ
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
if|if
condition|(
name|vr
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|>
name|p
operator|->
name|value
index|[
name|NL_OFFS
index|]
condition|)
name|p
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|=
name|vr
operator|->
name|value
index|[
name|NL_OFFS
index|]
expr_stmt|;
endif|#
directive|endif
name|line
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|v
operator|=
name|v
index|[
literal|2
index|]
init|;
name|v
operator|!=
name|NIL
condition|;
name|v
operator|=
name|v
index|[
literal|2
index|]
control|)
name|defvnt
argument_list|(
name|p
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|vr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Define a field in subrecord p of record P0  * with name s and type t.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|deffld
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|reclook
argument_list|(
name|P0
argument_list|,
name|s
argument_list|)
operator|!=
name|NIL
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"%s is a duplicate field name in this record"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|NIL
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PI0
name|fp
operator|=
name|enter
argument_list|(
name|defnl
argument_list|(
name|s
argument_list|,
name|FIELD
argument_list|,
name|t
argument_list|,
name|p
operator|->
name|value
index|[
name|NL_OFFS
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fp
operator|=
name|enter
argument_list|(
name|defnl
argument_list|(
name|s
argument_list|,
name|FIELD
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|!=
name|NIL
condition|)
block|{
name|fp
operator|->
name|chain
operator|=
name|P0
operator|->
name|chain
expr_stmt|;
name|P0
operator|->
name|chain
operator|=
name|fp
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|p
operator|->
name|value
index|[
name|NL_FLDSZ
index|]
operator|=
name|p
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|+=
name|even
argument_list|(
name|width
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t
operator|!=
name|NIL
condition|)
block|{
name|P0
operator|->
name|nl_flags
operator||=
name|t
operator|->
name|nl_flags
operator|&
name|NFILES
expr_stmt|;
name|p
operator|->
name|nl_flags
operator||=
name|t
operator|->
name|nl_flags
operator|&
name|NFILES
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define a variant from the constant tree of t  * in subrecord p of record P0 where the casetype  * is ct and the variant record to be associated is vr.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|defvnt
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|vr
parameter_list|,
name|ct
parameter_list|)
name|struct
name|nl
modifier|*
name|p
decl_stmt|,
decl|*
name|vr
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|nl
modifier|*
name|ct
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|av
decl_stmt|;
name|gconst
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|!=
name|NIL
operator|&&
name|incompat
argument_list|(
name|con
operator|.
name|ctype
argument_list|,
name|ct
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|cerror
argument_list|(
literal|"Variant label type incompatible with selector type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ct
operator|=
name|NIL
expr_stmt|;
block|}
name|av
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|VARNT
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
name|ct
operator|!=
name|NIL
condition|)
name|uniqv
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|av
operator|->
name|chain
operator|=
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
expr_stmt|;
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
operator|=
name|av
expr_stmt|;
name|av
operator|->
name|ptr
index|[
name|NL_VTOREC
index|]
operator|=
name|vr
expr_stmt|;
name|av
operator|->
name|range
index|[
literal|0
index|]
operator|=
name|con
operator|.
name|crval
expr_stmt|;
return|return
operator|(
name|av
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_comment
comment|/*  * Check that the constant label value  * is unique among the labels in this variant.  */
end_comment

begin_macro
name|uniqv
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|vt
decl_stmt|;
for|for
control|(
name|vt
operator|=
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
init|;
name|vt
operator|!=
name|NIL
condition|;
name|vt
operator|=
name|vt
operator|->
name|chain
control|)
if|if
condition|(
name|vt
operator|->
name|range
index|[
literal|0
index|]
operator|==
name|con
operator|.
name|crval
condition|)
block|{
name|error
argument_list|(
literal|"Duplicate variant case label in record"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * See if the field name s is defined  * in the record p, returning a pointer  * to it namelist entry if it is.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|reclook
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NIL
operator|||
name|s
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|chain
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|chain
control|)
if|if
condition|(
name|p
operator|->
name|symbol
operator|==
name|s
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

end_unit

