begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_comment
comment|/* **  SCCS.C -- human-oriented front end to the SCCS system. ** **	Without trying to add any functionality to speak of, this **	program tries to make SCCS a little more accessible to human **	types.  The main thing it does is automatically put the **	string "SCCS/s." on the front of names.  Also, it has a **	couple of things that are designed to shorten frequent **	combinations, e.g., "delget" which expands to a "delta" **	and a "get". ** **	This program can also function as a setuid front end. **	To do this, you should copy the source, renaming it to **	whatever you want, e.g., "syssccs".  Change any defaults **	in the program (e.g., syssccs might default -d to **	"/usr/src/sys").  Then recompile and put the result **	as setuid to whomever you want.  In this mode, sccs **	knows to not run setuid for certain programs in order **	to preserve security, and so forth. ** **	Usage: **		sccs [flags] command [args] ** **	Flags: **		-d<dir><dir> represents a directory to search **				out of.  It should be a full pathname **				for general usage.  E.g., if<dir> is **				"/usr/src/sys", then a reference to the **				file "dev/bio.c" becomes a reference to **				"/usr/src/sys/dev/bio.c". **		-p<path>	prepends<path> to the final component **				of the pathname.  By default, this is **				"SCCS".  For example, in the -d example **				above, the path then gets modified to **				"/usr/src/sys/dev/SCCS/s.bio.c".  In **				more common usage (without the -d flag), **				"prog.c" would get modified to **				"SCCS/s.prog.c".  In both cases, the **				"s." gets automatically prepended. **		-r		run as the real user. ** **	Commands: **		admin, **		get, **		delta, **		rmdel, **		chghist, **		etc.		Straight out of SCCS; only difference **				is that pathnames get modified as **				described above. **		edit		Macro for "get -e". **		unedit		Removes a file being edited, knowing **				about p-files, etc. **		delget		Macro for "delta" followed by "get". **		deledit		Macro for "delta" followed by "get -e". **		info		Tell what files being edited. **		clean		Remove all files that can be **				regenerated from SCCS files. **		check		Like info, but return exit status, for **				use in makefiles. **		fix		Remove a top delta& reedit, but save **				the previous changes in that delta. ** **	Compilation Flags: **		UIDUSER -- determine who the user is by looking at the **			uid rather than the login name -- for machines **			where SCCS gets the user in this way. **		SCCSDIR -- if defined, forces the -d flag to take on **			this value.  This is so that the setuid **			aspects of this program cannot be abused. **			This flag also disables the -p flag. **		SCCSPATH -- the default for the -p flag. **		MYNAME -- the title this program should print when it **			gives error messages. ** **	Compilation Instructions: **		cc -O -n -s sccs.c **		The flags listed above can be -D defined to simplify **			recompilation for variant versions. ** **	Author: **		Eric Allman, UCB/INGRES **		Copyright 1980 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)sccs.c	1.46 %G%"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*******************  Configuration Information  ********************/
end_comment

begin_comment
comment|/* special defines for local berkeley systems */
end_comment

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CSVAX
end_ifdef

begin_define
define|#
directive|define
name|UIDUSER
end_define

begin_define
define|#
directive|define
name|PROGPATH
parameter_list|(
name|name
parameter_list|)
value|"/usr/local/name"
end_define

begin_endif
endif|#
directive|endif
endif|CSVAX
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INGVAX
end_ifdef

begin_define
define|#
directive|define
name|PROGPATH
parameter_list|(
name|name
parameter_list|)
value|"/usr/local/name"
end_define

begin_endif
endif|#
directive|endif
endif|INGVAX
end_endif

begin_comment
comment|/* end of berkeley systems defines */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCCSPATH
end_ifndef

begin_define
define|#
directive|define
name|SCCSPATH
value|"SCCS"
end_define

begin_comment
comment|/* pathname in which to find s-files */
end_comment

begin_endif
endif|#
directive|endif
endif|NOT SCCSPATH
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MYNAME
end_ifndef

begin_define
define|#
directive|define
name|MYNAME
value|"sccs"
end_define

begin_comment
comment|/* name used for printing errors */
end_comment

begin_endif
endif|#
directive|endif
endif|NOT MYNAME
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PROGPATH
end_ifndef

begin_define
define|#
directive|define
name|PROGPATH
parameter_list|(
name|name
parameter_list|)
value|"/usr/sccs/name"
end_define

begin_comment
comment|/* place to find binaries */
end_comment

begin_endif
endif|#
directive|endif
endif|PROGPATH
end_endif

begin_comment
comment|/****************  End of Configuration Information  ****************/
end_comment

begin_escape
end_escape

begin_typedef
typedef|typedef
name|char
name|bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|bitset
parameter_list|(
name|bit
parameter_list|,
name|word
parameter_list|)
value|((bool) ((bit)& (word)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UIDUSER
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
endif|UIDUSER
end_endif

begin_struct
struct|struct
name|sccsprog
block|{
name|char
modifier|*
name|sccsname
decl_stmt|;
comment|/* name of SCCS routine */
name|short
name|sccsoper
decl_stmt|;
comment|/* opcode, see below */
name|short
name|sccsflags
decl_stmt|;
comment|/* flags, see below */
name|char
modifier|*
name|sccspath
decl_stmt|;
comment|/* pathname of binary implementing */
block|}
struct|;
end_struct

begin_comment
comment|/* values for sccsoper */
end_comment

begin_define
define|#
directive|define
name|PROG
value|0
end_define

begin_comment
comment|/* call a program */
end_comment

begin_define
define|#
directive|define
name|CMACRO
value|1
end_define

begin_comment
comment|/* command substitution macro */
end_comment

begin_define
define|#
directive|define
name|FIX
value|2
end_define

begin_comment
comment|/* fix a delta */
end_comment

begin_define
define|#
directive|define
name|CLEAN
value|3
end_define

begin_comment
comment|/* clean out recreatable files */
end_comment

begin_define
define|#
directive|define
name|UNEDIT
value|4
end_define

begin_comment
comment|/* unedit a file */
end_comment

begin_define
define|#
directive|define
name|SHELL
value|5
end_define

begin_comment
comment|/* call a shell file (like PROG) */
end_comment

begin_define
define|#
directive|define
name|DIFFS
value|6
end_define

begin_comment
comment|/* diff between sccs& file out */
end_comment

begin_comment
comment|/* bits for sccsflags */
end_comment

begin_define
define|#
directive|define
name|NO_SDOT
value|0001
end_define

begin_comment
comment|/* no s. on front of args */
end_comment

begin_define
define|#
directive|define
name|REALUSER
value|0002
end_define

begin_comment
comment|/* protected (e.g., admin) */
end_comment

begin_comment
comment|/* modes for the "clean", "info", "check" ops */
end_comment

begin_define
define|#
directive|define
name|CLEANC
value|0
end_define

begin_comment
comment|/* clean command */
end_comment

begin_define
define|#
directive|define
name|INFOC
value|1
end_define

begin_comment
comment|/* info command */
end_comment

begin_define
define|#
directive|define
name|CHECKC
value|2
end_define

begin_comment
comment|/* check command */
end_comment

begin_define
define|#
directive|define
name|TELLC
value|3
end_define

begin_comment
comment|/* give list of files being edited */
end_comment

begin_comment
comment|/* **  Description of commands known to this program. **	First argument puts the command into a class.  Second arg is **	info regarding treatment of this command.  Third arg is a **	list of flags this command accepts from macros, etc.  Fourth **	arg is the pathname of the implementing program, or the **	macro definition, or the arg to a sub-algorithm. */
end_comment

begin_decl_stmt
name|struct
name|sccsprog
name|SccsProg
index|[]
init|=
block|{
literal|"admin"
block|,
name|PROG
block|,
name|REALUSER
block|,
name|PROGPATH
argument_list|(
name|admin
argument_list|)
block|,
literal|"chghist"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|rmdel
argument_list|)
block|,
literal|"comb"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|comb
argument_list|)
block|,
literal|"delta"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|delta
argument_list|)
block|,
literal|"get"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|get
argument_list|)
block|,
literal|"help"
block|,
name|PROG
block|,
name|NO_SDOT
block|,
name|PROGPATH
argument_list|(
name|help
argument_list|)
block|,
literal|"prt"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|prt
argument_list|)
block|,
literal|"rmdel"
block|,
name|PROG
block|,
name|REALUSER
block|,
name|PROGPATH
argument_list|(
name|rmdel
argument_list|)
block|,
literal|"what"
block|,
name|PROG
block|,
name|NO_SDOT
block|,
name|PROGPATH
argument_list|(
name|what
argument_list|)
block|,
literal|"sccsdiff"
block|,
name|SHELL
block|,
name|REALUSER
block|,
name|PROGPATH
argument_list|(
name|sccsdiff
argument_list|)
block|,
literal|"edit"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"get -e"
block|,
literal|"delget"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"delta:mysrp/get:ixbeskecl -t"
block|,
literal|"deledit"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"delta:mysrp/get:ixbeskecl -e -t"
block|,
literal|"fix"
block|,
name|FIX
block|,
name|NO_SDOT
block|,
name|NULL
block|,
literal|"clean"
block|,
name|CLEAN
block|,
name|REALUSER
block|,
operator|(
name|char
operator|*
operator|)
name|CLEANC
block|,
literal|"info"
block|,
name|CLEAN
block|,
name|REALUSER
block|,
operator|(
name|char
operator|*
operator|)
name|INFOC
block|,
literal|"check"
block|,
name|CLEAN
block|,
name|REALUSER
block|,
operator|(
name|char
operator|*
operator|)
name|CHECKC
block|,
literal|"tell"
block|,
name|CLEAN
block|,
name|REALUSER
block|,
operator|(
name|char
operator|*
operator|)
name|TELLC
block|,
literal|"unedit"
block|,
name|UNEDIT
block|,
name|NO_SDOT
block|,
name|NULL
block|,
literal|"diffs"
block|,
name|DIFFS
block|,
name|NO_SDOT
operator||
name|REALUSER
block|,
name|NULL
block|,
name|NULL
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one line from a p-file */
end_comment

begin_struct
struct|struct
name|pfile
block|{
name|char
modifier|*
name|p_osid
decl_stmt|;
comment|/* old SID */
name|char
modifier|*
name|p_nsid
decl_stmt|;
comment|/* new SID */
name|char
modifier|*
name|p_user
decl_stmt|;
comment|/* user who did edit */
name|char
modifier|*
name|p_date
decl_stmt|;
comment|/* date of get */
name|char
modifier|*
name|p_time
decl_stmt|;
comment|/* time of get */
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|SccsPath
init|=
name|SCCSPATH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of SCCS files */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSDIR
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|SccsDir
init|=
name|SCCSDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory to begin search from */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|SccsDir
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|MyName
index|[]
init|=
name|MYNAME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name used in messages */
end_comment

begin_decl_stmt
name|int
name|OutFile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override output file for commands */
end_comment

begin_decl_stmt
name|bool
name|RealUser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, running as real user */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|bool
name|Debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* turn on tracing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	**  Detect and decode flags intended for this program. 	*/
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [flags] command [flags]\n"
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* run as real user */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|RealUser
operator|++
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|SCCSDIR
case|case
literal|'p'
case|:
comment|/* path of sccs files */
name|SccsPath
operator|=
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* directory to search from */
name|SccsDir
operator|=
operator|++
name|p
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'T'
case|:
comment|/* trace */
name|Debug
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usrerr
argument_list|(
literal|"unknown option -%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|SccsPath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|SccsPath
operator|=
literal|"."
expr_stmt|;
block|}
name|i
operator|=
name|command
argument_list|(
name|argv
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  COMMAND -- look up and perform a command ** **	This routine is the guts of this program.  Given an **	argument vector, it looks up the "command" (argv[0]) **	in the configuration table and does the necessary stuff. ** **	Parameters: **		argv -- an argument vector to process. **		forkflag -- if set, fork before executing the command. **		editflag -- if set, only include flags listed in the **			sccsklets field of the command descriptor. **		arg0 -- a space-seperated list of arguments to insert **			before argv. ** **	Returns: **		zero -- command executed ok. **		else -- error status. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|command
argument_list|(
argument|argv
argument_list|,
argument|forkflag
argument_list|,
argument|arg0
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sccsprog
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|()
function_decl|;
name|char
modifier|*
name|nav
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|extern
name|bool
name|unedit
parameter_list|()
function_decl|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|makefile
parameter_list|()
function_decl|;
name|char
modifier|*
name|editchs
decl_stmt|;
specifier|extern
name|char
modifier|*
name|tail
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"command:\n\t\"%s\"\n"
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|argv
init|;
operator|*
name|np
operator|!=
name|NULL
condition|;
name|np
operator|++
control|)
name|printf
argument_list|(
literal|"\t\"%s\"\n"
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	**  Copy arguments. 	**	Copy from arg0& if necessary at most one arg 	**	from argv[0]. 	*/
name|np
operator|=
name|ap
operator|=
operator|&
name|nav
index|[
literal|1
index|]
expr_stmt|;
name|editchs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|arg0
operator|,
name|q
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
control|)
block|{
operator|*
name|np
operator|++
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|editchs
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
operator|*
name|np
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
name|NULL
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
comment|/* 	**  Look up command. 	**	At this point, *ap is the command name. 	*/
name|cmd
operator|=
name|lookup
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unknown command \"%s\""
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
comment|/* 	**  Copy remaining arguments doing editing as appropriate. 	*/
for|for
control|(
init|;
operator|*
name|argv
operator|!=
name|NULL
condition|;
name|argv
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|editchs
operator|==
name|NULL
operator|||
name|index
argument_list|(
name|editchs
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
operator|*
name|np
operator|++
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NO_SDOT
argument_list|,
name|cmd
operator|->
name|sccsflags
argument_list|)
condition|)
name|p
operator|=
name|makefile
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|np
operator|++
operator|=
name|p
expr_stmt|;
block|}
block|}
operator|*
name|np
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Interpret operation associated with this command. 	*/
switch|switch
condition|(
name|cmd
operator|->
name|sccsoper
condition|)
block|{
case|case
name|SHELL
case|:
comment|/* call a shell file */
operator|*
name|ap
operator|=
name|cmd
operator|->
name|sccspath
expr_stmt|;
operator|*
operator|--
name|ap
operator|=
literal|"sh"
expr_stmt|;
name|rval
operator|=
name|callprog
argument_list|(
literal|"/bin/sh"
argument_list|,
name|cmd
operator|->
name|sccsflags
argument_list|,
name|ap
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROG
case|:
comment|/* call an sccs prog */
name|rval
operator|=
name|callprog
argument_list|(
name|cmd
operator|->
name|sccspath
argument_list|,
name|cmd
operator|->
name|sccsflags
argument_list|,
name|ap
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMACRO
case|:
comment|/* command macro */
comment|/* step through& execute each part of the macro */
for|for
control|(
name|p
operator|=
name|cmd
operator|->
name|sccspath
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|!=
literal|'\0'
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
break|break;
block|}
break|break;
case|case
name|FIX
case|:
comment|/* fix a delta */
if|if
condition|(
name|strncmp
argument_list|(
name|ap
index|[
literal|1
index|]
argument_list|,
literal|"-r"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"-r flag needed for fix command"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
comment|/* get the version with all changes */
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"get -k"
argument_list|)
expr_stmt|;
comment|/* now remove that version from the s-file */
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"rmdel:r"
argument_list|)
expr_stmt|;
comment|/* and edit the old version (but don't clobber new vers) */
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|2
index|]
argument_list|,
name|FALSE
argument_list|,
literal|"get -e -g"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAN
case|:
name|rval
operator|=
name|clean
argument_list|(
operator|(
name|int
operator|)
name|cmd
operator|->
name|sccspath
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEDIT
case|:
for|for
control|(
name|argv
operator|=
name|np
operator|=
operator|&
name|ap
index|[
literal|1
index|]
init|;
operator|*
name|argv
operator|!=
name|NULL
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|unedit
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
block|}
operator|*
name|np
operator|=
name|NULL
expr_stmt|;
comment|/* get all the files that we unedited successfully */
if|if
condition|(
name|np
operator|>
operator|&
name|ap
index|[
literal|1
index|]
condition|)
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|,
literal|"get"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFFS
case|:
comment|/* diff between s-file& edit file */
comment|/* find the end of the flag arguments */
for|for
control|(
name|np
operator|=
operator|&
name|ap
index|[
literal|1
index|]
init|;
operator|*
name|np
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|np
operator|==
literal|'-'
condition|;
name|np
operator|++
control|)
continue|continue;
name|argv
operator|=
name|np
expr_stmt|;
comment|/* for each file, do the diff */
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|!=
name|NULL
condition|)
block|{
comment|/* messy, but we need a null terminated argv */
operator|*
name|argv
operator|=
operator|*
name|np
operator|++
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|dodiff
argument_list|(
name|ap
argument_list|,
name|tail
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|rval
operator|=
name|i
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
break|break;
default|default:
name|syserr
argument_list|(
literal|"oper %d"
argument_list|,
name|cmd
operator|->
name|sccsoper
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"command: rval=%d\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  LOOKUP -- look up an SCCS command name. ** **	Parameters: **		name -- the name of the command to look up. ** **	Returns: **		ptr to command descriptor for this command. **		NULL if no such entry. ** **	Side Effects: **		none. */
end_comment

begin_function
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|sccsprog
modifier|*
name|cmd
decl_stmt|;
for|for
control|(
name|cmd
operator|=
name|SccsProg
init|;
name|cmd
operator|->
name|sccsname
operator|!=
name|NULL
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
operator|->
name|sccsname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cmd
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CALLPROG -- call a program ** **	Used to call the SCCS programs. ** **	Parameters: **		progpath -- pathname of the program to call. **		flags -- status flags from the command descriptors. **		argv -- an argument vector to pass to the program. **		forkflag -- if true, fork before calling, else just **			exec. ** **	Returns: **		The exit status of the program. **		Nothing if forkflag == FALSE. ** **	Side Effects: **		Can exit if forkflag == FALSE. */
end_comment

begin_macro
name|callprog
argument_list|(
argument|progpath
argument_list|,
argument|flags
argument_list|,
argument|argv
argument_list|,
argument|forkflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|progpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"callprog:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t\"%s\"\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	**  Fork if appropriate. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"Forking\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|wait
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|&
literal|0377
operator|)
operator|==
literal|0
condition|)
name|st
operator|=
operator|(
name|st
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
if|if
condition|(
name|OutFile
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|OutFile
argument_list|)
expr_stmt|;
name|OutFile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|st
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|OutFile
operator|>=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"callprog: setting stdout w/o forking"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
comment|/* set protection as appropriate */
if|if
condition|(
name|bitset
argument_list|(
name|REALUSER
argument_list|,
name|flags
argument_list|)
condition|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* change standard input& output if needed */
if|if
condition|(
name|OutFile
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|OutFile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|OutFile
argument_list|)
expr_stmt|;
block|}
comment|/* call real SCCS program */
name|execv
argument_list|(
name|progpath
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"cannot execute %s"
argument_list|,
name|progpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKEFILE -- make filename of SCCS file ** **	If the name passed is already the name of an SCCS file, **	just return it.  Otherwise, munge the name into the name **	of the actual SCCS file. ** **	There are cases when it is not clear what you want to **	do.  For example, if SccsPath is an absolute pathname **	and the name given is also an absolute pathname, we go **	for SccsPath (& only use the last component of the name **	passed) -- this is important for security reasons (if **	sccs is being used as a setuid front end), but not **	particularly intuitive. ** **	Parameters: **		name -- the file name to be munged. ** **	Returns: **		The pathname of the sccs file. **		NULL on error. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|makefile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|isdir
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|name
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* 	**  See if the name can be used as-is. 	*/
if|if
condition|(
name|SccsPath
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name
operator|)
return|;
if|if
condition|(
name|isdir
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|name
operator|)
return|;
block|}
comment|/* 	**  Create the actual pathname. 	*/
comment|/* first the directory part */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|SccsDir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* then the head of the pathname */
name|strncat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|isdir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
comment|/* sorry, no; copy the SCCS pathname& the "s." */
name|strcpy
argument_list|(
name|q
argument_list|,
name|SccsPath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/s."
argument_list|)
expr_stmt|;
comment|/* and now the end of the name */
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* if i haven't changed it, why did I do all this? */
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ISDIR -- return true if the argument is a directory. ** **	Parameters: **		name -- the pathname of the file to check. ** **	Returns: **		TRUE if 'name' is a directory, FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isdir
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SAFEPATH -- determine whether a pathname is "safe" ** **	"Safe" pathnames only allow you to get deeper into the **	directory structure, i.e., full pathnames and ".." are **	not allowed. ** **	Parameters: **		p -- the name to check. ** **	Returns: **		TRUE -- if the path is safe. **		FALSE -- if the path is not safe. ** **	Side Effects: **		Prints a message if the path is not safe. */
end_comment

begin_function
name|bool
name|safepath
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
block|{
while|while
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"You may not use full pathnames or \"..\"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CLEAN -- clean out recreatable files ** **	Any file for which an "s." file exists but no "p." file **	exists in the current directory is purged. ** **	Parameters: **		tells whether this came from a "clean", "info", or **		"check" command. ** **	Returns: **		none. ** **	Side Effects: **		Removes files in the current directory. **		Prints information regarding files being edited. **		Exits if a "check" command. */
end_comment

begin_macro
name|clean
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|direct
name|dir
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|pline
index|[
literal|120
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|dirfd
decl_stmt|;
specifier|register
name|char
modifier|*
name|basefile
decl_stmt|;
name|bool
name|gotedit
decl_stmt|;
name|FILE
modifier|*
name|pfp
decl_stmt|;
comment|/* 	**  Find and open the SCCS directory. 	*/
name|strcpy
argument_list|(
name|buf
argument_list|,
name|SccsDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|SccsPath
argument_list|)
expr_stmt|;
name|dirfd
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirfd
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot open %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_NOINPUT
operator|)
return|;
block|}
comment|/* 	**  Scan the SCCS directory looking for s. files. 	**	gotedit tells whether we have tried to clean any 	**		files that are being edited. 	*/
name|gotedit
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dir
argument_list|,
sizeof|sizeof
name|dir
argument_list|,
literal|1
argument_list|,
name|dirfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|d_ino
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|dir
operator|.
name|d_name
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* got an s. file -- see if the p. file exists */
name|strcpy
argument_list|(
name|buf
argument_list|,
name|SccsDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|SccsPath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/p."
argument_list|)
expr_stmt|;
name|basefile
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|basefile
argument_list|,
operator|&
name|dir
operator|.
name|d_name
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
argument_list|)
expr_stmt|;
name|basefile
index|[
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pfp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|!=
name|NULL
condition|)
block|{
comment|/* the file exists -- report it's contents */
if|if
condition|(
name|mode
operator|==
name|TELLC
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|basefile
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|fgets
argument_list|(
name|pline
argument_list|,
sizeof|sizeof
name|pline
argument_list|,
name|pfp
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%12s: being edited: %s"
argument_list|,
name|basefile
argument_list|,
name|pline
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|gotedit
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* the s. file exists and no p. file exists -- unlink the g-file */
if|if
condition|(
name|mode
operator|==
name|CLEANC
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
operator|&
name|dir
operator|.
name|d_name
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|unlink
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* cleanup& report results */
name|fclose
argument_list|(
name|dirfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotedit
operator|&&
name|mode
operator|==
name|INFOC
condition|)
name|printf
argument_list|(
literal|"Nothing being edited\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CHECKC
condition|)
name|exit
argument_list|(
name|gotedit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  UNEDIT -- unedit a file ** **	Checks to see that the current user is actually editting **	the file and arranges that s/he is not editting it. ** **	Parameters: **		fn -- the name of the file to be unedited. ** **	Returns: **		TRUE -- if the file was successfully unedited. **		FALSE -- if the file was not unedited for some **			reason. ** **	Side Effects: **		fn is removed **		entries are removed from pfile. */
end_comment

begin_function
name|bool
name|unedit
parameter_list|(
name|fn
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|pfp
decl_stmt|;
name|char
modifier|*
name|pfn
decl_stmt|;
specifier|static
name|char
name|tfn
index|[]
init|=
literal|"/tmp/sccsXXXXX"
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|bool
name|delete
init|=
name|FALSE
decl_stmt|;
name|bool
name|others
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|myname
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
name|struct
name|pfile
modifier|*
name|pent
decl_stmt|;
specifier|extern
name|struct
name|pfile
modifier|*
name|getpfile
parameter_list|()
function_decl|;
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|makefile
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|UIDUSER
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|UIDUSER
comment|/* make "s." filename& find the trailing component */
name|pfn
operator|=
name|makefile
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|q
operator|=
name|rindex
argument_list|(
name|pfn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|q
operator|=
operator|&
name|pfn
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|!=
literal|'s'
operator|||
name|q
index|[
literal|2
index|]
operator|!=
literal|'.'
condition|)
block|{
name|usrerr
argument_list|(
literal|"bad file name \"%s\""
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* turn "s." into "p."& try to open it */
operator|*
operator|++
name|q
operator|=
literal|'p'
expr_stmt|;
name|pfp
operator|=
name|fopen
argument_list|(
name|pfn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%12s: not being edited\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* create temp file for editing p-file */
name|mktemp
argument_list|(
name|tfn
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|fopen
argument_list|(
name|tfn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot create \"%s\""
argument_list|,
name|tfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/* figure out who I am */
ifdef|#
directive|ifdef
name|UIDUSER
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"who are you? (uid=%d)"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|myname
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
else|#
directive|else
name|myname
operator|=
name|getlogin
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|UIDUSER
comment|/* 	**  Copy p-file to temp file, doing deletions as needed. 	*/
while|while
condition|(
operator|(
name|pent
operator|=
name|getpfile
argument_list|(
name|pfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pent
operator|->
name|p_user
argument_list|,
name|myname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* a match */
name|delete
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* output it again */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"%s %s %s %s %s\n"
argument_list|,
name|pent
operator|->
name|p_osid
argument_list|,
name|pent
operator|->
name|p_nsid
argument_list|,
name|pent
operator|->
name|p_user
argument_list|,
name|pent
operator|->
name|p_date
argument_list|,
name|pent
operator|->
name|p_time
argument_list|)
expr_stmt|;
name|others
operator|++
expr_stmt|;
block|}
block|}
comment|/* do final cleanup */
if|if
condition|(
name|others
condition|)
block|{
comment|/* copy it back (perhaps it should be linked?) */
if|if
condition|(
name|freopen
argument_list|(
name|tfn
argument_list|,
literal|"r"
argument_list|,
name|tfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot reopen \"%s\""
argument_list|,
name|tfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
name|pfn
argument_list|,
literal|"w"
argument_list|,
name|pfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot create \"%s\""
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|tfp
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it's empty -- remove it */
name|unlink
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfn
argument_list|)
expr_stmt|;
comment|/* actually remove the g-file */
if|if
condition|(
name|delete
condition|)
block|{
name|unlink
argument_list|(
name|tail
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%12s: removed\n"
argument_list|,
name|tail
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%12s: not being edited by you\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DODIFF -- diff an s-file against a g-file ** **	Parameters: **		getv -- argv for the 'get' command. **		gfile -- name of the g-file to diff against. ** **	Returns: **		Result of get. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|dodiff
argument_list|(
argument|getv
argument_list|,
argument|gfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|getv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pipev
index|[
literal|2
index|]
decl_stmt|;
name|int
name|rval
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
specifier|auto
name|int
name|st
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|int
function_decl|(
modifier|*
name|osig
function_decl|)
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"\n------- %s -------\n"
argument_list|,
name|gfile
argument_list|)
expr_stmt|;
comment|/* create context for diff to run in */
if|if
condition|(
name|pipe
argument_list|(
name|pipev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dodiff: pipe failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dodiff: fork failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* in parent; run get */
name|OutFile
operator|=
name|pipev
index|[
literal|1
index|]
expr_stmt|;
name|close
argument_list|(
name|pipev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rval
operator|=
name|command
argument_list|(
operator|&
name|getv
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"get -s -k -p"
argument_list|)
expr_stmt|;
name|osig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|st
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|i
operator|!=
name|pid
operator|)
operator|||
name|errno
operator|==
name|EINTR
condition|)
name|errno
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|osig
argument_list|)
expr_stmt|;
comment|/* ignore result of diff */
block|}
else|else
block|{
comment|/* in child, run diff */
if|if
condition|(
name|close
argument_list|(
name|pipev
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup
argument_list|(
name|pipev
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|close
argument_list|(
name|pipev
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dodiff: magic failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|execl
argument_list|(
name|PROGPATH
argument_list|(
name|bdiff
argument_list|)
argument_list|,
literal|"bdiff"
argument_list|,
literal|"-"
argument_list|,
name|gfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|V6
name|execlp
argument_list|(
literal|"bdiff"
argument_list|,
literal|"bdiff"
argument_list|,
literal|"-"
argument_list|,
name|gfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"diff"
argument_list|,
literal|"diff"
argument_list|,
literal|"-"
argument_list|,
name|gfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NOT V6
name|syserr
argument_list|(
literal|"bdiff: cannot execute"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TAIL -- return tail of filename. ** **	Parameters: **		fn -- the filename. ** **	Returns: **		a pointer to the tail of the filename; e.g., given **		"cmd/ls.c", "ls.c" is returned. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|tail
parameter_list|(
name|fn
parameter_list|)
specifier|register
name|char
modifier|*
name|fn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|fn
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|fn
operator|=
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GETPFILE -- get an entry from the p-file ** **	Parameters: **		pfp -- p-file file pointer ** **	Returns: **		pointer to p-file struct for next entry **		NULL on EOF or error ** **	Side Effects: **		Each call wipes out results of previous call. */
end_comment

begin_function
name|struct
name|pfile
modifier|*
name|getpfile
parameter_list|(
name|pfp
parameter_list|)
name|FILE
modifier|*
name|pfp
decl_stmt|;
block|{
specifier|static
name|struct
name|pfile
name|ent
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|nextfield
parameter_list|()
function_decl|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ent
operator|.
name|p_osid
operator|=
name|p
operator|=
name|buf
expr_stmt|;
name|ent
operator|.
name|p_nsid
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_user
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_date
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_time
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|nextfield
argument_list|(
name|p
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|ent
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|nextfield
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  USRERR -- issue user-level error ** **	Parameters: **		f -- format string. **		p1-p3 -- parameters to a printf. ** **	Returns: **		-1 ** **	Side Effects: **		none. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|usrerr
argument_list|(
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SYSERR -- print system-generated error. ** **	Parameters: **		f -- format string to a printf. **		p1, p2, p3 -- parameters to f. ** **	Returns: **		never. ** **	Side Effects: **		none. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|syserr
argument_list|(
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s SYSERR: "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
else|else
block|{
name|perror
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

