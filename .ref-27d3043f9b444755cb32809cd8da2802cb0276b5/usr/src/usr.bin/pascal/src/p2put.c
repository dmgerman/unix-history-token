begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)p2put.c 1.3 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	functions to help pi put out      *	polish postfix binary portable c compiler intermediate code      *	thereby becoming the portable pascal compiler      */
end_comment

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"pcops.h"
end_include

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_comment
comment|/*      *	mash into f77's format      *	lovely, isn't it?      */
end_comment

begin_define
define|#
directive|define
name|TOF77
parameter_list|(
name|fop
parameter_list|,
name|val
parameter_list|,
name|rest
parameter_list|)
value|( ( ( (rest)& 0177777 )<< 16 ) \ 					| ( ( (val)& 0377 )<< 8 )	 \ 					| ( (fop)& 0377 ) )
end_define

begin_escape
end_escape

begin_comment
comment|/*      *	emits an ftext operator and a string to the pcstream      */
end_comment

begin_macro
name|puttext
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|str4len
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|P2FTEXT
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2FTEXT | %3d | 0	"
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p2string
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|str4len
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*      *	put formatted text into a buffer for printing to the pcstream.      *	a call to putpflush actually puts out the text.      *	none of arg1 .. arg5 need be present.      *	and you can add more if you need them.      */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|putprintf
argument_list|(
argument|format
argument_list|,
argument|incomplete
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|incomplete
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|ppbuffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|ppbufp
init|=
name|ppbuffer
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
name|sprintf
argument_list|(
name|ppbufp
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|ppbufp
operator|=
operator|&
operator|(
name|ppbuffer
index|[
name|strlen
argument_list|(
name|ppbuffer
argument_list|)
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|ppbufp
operator|>=
operator|&
operator|(
name|ppbuffer
index|[
name|BUFSIZ
index|]
operator|)
condition|)
name|panic
argument_list|(
literal|"putprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|incomplete
condition|)
block|{
name|puttext
argument_list|(
name|ppbuffer
argument_list|)
expr_stmt|;
name|ppbufp
operator|=
name|ppbuffer
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	emit a left bracket operator to pcstream      *	with function number, the maximum temp register, and total local bytes      *	until i figure out how to use them, regs 0 .. 11 are free.      *	one idea for one reg is to save the display pointer on block entry      */
end_comment

begin_macro
name|putlbracket
argument_list|(
argument|ftnno
argument_list|,
argument|localbytes
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ftnno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|localbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|MAXTP2REG
value|11
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|P2FLBRAC
argument_list|,
name|MAXTP2REG
argument_list|,
name|ftnno
argument_list|)
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|BITSPERBYTE
operator|*
name|localbytes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2FLBRAC | %3d | %d	"
argument_list|,
name|MAXTP2REG
argument_list|,
name|ftnno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d\n"
argument_list|,
name|BITSPERBYTE
operator|*
name|localbytes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit a right bracket operator      *	which for the binary (fortran) interface      *	forces the stack allocate and register mask      */
end_comment

begin_macro
name|putrbracket
argument_list|(
argument|ftnno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ftnno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|P2FRBRAC
argument_list|,
literal|0
argument_list|,
name|ftnno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2FRBRAC |   0 | %d\n"
argument_list|,
name|ftnno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit an eof operator      */
end_comment

begin_macro
name|puteof
argument_list|()
end_macro

begin_block
block|{
name|p2word
argument_list|(
name|P2FEOF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2FEOF\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	emit a dot operator,      *	with a source file line number and name      *	if line is negative, there was an error on that line, but who cares?      */
end_comment

begin_macro
name|putdot
argument_list|(
argument|filename
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|str4len
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|<
literal|0
condition|)
block|{
name|line
operator|=
operator|-
name|line
expr_stmt|;
block|}
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|P2FEXPR
argument_list|,
name|length
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2FEXPR | %3d | %d	"
argument_list|,
name|length
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p2string
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put out a leaf node      */
end_comment

begin_macro
name|putleaf
argument_list|(
argument|op
argument_list|,
argument|lval
argument_list|,
argument|rval
argument_list|,
argument|type
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cgenflg
condition|)
return|return;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"[putleaf]"
argument_list|)
expr_stmt|;
case|case
name|P2ICON
case|:
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|P2ICON
argument_list|,
name|name
operator|!=
name|NIL
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|lval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2ICON | %3d | %d	"
argument_list|,
name|name
operator|!=
name|NIL
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d\n"
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|name
condition|)
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2NAME
case|:
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|P2NAME
argument_list|,
name|lval
operator|!=
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
name|p2word
argument_list|(
name|lval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2NAME | %3d | %d	"
argument_list|,
name|lval
operator|!=
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d	"
argument_list|,
name|lval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2REG
case|:
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|P2REG
argument_list|,
name|rval
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"P2REG | %3d | %d\n"
argument_list|,
name|rval
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
end_block

begin_comment
comment|/*      *	rvalues are just lvalues with indirection, except      *	special case for named globals, whose names are their rvalues      */
end_comment

begin_macro
name|putRV
argument_list|(
argument|name
argument_list|,
argument|level
argument_list|,
argument|offset
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|extname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|printname
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
if|if
condition|(
operator|(
name|level
operator|<=
literal|1
operator|)
operator|&&
operator|(
name|name
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|sprintf
argument_list|(
name|extname
argument_list|,
name|EXTFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printname
operator|=
name|extname
expr_stmt|;
block|}
else|else
block|{
name|printname
operator|=
name|name
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|P2NAME
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|printname
argument_list|)
expr_stmt|;
return|return;
block|}
name|putLV
argument_list|(
name|name
argument_list|,
name|level
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|putop
argument_list|(
argument|P2UNARY P2MUL
argument_list|,
argument|type
argument_list|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put out an lvalue       *	given a level and offset      *	special case for      *	    named globals, whose lvalues are just their names as constants.      *	    negative offsets, that are offsets from the frame pointer.      *	    positive offsets, that are offsets from argument pointer.      */
end_comment

begin_macro
name|putLV
argument_list|(
argument|name
argument_list|,
argument|level
argument_list|,
argument|offset
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|extname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|printname
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
if|if
condition|(
operator|(
name|level
operator|<=
literal|1
operator|)
operator|&&
operator|(
name|name
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|sprintf
argument_list|(
name|extname
argument_list|,
name|EXTFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printname
operator|=
name|extname
expr_stmt|;
block|}
else|else
block|{
name|printname
operator|=
name|name
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|ADDTYPE
argument_list|(
name|type
argument_list|,
name|P2PTR
argument_list|)
argument_list|,
name|printname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|level
operator|==
name|cbn
condition|)
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|putleaf
argument_list|(
name|P2REG
argument_list|,
literal|0
argument_list|,
name|P2FP
argument_list|,
name|ADDTYPE
argument_list|(
name|type
argument_list|,
name|P2PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|P2REG
argument_list|,
literal|0
argument_list|,
name|P2AP
argument_list|,
name|ADDTYPE
argument_list|(
name|type
argument_list|,
name|P2PTR
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|putleaf
argument_list|(
name|P2NAME
argument_list|,
operator|(
name|level
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dispsave
argument_list|)
operator|)
operator|+
name|FP_OFFSET
argument_list|,
literal|0
argument_list|,
name|P2PTR
operator||
name|P2CHAR
argument_list|,
name|DISPLAYNAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|P2NAME
argument_list|,
operator|(
name|level
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dispsave
argument_list|)
operator|)
operator|+
name|AP_OFFSET
argument_list|,
literal|0
argument_list|,
name|P2PTR
operator||
name|P2CHAR
argument_list|,
name|DISPLAYNAME
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
operator|-
name|offset
argument_list|,
literal|0
argument_list|,
name|P2INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|P2MINUS
argument_list|,
name|P2PTR
operator||
name|P2CHAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|P2INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|P2PLUS
argument_list|,
name|P2PTR
operator||
name|P2CHAR
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*      *	put out a floating point constant leaf node      *	the constant is declared in aligned data space      *	and a P2NAME leaf put out for it      */
end_comment

begin_macro
name|putCON8
argument_list|(
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|double
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|label
decl_stmt|;
name|char
name|name
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
name|putprintf
argument_list|(
literal|"	.data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.align 2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|putlab
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.double 0d%.20e"
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|PREFIXFORMAT
argument_list|,
name|LABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putleaf
argument_list|(
name|P2NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|P2DOUBLE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	 * put out either an lvalue or an rvalue for a constant string. 	 * an lvalue (for assignment rhs's) is the name as a constant,  	 * an rvalue (for parameters) is just the name. 	 */
end_comment

begin_macro
name|putCONG
argument_list|(
argument|string
argument_list|,
argument|length
argument_list|,
argument|required
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|required
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|name
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|label
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|others
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
name|putprintf
argument_list|(
literal|"	.data"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|putlab
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|cp
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.byte	0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|others
operator|=
literal|2
init|;
operator|(
name|others
operator|<=
literal|8
operator|)
operator|&&
operator|*
name|cp
condition|;
name|others
operator|++
control|)
block|{
name|putprintf
argument_list|(
literal|",0%o"
argument_list|,
literal|1
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pad
operator|=
name|length
operator|-
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|pad
operator|--
operator|>
literal|0
condition|)
block|{
name|putprintf
argument_list|(
literal|"	.byte	0%o"
argument_list|,
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|others
operator|=
literal|2
init|;
operator|(
name|others
operator|<=
literal|8
operator|)
operator|&&
operator|(
name|pad
operator|--
operator|>
literal|0
operator|)
condition|;
name|others
operator|++
control|)
block|{
name|putprintf
argument_list|(
literal|",0%o"
argument_list|,
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putprintf
argument_list|(
literal|"	.byte	0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
literal|"	.text"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|PREFIXFORMAT
argument_list|,
name|LABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|required
operator|==
name|RREQ
condition|)
block|{
name|putleaf
argument_list|(
name|P2NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|P2ARY
operator||
name|P2CHAR
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|P2PTR
operator||
name|P2CHAR
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	map a pascal type to a c type      *	this would be tail recursive, but i unfolded it into a for (;;).      *	this is sort of like isa and lwidth      *	a note on the types used by the portable c compiler:      *	    they are divided into a basic type (char, short, int, long, etc.)      *	    and qualifications on those basic types (pointer, function, array).      *	    the basic type is kept in the low 4 bits of the type descriptor,      *	    and the qualifications are arranged in two bit chunks, with the      *	    most significant on the right,      *	    and the least significant on the left      *		e.g. int *foo();      *			(a function returning a pointer to an integer)      *		is stored as      *<ptr><ftn><int>      *	so, we build types recursively      *	also, we know that /lib/f1 can only deal with 6 qualifications      *	so we stop the recursion there.  this stops infinite type recursion      *	through mutually recursive pointer types.      */
end_comment

begin_define
define|#
directive|define
name|MAXQUALS
value|6
end_define

begin_function
name|int
name|p2type
parameter_list|(
name|np
parameter_list|)
block|{
return|return
name|typerecur
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_macro
name|typerecur
argument_list|(
argument|np
argument_list|,
argument|quals
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quals
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|np
operator|==
name|NIL
operator|||
name|quals
operator|>
name|MAXQUALS
condition|)
block|{
return|return
name|P2UNDEF
return|;
block|}
switch|switch
condition|(
name|np
operator|->
name|class
condition|)
block|{
case|case
name|SCAL
case|:
case|case
name|RANGE
case|:
if|if
condition|(
name|np
operator|->
name|type
operator|==
operator|(
name|nl
operator|+
name|TDOUBLE
operator|)
condition|)
block|{
return|return
name|P2DOUBLE
return|;
block|}
switch|switch
condition|(
name|bytes
argument_list|(
name|np
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|np
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|P2CHAR
return|;
case|case
literal|2
case|:
return|return
name|P2SHORT
return|;
case|case
literal|4
case|:
return|return
name|P2INT
return|;
default|default:
name|panic
argument_list|(
literal|"p2type int"
argument_list|)
expr_stmt|;
block|}
case|case
name|STR
case|:
return|return
operator|(
name|P2ARY
operator||
name|P2CHAR
operator|)
return|;
case|case
name|RECORD
case|:
case|case
name|SET
case|:
return|return
name|P2STRTY
return|;
case|case
name|FILET
case|:
return|return
operator|(
name|P2PTR
operator||
name|P2STRTY
operator|)
return|;
case|case
name|CONST
case|:
case|case
name|VAR
case|:
case|case
name|FIELD
case|:
return|return
name|p2type
argument_list|(
name|np
operator|->
name|type
argument_list|)
return|;
case|case
name|TYPE
case|:
switch|switch
condition|(
name|nloff
argument_list|(
name|np
argument_list|)
condition|)
block|{
case|case
name|TNIL
case|:
return|return
operator|(
name|P2PTR
operator||
name|P2UNDEF
operator|)
return|;
case|case
name|TSTR
case|:
return|return
operator|(
name|P2ARY
operator||
name|P2CHAR
operator|)
return|;
case|case
name|TSET
case|:
return|return
name|P2STRTY
return|;
default|default :
return|return
operator|(
name|p2type
argument_list|(
name|np
operator|->
name|type
argument_list|)
operator|)
return|;
block|}
case|case
name|REF
case|:
case|case
name|WITHPTR
case|:
case|case
name|PTR
case|:
return|return
name|ADDTYPE
argument_list|(
name|typerecur
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|quals
operator|+
literal|1
argument_list|)
argument_list|,
name|P2PTR
argument_list|)
return|;
case|case
name|ARRAY
case|:
return|return
name|ADDTYPE
argument_list|(
name|typerecur
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|quals
operator|+
literal|1
argument_list|)
argument_list|,
name|P2ARY
argument_list|)
return|;
case|case
name|FUNC
case|:
comment|/* 		     * functions are really pointers to functions 		     * which return their underlying type. 		     */
return|return
name|ADDTYPE
argument_list|(
name|ADDTYPE
argument_list|(
name|typerecur
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|quals
operator|+
literal|2
argument_list|)
argument_list|,
name|P2FTN
argument_list|)
argument_list|,
name|P2PTR
argument_list|)
return|;
case|case
name|PROC
case|:
comment|/* 		     * procedures are pointers to functions  		     * which return integers (whether you look at them or not) 		     */
return|return
name|ADDTYPE
argument_list|(
name|ADDTYPE
argument_list|(
name|P2INT
argument_list|,
name|P2FTN
argument_list|)
argument_list|,
name|P2PTR
argument_list|)
return|;
case|case
name|FFUNC
case|:
case|case
name|FPROC
case|:
comment|/* 		     *	formal procedures and functions are pointers 		     *	to structures which describe their environment. 		     */
return|return
name|ADDTYPE
argument_list|(
name|P2PTR
argument_list|,
name|P2STRTY
argument_list|)
return|;
default|default :
name|panic
argument_list|(
literal|"p2type"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	add a most significant type modifier to a type      */
end_comment

begin_function
name|long
name|addtype
parameter_list|(
name|underlying
parameter_list|,
name|mtype
parameter_list|)
name|long
name|underlying
decl_stmt|;
name|long
name|mtype
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|underlying
operator|&
operator|~
name|P2BASETYPE
operator|)
operator|<<
name|P2TYPESHIFT
operator|)
operator||
name|mtype
operator||
operator|(
name|underlying
operator|&
name|P2BASETYPE
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      *	put a typed operator to the pcstream      */
end_comment

begin_macro
name|putop
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|p2opnames
index|[]
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s (%d) |   0 | %d\n"
argument_list|,
name|p2opnames
index|[
name|op
index|]
argument_list|,
name|op
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	put out a structure operator (STASG, STARG, STCALL, UNARY STCALL )      *	which looks just like a regular operator, only the size and      *	alignment go in the next consecutive words      */
end_comment

begin_macro
name|putstrop
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|,
argument|size
argument_list|,
argument|alignment
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alignment
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|p2opnames
index|[]
decl_stmt|;
if|if
condition|(
name|cgenflg
condition|)
return|return;
name|p2word
argument_list|(
name|TOF77
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s (%d) |   0 | %d	%d %d\n"
argument_list|,
name|p2opnames
index|[
name|op
index|]
argument_list|,
name|op
argument_list|,
name|type
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	the string names of p2ops      */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p2opnames
index|[]
init|=
block|{
literal|""
block|,
literal|"P2UNDEFINED"
block|,
comment|/* 1 */
literal|"P2NAME"
block|,
comment|/* 2 */
literal|"P2STRING"
block|,
comment|/* 3 */
literal|"P2ICON"
block|,
comment|/* 4 */
literal|"P2FCON"
block|,
comment|/* 5 */
literal|"P2PLUS"
block|,
comment|/* 6 */
literal|""
block|,
literal|"P2MINUS"
block|,
comment|/* 8		also unary == P2NEG */
literal|""
block|,
literal|"P2NEG"
block|,
literal|"P2MUL"
block|,
comment|/* 11		also unary == P2INDIRECT */
literal|""
block|,
literal|"P2INDIRECT"
block|,
literal|"P2AND"
block|,
comment|/* 14		also unary == P2ADDROF */
literal|""
block|,
literal|"P2ADDROF"
block|,
literal|"P2OR"
block|,
comment|/* 17 */
literal|""
block|,
literal|"P2ER"
block|,
comment|/* 19 */
literal|""
block|,
literal|"P2QUEST"
block|,
comment|/* 21 */
literal|"P2COLON"
block|,
comment|/* 22 */
literal|"P2ANDAND"
block|,
comment|/* 23 */
literal|"P2OROR"
block|,
comment|/* 24 */
literal|""
block|,
comment|/* 25 */
literal|""
block|,
comment|/* 26 */
literal|""
block|,
comment|/* 27 */
literal|""
block|,
comment|/* 28 */
literal|""
block|,
comment|/* 29 */
literal|""
block|,
comment|/* 30 */
literal|""
block|,
comment|/* 31 */
literal|""
block|,
comment|/* 32 */
literal|""
block|,
comment|/* 33 */
literal|""
block|,
comment|/* 34 */
literal|""
block|,
comment|/* 35 */
literal|""
block|,
comment|/* 36 */
literal|""
block|,
comment|/* 37 */
literal|""
block|,
comment|/* 38 */
literal|""
block|,
comment|/* 39 */
literal|""
block|,
comment|/* 40 */
literal|""
block|,
comment|/* 41 */
literal|""
block|,
comment|/* 42 */
literal|""
block|,
comment|/* 43 */
literal|""
block|,
comment|/* 44 */
literal|""
block|,
comment|/* 45 */
literal|""
block|,
comment|/* 46 */
literal|""
block|,
comment|/* 47 */
literal|""
block|,
comment|/* 48 */
literal|""
block|,
comment|/* 49 */
literal|""
block|,
comment|/* 50 */
literal|""
block|,
comment|/* 51 */
literal|""
block|,
comment|/* 52 */
literal|""
block|,
comment|/* 53 */
literal|""
block|,
comment|/* 54 */
literal|""
block|,
comment|/* 55 */
literal|"P2LISTOP"
block|,
comment|/* 56 */
literal|""
block|,
literal|"P2ASSIGN"
block|,
comment|/* 58 */
literal|"P2COMOP"
block|,
comment|/* 59 */
literal|"P2DIV"
block|,
comment|/* 60 */
literal|""
block|,
literal|"P2MOD"
block|,
comment|/* 62 */
literal|""
block|,
literal|"P2LS"
block|,
comment|/* 64 */
literal|""
block|,
literal|"P2RS"
block|,
comment|/* 66 */
literal|""
block|,
literal|"P2DOT"
block|,
comment|/* 68 */
literal|"P2STREF"
block|,
comment|/* 69 */
literal|"P2CALL"
block|,
comment|/* 70		also unary */
literal|""
block|,
literal|"P2UNARYCALL"
block|,
literal|"P2FORTCALL"
block|,
comment|/* 73		also unary */
literal|""
block|,
literal|"P2UNARYFORTCALL"
block|,
literal|"P2NOT"
block|,
comment|/* 76 */
literal|"P2COMPL"
block|,
comment|/* 77 */
literal|"P2INCR"
block|,
comment|/* 78 */
literal|"P2DECR"
block|,
comment|/* 79 */
literal|"P2EQ"
block|,
comment|/* 80 */
literal|"P2NE"
block|,
comment|/* 81 */
literal|"P2LE"
block|,
comment|/* 82 */
literal|"P2LT"
block|,
comment|/* 83 */
literal|"P2GE"
block|,
comment|/* 84 */
literal|"P2GT"
block|,
comment|/* 85 */
literal|"P2ULE"
block|,
comment|/* 86 */
literal|"P2ULT"
block|,
comment|/* 87 */
literal|"P2UGE"
block|,
comment|/* 88 */
literal|"P2UGT"
block|,
comment|/* 89 */
literal|"P2SETBIT"
block|,
comment|/* 90 */
literal|"P2TESTBIT"
block|,
comment|/* 91 */
literal|"P2RESETBIT"
block|,
comment|/* 92 */
literal|"P2ARS"
block|,
comment|/* 93 */
literal|"P2REG"
block|,
comment|/* 94 */
literal|"P2OREG"
block|,
comment|/* 95 */
literal|"P2CCODES"
block|,
comment|/* 96 */
literal|"P2FREE"
block|,
comment|/* 97 */
literal|"P2STASG"
block|,
comment|/* 98 */
literal|"P2STARG"
block|,
comment|/* 99 */
literal|"P2STCALL"
block|,
comment|/* 100		also unary */
literal|""
block|,
literal|"P2UNARYSTCALL"
block|,
literal|"P2FLD"
block|,
comment|/* 103 */
literal|"P2SCONV"
block|,
comment|/* 104 */
literal|"P2PCONV"
block|,
comment|/* 105 */
literal|"P2PMCONV"
block|,
comment|/* 106 */
literal|"P2PVCONV"
block|,
comment|/* 107 */
literal|"P2FORCE"
block|,
comment|/* 108 */
literal|"P2CBRANCH"
block|,
comment|/* 109 */
literal|"P2INIT"
block|,
comment|/* 110 */
literal|"P2CAST"
block|,
comment|/* 111 */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*      *	low level routines      */
end_comment

begin_comment
comment|/*      *	puts a long word on the pcstream      */
end_comment

begin_macro
name|p2word
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|long
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putw
argument_list|(
name|word
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put a length 0 mod 4 null padded string onto the pcstream      */
end_comment

begin_macro
name|p2string
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|wlen
init|=
operator|(
name|slen
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|int
name|plen
init|=
operator|(
name|wlen
operator|*
literal|4
operator|)
operator|-
name|slen
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|p
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|plen
condition|;
name|p
operator|++
control|)
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|plen
condition|;
name|p
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	puts a name on the pcstream      */
end_comment

begin_macro
name|p2name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pad
decl_stmt|;
name|fprintf
argument_list|(
name|pcstream
argument_list|,
name|NAMEFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pad
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pad
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|pad
operator|++
control|)
block|{
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|pcstream
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|opt
argument_list|(
literal|'k'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|NAMEFORMAT
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pad
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pad
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|pad
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*      *	put out a jump to a label      */
end_comment

begin_macro
name|putjbr
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|long
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printjbr
argument_list|(
name|LABELPREFIX
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	put out a jump to any kind of label      */
end_comment

begin_macro
name|printjbr
argument_list|(
argument|prefix
argument_list|,
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putprintf
argument_list|(
literal|"	jbr	"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putprintf
argument_list|(
name|PREFIXFORMAT
argument_list|,
literal|0
argument_list|,
name|prefix
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	another version of put to catch calls to put      */
end_comment

begin_macro
name|put
argument_list|(
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_block
block|{
name|putprintf
argument_list|(
literal|"#	PUT CALLED!: arg1 = %d arg2 = 0%o"
argument_list|,
literal|0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PC
end_endif

end_unit

