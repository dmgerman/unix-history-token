begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)conv.c 1.1 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PI
end_ifdef

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"pcops.h"
end_include

begin_endif
endif|#
directive|endif
endif|PC
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_comment
comment|/*  * Convert a p1 into a p2.  * Mostly used for different  * length integers and "to real" conversions.  */
end_comment

begin_macro
name|convert
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p1
operator|==
name|NIL
operator|||
name|p2
operator|==
name|NIL
condition|)
return|return;
switch|switch
condition|(
name|width
argument_list|(
name|p1
argument_list|)
operator|-
name|width
argument_list|(
name|p2
argument_list|)
condition|)
block|{
case|case
operator|-
literal|7
case|:
case|case
operator|-
literal|6
case|:
name|put1
argument_list|(
name|O_STOD
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|4
case|:
name|put1
argument_list|(
name|O_ITOD
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|3
case|:
case|case
operator|-
literal|2
case|:
name|put1
argument_list|(
name|O_STOI
argument_list|)
expr_stmt|;
return|return;
case|case
operator|-
literal|1
case|:
case|case
literal|0
case|:
case|case
literal|1
case|:
return|return;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|put1
argument_list|(
name|O_ITOS
argument_list|)
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"convert"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compat tells whether  * p1 and p2 are compatible  * types for an assignment like  * context, i.e. value parameters,  * indicies for 'in', etc.  */
end_comment

begin_macro
name|compat
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c1
operator|,
name|c2
expr_stmt|;
name|c1
operator|=
name|classify
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|c2
operator|=
name|classify
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
switch|switch
condition|(
name|c1
condition|)
block|{
case|case
name|TBOOL
case|:
case|case
name|TCHAR
case|:
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|TINT
case|:
if|if
condition|(
name|c2
operator|==
name|TINT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TDOUBLE
case|:
if|if
condition|(
name|c2
operator|==
name|TDOUBLE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifndef|#
directive|ifndef
name|PI0
if|if
condition|(
name|c2
operator|==
name|TINT
operator|&&
name|divflg
operator|==
literal|0
operator|&&
name|t
operator|!=
name|NIL
condition|)
block|{
name|divchk
operator|=
literal|1
expr_stmt|;
name|c1
operator|=
name|classify
argument_list|(
name|rvalue
argument_list|(
name|t
argument_list|,
name|NLNIL
argument_list|,
name|RREQ
argument_list|)
argument_list|)
expr_stmt|;
name|divchk
operator|=
name|NIL
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|TINT
condition|)
block|{
name|error
argument_list|(
literal|"Type clash: real is incompatible with integer"
argument_list|)
expr_stmt|;
name|cerror
argument_list|(
literal|"This resulted because you used '/' which always returns real rather"
argument_list|)
expr_stmt|;
name|cerror
argument_list|(
literal|"than 'div' which divides integers and returns integers"
argument_list|)
expr_stmt|;
name|divflg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|TSCAL
case|:
if|if
condition|(
name|c2
operator|!=
name|TSCAL
condition|)
break|break;
if|if
condition|(
name|scalar
argument_list|(
name|p1
argument_list|)
operator|!=
name|scalar
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|derror
argument_list|(
literal|"Type clash: non-identical scalar types"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TSTR
case|:
if|if
condition|(
name|c2
operator|!=
name|TSTR
condition|)
break|break;
if|if
condition|(
name|width
argument_list|(
name|p1
argument_list|)
operator|!=
name|width
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|derror
argument_list|(
literal|"Type clash: unequal length strings"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TNIL
case|:
if|if
condition|(
name|c2
operator|!=
name|TPTR
condition|)
break|break;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|TFILE
case|:
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
name|derror
argument_list|(
literal|"Type clash: files not allowed in this context"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
default|default:
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
if|if
condition|(
name|p1
operator|!=
name|p2
condition|)
block|{
name|derror
argument_list|(
literal|"Type clash: non-identical %s types"
argument_list|,
name|clnames
index|[
name|c1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|nl_flags
operator|&
name|NFILES
condition|)
block|{
name|derror
argument_list|(
literal|"Type clash: %ss with file components not allowed in this context"
argument_list|,
name|clnames
index|[
name|c1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|derror
argument_list|(
literal|"Type clash: %s is incompatible with %s"
argument_list|,
name|clnames
index|[
name|c1
index|]
argument_list|,
name|clnames
index|[
name|c2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_comment
comment|/*  * Rangechk generates code to  * check if the type p on top  * of the stack is in range for  * assignment to a variable  * of type q.  */
end_comment

begin_macro
name|rangechk
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|rp
decl_stmt|;
specifier|register
name|op
expr_stmt|;
name|int
name|wq
decl_stmt|,
name|wrp
decl_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'t'
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|rp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NIL
condition|)
return|return;
if|if
condition|(
name|q
operator|==
name|NIL
condition|)
return|return;
ifdef|#
directive|ifdef
name|OBJ
comment|/* 	     * When op is 1 we are checking length 	     * 4 numbers against length 2 bounds, 	     * and adding it to the opcode forces 	     * generation of appropriate tests. 	     */
name|op
operator|=
literal|0
expr_stmt|;
name|wq
operator|=
name|width
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|wrp
operator|=
name|width
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|op
operator|=
name|wq
operator|!=
name|wrp
operator|&&
operator|(
name|wq
operator|==
literal|4
operator|||
name|wrp
operator|==
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|class
operator|==
name|TYPE
condition|)
name|rp
operator|=
name|rp
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|rp
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
if|if
condition|(
name|rp
operator|->
name|range
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|wrp
operator|<=
literal|2
condition|)
name|put
argument_list|(
literal|3
argument_list|,
name|O_RANG2
operator|+
name|op
argument_list|,
operator|(
name|short
operator|)
name|rp
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
operator|(
name|short
operator|)
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|nl
operator|+
name|T4INT
condition|)
name|put
argument_list|(
literal|3
argument_list|,
name|O_RANG4
operator|+
name|op
argument_list|,
name|rp
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|hp21mx
condition|)
block|{
if|if
condition|(
name|wrp
operator|<=
literal|2
condition|)
name|put
argument_list|(
literal|3
argument_list|,
name|O_RANG2
operator|+
name|op
argument_list|,
operator|(
name|short
operator|)
name|rp
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
operator|(
name|short
operator|)
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|nl
operator|+
name|T4INT
condition|)
name|put
argument_list|(
literal|3
argument_list|,
name|O_RANG4
operator|+
name|op
argument_list|,
name|rp
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|!=
name|nl
operator|+
name|T2INT
operator|&&
name|rp
operator|!=
name|nl
operator|+
name|T4INT
condition|)
name|put
argument_list|(
literal|3
argument_list|,
name|O_RANG2
operator|+
name|op
argument_list|,
operator|(
name|short
operator|)
name|rp
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
operator|(
name|short
operator|)
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* 		     * Range whose lower bounds are 		     * zero can be treated as scalars. 		     */
case|case
name|SCAL
case|:
if|if
condition|(
name|wrp
operator|<=
literal|2
condition|)
name|put
argument_list|(
literal|2
argument_list|,
name|O_RSNG2
operator|+
name|op
argument_list|,
operator|(
name|short
operator|)
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|put
argument_list|(
literal|2
argument_list|,
name|O_RSNG4
operator|+
name|op
argument_list|,
name|rp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rangechk"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|OBJ
ifdef|#
directive|ifdef
name|PC
comment|/* 		 * what i want to do is make this and some other stuff 		 * arguments to a function call, which will do the rangecheck, 		 * and return the value of the current expression, or abort 		 * if the rangecheck fails. 		 * probably i need one rangecheck routine to return each c-type 		 * of value. 		 * also, i haven't figured out what the `other stuff' is. 		 */
name|putprintf
argument_list|(
literal|"#	call rangecheck"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_comment
comment|/*      *	if type p requires a range check,      *	    then put out the name of the checking function      *	for the beginning of a function call which is completed by postcheck.      *  (name1 is for a full check; name2 assumes a lower bound of zero)      */
end_comment

begin_macro
name|precheck
argument_list|(
argument|p
argument_list|,
argument|name1
argument_list|,
argument|name2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|opt
argument_list|(
literal|'t'
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|p
operator|==
name|NIL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|TYPE
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|type
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
if|if
condition|(
name|p
operator|!=
name|nl
operator|+
name|T4INT
condition|)
block|{
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ADDTYPE
argument_list|(
name|P2FTN
operator||
name|P2INT
argument_list|,
name|P2PTR
argument_list|)
argument_list|,
name|p
operator|->
name|range
index|[
literal|0
index|]
operator|!=
literal|0
condition|?
name|name1
else|:
name|name2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCAL
case|:
comment|/* 		     *	how could a scalar ever be out of range? 		     */
break|break;
default|default:
name|panic
argument_list|(
literal|"precheck"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*      *	if type p requires a range check,      *	    then put out the rest of the arguments of to the checking function      *	a call to which was started by precheck.      *	the first argument is what is being rangechecked (put out by rvalue),      *	the second argument is the lower bound of the range,      *	the third argument is the upper bound of the range.      */
end_comment

begin_macro
name|postcheck
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|opt
argument_list|(
literal|'t'
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|p
operator|==
name|NIL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|TYPE
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|type
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
if|if
condition|(
name|p
operator|!=
name|nl
operator|+
name|T4INT
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|range
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
name|p
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|P2INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|P2LISTOP
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
block|}
name|putleaf
argument_list|(
name|P2ICON
argument_list|,
name|p
operator|->
name|range
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|P2INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|P2LISTOP
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|P2CALL
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCAL
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"postcheck"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|conv
argument_list|(
argument|dub
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|dub
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|newfp
index|[
literal|2
index|]
decl_stmt|;
name|double
modifier|*
name|dp
init|=
name|dub
decl_stmt|;
name|long
modifier|*
name|lp
init|=
name|dub
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
name|long
name|mant
decl_stmt|;
name|newfp
index|[
literal|0
index|]
operator|=
name|dub
index|[
literal|0
index|]
operator|&
literal|0100000
expr_stmt|;
name|newfp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|0.0
condition|)
goto|goto
name|ret
goto|;
name|exp
operator|=
operator|(
operator|(
name|dub
index|[
literal|0
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0377
operator|)
operator|-
literal|0200
expr_stmt|;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
block|{
name|newfp
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|>
literal|63
condition|)
name|exp
operator|=
literal|63
expr_stmt|;
name|dub
index|[
literal|0
index|]
operator|&=
operator|~
literal|0177600
expr_stmt|;
name|dub
index|[
literal|0
index|]
operator||=
literal|0200
expr_stmt|;
name|mant
operator|=
operator|*
name|lp
expr_stmt|;
name|mant
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
name|newfp
index|[
literal|0
index|]
condition|)
name|mant
operator|=
operator|-
name|mant
expr_stmt|;
name|newfp
index|[
literal|0
index|]
operator||=
operator|(
name|mant
operator|>>
literal|17
operator|)
operator|&
literal|077777
expr_stmt|;
name|newfp
index|[
literal|1
index|]
operator||=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|mant
operator|>>
literal|1
argument_list|)
operator|)
operator|&
literal|0177400
operator|)
operator||
operator|(
name|exp
operator|<<
literal|1
operator|)
expr_stmt|;
name|ret
label|:
name|dub
index|[
literal|0
index|]
operator|=
name|newfp
index|[
literal|0
index|]
expr_stmt|;
name|dub
index|[
literal|1
index|]
operator|=
name|newfp
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

