begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)hash.c 1.1 %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"yy.h"
end_include

begin_comment
comment|/*  * The definition for the segmented hash tables.  */
end_comment

begin_struct
struct|struct
name|ht
block|{
name|int
modifier|*
name|ht_low
decl_stmt|;
name|int
modifier|*
name|ht_high
decl_stmt|;
name|int
name|ht_used
decl_stmt|;
block|}
name|htab
index|[
name|MAXHASH
index|]
struct|;
end_struct

begin_comment
comment|/*  * This is the array of keywords and their  * token values, which are hashed into the table  * by inithash.  */
end_comment

begin_decl_stmt
name|struct
name|kwtab
name|yykey
index|[]
init|=
block|{
literal|"and"
block|,
name|YAND
block|,
literal|"array"
block|,
name|YARRAY
block|,
literal|"assert"
block|,
name|YASSERT
block|,
literal|"begin"
block|,
name|YBEGIN
block|,
literal|"case"
block|,
name|YCASE
block|,
literal|"const"
block|,
name|YCONST
block|,
literal|"div"
block|,
name|YDIV
block|,
literal|"do"
block|,
name|YDO
block|,
literal|"downto"
block|,
name|YDOWNTO
block|,
literal|"else"
block|,
name|YELSE
block|,
literal|"end"
block|,
name|YEND
block|,
literal|"file"
block|,
name|YFILE
block|,
literal|"for"
block|,
name|YFOR
block|,
literal|"forward"
block|,
name|YFORWARD
block|,
literal|"function"
block|,
name|YFUNCTION
block|,
literal|"goto"
block|,
name|YGOTO
block|,
literal|"if"
block|,
name|YIF
block|,
literal|"in"
block|,
name|YIN
block|,
literal|"label"
block|,
name|YLABEL
block|,
literal|"mod"
block|,
name|YMOD
block|,
literal|"nil"
block|,
name|YNIL
block|,
literal|"not"
block|,
name|YNOT
block|,
literal|"of"
block|,
name|YOF
block|,
literal|"or"
block|,
name|YOR
block|,
literal|"packed"
block|,
name|YPACKED
block|,
literal|"procedure"
block|,
name|YPROCEDURE
block|,
literal|"program"
block|,
name|YPROG
block|,
literal|"record"
block|,
name|YRECORD
block|,
literal|"repeat"
block|,
name|YREPEAT
block|,
literal|"set"
block|,
name|YSET
block|,
literal|"then"
block|,
name|YTHEN
block|,
literal|"to"
block|,
name|YTO
block|,
literal|"type"
block|,
name|YTYPE
block|,
literal|"until"
block|,
name|YUNTIL
block|,
literal|"var"
block|,
name|YVAR
block|,
literal|"while"
block|,
name|YWHILE
block|,
literal|"with"
block|,
name|YWITH
block|,
literal|"oct"
block|,
name|YOCT
block|,
comment|/* non-standard Pascal */
literal|"hex"
block|,
name|YHEX
block|,
comment|/* non-standard Pascal */
literal|"external"
block|,
name|YEXTERN
block|,
comment|/* non-standard Pascal */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lastkey
init|=
operator|&
name|yykey
index|[
sizeof|sizeof
name|yykey
operator|/
sizeof|sizeof
name|yykey
index|[
literal|0
index|]
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Inithash initializes the hash table routines  * by allocating the first hash table segment using  * an already existing memory slot.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_macro
name|inithash
argument_list|()
end_macro

begin_else
else|#
directive|else
end_else

begin_macro
name|inithash
argument_list|(
argument|hshtab
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|hshtab
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
ifndef|#
directive|ifndef
name|PI0
specifier|static
name|int
name|hshtab
index|[
name|HASHINC
index|]
decl_stmt|;
endif|#
directive|endif
name|htab
index|[
literal|0
index|]
operator|.
name|ht_low
operator|=
name|hshtab
expr_stmt|;
name|htab
index|[
literal|0
index|]
operator|.
name|ht_high
operator|=
operator|&
name|hshtab
index|[
name|HASHINC
index|]
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|yykey
init|;
operator|*
name|ip
condition|;
name|ip
operator|+=
literal|2
control|)
name|hash
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|=
name|ip
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Hash looks up the s(ymbol) argument  * in the string table, entering it if  * it is not found. If save is 0, then  * the argument string is already in  * a safe place. Otherwise, if hash is  * entering the symbol for the first time  * it will save the symbol in the string  * table using savestr.  */
end_comment

begin_function
name|int
modifier|*
name|hash
parameter_list|(
name|s
parameter_list|,
name|save
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|save
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|h
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
modifier|*
name|sym
decl_stmt|;
name|struct
name|ht
modifier|*
name|htp
decl_stmt|;
name|int
name|sh
decl_stmt|;
comment|/* 	 * The hash function is a modular hash of 	 * the sum of the characters with the sum 	 * doubled before each successive character 	 * is added. 	 */
name|cp
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|cp
operator|=
name|token
expr_stmt|;
comment|/* default symbol to be hashed */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|i
operator|=
name|i
operator|*
literal|2
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
name|sh
operator|=
operator|(
name|i
operator|&
literal|077777
operator|)
operator|%
name|HASHINC
expr_stmt|;
name|cp
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|cp
operator|=
name|token
expr_stmt|;
comment|/* 	 * There are as many as MAXHASH active 	 * hash tables at any given point in time. 	 * The search starts with the first table 	 * and continues through the active tables 	 * as necessary. 	 */
for|for
control|(
name|htp
operator|=
name|htab
init|;
name|htp
operator|<
operator|&
name|htab
index|[
name|MAXHASH
index|]
condition|;
name|htp
operator|++
control|)
block|{
if|if
condition|(
name|htp
operator|->
name|ht_low
operator|==
name|NIL
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|,
name|HASHINC
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|-
literal|1
condition|)
block|{
name|yerror
argument_list|(
literal|"Ran out of memory (hash)"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|htp
operator|->
name|ht_low
operator|=
name|cp
expr_stmt|;
name|htp
operator|->
name|ht_high
operator|=
name|htp
operator|->
name|ht_low
operator|+
name|HASHINC
expr_stmt|;
name|cp
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|cp
operator|=
name|token
expr_stmt|;
block|}
name|h
operator|=
name|htp
operator|->
name|ht_low
operator|+
name|sh
expr_stmt|;
comment|/* 		 * quadratic rehash increment 		 * starts at 1 and incremented 		 * by two each rehash. 		 */
name|i
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|h
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|htp
operator|->
name|ht_used
operator|>
operator|(
name|HASHINC
operator|*
literal|3
operator|)
operator|/
literal|4
condition|)
break|break;
name|htp
operator|->
name|ht_used
operator|++
expr_stmt|;
if|if
condition|(
name|save
operator|!=
literal|0
condition|)
block|{
operator|*
name|h
operator|=
operator|(
name|int
operator|)
name|savestr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|h
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
name|sym
operator|=
operator|*
name|h
expr_stmt|;
if|if
condition|(
name|sym
operator|<
name|lastkey
operator|&&
name|sym
operator|>=
name|yykey
condition|)
name|sym
operator|=
operator|*
name|sym
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|pchar
operator|==
operator|*
name|cp
operator|&&
name|strcmp
argument_list|(
name|sym
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|h
operator|)
return|;
name|h
operator|+=
name|i
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|h
operator|>=
name|htp
operator|->
name|ht_high
condition|)
name|h
operator|-=
name|HASHINC
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|HASHINC
condition|)
do|;
block|}
name|yerror
argument_list|(
literal|"Ran out of hash tables"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

