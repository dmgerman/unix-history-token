begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*$Header: /p/tcsh/cvsroot/tcsh/win32/fork.c,v 1.13 2014/08/17 02:56:37 amold Exp $*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1980, 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*   * The fork() here is based on the ideas used by cygwin  * -amol  *  */
end_comment

begin_comment
comment|/*  * _M_ALPHA changes by Mark Tucker  */
end_comment

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ntport.h>
end_include

begin_include
include|#
directive|include
file|"forkdata.h"
end_include

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
literal|"memcpy"
name|,
literal|"memset"
name|,
literal|"memcmp"
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|push
name|,
name|3
name|)
end_pragma

begin_comment
comment|// forget about W4 here
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|u_long
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|ptr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|U_char
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|U_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|U_short
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|U_long
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|stack_probe
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*static void heap_init(void);*/
end_comment

begin_function_decl
name|BOOL
name|CreateWow64Events
parameter_list|(
name|DWORD
parameter_list|,
name|HANDLE
modifier|*
parameter_list|,
name|HANDLE
modifier|*
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//
end_comment

begin_comment
comment|// This is exported from the user program.
end_comment

begin_comment
comment|// It must return 0 for no error !!!!
end_comment

begin_function_decl
specifier|extern
name|int
name|fork_copy_user_mem
parameter_list|(
name|HANDLE
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * Apparently , visual c++ on the alpha does not place the  * fork data contiguously. To work around that, Mark created  * this structure (see forkdata.h)  * -amol  */
end_comment

begin_decl_stmt
name|ForkData
name|gForkData
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_M_IX86
end_ifdef

begin_decl_stmt
name|u_long
name|_old_exr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Saved exception registration for longjmp
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// _M_ALPHA
end_comment

begin_comment
comment|/*  * This hack is an attempt at getting to the exception registration  * in an architecture-independent way. It's critical for longjmp in a  * code using __try/__except blocks. Microsoft Visual C++ does a global  * unwind during a longjmp, and that can cause havoc if the exception   * registration stored in longjmp is lower(address wise, indicating a jump  * from below of the stack upward.) in the stack than the current  * registration (returned by NtCurrentTeb).  *  * This works with VC++, because that's all I have. With other compilers,   * there might be minimal changes required, depending on where the   * exception registration record is stored in the longjmp structure.  *  * -amol 2/6/97  */
end_comment

begin_function_decl
name|NT_TIB
modifier|*
function_decl|(
modifier|*
name|myNtCurrentTeb
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|GETEXCEPTIONREGIST
parameter_list|()
value|(((NT_TIB*)get_teb())->ExceptionList)
end_define

begin_define
define|#
directive|define
name|GETSTACKBASE
parameter_list|()
value|(((NT_TIB*)get_teb())->StackBase)
end_define

begin_decl_stmt
specifier|static
name|NT_TIB
modifier|*
name|the_tib
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_M_IA64
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_M_AMD64
argument_list|)
end_if

begin_function
name|void
modifier|*
name|get_teb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|the_tib
condition|)
return|return
name|the_tib
return|;
pragma|#
directive|pragma
name|warning
name|(
name|suppress
name|:
name|6309
name|)
name|myNtCurrentTeb
operator|=
operator|(
name|void
operator|*
operator|)
name|GetProcAddress
argument_list|(
name|LoadLibrary
argument_list|(
literal|"ntdll.dll"
argument_list|)
argument_list|,
literal|"NtCurrentTeb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|myNtCurrentTeb
condition|)
return|return
name|NULL
return|;
name|the_tib
operator|=
name|myNtCurrentTeb
argument_list|()
expr_stmt|;
if|if
condition|(
name|the_tib
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|the_tib
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|get_teb
value|NtCurrentTeb
end_define

begin_endif
endif|#
directive|endif
endif|_M_IA64
end_endif

begin_function
name|void
name|set_stackbase
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|GETSTACKBASE
argument_list|()
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * This must be called by the application as the first thing it does.  * -amol 2/6/97  *  * Well, maybe not the FIRST..  * -amol 11/10/97  */
end_comment

begin_decl_stmt
specifier|extern
name|BOOL
name|bIsWow64Process
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|fork_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|//heap_init(); Now called as the very first thing in silly_entry().
if|if
condition|(
name|__forked
condition|)
block|{
comment|// stack_probe probes out a decent-sized stack for the child,
comment|// since initially it has a very small stack (1 page).
comment|//
comment|/* not needed since default commit is set to 0.5MB in  		 * makefile.win32 		 * 		 * stack_probe((char *)__fork_stack_end - 64); 		 */
comment|//
comment|// Save the old Exception registration record and jump
comment|// off the cliff.
comment|//
ifdef|#
directive|ifdef
name|_M_IX86
name|_old_exr
operator|=
name|__fork_context
index|[
literal|6
index|]
expr_stmt|;
name|__fork_context
index|[
literal|6
index|]
operator|=
operator|(
name|int
operator|)
name|GETEXCEPTIONREGIST
argument_list|()
expr_stmt|;
comment|//tmp;
endif|#
directive|endif
endif|_M_ALPHA
comment|//
comment|// Whee !
name|longjmp
argument_list|(
name|__fork_context
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fork
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|rc
decl_stmt|;
name|size_t
name|stacksize
decl_stmt|;
name|char
name|modname
index|[
literal|512
index|]
decl_stmt|;
comment|/*FIXBUF*/
name|HANDLE
name|hProc
decl_stmt|,
name|hThread
decl_stmt|,
name|hArray
index|[
literal|2
index|]
decl_stmt|;
name|STARTUPINFO
name|si
decl_stmt|;
name|PROCESS_INFORMATION
name|pi
decl_stmt|;
name|SECURITY_ATTRIBUTES
name|sa
decl_stmt|;
name|DWORD
name|dwCreationflags
decl_stmt|;
name|unsigned
name|int
name|priority
decl_stmt|;
name|HANDLE
name|h64Parent
decl_stmt|,
name|h64Child
decl_stmt|;
ifndef|#
directive|ifndef
name|_M_ALPHA
name|unsigned
name|long
name|fork_stack_end
decl_stmt|;
endif|#
directive|endif
endif|_M_ALPHA
name|__fork_stack_begin
operator|=
name|GETSTACKBASE
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|_M_ALPHA
name|__fork_stack_end
operator|=
operator|&
name|fork_stack_end
expr_stmt|;
else|#
directive|else
name|__fork_stack_end
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
asm|__asm("mov $sp, $0");
endif|#
directive|endif
comment|/*_M_ALPHA*/
name|h64Parent
operator|=
name|h64Child
operator|=
name|NULL
expr_stmt|;
comment|//
comment|// Create two inheritable events
comment|//
name|sa
operator|.
name|nLength
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|lpSecurityDescriptor
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|bInheritHandle
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|__hforkchild
condition|)
name|__hforkchild
operator|=
name|CreateEvent
argument_list|(
operator|&
name|sa
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__hforkparent
condition|)
name|__hforkparent
operator|=
name|CreateEvent
argument_list|(
operator|&
name|sa
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|=
name|setjmp
argument_list|(
name|__fork_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|// child
ifdef|#
directive|ifdef
name|_M_IX86
comment|//
comment|// Restore old registration
comment|// -amol 2/2/97
name|GETEXCEPTIONREGIST
argument_list|()
operator|=
operator|(
expr|struct
name|_EXCEPTION_REGISTRATION_RECORD
operator|*
operator|)
name|_old_exr
expr_stmt|;
endif|#
directive|endif
comment|// _M_ALPHA
name|SetEvent
argument_list|(
name|__hforkchild
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"Child ready to rumble\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|__hforkparent
argument_list|,
name|FORK_TIMEOUT
argument_list|)
operator|!=
name|WAIT_OBJECT_0
condition|)
name|ExitProcess
argument_list|(
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|__hforkchild
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|__hforkparent
argument_list|)
expr_stmt|;
name|__hforkchild
operator|=
name|__hforkparent
operator|=
literal|0
expr_stmt|;
comment|//__asm { int 3};
name|restore_fds
argument_list|()
expr_stmt|;
name|STR_environ
operator|=
name|blk2short
argument_list|(
name|environ
argument_list|)
expr_stmt|;
name|environ
operator|=
name|short2blk
argument_list|(
name|STR_environ
argument_list|)
expr_stmt|;
comment|/* So that we can free it */
name|dprintf
argument_list|(
literal|"returning 0\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|copy_fds
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|si
argument_list|)
expr_stmt|;
comment|/* 	 * This f!@#!@% function returns the old value even if the std handles 	 * have been closed. 	 * Skip this step, since we know tcsh will do the right thing later. 	 *  	 si.hStdInput= GetStdHandle(STD_INPUT_HANDLE); 	 si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE); 	 si.hStdError = GetStdHandle(STD_ERROR_HANDLE); 	 */
if|if
condition|(
operator|!
name|GetModuleFileName
argument_list|(
name|GetModuleHandle
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|modname
argument_list|,
literal|512
argument_list|)
condition|)
block|{
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dwCreationflags
operator|=
name|GetPriorityClass
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|)
expr_stmt|;
name|priority
operator|=
name|GetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
name|rc
operator|=
name|CreateProcess
argument_list|(
name|NULL
argument_list|,
name|modname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|CREATE_SUSPENDED
operator||
name|dwCreationflags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|si
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ResetEvent
argument_list|(
name|__hforkchild
argument_list|)
expr_stmt|;
name|ResetEvent
argument_list|(
name|__hforkparent
argument_list|)
expr_stmt|;
name|hProc
operator|=
name|pi
operator|.
name|hProcess
expr_stmt|;
name|hThread
operator|=
name|pi
operator|.
name|hThread
expr_stmt|;
name|__forked
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Usage of events in the wow64 case: 	 * 	 * h64Parent : initially non-signalled 	 * h64Child  : initially non-signalled 	 * 	 *    1. Create the events, resume the child thread. 	 *    2. Child opens h64Parent to see if it is a child process in wow64 	 *    3. Child opens and sets h64Child to tell parent it's running. (This 	 *       step is needed because we can't copy to a process created in the 	 *       suspended state on wow64.) 	 *    4. Copy gForkData and then set h64Parent. This tells the child 	 *       that the parameters in the structure are trustworthy. 	 *    5. Wait for h64Child so that we know the child has created the stack 	 *       in dynamic memory. 	 * 	 *   The rest of the fork hack should now proceed as in x86 	 * 	 */
if|if
condition|(
name|bIsWow64Process
condition|)
block|{
comment|// allocate the heap for the child. this can be done even when
comment|// the child is suspended.
comment|// avoids inexplicable allocation failures in the child.
if|if
condition|(
name|VirtualAllocEx
argument_list|(
name|hProc
argument_list|,
name|__heap_base
argument_list|,
name|__heap_size
argument_list|,
name|MEM_RESERVE
argument_list|,
name|PAGE_READWRITE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"virtual allocex failed %d\n"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|VirtualAllocEx
argument_list|(
name|hProc
argument_list|,
name|__heap_base
argument_list|,
name|__heap_size
argument_list|,
name|MEM_COMMIT
argument_list|,
name|PAGE_READWRITE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"virtual allocex2 failed %d\n"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|{
name|char
modifier|*
name|stk
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|stk
operator|=
operator|(
name|char
operator|*
operator|)
name|__fork_stack_begin
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
operator|(
literal|1
operator|<<
literal|20
operator|)
operator|-
literal|65536
expr_stmt|;
name|dprintf
argument_list|(
literal|"begin is 0x%08x\n"
argument_list|,
name|stk
argument_list|)
expr_stmt|;
name|end
operator|=
name|VirtualAllocEx
argument_list|(
name|hProc
argument_list|,
name|stk
argument_list|,
operator|(
literal|1
operator|<<
literal|20
operator|)
operator|+
literal|65536
argument_list|,
name|MEM_RESERVE
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
block|}
comment|// Do NOT expect existing events
if|if
condition|(
operator|!
name|CreateWow64Events
argument_list|(
name|pi
operator|.
name|dwProcessId
argument_list|,
operator|&
name|h64Parent
argument_list|,
operator|&
name|h64Child
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|ResumeThread
argument_list|(
name|hThread
argument_list|)
expr_stmt|;
comment|// wait for the child to tell us it is running
comment|//if (WaitForSingleObject(h64Child,FORK_TIMEOUT) != WAIT_OBJECT_0) {
comment|//	rc = GetLastError();
comment|//	goto error;
comment|//}
name|hArray
index|[
literal|0
index|]
operator|=
name|h64Child
expr_stmt|;
name|hArray
index|[
literal|1
index|]
operator|=
name|hProc
expr_stmt|;
if|if
condition|(
name|WaitForMultipleObjects
argument_list|(
literal|2
argument_list|,
name|hArray
argument_list|,
name|FALSE
argument_list|,
name|FORK_TIMEOUT
argument_list|)
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|//
comment|// Copy all the shared data
comment|//
if|if
condition|(
operator|!
name|WriteProcessMemory
argument_list|(
name|hProc
argument_list|,
operator|&
name|gForkData
argument_list|,
operator|&
name|gForkData
argument_list|,
sizeof|sizeof
argument_list|(
name|ForkData
argument_list|)
argument_list|,
operator|&
name|rc
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|rc
operator|!=
sizeof|sizeof
argument_list|(
name|ForkData
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|!
name|bIsWow64Process
condition|)
block|{
name|rc
operator|=
name|ResumeThread
argument_list|(
name|hThread
argument_list|)
expr_stmt|;
block|}
comment|// in the wow64 case, the child will be waiting  on h64parent again.
comment|// set it, and then wait for h64child. This will mean the child has
comment|// a stack set up at the right location.
else|else
block|{
name|SetEvent
argument_list|(
name|h64Parent
argument_list|)
expr_stmt|;
name|hArray
index|[
literal|0
index|]
operator|=
name|h64Child
expr_stmt|;
name|hArray
index|[
literal|1
index|]
operator|=
name|hProc
expr_stmt|;
if|if
condition|(
name|WaitForMultipleObjects
argument_list|(
literal|2
argument_list|,
name|hArray
argument_list|,
name|FALSE
argument_list|,
name|FORK_TIMEOUT
argument_list|)
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|CloseHandle
argument_list|(
name|h64Parent
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|h64Child
argument_list|)
expr_stmt|;
name|h64Parent
operator|=
name|h64Child
operator|=
name|NULL
expr_stmt|;
block|}
comment|//
comment|// Wait for the child to start and init itself.
comment|// The timeout is so that we don't wait too long
comment|//
name|hArray
index|[
literal|0
index|]
operator|=
name|__hforkchild
expr_stmt|;
name|hArray
index|[
literal|1
index|]
operator|=
name|hProc
expr_stmt|;
if|if
condition|(
name|WaitForMultipleObjects
argument_list|(
literal|2
argument_list|,
name|hArray
argument_list|,
name|FALSE
argument_list|,
name|FORK_TIMEOUT
argument_list|)
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
name|int
name|err
init|=
name|GetLastError
argument_list|()
decl_stmt|;
comment|// For debugging purposes
name|dprintf
argument_list|(
literal|"wait failed err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Stop the child again and copy the stack and heap
comment|//
name|SuspendThread
argument_list|(
name|hThread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|hThread
argument_list|,
name|priority
argument_list|)
condition|)
block|{
name|priority
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
block|}
comment|// stack
name|stacksize
operator|=
operator|(
name|char
operator|*
operator|)
name|__fork_stack_begin
operator|-
operator|(
name|char
operator|*
operator|)
name|__fork_stack_end
expr_stmt|;
if|if
condition|(
operator|!
name|WriteProcessMemory
argument_list|(
name|hProc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|__fork_stack_end
argument_list|,
operator|(
name|char
operator|*
operator|)
name|__fork_stack_end
argument_list|,
operator|(
name|u_long
operator|)
name|stacksize
argument_list|,
operator|&
name|rc
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|//
comment|// copy heap itself
if|if
condition|(
operator|!
name|WriteProcessMemory
argument_list|(
name|hProc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|__heap_base
argument_list|,
operator|(
name|void
operator|*
operator|)
name|__heap_base
argument_list|,
call|(
name|DWORD
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|__heap_top
operator|-
operator|(
name|char
operator|*
operator|)
name|__heap_base
argument_list|)
argument_list|,
operator|&
name|rc
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
name|rc
operator|=
name|fork_copy_user_mem
argument_list|(
name|hProc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|// Release the child.
name|SetEvent
argument_list|(
name|__hforkparent
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ResumeThread
argument_list|(
name|hThread
argument_list|)
expr_stmt|;
name|__forked
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
literal|"forked process %d\n"
argument_list|,
name|pi
operator|.
name|dwProcessId
argument_list|)
expr_stmt|;
name|start_sigchild_thread
argument_list|(
name|hProc
argument_list|,
name|pi
operator|.
name|dwProcessId
argument_list|)
expr_stmt|;
name|close_copied_fds
argument_list|()
expr_stmt|;
name|CloseHandle
argument_list|(
name|hThread
argument_list|)
expr_stmt|;
comment|//
comment|// return process id to parent.
return|return
name|pi
operator|.
name|dwProcessId
return|;
name|error
label|:
name|__forked
operator|=
literal|0
expr_stmt|;
name|SetEvent
argument_list|(
name|__hforkparent
argument_list|)
expr_stmt|;
name|ResumeThread
argument_list|(
name|hThread
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hProc
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|h64Parent
condition|)
block|{
name|SetEvent
argument_list|(
name|h64Parent
argument_list|)
expr_stmt|;
comment|// don't let child block forever
name|CloseHandle
argument_list|(
name|h64Parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h64Child
condition|)
name|CloseHandle
argument_list|(
name|h64Child
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|""
name|,
name|off
name|)
end_pragma

begin_comment
comment|// The damn optimizer will remove the recursion, resulting in an infinite
end_comment

begin_comment
comment|// loop. -amol 4/17/97
end_comment

begin_function
name|void
name|stack_probe
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|&
name|x
operator|>
operator|(
name|int
operator|*
operator|)
name|ptr
condition|)
name|stack_probe
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|buf
expr_stmt|;
block|}
end_function

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|""
name|,
name|on
name|)
end_pragma

begin_comment
comment|//
end_comment

begin_comment
comment|// This function basically reserves some heap space.
end_comment

begin_comment
comment|// In the child it also commits the size committed in the parent.
end_comment

begin_function
name|void
name|heap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|__forked
condition|)
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|VirtualAlloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|__heap_base
argument_list|,
name|__heap_size
argument_list|,
name|MEM_RESERVE
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
operator|(
name|char
operator|*
operator|)
name|__heap_base
condition|)
block|{
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|bIsWow64Process
condition|)
name|ExitProcess
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|__heap_base
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VirtualAlloc
argument_list|(
name|__heap_base
argument_list|,
operator|(
name|char
operator|*
operator|)
name|__heap_top
operator|-
operator|(
name|char
operator|*
operator|)
name|__heap_base
argument_list|,
name|MEM_COMMIT
argument_list|,
name|PAGE_READWRITE
argument_list|)
condition|)
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|bIsWow64Process
condition|)
name|ExitProcess
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|__heap_base
expr_stmt|;
block|}
else|else
block|{
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|sysinfo
argument_list|)
expr_stmt|;
name|__heap_size
operator|=
name|sysinfo
operator|.
name|dwPageSize
operator|*
literal|1024
expr_stmt|;
name|__heap_base
operator|=
name|VirtualAlloc
argument_list|(
literal|0
argument_list|,
name|__heap_size
argument_list|,
name|MEM_RESERVE
operator||
name|MEM_TOP_DOWN
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|__heap_base
operator|==
literal|0
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|__heap_top
operator|=
name|__heap_base
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|// Implementation of sbrk() for the fmalloc family
end_comment

begin_comment
comment|//
end_comment

begin_function
name|void
modifier|*
name|sbrk
parameter_list|(
name|int
name|delta
parameter_list|)
block|{
name|void
modifier|*
name|retval
decl_stmt|;
name|void
modifier|*
name|old_top
init|=
name|__heap_top
decl_stmt|;
name|char
modifier|*
name|b
init|=
operator|(
name|char
operator|*
operator|)
name|__heap_top
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
return|return
name|__heap_top
return|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|retval
operator|=
name|VirtualAlloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|__heap_top
argument_list|,
name|delta
argument_list|,
name|MEM_COMMIT
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|b
operator|+=
name|delta
expr_stmt|;
name|__heap_top
operator|=
operator|(
name|void
operator|*
operator|)
name|b
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|VirtualAlloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|__heap_top
operator|-
name|delta
operator|)
argument_list|,
name|delta
argument_list|,
name|MEM_DECOMMIT
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|b
operator|-=
name|delta
expr_stmt|;
name|__heap_top
operator|=
operator|(
name|void
operator|*
operator|)
name|b
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|old_top
return|;
block|}
end_function

begin_comment
comment|/*  * Semantics of CreateWow64Events  *  * Try to open the events even if bOpenExisting is FALSE. This will help  * us detect name duplication.  *  *       1. If OpenEvent succeeds,and bOpenExisting is FALSE,  fail.  *  *       2. If OpenEvent failed,and bOpenExisting is TRUE fail  *  *       3. else create the events anew  *  */
end_comment

begin_define
define|#
directive|define
name|TCSH_WOW64_PARENT_EVENT_NAME
value|"tcsh-wow64-parent-event"
end_define

begin_define
define|#
directive|define
name|TCSH_WOW64_CHILD_EVENT_NAME
value|"tcsh-wow64-child-event"
end_define

begin_function
name|BOOL
name|CreateWow64Events
parameter_list|(
name|DWORD
name|pid
parameter_list|,
name|HANDLE
modifier|*
name|hParent
parameter_list|,
name|HANDLE
modifier|*
name|hChild
parameter_list|,
name|BOOL
name|bOpenExisting
parameter_list|)
block|{
name|SECURITY_ATTRIBUTES
name|sa
decl_stmt|;
name|char
name|parentname
index|[
literal|256
index|]
decl_stmt|,
name|childname
index|[
literal|256
index|]
decl_stmt|;
operator|*
name|hParent
operator|=
operator|*
name|hChild
operator|=
name|NULL
expr_stmt|;
comment|// make darn sure they're not inherited
name|sa
operator|.
name|nLength
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|lpSecurityDescriptor
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|bInheritHandle
operator|=
name|FALSE
expr_stmt|;
comment|//
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4995
name|)
comment|// This event tells the child to hold for gForkData to be copied
name|wsprintfA
argument_list|(
name|parentname
argument_list|,
literal|"Local\\%u-%s"
argument_list|,
name|pid
argument_list|,
name|TCSH_WOW64_PARENT_EVENT_NAME
argument_list|)
expr_stmt|;
name|wsprintfA
argument_list|(
name|childname
argument_list|,
literal|"Local\\%u-%s"
argument_list|,
name|pid
argument_list|,
name|TCSH_WOW64_CHILD_EVENT_NAME
argument_list|)
expr_stmt|;
pragma|#
directive|pragma
name|warning
name|(
name|default
name|:
name|4995
name|)
operator|*
name|hParent
operator|=
name|OpenEvent
argument_list|(
name|EVENT_ALL_ACCESS
argument_list|,
name|FALSE
argument_list|,
name|parentname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hParent
condition|)
block|{
if|if
condition|(
name|bOpenExisting
operator|==
name|FALSE
condition|)
block|{
comment|// didn't expect to be a child process
name|CloseHandle
argument_list|(
operator|*
name|hParent
argument_list|)
expr_stmt|;
operator|*
name|hParent
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|hChild
operator|=
name|OpenEvent
argument_list|(
name|EVENT_ALL_ACCESS
argument_list|,
name|FALSE
argument_list|,
name|childname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|hChild
condition|)
block|{
name|CloseHandle
argument_list|(
operator|*
name|hParent
argument_list|)
expr_stmt|;
operator|*
name|hParent
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|//event does not exist
if|if
condition|(
name|bOpenExisting
operator|==
name|TRUE
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|hParent
operator|=
name|CreateEvent
argument_list|(
operator|&
name|sa
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|parentname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|hParent
condition|)
return|return
name|FALSE
return|;
operator|*
name|hChild
operator|=
name|CreateEvent
argument_list|(
operator|&
name|sa
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|childname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|hChild
condition|)
block|{
name|CloseHandle
argument_list|(
operator|*
name|hParent
argument_list|)
expr_stmt|;
operator|*
name|hParent
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

