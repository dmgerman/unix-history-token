begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*$Header: /p/tcsh/cvsroot/tcsh/win32/support.c,v 1.14 2008/08/31 14:09:01 amold Exp $*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1980, 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * support.c  * various routines to do exec, etc.  *  */
end_comment

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<wincon.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|"ntport.h"
end_include

begin_include
include|#
directive|include
file|"sh.err.h"
end_include

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_include
include|#
directive|include
file|"nt.const.h"
end_include

begin_decl_stmt
name|DWORD
name|gdwPlatform
decl_stmt|,
name|gdwVersion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|__nt_really_exec
init|=
literal|0
decl_stmt|,
name|__nt_child_nohupped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DWORD
name|gdwStackSize
init|=
literal|524288
decl_stmt|;
end_decl_stmt

begin_comment
comment|//0.5 MB
end_comment

begin_function
name|void
name|path_slashify
parameter_list|(
name|char
modifier|*
name|pstr
parameter_list|)
block|{
while|while
condition|(
operator|*
name|pstr
condition|)
block|{
ifdef|#
directive|ifdef
name|DSPMBYTE
if|if
condition|(
name|Ismbyte1
argument_list|(
operator|*
name|pstr
argument_list|)
operator|&&
operator|*
operator|(
name|pstr
operator|+
literal|1
operator|)
condition|)
name|pstr
operator|++
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* DSPMBYTE */
if|if
condition|(
operator|*
name|pstr
operator|==
literal|'\\'
condition|)
operator|*
name|pstr
operator|=
literal|'/'
expr_stmt|;
name|pstr
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|do_nothing
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|p1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|p2
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|p3
parameter_list|,
name|unsigned
name|int
name|p4
parameter_list|,
name|uintptr_t
name|p5
parameter_list|)
block|{
name|UNREFERENCED_PARAMETER
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|p5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nt_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SECURE_CD
block|{
name|char
name|temp
index|[
literal|512
index|]
decl_stmt|;
comment|/*FIXBUF*/
specifier|extern
name|char
name|gcurr_drive
decl_stmt|;
if|if
condition|(
operator|!
name|GetCurrentDirectory
argument_list|(
literal|512
argument_list|,
name|temp
argument_list|)
condition|)
name|ExitProcess
argument_list|(
operator|(
name|DWORD
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gcurr_drive
operator|=
name|temp
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
endif|SECURE_CD
name|_set_invalid_parameter_handler
argument_list|(
name|do_nothing
argument_list|)
expr_stmt|;
name|init_stdio
argument_list|()
expr_stmt|;
name|nt_init_signals
argument_list|()
expr_stmt|;
name|nt_term_init
argument_list|()
expr_stmt|;
name|init_hb_subst
argument_list|()
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|init_shell_dll
argument_list|()
expr_stmt|;
name|init_plister
argument_list|()
expr_stmt|;
name|fork_init
argument_list|()
expr_stmt|;
name|init_clipboard
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|nt_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|nt_term_cleanup
argument_list|()
expr_stmt|;
name|nt_cleanup_signals
argument_list|()
expr_stmt|;
name|cleanup_netbios
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|caseify_pwd
parameter_list|(
name|char
modifier|*
name|curwd
parameter_list|)
block|{
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|WIN32_FIND_DATA
name|fdata
decl_stmt|;
name|HANDLE
name|hFind
decl_stmt|;
if|if
condition|(
name|gdwPlatform
operator|!=
name|VER_PLATFORM_WIN32_NT
condition|)
return|return;
if|if
condition|(
operator|*
name|curwd
operator|==
literal|'\\'
operator|&&
operator|(
operator|!
name|curwd
index|[
literal|1
index|]
operator|||
name|curwd
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
return|return;
name|sp
operator|=
name|curwd
operator|+
literal|3
expr_stmt|;
name|dp
operator|=
name|curwd
operator|+
literal|3
expr_stmt|;
do|do
block|{
name|p
operator|=
operator|*
name|sp
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|!=
literal|'\\'
condition|)
block|{
name|sp
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
name|hFind
operator|=
name|FindFirstFile
argument_list|(
name|curwd
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|hFind
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|FindClose
argument_list|(
name|hFind
argument_list|)
expr_stmt|;
name|s
operator|=
name|fdata
operator|.
name|cFileName
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|dp
operator|++
expr_stmt|;
name|sp
operator|=
name|dp
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|++
expr_stmt|;
name|dp
operator|=
name|sp
expr_stmt|;
block|}
block|}
name|sp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|defcwd
index|[
name|MAX_PATH
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|forward_slash_get_cwd
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|size_t
name|maxlen
parameter_list|)
block|{
name|char
modifier|*
name|ptemp
decl_stmt|;
name|Char
modifier|*
name|vp
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|path
operator|==
name|NULL
operator|)
operator|||
operator|(
name|maxlen
operator|==
literal|0
operator|)
condition|)
block|{
name|path
operator|=
operator|&
name|defcwd
index|[
literal|0
index|]
expr_stmt|;
name|maxlen
operator|=
name|MAX_PATH
expr_stmt|;
block|}
name|rc
operator|=
name|GetCurrentDirectory
argument_list|(
operator|(
name|DWORD
operator|)
name|maxlen
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|maxlen
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|vp
operator|=
name|varval
argument_list|(
name|STRNTcaseifypwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|STRNULL
condition|)
block|{
name|caseify_pwd
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|ptemp
operator|=
name|path
expr_stmt|;
name|path_slashify
argument_list|(
name|ptemp
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_function
name|void
name|getmachine
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|temp
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|vendor
decl_stmt|,
modifier|*
name|ostype
decl_stmt|;
name|OSVERSIONINFO
name|osver
decl_stmt|;
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|osver
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|osver
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sysinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sysinfo
argument_list|)
argument_list|)
expr_stmt|;
name|vendor
operator|=
literal|"Microsoft"
expr_stmt|;
name|tsetenv
argument_list|(
name|STRVENDOR
argument_list|,
name|str2short
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|osver
operator|.
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
argument_list|(
name|OSVERSIONINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetVersionEx
argument_list|(
operator|&
name|osver
argument_list|)
condition|)
block|{
name|MessageBox
argument_list|(
name|NULL
argument_list|,
literal|"GetVersionEx failed in getmachine"
argument_list|,
literal|"tcsh"
argument_list|,
name|MB_ICONHAND
argument_list|)
expr_stmt|;
name|ExitProcess
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|GetSystemInfo
argument_list|(
operator|&
name|sysinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|osver
operator|.
name|dwPlatformId
operator|==
name|VER_PLATFORM_WIN32_NT
condition|)
block|{
name|char
modifier|*
name|ostr
decl_stmt|;
name|ostype
operator|=
literal|"WindowsNT"
expr_stmt|;
name|ostr
operator|=
literal|"Windows NT"
expr_stmt|;
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"%s %d.%d Build %d (%s)"
argument_list|,
name|ostr
argument_list|,
name|osver
operator|.
name|dwMajorVersion
argument_list|,
name|osver
operator|.
name|dwMinorVersion
argument_list|,
name|osver
operator|.
name|dwBuildNumber
argument_list|,
name|osver
operator|.
name|szCSDVersion
index|[
literal|0
index|]
condition|?
name|osver
operator|.
name|szCSDVersion
else|:
literal|""
argument_list|)
expr_stmt|;
name|tsetenv
argument_list|(
name|STRHOSTTYPE
argument_list|,
name|str2short
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwPlatformId
operator|==
name|VER_PLATFORM_WIN32_WINDOWS
condition|)
block|{
name|ostype
operator|=
literal|"Windows9x"
expr_stmt|;
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"Win9x %d.%d:%d"
argument_list|,
name|osver
operator|.
name|dwMajorVersion
argument_list|,
name|osver
operator|.
name|dwMinorVersion
argument_list|,
name|LOWORD
argument_list|(
name|osver
operator|.
name|dwBuildNumber
argument_list|)
argument_list|)
expr_stmt|;
name|tsetenv
argument_list|(
name|STRHOSTTYPE
argument_list|,
name|str2short
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ostype
operator|=
literal|"WindowsWhoKnows"
expr_stmt|;
name|MessageBox
argument_list|(
name|NULL
argument_list|,
literal|"Unknown platform"
argument_list|,
literal|"tcsh"
argument_list|,
name|MB_ICONHAND
argument_list|)
expr_stmt|;
block|}
name|tsetenv
argument_list|(
name|STROSTYPE
argument_list|,
name|str2short
argument_list|(
name|ostype
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sysinfo
operator|.
name|wProcessorArchitecture
condition|)
block|{
case|case
name|PROCESSOR_ARCHITECTURE_INTEL
case|:
if|if
condition|(
operator|(
name|sysinfo
operator|.
name|wProcessorLevel
operator|<
literal|3
operator|)
operator|||
operator|(
name|sysinfo
operator|.
name|wProcessorLevel
operator|>
literal|9
operator|)
condition|)
name|sysinfo
operator|.
name|wProcessorLevel
operator|=
literal|3
expr_stmt|;
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"i%d86"
argument_list|,
name|sysinfo
operator|.
name|wProcessorLevel
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ARCHITECTURE_ALPHA
case|:
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"Alpha"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ARCHITECTURE_MIPS
case|:
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"Mips"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ARCHITECTURE_PPC
case|:
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"PPC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_ARCHITECTURE_AMD64
case|:
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"AMD64"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
name|tsetenv
argument_list|(
name|STRMACHTYPE
argument_list|,
name|str2short
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nt_exec
parameter_list|(
name|char
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
modifier|*
name|args
parameter_list|)
block|{
name|nt_execve
argument_list|(
name|prog
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nt_execve
parameter_list|(
name|char
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|envir
parameter_list|)
block|{
name|STARTUPINFO
name|si
decl_stmt|;
name|PROCESS_INFORMATION
name|pi
decl_stmt|;
name|HANDLE
name|htemp
decl_stmt|;
name|BOOL
name|bRet
decl_stmt|;
name|DWORD
name|type
init|=
literal|0
decl_stmt|;
name|DWORD
name|dwCreationflags
decl_stmt|;
name|unsigned
name|int
name|priority
decl_stmt|;
name|char
modifier|*
name|argv0
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cmdstr
decl_stmt|,
modifier|*
name|cmdend
decl_stmt|;
name|char
modifier|*
name|originalPtr
decl_stmt|;
name|unsigned
name|int
name|cmdsize
decl_stmt|,
name|cmdlen
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
modifier|*
name|savedargs
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|int
name|hasdot
init|=
literal|0
decl_stmt|;
name|int
name|is_winnt
decl_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|envir
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|savedargs
operator|=
name|args
expr_stmt|;
comment|/*  	 * This memory is not freed because we are exec()ed and will 	 * not be alive long. 	 */
name|originalPtr
operator|=
name|cmdstr
operator|=
name|heap_alloc
argument_list|(
name|MAX_PATH
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|is_winnt
operator|=
operator|(
name|gdwPlatform
operator|!=
name|VER_PLATFORM_WIN32_WINDOWS
operator|)
expr_stmt|;
name|cmdsize
operator|=
name|MAX_PATH
operator|<<
literal|2
expr_stmt|;
name|p2
operator|=
name|cmdstr
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
name|cmdlen
operator|+=
name|copy_quote_and_fix_slashes
argument_list|(
name|prog
argument_list|,
name|cmdstr
argument_list|,
operator|&
name|hasdot
argument_list|)
expr_stmt|;
name|p2
operator|+=
name|cmdlen
expr_stmt|;
comment|/* If the command was not quoted , 	   skip initial character we left for quote */
if|if
condition|(
operator|*
name|cmdstr
operator|!=
literal|'"'
condition|)
block|{
operator|*
name|cmdstr
operator|=
literal|'A'
expr_stmt|;
name|cmdstr
operator|++
expr_stmt|;
name|cmdsize
operator|--
expr_stmt|;
block|}
operator|*
name|p2
operator|=
literal|0
expr_stmt|;
name|cmdend
operator|=
name|p2
expr_stmt|;
if|if
condition|(
operator|!
name|is_winnt
condition|)
block|{
name|argv0
operator|=
name|NULL
expr_stmt|;
goto|goto
name|win95_directly_here
goto|;
block|}
else|else
block|{
name|argv0
operator|=
name|heap_alloc
argument_list|(
name|MAX_PATH
argument_list|)
expr_stmt|;
comment|/* not freed */
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|argv0
argument_list|,
name|MAX_PATH
argument_list|,
literal|"%s"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
block|}
name|retry
label|:
name|bRet
operator|=
name|GetBinaryType
argument_list|(
name|argv0
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"binary type for %s is %d\n"
argument_list|,
name|argv0
argument_list|,
name|bRet
argument_list|)
expr_stmt|;
comment|//
comment|// For NT, append .EXE and retry
comment|//
if|if
condition|(
name|is_winnt
operator|&&
operator|!
name|bRet
condition|)
block|{
comment|/* Don't append .EXE if it could be a script file */
if|if
condition|(
name|GetLastError
argument_list|()
operator|==
name|ERROR_BAD_EXE_FORMAT
condition|)
block|{
name|errno
operator|=
name|ENOEXEC
expr_stmt|;
if|if
condition|(
operator|!
name|__nt_only_start_exes
condition|)
name|try_shell_ex
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|//can't throw on error
return|return;
block|}
elseif|else
if|if
condition|(
name|retries
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|argv0
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|argv0
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|&&
operator|(
operator|(
name|argv0
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|argv0
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|&&
operator|(
operator|!
name|args
index|[
literal|1
index|]
operator|)
condition|)
if|if
condition|(
operator|!
name|__nt_only_start_exes
condition|)
name|try_shell_ex
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|retries
operator|>
literal|1
condition|)
block|{
return|return;
block|}
comment|// Try uppercase once and then lower case
comment|//
if|if
condition|(
operator|!
name|retries
condition|)
block|{
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|argv0
argument_list|,
name|MAX_PATH
argument_list|,
literal|"%s.exe"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|argv0
argument_list|,
name|MAX_PATH
argument_list|,
literal|"%s.EXE"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
comment|/* fix for clearcase */
block|}
name|retries
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|win95_directly_here
label|:
name|si
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|STARTUPINFO
argument_list|)
expr_stmt|;
name|si
operator|.
name|dwFlags
operator|=
name|STARTF_USESTDHANDLES
expr_stmt|;
name|htemp
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|htemp
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|si
operator|.
name|hStdInput
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
expr_stmt|;
name|htemp
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|htemp
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|si
operator|.
name|hStdOutput
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
expr_stmt|;
name|htemp
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|htemp
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|si
operator|.
name|hStdError
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
expr_stmt|;
name|args
operator|++
expr_stmt|;
comment|// the first arg is the command
name|dprintf
argument_list|(
literal|"nt_execve calling c_a_a_q"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|concat_args_and_quote
argument_list|(
name|args
argument_list|,
operator|&
name|originalPtr
argument_list|,
operator|&
name|cmdstr
argument_list|,
operator|&
name|cmdlen
argument_list|,
operator|&
name|cmdend
argument_list|,
operator|&
name|cmdsize
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"concat_args_and_quote failed\n"
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
name|originalPtr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail_return
goto|;
block|}
operator|*
name|cmdend
operator|=
literal|0
expr_stmt|;
name|dwCreationflags
operator|=
name|GetPriorityClass
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|__nt_child_nohupped
condition|)
block|{
name|dwCreationflags
operator||=
name|DETACHED_PROCESS
expr_stmt|;
block|}
name|priority
operator|=
name|GetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fix_path_for_child
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_winnt
condition|)
name|dwCreationflags
operator||=
name|CREATE_SUSPENDED
expr_stmt|;
name|re_cp
label|:
name|dprintf
argument_list|(
literal|"argv0 %s cmdstr %s\n"
argument_list|,
name|argv0
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
name|bRet
operator|=
name|CreateProcessA
argument_list|(
name|argv0
argument_list|,
name|cmdstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
comment|// need this for redirecting std handles
name|dwCreationflags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|si
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bRet
condition|)
block|{
if|if
condition|(
name|GetLastError
argument_list|()
operator|==
name|ERROR_BAD_EXE_FORMAT
condition|)
block|{
if|if
condition|(
operator|!
name|__nt_only_start_exes
condition|)
name|try_shell_ex
argument_list|(
name|savedargs
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOEXEC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GetLastError
argument_list|()
operator|==
name|ERROR_INVALID_PARAMETER
condition|)
block|{
comment|/* can't get invalid parameter, so this must be 			 *  the case when we exceed the command length limit. 			 */
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_winnt
operator|&&
operator|!
name|hasdot
condition|)
block|{
comment|//append '.' to the end if needed
operator|(
name|void
operator|)
name|StringCbCat
argument_list|(
name|cmdstr
argument_list|,
name|cmdsize
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|hasdot
operator|=
literal|1
expr_stmt|;
goto|goto
name|re_cp
goto|;
block|}
block|}
else|else
block|{
name|int
name|gui_app
decl_stmt|;
name|char
name|guivar
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
name|GetEnvironmentVariable
argument_list|(
literal|"TCSH_NOASYNCGUI"
argument_list|,
name|guivar
argument_list|,
literal|50
argument_list|)
condition|)
name|gui_app
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|is_winnt
operator|||
name|hasdot
condition|)
name|gui_app
operator|=
name|is_gui
argument_list|(
name|argv0
argument_list|)
expr_stmt|;
else|else
name|gui_app
operator|=
name|is_9x_gui
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_winnt
operator|&&
operator|!
name|SetThreadPriority
argument_list|(
name|pi
operator|.
name|hThread
argument_list|,
name|priority
argument_list|)
condition|)
block|{
name|priority
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|is_winnt
condition|)
name|ResumeThread
argument_list|(
name|pi
operator|.
name|hThread
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__nt_really_exec
operator|||
name|__nt_child_nohupped
operator|||
name|gui_app
condition|)
block|{
name|ExitProcess
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DWORD
name|exitcode
init|=
literal|0
decl_stmt|;
name|WaitForSingleObject
argument_list|(
name|pi
operator|.
name|hProcess
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|GetExitCodeProcess
argument_list|(
name|pi
operator|.
name|hProcess
argument_list|,
operator|&
name|exitcode
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pi
operator|.
name|hProcess
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pi
operator|.
name|hThread
argument_list|)
expr_stmt|;
comment|/* 			 * If output was redirected to /dev/clipboard, 			 * we need to close the pipe handles 			 */
if|if
condition|(
name|is_dev_clipboard_active
condition|)
block|{
name|CloseHandle
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|si
operator|.
name|hStdInput
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|si
operator|.
name|hStdOutput
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|si
operator|.
name|hStdError
argument_list|)
expr_stmt|;
name|WaitForSingleObject
argument_list|(
name|ghdevclipthread
argument_list|,
literal|60
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
name|ExitProcess
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
block|}
name|fail_return
label|:
name|CloseHandle
argument_list|(
name|si
operator|.
name|hStdInput
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|si
operator|.
name|hStdOutput
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|si
operator|.
name|hStdError
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This function from  Mark Tucker (mtucker@fiji.sidefx.com) */
end_comment

begin_function
name|int
name|quoteProtect
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|long
name|destsize
parameter_list|)
block|{
name|char
modifier|*
name|prev
decl_stmt|,
modifier|*
name|curr
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|src
init|;
operator|*
name|curr
condition|;
name|curr
operator|++
control|)
block|{
comment|// Protect " from MS-DOS expansion
if|if
condition|(
operator|*
name|curr
operator|==
literal|'"'
condition|)
block|{
comment|// Now, protect each preceeding backslash
for|for
control|(
name|prev
operator|=
name|curr
operator|-
literal|1
init|;
name|prev
operator|>=
name|src
operator|&&
operator|*
name|prev
operator|==
literal|'\\'
condition|;
name|prev
operator|--
control|)
block|{
operator|*
name|dest
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|destsize
operator|--
expr_stmt|;
if|if
condition|(
name|destsize
operator|==
literal|0
condition|)
return|return
name|ERROR_BUFFER_OVERFLOW
return|;
block|}
operator|*
name|dest
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|destsize
operator|--
expr_stmt|;
if|if
condition|(
name|destsize
operator|==
literal|0
condition|)
return|return
name|ERROR_BUFFER_OVERFLOW
return|;
block|}
operator|*
name|dest
operator|++
operator|=
operator|*
name|curr
expr_stmt|;
name|destsize
operator|--
expr_stmt|;
if|if
condition|(
name|destsize
operator|==
literal|0
condition|)
return|return
name|ERROR_BUFFER_OVERFLOW
return|;
block|}
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
return|return
name|NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|gethostname
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|GetComputerName
argument_list|(
name|buf
argument_list|,
operator|(
name|DWORD
operator|*
operator|)
operator|&
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nt_chdir
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
name|path
decl_stmt|;
if|if
condition|(
name|gdwPlatform
operator|!=
name|VER_PLATFORM_WIN32_NT
condition|)
block|{
while|while
condition|(
operator|*
name|tmp
condition|)
block|{
if|if
condition|(
operator|*
name|tmp
operator|==
literal|'/'
condition|)
operator|*
name|tmp
operator|=
literal|'\\'
expr_stmt|;
name|tmp
operator|++
expr_stmt|;
block|}
block|}
return|return
name|_chdir
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|WINAPI
name|uhef
parameter_list|(
name|EXCEPTION_POINTERS
modifier|*
name|lpep
parameter_list|)
block|{
name|ExitProcess
argument_list|(
name|lpep
operator|->
name|ExceptionRecord
operator|->
name|ExceptionCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|BOOL
name|CreateWow64Events
parameter_list|(
name|DWORD
parameter_list|,
name|HANDLE
modifier|*
parameter_list|,
name|HANDLE
modifier|*
parameter_list|,
name|BOOL
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// load kernel32 and look for iswow64. if not found, assume FALSE
end_comment

begin_decl_stmt
name|BOOL
name|bIsWow64Process
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_wow64
parameter_list|(
name|void
parameter_list|)
block|{
name|HMODULE
name|hlib
decl_stmt|;
comment|//BOOL (WINAPI *pfnIsWow64)(HANDLE,BOOL*);
name|FARPROC
name|pfnIsWow64
decl_stmt|;
name|bIsWow64Process
operator|=
name|FALSE
expr_stmt|;
name|hlib
operator|=
name|LoadLibrary
argument_list|(
literal|"kernel32.dll"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hlib
condition|)
block|{
return|return;
block|}
name|pfnIsWow64
operator|=
name|GetProcAddress
argument_list|(
name|hlib
argument_list|,
literal|"IsWow64Process"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfnIsWow64
condition|)
block|{
name|FreeLibrary
argument_list|(
name|hlib
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|pfnIsWow64
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|bIsWow64Process
argument_list|)
condition|)
name|bIsWow64Process
operator|=
name|FALSE
expr_stmt|;
name|FreeLibrary
argument_list|(
name|hlib
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|mainCRTStartup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * heap_init() MUST NOT be moved outside the entry point. Sometimes child  * processes may load random DLLs not loaded by the parent and   * use the heap address reserved for fmalloc() in the parent. This  * causes havoc as no dynamic memory can then be inherited.  *    */
end_comment

begin_function_decl
specifier|extern
name|void
name|heap_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<forkdata.h>
end_include

begin_function
name|void
name|silly_entry
parameter_list|(
name|void
modifier|*
name|peb
parameter_list|)
block|{
name|char
modifier|*
name|path1
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|char
name|temp
index|[
name|MAX_PATH
operator|+
literal|5
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|char
name|ptr1
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|char
name|ptr2
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|char
name|ptr3
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|OSVERSIONINFO
name|osver
decl_stmt|;
name|osver
operator|.
name|dwOSVersionInfoSize
operator|=
sizeof|sizeof
argument_list|(
name|OSVERSIONINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetVersionEx
argument_list|(
operator|&
name|osver
argument_list|)
condition|)
block|{
name|MessageBox
argument_list|(
name|NULL
argument_list|,
literal|"GetVersionEx failed"
argument_list|,
literal|"tcsh"
argument_list|,
name|MB_ICONHAND
argument_list|)
expr_stmt|;
name|ExitProcess
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|gdwVersion
operator|=
name|osver
operator|.
name|dwMajorVersion
expr_stmt|;
if|if
condition|(
name|gdwVersion
operator|<
literal|6
condition|)
comment|// no wow64 hackery for vista.
block|{
name|init_wow64
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_M_IX86
comment|// look at the explanation in fork.c for why we do these steps.
if|if
condition|(
name|bIsWow64Process
condition|)
block|{
name|HANDLE
name|h64Parent
decl_stmt|,
name|h64Child
decl_stmt|;
name|char
modifier|*
name|stk
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|DWORD
name|mb
init|=
operator|(
literal|1
operator|<<
literal|20
operator|)
decl_stmt|;
comment|// if we found the events, then we're the product of a fork()
if|if
condition|(
name|CreateWow64Events
argument_list|(
name|GetCurrentProcessId
argument_list|()
argument_list|,
operator|&
name|h64Parent
argument_list|,
operator|&
name|h64Child
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|h64Parent
operator|||
operator|!
name|h64Child
condition|)
return|return;
comment|// tell parent we're rolling
name|SetEvent
argument_list|(
name|h64Child
argument_list|)
expr_stmt|;
if|if
condition|(
name|WaitForSingleObject
argument_list|(
name|h64Parent
argument_list|,
name|FORK_TIMEOUT
argument_list|)
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
return|return;
block|}
comment|// if __forked is 0, we shouldn't have found the events
if|if
condition|(
operator|!
name|__forked
condition|)
return|return;
block|}
comment|// now create the stack
if|if
condition|(
operator|!
name|__forked
condition|)
block|{
name|stk
operator|=
name|VirtualAlloc
argument_list|(
name|NULL
argument_list|,
name|mb
operator|+
literal|65536
argument_list|,
name|MEM_COMMIT
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stk
condition|)
block|{
name|dprintf
argument_list|(
literal|"virtual alloc in parent failed %d\n"
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|end
operator|=
name|stk
operator|+
name|mb
operator|+
literal|65536
expr_stmt|;
name|end
operator|-=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|__fork_stack_begin
operator|=
name|end
expr_stmt|;
asm|__asm {
asm|mov esp,end
asm|};
name|set_stackbase
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|heap_init
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// child process
name|stk
operator|=
operator|(
name|char
operator|*
operator|)
name|__fork_stack_begin
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
name|mb
operator|-
literal|65536
expr_stmt|;
name|dprintf
argument_list|(
literal|"begin is 0x%08x\n"
argument_list|,
name|stk
argument_list|)
expr_stmt|;
name|end
operator|=
name|VirtualAlloc
argument_list|(
name|stk
argument_list|,
name|mb
operator|+
literal|65536
argument_list|,
name|MEM_RESERVE
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
block|{
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
literal|"virtual alloc 1 in child failed %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return;
block|}
name|stk
operator|=
name|VirtualAlloc
argument_list|(
name|end
argument_list|,
name|mb
operator|+
literal|65536
argument_list|,
name|MEM_COMMIT
argument_list|,
name|PAGE_READWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stk
condition|)
block|{
name|rc
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
literal|"virtual alloc 2 in child failed %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return;
block|}
name|end
operator|=
name|stk
operator|+
name|mb
operator|+
literal|65536
expr_stmt|;
asm|__asm {
asm|mov esp, end
asm|};
name|set_stackbase
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|SetEvent
argument_list|(
name|h64Child
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|h64Parent
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|h64Child
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|_M_IX86
name|SetFileApisToOEM
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bIsWow64Process
condition|)
name|heap_init
argument_list|()
expr_stmt|;
comment|/* If home is set, we only need to change '\' to '/' */
name|rc
operator|=
name|GetEnvironmentVariable
argument_list|(
literal|"HOME"
argument_list|,
name|buf
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|&&
operator|(
name|rc
operator|<
name|MAX_PATH
operator|)
condition|)
block|{
name|path_slashify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SetEnvironmentVariable
argument_list|(
literal|"HOME"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|skippy
goto|;
block|}
name|memset
argument_list|(
name|ptr1
argument_list|,
literal|0
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr2
argument_list|,
literal|0
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr3
argument_list|,
literal|0
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|osver
operator|.
name|dwPlatformId
operator|==
name|VER_PLATFORM_WIN32_NT
condition|)
block|{
name|GetEnvironmentVariable
argument_list|(
literal|"USERPROFILE"
argument_list|,
name|ptr1
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
name|GetEnvironmentVariable
argument_list|(
literal|"HOMEDRIVE"
argument_list|,
name|ptr2
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
name|GetEnvironmentVariable
argument_list|(
literal|"HOMEPATH"
argument_list|,
name|ptr3
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
name|ptr1
index|[
name|MAX_PATH
operator|-
literal|1
index|]
operator|=
name|ptr2
index|[
name|MAX_PATH
operator|-
literal|1
index|]
operator|=
name|ptr3
index|[
name|MAX_PATH
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4995
name|)
if|if
condition|(
operator|!
name|ptr1
index|[
literal|0
index|]
operator|||
name|osver
operator|.
name|dwMajorVersion
operator|<
literal|4
condition|)
block|{
name|wsprintfA
argument_list|(
name|temp
argument_list|,
literal|"%s%s"
argument_list|,
name|ptr2
index|[
literal|0
index|]
condition|?
name|ptr2
else|:
literal|"C:"
argument_list|,
name|ptr3
index|[
literal|0
index|]
condition|?
name|ptr3
else|:
literal|"\\"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwMajorVersion
operator|>=
literal|4
condition|)
block|{
name|wsprintfA
argument_list|(
name|temp
argument_list|,
literal|"%s"
argument_list|,
name|ptr1
argument_list|)
expr_stmt|;
block|}
pragma|#
directive|pragma
name|warning
name|(
name|default
name|:
name|4995
name|)
block|}
elseif|else
if|if
condition|(
name|osver
operator|.
name|dwPlatformId
operator|==
name|VER_PLATFORM_WIN32_WINDOWS
condition|)
block|{
name|rc
operator|=
name|GetWindowsDirectory
argument_list|(
name|ptr1
argument_list|,
name|MAX_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|MAX_PATH
condition|)
block|{
name|MessageBox
argument_list|(
name|NULL
argument_list|,
literal|"This should never happen"
argument_list|,
literal|"tcsh"
argument_list|,
name|MB_ICONHAND
argument_list|)
expr_stmt|;
name|ExitProcess
argument_list|(
literal|0xFF
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|StringCbPrintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|ptr1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MessageBox
argument_list|(
name|NULL
argument_list|,
literal|"Unknown platform"
argument_list|,
literal|"tcsh"
argument_list|,
name|MB_ICONHAND
argument_list|)
expr_stmt|;
block|}
name|path_slashify
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|SetEnvironmentVariable
argument_list|(
literal|"HOME"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|skippy
label|:
name|gdwPlatform
operator|=
name|osver
operator|.
name|dwPlatformId
expr_stmt|;
name|rc
operator|=
name|GetEnvironmentVariable
argument_list|(
literal|"Path"
argument_list|,
name|path1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|path1
operator|=
name|heap_alloc
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|GetEnvironmentVariable
argument_list|(
literal|"Path"
argument_list|,
name|path1
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|SetEnvironmentVariable
argument_list|(
literal|"Path"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*SetEnvironmentVariable("PATH",NULL);*/
name|SetEnvironmentVariable
argument_list|(
literal|"PATH"
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
name|path1
argument_list|)
expr_stmt|;
block|}
name|mainCRTStartup
argument_list|(
name|peb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Copy source into target, quote if it has space, also converting '/' to '\'.   *  * hasdot is set to 1 if source ends in a file extension  * return value is the  length of the string copied.  */
end_comment

begin_function
name|int
name|copy_quote_and_fix_slashes
parameter_list|(
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|hasdot
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|hasspace
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|save
operator|=
name|target
expr_stmt|;
comment|/* leave space for quote */
name|len
operator|=
literal|1
expr_stmt|;
name|target
operator|++
expr_stmt|;
name|hasspace
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|source
condition|)
block|{
if|if
condition|(
operator|*
name|source
operator|==
literal|'/'
condition|)
operator|*
name|source
operator|=
literal|'\\'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|source
operator|==
literal|' '
condition|)
name|hasspace
operator|=
literal|1
expr_stmt|;
operator|*
name|target
operator|++
operator|=
operator|*
name|source
expr_stmt|;
name|source
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
name|target
expr_stmt|;
comment|//source;
while|while
condition|(
operator|(
name|ptr
operator|>
name|save
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|!=
literal|'\\'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'.'
condition|)
operator|*
name|hasdot
operator|=
literal|1
expr_stmt|;
name|ptr
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|hasspace
condition|)
block|{
operator|*
name|save
operator|=
literal|'"'
expr_stmt|;
operator|*
name|target
operator|=
literal|'"'
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is a replacement for the old, horrible strcat() loop  * that was used to turn the argv[] array into a string for CreateProcess().  * It's about a zillion times faster.   * -amol 2/4/99  */
end_comment

begin_function
name|char
modifier|*
name|concat_args_and_quote
parameter_list|(
name|char
modifier|*
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|poriginalPtr
parameter_list|,
name|char
modifier|*
modifier|*
name|cstr
parameter_list|,
name|unsigned
name|int
modifier|*
name|clen
parameter_list|,
name|char
modifier|*
modifier|*
name|cend
parameter_list|,
name|unsigned
name|int
modifier|*
name|cmdsize
parameter_list|)
block|{
name|unsigned
name|int
name|argcount
decl_stmt|,
name|arglen
decl_stmt|,
name|cmdlen
decl_stmt|;
name|char
modifier|*
name|tempptr
decl_stmt|,
modifier|*
name|cmdend
decl_stmt|,
modifier|*
name|cmdstr
decl_stmt|;
name|short
name|quotespace
init|=
literal|0
decl_stmt|;
name|short
name|quotequote
init|=
literal|0
decl_stmt|;
name|short
name|noquoteprotect
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tempquotedbuf
decl_stmt|;
name|unsigned
name|long
name|tqlen
init|=
literal|256
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|dprintf
argument_list|(
literal|"entering concat_args_and_quote\n"
argument_list|)
expr_stmt|;
name|tempquotedbuf
operator|=
name|heap_alloc
argument_list|(
name|tqlen
argument_list|)
expr_stmt|;
name|noquoteprotect
operator|=
call|(
name|short
call|)
argument_list|(
name|varval
argument_list|(
name|STRNTnoquoteprotect
argument_list|)
operator|!=
name|STRNULL
argument_list|)
expr_stmt|;
comment|/*  	   quotespace hack needed since execv() would have separated args, but 	   createproces doesnt 	   -amol 9/14/96 	 */
name|cmdend
operator|=
operator|*
name|cend
expr_stmt|;
name|cmdstr
operator|=
operator|*
name|cstr
expr_stmt|;
name|cmdlen
operator|=
operator|*
name|clen
expr_stmt|;
name|argcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
operator|*
name|cmdend
operator|++
operator|=
literal|' '
expr_stmt|;
name|cmdlen
operator|++
expr_stmt|;
name|tempptr
operator|=
operator|*
name|args
expr_stmt|;
name|arglen
operator|=
literal|0
expr_stmt|;
name|argcount
operator|++
expr_stmt|;
comment|//dprintf("args is %s\n",*args);
if|if
condition|(
operator|!
operator|*
name|tempptr
condition|)
block|{
operator|*
name|cmdend
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|cmdend
operator|++
operator|=
literal|'"'
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|tempptr
condition|)
block|{
if|if
condition|(
operator|*
name|tempptr
operator|==
literal|' '
operator|||
operator|*
name|tempptr
operator|==
literal|'\t'
condition|)
name|quotespace
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tempptr
operator|==
literal|'"'
condition|)
name|quotequote
operator|=
literal|1
expr_stmt|;
name|tempptr
operator|++
expr_stmt|;
name|arglen
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arglen
operator|+
name|cmdlen
operator|+
literal|4
operator|>
operator|*
name|cmdsize
condition|)
block|{
comment|// +4 is if we have to quote
name|tempptr
operator|=
name|heap_realloc
argument_list|(
operator|*
name|poriginalPtr
argument_list|,
operator|*
name|cmdsize
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tempptr
condition|)
return|return
name|NULL
return|;
comment|// If it's not the same heap block, re-adjust the pointers.
if|if
condition|(
name|tempptr
operator|!=
operator|*
name|poriginalPtr
condition|)
block|{
name|cmdstr
operator|=
name|tempptr
operator|+
operator|(
name|cmdstr
operator|-
operator|*
name|poriginalPtr
operator|)
expr_stmt|;
name|cmdend
operator|=
name|tempptr
operator|+
operator|(
name|cmdend
operator|-
operator|*
name|poriginalPtr
operator|)
expr_stmt|;
operator|*
name|poriginalPtr
operator|=
name|tempptr
expr_stmt|;
block|}
operator|*
name|cmdsize
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|quotespace
condition|)
operator|*
name|cmdend
operator|++
operator|=
literal|'"'
expr_stmt|;
if|if
condition|(
operator|(
name|noquoteprotect
operator|==
literal|0
operator|)
operator|&&
name|quotequote
condition|)
block|{
name|tempquotedbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tempptr
operator|=
operator|&
name|tempquotedbuf
index|[
literal|0
index|]
expr_stmt|;
name|rc
operator|=
name|quoteProtect
argument_list|(
name|tempquotedbuf
argument_list|,
operator|*
name|args
argument_list|,
name|tqlen
argument_list|)
expr_stmt|;
while|while
condition|(
name|rc
operator|==
name|ERROR_BUFFER_OVERFLOW
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|tempquotedbuf
decl_stmt|;
name|tempquotedbuf
operator|=
name|heap_realloc
argument_list|(
name|tempquotedbuf
argument_list|,
name|tqlen
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tempquotedbuf
condition|)
block|{
name|heap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tqlen
operator|<<=
literal|1
expr_stmt|;
name|tempptr
operator|=
operator|&
name|tempquotedbuf
index|[
literal|0
index|]
expr_stmt|;
name|rc
operator|=
name|quoteProtect
argument_list|(
name|tempquotedbuf
argument_list|,
operator|*
name|args
argument_list|,
name|tqlen
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|tempptr
condition|)
block|{
operator|*
name|cmdend
operator|=
operator|*
name|tempptr
expr_stmt|;
name|cmdend
operator|++
expr_stmt|;
name|tempptr
operator|++
expr_stmt|;
block|}
name|cmdlen
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|tempptr
operator|=
operator|*
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|tempptr
condition|)
block|{
operator|*
name|cmdend
operator|=
operator|*
name|tempptr
expr_stmt|;
name|cmdend
operator|++
expr_stmt|;
name|tempptr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quotespace
condition|)
block|{
operator|*
name|cmdend
operator|++
operator|=
literal|'"'
expr_stmt|;
name|cmdlen
operator|+=
literal|2
expr_stmt|;
block|}
name|cmdlen
operator|+=
name|arglen
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
operator|*
name|clen
operator|=
name|cmdlen
expr_stmt|;
operator|*
name|cend
operator|=
name|cmdend
expr_stmt|;
operator|*
name|cstr
operator|=
name|cmdstr
expr_stmt|;
name|heap_free
argument_list|(
name|tempquotedbuf
argument_list|)
expr_stmt|;
return|return
name|cmdstr
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fix_path_for_child
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|Char
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|pathstr
decl_stmt|;
name|char
modifier|*
name|oldpath
decl_stmt|;
name|long
name|len
decl_stmt|;
name|vp
operator|=
name|varval
argument_list|(
name|STRNTlamepathfix
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|STRNULL
condition|)
block|{
name|len
operator|=
name|GetEnvironmentVariable
argument_list|(
literal|"PATH"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oldpath
operator|=
name|heap_alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathstr
operator|=
name|heap_alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|GetEnvironmentVariable
argument_list|(
literal|"PATH"
argument_list|,
name|oldpath
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pathstr
argument_list|,
name|oldpath
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|pathstr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
operator|*
name|ptr
operator|=
literal|'\\'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|SetEnvironmentVariable
argument_list|(
literal|"PATH"
argument_list|,
name|pathstr
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
name|pathstr
argument_list|)
expr_stmt|;
return|return
name|oldpath
return|;
comment|//freed in restore_path;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|restore_path
parameter_list|(
name|char
modifier|*
name|oldpath
parameter_list|)
block|{
if|if
condition|(
name|oldpath
condition|)
block|{
name|SetEnvironmentVariable
argument_list|(
literal|"PATH"
argument_list|,
name|oldpath
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
name|oldpath
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

