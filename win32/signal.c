begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*$Header: /p/tcsh/cvsroot/tcsh/win32/signal.c,v 1.13 2014/08/13 23:39:34 amold Exp $*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1980, 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * signal.c: Signal emulation hacks.  * -amol  *  */
end_comment

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"ntport.h"
end_include

begin_include
include|#
directive|include
file|"forkdata.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4055
name|)
end_pragma

begin_define
define|#
directive|define
name|SIGBAD
parameter_list|(
name|signo
parameter_list|)
value|( (signo)<=0 || (signo)>=NSIG)
end_define

begin_define
define|#
directive|define
name|fast_sigmember
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( (*(a)& (1<< (b-1)) ) )
end_define

begin_define
define|#
directive|define
name|inc_pending
parameter_list|(
name|a
parameter_list|)
value|(gPending[(a)]+=1)
end_define

begin_define
define|#
directive|define
name|suspend_main_thread
parameter_list|()
value|SuspendThread(hmainthr)
end_define

begin_define
define|#
directive|define
name|resume_main_thread
parameter_list|()
value|ResumeThread(hmainthr)
end_define

begin_function_decl
name|int
name|generic_handler
parameter_list|(
name|DWORD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ctrl_handler
parameter_list|(
name|DWORD
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|_child_list
block|{
name|DWORD
name|dwProcessId
decl_stmt|;
name|DWORD
name|exitcode
decl_stmt|;
name|struct
name|_child_list
modifier|*
name|next
decl_stmt|;
block|}
name|ChildListNode
typedef|;
end_typedef

begin_decl_stmt
name|Sigfunc
modifier|*
name|handlers
index|[
name|NSIG
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|gPending
index|[
name|NSIG
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|gBlockMask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ChildListNode
modifier|*
name|clist_h
decl_stmt|;
end_decl_stmt

begin_comment
comment|//head of list
end_comment

begin_decl_stmt
specifier|static
name|ChildListNode
modifier|*
name|clist_t
decl_stmt|;
end_decl_stmt

begin_comment
comment|// tail of list
end_comment

begin_decl_stmt
specifier|static
name|CRITICAL_SECTION
name|sigcritter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hmainthr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|hsigsusp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__is_suspended
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HANDLE
name|__halarm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HANDLE
name|__h_con_alarm
decl_stmt|,
name|__h_con_int
decl_stmt|,
name|__h_con_hup
decl_stmt|;
end_decl_stmt

begin_comment
comment|// must be done before fork;
end_comment

begin_function
name|void
name|nt_init_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|SetConsoleCtrlHandler
argument_list|(
operator|(
name|PHANDLER_ROUTINE
operator|)
name|ctrl_handler
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|InitializeCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|clist_t
operator|=
name|clist_h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|DuplicateHandle
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|GetCurrentThread
argument_list|()
argument_list|,
name|GetCurrentProcess
argument_list|()
argument_list|,
operator|&
name|hmainthr
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|DUPLICATE_SAME_ACCESS
argument_list|)
condition|)
block|{
name|ExitProcess
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|hsigsusp
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|__h_con_alarm
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|__h_con_int
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|__h_con_hup
operator|=
name|CreateEvent
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hsigsusp
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nt_cleanup_signals
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|__forked
condition|)
return|return;
name|DeleteCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hmainthr
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|hsigsusp
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|__h_con_alarm
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|__h_con_int
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|__h_con_hup
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|__halarm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sigaddset
parameter_list|(
name|sigset_t
modifier|*
name|set
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
if|if
condition|(
name|SIGBAD
argument_list|(
name|signo
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|set
operator||=
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sigdelset
parameter_list|(
name|sigset_t
modifier|*
name|set
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
if|if
condition|(
name|SIGBAD
argument_list|(
name|signo
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|set
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sigismember
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
if|if
condition|(
name|SIGBAD
argument_list|(
name|signo
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
operator|(
operator|*
name|set
operator|&
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|deliver_pending
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|temp
decl_stmt|;
name|int
name|sig
init|=
literal|1
decl_stmt|;
name|temp
operator|=
operator|~
name|gBlockMask
expr_stmt|;
while|while
condition|(
name|temp
operator|&&
operator|(
name|sig
operator|<
name|NSIG
operator|)
condition|)
block|{
if|if
condition|(
name|temp
operator|&
literal|0x01
condition|)
block|{
if|if
condition|(
name|gPending
index|[
name|sig
index|]
condition|)
block|{
comment|//gPending[sig]=0;
do|do
block|{
name|dprintf
argument_list|(
literal|"deliver_pending for sig %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|gPending
index|[
name|sig
index|]
operator|--
expr_stmt|;
name|generic_handler
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gPending
index|[
name|sig
index|]
operator|!=
literal|0
condition|)
do|;
block|}
block|}
name|temp
operator|>>=
literal|1
expr_stmt|;
name|sig
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sigprocmask
parameter_list|(
name|int
name|how
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|sigset_t
modifier|*
name|oset
parameter_list|)
block|{
if|if
condition|(
name|oset
condition|)
operator|*
name|oset
operator|=
name|gBlockMask
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|SIG_BLOCK
case|:
name|gBlockMask
operator||=
operator|*
name|set
expr_stmt|;
break|break;
case|case
name|SIG_UNBLOCK
case|:
name|gBlockMask
operator|&=
operator|(
operator|~
operator|(
operator|*
name|set
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|SIG_SETMASK
case|:
name|gBlockMask
operator|=
operator|*
name|set
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|how
operator|!=
name|SIG_BLOCK
condition|)
name|deliver_pending
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sigsuspend
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|mask
parameter_list|)
block|{
name|sigset_t
name|omask
decl_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|__is_suspended
operator|++
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
name|mask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"suspending main thread susp count %d\n"
argument_list|,
name|__is_suspended
argument_list|)
expr_stmt|;
do|do
block|{
name|WaitForSingleObject
argument_list|(
name|hsigsusp
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|__is_suspended
operator|>
literal|0
condition|)
do|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINTR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sigaction
parameter_list|(
name|int
name|signo
parameter_list|,
specifier|const
name|struct
name|sigaction
modifier|*
name|act
parameter_list|,
name|struct
name|sigaction
modifier|*
name|oact
parameter_list|)
block|{
if|if
condition|(
name|SIGBAD
argument_list|(
name|signo
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|oact
condition|)
block|{
name|oact
operator|->
name|sa_handler
operator|=
name|handlers
index|[
name|signo
index|]
expr_stmt|;
name|oact
operator|->
name|sa_mask
operator|=
literal|0
expr_stmt|;
name|oact
operator|->
name|sa_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|signo
operator|==
name|SIGHUP
operator|)
operator|&&
operator|(
name|act
operator|&&
operator|(
name|act
operator|->
name|sa_handler
operator|==
name|SIG_IGN
operator|)
operator|)
operator|&&
name|__forked
condition|)
name|__nt_child_nohupped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|act
condition|)
name|handlers
index|[
name|signo
index|]
operator|=
name|act
operator|->
name|sa_handler
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ctrl_handler
parameter_list|(
name|DWORD
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|==
name|CTRL_C_EVENT
operator|||
name|event
operator|==
name|CTRL_BREAK_EVENT
condition|)
block|{
name|SetEvent
argument_list|(
name|__h_con_int
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|event
operator|==
name|CTRL_CLOSE_EVENT
condition|)
block|{
name|SetEvent
argument_list|(
name|__h_con_hup
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|generic_handler
argument_list|(
name|event
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|generic_handler
parameter_list|(
name|DWORD
name|signo
parameter_list|)
block|{
name|int
name|blocked
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SIGBAD
argument_list|(
name|signo
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGINT
case|:
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|fast_sigmember
argument_list|(
operator|&
name|gBlockMask
argument_list|,
name|signo
argument_list|)
condition|)
block|{
name|inc_pending
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|==
name|SIG_DFL
condition|)
name|ExitProcess
argument_list|(
literal|0xC000013AL
argument_list|)
expr_stmt|;
else|else
name|handlers
index|[
name|signo
index|]
operator|(
name|signo
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|SIGBREAK
case|:
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|fast_sigmember
argument_list|(
operator|&
name|gBlockMask
argument_list|,
name|signo
argument_list|)
condition|)
block|{
name|inc_pending
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|==
name|SIG_DFL
condition|)
name|ExitProcess
argument_list|(
literal|0xC000013AL
argument_list|)
expr_stmt|;
else|else
name|handlers
index|[
name|signo
index|]
operator|(
name|signo
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|SIGHUP
case|:
comment|//CTRL_CLOSE_EVENT
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|fast_sigmember
argument_list|(
operator|&
name|gBlockMask
argument_list|,
name|signo
argument_list|)
condition|)
block|{
name|inc_pending
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|==
name|SIG_DFL
condition|)
name|ExitProcess
argument_list|(
literal|604
argument_list|)
expr_stmt|;
else|else
name|handlers
index|[
name|signo
index|]
operator|(
name|signo
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|SIGTERM
case|:
comment|//CTRL_LOGOFF_EVENT
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|fast_sigmember
argument_list|(
operator|&
name|gBlockMask
argument_list|,
name|signo
argument_list|)
condition|)
block|{
name|inc_pending
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|==
name|SIG_DFL
condition|)
name|ExitProcess
argument_list|(
literal|604
argument_list|)
expr_stmt|;
else|else
name|handlers
index|[
name|signo
index|]
operator|(
name|signo
operator|)
expr_stmt|;
block|}
else|else
name|ExitProcess
argument_list|(
literal|604
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGKILL
case|:
comment|//CTRL_SHUTDOWN_EVENT
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|fast_sigmember
argument_list|(
operator|&
name|gBlockMask
argument_list|,
name|signo
argument_list|)
condition|)
block|{
name|inc_pending
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|==
name|SIG_DFL
condition|)
name|ExitProcess
argument_list|(
literal|604
argument_list|)
expr_stmt|;
else|else
name|handlers
index|[
name|signo
index|]
operator|(
name|signo
operator|)
expr_stmt|;
block|}
else|else
name|ExitProcess
argument_list|(
literal|604
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGALRM
case|:
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|fast_sigmember
argument_list|(
operator|&
name|gBlockMask
argument_list|,
name|signo
argument_list|)
condition|)
block|{
name|inc_pending
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|==
name|SIG_DFL
condition|)
name|ExitProcess
argument_list|(
literal|604
argument_list|)
expr_stmt|;
else|else
name|handlers
index|[
name|signo
index|]
operator|(
name|signo
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|SIGCHLD
case|:
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|fast_sigmember
argument_list|(
operator|&
name|gBlockMask
argument_list|,
name|signo
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"inc pending for sig %d count %d\n"
argument_list|,
name|signo
argument_list|,
name|gPending
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
name|inc_pending
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|handlers
index|[
name|signo
index|]
operator|!=
name|SIG_DFL
condition|)
name|handlers
index|[
name|signo
index|]
operator|(
name|signo
operator|)
expr_stmt|;
block|}
break|break;
default|default:
name|ExitProcess
argument_list|(
literal|604
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|blocked
operator|&&
name|__is_suspended
condition|)
block|{
name|EnterCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|__is_suspended
operator|--
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"releasing suspension is_suspsend = %d\n"
argument_list|,
name|__is_suspended
argument_list|)
expr_stmt|;
name|SetEvent
argument_list|(
name|hsigsusp
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|Sigfunc
modifier|*
name|_nt_signal
parameter_list|(
name|int
name|signal
parameter_list|,
name|Sigfunc
modifier|*
name|handler
parameter_list|)
block|{
name|Sigfunc
modifier|*
name|old
decl_stmt|;
if|if
condition|(
name|SIGBAD
argument_list|(
name|signal
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|SIG_ERR
return|;
block|}
if|if
condition|(
name|signal
operator|==
name|SIGHUP
operator|&&
name|handler
operator|==
name|SIG_IGN
operator|&&
name|__forked
condition|)
block|{
name|__nt_child_nohupped
operator|=
literal|1
expr_stmt|;
block|}
name|old
operator|=
name|handlers
index|[
name|signal
index|]
expr_stmt|;
name|handlers
index|[
name|signal
index|]
operator|=
name|handler
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_function
name|int
name|waitpid
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|statloc
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|ChildListNode
modifier|*
name|temp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|EnterCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clist_h
condition|)
name|retcode
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|retcode
operator|=
name|clist_h
operator|->
name|dwProcessId
expr_stmt|;
if|if
condition|(
name|statloc
condition|)
operator|*
name|statloc
operator|=
name|clist_h
operator|->
name|exitcode
expr_stmt|;
name|temp
operator|=
name|clist_h
expr_stmt|;
name|clist_h
operator|=
name|clist_h
operator|->
name|next
expr_stmt|;
name|heap_free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|LeaveCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|int
name|__alarm_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|CALLBACK
name|alarm_callback
parameter_list|(
name|unsigned
name|long
name|interval
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|WaitForSingleObject
argument_list|(
name|__halarm
argument_list|,
name|interval
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|WAIT_TIMEOUT
condition|)
return|return ;
name|SetEvent
argument_list|(
name|__h_con_alarm
argument_list|)
expr_stmt|;
name|__alarm_set
operator|=
literal|0
expr_stmt|;
return|return;
comment|// consoleread() now waits for above event, and calls generic_handler to
comment|// handle SIGALRM in the main thread. That helps me avoid
comment|// problems with  fork() when we are in a secondary thread.
comment|//
comment|// This means sched, periodic etc will not be signalled unless consoleread
comment|// is called, but that's a reasonable risk, i think.
comment|// -amol 4/10/97
block|}
end_function

begin_function
name|unsigned
name|int
name|alarm
parameter_list|(
name|unsigned
name|int
name|seconds
parameter_list|)
block|{
name|unsigned
name|int
name|temp
decl_stmt|;
specifier|static
name|unsigned
name|int
name|prev_val
init|=
literal|0
decl_stmt|;
name|HANDLE
name|ht
decl_stmt|;
name|DWORD
name|tid
decl_stmt|;
name|SECURITY_ATTRIBUTES
name|secd
decl_stmt|;
name|secd
operator|.
name|nLength
operator|=
sizeof|sizeof
argument_list|(
name|secd
argument_list|)
expr_stmt|;
name|secd
operator|.
name|lpSecurityDescriptor
operator|=
name|NULL
expr_stmt|;
name|secd
operator|.
name|bInheritHandle
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|__halarm
condition|)
block|{
name|__halarm
operator|=
name|CreateEvent
argument_list|(
operator|&
name|secd
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__halarm
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|__alarm_set
condition|)
name|SetEvent
argument_list|(
name|__halarm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seconds
condition|)
block|{
name|__alarm_set
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|__alarm_set
operator|=
literal|1
expr_stmt|;
name|ht
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
name|gdwStackSize
argument_list|,
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|alarm_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
name|UIntToPtr
argument_list|(
name|seconds
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ht
condition|)
name|CloseHandle
argument_list|(
name|ht
argument_list|)
expr_stmt|;
name|temp
operator|=
name|prev_val
expr_stmt|;
name|prev_val
operator|=
name|seconds
operator|*
literal|1000
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
name|void
name|add_to_child_list
parameter_list|(
name|DWORD
name|dwpid
parameter_list|,
name|DWORD
name|exitcode
parameter_list|)
block|{
if|if
condition|(
name|clist_h
operator|==
name|NULL
condition|)
block|{
name|clist_h
operator|=
name|heap_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ChildListNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clist_h
condition|)
goto|goto
name|end
goto|;
name|clist_h
operator|->
name|dwProcessId
operator|=
name|dwpid
expr_stmt|;
name|clist_h
operator|->
name|exitcode
operator|=
name|exitcode
expr_stmt|;
name|clist_h
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|clist_t
operator|=
name|clist_h
expr_stmt|;
block|}
else|else
block|{
name|clist_t
operator|->
name|next
operator|=
name|heap_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ChildListNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clist_t
operator|->
name|next
condition|)
goto|goto
name|end
goto|;
name|clist_t
operator|=
name|clist_t
operator|->
name|next
expr_stmt|;
name|clist_t
operator|->
name|dwProcessId
operator|=
name|dwpid
expr_stmt|;
name|clist_h
operator|->
name|exitcode
operator|=
name|exitcode
expr_stmt|;
name|clist_t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
name|void
name|sig_child_callback
parameter_list|(
name|DWORD
name|pid
parameter_list|,
name|DWORD
name|exitcode
parameter_list|)
block|{
name|DWORD
name|ecode
init|=
literal|0
decl_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
name|add_to_child_list
argument_list|(
name|pid
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
name|suspend_main_thread
argument_list|()
expr_stmt|;
comment|//
comment|// pchild() tries to reset(), which crashes the thread
comment|//
name|__try
block|{
name|generic_handler
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
name|__except
argument_list|(
argument|ecode = GetExceptionCode()
argument_list|)
block|{
empty_stmt|;
block|}
name|resume_main_thread
argument_list|()
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|sigcritter
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|thread_args
block|{
name|DWORD
name|pid
decl_stmt|;
name|HANDLE
name|hproc
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|sigchild_thread
parameter_list|(
name|struct
name|thread_args
modifier|*
name|args
parameter_list|)
block|{
name|DWORD
name|exitcode
init|=
literal|0
decl_stmt|;
name|WaitForSingleObject
argument_list|(
name|args
operator|->
name|hproc
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
name|GetExitCodeProcess
argument_list|(
name|args
operator|->
name|hproc
argument_list|,
operator|&
name|exitcode
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|args
operator|->
name|hproc
argument_list|)
expr_stmt|;
name|sig_child_callback
argument_list|(
name|args
operator|->
name|pid
argument_list|,
name|exitcode
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"exiting sigchild thread for pid %d\n"
argument_list|,
name|args
operator|->
name|pid
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_sigchild_thread
parameter_list|(
name|HANDLE
name|hproc
parameter_list|,
name|DWORD
name|pid
parameter_list|)
block|{
name|struct
name|thread_args
modifier|*
name|args
init|=
name|heap_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|thread_args
argument_list|)
argument_list|)
decl_stmt|;
name|DWORD
name|tid
decl_stmt|;
name|HANDLE
name|hthr
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
block|{
return|return;
block|}
name|args
operator|->
name|hproc
operator|=
name|hproc
expr_stmt|;
name|args
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|dprintf
argument_list|(
literal|"creating sigchild thread for pid %d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|hthr
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
name|gdwStackSize
argument_list|,
operator|(
name|LPTHREAD_START_ROUTINE
operator|)
name|sigchild_thread
argument_list|,
operator|(
name|LPVOID
operator|)
name|args
argument_list|,
literal|0
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|hthr
condition|)
block|{
name|CloseHandle
argument_list|(
name|hthr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|kill
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|HANDLE
name|hproc
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
specifier|extern
name|DWORD
name|gdwPlatform
decl_stmt|;
name|BOOL
name|is_winnt
init|=
name|TRUE
decl_stmt|;
name|errno
operator|=
name|EPERM
expr_stmt|;
name|is_winnt
operator|=
operator|(
name|gdwPlatform
operator|!=
name|VER_PLATFORM_WIN32_WINDOWS
operator|)
expr_stmt|;
if|if
condition|(
name|is_winnt
condition|)
block|{
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|pid
operator|=
operator|-
name|pid
expr_stmt|;
comment|//no groups that we can actually do anything with.
block|}
block|}
else|else
block|{
comment|//win9x has -ve pids
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pid
operator|==
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|pid
operator|=
operator|-
name|pid
expr_stmt|;
comment|//no groups that we can actually do anything with.
block|}
block|}
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|7
case|:
name|hproc
operator|=
name|OpenProcess
argument_list|(
name|PROCESS_ALL_ACCESS
argument_list|,
name|FALSE
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|hproc
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ESRCH
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|"proc %d not found\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|"proc %d found\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sig
operator|==
literal|7
condition|)
block|{
if|if
condition|(
operator|!
name|TerminateProcess
argument_list|(
name|hproc
argument_list|,
literal|0xC000013AL
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|CloseHandle
argument_list|(
name|hproc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|GenerateConsoleCtrlEvent
argument_list|(
name|CTRL_C_EVENT
argument_list|,
name|pid
argument_list|)
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|GenerateConsoleCtrlEvent
argument_list|(
name|CTRL_BREAK_EVENT
argument_list|,
name|pid
argument_list|)
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|kill_by_wm_close
argument_list|(
name|pid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|ESRCH
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
default|default:
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|// nice(niceness)
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// where niceness is an integer in the range -6 to +7
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// A usual foreground process starts at level 9 in the chart below
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// the range -6 to +7 takes it from Base priority 15 down to 2.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Note that level 1 or> 15 are not allowed.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Priority Level 11 (niceness -2) or greater affects system performance,
end_comment

begin_comment
comment|//	so use with care.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// niceness defaults to  +4, which is lowest for background normal class.
end_comment

begin_comment
comment|// As in unix, +ve niceness indicates lower priorities.
end_comment

begin_comment
comment|/*************************************************************************** Niceness    Base    Priority class/thread priority              1    Idle, normal, or high class,    THREAD_PRIORITY_IDLE  +7          2    Idle class,                     THREAD_PRIORITY_LOWEST +6          3    Idle class,                     THREAD_PRIORITY_BELOW_NORMAL +5          4    Idle class,                     THREAD_PRIORITY_NORMAL +4          5    Background normal class,        THREAD_PRIORITY_LOWEST                     Idle class,                  THREAD_PRIORITY_ABOVE_NORMAL +3          6    Background normal class,        THREAD_PRIORITY_BELOW_NORMAL                     Idle class,                  THREAD_PRIORITY_HIGHEST +2          7    Foreground normal class,        THREAD_PRIORITY_LOWEST                     Background normal class,     THREAD_PRIORITY_NORMAL +1          8    Foreground normal class,        THREAD_PRIORITY_BELOW_NORMAL                     Background normal class,     THREAD_PRIORITY_ABOVE_NORMAL  0          9    Foreground normal class,        THREAD_PRIORITY_NORMAL                     Background normal class,     THREAD_PRIORITY_HIGHEST -1          10   Foreground normal class,        THREAD_PRIORITY_ABOVE_NORMAL -2          11    High class,                    THREAD_PRIORITY_LOWEST                     Foreground normal class,     THREAD_PRIORITY_HIGHEST -3          12    High class,                    THREAD_PRIORITY_BELOW_NORMAL -4          13    High class,                    THREAD_PRIORITY_NORMAL -5          14    High class,                    THREAD_PRIORITY_ABOVE_NORMAL -6          15    Idle, normal, or high class,   THREAD_PRIORITY_TIME_CRITICAL                    High class,                    THREAD_PRIORITY_HIGHEST       16    Real-time class, THREAD_PRIORITY_IDLE     22    Real-time class, THREAD_PRIORITY_LOWEST     23    Real-time class, THREAD_PRIORITY_BELOW_NORMAL     24    Real-time class, THREAD_PRIORITY_NORMAL     25    Real-time class, THREAD_PRIORITY_ABOVE_NORMAL     26    Real-time class, THREAD_PRIORITY_HIGHEST     31    Real-time class, THREAD_PRIORITY_TIME_CRITICAL ****************************************************************************/
end_comment

begin_function
name|int
name|nice
parameter_list|(
name|int
name|niceness
parameter_list|)
block|{
name|DWORD
name|pclass
init|=
name|IDLE_PRIORITY_CLASS
decl_stmt|;
name|int
name|priority
init|=
name|THREAD_PRIORITY_NORMAL
decl_stmt|;
if|if
condition|(
name|niceness
operator|<
operator|-
literal|6
operator|||
name|niceness
operator|>
literal|7
condition|)
block|{
name|errno
operator|=
name|EPERM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|niceness
condition|)
block|{
case|case
literal|7
case|:
name|pclass
operator|=
name|IDLE_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_LOWEST
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|pclass
operator|=
name|IDLE_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_BELOW_NORMAL
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|pclass
operator|=
name|IDLE_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_NORMAL
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pclass
operator|=
name|IDLE_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_ABOVE_NORMAL
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pclass
operator|=
name|IDLE_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_HIGHEST
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pclass
operator|=
name|NORMAL_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_LOWEST
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pclass
operator|=
name|NORMAL_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_BELOW_NORMAL
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|1
operator|)
case|:
name|pclass
operator|=
name|NORMAL_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_ABOVE_NORMAL
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|2
operator|)
case|:
name|pclass
operator|=
name|NORMAL_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_HIGHEST
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|3
operator|)
case|:
name|pclass
operator|=
name|HIGH_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_BELOW_NORMAL
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|4
operator|)
case|:
name|pclass
operator|=
name|HIGH_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_NORMAL
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|5
operator|)
case|:
name|pclass
operator|=
name|HIGH_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_ABOVE_NORMAL
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|6
operator|)
case|:
name|pclass
operator|=
name|HIGH_PRIORITY_CLASS
expr_stmt|;
name|priority
operator|=
name|THREAD_PRIORITY_HIGHEST
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|SetPriorityClass
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|pclass
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EPERM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|priority
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EPERM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

