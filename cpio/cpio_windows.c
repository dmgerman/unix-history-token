begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cpio_platform.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<sddl.h>
end_include

begin_include
include|#
directive|include
file|"cpio.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_define
define|#
directive|define
name|EPOC_TIME
value|(116444736000000000ULL)
end_define

begin_function_decl
specifier|static
name|void
name|cpio_dosmaperr
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Prepend "\\?\" to the path name and convert it to unicode to permit  * an extended-length path for a maximum total path length of 32767  * characters.  * see also http://msdn.microsoft.com/en-us/library/aa365247.aspx  */
end_comment

begin_function
specifier|static
name|wchar_t
modifier|*
name|permissive_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wn
decl_stmt|,
modifier|*
name|wnp
decl_stmt|;
name|wchar_t
modifier|*
name|ws
decl_stmt|,
modifier|*
name|wsp
decl_stmt|;
name|DWORD
name|l
decl_stmt|,
name|len
decl_stmt|,
name|slen
decl_stmt|,
name|alloclen
decl_stmt|;
name|int
name|unc
decl_stmt|;
name|len
operator|=
operator|(
name|DWORD
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|wn
operator|=
name|malloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|l
operator|=
name|MultiByteToWideChar
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|wn
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|wn
index|[
name|l
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* Get a full path names */
name|l
operator|=
name|GetFullPathNameW
argument_list|(
name|wn
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|wnp
operator|=
name|malloc
argument_list|(
name|l
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
name|GetFullPathNameW
argument_list|(
name|wn
argument_list|,
name|l
argument_list|,
name|wnp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
name|wn
operator|=
name|wnp
expr_stmt|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|==
literal|L'
expr|?'
operator|&&
name|wnp
index|[
literal|3
index|]
operator|==
literal|L'
expr|\\'
condition|)
comment|/* We have already permissive names. */
return|return
operator|(
name|wn
operator|)
return|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|==
literal|L'
expr|.'
operator|&&
name|wnp
index|[
literal|3
index|]
operator|==
literal|L'
expr|\\'
condition|)
block|{
comment|/* Device names */
if|if
condition|(
operator|(
operator|(
name|wnp
index|[
literal|4
index|]
operator|>=
literal|L'
expr|a'
operator|&&
name|wnp
index|[
literal|4
index|]
operator|<=
literal|L'
expr|z'
operator|)
operator|||
operator|(
name|wnp
index|[
literal|4
index|]
operator|>=
literal|L'
expr|A'
operator|&&
name|wnp
index|[
literal|4
index|]
operator|<=
literal|L'
expr|Z'
operator|)
operator|)
operator|&&
name|wnp
index|[
literal|5
index|]
operator|==
literal|L'
expr|:'
operator|&&
name|wnp
index|[
literal|6
index|]
operator|==
literal|L'
expr|\\'
condition|)
name|wnp
index|[
literal|2
index|]
operator|=
literal|L'
expr|?'
expr_stmt|;
comment|/* Not device names. */
return|return
operator|(
name|wn
operator|)
return|;
block|}
name|unc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|!=
literal|L'
expr|\\'
condition|)
block|{
name|wchar_t
modifier|*
name|p
init|=
operator|&
name|wnp
index|[
literal|2
index|]
decl_stmt|;
comment|/* Skip server-name letters. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\\'
operator|&&
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
condition|)
block|{
name|wchar_t
modifier|*
name|rp
init|=
operator|++
name|p
decl_stmt|;
comment|/* Skip share-name letters. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\\'
operator|&&
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
operator|&&
name|p
operator|!=
name|rp
condition|)
block|{
comment|/* Now, match patterns such as 				 * "\\server-name\share-name\" */
name|wnp
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|unc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|alloclen
operator|=
name|slen
operator|=
literal|4
operator|+
operator|(
name|unc
operator|*
literal|4
operator|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|ws
operator|=
name|wsp
operator|=
name|malloc
argument_list|(
name|slen
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* prepend "\\?\" */
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
literal|L"\\\\?\\"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wsp
operator|+=
literal|4
expr_stmt|;
name|slen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|unc
condition|)
block|{
comment|/* append "UNC\" ---> "\\?\UNC\" */
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
literal|L"UNC\\"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wsp
operator|+=
literal|4
expr_stmt|;
name|slen
operator|-=
literal|4
expr_stmt|;
block|}
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
name|wnp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
name|ws
index|[
name|alloclen
operator|-
literal|1
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
return|return
operator|(
name|ws
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HANDLE
name|cpio_CreateFile
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|DWORD
name|dwDesiredAccess
parameter_list|,
name|DWORD
name|dwShareMode
parameter_list|,
name|LPSECURITY_ATTRIBUTES
name|lpSecurityAttributes
parameter_list|,
name|DWORD
name|dwCreationDisposition
parameter_list|,
name|DWORD
name|dwFlagsAndAttributes
parameter_list|,
name|HANDLE
name|hTemplateFile
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wpath
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
name|handle
operator|=
name|CreateFileA
argument_list|(
name|path
argument_list|,
name|dwDesiredAccess
argument_list|,
name|dwShareMode
argument_list|,
name|lpSecurityAttributes
argument_list|,
name|dwCreationDisposition
argument_list|,
name|dwFlagsAndAttributes
argument_list|,
name|hTemplateFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|(
name|handle
operator|)
return|;
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_PATH_NOT_FOUND
condition|)
return|return
operator|(
name|handle
operator|)
return|;
name|wpath
operator|=
name|permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpath
operator|==
name|NULL
condition|)
return|return
operator|(
name|handle
operator|)
return|;
name|handle
operator|=
name|CreateFileW
argument_list|(
name|wpath
argument_list|,
name|dwDesiredAccess
argument_list|,
name|dwShareMode
argument_list|,
name|lpSecurityAttributes
argument_list|,
name|dwCreationDisposition
argument_list|,
name|dwFlagsAndAttributes
argument_list|,
name|hTemplateFile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|handle
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WINTIME
parameter_list|(
name|sec
parameter_list|,
name|usec
parameter_list|)
value|((Int32x32To64(sec, 10000000) + EPOC_TIME) + (usec * 10))
end_define

begin_function
specifier|static
name|int
name|__hutimes
parameter_list|(
name|HANDLE
name|handle
parameter_list|,
specifier|const
name|struct
name|__timeval
modifier|*
name|times
parameter_list|)
block|{
name|ULARGE_INTEGER
name|wintm
decl_stmt|;
name|FILETIME
name|fatime
decl_stmt|,
name|fmtime
decl_stmt|;
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
argument_list|,
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|fatime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fatime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
name|wintm
operator|.
name|QuadPart
operator|=
name|WINTIME
argument_list|(
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
argument_list|,
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|fmtime
operator|.
name|dwLowDateTime
operator|=
name|wintm
operator|.
name|LowPart
expr_stmt|;
name|fmtime
operator|.
name|dwHighDateTime
operator|=
name|wintm
operator|.
name|HighPart
expr_stmt|;
if|if
condition|(
name|SetFileTime
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
operator|&
name|fatime
argument_list|,
operator|&
name|fmtime
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|futimes
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|__timeval
modifier|*
name|times
parameter_list|)
block|{
return|return
operator|(
name|__hutimes
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
name|times
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|utimes
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|__timeval
modifier|*
name|times
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
name|handle
operator|=
name|cpio_CreateFile
argument_list|(
name|name
argument_list|,
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|cpio_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|__hutimes
argument_list|(
name|handle
argument_list|,
name|times
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following function was modified from PostgreSQL sources and is  * subject to the copyright below.  */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------  *  * win32error.c  *	  Map win32 error codes to errno values  *  * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group  *  * IDENTIFICATION  *	  $PostgreSQL: pgsql/src/port/win32error.c,v 1.4 2008/01/01 19:46:00 momjian Exp $  *  *-------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* PostgreSQL Database Management System (formerly known as Postgres, then as Postgres95)  Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group  Portions Copyright (c) 1994, The Regents of the University of California  Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without a written agreement is hereby granted, provided that the above copyright notice and this paragraph and the following two paragraphs appear in all copies.  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|DWORD
name|winerr
decl_stmt|;
name|int
name|doserr
decl_stmt|;
block|}
name|doserrors
index|[]
init|=
block|{
block|{
name|ERROR_INVALID_FUNCTION
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_FILE_NOT_FOUND
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_PATH_NOT_FOUND
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_TOO_MANY_OPEN_FILES
block|,
name|EMFILE
block|}
block|,
block|{
name|ERROR_ACCESS_DENIED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_INVALID_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_ARENA_TRASHED
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_NOT_ENOUGH_MEMORY
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_INVALID_BLOCK
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_BAD_ENVIRONMENT
block|,
name|E2BIG
block|}
block|,
block|{
name|ERROR_BAD_FORMAT
block|,
name|ENOEXEC
block|}
block|,
block|{
name|ERROR_INVALID_ACCESS
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_INVALID_DATA
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_INVALID_DRIVE
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_CURRENT_DIRECTORY
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_NOT_SAME_DEVICE
block|,
name|EXDEV
block|}
block|,
block|{
name|ERROR_NO_MORE_FILES
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_LOCK_VIOLATION
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_SHARING_VIOLATION
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_NETPATH
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_NETWORK_ACCESS_DENIED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_NET_NAME
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_FILE_EXISTS
block|,
name|EEXIST
block|}
block|,
block|{
name|ERROR_CANNOT_MAKE
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_FAIL_I24
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_INVALID_PARAMETER
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_NO_PROC_SLOTS
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_DRIVE_LOCKED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BROKEN_PIPE
block|,
name|EPIPE
block|}
block|,
block|{
name|ERROR_DISK_FULL
block|,
name|ENOSPC
block|}
block|,
block|{
name|ERROR_INVALID_TARGET_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_INVALID_HANDLE
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_WAIT_NO_CHILDREN
block|,
name|ECHILD
block|}
block|,
block|{
name|ERROR_CHILD_NOT_COMPLETE
block|,
name|ECHILD
block|}
block|,
block|{
name|ERROR_DIRECT_ACCESS_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_NEGATIVE_SEEK
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_SEEK_ON_DEVICE
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_DIR_NOT_EMPTY
block|,
name|ENOTEMPTY
block|}
block|,
block|{
name|ERROR_NOT_LOCKED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_PATHNAME
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_MAX_THRDS_REACHED
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_LOCK_FAILED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_ALREADY_EXISTS
block|,
name|EEXIST
block|}
block|,
block|{
name|ERROR_FILENAME_EXCED_RANGE
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_NESTING_NOT_ALLOWED
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_NOT_ENOUGH_QUOTA
block|,
name|ENOMEM
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|cpio_dosmaperr
parameter_list|(
name|unsigned
name|long
name|e
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|doserrors
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|doserrors
index|[
name|i
index|]
operator|.
name|winerr
operator|==
name|e
condition|)
block|{
name|errno
operator|=
name|doserrors
index|[
name|i
index|]
operator|.
name|doserr
expr_stmt|;
return|return;
block|}
block|}
comment|/* fprintf(stderr, "unrecognized win32 error code: %lu", e); */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

