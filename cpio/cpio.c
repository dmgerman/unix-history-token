begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"cpio_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD: src/usr.bin/cpio/cpio.c,v 1.15 2008/12/06 07:30:40 kientzle Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<archive.h>
end_include

begin_include
include|#
directive|include
file|<archive_entry.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MKDEV_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GRP_H
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LOCALE_H
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PWD_H
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNAL_H
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cpio.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"line_reader.h"
end_include

begin_include
include|#
directive|include
file|"passphrase.h"
end_include

begin_comment
comment|/* Fixed size of uname/gname caches. */
end_comment

begin_define
define|#
directive|define
name|name_cache_size
value|101
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|name_cache
block|{
name|int
name|probes
decl_stmt|;
name|int
name|hits
decl_stmt|;
name|size_t
name|size
decl_stmt|;
struct|struct
block|{
name|id_t
name|id
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|cache
index|[
name|name_cache_size
index|]
struct|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|extract_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|cpio_i64toa
parameter_list|(
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|cpio_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|entry_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_cache
parameter_list|(
name|struct
name|name_cache
modifier|*
name|cache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|list_item_verbose
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|long_help
argument_list|(
name|void
argument_list|)
name|__LA_DEAD
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|lookup_gname
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
name|gid_t
name|gid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_gname_helper
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|id_t
name|gid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|lookup_uname
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
name|uid_t
name|uid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_uname_helper
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|id_t
name|uid
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|mode_in
argument_list|(
expr|struct
name|cpio
operator|*
argument_list|)
name|__LA_DEAD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mode_list
argument_list|(
expr|struct
name|cpio
operator|*
argument_list|)
name|__LA_DEAD
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mode_out
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mode_pass
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|remove_leading_slash
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_time
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|void
argument_list|)
name|__LA_DEAD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|version
argument_list|(
name|void
argument_list|)
name|__LA_DEAD
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|passphrase_callback
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passphrase_free
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|16384
index|]
decl_stmt|;
name|struct
name|cpio
name|_cpio
decl_stmt|;
comment|/* Allocated on stack. */
name|struct
name|cpio
modifier|*
name|cpio
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|cpio
operator|=
operator|&
name|_cpio
expr_stmt|;
name|memset
argument_list|(
name|cpio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpio
argument_list|)
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|buff
operator|=
name|buff
expr_stmt|;
name|cpio
operator|->
name|buff_size
operator|=
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGACTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
block|{
comment|/* Ignore SIGPIPE signals. */
name|struct
name|sigaction
name|sa
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Set lafe_progname before calling lafe_warnc. */
name|lafe_setprogname
argument_list|(
operator|*
name|argv
argument_list|,
literal|"bsdcpio"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SETLOCALE
if|if
condition|(
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
operator|==
name|NULL
condition|)
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"Failed to set default locale"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cpio
operator|->
name|uid_override
operator|=
operator|-
literal|1
expr_stmt|;
name|cpio
operator|->
name|gid_override
operator|=
operator|-
literal|1
expr_stmt|;
name|cpio
operator|->
name|argv
operator|=
name|argv
expr_stmt|;
name|cpio
operator|->
name|argc
operator|=
name|argc
expr_stmt|;
name|cpio
operator|->
name|mode
operator|=
literal|'\0'
expr_stmt|;
name|cpio
operator|->
name|verbose
operator|=
literal|0
expr_stmt|;
name|cpio
operator|->
name|compress
operator|=
literal|'\0'
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator|=
name|ARCHIVE_EXTRACT_NO_AUTODIR
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_SECURE_SYMLINKS
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_PERM
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_FFLAGS
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_ACL
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_OWNER
expr_stmt|;
endif|#
directive|endif
name|cpio
operator|->
name|bytes_per_block
operator|=
literal|512
expr_stmt|;
name|cpio
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|cpio
operator|->
name|matching
operator|=
name|archive_match_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|matching
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|cpio_getopt
argument_list|(
name|cpio
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* GNU convention: --null, -0 */
name|cpio
operator|->
name|option_null
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* NetBSD/OpenBSD */
name|cpio
operator|->
name|option_append
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_atime_restore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|bytes_per_block
operator|=
literal|5120
expr_stmt|;
break|break;
case|case
name|OPTION_B64ENCODE
case|:
name|cpio
operator|->
name|add_filter
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* NetBSD/OpenBSD */
name|cpio
operator|->
name|bytes_per_block
operator|=
name|atoi
argument_list|(
name|cpio
operator|->
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|bytes_per_block
operator|<=
literal|0
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Invalid blocksize %s"
argument_list|,
name|cpio
operator|->
name|argument
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|format
operator|=
literal|"odc"
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_NO_AUTODIR
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* NetBSD/OpenBSD */
if|if
condition|(
name|archive_match_include_pattern_from_file
argument_list|(
name|cpio
operator|->
name|matching
argument_list|,
name|cpio
operator|->
name|argument
argument_list|,
name|cpio
operator|->
name|option_null
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Error : %s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|matching
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* NetBSD/OpenBSD/GNU cpio */
name|cpio
operator|->
name|filename
operator|=
name|cpio
operator|->
name|argument
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* POSIX 1997 */
if|if
condition|(
name|archive_match_exclude_pattern
argument_list|(
name|cpio
operator|->
name|matching
argument_list|,
name|cpio
operator|->
name|argument
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Error : %s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|matching
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_GRZIP
case|:
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* GNU cpio (also --format) */
name|cpio
operator|->
name|format
operator|=
name|cpio
operator|->
name|argument
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|long_help
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* NetBSD/OpenBSD */
name|cpio
operator|->
name|filename
operator|=
name|cpio
operator|->
name|argument
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* POSIX 1997 */
if|if
condition|(
name|cpio
operator|->
name|mode
operator|!=
literal|'\0'
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot use both -i and -%c"
argument_list|,
name|cpio
operator|->
name|mode
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* GNU tar, others */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* GNU tar, others */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
name|OPTION_INSECURE
case|:
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_SYMLINKS
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|option_follow_links
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_link
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_LRZIP
case|:
case|case
name|OPTION_LZ4
case|:
case|case
name|OPTION_LZMA
case|:
comment|/* GNU tar, others */
case|case
name|OPTION_LZOP
case|:
comment|/* GNU tar, others */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_TIME
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|option_numeric_uid_gid
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_PRESERVE_OWNER
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_OWNER
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|filename
operator|=
name|cpio
operator|->
name|argument
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* POSIX 1997 */
if|if
condition|(
name|cpio
operator|->
name|mode
operator|!=
literal|'\0'
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot use both -o and -%c"
argument_list|,
name|cpio
operator|->
name|mode
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* POSIX 1997 */
if|if
condition|(
name|cpio
operator|->
name|mode
operator|!=
literal|'\0'
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot use both -p and -%c"
argument_list|,
name|cpio
operator|->
name|mode
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|mode
operator|=
name|opt
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
expr_stmt|;
break|break;
case|case
name|OPTION_PASSPHRASE
case|:
name|cpio
operator|->
name|passphrase
operator|=
name|cpio
operator|->
name|argument
expr_stmt|;
break|break;
case|case
name|OPTION_PRESERVE_OWNER
case|:
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_OWNER
expr_stmt|;
break|break;
case|case
name|OPTION_QUIET
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* GNU cpio, also --owner */
comment|/* TODO: owner_parse should return uname/gname 			 * also; use that to set [ug]name_override. */
name|errmsg
operator|=
name|owner_parse
argument_list|(
name|cpio
operator|->
name|argument
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|lafe_warnc
argument_list|(
operator|-
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uid
operator|!=
operator|-
literal|1
condition|)
block|{
name|cpio
operator|->
name|uid_override
operator|=
name|uid
expr_stmt|;
name|cpio
operator|->
name|uname_override
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|gid
operator|!=
operator|-
literal|1
condition|)
block|{
name|cpio
operator|->
name|gid_override
operator|=
name|gid
expr_stmt|;
name|cpio
operator|->
name|gname_override
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_rename
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER
expr_stmt|;
break|break;
case|case
name|OPTION_UUENCODE
case|:
name|cpio
operator|->
name|add_filter
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|dot
operator|++
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION
case|:
comment|/* GNU convention */
name|version
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* 		 * cpio_getopt() handles -W specially, so it's not 		 * available here. 		 */
block|case 'W':
comment|/* Obscure, but useful GNU convention. */
block|break;
endif|#
directive|endif
case|case
literal|'y'
case|:
comment|/* tar convention */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* tar convention */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* tar convention */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Sanity-check args, error out on nonsensical combinations. 	 */
comment|/* -t implies -i if no mode was specified. */
if|if
condition|(
name|cpio
operator|->
name|option_list
operator|&&
name|cpio
operator|->
name|mode
operator|==
literal|'\0'
condition|)
name|cpio
operator|->
name|mode
operator|=
literal|'i'
expr_stmt|;
comment|/* -t requires -i */
if|if
condition|(
name|cpio
operator|->
name|option_list
operator|&&
name|cpio
operator|->
name|mode
operator|!=
literal|'i'
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Option -t requires -i"
argument_list|)
expr_stmt|;
comment|/* -n requires -it */
if|if
condition|(
name|cpio
operator|->
name|option_numeric_uid_gid
operator|&&
operator|!
name|cpio
operator|->
name|option_list
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Option -n requires -it"
argument_list|)
expr_stmt|;
comment|/* Can only specify format when writing */
if|if
condition|(
name|cpio
operator|->
name|format
operator|!=
name|NULL
operator|&&
name|cpio
operator|->
name|mode
operator|!=
literal|'o'
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Option --format requires -o"
argument_list|)
expr_stmt|;
comment|/* -l requires -p */
if|if
condition|(
name|cpio
operator|->
name|option_link
operator|&&
name|cpio
operator|->
name|mode
operator|!=
literal|'p'
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Option -l requires -p"
argument_list|)
expr_stmt|;
comment|/* -v overrides -V */
if|if
condition|(
name|cpio
operator|->
name|dot
operator|&&
name|cpio
operator|->
name|verbose
condition|)
name|cpio
operator|->
name|dot
operator|=
literal|0
expr_stmt|;
comment|/* TODO: Flag other nonsensical combinations. */
switch|switch
condition|(
name|cpio
operator|->
name|mode
condition|)
block|{
case|case
literal|'o'
case|:
comment|/* TODO: Implement old binary format in libarchive, 		   use that here. */
if|if
condition|(
name|cpio
operator|->
name|format
operator|==
name|NULL
condition|)
name|cpio
operator|->
name|format
operator|=
literal|"odc"
expr_stmt|;
comment|/* Default format */
name|mode_out
argument_list|(
name|cpio
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
while|while
condition|(
operator|*
name|cpio
operator|->
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|archive_match_include_pattern
argument_list|(
name|cpio
operator|->
name|matching
argument_list|,
operator|*
name|cpio
operator|->
name|argv
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Error : %s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|matching
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|cpio
operator|->
name|argc
expr_stmt|;
operator|++
name|cpio
operator|->
name|argv
expr_stmt|;
block|}
if|if
condition|(
name|cpio
operator|->
name|option_list
condition|)
name|mode_list
argument_list|(
name|cpio
argument_list|)
expr_stmt|;
else|else
name|mode_in
argument_list|(
name|cpio
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|*
name|cpio
operator|->
name|argv
operator|==
name|NULL
operator|||
operator|*
operator|*
name|cpio
operator|->
name|argv
operator|==
literal|'\0'
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-p mode requires a target directory"
argument_list|)
expr_stmt|;
name|mode_pass
argument_list|(
name|cpio
argument_list|,
operator|*
name|cpio
operator|->
name|argv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Must specify at least one of -i, -o, or -p"
argument_list|)
expr_stmt|;
block|}
name|archive_match_free
argument_list|(
name|cpio
operator|->
name|matching
argument_list|)
expr_stmt|;
name|free_cache
argument_list|(
name|cpio
operator|->
name|gname_cache
argument_list|)
expr_stmt|;
name|free_cache
argument_list|(
name|cpio
operator|->
name|uname_cache
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpio
operator|->
name|destdir
argument_list|)
expr_stmt|;
name|passphrase_free
argument_list|(
name|cpio
operator|->
name|ppbuff
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpio
operator|->
name|return_value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|lafe_getprogname
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Brief Usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  List:    %s -it< archive\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Extract: %s -i< archive\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Create:  %s -o< filenames> archive\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Help:    %s --help\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|long_help_msg
init|=
literal|"First option must be a mode specifier:\n"
literal|"  -i Input  -o Output  -p Pass\n"
literal|"Common Options:\n"
literal|"  -v Verbose filenames     -V  one dot per file\n"
literal|"Create: %p -o [options]< [list of files]> [archive]\n"
literal|"  -J,-y,-z,--lzma  Compress archive with xz/bzip2/gzip/lzma\n"
literal|"  --format {odc|newc|ustar}  Select archive format\n"
literal|"List: %p -it< [archive]\n"
literal|"Extract: %p -i [options]< [archive]\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Note that the word 'bsdcpio' will always appear in the first line  * of output.  *  * In particular, /bin/sh scripts that need to test for the presence  * of bsdcpio can use the following template:  *  * if (cpio --help 2>&1 | grep bsdcpio>/dev/null 2>&1 ) then \  *          echo bsdcpio; else echo not bsdcpio; fi  */
end_comment

begin_function
specifier|static
name|void
name|long_help
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prog
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|prog
operator|=
name|lafe_getprogname
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|strcmp
argument_list|(
name|prog
argument_list|,
literal|"bsdcpio"
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|"(bsdcpio)"
else|:
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s: manipulate archive files\n"
argument_list|,
name|prog
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|long_help_msg
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
name|fputs
argument_list|(
name|prog
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|version
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"bsdcpio %s - %s\n"
argument_list|,
name|BSDCPIO_VERSION_STRING
argument_list|,
name|archive_version_details
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mode_out
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|spare
decl_stmt|;
name|struct
name|lafe_line_reader
modifier|*
name|lr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|cpio
operator|->
name|option_append
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Append mode not yet supported."
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|archive_read_disk
operator|=
name|archive_read_disk_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|archive_read_disk
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Failed to allocate archive object"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|option_follow_links
condition|)
name|archive_read_disk_set_symlink_logical
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
expr_stmt|;
else|else
name|archive_read_disk_set_symlink_physical
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
expr_stmt|;
name|archive_read_disk_set_standard_lookup
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|archive
operator|=
name|archive_write_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|archive
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Failed to allocate archive object"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpio
operator|->
name|compress
condition|)
block|{
case|case
name|OPTION_GRZIP
case|:
name|r
operator|=
name|archive_write_add_filter_grzip
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|r
operator|=
name|archive_write_add_filter_xz
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LRZIP
case|:
name|r
operator|=
name|archive_write_add_filter_lrzip
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LZ4
case|:
name|r
operator|=
name|archive_write_add_filter_lz4
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LZMA
case|:
name|r
operator|=
name|archive_write_add_filter_lzma
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_LZOP
case|:
name|r
operator|=
name|archive_write_add_filter_lzop
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
case|case
literal|'y'
case|:
name|r
operator|=
name|archive_write_add_filter_bzip2
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|r
operator|=
name|archive_write_add_filter_gzip
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|r
operator|=
name|archive_write_add_filter_compress
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|archive_write_add_filter_none
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Requested compression not available"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpio
operator|->
name|add_filter
condition|)
block|{
case|case
literal|0
case|:
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
break|break;
case|case
name|OPTION_B64ENCODE
case|:
name|r
operator|=
name|archive_write_add_filter_b64encode
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_UUENCODE
case|:
name|r
operator|=
name|archive_write_add_filter_uuencode
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Requested filter not available"
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_set_format_by_name
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|archive_write_set_bytes_per_block
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|bytes_per_block
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|linkresolver
operator|=
name|archive_entry_linkresolver_new
argument_list|()
expr_stmt|;
name|archive_entry_linkresolver_set_strategy
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
name|archive_format
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|passphrase
operator|!=
name|NULL
condition|)
name|r
operator|=
name|archive_write_set_passphrase
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|passphrase
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|archive_write_set_passphrase_callback
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
argument_list|,
operator|&
name|passphrase_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The main loop:  Copy each file into the output archive. 	 */
name|r
operator|=
name|archive_write_open_filename
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
name|lafe_line_reader
argument_list|(
literal|"-"
argument_list|,
name|cpio
operator|->
name|option_null
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|lafe_line_reader_next
argument_list|(
name|lr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|file_to_archive
argument_list|(
name|cpio
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lafe_line_reader_free
argument_list|(
name|lr
argument_list|)
expr_stmt|;
comment|/* 	 * The hardlink detection may have queued up a couple of entries 	 * that can now be flushed. 	 */
name|entry
operator|=
name|NULL
expr_stmt|;
name|archive_entry_linkify
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|spare
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|entry_to_archive
argument_list|(
name|cpio
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|NULL
expr_stmt|;
name|archive_entry_linkify
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|spare
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|archive_write_close
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|dot
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|quiet
condition|)
block|{
name|int64_t
name|blocks
init|=
operator|(
name|archive_filter_bytes
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
literal|0
argument_list|)
operator|+
literal|511
operator|)
operator|/
literal|512
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|blocks
argument_list|,
name|blocks
operator|==
literal|1
condition|?
literal|"block"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
block|}
name|archive_write_free
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|remove_leading_slash
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* Remove leading "//./" or "//?/" or "//?/UNC/" 	 * (absolute path prefixes used by Windows API) */
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'?'
operator|)
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'?'
operator|&&
operator|(
name|p
index|[
literal|4
index|]
operator|==
literal|'U'
operator|||
name|p
index|[
literal|4
index|]
operator|==
literal|'u'
operator|)
operator|&&
operator|(
name|p
index|[
literal|5
index|]
operator|==
literal|'N'
operator|||
name|p
index|[
literal|5
index|]
operator|==
literal|'n'
operator|)
operator|&&
operator|(
name|p
index|[
literal|6
index|]
operator|==
literal|'C'
operator|||
name|p
index|[
literal|6
index|]
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|p
index|[
literal|7
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|7
index|]
operator|==
literal|'\\'
operator|)
condition|)
name|p
operator|+=
literal|8
expr_stmt|;
else|else
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|do
block|{
name|rp
operator|=
name|p
expr_stmt|;
comment|/* Remove leading drive letter from archives created 		 * on Windows. */
if|if
condition|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Remove leading "/../", "//", etc. */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
comment|/* Remove "/..", leave "/" 					 * for next pass. */
block|}
else|else
name|p
operator|+=
literal|1
expr_stmt|;
comment|/* Remove "/". */
block|}
block|}
do|while
condition|(
name|rp
operator|!=
name|p
condition|)
do|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is used by both out mode (to copy objects from disk into  * an archive) and pass mode (to copy objects from disk to  * an archive_write_disk "archive").  */
end_comment

begin_function
specifier|static
name|int
name|file_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
specifier|const
name|char
modifier|*
name|srcpath
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|destpath
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|spare
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* 	 * Create an archive_entry describing the source file. 	 * 	 */
name|entry
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate entry"
argument_list|)
expr_stmt|;
name|archive_entry_copy_sourcepath
argument_list|(
name|entry
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_read_disk_entry_from_file
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|,
name|entry
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_FAILED
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_OK
condition|)
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
name|ARCHIVE_FAILED
condition|)
block|{
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|cpio
operator|->
name|uid_override
operator|>=
literal|0
condition|)
block|{
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|uid_override
argument_list|)
expr_stmt|;
name|archive_entry_set_uname
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|uname_override
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpio
operator|->
name|gid_override
operator|>=
literal|0
condition|)
block|{
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|gid_override
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|gname_override
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Generate a destination path for this entry. 	 * "destination path" is the name to which it will be copied in 	 * pass mode or the name that will go into the archive in 	 * output mode. 	 */
name|destpath
operator|=
name|srcpath
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|destdir
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cpio
operator|->
name|destdir
argument_list|)
operator|+
name|strlen
argument_list|(
name|srcpath
argument_list|)
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|cpio
operator|->
name|pass_destpath_alloc
condition|)
block|{
while|while
condition|(
name|len
operator|>=
name|cpio
operator|->
name|pass_destpath_alloc
condition|)
block|{
name|cpio
operator|->
name|pass_destpath_alloc
operator|+=
literal|512
expr_stmt|;
name|cpio
operator|->
name|pass_destpath_alloc
operator|*=
literal|2
expr_stmt|;
block|}
name|free
argument_list|(
name|cpio
operator|->
name|pass_destpath
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|pass_destpath
operator|=
name|malloc
argument_list|(
name|cpio
operator|->
name|pass_destpath_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|pass_destpath
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate path buffer"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|cpio
operator|->
name|pass_destpath
argument_list|,
name|cpio
operator|->
name|destdir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cpio
operator|->
name|pass_destpath
argument_list|,
name|remove_leading_slash
argument_list|(
name|srcpath
argument_list|)
argument_list|)
expr_stmt|;
name|destpath
operator|=
name|cpio
operator|->
name|pass_destpath
expr_stmt|;
block|}
if|if
condition|(
name|cpio
operator|->
name|option_rename
condition|)
name|destpath
operator|=
name|cpio_rename
argument_list|(
name|destpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|destpath
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
comment|/* 	 * If we're trying to preserve hardlinks, match them here. 	 */
name|spare
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|linkresolver
operator|!=
name|NULL
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|!=
name|AE_IFDIR
condition|)
block|{
name|archive_entry_linkify
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|spare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|entry_to_archive
argument_list|(
name|cpio
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|spare
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|entry_to_archive
argument_list|(
name|cpio
argument_list|,
name|spare
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|spare
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|entry_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|destpath
init|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|srcpath
init|=
name|archive_entry_sourcepath
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Print out the destination name to the user. */
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|dot
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* 	 * Option_link only makes sense in pass mode and for 	 * regular files.  Also note: if a link operation fails 	 * because of cross-device restrictions, we'll fall back 	 * to copy mode for that entry. 	 * 	 * TODO: Test other cpio implementations to see if they 	 * hard-link anything other than regular files here. 	 */
if|if
condition|(
name|cpio
operator|->
name|option_link
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|struct
name|archive_entry
modifier|*
name|t
decl_stmt|;
comment|/* Save the original entry in case we need it later. */
name|t
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't create link"
argument_list|)
expr_stmt|;
comment|/* Note: link(2) doesn't create parent directories, 		 * so we use archive_write_header() instead as a 		 * convenience. */
name|archive_entry_set_hardlink
argument_list|(
name|t
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
comment|/* This is a straight link that carries no data. */
name|archive_entry_set_size
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_header
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXDEV
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
operator|&&
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
operator|==
name|EXDEV
condition|)
block|{
comment|/* Cross-device link:  Just fall through and use 			 * the original entry to copy the file over. */
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"Copying file instead"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make sure we can open the file (if necessary) before 	 * trying to write the header. 	 */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|srcpath
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|lafe_warnc
argument_list|(
name|errno
argument_list|,
literal|"%s: could not open file"
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
else|else
block|{
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|archive_write_header
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|,
literal|"%s: %s"
argument_list|,
name|srcpath
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|ARCHIVE_WARN
operator|&&
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
operator|&&
name|fd
operator|>=
literal|0
condition|)
block|{
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cpio
operator|->
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
name|cpio
operator|->
name|buff_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|bytes_write
decl_stmt|;
name|bytes_write
operator|=
name|archive_write_data
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|buff
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_write
operator|<
literal|0
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_write
operator|<
name|bytes_read
condition|)
block|{
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"Truncated write; file may have "
literal|"grown while being archived."
argument_list|)
expr_stmt|;
block|}
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cpio
operator|->
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
name|cpio
operator|->
name|buff_size
argument_list|)
expr_stmt|;
block|}
block|}
name|fd
operator|=
name|restore_time
argument_list|(
name|cpio
argument_list|,
name|entry
argument_list|,
name|srcpath
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|restore_time
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_UTIMES
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|cpio
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|entry
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
operator|!
name|warned
condition|)
name|lafe_warnc
argument_list|(
literal|0
argument_list|,
literal|"Can't restore access times on this platform"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|struct
name|__timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cpio
operator|->
name|option_atime_restore
condition|)
return|return
operator|(
name|fd
operator|)
return|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|archive_entry_atime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|archive_entry_atime_nsec
argument_list|(
name|entry
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FUTIMES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|futimes
argument_list|(
name|fd
argument_list|,
name|times
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Some platform cannot restore access times if the file descriptor 	 * is still opened. 	 */
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_LUTIMES
if|if
condition|(
name|lutimes
argument_list|(
name|name
argument_list|,
name|times
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|AE_IFLNK
operator|!=
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|)
operator|&&
name|utimes
argument_list|(
name|name
argument_list|,
name|times
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|lafe_warnc
argument_list|(
name|errno
argument_list|,
literal|"Can't update time for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mode_in
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|archive
modifier|*
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|destpath
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ext
operator|=
name|archive_write_disk_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ext
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate restore object"
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_disk_set_options
argument_list|(
name|ext
argument_list|,
name|cpio
operator|->
name|extract_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate archive object"
argument_list|)
expr_stmt|;
name|archive_read_support_filter_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|passphrase
operator|!=
name|NULL
condition|)
name|r
operator|=
name|archive_read_add_passphrase
argument_list|(
name|a
argument_list|,
name|cpio
operator|->
name|passphrase
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|archive_read_set_passphrase_callback
argument_list|(
name|a
argument_list|,
name|cpio
argument_list|,
operator|&
name|passphrase_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_read_open_filename
argument_list|(
name|a
argument_list|,
name|cpio
operator|->
name|filename
argument_list|,
name|cpio
operator|->
name|bytes_per_block
argument_list|)
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_match_path_excluded
argument_list|(
name|cpio
operator|->
name|matching
argument_list|,
name|entry
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cpio
operator|->
name|option_rename
condition|)
block|{
name|destpath
operator|=
name|cpio_rename
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
block|}
else|else
name|destpath
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|destpath
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|dot
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|uid_override
operator|>=
literal|0
condition|)
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|uid_override
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|gid_override
operator|>=
literal|0
condition|)
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|gid_override
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_header
argument_list|(
name|ext
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|archive_entry_size_is_set
argument_list|(
name|entry
argument_list|)
operator|||
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|extract_data
argument_list|(
name|a
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio
operator|->
name|return_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|r
operator|=
name|archive_read_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|dot
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_close
argument_list|(
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|quiet
condition|)
block|{
name|int64_t
name|blocks
init|=
operator|(
name|archive_filter_bytes
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|+
literal|511
operator|)
operator|/
literal|512
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|blocks
argument_list|,
name|blocks
operator|==
literal|1
condition|?
literal|"block"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
block|}
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_write_free
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|cpio
operator|->
name|return_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exits if there's a fatal error.  Returns ARCHIVE_OK  * if everything is kosher.  */
end_comment

begin_function
specifier|static
name|int
name|extract_data
parameter_list|(
name|struct
name|archive
modifier|*
name|ar
parameter_list|,
name|struct
name|archive
modifier|*
name|aw
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|size_t
name|size
decl_stmt|;
specifier|const
name|void
modifier|*
name|block
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_data_block
argument_list|(
name|ar
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|ar
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
operator|(
name|int
operator|)
name|archive_write_data_block
argument_list|(
name|aw
argument_list|,
name|block
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_warnc
argument_list|(
name|archive_errno
argument_list|(
name|aw
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|aw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mode_list
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|r
decl_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate archive object"
argument_list|)
expr_stmt|;
name|archive_read_support_filter_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|passphrase
operator|!=
name|NULL
condition|)
name|r
operator|=
name|archive_read_add_passphrase
argument_list|(
name|a
argument_list|,
name|cpio
operator|->
name|passphrase
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|archive_read_set_passphrase_callback
argument_list|(
name|a
argument_list|,
name|cpio
argument_list|,
operator|&
name|passphrase_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_read_open_filename
argument_list|(
name|a
argument_list|,
name|cpio
operator|->
name|filename
argument_list|,
name|cpio
operator|->
name|bytes_per_block
argument_list|)
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive_match_path_excluded
argument_list|(
name|cpio
operator|->
name|matching
argument_list|,
name|entry
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
name|list_item_verbose
argument_list|(
name|cpio
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|archive_read_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|quiet
condition|)
block|{
name|int64_t
name|blocks
init|=
operator|(
name|archive_filter_bytes
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
operator|+
literal|511
operator|)
operator|/
literal|512
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|blocks
argument_list|,
name|blocks
operator|==
literal|1
condition|?
literal|"block"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
block|}
name|archive_read_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display information about the current file.  *  * The format here roughly duplicates the output of 'ls -l'.  * This is based on SUSv2, where 'tar tv' is documented as  * listing additional information in an "unspecified format,"  * and 'pax -l' is documented as using the same format as 'ls -l'.  */
end_comment

begin_function
specifier|static
name|void
name|list_item_verbose
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|char
name|size
index|[
literal|32
index|]
decl_stmt|;
name|char
name|date
index|[
literal|32
index|]
decl_stmt|;
name|char
name|uids
index|[
literal|16
index|]
decl_stmt|,
name|gids
index|[
literal|16
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|uname
decl_stmt|,
modifier|*
name|gname
decl_stmt|;
name|FILE
modifier|*
name|out
init|=
name|stdout
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
specifier|static
name|time_t
name|now
decl_stmt|;
if|if
condition|(
operator|!
name|now
condition|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|option_numeric_uid_gid
condition|)
block|{
comment|/* Format numeric uid/gid for display. */
name|strcpy
argument_list|(
name|uids
argument_list|,
name|cpio_i64toa
argument_list|(
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|uname
operator|=
name|uids
expr_stmt|;
name|strcpy
argument_list|(
name|gids
argument_list|,
name|cpio_i64toa
argument_list|(
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gname
operator|=
name|gids
expr_stmt|;
block|}
else|else
block|{
comment|/* Use uname if it's present, else lookup name from uid. */
name|uname
operator|=
name|archive_entry_uname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|uname
operator|==
name|NULL
condition|)
name|uname
operator|=
name|lookup_uname
argument_list|(
name|cpio
argument_list|,
operator|(
name|uid_t
operator|)
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use gname if it's present, else lookup name from gid. */
name|gname
operator|=
name|archive_entry_gname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|gname
operator|==
name|NULL
condition|)
name|gname
operator|=
name|lookup_gname
argument_list|(
name|cpio
argument_list|,
operator|(
name|uid_t
operator|)
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print device number or file size. */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFCHR
operator|||
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFBLK
condition|)
block|{
name|snprintf
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|,
literal|"%lu,%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|archive_entry_rdevmajor
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|archive_entry_rdevminor
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|size
argument_list|,
name|cpio_i64toa
argument_list|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Format the time using 'ls -l' conventions. */
name|mtime
operator|=
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Windows' strftime function does not support %e format. */
if|if
condition|(
name|mtime
operator|-
name|now
operator|>
literal|365
operator|*
literal|86400
operator|/
literal|2
operator|||
name|mtime
operator|-
name|now
operator|<
operator|-
literal|365
operator|*
literal|86400
operator|/
literal|2
condition|)
name|fmt
operator|=
name|cpio
operator|->
name|day_first
condition|?
literal|"%d %b  %Y"
else|:
literal|"%b %d  %Y"
expr_stmt|;
else|else
name|fmt
operator|=
name|cpio
operator|->
name|day_first
condition|?
literal|"%d %b %H:%M"
else|:
literal|"%b %d %H:%M"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|mtime
operator|-
name|now
operator|>
literal|365
operator|*
literal|86400
operator|/
literal|2
operator|||
name|mtime
operator|-
name|now
operator|<
operator|-
literal|365
operator|*
literal|86400
operator|/
literal|2
condition|)
name|fmt
operator|=
name|cpio
operator|->
name|day_first
condition|?
literal|"%e %b  %Y"
else|:
literal|"%b %e  %Y"
expr_stmt|;
else|else
name|fmt
operator|=
name|cpio
operator|->
name|day_first
condition|?
literal|"%e %b %H:%M"
else|:
literal|"%b %e %H:%M"
expr_stmt|;
endif|#
directive|endif
name|strftime
argument_list|(
name|date
argument_list|,
sizeof|sizeof
argument_list|(
name|date
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|localtime
argument_list|(
operator|&
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%3d %-8s %-8s %8s %12s %s"
argument_list|,
name|archive_entry_strmode
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_nlink
argument_list|(
name|entry
argument_list|)
argument_list|,
name|uname
argument_list|,
name|gname
argument_list|,
name|size
argument_list|,
name|date
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extra information for links. */
if|if
condition|(
name|archive_entry_hardlink
argument_list|(
name|entry
argument_list|)
condition|)
comment|/* Hard link */
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" link to %s"
argument_list|,
name|archive_entry_hardlink
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
condition|)
comment|/* Symbolic link */
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" -> %s"
argument_list|,
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mode_pass
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
specifier|const
name|char
modifier|*
name|destdir
parameter_list|)
block|{
name|struct
name|lafe_line_reader
modifier|*
name|lr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Ensure target dir has a trailing '/' to simplify path surgery. */
name|cpio
operator|->
name|destdir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|destdir
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cpio
operator|->
name|destdir
argument_list|,
name|destdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|destdir
index|[
name|strlen
argument_list|(
name|destdir
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|cpio
operator|->
name|destdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|archive
operator|=
name|archive_write_disk_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|archive
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Failed to allocate archive object"
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_disk_set_options
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|extract_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|linkresolver
operator|=
name|archive_entry_linkresolver_new
argument_list|()
expr_stmt|;
name|archive_write_disk_set_standard_lookup
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|archive_read_disk
operator|=
name|archive_read_disk_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|archive_read_disk
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Failed to allocate archive object"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|option_follow_links
condition|)
name|archive_read_disk_set_symlink_logical
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
expr_stmt|;
else|else
name|archive_read_disk_set_symlink_physical
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
expr_stmt|;
name|archive_read_disk_set_standard_lookup
argument_list|(
name|cpio
operator|->
name|archive_read_disk
argument_list|)
expr_stmt|;
name|lr
operator|=
name|lafe_line_reader
argument_list|(
literal|"-"
argument_list|,
name|cpio
operator|->
name|option_null
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|lafe_line_reader_next
argument_list|(
name|lr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|file_to_archive
argument_list|(
name|cpio
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lafe_line_reader_free
argument_list|(
name|lr
argument_list|)
expr_stmt|;
name|archive_entry_linkresolver_free
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_close
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|dot
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|quiet
condition|)
block|{
name|int64_t
name|blocks
init|=
operator|(
name|archive_filter_bytes
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
literal|0
argument_list|)
operator|+
literal|511
operator|)
operator|/
literal|512
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|blocks
argument_list|,
name|blocks
operator|==
literal|1
condition|?
literal|"block"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
block|}
name|archive_write_free
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prompt for a new name for this entry.  Returns a pointer to the  * new name or NULL if the entry should not be copied.  This  * implements the semantics defined in POSIX.1-1996, which specifies  * that an input of '.' means the name should be unchanged.  GNU cpio  * treats '.' as a literal new name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cpio_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|FILE
modifier|*
name|to
decl_stmt|;
name|t
operator|=
name|fopen
argument_list|(
literal|"CONIN$"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|to
operator|=
name|fopen
argument_list|(
literal|"CONOUT$"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|to
argument_list|,
literal|"%s (Enter/./(new name))? "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
name|t
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|fprintf
argument_list|(
name|t
argument_list|,
literal|"%s (Enter/./(new name))? "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* End-of-file is a blank line. */
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Empty line. */
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
comment|/* Single period preserves original name. */
return|return
operator|(
name|name
operator|)
return|;
name|ret
operator|=
name|p
expr_stmt|;
comment|/* Trim the final newline. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Overwrite the final \n with a null character. */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_cache
parameter_list|(
name|struct
name|name_cache
modifier|*
name|cache
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|cache
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|cache
operator|->
name|cache
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup uname/gname from uid/gid, return NULL if no match.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lookup_name
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|struct
name|name_cache
modifier|*
modifier|*
name|name_cache_variable
parameter_list|,
name|int
function_decl|(
modifier|*
name|lookup_fn
function_decl|)
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|id_t
parameter_list|)
parameter_list|,
name|id_t
name|id
parameter_list|)
block|{
name|char
name|asnum
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|name_cache
modifier|*
name|cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|slot
decl_stmt|;
if|if
condition|(
operator|*
name|name_cache_variable
operator|==
name|NULL
condition|)
block|{
operator|*
name|name_cache_variable
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|name_cache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name_cache_variable
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"No more memory"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|name_cache_variable
operator|)
operator|->
name|size
operator|=
name|name_cache_size
expr_stmt|;
block|}
name|cache
operator|=
operator|*
name|name_cache_variable
expr_stmt|;
name|cache
operator|->
name|probes
operator|++
expr_stmt|;
name|slot
operator|=
name|id
operator|%
name|cache
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|id
operator|==
name|id
condition|)
block|{
name|cache
operator|->
name|hits
operator|++
expr_stmt|;
return|return
operator|(
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|name
operator|)
return|;
block|}
name|free
argument_list|(
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|lookup_fn
argument_list|(
name|cpio
argument_list|,
operator|&
name|name
argument_list|,
name|id
argument_list|)
condition|)
block|{
comment|/* If lookup failed, format it as a number. */
name|snprintf
argument_list|(
name|asnum
argument_list|,
sizeof|sizeof
argument_list|(
name|asnum
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
operator|)
name|id
argument_list|)
expr_stmt|;
name|name
operator|=
name|asnum
expr_stmt|;
block|}
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|id
operator|=
name|id
expr_stmt|;
return|return
operator|(
name|cache
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|name
operator|)
return|;
block|}
comment|/* 	 * Conveniently, NULL marks an empty slot, so 	 * if the strdup() fails, we've just failed to 	 * cache it.  No recovery necessary. 	 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lookup_uname
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|uid_t
name|uid
parameter_list|)
block|{
return|return
operator|(
name|lookup_name
argument_list|(
name|cpio
argument_list|,
operator|&
name|cpio
operator|->
name|uname_cache
argument_list|,
operator|&
name|lookup_uname_helper
argument_list|,
operator|(
name|id_t
operator|)
name|uid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_uname_helper
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|id_t
name|id
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
operator|(
name|void
operator|)
name|cpio
expr_stmt|;
comment|/* UNUSED */
name|errno
operator|=
literal|0
expr_stmt|;
name|pwent
operator|=
name|getpwuid
argument_list|(
operator|(
name|uid_t
operator|)
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|lafe_warnc
argument_list|(
name|errno
argument_list|,
literal|"getpwuid(%s) failed"
argument_list|,
name|cpio_i64toa
argument_list|(
operator|(
name|int64_t
operator|)
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|name
operator|=
name|pwent
operator|->
name|pw_name
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lookup_gname
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|gid_t
name|gid
parameter_list|)
block|{
return|return
operator|(
name|lookup_name
argument_list|(
name|cpio
argument_list|,
operator|&
name|cpio
operator|->
name|gname_cache
argument_list|,
operator|&
name|lookup_gname_helper
argument_list|,
operator|(
name|id_t
operator|)
name|gid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_gname_helper
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|id_t
name|id
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grent
decl_stmt|;
operator|(
name|void
operator|)
name|cpio
expr_stmt|;
comment|/* UNUSED */
name|errno
operator|=
literal|0
expr_stmt|;
name|grent
operator|=
name|getgrgid
argument_list|(
operator|(
name|gid_t
operator|)
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|grent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|lafe_warnc
argument_list|(
name|errno
argument_list|,
literal|"getgrgid(%s) failed"
argument_list|,
name|cpio_i64toa
argument_list|(
operator|(
name|int64_t
operator|)
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|name
operator|=
name|grent
operator|->
name|gr_name
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * It would be nice to just use printf() for formatting large numbers,  * but the compatibility problems are a big headache.  Hence the  * following simple utility function.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cpio_i64toa
parameter_list|(
name|int64_t
name|n0
parameter_list|)
block|{
comment|/* 2^64 =~ 1.8 * 10^19, so 20 decimal digits suffice. 	 * We also need 1 byte for '-' and 1 for '\0'. 	 */
specifier|static
name|char
name|buff
index|[
literal|22
index|]
decl_stmt|;
name|int64_t
name|n
init|=
name|n0
operator|<
literal|0
condition|?
operator|-
name|n0
else|:
name|n0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buff
operator|+
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
decl_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
call|(
name|int
call|)
argument_list|(
name|n
operator|%
literal|10
argument_list|)
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|n0
operator|<
literal|0
condition|)
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PPBUFF_SIZE
value|1024
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|passphrase_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|_client_data
parameter_list|)
block|{
name|struct
name|cpio
modifier|*
name|cpio
init|=
operator|(
expr|struct
name|cpio
operator|*
operator|)
name|_client_data
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|cpio
operator|->
name|ppbuff
operator|==
name|NULL
condition|)
block|{
name|cpio
operator|->
name|ppbuff
operator|=
name|malloc
argument_list|(
name|PPBUFF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|ppbuff
operator|==
name|NULL
condition|)
name|lafe_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
block|}
return|return
name|lafe_readpassphrase
argument_list|(
literal|"Enter passphrase:"
argument_list|,
name|cpio
operator|->
name|ppbuff
argument_list|,
name|PPBUFF_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|passphrase_free
parameter_list|(
name|char
modifier|*
name|ppbuff
parameter_list|)
block|{
if|if
condition|(
name|ppbuff
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|ppbuff
argument_list|,
literal|0
argument_list|,
name|PPBUFF_SIZE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppbuff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

