begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// Algorithm implementation -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006
end_comment

begin_comment
comment|// Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/*  *  * Copyright (c) 1994  * Hewlett-Packard Company  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Hewlett-Packard Company makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  *  *  * Copyright (c) 1996  * Silicon Graphics Computer Systems, Inc.  *  * Permission to use, copy, modify, distribute and sell this software  * and its documentation for any purpose is hereby granted without fee,  * provided that the above copyright notice appear in all copies and  * that both that copyright notice and this permission notice appear  * in supporting documentation.  Silicon Graphics makes no  * representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/** @file stl_algo.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_ALGO_H
end_ifndef

begin_define
define|#
directive|define
name|_ALGO_H
value|1
end_define

begin_include
include|#
directive|include
file|<bits/stl_heap.h>
end_include

begin_include
include|#
directive|include
file|<bits/stl_tempbuf.h>
end_include

begin_comment
comment|// for _Temporary_buffer
end_comment

begin_include
include|#
directive|include
file|<debug/debug.h>
end_include

begin_comment
comment|// See concept_check.h for the __glibcxx_*_requires macros.
end_comment

begin_macro
name|_GLIBCXX_BEGIN_NAMESPACE
argument_list|(
argument|std
argument_list|)
end_macro

begin_comment
comment|/**    *  @brief Find the median of three values.    *  @param  a  A value.    *  @param  b  A value.    *  @param  c  A value.    *  @return One of @p a, @p b or @p c.    *    *  If @c {l,m,n} is some convolution of @p {a,b,c} such that @c l<=m<=n    *  then the value returned will be @c m.    *  This is an SGI extension.    *  @ingroup SGIextensions   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
specifier|inline
specifier|const
name|_Tp
operator|&
name|__median
argument_list|(
argument|const _Tp& __a
argument_list|,
argument|const _Tp& __b
argument_list|,
argument|const _Tp& __c
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept<_Tp>
argument_list|)
if|if
condition|(
name|__a
operator|<
name|__b
condition|)
if|if
condition|(
name|__b
operator|<
name|__c
condition|)
return|return
name|__b
return|;
elseif|else
if|if
condition|(
name|__a
operator|<
name|__c
condition|)
return|return
name|__c
return|;
else|else
return|return
name|__a
return|;
elseif|else
if|if
condition|(
name|__a
operator|<
name|__c
condition|)
return|return
name|__a
return|;
elseif|else
if|if
condition|(
name|__b
operator|<
name|__c
condition|)
return|return
name|__c
return|;
else|else
return|return
name|__b
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Find the median of three values using a predicate for comparison.    *  @param  a     A value.    *  @param  b     A value.    *  @param  c     A value.    *  @param  comp  A binary predicate.    *  @return One of @p a, @p b or @p c.    *    *  If @c {l,m,n} is some convolution of @p {a,b,c} such that @p comp(l,m)    *  and @p comp(m,n) are both true then the value returned will be @c m.    *  This is an SGI extension.    *  @ingroup SGIextensions   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
specifier|inline
specifier|const
name|_Tp
operator|&
name|__median
argument_list|(
argument|const _Tp& __a
argument_list|,
argument|const _Tp& __b
argument_list|,
argument|const _Tp& __c
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryFunctionConcept<_Compare
argument_list|,
argument|bool
argument_list|,
argument|_Tp
argument_list|,
argument|_Tp>
argument_list|)
if|if
condition|(
name|__comp
argument_list|(
name|__a
argument_list|,
name|__b
argument_list|)
condition|)
if|if
condition|(
name|__comp
argument_list|(
name|__b
argument_list|,
name|__c
argument_list|)
condition|)
return|return
name|__b
return|;
elseif|else
if|if
condition|(
name|__comp
argument_list|(
name|__a
argument_list|,
name|__c
argument_list|)
condition|)
return|return
name|__c
return|;
else|else
return|return
name|__a
return|;
elseif|else
if|if
condition|(
name|__comp
argument_list|(
name|__a
argument_list|,
name|__c
argument_list|)
condition|)
return|return
name|__a
return|;
elseif|else
if|if
condition|(
name|__comp
argument_list|(
name|__b
argument_list|,
name|__c
argument_list|)
condition|)
return|return
name|__c
return|;
else|else
return|return
name|__b
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Apply a function to every element of a sequence.    *  @param  first  An input iterator.    *  @param  last   An input iterator.    *  @param  f      A unary function object.    *  @return   @p f.    *    *  Applies the function object @p f to each element in the range    *  @p [first,last).  @p f must not modify the order of the sequence.    *  If @p f has a return value it is ignored.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Function
operator|>
name|_Function
name|for_each
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_Function __f
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
name|__f
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__f
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an overload used by find() for the Input Iterator case.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Tp
operator|>
specifier|inline
name|_InputIterator
name|__find
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|input_iterator_tag
argument_list|)
block|{
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
operator|!
operator|(
operator|*
name|__first
operator|==
name|__val
operator|)
condition|)
operator|++
name|__first
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an overload used by find_if() for the Input Iterator case.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Predicate
operator|>
specifier|inline
name|_InputIterator
name|__find_if
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|input_iterator_tag
argument_list|)
block|{
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
operator|!
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
operator|++
name|__first
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an overload used by find() for the RAI case.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Tp
operator|>
name|_RandomAccessIterator
name|__find
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|random_access_iterator_tag
argument_list|)
block|{
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|__trip_count
operator|=
operator|(
name|__last
operator|-
name|__first
operator|)
operator|>>
literal|2
block|;
for|for
control|(
init|;
name|__trip_count
operator|>
literal|0
condition|;
operator|--
name|__trip_count
control|)
block|{
if|if
condition|(
operator|*
name|__first
operator|==
name|__val
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
if|if
condition|(
operator|*
name|__first
operator|==
name|__val
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
if|if
condition|(
operator|*
name|__first
operator|==
name|__val
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
if|if
condition|(
operator|*
name|__first
operator|==
name|__val
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|__last
operator|-
name|__first
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
operator|*
name|__first
operator|==
name|__val
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
case|case
literal|2
case|:
if|if
condition|(
operator|*
name|__first
operator|==
name|__val
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
operator|*
name|__first
operator|==
name|__val
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
case|case
literal|0
case|:
default|default:
return|return
name|__last
return|;
block|}
end_switch

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an overload used by find_if() for the RAI case.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Predicate
operator|>
name|_RandomAccessIterator
name|__find_if
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|random_access_iterator_tag
argument_list|)
block|{
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|__trip_count
operator|=
operator|(
name|__last
operator|-
name|__first
operator|)
operator|>>
literal|2
block|;
for|for
control|(
init|;
name|__trip_count
operator|>
literal|0
condition|;
operator|--
name|__trip_count
control|)
block|{
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|__last
operator|-
name|__first
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
case|case
literal|2
case|:
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
return|return
name|__first
return|;
operator|++
name|__first
expr_stmt|;
case|case
literal|0
case|:
default|default:
return|return
name|__last
return|;
block|}
end_switch

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an overload of find() for streambuf iterators.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_CharT
operator|>
name|typename
name|__gnu_cxx
operator|::
name|__enable_if
operator|<
name|__is_char
operator|<
name|_CharT
operator|>
operator|::
name|__value
operator|,
name|istreambuf_iterator
operator|<
name|_CharT
operator|>
expr|>
operator|::
name|__type
name|find
argument_list|(
name|istreambuf_iterator
operator|<
name|_CharT
operator|>
argument_list|,
name|istreambuf_iterator
operator|<
name|_CharT
operator|>
argument_list|,
specifier|const
name|_CharT
operator|&
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**    *  @brief Find the first occurrence of a value in a sequence.    *  @param  first  An input iterator.    *  @param  last   An input iterator.    *  @param  val    The value to find.    *  @return   The first iterator @c i in the range @p [first,last)    *  such that @c *i == @p val, or @p last if no such iterator exists.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Tp
operator|>
specifier|inline
name|_InputIterator
name|find
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 		typename iterator_traits<_InputIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
return|return
name|std
operator|::
name|__find
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Find the first element in a sequence for which a predicate is true.    *  @param  first  An input iterator.    *  @param  last   An input iterator.    *  @param  pred   A predicate.    *  @return   The first iterator @c i in the range @p [first,last)    *  such that @p pred(*i) is true, or @p last if no such iterator exists.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Predicate
operator|>
specifier|inline
name|_InputIterator
name|find_if
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
return|return
name|std
operator|::
name|__find_if
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__pred
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Find two adjacent values in a sequence that are equal.    *  @param  first  A forward iterator.    *  @param  last   A forward iterator.    *  @return   The first iterator @c i such that @c i and @c i+1 are both    *  valid iterators in @p [first,last) and such that @c *i == @c *(i+1),    *  or @p last if no such iterator exists.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_ForwardIterator
operator|>
name|_ForwardIterator
name|adjacent_find
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualityComparableConcept< 	    typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__last
return|;
name|_ForwardIterator
name|__next
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__next
operator|!=
name|__last
condition|)
block|{
if|if
condition|(
operator|*
name|__first
operator|==
operator|*
name|__next
condition|)
return|return
name|__first
return|;
name|__first
operator|=
name|__next
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__last
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Find two adjacent values in a sequence using a predicate.    *  @param  first         A forward iterator.    *  @param  last          A forward iterator.    *  @param  binary_pred   A binary predicate.    *  @return   The first iterator @c i such that @c i and @c i+1 are both    *  valid iterators in @p [first,last) and such that    *  @p binary_pred(*i,*(i+1)) is true, or @p last if no such iterator    *  exists.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_ForwardIterator
name|adjacent_find
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__last
return|;
name|_ForwardIterator
name|__next
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__next
operator|!=
name|__last
condition|)
block|{
if|if
condition|(
name|__binary_pred
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
name|__next
argument_list|)
condition|)
return|return
name|__first
return|;
name|__first
operator|=
name|__next
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__last
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Count the number of copies of a value in a sequence.    *  @param  first  An input iterator.    *  @param  last   An input iterator.    *  @param  value  The value to be counted.    *  @return   The number of iterators @c i in the range @p [first,last)    *  for which @c *i == @p value   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Tp
operator|>
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|difference_type
name|count
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|const _Tp& __value
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	typename iterator_traits<_InputIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|difference_type
name|__n
operator|=
literal|0
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
if|if
condition|(
operator|*
name|__first
operator|==
name|__value
condition|)
operator|++
name|__n
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__n
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Count the elements of a sequence for which a predicate is true.    *  @param  first  An input iterator.    *  @param  last   An input iterator.    *  @param  pred   A predicate.    *  @return   The number of iterators @c i in the range @p [first,last)    *  for which @p pred(*i) is true.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_Predicate
operator|>
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|difference_type
name|count_if
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|difference_type
name|__n
operator|=
literal|0
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
operator|++
name|__n
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__n
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Search a sequence for a matching sub-sequence.    *  @param  first1  A forward iterator.    *  @param  last1   A forward iterator.    *  @param  first2  A forward iterator.    *  @param  last2   A forward iterator.    *  @return   The first iterator @c i in the range    *  @p [first1,last1-(last2-first2)) such that @c *(i+N) == @p *(first2+N)    *  for each @c N in the range @p [0,last2-first2), or @p last1 if no    *  such iterator exists.    *    *  Searches the range @p [first1,last1) for a sub-sequence that compares    *  equal value-by-value with the sequence given by @p [first2,last2) and    *  returns an iterator to the first element of the sub-sequence, or    *  @p last1 if the sub-sequence is not found.    *    *  Because the sub-sequence must lie completely within the range    *  @p [first1,last1) it must start at a position less than    *  @p last1-(last2-first2) where @p last2-first2 is the length of the    *  sub-sequence.    *  This means that the returned iterator @c i will be in the range    *  @p [first1,last1-(last2-first2))   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator1
operator|,
name|typename
name|_ForwardIterator2
operator|>
name|_ForwardIterator1
name|search
argument_list|(
argument|_ForwardIterator1 __first1
argument_list|,
argument|_ForwardIterator1 __last1
argument_list|,
argument|_ForwardIterator2 __first2
argument_list|,
argument|_ForwardIterator2 __last2
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator2>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	    typename iterator_traits<_ForwardIterator1>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator2>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
block|;
comment|// Test for empty ranges
if|if
condition|(
name|__first1
operator|==
name|__last1
operator|||
name|__first2
operator|==
name|__last2
condition|)
return|return
name|__first1
return|;
comment|// Test for a pattern of length 1.
name|_ForwardIterator2
name|__tmp
argument_list|(
name|__first2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__tmp
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__tmp
operator|==
name|__last2
condition|)
return|return
name|std
operator|::
name|find
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
operator|*
name|__first2
argument_list|)
return|;
end_if

begin_comment
comment|// General case.
end_comment

begin_decl_stmt
name|_ForwardIterator2
name|__p1
decl_stmt|,
name|__p
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__p1
operator|=
name|__first2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__p1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_ForwardIterator1
name|__current
init|=
name|__first1
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
condition|)
block|{
name|__first1
operator|=
name|std
operator|::
name|find
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
operator|*
name|__first2
argument_list|)
expr_stmt|;
if|if
condition|(
name|__first1
operator|==
name|__last1
condition|)
return|return
name|__last1
return|;
name|__p
operator|=
name|__p1
expr_stmt|;
name|__current
operator|=
name|__first1
expr_stmt|;
if|if
condition|(
operator|++
name|__current
operator|==
name|__last1
condition|)
return|return
name|__last1
return|;
while|while
condition|(
operator|*
name|__current
operator|==
operator|*
name|__p
condition|)
block|{
if|if
condition|(
operator|++
name|__p
operator|==
name|__last2
condition|)
return|return
name|__first1
return|;
if|if
condition|(
operator|++
name|__current
operator|==
name|__last1
condition|)
return|return
name|__last1
return|;
block|}
operator|++
name|__first1
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__first1
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Search a sequence for a matching sub-sequence using a predicate.    *  @param  first1     A forward iterator.    *  @param  last1      A forward iterator.    *  @param  first2     A forward iterator.    *  @param  last2      A forward iterator.    *  @param  predicate  A binary predicate.    *  @return   The first iterator @c i in the range    *  @p [first1,last1-(last2-first2)) such that    *  @p predicate(*(i+N),*(first2+N)) is true for each @c N in the range    *  @p [0,last2-first2), or @p last1 if no such iterator exists.    *    *  Searches the range @p [first1,last1) for a sub-sequence that compares    *  equal value-by-value with the sequence given by @p [first2,last2),    *  using @p predicate to determine equality, and returns an iterator    *  to the first element of the sub-sequence, or @p last1 if no such    *  iterator exists.    *    *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator1
operator|,
name|typename
name|_ForwardIterator2
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_ForwardIterator1
name|search
argument_list|(
argument|_ForwardIterator1 __first1
argument_list|,
argument|_ForwardIterator1 __last1
argument_list|,
argument|_ForwardIterator2 __first2
argument_list|,
argument|_ForwardIterator2 __last2
argument_list|,
argument|_BinaryPredicate  __predicate
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator2>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator1>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator2>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
block|;
comment|// Test for empty ranges
if|if
condition|(
name|__first1
operator|==
name|__last1
operator|||
name|__first2
operator|==
name|__last2
condition|)
return|return
name|__first1
return|;
comment|// Test for a pattern of length 1.
name|_ForwardIterator2
name|__tmp
argument_list|(
name|__first2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__tmp
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__tmp
operator|==
name|__last2
condition|)
block|{
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
operator|!
name|__predicate
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
operator|++
name|__first1
expr_stmt|;
return|return
name|__first1
return|;
block|}
end_if

begin_comment
comment|// General case.
end_comment

begin_decl_stmt
name|_ForwardIterator2
name|__p1
decl_stmt|,
name|__p
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__p1
operator|=
name|__first2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__p1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_ForwardIterator1
name|__current
init|=
name|__first1
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
condition|)
block|{
while|while
condition|(
name|__first1
operator|!=
name|__last1
condition|)
block|{
if|if
condition|(
name|__predicate
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
break|break;
operator|++
name|__first1
expr_stmt|;
block|}
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
operator|!
name|__predicate
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
operator|++
name|__first1
expr_stmt|;
if|if
condition|(
name|__first1
operator|==
name|__last1
condition|)
return|return
name|__last1
return|;
name|__p
operator|=
name|__p1
expr_stmt|;
name|__current
operator|=
name|__first1
expr_stmt|;
if|if
condition|(
operator|++
name|__current
operator|==
name|__last1
condition|)
return|return
name|__last1
return|;
while|while
condition|(
name|__predicate
argument_list|(
operator|*
name|__current
argument_list|,
operator|*
name|__p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|__p
operator|==
name|__last2
condition|)
return|return
name|__first1
return|;
if|if
condition|(
operator|++
name|__current
operator|==
name|__last1
condition|)
return|return
name|__last1
return|;
block|}
operator|++
name|__first1
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__first1
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified    *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)    *  overloaded for forward iterators.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Integer
operator|,
name|typename
name|_Tp
operator|>
name|_ForwardIterator
name|__search_n
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Integer __count
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|std::forward_iterator_tag
argument_list|)
block|{
name|__first
operator|=
name|std
operator|::
name|find
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
block|;
while|while
condition|(
name|__first
operator|!=
name|__last
condition|)
block|{
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|__n
operator|=
name|__count
expr_stmt|;
name|_ForwardIterator
name|__i
init|=
name|__first
decl_stmt|;
operator|++
name|__i
expr_stmt|;
while|while
condition|(
name|__i
operator|!=
name|__last
operator|&&
name|__n
operator|!=
literal|1
operator|&&
operator|*
name|__i
operator|==
name|__val
condition|)
block|{
operator|++
name|__i
expr_stmt|;
operator|--
name|__n
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|__n
operator|==
literal|1
condition|)
return|return
name|__first
return|;
end_if

begin_if
if|if
condition|(
name|__i
operator|==
name|__last
condition|)
return|return
name|__last
return|;
end_if

begin_expr_stmt
name|__first
operator|=
name|std
operator|::
name|find
argument_list|(
operator|++
name|__i
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}       return
name|__last
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified    *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)    *  overloaded for random access iterators.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIter
operator|,
name|typename
name|_Integer
operator|,
name|typename
name|_Tp
operator|>
name|_RandomAccessIter
name|__search_n
argument_list|(
argument|_RandomAccessIter __first
argument_list|,
argument|_RandomAccessIter __last
argument_list|,
argument|_Integer __count
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|std::random_access_iterator_tag
argument_list|)
block|{
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_RandomAccessIter
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
name|_DistanceType
name|__tailSize
operator|=
name|__last
operator|-
name|__first
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|_DistanceType
name|__pattSize
init|=
name|__count
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__tailSize
operator|<
name|__pattSize
condition|)
return|return
name|__last
return|;
end_if

begin_decl_stmt
specifier|const
name|_DistanceType
name|__skipOffset
init|=
name|__pattSize
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_RandomAccessIter
name|__lookAhead
init|=
name|__first
operator|+
name|__skipOffset
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__tailSize
operator|-=
name|__pattSize
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
literal|1
condition|)
comment|// the main loop...
block|{
comment|// __lookAhead here is always pointing to the last element of next
comment|// possible match.
while|while
condition|(
operator|!
operator|(
operator|*
name|__lookAhead
operator|==
name|__val
operator|)
condition|)
comment|// the skip loop...
block|{
if|if
condition|(
name|__tailSize
operator|<
name|__pattSize
condition|)
return|return
name|__last
return|;
comment|// Failure
name|__lookAhead
operator|+=
name|__pattSize
expr_stmt|;
name|__tailSize
operator|-=
name|__pattSize
expr_stmt|;
block|}
name|_DistanceType
name|__remainder
init|=
name|__skipOffset
decl_stmt|;
for|for
control|(
name|_RandomAccessIter
name|__backTrack
init|=
name|__lookAhead
operator|-
literal|1
init|;
operator|*
name|__backTrack
operator|==
name|__val
condition|;
operator|--
name|__backTrack
control|)
block|{
if|if
condition|(
operator|--
name|__remainder
operator|==
literal|0
condition|)
return|return
operator|(
name|__lookAhead
operator|-
name|__skipOffset
operator|)
return|;
comment|// Success
block|}
if|if
condition|(
name|__remainder
operator|>
name|__tailSize
condition|)
return|return
name|__last
return|;
comment|// Failure
name|__lookAhead
operator|+=
name|__remainder
expr_stmt|;
name|__tailSize
operator|-=
name|__remainder
expr_stmt|;
block|}
end_while

begin_comment
unit|}
comment|/**    *  @brief Search a sequence for a number of consecutive values.    *  @param  first  A forward iterator.    *  @param  last   A forward iterator.    *  @param  count  The number of consecutive values.    *  @param  val    The value to find.    *  @return   The first iterator @c i in the range @p [first,last-count)    *  such that @c *(i+N) == @p val for each @c N in the range @p [0,count),    *  or @p last if no such iterator exists.    *    *  Searches the range @p [first,last) for @p count consecutive elements    *  equal to @p val.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Integer
operator|,
name|typename
name|_Tp
operator|>
name|_ForwardIterator
name|search_n
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Integer __count
argument_list|,
argument|const _Tp& __val
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__count
operator|<=
literal|0
condition|)
return|return
name|__first
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|__count
operator|==
literal|1
condition|)
return|return
name|std
operator|::
name|find
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
return|;
end_if

begin_return
return|return
name|std
operator|::
name|__search_n
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__count
argument_list|,
name|__val
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified    *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,    *	       _BinaryPredicate)    *  overloaded for forward iterators.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Integer
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_ForwardIterator
name|__search_n
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Integer __count
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|,
argument|std::forward_iterator_tag
argument_list|)
block|{
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
operator|!
name|__binary_pred
argument_list|(
operator|*
name|__first
argument_list|,
name|__val
argument_list|)
condition|)
operator|++
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first
operator|!=
name|__last
condition|)
block|{
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|__n
operator|=
name|__count
expr_stmt|;
name|_ForwardIterator
name|__i
init|=
name|__first
decl_stmt|;
operator|++
name|__i
expr_stmt|;
while|while
condition|(
name|__i
operator|!=
name|__last
operator|&&
name|__n
operator|!=
literal|1
operator|&&
name|__binary_pred
argument_list|(
operator|*
name|__i
argument_list|,
name|__val
argument_list|)
condition|)
block|{
operator|++
name|__i
expr_stmt|;
operator|--
name|__n
expr_stmt|;
block|}
if|if
condition|(
name|__n
operator|==
literal|1
condition|)
return|return
name|__first
return|;
if|if
condition|(
name|__i
operator|==
name|__last
condition|)
return|return
name|__last
return|;
name|__first
operator|=
operator|++
name|__i
expr_stmt|;
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
operator|!
name|__binary_pred
argument_list|(
operator|*
name|__first
argument_list|,
name|__val
argument_list|)
condition|)
operator|++
name|__first
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__last
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified    *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,    *	       _BinaryPredicate)    *  overloaded for random access iterators.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIter
operator|,
name|typename
name|_Integer
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_RandomAccessIter
name|__search_n
argument_list|(
argument|_RandomAccessIter __first
argument_list|,
argument|_RandomAccessIter __last
argument_list|,
argument|_Integer __count
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|,
argument|std::random_access_iterator_tag
argument_list|)
block|{
typedef|typedef
name|typename
name|std
operator|::
name|iterator_traits
operator|<
name|_RandomAccessIter
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
name|_DistanceType
name|__tailSize
operator|=
name|__last
operator|-
name|__first
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|_DistanceType
name|__pattSize
init|=
name|__count
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__tailSize
operator|<
name|__pattSize
condition|)
return|return
name|__last
return|;
end_if

begin_decl_stmt
specifier|const
name|_DistanceType
name|__skipOffset
init|=
name|__pattSize
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_RandomAccessIter
name|__lookAhead
init|=
name|__first
operator|+
name|__skipOffset
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__tailSize
operator|-=
name|__pattSize
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
literal|1
condition|)
comment|// the main loop...
block|{
comment|// __lookAhead here is always pointing to the last element of next
comment|// possible match.
while|while
condition|(
operator|!
name|__binary_pred
argument_list|(
operator|*
name|__lookAhead
argument_list|,
name|__val
argument_list|)
condition|)
comment|// the skip loop...
block|{
if|if
condition|(
name|__tailSize
operator|<
name|__pattSize
condition|)
return|return
name|__last
return|;
comment|// Failure
name|__lookAhead
operator|+=
name|__pattSize
expr_stmt|;
name|__tailSize
operator|-=
name|__pattSize
expr_stmt|;
block|}
name|_DistanceType
name|__remainder
init|=
name|__skipOffset
decl_stmt|;
for|for
control|(
name|_RandomAccessIter
name|__backTrack
init|=
name|__lookAhead
operator|-
literal|1
init|;
name|__binary_pred
argument_list|(
operator|*
name|__backTrack
argument_list|,
name|__val
argument_list|)
condition|;
operator|--
name|__backTrack
control|)
block|{
if|if
condition|(
operator|--
name|__remainder
operator|==
literal|0
condition|)
return|return
operator|(
name|__lookAhead
operator|-
name|__skipOffset
operator|)
return|;
comment|// Success
block|}
if|if
condition|(
name|__remainder
operator|>
name|__tailSize
condition|)
return|return
name|__last
return|;
comment|// Failure
name|__lookAhead
operator|+=
name|__remainder
expr_stmt|;
name|__tailSize
operator|-=
name|__remainder
expr_stmt|;
block|}
end_while

begin_comment
unit|}
comment|/**    *  @brief Search a sequence for a number of consecutive values using a    *         predicate.    *  @param  first        A forward iterator.    *  @param  last         A forward iterator.    *  @param  count        The number of consecutive values.    *  @param  val          The value to find.    *  @param  binary_pred  A binary predicate.    *  @return   The first iterator @c i in the range @p [first,last-count)    *  such that @p binary_pred(*(i+N),val) is true for each @c N in the    *  range @p [0,count), or @p last if no such iterator exists.    *    *  Searches the range @p [first,last) for @p count consecutive elements    *  for which the predicate returns true.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Integer
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_ForwardIterator
name|search_n
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Integer __count
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__count
operator|<=
literal|0
condition|)
return|return
name|__first
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|__count
operator|==
literal|1
condition|)
block|{
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
operator|!
name|__binary_pred
argument_list|(
operator|*
name|__first
argument_list|,
name|__val
argument_list|)
condition|)
operator|++
name|__first
expr_stmt|;
return|return
name|__first
return|;
block|}
end_if

begin_return
return|return
name|std
operator|::
name|__search_n
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__count
argument_list|,
name|__val
argument_list|,
name|__binary_pred
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Swap the elements of two sequences.    *  @param  first1  A forward iterator.    *  @param  last1   A forward iterator.    *  @param  first2  A forward iterator.    *  @return   An iterator equal to @p first2+(last1-first1).    *    *  Swaps each element in the range @p [first1,last1) with the    *  corresponding element in the range @p [first2,(last1-first1)).    *  The ranges must not overlap.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator1
operator|,
name|typename
name|_ForwardIterator2
operator|>
name|_ForwardIterator2
name|swap_ranges
argument_list|(
argument|_ForwardIterator1 __first1
argument_list|,
argument|_ForwardIterator1 __last1
argument_list|,
argument|_ForwardIterator2 __first2
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator2>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept< 	    typename iterator_traits<_ForwardIterator1>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator2>::value_type>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept< 	    typename iterator_traits<_ForwardIterator2>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator1>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
for|for
control|(
init|;
name|__first1
operator|!=
name|__last1
condition|;
operator|++
name|__first1
operator|,
operator|++
name|__first2
control|)
name|std
operator|::
name|iter_swap
argument_list|(
name|__first1
argument_list|,
name|__first2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__first2
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Perform an operation on a sequence.    *  @param  first     An input iterator.    *  @param  last      An input iterator.    *  @param  result    An output iterator.    *  @param  unary_op  A unary operator.    *  @return   An output iterator equal to @p result+(last-first).    *    *  Applies the operator to each element in the input range and assigns    *  the results to successive elements of the output sequence.    *  Evaluates @p *(result+N)=unary_op(*(first+N)) for each @c N in the    *  range @p [0,last-first).    *    *  @p unary_op must not alter its argument.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_UnaryOperation
operator|>
name|_OutputIterator
name|transform
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_UnaryOperation __unary_op
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
comment|// "the type returned by a _UnaryOperation"
argument|__typeof__(__unary_op(*__first))>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
operator|,
operator|++
name|__result
control|)
operator|*
name|__result
operator|=
name|__unary_op
argument_list|(
operator|*
name|__first
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Perform an operation on corresponding elements of two sequences.    *  @param  first1     An input iterator.    *  @param  last1      An input iterator.    *  @param  first2     An input iterator.    *  @param  result     An output iterator.    *  @param  binary_op  A binary operator.    *  @return   An output iterator equal to @p result+(last-first).    *    *  Applies the operator to the corresponding elements in the two    *  input ranges and assigns the results to successive elements of the    *  output sequence.    *  Evaluates @p *(result+N)=binary_op(*(first1+N),*(first2+N)) for each    *  @c N in the range @p [0,last1-first1).    *    *  @p binary_op must not alter either of its arguments.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_BinaryOperation
operator|>
name|_OutputIterator
name|transform
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_BinaryOperation __binary_op
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
comment|// "the type returned by a _BinaryOperation"
argument|__typeof__(__binary_op(*__first1,*__first2))>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
for|for
control|(
init|;
name|__first1
operator|!=
name|__last1
condition|;
operator|++
name|__first1
operator|,
operator|++
name|__first2
operator|,
operator|++
name|__result
control|)
operator|*
name|__result
operator|=
name|__binary_op
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Replace each occurrence of one value in a sequence with another    *         value.    *  @param  first      A forward iterator.    *  @param  last       A forward iterator.    *  @param  old_value  The value to be replaced.    *  @param  new_value  The replacement value.    *  @return   replace() returns no value.    *    *  For each iterator @c i in the range @p [first,last) if @c *i ==    *  @p old_value then the assignment @c *i = @p new_value is performed.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|>
name|void
name|replace
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __old_value
argument_list|,
argument|const _Tp& __new_value
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	    typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
if|if
condition|(
operator|*
name|__first
operator|==
name|__old_value
condition|)
operator|*
name|__first
operator|=
name|__new_value
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Replace each value in a sequence for which a predicate returns    *         true with another value.    *  @param  first      A forward iterator.    *  @param  last       A forward iterator.    *  @param  pred       A predicate.    *  @param  new_value  The replacement value.    *  @return   replace_if() returns no value.    *    *  For each iterator @c i in the range @p [first,last) if @p pred(*i)    *  is true then the assignment @c *i = @p new_value is performed.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Predicate
operator|,
name|typename
name|_Tp
operator|>
name|void
name|replace_if
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|const _Tp& __new_value
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
operator|*
name|__first
operator|=
name|__new_value
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Copy a sequence, replacing each element of one value with another    *         value.    *  @param  first      An input iterator.    *  @param  last       An input iterator.    *  @param  result     An output iterator.    *  @param  old_value  The value to be replaced.    *  @param  new_value  The replacement value.    *  @return   The end of the output sequence, @p result+(last-first).    *    *  Copies each element in the input range @p [first,last) to the    *  output range @p [result,result+(last-first)) replacing elements    *  equal to @p old_value with @p new_value.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Tp
operator|>
name|_OutputIterator
name|replace_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|const _Tp& __old_value
argument_list|,
argument|const _Tp& __new_value
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	    typename iterator_traits<_InputIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
operator|,
operator|++
name|__result
control|)
if|if
condition|(
operator|*
name|__first
operator|==
name|__old_value
condition|)
operator|*
name|__result
operator|=
name|__new_value
expr_stmt|;
else|else
operator|*
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Copy a sequence, replacing each value for which a predicate    *         returns true with another value.    *  @param  first      An input iterator.    *  @param  last       An input iterator.    *  @param  result     An output iterator.    *  @param  pred       A predicate.    *  @param  new_value  The replacement value.    *  @return   The end of the output sequence, @p result+(last-first).    *    *  Copies each element in the range @p [first,last) to the range    *  @p [result,result+(last-first)) replacing elements for which    *  @p pred returns true with @p new_value.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Predicate
operator|,
name|typename
name|_Tp
operator|>
name|_OutputIterator
name|replace_copy_if
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|const _Tp& __new_value
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
operator|,
operator|++
name|__result
control|)
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
operator|*
name|__result
operator|=
name|__new_value
expr_stmt|;
else|else
operator|*
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Assign the result of a function object to each value in a    *         sequence.    *  @param  first  A forward iterator.    *  @param  last   A forward iterator.    *  @param  gen    A function object taking no arguments.    *  @return   generate() returns no value.    *    *  Performs the assignment @c *i = @p gen() for each @c i in the range    *  @p [first,last).   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Generator
operator|>
name|void
name|generate
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Generator __gen
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_GeneratorConcept<_Generator
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
operator|*
name|__first
operator|=
name|__gen
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Assign the result of a function object to each value in a    *         sequence.    *  @param  first  A forward iterator.    *  @param  n      The length of the sequence.    *  @param  gen    A function object taking no arguments.    *  @return   The end of the sequence, @p first+n    *    *  Performs the assignment @c *i = @p gen() for each @c i in the range    *  @p [first,first+n).   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Size
operator|,
name|typename
name|_Generator
operator|>
name|_OutputIterator
name|generate_n
argument_list|(
argument|_OutputIterator __first
argument_list|,
argument|_Size __n
argument_list|,
argument|_Generator __gen
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
comment|// "the type returned by a _Generator"
argument|__typeof__(__gen())>
argument_list|)
for|for
control|(
init|;
name|__n
operator|>
literal|0
condition|;
operator|--
name|__n
operator|,
operator|++
name|__first
control|)
operator|*
name|__first
operator|=
name|__gen
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Copy a sequence, removing elements of a given value.    *  @param  first   An input iterator.    *  @param  last    An input iterator.    *  @param  result  An output iterator.    *  @param  value   The value to be removed.    *  @return   An iterator designating the end of the resulting sequence.    *    *  Copies each element in the range @p [first,last) not equal to @p value    *  to the range beginning at @p result.    *  remove_copy() is stable, so the relative order of elements that are    *  copied is unchanged.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Tp
operator|>
name|_OutputIterator
name|remove_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|const _Tp& __value
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	    typename iterator_traits<_InputIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
if|if
condition|(
operator|!
operator|(
operator|*
name|__first
operator|==
name|__value
operator|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Copy a sequence, removing elements for which a predicate is true.    *  @param  first   An input iterator.    *  @param  last    An input iterator.    *  @param  result  An output iterator.    *  @param  pred    A predicate.    *  @return   An iterator designating the end of the resulting sequence.    *    *  Copies each element in the range @p [first,last) for which    *  @p pred returns true to the range beginning at @p result.    *    *  remove_copy_if() is stable, so the relative order of elements that are    *  copied is unchanged.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Predicate
operator|>
name|_OutputIterator
name|remove_copy_if
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_Predicate __pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
if|if
condition|(
operator|!
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Remove elements from a sequence.    *  @param  first  An input iterator.    *  @param  last   An input iterator.    *  @param  value  The value to be removed.    *  @return   An iterator designating the end of the resulting sequence.    *    *  All elements equal to @p value are removed from the range    *  @p [first,last).    *    *  remove() is stable, so the relative order of elements that are    *  not removed is unchanged.    *    *  Elements between the end of the resulting sequence and @p last    *  are still present, but their value is unspecified.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|>
name|_ForwardIterator
name|remove
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __value
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	    typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|_Tp>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
name|__first
operator|=
name|std
operator|::
name|find
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__value
argument_list|)
block|;
name|_ForwardIterator
name|__i
operator|=
name|__first
block|;
return|return
name|__first
operator|==
name|__last
condition|?
name|__first
else|:
name|std
operator|::
name|remove_copy
argument_list|(
operator|++
name|__i
argument_list|,
name|__last
argument_list|,
name|__first
argument_list|,
name|__value
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Remove elements from a sequence using a predicate.    *  @param  first  A forward iterator.    *  @param  last   A forward iterator.    *  @param  pred   A predicate.    *  @return   An iterator designating the end of the resulting sequence.    *    *  All elements for which @p pred returns true are removed from the range    *  @p [first,last).    *    *  remove_if() is stable, so the relative order of elements that are    *  not removed is unchanged.    *    *  Elements between the end of the resulting sequence and @p last    *  are still present, but their value is unspecified.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Predicate
operator|>
name|_ForwardIterator
name|remove_if
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
name|__first
operator|=
name|std
operator|::
name|find_if
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__pred
argument_list|)
block|;
name|_ForwardIterator
name|__i
operator|=
name|__first
block|;
return|return
name|__first
operator|==
name|__last
condition|?
name|__first
else|:
name|std
operator|::
name|remove_copy_if
argument_list|(
operator|++
name|__i
argument_list|,
name|__last
argument_list|,
name|__first
argument_list|,
name|__pred
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @if maint    *  This is an uglified unique_copy(_InputIterator, _InputIterator,    *                                  _OutputIterator)    *  overloaded for forward iterators and output iterator as result.    *  @endif   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|__unique_copy
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|forward_iterator_tag
argument_list|,
argument|output_iterator_tag
argument_list|)
block|{
comment|// concept requirements -- taken care of in dispatching function
name|_ForwardIterator
name|__next
operator|=
name|__first
block|;
operator|*
name|__result
operator|=
operator|*
name|__first
block|;
while|while
condition|(
operator|++
name|__next
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
operator|(
operator|*
name|__first
operator|==
operator|*
name|__next
operator|)
condition|)
block|{
name|__first
operator|=
name|__next
expr_stmt|;
operator|*
operator|++
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|++
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified unique_copy(_InputIterator, _InputIterator,    *                                  _OutputIterator)    *  overloaded for input iterators and output iterator as result.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|__unique_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|input_iterator_tag
argument_list|,
argument|output_iterator_tag
argument_list|)
block|{
comment|// concept requirements -- taken care of in dispatching function
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|value_type
name|__value
operator|=
operator|*
name|__first
block|;
operator|*
name|__result
operator|=
name|__value
block|;
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
operator|(
name|__value
operator|==
operator|*
name|__first
operator|)
condition|)
block|{
name|__value
operator|=
operator|*
name|__first
expr_stmt|;
operator|*
operator|++
name|__result
operator|=
name|__value
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|++
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified unique_copy(_InputIterator, _InputIterator,    *                                  _OutputIterator)    *  overloaded for input iterators and forward iterator as result.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_ForwardIterator
operator|>
name|_ForwardIterator
name|__unique_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_ForwardIterator __result
argument_list|,
argument|input_iterator_tag
argument_list|,
argument|forward_iterator_tag
argument_list|)
block|{
comment|// concept requirements -- taken care of in dispatching function
operator|*
name|__result
operator|=
operator|*
name|__first
block|;
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
operator|(
operator|*
name|__result
operator|==
operator|*
name|__first
operator|)
condition|)
operator|*
operator|++
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|++
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,    *              _BinaryPredicate)    *  overloaded for forward iterators and output iterator as result.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_OutputIterator
name|__unique_copy
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|,
argument|forward_iterator_tag
argument_list|,
argument|output_iterator_tag
argument_list|)
block|{
comment|// concept requirements -- iterators already checked
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|_ForwardIterator
name|__next
operator|=
name|__first
block|;
operator|*
name|__result
operator|=
operator|*
name|__first
block|;
while|while
condition|(
operator|++
name|__next
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
name|__binary_pred
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
name|__next
argument_list|)
condition|)
block|{
name|__first
operator|=
name|__next
expr_stmt|;
operator|*
operator|++
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|++
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,    *              _BinaryPredicate)    *  overloaded for input iterators and output iterator as result.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_OutputIterator
name|__unique_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|,
argument|input_iterator_tag
argument_list|,
argument|output_iterator_tag
argument_list|)
block|{
comment|// concept requirements -- iterators already checked
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|value_type
name|__value
operator|=
operator|*
name|__first
block|;
operator|*
name|__result
operator|=
name|__value
block|;
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
name|__binary_pred
argument_list|(
name|__value
argument_list|,
operator|*
name|__first
argument_list|)
condition|)
block|{
name|__value
operator|=
operator|*
name|__first
expr_stmt|;
operator|*
operator|++
name|__result
operator|=
name|__value
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|++
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,    *              _BinaryPredicate)    *  overloaded for input iterators and forward iterator as result.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_ForwardIterator
name|__unique_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_ForwardIterator __result
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|,
argument|input_iterator_tag
argument_list|,
argument|forward_iterator_tag
argument_list|)
block|{
comment|// concept requirements -- iterators already checked
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
operator|*
name|__result
operator|=
operator|*
name|__first
block|;
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
name|__binary_pred
argument_list|(
operator|*
name|__result
argument_list|,
operator|*
name|__first
argument_list|)
condition|)
operator|*
operator|++
name|__result
operator|=
operator|*
name|__first
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|++
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Copy a sequence, removing consecutive duplicate values.    *  @param  first   An input iterator.    *  @param  last    An input iterator.    *  @param  result  An output iterator.    *  @return   An iterator designating the end of the resulting sequence.    *    *  Copies each element in the range @p [first,last) to the range    *  beginning at @p result, except that only the first element is copied    *  from groups of consecutive elements that compare equal.    *  unique_copy() is stable, so the relative order of elements that are    *  copied is unchanged.    *    *  @if maint    *  _GLIBCXX_RESOLVE_LIB_DEFECTS    *  DR 241. Does unique_copy() require CopyConstructible and Assignable?    *      *  _GLIBCXX_RESOLVE_LIB_DEFECTS    *  DR 538. 241 again: Does unique_copy() require CopyConstructible and     *  Assignable?    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|>
specifier|inline
name|_OutputIterator
name|unique_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualityComparableConcept< 	    typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__result
return|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|__unique_copy
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__result
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Copy a sequence, removing consecutive values using a predicate.    *  @param  first        An input iterator.    *  @param  last         An input iterator.    *  @param  result       An output iterator.    *  @param  binary_pred  A binary predicate.    *  @return   An iterator designating the end of the resulting sequence.    *    *  Copies each element in the range @p [first,last) to the range    *  beginning at @p result, except that only the first element is copied    *  from groups of consecutive elements for which @p binary_pred returns    *  true.    *  unique_copy() is stable, so the relative order of elements that are    *  copied is unchanged.    *    *  @if maint    *  _GLIBCXX_RESOLVE_LIB_DEFECTS    *  DR 241. Does unique_copy() require CopyConstructible and Assignable?    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_BinaryPredicate
operator|>
specifier|inline
name|_OutputIterator
name|unique_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|)
block|{
comment|// concept requirements -- predicates checked later
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__result
return|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|__unique_copy
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__result
argument_list|,
name|__binary_pred
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Remove consecutive duplicate values from a sequence.    *  @param  first  A forward iterator.    *  @param  last   A forward iterator.    *  @return  An iterator designating the end of the resulting sequence.    *    *  Removes all but the first element from each group of consecutive    *  values that compare equal.    *  unique() is stable, so the relative order of elements that are    *  not removed is unchanged.    *  Elements between the end of the resulting sequence and @p last    *  are still present, but their value is unspecified.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|>
name|_ForwardIterator
name|unique
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualityComparableConcept< 		     typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
comment|// Skip the beginning, if already unique.
name|__first
operator|=
name|std
operator|::
name|adjacent_find
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__last
return|;
comment|// Do the real copy work.
name|_ForwardIterator
name|__dest
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
operator|(
operator|*
name|__dest
operator|==
operator|*
name|__first
operator|)
condition|)
operator|*
operator|++
name|__dest
operator|=
operator|*
name|__first
expr_stmt|;
end_while

begin_return
return|return
operator|++
name|__dest
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Remove consecutive values from a sequence using a predicate.    *  @param  first        A forward iterator.    *  @param  last         A forward iterator.    *  @param  binary_pred  A binary predicate.    *  @return  An iterator designating the end of the resulting sequence.    *    *  Removes all but the first element from each group of consecutive    *  values for which @p binary_pred returns true.    *  unique() is stable, so the relative order of elements that are    *  not removed is unchanged.    *  Elements between the end of the resulting sequence and @p last    *  are still present, but their value is unspecified.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_ForwardIterator
name|unique
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_BinaryPredicate __binary_pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
comment|// Skip the beginning, if already unique.
name|__first
operator|=
name|std
operator|::
name|adjacent_find
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__binary_pred
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__last
return|;
comment|// Do the real copy work.
name|_ForwardIterator
name|__dest
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|!
name|__binary_pred
argument_list|(
operator|*
name|__dest
argument_list|,
operator|*
name|__first
argument_list|)
condition|)
operator|*
operator|++
name|__dest
operator|=
operator|*
name|__first
expr_stmt|;
end_while

begin_return
return|return
operator|++
name|__dest
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified reverse(_BidirectionalIterator,    *                              _BidirectionalIterator)    *  overloaded for bidirectional iterators.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|>
name|void
name|__reverse
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|bidirectional_iterator_tag
argument_list|)
block|{
while|while
condition|(
name|true
condition|)
if|if
condition|(
name|__first
operator|==
name|__last
operator|||
name|__first
operator|==
operator|--
name|__last
condition|)
return|return;
else|else
block|{
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is an uglified reverse(_BidirectionalIterator,    *                              _BidirectionalIterator)    *  overloaded for random access iterators.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
name|void
name|__reverse
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|random_access_iterator_tag
argument_list|)
block|{
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return;
operator|--
name|__last
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first
operator|<
name|__last
condition|)
block|{
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
operator|--
name|__last
expr_stmt|;
block|}
end_while

begin_comment
unit|}
comment|/**    *  @brief Reverse a sequence.    *  @param  first  A bidirectional iterator.    *  @param  last   A bidirectional iterator.    *  @return   reverse() returns no value.    *    *  Reverses the order of the elements in the range @p [first,last),    *  so that the first element becomes the last etc.    *  For every @c i such that @p 0<=i<=(last-first)/2), @p reverse()    *  swaps @p *(first+i) and @p *(last-(i+1))   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|>
specifier|inline
name|void
name|reverse
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_BidirectionalIteratorConcept< 				  _BidirectionalIterator>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
name|std
operator|::
name|__reverse
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|)
block|;     }
comment|/**    *  @brief Copy a sequence, reversing its elements.    *  @param  first   A bidirectional iterator.    *  @param  last    A bidirectional iterator.    *  @param  result  An output iterator.    *  @return  An iterator designating the end of the resulting sequence.    *    *  Copies the elements in the range @p [first,last) to the range    *  @p [result,result+(last-first)) such that the order of the    *  elements is reversed.    *  For every @c i such that @p 0<=i<=(last-first), @p reverse_copy()    *  performs the assignment @p *(result+(last-first)-i) = *(first+i).    *  The ranges @p [first,last) and @p [result,result+(last-first))    *  must not overlap.   */
name|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|reverse_copy
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_BidirectionalIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
while|while
condition|(
name|__first
operator|!=
name|__last
condition|)
block|{
operator|--
name|__last
expr_stmt|;
operator|*
name|__result
operator|=
operator|*
name|__last
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the rotate algorithm specialized on RAIs.    *  It returns the greatest common divisor of two integer values.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_EuclideanRingElement
operator|>
name|_EuclideanRingElement
name|__gcd
argument_list|(
argument|_EuclideanRingElement __m
argument_list|,
argument|_EuclideanRingElement __n
argument_list|)
block|{
while|while
condition|(
name|__n
operator|!=
literal|0
condition|)
block|{
name|_EuclideanRingElement
name|__t
init|=
name|__m
operator|%
name|__n
decl_stmt|;
name|__m
operator|=
name|__n
expr_stmt|;
name|__n
operator|=
name|__t
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|__m
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the rotate algorithm.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|>
name|void
name|__rotate
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __middle
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|forward_iterator_tag
argument_list|)
block|{
if|if
condition|(
name|__first
operator|==
name|__middle
operator|||
name|__last
operator|==
name|__middle
condition|)
return|return;
name|_ForwardIterator
name|__first2
operator|=
name|__middle
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
name|swap
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
name|__first2
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
if|if
condition|(
name|__first
operator|==
name|__middle
condition|)
name|__middle
operator|=
name|__first2
expr_stmt|;
block|}
do|while
condition|(
name|__first2
operator|!=
name|__last
condition|)
do|;
end_do

begin_expr_stmt
name|__first2
operator|=
name|__middle
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first2
operator|!=
name|__last
condition|)
block|{
name|swap
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
name|__first2
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
if|if
condition|(
name|__first
operator|==
name|__middle
condition|)
name|__middle
operator|=
name|__first2
expr_stmt|;
elseif|else
if|if
condition|(
name|__first2
operator|==
name|__last
condition|)
name|__first2
operator|=
name|__middle
expr_stmt|;
block|}
end_while

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the rotate algorithm.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|>
name|void
name|__rotate
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __middle
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|bidirectional_iterator_tag
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_BidirectionalIteratorConcept< 				  _BidirectionalIterator>
argument_list|)
if|if
condition|(
name|__first
operator|==
name|__middle
operator|||
name|__last
operator|==
name|__middle
condition|)
return|return;
name|std
operator|::
name|__reverse
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|bidirectional_iterator_tag
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__reverse
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|bidirectional_iterator_tag
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first
operator|!=
name|__middle
operator|&&
name|__middle
operator|!=
name|__last
condition|)
block|{
name|swap
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
operator|--
name|__last
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_while

begin_if
if|if
condition|(
name|__first
operator|==
name|__middle
condition|)
name|std
operator|::
name|__reverse
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|bidirectional_iterator_tag
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|std
operator|::
name|__reverse
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|bidirectional_iterator_tag
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the rotate algorithm.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
name|void
name|__rotate
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __middle
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|random_access_iterator_tag
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 				  _RandomAccessIterator>
argument_list|)
if|if
condition|(
name|__first
operator|==
name|__middle
operator|||
name|__last
operator|==
name|__middle
condition|)
return|return;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|_Distance
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|const
name|_Distance
name|__n
init|=
name|__last
operator|-
name|__first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|_Distance
name|__k
init|=
name|__middle
operator|-
name|__first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|_Distance
name|__l
init|=
name|__n
operator|-
name|__k
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__k
operator|==
name|__l
condition|)
block|{
name|std
operator|::
name|swap_ranges
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_decl_stmt
specifier|const
name|_Distance
name|__d
init|=
name|__gcd
argument_list|(
name|__n
argument_list|,
name|__k
argument_list|)
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|_Distance
name|__i
init|=
literal|0
init|;
name|__i
operator|<
name|__d
condition|;
name|__i
operator|++
control|)
block|{
name|_ValueType
name|__tmp
init|=
operator|*
name|__first
decl_stmt|;
name|_RandomAccessIterator
name|__p
init|=
name|__first
decl_stmt|;
if|if
condition|(
name|__k
operator|<
name|__l
condition|)
block|{
for|for
control|(
name|_Distance
name|__j
init|=
literal|0
init|;
name|__j
operator|<
name|__l
operator|/
name|__d
condition|;
name|__j
operator|++
control|)
block|{
if|if
condition|(
name|__p
operator|>
name|__first
operator|+
name|__l
condition|)
block|{
operator|*
name|__p
operator|=
operator|*
operator|(
name|__p
operator|-
name|__l
operator|)
expr_stmt|;
name|__p
operator|-=
name|__l
expr_stmt|;
block|}
operator|*
name|__p
operator|=
operator|*
operator|(
name|__p
operator|+
name|__k
operator|)
expr_stmt|;
name|__p
operator|+=
name|__k
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|_Distance
name|__j
init|=
literal|0
init|;
name|__j
operator|<
name|__k
operator|/
name|__d
operator|-
literal|1
condition|;
name|__j
operator|++
control|)
block|{
if|if
condition|(
name|__p
operator|<
name|__last
operator|-
name|__k
condition|)
block|{
operator|*
name|__p
operator|=
operator|*
operator|(
name|__p
operator|+
name|__k
operator|)
expr_stmt|;
name|__p
operator|+=
name|__k
expr_stmt|;
block|}
operator|*
name|__p
operator|=
operator|*
operator|(
name|__p
operator|-
name|__l
operator|)
expr_stmt|;
name|__p
operator|-=
name|__l
expr_stmt|;
block|}
block|}
operator|*
name|__p
operator|=
name|__tmp
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_for

begin_comment
unit|}
comment|/**    *  @brief Rotate the elements of a sequence.    *  @param  first   A forward iterator.    *  @param  middle  A forward iterator.    *  @param  last    A forward iterator.    *  @return  Nothing.    *    *  Rotates the elements of the range @p [first,last) by @p (middle-first)    *  positions so that the element at @p middle is moved to @p first, the    *  element at @p middle+1 is moved to @first+1 and so on for each element    *  in the range @p [first,last).    *    *  This effectively swaps the ranges @p [first,middle) and    *  @p [middle,last).    *    *  Performs @p *(first+(n+(last-middle))%(last-first))=*(first+n) for    *  each @p n in the range @p [0,last-first).   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|>
specifier|inline
name|void
name|rotate
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __middle
argument_list|,
argument|_ForwardIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
block|;
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|iterator_category
name|_IterType
expr_stmt|;
name|std
operator|::
name|__rotate
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|_IterType
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Copy a sequence, rotating its elements.    *  @param  first   A forward iterator.    *  @param  middle  A forward iterator.    *  @param  last    A forward iterator.    *  @param  result  An output iterator.    *  @return   An iterator designating the end of the resulting sequence.    *    *  Copies the elements of the range @p [first,last) to the range    *  beginning at @result, rotating the copied elements by @p (middle-first)    *  positions so that the element at @p middle is moved to @p result, the    *  element at @p middle+1 is moved to @result+1 and so on for each element    *  in the range @p [first,last).    *    *  Performs @p *(result+(n+(last-middle))%(last-first))=*(first+n) for    *  each @p n in the range @p [0,last-first).   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|rotate_copy
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __middle
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
block|;
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|std
operator|::
name|copy
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__result
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Randomly shuffle the elements of a sequence.    *  @param  first   A forward iterator.    *  @param  last    A forward iterator.    *  @return  Nothing.    *    *  Reorder the elements in the range @p [first,last) using a random    *  distribution, so that every possible ordering of the sequence is    *  equally likely.   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
specifier|inline
name|void
name|random_shuffle
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|!=
name|__last
condition|)
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__first
operator|+
literal|1
init|;
name|__i
operator|!=
name|__last
condition|;
operator|++
name|__i
control|)
name|std
operator|::
name|iter_swap
argument_list|(
name|__i
argument_list|,
name|__first
operator|+
operator|(
name|std
operator|::
name|rand
argument_list|()
operator|%
operator|(
operator|(
name|__i
operator|-
name|__first
operator|)
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief Shuffle the elements of a sequence using a random number    *         generator.    *  @param  first   A forward iterator.    *  @param  last    A forward iterator.    *  @param  rand    The RNG functor or function.    *  @return  Nothing.    *    *  Reorders the elements in the range @p [first,last) using @p rand to    *  provide a random distribution. Calling @p rand(N) for a positive    *  integer @p N should return a randomly chosen integer from the    *  range [0,N).   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_RandomNumberGenerator
operator|>
name|void
name|random_shuffle
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_RandomNumberGenerator& __rand
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return;
end_expr_stmt

begin_for
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__first
operator|+
literal|1
init|;
name|__i
operator|!=
name|__last
condition|;
operator|++
name|__i
control|)
name|std
operator|::
name|iter_swap
argument_list|(
name|__i
argument_list|,
name|__first
operator|+
name|__rand
argument_list|(
operator|(
name|__i
operator|-
name|__first
operator|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function...    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Predicate
operator|>
name|_ForwardIterator
name|__partition
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|forward_iterator_tag
argument_list|)
block|{
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
end_expr_stmt

begin_while
while|while
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
if|if
condition|(
operator|++
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
end_while

begin_decl_stmt
name|_ForwardIterator
name|__next
init|=
name|__first
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
operator|++
name|__next
operator|!=
name|__last
condition|)
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__next
argument_list|)
condition|)
block|{
name|swap
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
name|__next
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function...    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Predicate
operator|>
name|_BidirectionalIterator
name|__partition
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|bidirectional_iterator_tag
argument_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
while|while
condition|(
name|true
condition|)
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
elseif|else
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
operator|++
name|__first
expr_stmt|;
else|else
break|break;
operator|--
name|__last
expr_stmt|;
while|while
condition|(
name|true
condition|)
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
elseif|else
if|if
condition|(
operator|!
name|__pred
argument_list|(
operator|*
name|__last
argument_list|)
condition|)
operator|--
name|__last
expr_stmt|;
else|else
break|break;
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Move elements for which a predicate is true to the beginning    *         of a sequence.    *  @param  first   A forward iterator.    *  @param  last    A forward iterator.    *  @param  pred    A predicate functor.    *  @return  An iterator @p middle such that @p pred(i) is true for each    *  iterator @p i in the range @p [first,middle) and false for each @p i    *  in the range @p [middle,last).    *    *  @p pred must not modify its operand. @p partition() does not preserve    *  the relative ordering of elements in each group, use    *  @p stable_partition() if this is needed.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Predicate
operator|>
specifier|inline
name|_ForwardIterator
name|partition
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Predicate   __pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
return|return
name|std
operator|::
name|__partition
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__pred
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @if maint    *  This is a helper function...    *  @endif   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Predicate
operator|,
name|typename
name|_Distance
operator|>
name|_ForwardIterator
name|__inplace_stable_partition
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|_Distance __len
argument_list|)
block|{
if|if
condition|(
name|__len
operator|==
literal|1
condition|)
return|return
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
operator|?
name|__last
operator|:
name|__first
return|;
name|_ForwardIterator
name|__middle
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__len
operator|/
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_ForwardIterator
name|__begin
init|=
name|std
operator|::
name|__inplace_stable_partition
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__pred
argument_list|,
name|__len
operator|/
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__end
init|=
name|std
operator|::
name|__inplace_stable_partition
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__pred
argument_list|,
name|__len
operator|-
name|__len
operator|/
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|rotate
argument_list|(
name|__begin
argument_list|,
name|__middle
argument_list|,
name|__end
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|advance
argument_list|(
name|__begin
argument_list|,
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__end
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__begin
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function...    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Pointer
operator|,
name|typename
name|_Predicate
operator|,
name|typename
name|_Distance
operator|>
name|_ForwardIterator
name|__stable_partition_adaptive
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|,
argument|_Distance __len
argument_list|,
argument|_Pointer __buffer
argument_list|,
argument|_Distance __buffer_size
argument_list|)
block|{
if|if
condition|(
name|__len
operator|<=
name|__buffer_size
condition|)
block|{
name|_ForwardIterator
name|__result1
init|=
name|__first
decl_stmt|;
name|_Pointer
name|__result2
init|=
name|__buffer
decl_stmt|;
for|for
control|(
init|;
name|__first
operator|!=
name|__last
condition|;
operator|++
name|__first
control|)
if|if
condition|(
name|__pred
argument_list|(
operator|*
name|__first
argument_list|)
condition|)
block|{
operator|*
name|__result1
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__result1
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
operator|*
name|__result2
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__result2
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|std
operator|::
name|copy
argument_list|(
name|__buffer
argument_list|,
name|__result2
argument_list|,
name|__result1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result1
return|;
end_return

begin_block
unit|}       else
block|{
name|_ForwardIterator
name|__middle
init|=
name|__first
decl_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__len
operator|/
literal|2
argument_list|)
expr_stmt|;
name|_ForwardIterator
name|__begin
init|=
name|std
operator|::
name|__stable_partition_adaptive
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__pred
argument_list|,
name|__len
operator|/
literal|2
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
decl_stmt|;
name|_ForwardIterator
name|__end
init|=
name|std
operator|::
name|__stable_partition_adaptive
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__pred
argument_list|,
name|__len
operator|-
name|__len
operator|/
literal|2
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
decl_stmt|;
name|std
operator|::
name|rotate
argument_list|(
name|__begin
argument_list|,
name|__middle
argument_list|,
name|__end
argument_list|)
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__begin
argument_list|,
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__end
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|__begin
return|;
block|}
end_block

begin_comment
unit|}
comment|/**    *  @brief Move elements for which a predicate is true to the beginning    *         of a sequence, preserving relative ordering.    *  @param  first   A forward iterator.    *  @param  last    A forward iterator.    *  @param  pred    A predicate functor.    *  @return  An iterator @p middle such that @p pred(i) is true for each    *  iterator @p i in the range @p [first,middle) and false for each @p i    *  in the range @p [middle,last).    *    *  Performs the same function as @p partition() with the additional    *  guarantee that the relative ordering of elements in each group is    *  preserved, so any two elements @p x and @p y in the range    *  @p [first,last) such that @p pred(x)==pred(y) will have the same    *  relative ordering after calling @p stable_partition().   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Predicate
operator|>
name|_ForwardIterator
name|stable_partition
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Predicate __pred
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_ForwardIteratorConcept< 				  _ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_UnaryPredicateConcept<_Predicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
else|else
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
name|_Temporary_buffer
operator|<
name|_ForwardIterator
operator|,
name|_ValueType
operator|>
name|__buf
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
if|if
condition|(
name|__buf
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
return|return
name|std
operator|::
name|__stable_partition_adaptive
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__pred
argument_list|,
name|_DistanceType
argument_list|(
name|__buf
operator|.
name|requested_size
argument_list|()
argument_list|)
argument_list|,
name|__buf
operator|.
name|begin
argument_list|()
argument_list|,
name|__buf
operator|.
name|size
argument_list|()
argument_list|)
return|;
else|else
return|return
name|std
operator|::
name|__inplace_stable_partition
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__pred
argument_list|,
name|_DistanceType
argument_list|(
name|__buf
operator|.
name|requested_size
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function...    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Tp
operator|>
name|_RandomAccessIterator
name|__unguarded_partition
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Tp __pivot
argument_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
while|while
condition|(
operator|*
name|__first
operator|<
name|__pivot
condition|)
operator|++
name|__first
expr_stmt|;
operator|--
name|__last
expr_stmt|;
while|while
condition|(
name|__pivot
operator|<
operator|*
name|__last
condition|)
operator|--
name|__last
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|__first
operator|<
name|__last
operator|)
condition|)
return|return
name|__first
return|;
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function...    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
name|_RandomAccessIterator
name|__unguarded_partition
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Tp __pivot
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
while|while
condition|(
name|__comp
argument_list|(
operator|*
name|__first
argument_list|,
name|__pivot
argument_list|)
condition|)
operator|++
name|__first
expr_stmt|;
operator|--
name|__last
expr_stmt|;
while|while
condition|(
name|__comp
argument_list|(
name|__pivot
argument_list|,
operator|*
name|__last
argument_list|)
condition|)
operator|--
name|__last
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|__first
operator|<
name|__last
operator|)
condition|)
return|return
name|__first
return|;
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  @doctodo    *  This controls some aspect of the sort routines.    *  @endif   */
end_comment

begin_block
unit|enum
block|{
name|_S_threshold
operator|=
literal|16
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Tp
operator|>
name|void
name|__unguarded_linear_insert
argument_list|(
argument|_RandomAccessIterator __last
argument_list|,
argument|_Tp __val
argument_list|)
block|{
name|_RandomAccessIterator
name|__next
operator|=
name|__last
block|;
operator|--
name|__next
block|;
while|while
condition|(
name|__val
operator|<
operator|*
name|__next
condition|)
block|{
operator|*
name|__last
operator|=
operator|*
name|__next
expr_stmt|;
name|__last
operator|=
name|__next
expr_stmt|;
operator|--
name|__next
expr_stmt|;
block|}
operator|*
name|__last
operator|=
name|__val
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__unguarded_linear_insert
argument_list|(
argument|_RandomAccessIterator __last
argument_list|,
argument|_Tp __val
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
name|_RandomAccessIterator
name|__next
operator|=
name|__last
block|;
operator|--
name|__next
block|;
while|while
condition|(
name|__comp
argument_list|(
name|__val
argument_list|,
operator|*
name|__next
argument_list|)
condition|)
block|{
operator|*
name|__last
operator|=
operator|*
name|__next
expr_stmt|;
name|__last
operator|=
name|__next
expr_stmt|;
operator|--
name|__next
expr_stmt|;
block|}
operator|*
name|__last
operator|=
name|__val
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
name|void
name|__insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return;
end_expr_stmt

begin_for
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__first
operator|+
literal|1
init|;
name|__i
operator|!=
name|__last
condition|;
operator|++
name|__i
control|)
block|{
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|__val
operator|=
operator|*
name|__i
expr_stmt|;
if|if
condition|(
name|__val
operator|<
operator|*
name|__first
condition|)
block|{
name|std
operator|::
name|copy_backward
argument_list|(
name|__first
argument_list|,
name|__i
argument_list|,
name|__i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|__first
operator|=
name|__val
expr_stmt|;
block|}
else|else
name|std
operator|::
name|__unguarded_linear_insert
argument_list|(
name|__i
argument_list|,
name|__val
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return;
end_expr_stmt

begin_for
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__first
operator|+
literal|1
init|;
name|__i
operator|!=
name|__last
condition|;
operator|++
name|__i
control|)
block|{
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|__val
operator|=
operator|*
name|__i
expr_stmt|;
if|if
condition|(
name|__comp
argument_list|(
name|__val
argument_list|,
operator|*
name|__first
argument_list|)
condition|)
block|{
name|std
operator|::
name|copy_backward
argument_list|(
name|__first
argument_list|,
name|__i
argument_list|,
name|__i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|__first
operator|=
name|__val
expr_stmt|;
block|}
else|else
name|std
operator|::
name|__unguarded_linear_insert
argument_list|(
name|__i
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
specifier|inline
name|void
name|__unguarded_insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__first
init|;
name|__i
operator|!=
name|__last
condition|;
operator|++
name|__i
control|)
name|std
operator|::
name|__unguarded_linear_insert
argument_list|(
name|__i
argument_list|,
name|_ValueType
argument_list|(
operator|*
name|__i
argument_list|)
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
specifier|inline
name|void
name|__unguarded_insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__first
init|;
name|__i
operator|!=
name|__last
condition|;
operator|++
name|__i
control|)
name|std
operator|::
name|__unguarded_linear_insert
argument_list|(
name|__i
argument_list|,
name|_ValueType
argument_list|(
operator|*
name|__i
argument_list|)
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
name|void
name|__final_insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
if|if
condition|(
name|__last
operator|-
name|__first
operator|>
name|int
argument_list|(
name|_S_threshold
argument_list|)
condition|)
block|{
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|int
argument_list|(
name|_S_threshold
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|__unguarded_insertion_sort
argument_list|(
name|__first
operator|+
name|int
argument_list|(
name|_S_threshold
argument_list|)
argument_list|,
name|__last
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_else

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__final_insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
if|if
condition|(
name|__last
operator|-
name|__first
operator|>
name|int
argument_list|(
name|_S_threshold
argument_list|)
condition|)
block|{
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|int
argument_list|(
name|_S_threshold
argument_list|)
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|std
operator|::
name|__unguarded_insertion_sort
argument_list|(
name|__first
operator|+
name|int
argument_list|(
name|_S_threshold
argument_list|)
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_else

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
name|void
name|__heap_select
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __middle
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
name|std
operator|::
name|make_heap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__middle
init|;
name|__i
operator|<
name|__last
condition|;
operator|++
name|__i
control|)
if|if
condition|(
operator|*
name|__i
operator|<
operator|*
name|__first
condition|)
name|std
operator|::
name|__pop_heap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__i
argument_list|,
name|_ValueType
argument_list|(
operator|*
name|__i
argument_list|)
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__heap_select
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __middle
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
name|std
operator|::
name|make_heap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|_RandomAccessIterator
name|__i
init|=
name|__middle
init|;
name|__i
operator|<
name|__last
condition|;
operator|++
name|__i
control|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__i
argument_list|,
operator|*
name|__first
argument_list|)
condition|)
name|std
operator|::
name|__pop_heap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__i
argument_list|,
name|_ValueType
argument_list|(
operator|*
name|__i
argument_list|)
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_Size
operator|>
specifier|inline
name|_Size
name|__lg
argument_list|(
argument|_Size __n
argument_list|)
block|{
name|_Size
name|__k
block|;
for|for
control|(
name|__k
operator|=
literal|0
init|;
name|__n
operator|!=
literal|1
condition|;
name|__n
operator|>>=
literal|1
control|)
operator|++
name|__k
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__k
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Sort the smallest elements of a sequence.    *  @param  first   An iterator.    *  @param  middle  Another iterator.    *  @param  last    Another iterator.    *  @return  Nothing.    *    *  Sorts the smallest @p (middle-first) elements in the range    *  @p [first,last) and moves them to the range @p [first,middle). The    *  order of the remaining elements in the range @p [middle,last) is    *  undefined.    *  After the sort if @p i and @j are iterators in the range    *  @p [first,middle) such that @i precedes @j and @k is an iterator in    *  the range @p [middle,last) then @p *j<*i and @p *k<*i are both false.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
specifier|inline
name|void
name|partial_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __middle
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept<_ValueType>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__heap_select
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|sort_heap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Sort the smallest elements of a sequence using a predicate    *         for comparison.    *  @param  first   An iterator.    *  @param  middle  Another iterator.    *  @param  last    Another iterator.    *  @param  comp    A comparison functor.    *  @return  Nothing.    *    *  Sorts the smallest @p (middle-first) elements in the range    *  @p [first,last) and moves them to the range @p [first,middle). The    *  order of the remaining elements in the range @p [middle,last) is    *  undefined.    *  After the sort if @p i and @j are iterators in the range    *  @p [first,middle) such that @i precedes @j and @k is an iterator in    *  the range @p [middle,last) then @p *comp(j,*i) and @p comp(*k,*i)    *  are both false.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
specifier|inline
name|void
name|partial_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __middle
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType
argument_list|,
argument|_ValueType>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__heap_select
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|sort_heap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Copy the smallest elements of a sequence.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  result_first   A random-access iterator.    *  @param  result_last    Another random-access iterator.    *  @return   An iterator indicating the end of the resulting sequence.    *    *  Copies and sorts the smallest N values from the range @p [first,last)    *  to the range beginning at @p result_first, where the number of    *  elements to be copied, @p N, is the smaller of @p (last-first) and    *  @p (result_last-result_first).    *  After the sort if @p i and @j are iterators in the range    *  @p [result_first,result_first+N) such that @i precedes @j then    *  @p *j<*i is false.    *  The value returned is @p result_first+N.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_RandomAccessIterator
operator|>
name|_RandomAccessIterator
name|partial_sort_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_RandomAccessIterator __result_first
argument_list|,
argument|_RandomAccessIterator __result_last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|value_type
name|_InputValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_OutputValueType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_InputValueType
argument_list|,
argument|_OutputValueType>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_InputValueType
argument_list|,
argument|_OutputValueType>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept<_OutputValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__result_first
argument_list|,
name|__result_last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__result_first
operator|==
name|__result_last
condition|)
return|return
name|__result_last
return|;
end_if

begin_decl_stmt
name|_RandomAccessIterator
name|__result_real_last
init|=
name|__result_first
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
name|__result_real_last
operator|!=
name|__result_last
condition|)
block|{
operator|*
name|__result_real_last
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__result_real_last
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|std
operator|::
name|make_heap
argument_list|(
name|__result_first
argument_list|,
name|__result_real_last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first
operator|!=
name|__last
condition|)
block|{
if|if
condition|(
operator|*
name|__first
operator|<
operator|*
name|__result_first
condition|)
name|std
operator|::
name|__adjust_heap
argument_list|(
name|__result_first
argument_list|,
name|_DistanceType
argument_list|(
literal|0
argument_list|)
argument_list|,
name|_DistanceType
argument_list|(
name|__result_real_last
operator|-
name|__result_first
argument_list|)
argument_list|,
name|_InputValueType
argument_list|(
operator|*
name|__first
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|std
operator|::
name|sort_heap
argument_list|(
name|__result_first
argument_list|,
name|__result_real_last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result_real_last
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Copy the smallest elements of a sequence using a predicate for    *         comparison.    *  @param  first   An input iterator.    *  @param  last    Another input iterator.    *  @param  result_first   A random-access iterator.    *  @param  result_last    Another random-access iterator.    *  @param  comp    A comparison functor.    *  @return   An iterator indicating the end of the resulting sequence.    *    *  Copies and sorts the smallest N values from the range @p [first,last)    *  to the range beginning at @p result_first, where the number of    *  elements to be copied, @p N, is the smaller of @p (last-first) and    *  @p (result_last-result_first).    *  After the sort if @p i and @j are iterators in the range    *  @p [result_first,result_first+N) such that @i precedes @j then    *  @p comp(*j,*i) is false.    *  The value returned is @p result_first+N.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
name|_RandomAccessIterator
name|partial_sort_copy
argument_list|(
argument|_InputIterator __first
argument_list|,
argument|_InputIterator __last
argument_list|,
argument|_RandomAccessIterator __result_first
argument_list|,
argument|_RandomAccessIterator __result_last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator
operator|>
operator|::
name|value_type
name|_InputValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_OutputValueType
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 				  _RandomAccessIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_InputValueType
argument_list|,
argument|_OutputValueType>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_InputValueType
argument_list|,
argument|_OutputValueType>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_OutputValueType
argument_list|,
argument|_OutputValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__result_first
argument_list|,
name|__result_last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__result_first
operator|==
name|__result_last
condition|)
return|return
name|__result_last
return|;
end_if

begin_decl_stmt
name|_RandomAccessIterator
name|__result_real_last
init|=
name|__result_first
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__first
operator|!=
name|__last
operator|&&
name|__result_real_last
operator|!=
name|__result_last
condition|)
block|{
operator|*
name|__result_real_last
operator|=
operator|*
name|__first
expr_stmt|;
operator|++
name|__result_real_last
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|std
operator|::
name|make_heap
argument_list|(
name|__result_first
argument_list|,
name|__result_real_last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first
operator|!=
name|__last
condition|)
block|{
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
name|__result_first
argument_list|)
condition|)
name|std
operator|::
name|__adjust_heap
argument_list|(
name|__result_first
argument_list|,
name|_DistanceType
argument_list|(
literal|0
argument_list|)
argument_list|,
name|_DistanceType
argument_list|(
name|__result_real_last
operator|-
name|__result_first
argument_list|)
argument_list|,
name|_InputValueType
argument_list|(
operator|*
name|__first
argument_list|)
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
operator|++
name|__first
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|std
operator|::
name|sort_heap
argument_list|(
name|__result_first
argument_list|,
name|__result_real_last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|__result_real_last
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Size
operator|>
name|void
name|__introsort_loop
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Size __depth_limit
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__last
operator|-
name|__first
operator|>
name|int
argument_list|(
name|_S_threshold
argument_list|)
condition|)
block|{
if|if
condition|(
name|__depth_limit
operator|==
literal|0
condition|)
block|{
name|std
operator|::
name|partial_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|__depth_limit
expr_stmt|;
name|_RandomAccessIterator
name|__cut
init|=
name|std
operator|::
name|__unguarded_partition
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|_ValueType
argument_list|(
name|std
operator|::
name|__median
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
operator|(
name|__first
operator|+
operator|(
name|__last
operator|-
name|__first
operator|)
operator|/
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|__last
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|std
operator|::
name|__introsort_loop
argument_list|(
name|__cut
argument_list|,
name|__last
argument_list|,
name|__depth_limit
argument_list|)
expr_stmt|;
name|__last
operator|=
name|__cut
expr_stmt|;
block|}
end_while

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the sort routine.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Size
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__introsort_loop
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Size __depth_limit
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__last
operator|-
name|__first
operator|>
name|int
argument_list|(
name|_S_threshold
argument_list|)
condition|)
block|{
if|if
condition|(
name|__depth_limit
operator|==
literal|0
condition|)
block|{
name|std
operator|::
name|partial_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|__depth_limit
expr_stmt|;
name|_RandomAccessIterator
name|__cut
init|=
name|std
operator|::
name|__unguarded_partition
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|_ValueType
argument_list|(
name|std
operator|::
name|__median
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
operator|(
name|__first
operator|+
operator|(
name|__last
operator|-
name|__first
operator|)
operator|/
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|__last
operator|-
literal|1
operator|)
argument_list|,
name|__comp
argument_list|)
argument_list|)
argument_list|,
name|__comp
argument_list|)
decl_stmt|;
name|std
operator|::
name|__introsort_loop
argument_list|(
name|__cut
argument_list|,
name|__last
argument_list|,
name|__depth_limit
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__last
operator|=
name|__cut
expr_stmt|;
block|}
end_while

begin_comment
unit|}
comment|/**    *  @brief Sort the elements of a sequence.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @return  Nothing.    *    *  Sorts the elements in the range @p [first,last) in ascending order,    *  such that @p *(i+1)<*i is false for each iterator @p i in the range    *  @p [first,last-1).    *    *  The relative ordering of equivalent elements is not preserved, use    *  @p stable_sort() if this is needed.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
specifier|inline
name|void
name|sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept<_ValueType>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first
operator|!=
name|__last
condition|)
block|{
name|std
operator|::
name|__introsort_loop
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|std
operator|::
name|__lg
argument_list|(
name|__last
operator|-
name|__first
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|std
operator|::
name|__final_insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|/**    *  @brief Sort the elements of a sequence using a predicate for comparison.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  comp    A comparison functor.    *  @return  Nothing.    *    *  Sorts the elements in the range @p [first,last) in ascending order,    *  such that @p comp(*(i+1),*i) is false for every iterator @p i in the    *  range @p [first,last-1).    *    *  The relative ordering of equivalent elements is not preserved, use    *  @p stable_sort() if this is needed.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
specifier|inline
name|void
name|sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType
argument_list|,
argument|_ValueType>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first
operator|!=
name|__last
condition|)
block|{
name|std
operator|::
name|__introsort_loop
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|std
operator|::
name|__lg
argument_list|(
name|__last
operator|-
name|__first
argument_list|)
operator|*
literal|2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|std
operator|::
name|__final_insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|/**    *  @brief Finds the first position in which @a val could be inserted    *         without changing the ordering.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @return  An iterator pointing to the first element "not less than" @a val,    *           or end() if every element is less than @a val.    *  @ingroup binarysearch   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|>
name|_ForwardIterator
name|lower_bound
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType
argument_list|,
argument|_Tp>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_partitioned
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_DistanceType
name|__len
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__half
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__middle
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__len
operator|>
literal|0
condition|)
block|{
name|__half
operator|=
name|__len
operator|>>
literal|1
expr_stmt|;
name|__middle
operator|=
name|__first
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__half
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|__middle
operator|<
name|__val
condition|)
block|{
name|__first
operator|=
name|__middle
expr_stmt|;
operator|++
name|__first
expr_stmt|;
name|__len
operator|=
name|__len
operator|-
name|__half
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|__len
operator|=
name|__half
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Finds the first position in which @a val could be inserted    *         without changing the ordering.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @param  comp    A functor to use for comparisons.    *  @return  An iterator pointing to the first element "not less than" @a val,    *           or end() if every element is less than @a val.    *  @ingroup binarysearch    *    *  The comparison function should have the same effects on ordering as    *  the function used for the initial sort.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
name|_ForwardIterator
name|lower_bound
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType
argument_list|,
argument|_Tp>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_partitioned_pred
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_DistanceType
name|__len
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__half
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__middle
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__len
operator|>
literal|0
condition|)
block|{
name|__half
operator|=
name|__len
operator|>>
literal|1
expr_stmt|;
name|__middle
operator|=
name|__first
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__half
argument_list|)
expr_stmt|;
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__middle
argument_list|,
name|__val
argument_list|)
condition|)
block|{
name|__first
operator|=
name|__middle
expr_stmt|;
operator|++
name|__first
expr_stmt|;
name|__len
operator|=
name|__len
operator|-
name|__half
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|__len
operator|=
name|__half
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Finds the last position in which @a val could be inserted    *         without changing the ordering.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @return  An iterator pointing to the first element greater than @a val,    *           or end() if no elements are greater than @a val.    *  @ingroup binarysearch   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|>
name|_ForwardIterator
name|upper_bound
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_Tp
argument_list|,
argument|_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_partitioned
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_DistanceType
name|__len
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__half
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__middle
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__len
operator|>
literal|0
condition|)
block|{
name|__half
operator|=
name|__len
operator|>>
literal|1
expr_stmt|;
name|__middle
operator|=
name|__first
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__half
argument_list|)
expr_stmt|;
if|if
condition|(
name|__val
operator|<
operator|*
name|__middle
condition|)
name|__len
operator|=
name|__half
expr_stmt|;
else|else
block|{
name|__first
operator|=
name|__middle
expr_stmt|;
operator|++
name|__first
expr_stmt|;
name|__len
operator|=
name|__len
operator|-
name|__half
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_while

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Finds the last position in which @a val could be inserted    *         without changing the ordering.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @param  comp    A functor to use for comparisons.    *  @return  An iterator pointing to the first element greater than @a val,    *           or end() if no elements are greater than @a val.    *  @ingroup binarysearch    *    *  The comparison function should have the same effects on ordering as    *  the function used for the initial sort.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
name|_ForwardIterator
name|upper_bound
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_Tp
argument_list|,
argument|_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_partitioned_pred
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_DistanceType
name|__len
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__half
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__middle
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__len
operator|>
literal|0
condition|)
block|{
name|__half
operator|=
name|__len
operator|>>
literal|1
expr_stmt|;
name|__middle
operator|=
name|__first
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__half
argument_list|)
expr_stmt|;
if|if
condition|(
name|__comp
argument_list|(
name|__val
argument_list|,
operator|*
name|__middle
argument_list|)
condition|)
name|__len
operator|=
name|__half
expr_stmt|;
else|else
block|{
name|__first
operator|=
name|__middle
expr_stmt|;
operator|++
name|__first
expr_stmt|;
name|__len
operator|=
name|__len
operator|-
name|__half
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_while

begin_return
return|return
name|__first
return|;
end_return

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the merge routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Distance
operator|>
name|void
name|__merge_without_buffer
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __middle
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Distance __len1
argument_list|,
argument|_Distance __len2
argument_list|)
block|{
if|if
condition|(
name|__len1
operator|==
literal|0
operator|||
name|__len2
operator|==
literal|0
condition|)
return|return;
end_expr_stmt

begin_if
if|if
condition|(
name|__len1
operator|+
name|__len2
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|__middle
operator|<
operator|*
name|__first
condition|)
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_decl_stmt
name|_BidirectionalIterator
name|__first_cut
init|=
name|__first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_BidirectionalIterator
name|__second_cut
init|=
name|__middle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Distance
name|__len11
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Distance
name|__len22
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__len1
operator|>
name|__len2
condition|)
block|{
name|__len11
operator|=
name|__len1
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__first_cut
argument_list|,
name|__len11
argument_list|)
expr_stmt|;
name|__second_cut
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
operator|*
name|__first_cut
argument_list|)
expr_stmt|;
name|__len22
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__second_cut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__len22
operator|=
name|__len2
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__second_cut
argument_list|,
name|__len22
argument_list|)
expr_stmt|;
name|__first_cut
operator|=
name|std
operator|::
name|upper_bound
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
operator|*
name|__second_cut
argument_list|)
expr_stmt|;
name|__len11
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|std
operator|::
name|rotate
argument_list|(
name|__first_cut
argument_list|,
name|__middle
argument_list|,
name|__second_cut
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_BidirectionalIterator
name|__new_middle
init|=
name|__first_cut
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|advance
argument_list|(
name|__new_middle
argument_list|,
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__second_cut
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|,
name|__new_middle
argument_list|,
name|__len11
argument_list|,
name|__len22
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__new_middle
argument_list|,
name|__second_cut
argument_list|,
name|__last
argument_list|,
name|__len1
operator|-
name|__len11
argument_list|,
name|__len2
operator|-
name|__len22
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the merge routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Distance
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__merge_without_buffer
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __middle
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Distance __len1
argument_list|,
argument|_Distance __len2
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
if|if
condition|(
name|__len1
operator|==
literal|0
operator|||
name|__len2
operator|==
literal|0
condition|)
return|return;
end_expr_stmt

begin_if
if|if
condition|(
name|__len1
operator|+
name|__len2
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__middle
argument_list|,
operator|*
name|__first
argument_list|)
condition|)
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_decl_stmt
name|_BidirectionalIterator
name|__first_cut
init|=
name|__first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_BidirectionalIterator
name|__second_cut
init|=
name|__middle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Distance
name|__len11
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Distance
name|__len22
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__len1
operator|>
name|__len2
condition|)
block|{
name|__len11
operator|=
name|__len1
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__first_cut
argument_list|,
name|__len11
argument_list|)
expr_stmt|;
name|__second_cut
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
operator|*
name|__first_cut
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__len22
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__second_cut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__len22
operator|=
name|__len2
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__second_cut
argument_list|,
name|__len22
argument_list|)
expr_stmt|;
name|__first_cut
operator|=
name|std
operator|::
name|upper_bound
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
operator|*
name|__second_cut
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__len11
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|std
operator|::
name|rotate
argument_list|(
name|__first_cut
argument_list|,
name|__middle
argument_list|,
name|__second_cut
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_BidirectionalIterator
name|__new_middle
init|=
name|__first_cut
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|advance
argument_list|(
name|__new_middle
argument_list|,
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__second_cut
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|,
name|__new_middle
argument_list|,
name|__len11
argument_list|,
name|__len22
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__new_middle
argument_list|,
name|__second_cut
argument_list|,
name|__last
argument_list|,
name|__len1
operator|-
name|__len11
argument_list|,
name|__len2
operator|-
name|__len22
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the stable sorting routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
name|void
name|__inplace_stable_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
if|if
condition|(
name|__last
operator|-
name|__first
operator|<
literal|15
condition|)
block|{
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return;
block|}
name|_RandomAccessIterator
name|__middle
operator|=
name|__first
operator|+
operator|(
name|__last
operator|-
name|__first
operator|)
operator|/
literal|2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__inplace_stable_sort
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__inplace_stable_sort
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__middle
operator|-
name|__first
argument_list|,
name|__last
operator|-
name|__middle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the stable sorting routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__inplace_stable_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
if|if
condition|(
name|__last
operator|-
name|__first
operator|<
literal|15
condition|)
block|{
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
return|return;
block|}
name|_RandomAccessIterator
name|__middle
operator|=
name|__first
operator|+
operator|(
name|__last
operator|-
name|__first
operator|)
operator|/
literal|2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__inplace_stable_sort
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__inplace_stable_sort
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__middle
operator|-
name|__first
argument_list|,
name|__last
operator|-
name|__middle
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Merges two sorted ranges.    *  @param  first1  An iterator.    *  @param  first2  Another iterator.    *  @param  last1   Another iterator.    *  @param  last2   Another iterator.    *  @param  result  An iterator pointing to the end of the merged range.    *  @return  An iterator pointing to the first element "not less than" @a val.    *    *  Merges the ranges [first1,last1) and [first2,last2) into the sorted range    *  [result, result + (last1-first1) + (last2-first2)).  Both input ranges    *  must be sorted, and the output range must not overlap with either of    *  the input ranges.  The sort is @e stable, that is, for equivalent    *  elements in the two ranges, elements from the first range will always    *  come before elements from the second.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|merge
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
block|{
if|if
condition|(
operator|*
name|__first2
operator|<
operator|*
name|__first1
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first2
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
block|}
operator|++
name|__result
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Merges two sorted ranges.    *  @param  first1  An iterator.    *  @param  first2  Another iterator.    *  @param  last1   Another iterator.    *  @param  last2   Another iterator.    *  @param  result  An iterator pointing to the end of the merged range.    *  @param  comp    A functor to use for comparisons.    *  @return  An iterator pointing to the first element "not less than" @a val.    *    *  Merges the ranges [first1,last1) and [first2,last2) into the sorted range    *  [result, result + (last1-first1) + (last2-first2)).  Both input ranges    *  must be sorted, and the output range must not overlap with either of    *  the input ranges.  The sort is @e stable, that is, for equivalent    *  elements in the two ranges, elements from the first range will always    *  come before elements from the second.    *    *  The comparison function should have the same effects on ordering as    *  the function used for the initial sort.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Compare
operator|>
name|_OutputIterator
name|merge
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
block|{
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first2
argument_list|,
operator|*
name|__first1
argument_list|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first2
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
block|}
operator|++
name|__result
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator1
operator|,
name|typename
name|_RandomAccessIterator2
operator|,
name|typename
name|_Distance
operator|>
name|void
name|__merge_sort_loop
argument_list|(
argument|_RandomAccessIterator1 __first
argument_list|,
argument|_RandomAccessIterator1 __last
argument_list|,
argument|_RandomAccessIterator2 __result
argument_list|,
argument|_Distance __step_size
argument_list|)
block|{
specifier|const
name|_Distance
name|__two_step
operator|=
literal|2
operator|*
name|__step_size
block|;
while|while
condition|(
name|__last
operator|-
name|__first
operator|>=
name|__two_step
condition|)
block|{
name|__result
operator|=
name|std
operator|::
name|merge
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__first
operator|+
name|__two_step
argument_list|,
name|__result
argument_list|)
expr_stmt|;
name|__first
operator|+=
name|__two_step
expr_stmt|;
block|}
name|__step_size
operator|=
name|std
operator|::
name|min
argument_list|(
name|_Distance
argument_list|(
name|__last
operator|-
name|__first
argument_list|)
argument_list|,
name|__step_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|merge
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__last
argument_list|,
name|__result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator1
operator|,
name|typename
name|_RandomAccessIterator2
operator|,
name|typename
name|_Distance
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__merge_sort_loop
argument_list|(
argument|_RandomAccessIterator1 __first
argument_list|,
argument|_RandomAccessIterator1 __last
argument_list|,
argument|_RandomAccessIterator2 __result
argument_list|,
argument|_Distance __step_size
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
specifier|const
name|_Distance
name|__two_step
operator|=
literal|2
operator|*
name|__step_size
block|;
while|while
condition|(
name|__last
operator|-
name|__first
operator|>=
name|__two_step
condition|)
block|{
name|__result
operator|=
name|std
operator|::
name|merge
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__first
operator|+
name|__two_step
argument_list|,
name|__result
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__first
operator|+=
name|__two_step
expr_stmt|;
block|}
name|__step_size
operator|=
name|std
operator|::
name|min
argument_list|(
name|_Distance
argument_list|(
name|__last
operator|-
name|__first
argument_list|)
argument_list|,
name|__step_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|merge
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__first
operator|+
name|__step_size
argument_list|,
name|__last
argument_list|,
name|__result
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
unit|}    enum
block|{
name|_S_chunk_size
operator|=
literal|7
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Distance
operator|>
name|void
name|__chunk_insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Distance __chunk_size
argument_list|)
block|{
while|while
condition|(
name|__last
operator|-
name|__first
operator|>=
name|__chunk_size
condition|)
block|{
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|__chunk_size
argument_list|)
expr_stmt|;
name|__first
operator|+=
name|__chunk_size
expr_stmt|;
block|}
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Distance
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__chunk_insertion_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Distance __chunk_size
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
while|while
condition|(
name|__last
operator|-
name|__first
operator|>=
name|__chunk_size
condition|)
block|{
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__first
operator|+
name|__chunk_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__first
operator|+=
name|__chunk_size
expr_stmt|;
block|}
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Pointer
operator|>
name|void
name|__merge_sort_with_buffer
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Pointer __buffer
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|_Distance
expr_stmt|;
specifier|const
name|_Distance
name|__len
operator|=
name|__last
operator|-
name|__first
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|_Pointer
name|__buffer_last
init|=
name|__buffer
operator|+
name|__len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Distance
name|__step_size
init|=
name|_S_chunk_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|__chunk_insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__step_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__step_size
operator|<
name|__len
condition|)
block|{
name|std
operator|::
name|__merge_sort_loop
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|,
name|__step_size
argument_list|)
expr_stmt|;
name|__step_size
operator|*=
literal|2
expr_stmt|;
name|std
operator|::
name|__merge_sort_loop
argument_list|(
name|__buffer
argument_list|,
name|__buffer_last
argument_list|,
name|__first
argument_list|,
name|__step_size
argument_list|)
expr_stmt|;
name|__step_size
operator|*=
literal|2
expr_stmt|;
block|}
end_while

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Pointer
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__merge_sort_with_buffer
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Pointer __buffer
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|_Distance
expr_stmt|;
specifier|const
name|_Distance
name|__len
operator|=
name|__last
operator|-
name|__first
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|_Pointer
name|__buffer_last
init|=
name|__buffer
operator|+
name|__len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Distance
name|__step_size
init|=
name|_S_chunk_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|__chunk_insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__step_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__step_size
operator|<
name|__len
condition|)
block|{
name|std
operator|::
name|__merge_sort_loop
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|,
name|__step_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__step_size
operator|*=
literal|2
expr_stmt|;
name|std
operator|::
name|__merge_sort_loop
argument_list|(
name|__buffer
argument_list|,
name|__buffer_last
argument_list|,
name|__first
argument_list|,
name|__step_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__step_size
operator|*=
literal|2
expr_stmt|;
block|}
end_while

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the merge routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator1
operator|,
name|typename
name|_BidirectionalIterator2
operator|,
name|typename
name|_BidirectionalIterator3
operator|>
name|_BidirectionalIterator3
name|__merge_backward
argument_list|(
argument|_BidirectionalIterator1 __first1
argument_list|,
argument|_BidirectionalIterator1 __last1
argument_list|,
argument|_BidirectionalIterator2 __first2
argument_list|,
argument|_BidirectionalIterator2 __last2
argument_list|,
argument|_BidirectionalIterator3 __result
argument_list|)
block|{
if|if
condition|(
name|__first1
operator|==
name|__last1
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__result
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first2
operator|==
name|__last2
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
return|;
end_if

begin_expr_stmt
operator|--
name|__last1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|--
name|__last2
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
operator|*
name|__last2
operator|<
operator|*
name|__last1
condition|)
block|{
operator|*
operator|--
name|__result
operator|=
operator|*
name|__last1
expr_stmt|;
if|if
condition|(
name|__first1
operator|==
name|__last1
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first2
argument_list|,
operator|++
name|__last2
argument_list|,
name|__result
argument_list|)
return|;
operator|--
name|__last1
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|--
name|__result
operator|=
operator|*
name|__last2
expr_stmt|;
if|if
condition|(
name|__first2
operator|==
name|__last2
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first1
argument_list|,
operator|++
name|__last1
argument_list|,
name|__result
argument_list|)
return|;
operator|--
name|__last2
expr_stmt|;
block|}
block|}
end_while

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the merge routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator1
operator|,
name|typename
name|_BidirectionalIterator2
operator|,
name|typename
name|_BidirectionalIterator3
operator|,
name|typename
name|_Compare
operator|>
name|_BidirectionalIterator3
name|__merge_backward
argument_list|(
argument|_BidirectionalIterator1 __first1
argument_list|,
argument|_BidirectionalIterator1 __last1
argument_list|,
argument|_BidirectionalIterator2 __first2
argument_list|,
argument|_BidirectionalIterator2 __last2
argument_list|,
argument|_BidirectionalIterator3 __result
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
if|if
condition|(
name|__first1
operator|==
name|__last1
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__result
argument_list|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first2
operator|==
name|__last2
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
return|;
end_if

begin_expr_stmt
operator|--
name|__last1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|--
name|__last2
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__last2
argument_list|,
operator|*
name|__last1
argument_list|)
condition|)
block|{
operator|*
operator|--
name|__result
operator|=
operator|*
name|__last1
expr_stmt|;
if|if
condition|(
name|__first1
operator|==
name|__last1
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first2
argument_list|,
operator|++
name|__last2
argument_list|,
name|__result
argument_list|)
return|;
operator|--
name|__last1
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|--
name|__result
operator|=
operator|*
name|__last2
expr_stmt|;
if|if
condition|(
name|__first2
operator|==
name|__last2
condition|)
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__first1
argument_list|,
operator|++
name|__last1
argument_list|,
name|__result
argument_list|)
return|;
operator|--
name|__last2
expr_stmt|;
block|}
block|}
end_while

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the merge routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator1
operator|,
name|typename
name|_BidirectionalIterator2
operator|,
name|typename
name|_Distance
operator|>
name|_BidirectionalIterator1
name|__rotate_adaptive
argument_list|(
argument|_BidirectionalIterator1 __first
argument_list|,
argument|_BidirectionalIterator1 __middle
argument_list|,
argument|_BidirectionalIterator1 __last
argument_list|,
argument|_Distance __len1
argument_list|,
argument|_Distance __len2
argument_list|,
argument|_BidirectionalIterator2 __buffer
argument_list|,
argument|_Distance __buffer_size
argument_list|)
block|{
name|_BidirectionalIterator2
name|__buffer_end
block|;
if|if
condition|(
name|__len1
operator|>
name|__len2
operator|&&
name|__len2
operator|<=
name|__buffer_size
condition|)
block|{
name|__buffer_end
operator|=
name|std
operator|::
name|copy
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy_backward
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|copy
argument_list|(
name|__buffer
argument_list|,
name|__buffer_end
argument_list|,
name|__first
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__len1
operator|<=
name|__buffer_size
condition|)
block|{
name|__buffer_end
operator|=
name|std
operator|::
name|copy
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__first
argument_list|)
expr_stmt|;
return|return
name|std
operator|::
name|copy_backward
argument_list|(
name|__buffer
argument_list|,
name|__buffer_end
argument_list|,
name|__last
argument_list|)
return|;
block|}
end_elseif

begin_else
else|else
block|{
name|std
operator|::
name|rotate
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|)
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__first
argument_list|,
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|__first
return|;
block|}
end_else

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the merge routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Distance
operator|,
name|typename
name|_Pointer
operator|>
name|void
name|__merge_adaptive
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __middle
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Distance __len1
argument_list|,
argument|_Distance __len2
argument_list|,
argument|_Pointer __buffer
argument_list|,
argument|_Distance __buffer_size
argument_list|)
block|{
if|if
condition|(
name|__len1
operator|<=
name|__len2
operator|&&
name|__len1
operator|<=
name|__buffer_size
condition|)
block|{
name|_Pointer
name|__buffer_end
init|=
name|std
operator|::
name|copy
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|)
decl_stmt|;
name|std
operator|::
name|merge
argument_list|(
name|__buffer
argument_list|,
name|__buffer_end
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__len2
operator|<=
name|__buffer_size
condition|)
block|{
name|_Pointer
name|__buffer_end
init|=
name|std
operator|::
name|copy
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|)
decl_stmt|;
name|std
operator|::
name|__merge_backward
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|,
name|__buffer_end
argument_list|,
name|__last
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_else
else|else
block|{
name|_BidirectionalIterator
name|__first_cut
init|=
name|__first
decl_stmt|;
name|_BidirectionalIterator
name|__second_cut
init|=
name|__middle
decl_stmt|;
name|_Distance
name|__len11
init|=
literal|0
decl_stmt|;
name|_Distance
name|__len22
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__len1
operator|>
name|__len2
condition|)
block|{
name|__len11
operator|=
name|__len1
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__first_cut
argument_list|,
name|__len11
argument_list|)
expr_stmt|;
name|__second_cut
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
operator|*
name|__first_cut
argument_list|)
expr_stmt|;
name|__len22
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__second_cut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__len22
operator|=
name|__len2
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__second_cut
argument_list|,
name|__len22
argument_list|)
expr_stmt|;
name|__first_cut
operator|=
name|std
operator|::
name|upper_bound
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
operator|*
name|__second_cut
argument_list|)
expr_stmt|;
name|__len11
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|)
expr_stmt|;
block|}
name|_BidirectionalIterator
name|__new_middle
init|=
name|std
operator|::
name|__rotate_adaptive
argument_list|(
name|__first_cut
argument_list|,
name|__middle
argument_list|,
name|__second_cut
argument_list|,
name|__len1
operator|-
name|__len11
argument_list|,
name|__len22
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
decl_stmt|;
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|,
name|__new_middle
argument_list|,
name|__len11
argument_list|,
name|__len22
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
expr_stmt|;
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__new_middle
argument_list|,
name|__second_cut
argument_list|,
name|__last
argument_list|,
name|__len1
operator|-
name|__len11
argument_list|,
name|__len2
operator|-
name|__len22
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
expr_stmt|;
block|}
end_else

begin_comment
unit|}
comment|/**    *  @if maint    *  This is a helper function for the merge routines.    *  @endif   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Distance
operator|,
name|typename
name|_Pointer
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__merge_adaptive
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __middle
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Distance __len1
argument_list|,
argument|_Distance __len2
argument_list|,
argument|_Pointer __buffer
argument_list|,
argument|_Distance __buffer_size
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
if|if
condition|(
name|__len1
operator|<=
name|__len2
operator|&&
name|__len1
operator|<=
name|__buffer_size
condition|)
block|{
name|_Pointer
name|__buffer_end
init|=
name|std
operator|::
name|copy
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|)
decl_stmt|;
name|std
operator|::
name|merge
argument_list|(
name|__buffer
argument_list|,
name|__buffer_end
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__first
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|__len2
operator|<=
name|__buffer_size
condition|)
block|{
name|_Pointer
name|__buffer_end
init|=
name|std
operator|::
name|copy
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|)
decl_stmt|;
name|std
operator|::
name|__merge_backward
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|,
name|__buffer_end
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_else
else|else
block|{
name|_BidirectionalIterator
name|__first_cut
init|=
name|__first
decl_stmt|;
name|_BidirectionalIterator
name|__second_cut
init|=
name|__middle
decl_stmt|;
name|_Distance
name|__len11
init|=
literal|0
decl_stmt|;
name|_Distance
name|__len22
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__len1
operator|>
name|__len2
condition|)
block|{
name|__len11
operator|=
name|__len1
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__first_cut
argument_list|,
name|__len11
argument_list|)
expr_stmt|;
name|__second_cut
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
operator|*
name|__first_cut
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__len22
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__second_cut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__len22
operator|=
name|__len2
operator|/
literal|2
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__second_cut
argument_list|,
name|__len22
argument_list|)
expr_stmt|;
name|__first_cut
operator|=
name|std
operator|::
name|upper_bound
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
operator|*
name|__second_cut
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|__len11
operator|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|)
expr_stmt|;
block|}
name|_BidirectionalIterator
name|__new_middle
init|=
name|std
operator|::
name|__rotate_adaptive
argument_list|(
name|__first_cut
argument_list|,
name|__middle
argument_list|,
name|__second_cut
argument_list|,
name|__len1
operator|-
name|__len11
argument_list|,
name|__len22
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
decl_stmt|;
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__first
argument_list|,
name|__first_cut
argument_list|,
name|__new_middle
argument_list|,
name|__len11
argument_list|,
name|__len22
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__new_middle
argument_list|,
name|__second_cut
argument_list|,
name|__last
argument_list|,
name|__len1
operator|-
name|__len11
argument_list|,
name|__len2
operator|-
name|__len22
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_else

begin_comment
unit|}
comment|/**    *  @brief Merges two sorted ranges in place.    *  @param  first   An iterator.    *  @param  middle  Another iterator.    *  @param  last    Another iterator.    *  @return  Nothing.    *    *  Merges two sorted and consecutive ranges, [first,middle) and    *  [middle,last), and puts the result in [first,last).  The output will    *  be sorted.  The sort is @e stable, that is, for equivalent    *  elements in the two ranges, elements from the first range will always    *  come before elements from the second.    *    *  If enough additional memory is available, this takes (last-first)-1    *  comparisons.  Otherwise an NlogN algorithm is used, where N is    *  distance(first,last).   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|>
name|void
name|inplace_merge
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __middle
argument_list|,
argument|_BidirectionalIterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_BidirectionalIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_BidirectionalIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_BidirectionalIteratorConcept< 	    _BidirectionalIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept<_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first
operator|==
name|__middle
operator|||
name|__middle
operator|==
name|__last
condition|)
return|return;
end_if

begin_decl_stmt
name|_DistanceType
name|__len1
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__len2
init|=
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_Temporary_buffer
operator|<
name|_BidirectionalIterator
operator|,
name|_ValueType
operator|>
name|__buf
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__buf
operator|.
name|begin
argument_list|()
operator|==
literal|0
condition|)
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__len1
argument_list|,
name|__len2
argument_list|)
expr_stmt|;
else|else
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__len1
argument_list|,
name|__len2
argument_list|,
name|__buf
operator|.
name|begin
argument_list|()
argument_list|,
name|_DistanceType
argument_list|(
name|__buf
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/**    *  @brief Merges two sorted ranges in place.    *  @param  first   An iterator.    *  @param  middle  Another iterator.    *  @param  last    Another iterator.    *  @param  comp    A functor to use for comparisons.    *  @return  Nothing.    *    *  Merges two sorted and consecutive ranges, [first,middle) and    *  [middle,last), and puts the result in [first,last).  The output will    *  be sorted.  The sort is @e stable, that is, for equivalent    *  elements in the two ranges, elements from the first range will always    *  come before elements from the second.    *    *  If enough additional memory is available, this takes (last-first)-1    *  comparisons.  Otherwise an NlogN algorithm is used, where N is    *  distance(first,last).    *    *  The comparison function should have the same effects on ordering as    *  the function used for the initial sort.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Compare
operator|>
name|void
name|inplace_merge
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __middle
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_BidirectionalIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_BidirectionalIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_BidirectionalIteratorConcept< 	    _BidirectionalIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType
argument_list|,
argument|_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first
operator|==
name|__middle
operator|||
name|__middle
operator|==
name|__last
condition|)
return|return;
end_if

begin_decl_stmt
specifier|const
name|_DistanceType
name|__len1
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|_DistanceType
name|__len2
init|=
name|std
operator|::
name|distance
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_Temporary_buffer
operator|<
name|_BidirectionalIterator
operator|,
name|_ValueType
operator|>
name|__buf
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__buf
operator|.
name|begin
argument_list|()
operator|==
literal|0
condition|)
name|std
operator|::
name|__merge_without_buffer
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__len1
argument_list|,
name|__len2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
else|else
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|__len1
argument_list|,
name|__len2
argument_list|,
name|__buf
operator|.
name|begin
argument_list|()
argument_list|,
name|_DistanceType
argument_list|(
name|__buf
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Pointer
operator|,
name|typename
name|_Distance
operator|>
name|void
name|__stable_sort_adaptive
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Pointer __buffer
argument_list|,
argument|_Distance __buffer_size
argument_list|)
block|{
specifier|const
name|_Distance
name|__len
operator|=
operator|(
name|__last
operator|-
name|__first
operator|+
literal|1
operator|)
operator|/
literal|2
block|;
specifier|const
name|_RandomAccessIterator
name|__middle
operator|=
name|__first
operator|+
name|__len
block|;
if|if
condition|(
name|__len
operator|>
name|__buffer_size
condition|)
block|{
name|std
operator|::
name|__stable_sort_adaptive
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
expr_stmt|;
name|std
operator|::
name|__stable_sort_adaptive
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|std
operator|::
name|__merge_sort_with_buffer
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
name|std
operator|::
name|__merge_sort_with_buffer
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|_Distance
argument_list|(
name|__middle
operator|-
name|__first
argument_list|)
argument_list|,
name|_Distance
argument_list|(
name|__last
operator|-
name|__middle
argument_list|)
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Pointer
operator|,
name|typename
name|_Distance
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__stable_sort_adaptive
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Pointer __buffer
argument_list|,
argument|_Distance __buffer_size
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
specifier|const
name|_Distance
name|__len
operator|=
operator|(
name|__last
operator|-
name|__first
operator|+
literal|1
operator|)
operator|/
literal|2
block|;
specifier|const
name|_RandomAccessIterator
name|__middle
operator|=
name|__first
operator|+
name|__len
block|;
if|if
condition|(
name|__len
operator|>
name|__buffer_size
condition|)
block|{
name|std
operator|::
name|__stable_sort_adaptive
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|std
operator|::
name|__stable_sort_adaptive
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|std
operator|::
name|__merge_sort_with_buffer
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__buffer
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|std
operator|::
name|__merge_sort_with_buffer
argument_list|(
name|__middle
argument_list|,
name|__last
argument_list|,
name|__buffer
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|std
operator|::
name|__merge_adaptive
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__last
argument_list|,
name|_Distance
argument_list|(
name|__middle
operator|-
name|__first
argument_list|)
argument_list|,
name|_Distance
argument_list|(
name|__last
operator|-
name|__middle
argument_list|)
argument_list|,
name|__buffer
argument_list|,
name|__buffer_size
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Sort the elements of a sequence, preserving the relative order    *         of equivalent elements.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @return  Nothing.    *    *  Sorts the elements in the range @p [first,last) in ascending order,    *  such that @p *(i+1)<*i is false for each iterator @p i in the range    *  @p [first,last-1).    *    *  The relative ordering of equivalent elements is preserved, so any two    *  elements @p x and @p y in the range @p [first,last) such that    *  @p x<y is false and @p y<x is false will have the same relative    *  ordering after calling @p stable_sort().   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
specifier|inline
name|void
name|stable_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept<_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Temporary_buffer
operator|<
name|_RandomAccessIterator
operator|,
name|_ValueType
operator|>
name|__buf
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__buf
operator|.
name|begin
argument_list|()
operator|==
literal|0
condition|)
name|std
operator|::
name|__inplace_stable_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
else|else
name|std
operator|::
name|__stable_sort_adaptive
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__buf
operator|.
name|begin
argument_list|()
argument_list|,
name|_DistanceType
argument_list|(
name|__buf
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/**    *  @brief Sort the elements of a sequence using a predicate for comparison,    *         preserving the relative order of equivalent elements.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  comp    A comparison functor.    *  @return  Nothing.    *    *  Sorts the elements in the range @p [first,last) in ascending order,    *  such that @p comp(*(i+1),*i) is false for each iterator @p i in the    *  range @p [first,last-1).    *    *  The relative ordering of equivalent elements is preserved, so any two    *  elements @p x and @p y in the range @p [first,last) such that    *  @p comp(x,y) is false and @p comp(y,x) is false will have the same    *  relative ordering after calling @p stable_sort().   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
specifier|inline
name|void
name|stable_sort
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 	    _RandomAccessIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType
argument_list|,
argument|_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Temporary_buffer
operator|<
name|_RandomAccessIterator
operator|,
name|_ValueType
operator|>
name|__buf
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__buf
operator|.
name|begin
argument_list|()
operator|==
literal|0
condition|)
name|std
operator|::
name|__inplace_stable_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
else|else
name|std
operator|::
name|__stable_sort_adaptive
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__buf
operator|.
name|begin
argument_list|()
argument_list|,
name|_DistanceType
argument_list|(
name|__buf
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}     template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Size
operator|>
name|void
name|__introselect
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __nth
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Size __depth_limit
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__last
operator|-
name|__first
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|__depth_limit
operator|==
literal|0
condition|)
block|{
name|std
operator|::
name|__heap_select
argument_list|(
name|__first
argument_list|,
name|__nth
operator|+
literal|1
argument_list|,
name|__last
argument_list|)
expr_stmt|;
comment|// Place the nth largest element in its final position.
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__nth
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|__depth_limit
expr_stmt|;
name|_RandomAccessIterator
name|__cut
init|=
name|std
operator|::
name|__unguarded_partition
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|_ValueType
argument_list|(
name|std
operator|::
name|__median
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
operator|(
name|__first
operator|+
operator|(
name|__last
operator|-
name|__first
operator|)
operator|/
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|__last
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|__cut
operator|<=
name|__nth
condition|)
name|__first
operator|=
name|__cut
expr_stmt|;
else|else
name|__last
operator|=
name|__cut
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Size
operator|,
name|typename
name|_Compare
operator|>
name|void
name|__introselect
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __nth
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Size __depth_limit
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__last
operator|-
name|__first
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|__depth_limit
operator|==
literal|0
condition|)
block|{
name|std
operator|::
name|__heap_select
argument_list|(
name|__first
argument_list|,
name|__nth
operator|+
literal|1
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
comment|// Place the nth largest element in its final position.
name|std
operator|::
name|iter_swap
argument_list|(
name|__first
argument_list|,
name|__nth
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|__depth_limit
expr_stmt|;
name|_RandomAccessIterator
name|__cut
init|=
name|std
operator|::
name|__unguarded_partition
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|_ValueType
argument_list|(
name|std
operator|::
name|__median
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
operator|(
name|__first
operator|+
operator|(
name|__last
operator|-
name|__first
operator|)
operator|/
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|__last
operator|-
literal|1
operator|)
argument_list|,
name|__comp
argument_list|)
argument_list|)
argument_list|,
name|__comp
argument_list|)
decl_stmt|;
if|if
condition|(
name|__cut
operator|<=
name|__nth
condition|)
name|__first
operator|=
name|__cut
expr_stmt|;
else|else
name|__last
operator|=
name|__cut
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|std
operator|::
name|__insertion_sort
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Sort a sequence just enough to find a particular position.    *  @param  first   An iterator.    *  @param  nth     Another iterator.    *  @param  last    Another iterator.    *  @return  Nothing.    *    *  Rearranges the elements in the range @p [first,last) so that @p *nth    *  is the same element that would have been in that position had the    *  whole sequence been sorted.    *  whole sequence been sorted. The elements either side of @p *nth are    *  not completely sorted, but for any iterator @i in the range    *  @p [first,nth) and any iterator @j in the range @p [nth,last) it    *  holds that @p *j<*i is false.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|>
specifier|inline
name|void
name|nth_element
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __nth
argument_list|,
argument|_RandomAccessIterator __last
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 				  _RandomAccessIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept<_ValueType>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__nth
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__nth
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first
operator|==
name|__last
operator|||
name|__nth
operator|==
name|__last
condition|)
return|return;
end_if

begin_expr_stmt
name|std
operator|::
name|__introselect
argument_list|(
name|__first
argument_list|,
name|__nth
argument_list|,
name|__last
argument_list|,
name|std
operator|::
name|__lg
argument_list|(
name|__last
operator|-
name|__first
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Sort a sequence just enough to find a particular position    *         using a predicate for comparison.    *  @param  first   An iterator.    *  @param  nth     Another iterator.    *  @param  last    Another iterator.    *  @param  comp    A comparison functor.    *  @return  Nothing.    *    *  Rearranges the elements in the range @p [first,last) so that @p *nth    *  is the same element that would have been in that position had the    *  whole sequence been sorted. The elements either side of @p *nth are    *  not completely sorted, but for any iterator @i in the range    *  @p [first,nth) and any iterator @j in the range @p [nth,last) it    *  holds that @p comp(*j,*i) is false.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_RandomAccessIterator
operator|,
name|typename
name|_Compare
operator|>
specifier|inline
name|void
name|nth_element
argument_list|(
argument|_RandomAccessIterator __first
argument_list|,
argument|_RandomAccessIterator __nth
argument_list|,
argument|_RandomAccessIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_RandomAccessIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_Mutable_RandomAccessIteratorConcept< 				  _RandomAccessIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType
argument_list|,
argument|_ValueType>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__nth
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_valid_range
argument_list|(
name|__nth
argument_list|,
name|__last
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__first
operator|==
name|__last
operator|||
name|__nth
operator|==
name|__last
condition|)
return|return;
end_if

begin_expr_stmt
name|std
operator|::
name|__introselect
argument_list|(
name|__first
argument_list|,
name|__nth
argument_list|,
name|__last
argument_list|,
name|std
operator|::
name|__lg
argument_list|(
name|__last
operator|-
name|__first
argument_list|)
operator|*
literal|2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/**    *  @brief Finds the largest subrange in which @a val could be inserted    *         at any place in it without changing the ordering.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @return  An pair of iterators defining the subrange.    *  @ingroup binarysearch    *    *  This is equivalent to    *  @code    *    std::make_pair(lower_bound(first, last, val),    *                   upper_bound(first, last, val))    *  @endcode    *  but does not actually call those functions.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|>
name|pair
operator|<
name|_ForwardIterator
operator|,
name|_ForwardIterator
operator|>
name|equal_range
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType
argument_list|,
argument|_Tp>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_Tp
argument_list|,
argument|_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_partitioned
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_DistanceType
name|__len
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__half
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__middle
decl_stmt|,
name|__left
decl_stmt|,
name|__right
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__len
operator|>
literal|0
condition|)
block|{
name|__half
operator|=
name|__len
operator|>>
literal|1
expr_stmt|;
name|__middle
operator|=
name|__first
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__half
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|__middle
operator|<
name|__val
condition|)
block|{
name|__first
operator|=
name|__middle
expr_stmt|;
operator|++
name|__first
expr_stmt|;
name|__len
operator|=
name|__len
operator|-
name|__half
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__val
operator|<
operator|*
name|__middle
condition|)
name|__len
operator|=
name|__half
expr_stmt|;
else|else
block|{
name|__left
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__val
argument_list|)
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__first
argument_list|,
name|__len
argument_list|)
expr_stmt|;
name|__right
operator|=
name|std
operator|::
name|upper_bound
argument_list|(
operator|++
name|__middle
argument_list|,
name|__first
argument_list|,
name|__val
argument_list|)
expr_stmt|;
return|return
name|pair
operator|<
name|_ForwardIterator
operator|,
name|_ForwardIterator
operator|>
operator|(
name|__left
operator|,
name|__right
operator|)
return|;
block|}
block|}
end_while

begin_return
return|return
name|pair
operator|<
name|_ForwardIterator
operator|,
name|_ForwardIterator
operator|>
operator|(
name|__first
operator|,
name|__first
operator|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Finds the largest subrange in which @a val could be inserted    *         at any place in it without changing the ordering.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @param  comp    A functor to use for comparisons.    *  @return  An pair of iterators defining the subrange.    *  @ingroup binarysearch    *    *  This is equivalent to    *  @code    *    std::make_pair(lower_bound(first, last, val, comp),    *                   upper_bound(first, last, val, comp))    *  @endcode    *  but does not actually call those functions.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
name|pair
operator|<
name|_ForwardIterator
operator|,
name|_ForwardIterator
operator|>
name|equal_range
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|difference_type
name|_DistanceType
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType
argument_list|,
argument|_Tp>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_Tp
argument_list|,
argument|_ValueType>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_partitioned_pred
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_DistanceType
name|__len
init|=
name|std
operator|::
name|distance
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_DistanceType
name|__half
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_ForwardIterator
name|__middle
decl_stmt|,
name|__left
decl_stmt|,
name|__right
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|__len
operator|>
literal|0
condition|)
block|{
name|__half
operator|=
name|__len
operator|>>
literal|1
expr_stmt|;
name|__middle
operator|=
name|__first
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__middle
argument_list|,
name|__half
argument_list|)
expr_stmt|;
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__middle
argument_list|,
name|__val
argument_list|)
condition|)
block|{
name|__first
operator|=
name|__middle
expr_stmt|;
operator|++
name|__first
expr_stmt|;
name|__len
operator|=
name|__len
operator|-
name|__half
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__comp
argument_list|(
name|__val
argument_list|,
operator|*
name|__middle
argument_list|)
condition|)
name|__len
operator|=
name|__half
expr_stmt|;
else|else
block|{
name|__left
operator|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__first
argument_list|,
name|__middle
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__first
argument_list|,
name|__len
argument_list|)
expr_stmt|;
name|__right
operator|=
name|std
operator|::
name|upper_bound
argument_list|(
operator|++
name|__middle
argument_list|,
name|__first
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
return|return
name|pair
operator|<
name|_ForwardIterator
operator|,
name|_ForwardIterator
operator|>
operator|(
name|__left
operator|,
name|__right
operator|)
return|;
block|}
block|}
end_while

begin_return
return|return
name|pair
operator|<
name|_ForwardIterator
operator|,
name|_ForwardIterator
operator|>
operator|(
name|__first
operator|,
name|__first
operator|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Determines whether an element exists in a range.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @return  True if @a val (or its equivelent) is in [@a first,@a last ].    *  @ingroup binarysearch    *    *  Note that this does not actually return an iterator to @a val.  For    *  that, use std::find or a container's specialized find member functions.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|>
name|bool
name|binary_search
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_Tp
argument_list|,
argument|_ValueType>
argument_list|)
name|__glibcxx_requires_partitioned
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_ForwardIterator
name|__i
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|__i
operator|!=
name|__last
operator|&&
operator|!
operator|(
name|__val
operator|<
operator|*
name|__i
operator|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Determines whether an element exists in a range.    *  @param  first   An iterator.    *  @param  last    Another iterator.    *  @param  val     The search term.    *  @param  comp    A functor to use for comparisons.    *  @return  True if @a val (or its equivelent) is in [@a first,@a last ].    *  @ingroup binarysearch    *    *  Note that this does not actually return an iterator to @a val.  For    *  that, use std::find or a container's specialized find member functions.    *    *  The comparison function should have the same effects on ordering as    *  the function used for the initial sort.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Tp
operator|,
name|typename
name|_Compare
operator|>
name|bool
name|binary_search
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|const _Tp& __val
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_ForwardIterator
operator|>
operator|::
name|value_type
name|_ValueType
expr_stmt|;
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_Tp
argument_list|,
argument|_ValueType>
argument_list|)
name|__glibcxx_requires_partitioned_pred
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_ForwardIterator
name|__i
init|=
name|std
operator|::
name|lower_bound
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|,
name|__val
argument_list|,
name|__comp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|__i
operator|!=
name|__last
operator|&&
operator|!
name|__comp
argument_list|(
name|__val
argument_list|,
operator|*
name|__i
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// Set algorithms: includes, set_union, set_intersection, set_difference,
end_comment

begin_comment
comment|// set_symmetric_difference.  All of these algorithms have the precondition
end_comment

begin_comment
comment|// that their input ranges are sorted and the postcondition that their output
end_comment

begin_comment
comment|// ranges are sorted.
end_comment

begin_comment
comment|/**    *  @brief Determines whether all elements of a sequence exists in a range.    *  @param  first1  Start of search range.    *  @param  last1   End of search range.    *  @param  first2  Start of sequence    *  @param  last2   End of sequence.    *  @return  True if each element in [first2,last2) is contained in order    *  within [first1,last1).  False otherwise.    *  @ingroup setoperations    *    *  This operation expects both [first1,last1) and [first2,last2) to be    *  sorted.  Searches for the presence of each element in [first2,last2)    *  within [first1,last1).  The iterators over each range only move forward,    *  so this is a linear algorithm.  If an element in [first2,last2) is not    *  found before the search iterator reaches @a last2, false is returned.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|>
name|bool
name|includes
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
operator|*
name|__first2
operator|<
operator|*
name|__first1
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
operator|*
name|__first1
operator|<
operator|*
name|__first2
condition|)
operator|++
name|__first1
expr_stmt|;
else|else
operator|++
name|__first1
operator|,
operator|++
name|__first2
expr_stmt|;
end_while

begin_return
return|return
name|__first2
operator|==
name|__last2
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Determines whether all elements of a sequence exists in a range    *  using comparison.    *  @param  first1  Start of search range.    *  @param  last1   End of search range.    *  @param  first2  Start of sequence    *  @param  last2   End of sequence.    *  @param  comp    Comparison function to use.    *  @return  True if each element in [first2,last2) is contained in order    *  within [first1,last1) according to comp.  False otherwise.    *  @ingroup setoperations    *    *  This operation expects both [first1,last1) and [first2,last2) to be    *  sorted.  Searches for the presence of each element in [first2,last2)    *  within [first1,last1), using comp to decide.  The iterators over each    *  range only move forward, so this is a linear algorithm.  If an element    *  in [first2,last2) is not found before the search iterator reaches @a    *  last2, false is returned.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_Compare
operator|>
name|bool
name|includes
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first2
argument_list|,
operator|*
name|__first1
argument_list|)
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
operator|++
name|__first1
expr_stmt|;
else|else
operator|++
name|__first1
operator|,
operator|++
name|__first2
expr_stmt|;
end_while

begin_return
return|return
name|__first2
operator|==
name|__last2
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Return the union of two sorted ranges.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  each range in order to the output range.  Iterators increment for each    *  range.  When the current element of one range is less than the other,    *  that element is copied and the iterator advanced.  If an element is    *  contained in both ranges, the element from the first range is copied and    *  both ranges advance.  The output range may not overlap either input    *  range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|set_union
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
block|{
if|if
condition|(
operator|*
name|__first1
operator|<
operator|*
name|__first2
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|__first2
operator|<
operator|*
name|__first1
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first2
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
operator|++
name|__result
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Return the union of two sorted ranges using a comparison functor.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @param  comp    The comparison functor.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  each range in order to the output range.  Iterators increment for each    *  range.  When the current element of one range is less than the other    *  according to @a comp, that element is copied and the iterator advanced.    *  If an equivalent element according to @a comp is contained in both    *  ranges, the element from the first range is copied and both ranges    *  advance.  The output range may not overlap either input range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Compare
operator|>
name|_OutputIterator
name|set_union
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
block|{
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first2
argument_list|,
operator|*
name|__first1
argument_list|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first2
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
operator|++
name|__result
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Return the intersection of two sorted ranges.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  both ranges in order to the output range.  Iterators increment for each    *  range.  When the current element of one range is less than the other,    *  that iterator advances.  If an element is contained in both ranges, the    *  element from the first range is copied and both ranges advance.  The    *  output range may not overlap either input range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|set_intersection
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
operator|*
name|__first1
operator|<
operator|*
name|__first2
condition|)
operator|++
name|__first1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|__first2
operator|<
operator|*
name|__first1
condition|)
operator|++
name|__first2
expr_stmt|;
else|else
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Return the intersection of two sorted ranges using comparison    *  functor.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @param  comp    The comparison functor.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  both ranges in order to the output range.  Iterators increment for each    *  range.  When the current element of one range is less than the other    *  according to @a comp, that iterator advances.  If an element is    *  contained in both ranges according to @a comp, the element from the    *  first range is copied and both ranges advance.  The output range may not    *  overlap either input range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Compare
operator|>
name|_OutputIterator
name|set_intersection
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
operator|++
name|__first1
expr_stmt|;
elseif|else
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first2
argument_list|,
operator|*
name|__first1
argument_list|)
condition|)
operator|++
name|__first2
expr_stmt|;
else|else
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
end_while

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief Return the difference of two sorted ranges.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  the first range but not the second in order to the output range.    *  Iterators increment for each range.  When the current element of the    *  first range is less than the second, that element is copied and the    *  iterator advances.  If the current element of the second range is less,    *  the iterator advances, but no element is copied.  If an element is    *  contained in both ranges, no elements are copied and both ranges    *  advance.  The output range may not overlap either input range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|set_difference
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
operator|*
name|__first1
operator|<
operator|*
name|__first2
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|__first2
operator|<
operator|*
name|__first1
condition|)
operator|++
name|__first2
expr_stmt|;
else|else
block|{
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief  Return the difference of two sorted ranges using comparison    *  functor.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @param  comp    The comparison functor.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  the first range but not the second in order to the output range.    *  Iterators increment for each range.  When the current element of the    *  first range is less than the second according to @a comp, that element    *  is copied and the iterator advances.  If the current element of the    *  second range is less, no element is copied and the iterator advances.    *  If an element is contained in both ranges according to @a comp, no    *  elements are copied and both ranges advance.  The output range may not    *  overlap either input range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Compare
operator|>
name|_OutputIterator
name|set_difference
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first2
argument_list|,
operator|*
name|__first1
argument_list|)
condition|)
operator|++
name|__first2
expr_stmt|;
else|else
block|{
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief  Return the symmetric difference of two sorted ranges.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  one range but not the other in order to the output range.  Iterators    *  increment for each range.  When the current element of one range is less    *  than the other, that element is copied and the iterator advances.  If an    *  element is contained in both ranges, no elements are copied and both    *  ranges advance.  The output range may not overlap either input range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|>
name|_OutputIterator
name|set_symmetric_difference
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanOpConcept<_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
operator|*
name|__first1
operator|<
operator|*
name|__first2
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|__first2
operator|<
operator|*
name|__first1
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first2
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
else|else
block|{
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief  Return the symmetric difference of two sorted ranges using    *  comparison functor.    *  @param  first1  Start of first range.    *  @param  last1   End of first range.    *  @param  first2  Start of second range.    *  @param  last2   End of second range.    *  @param  comp    The comparison functor.    *  @return  End of the output range.    *  @ingroup setoperations    *    *  This operation iterates over both ranges, copying elements present in    *  one range but not the other in order to the output range.  Iterators    *  increment for each range.  When the current element of one range is less    *  than the other according to @a comp, that element is copied and the    *  iterator advances.  If an element is contained in both ranges according    *  to @a comp, no elements are copied and both ranges advance.  The output    *  range may not overlap either input range.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator1
operator|,
name|typename
name|_InputIterator2
operator|,
name|typename
name|_OutputIterator
operator|,
name|typename
name|_Compare
operator|>
name|_OutputIterator
name|set_symmetric_difference
argument_list|(
argument|_InputIterator1 __first1
argument_list|,
argument|_InputIterator1 __last1
argument_list|,
argument|_InputIterator2 __first2
argument_list|,
argument|_InputIterator2 __last2
argument_list|,
argument|_OutputIterator __result
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator1
operator|>
operator|::
name|value_type
name|_ValueType1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|iterator_traits
operator|<
name|_InputIterator2
operator|>
operator|::
name|value_type
name|_ValueType2
expr_stmt|;
end_typedef

begin_comment
comment|// concept requirements
end_comment

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_OutputIteratorConcept<_OutputIterator
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType1
argument_list|,
argument|_ValueType2>
argument_list|)
end_macro

begin_macro
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|_ValueType2
argument_list|,
argument|_ValueType1>
argument_list|)
end_macro

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__glibcxx_requires_sorted_pred
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|__first1
operator|!=
name|__last1
operator|&&
name|__first2
operator|!=
name|__last2
condition|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__first2
argument_list|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first1
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first2
argument_list|,
operator|*
name|__first1
argument_list|)
condition|)
block|{
operator|*
name|__result
operator|=
operator|*
name|__first2
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
operator|++
name|__result
expr_stmt|;
block|}
else|else
block|{
operator|++
name|__first1
expr_stmt|;
operator|++
name|__first2
expr_stmt|;
block|}
end_while

begin_return
return|return
name|std
operator|::
name|copy
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|copy
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__result
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// min_element and max_element, with and without an explicitly supplied
end_comment

begin_comment
comment|// comparison function.
end_comment

begin_comment
comment|/**    *  @brief  Return the maximum element in a range.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @return  Iterator referencing the first instance of the largest value.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|>
name|_ForwardIterator
name|max_element
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept< 	    typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
name|_ForwardIterator
name|__result
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|*
name|__result
operator|<
operator|*
name|__first
condition|)
name|__result
operator|=
name|__first
expr_stmt|;
end_while

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief  Return the maximum element in a range using comparison functor.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @param  comp   Comparison functor.    *  @return  Iterator referencing the first instance of the largest value    *  according to comp.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Compare
operator|>
name|_ForwardIterator
name|max_element
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
name|_ForwardIterator
name|__result
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__result
argument_list|,
operator|*
name|__first
argument_list|)
condition|)
name|__result
operator|=
name|__first
expr_stmt|;
end_while

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief  Return the minimum element in a range.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @return  Iterator referencing the first instance of the smallest value.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|>
name|_ForwardIterator
name|min_element
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept< 	    typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
name|_ForwardIterator
name|__result
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
operator|*
name|__first
operator|<
operator|*
name|__result
condition|)
name|__result
operator|=
name|__first
expr_stmt|;
end_while

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief  Return the minimum element in a range using comparison functor.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @param  comp   Comparison functor.    *  @return  Iterator referencing the first instance of the smallest value    *  according to comp.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_Compare
operator|>
name|_ForwardIterator
name|min_element
argument_list|(
argument|_ForwardIterator __first
argument_list|,
argument|_ForwardIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|__first
return|;
name|_ForwardIterator
name|__result
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|++
name|__first
operator|!=
name|__last
condition|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first
argument_list|,
operator|*
name|__result
argument_list|)
condition|)
name|__result
operator|=
name|__first
expr_stmt|;
end_while

begin_return
return|return
name|__result
return|;
end_return

begin_comment
unit|}
comment|// next_permutation and prev_permutation, with and without an explicitly
end_comment

begin_comment
comment|// supplied comparison function.
end_comment

begin_comment
comment|/**    *  @brief  Permute range into the next "dictionary" ordering.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @return  False if wrapped to first permutation, true otherwise.    *    *  Treats all permutations of the range as a set of "dictionary" sorted    *  sequences.  Permutes the current sequence into the next one of this set.    *  Returns true if there are more sequences to generate.  If the sequence    *  is the largest of the set, the smallest is generated and false returned.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|>
name|bool
name|next_permutation
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept< 	    typename iterator_traits<_BidirectionalIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|false
return|;
name|_BidirectionalIterator
name|__i
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__i
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__i
operator|==
name|__last
condition|)
return|return
name|false
return|;
end_if

begin_expr_stmt
name|__i
operator|=
name|__last
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|--
name|__i
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|_BidirectionalIterator
name|__ii
init|=
name|__i
decl_stmt|;
operator|--
name|__i
expr_stmt|;
if|if
condition|(
operator|*
name|__i
operator|<
operator|*
name|__ii
condition|)
block|{
name|_BidirectionalIterator
name|__j
init|=
name|__last
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|__i
operator|<
operator|*
operator|--
name|__j
operator|)
condition|)
block|{}
name|std
operator|::
name|iter_swap
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
name|std
operator|::
name|reverse
argument_list|(
name|__ii
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|__i
operator|==
name|__first
condition|)
block|{
name|std
operator|::
name|reverse
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_for

begin_comment
unit|}
comment|/**    *  @brief  Permute range into the next "dictionary" ordering using    *  comparison functor.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @param  comp    *  @return  False if wrapped to first permutation, true otherwise.    *    *  Treats all permutations of the range [first,last) as a set of    *  "dictionary" sorted sequences ordered by @a comp.  Permutes the current    *  sequence into the next one of this set.  Returns true if there are more    *  sequences to generate.  If the sequence is the largest of the set, the    *  smallest is generated and false returned.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Compare
operator|>
name|bool
name|next_permutation
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|typename iterator_traits<_BidirectionalIterator>::value_type
argument_list|,
argument|typename iterator_traits<_BidirectionalIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|false
return|;
name|_BidirectionalIterator
name|__i
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__i
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__i
operator|==
name|__last
condition|)
return|return
name|false
return|;
end_if

begin_expr_stmt
name|__i
operator|=
name|__last
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|--
name|__i
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|_BidirectionalIterator
name|__ii
init|=
name|__i
decl_stmt|;
operator|--
name|__i
expr_stmt|;
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__i
argument_list|,
operator|*
name|__ii
argument_list|)
condition|)
block|{
name|_BidirectionalIterator
name|__j
init|=
name|__last
decl_stmt|;
while|while
condition|(
operator|!
name|__comp
argument_list|(
operator|*
name|__i
argument_list|,
operator|*
operator|--
name|__j
argument_list|)
condition|)
block|{}
name|std
operator|::
name|iter_swap
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
name|std
operator|::
name|reverse
argument_list|(
name|__ii
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|__i
operator|==
name|__first
condition|)
block|{
name|std
operator|::
name|reverse
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_for

begin_comment
unit|}
comment|/**    *  @brief  Permute range into the previous "dictionary" ordering.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @return  False if wrapped to last permutation, true otherwise.    *    *  Treats all permutations of the range as a set of "dictionary" sorted    *  sequences.  Permutes the current sequence into the previous one of this    *  set.  Returns true if there are more sequences to generate.  If the    *  sequence is the smallest of the set, the largest is generated and false    *  returned.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|>
name|bool
name|prev_permutation
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_LessThanComparableConcept< 	    typename iterator_traits<_BidirectionalIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|false
return|;
name|_BidirectionalIterator
name|__i
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__i
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__i
operator|==
name|__last
condition|)
return|return
name|false
return|;
end_if

begin_expr_stmt
name|__i
operator|=
name|__last
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|--
name|__i
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|_BidirectionalIterator
name|__ii
init|=
name|__i
decl_stmt|;
operator|--
name|__i
expr_stmt|;
if|if
condition|(
operator|*
name|__ii
operator|<
operator|*
name|__i
condition|)
block|{
name|_BidirectionalIterator
name|__j
init|=
name|__last
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
operator|--
name|__j
operator|<
operator|*
name|__i
operator|)
condition|)
block|{}
name|std
operator|::
name|iter_swap
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
name|std
operator|::
name|reverse
argument_list|(
name|__ii
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|__i
operator|==
name|__first
condition|)
block|{
name|std
operator|::
name|reverse
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_for

begin_comment
unit|}
comment|/**    *  @brief  Permute range into the previous "dictionary" ordering using    *  comparison functor.    *  @param  first  Start of range.    *  @param  last   End of range.    *  @param  comp    *  @return  False if wrapped to last permutation, true otherwise.    *    *  Treats all permutations of the range [first,last) as a set of    *  "dictionary" sorted sequences ordered by @a comp.  Permutes the current    *  sequence into the previous one of this set.  Returns true if there are    *  more sequences to generate.  If the sequence is the smallest of the set,    *  the largest is generated and false returned.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator
operator|,
name|typename
name|_Compare
operator|>
name|bool
name|prev_permutation
argument_list|(
argument|_BidirectionalIterator __first
argument_list|,
argument|_BidirectionalIterator __last
argument_list|,
argument|_Compare __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_Compare
argument_list|,
argument|typename iterator_traits<_BidirectionalIterator>::value_type
argument_list|,
argument|typename iterator_traits<_BidirectionalIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
block|;
if|if
condition|(
name|__first
operator|==
name|__last
condition|)
return|return
name|false
return|;
name|_BidirectionalIterator
name|__i
operator|=
name|__first
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|++
name|__i
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|__i
operator|==
name|__last
condition|)
return|return
name|false
return|;
end_if

begin_expr_stmt
name|__i
operator|=
name|__last
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|--
name|__i
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|_BidirectionalIterator
name|__ii
init|=
name|__i
decl_stmt|;
operator|--
name|__i
expr_stmt|;
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__ii
argument_list|,
operator|*
name|__i
argument_list|)
condition|)
block|{
name|_BidirectionalIterator
name|__j
init|=
name|__last
decl_stmt|;
while|while
condition|(
operator|!
name|__comp
argument_list|(
operator|*
operator|--
name|__j
argument_list|,
operator|*
name|__i
argument_list|)
condition|)
block|{}
name|std
operator|::
name|iter_swap
argument_list|(
name|__i
argument_list|,
name|__j
argument_list|)
expr_stmt|;
name|std
operator|::
name|reverse
argument_list|(
name|__ii
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|__i
operator|==
name|__first
condition|)
block|{
name|std
operator|::
name|reverse
argument_list|(
name|__first
argument_list|,
name|__last
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_for

begin_comment
unit|}
comment|// find_first_of, with and without an explicitly supplied comparison function.
end_comment

begin_comment
comment|/**    *  @brief  Find element from a set in a sequence.    *  @param  first1  Start of range to search.    *  @param  last1   End of range to search.    *  @param  first2  Start of match candidates.    *  @param  last2   End of match candidates.    *  @return   The first iterator @c i in the range    *  @p [first1,last1) such that @c *i == @p *(i2) such that i2 is an    *  interator in [first2,last2), or @p last1 if no such iterator exists.    *    *  Searches the range @p [first1,last1) for an element that is equal to    *  some element in the range [first2,last2).  If found, returns an iterator    *  in the range [first1,last1), otherwise returns @p last1.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_ForwardIterator
operator|>
name|_InputIterator
name|find_first_of
argument_list|(
argument|_InputIterator __first1
argument_list|,
argument|_InputIterator __last1
argument_list|,
argument|_ForwardIterator __first2
argument_list|,
argument|_ForwardIterator __last2
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	    typename iterator_traits<_InputIterator>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
block|;
for|for
control|(
init|;
name|__first1
operator|!=
name|__last1
condition|;
operator|++
name|__first1
control|)
for|for
control|(
name|_ForwardIterator
name|__iter
init|=
name|__first2
init|;
name|__iter
operator|!=
name|__last2
condition|;
operator|++
name|__iter
control|)
if|if
condition|(
operator|*
name|__first1
operator|==
operator|*
name|__iter
condition|)
return|return
name|__first1
return|;
end_expr_stmt

begin_return
return|return
name|__last1
return|;
end_return

begin_comment
unit|}
comment|/**    *  @brief  Find element from a set in a sequence using a predicate.    *  @param  first1  Start of range to search.    *  @param  last1   End of range to search.    *  @param  first2  Start of match candidates.    *  @param  last2   End of match candidates.    *  @param  comp    Predicate to use.    *  @return   The first iterator @c i in the range    *  @p [first1,last1) such that @c comp(*i, @p *(i2)) is true and i2 is an    *  interator in [first2,last2), or @p last1 if no such iterator exists.    *    *  Searches the range @p [first1,last1) for an element that is equal to    *  some element in the range [first2,last2).  If found, returns an iterator in    *  the range [first1,last1), otherwise returns @p last1.   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_InputIterator
operator|,
name|typename
name|_ForwardIterator
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_InputIterator
name|find_first_of
argument_list|(
argument|_InputIterator __first1
argument_list|,
argument|_InputIterator __last1
argument_list|,
argument|_ForwardIterator __first2
argument_list|,
argument|_ForwardIterator __last2
argument_list|,
argument|_BinaryPredicate __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_InputIteratorConcept<_InputIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_InputIterator>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
block|;
for|for
control|(
init|;
name|__first1
operator|!=
name|__last1
condition|;
operator|++
name|__first1
control|)
for|for
control|(
name|_ForwardIterator
name|__iter
init|=
name|__first2
init|;
name|__iter
operator|!=
name|__last2
condition|;
operator|++
name|__iter
control|)
if|if
condition|(
name|__comp
argument_list|(
operator|*
name|__first1
argument_list|,
operator|*
name|__iter
argument_list|)
condition|)
return|return
name|__first1
return|;
end_expr_stmt

begin_return
return|return
name|__last1
return|;
end_return

begin_comment
unit|}
comment|// find_end, with and without an explicitly supplied comparison function.
end_comment

begin_comment
comment|// Search [first2, last2) as a subsequence in [first1, last1), and return
end_comment

begin_comment
comment|// the *last* possible match.  Note that find_end for bidirectional iterators
end_comment

begin_comment
comment|// is much faster than for forward iterators.
end_comment

begin_comment
comment|// find_end for forward iterators.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator1
operator|,
name|typename
name|_ForwardIterator2
operator|>
name|_ForwardIterator1
name|__find_end
argument_list|(
argument|_ForwardIterator1 __first1
argument_list|,
argument|_ForwardIterator1 __last1
argument_list|,
argument|_ForwardIterator2 __first2
argument_list|,
argument|_ForwardIterator2 __last2
argument_list|,
argument|forward_iterator_tag
argument_list|,
argument|forward_iterator_tag
argument_list|)
block|{
if|if
condition|(
name|__first2
operator|==
name|__last2
condition|)
return|return
name|__last1
return|;
else|else
block|{
name|_ForwardIterator1
name|__result
init|=
name|__last1
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|_ForwardIterator1
name|__new_result
init|=
name|std
operator|::
name|search
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__first2
argument_list|,
name|__last2
argument_list|)
decl_stmt|;
if|if
condition|(
name|__new_result
operator|==
name|__last1
condition|)
return|return
name|__result
return|;
else|else
block|{
name|__result
operator|=
name|__new_result
expr_stmt|;
name|__first1
operator|=
name|__new_result
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|} 	}     }    template
operator|<
name|typename
name|_ForwardIterator1
operator|,
name|typename
name|_ForwardIterator2
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_ForwardIterator1
name|__find_end
argument_list|(
argument|_ForwardIterator1 __first1
argument_list|,
argument|_ForwardIterator1 __last1
argument_list|,
argument|_ForwardIterator2 __first2
argument_list|,
argument|_ForwardIterator2 __last2
argument_list|,
argument|forward_iterator_tag
argument_list|,
argument|forward_iterator_tag
argument_list|,
argument|_BinaryPredicate __comp
argument_list|)
block|{
if|if
condition|(
name|__first2
operator|==
name|__last2
condition|)
return|return
name|__last1
return|;
else|else
block|{
name|_ForwardIterator1
name|__result
init|=
name|__last1
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|_ForwardIterator1
name|__new_result
init|=
name|std
operator|::
name|search
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__first2
argument_list|,
name|__last2
argument_list|,
name|__comp
argument_list|)
decl_stmt|;
if|if
condition|(
name|__new_result
operator|==
name|__last1
condition|)
return|return
name|__result
return|;
else|else
block|{
name|__result
operator|=
name|__new_result
expr_stmt|;
name|__first1
operator|=
name|__new_result
expr_stmt|;
operator|++
name|__first1
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|} 	}     }
comment|// find_end for bidirectional iterators.  Requires partial specialization.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_BidirectionalIterator1
operator|,
name|typename
name|_BidirectionalIterator2
operator|>
name|_BidirectionalIterator1
name|__find_end
argument_list|(
argument|_BidirectionalIterator1 __first1
argument_list|,
argument|_BidirectionalIterator1 __last1
argument_list|,
argument|_BidirectionalIterator2 __first2
argument_list|,
argument|_BidirectionalIterator2 __last2
argument_list|,
argument|bidirectional_iterator_tag
argument_list|,
argument|bidirectional_iterator_tag
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator2>
argument_list|)
typedef|typedef
name|reverse_iterator
operator|<
name|_BidirectionalIterator1
operator|>
name|_RevIterator1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|_BidirectionalIterator2
operator|>
name|_RevIterator2
expr_stmt|;
end_typedef

begin_function_decl
name|_RevIterator1
name|__rlast1
parameter_list|(
name|__first1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|_RevIterator2
name|__rlast2
parameter_list|(
name|__first2
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|_RevIterator1
name|__rresult
init|=
name|std
operator|::
name|search
argument_list|(
name|_RevIterator1
argument_list|(
name|__last1
argument_list|)
argument_list|,
name|__rlast1
argument_list|,
name|_RevIterator2
argument_list|(
name|__last2
argument_list|)
argument_list|,
name|__rlast2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__rresult
operator|==
name|__rlast1
condition|)
return|return
name|__last1
return|;
else|else
block|{
name|_BidirectionalIterator1
name|__result
init|=
name|__rresult
operator|.
name|base
argument_list|()
decl_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__result
argument_list|,
operator|-
name|std
operator|::
name|distance
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
end_if

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_BidirectionalIterator1
operator|,
name|typename
name|_BidirectionalIterator2
operator|,
name|typename
name|_BinaryPredicate
operator|>
name|_BidirectionalIterator1
name|__find_end
argument_list|(
argument|_BidirectionalIterator1 __first1
argument_list|,
argument|_BidirectionalIterator1 __last1
argument_list|,
argument|_BidirectionalIterator2 __first2
argument_list|,
argument|_BidirectionalIterator2 __last2
argument_list|,
argument|bidirectional_iterator_tag
argument_list|,
argument|bidirectional_iterator_tag
argument_list|,
argument|_BinaryPredicate __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BidirectionalIteratorConcept< 				  _BidirectionalIterator2>
argument_list|)
typedef|typedef
name|reverse_iterator
operator|<
name|_BidirectionalIterator1
operator|>
name|_RevIterator1
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|reverse_iterator
operator|<
name|_BidirectionalIterator2
operator|>
name|_RevIterator2
expr_stmt|;
end_typedef

begin_function_decl
name|_RevIterator1
name|__rlast1
parameter_list|(
name|__first1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|_RevIterator2
name|__rlast2
parameter_list|(
name|__first2
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|_RevIterator1
name|__rresult
init|=
name|std
operator|::
name|search
argument_list|(
name|_RevIterator1
argument_list|(
name|__last1
argument_list|)
argument_list|,
name|__rlast1
argument_list|,
name|_RevIterator2
argument_list|(
name|__last2
argument_list|)
argument_list|,
name|__rlast2
argument_list|,
name|__comp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|__rresult
operator|==
name|__rlast1
condition|)
return|return
name|__last1
return|;
else|else
block|{
name|_BidirectionalIterator1
name|__result
init|=
name|__rresult
operator|.
name|base
argument_list|()
decl_stmt|;
name|std
operator|::
name|advance
argument_list|(
name|__result
argument_list|,
operator|-
name|std
operator|::
name|distance
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|__result
return|;
block|}
end_if

begin_comment
unit|}
comment|// Dispatching functions for find_end.
end_comment

begin_comment
comment|/**    *  @brief  Find last matching subsequence in a sequence.    *  @param  first1  Start of range to search.    *  @param  last1   End of range to search.    *  @param  first2  Start of sequence to match.    *  @param  last2   End of sequence to match.    *  @return   The last iterator @c i in the range    *  @p [first1,last1-(last2-first2)) such that @c *(i+N) == @p *(first2+N)    *  for each @c N in the range @p [0,last2-first2), or @p last1 if no    *  such iterator exists.    *    *  Searches the range @p [first1,last1) for a sub-sequence that compares    *  equal value-by-value with the sequence given by @p [first2,last2) and    *  returns an iterator to the first element of the sub-sequence, or    *  @p last1 if the sub-sequence is not found.  The sub-sequence will be the    *  last such subsequence contained in [first,last1).    *    *  Because the sub-sequence must lie completely within the range    *  @p [first1,last1) it must start at a position less than    *  @p last1-(last2-first2) where @p last2-first2 is the length of the    *  sub-sequence.    *  This means that the returned iterator @c i will be in the range    *  @p [first1,last1-(last2-first2))   */
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|_ForwardIterator1
operator|,
name|typename
name|_ForwardIterator2
operator|>
specifier|inline
name|_ForwardIterator1
name|find_end
argument_list|(
argument|_ForwardIterator1 __first1
argument_list|,
argument|_ForwardIterator1 __last1
argument_list|,
argument|_ForwardIterator2 __first2
argument_list|,
argument|_ForwardIterator2 __last2
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator2>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_EqualOpConcept< 	    typename iterator_traits<_ForwardIterator1>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator2>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
block|;
return|return
name|std
operator|::
name|__find_end
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first1
argument_list|)
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first2
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**    *  @brief  Find last matching subsequence in a sequence using a predicate.    *  @param  first1  Start of range to search.    *  @param  last1   End of range to search.    *  @param  first2  Start of sequence to match.    *  @param  last2   End of sequence to match.    *  @param  comp    The predicate to use.    *  @return   The last iterator @c i in the range    *  @p [first1,last1-(last2-first2)) such that @c predicate(*(i+N), @p    *  (first2+N)) is true for each @c N in the range @p [0,last2-first2), or    *  @p last1 if no such iterator exists.    *    *  Searches the range @p [first1,last1) for a sub-sequence that compares    *  equal value-by-value with the sequence given by @p [first2,last2) using    *  comp as a predicate and returns an iterator to the first element of the    *  sub-sequence, or @p last1 if the sub-sequence is not found.  The    *  sub-sequence will be the last such subsequence contained in    *  [first,last1).    *    *  Because the sub-sequence must lie completely within the range    *  @p [first1,last1) it must start at a position less than    *  @p last1-(last2-first2) where @p last2-first2 is the length of the    *  sub-sequence.    *  This means that the returned iterator @c i will be in the range    *  @p [first1,last1-(last2-first2))   */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_ForwardIterator1
operator|,
name|typename
name|_ForwardIterator2
operator|,
name|typename
name|_BinaryPredicate
operator|>
specifier|inline
name|_ForwardIterator1
name|find_end
argument_list|(
argument|_ForwardIterator1 __first1
argument_list|,
argument|_ForwardIterator1 __last1
argument_list|,
argument|_ForwardIterator2 __first2
argument_list|,
argument|_ForwardIterator2 __last2
argument_list|,
argument|_BinaryPredicate __comp
argument_list|)
block|{
comment|// concept requirements
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator1>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_ForwardIteratorConcept<_ForwardIterator2>
argument_list|)
name|__glibcxx_function_requires
argument_list|(
argument|_BinaryPredicateConcept<_BinaryPredicate
argument_list|,
argument|typename iterator_traits<_ForwardIterator1>::value_type
argument_list|,
argument|typename iterator_traits<_ForwardIterator2>::value_type>
argument_list|)
name|__glibcxx_requires_valid_range
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|)
block|;
name|__glibcxx_requires_valid_range
argument_list|(
name|__first2
argument_list|,
name|__last2
argument_list|)
block|;
return|return
name|std
operator|::
name|__find_end
argument_list|(
name|__first1
argument_list|,
name|__last1
argument_list|,
name|__first2
argument_list|,
name|__last2
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first1
argument_list|)
argument_list|,
name|std
operator|::
name|__iterator_category
argument_list|(
name|__first2
argument_list|)
argument_list|,
name|__comp
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|_GLIBCXX_END_NAMESPACE
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _ALGO_H */
end_comment

end_unit

