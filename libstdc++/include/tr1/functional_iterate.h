begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// TR1 functional -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2005, 2006 Free Software Foundation, Inc.
end_comment

begin_comment
comment|// Written by Douglas Gregor<doug.gregor -at- gmail.com>
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|/** @file tr1/functional_iterate.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  */
end_comment

begin_decl_stmt
name|namespace
name|std
block|{
name|_GLIBCXX_BEGIN_NAMESPACE
argument_list|(
argument|tr1
argument_list|)
name|template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
expr|struct
name|_Weak_result_type_impl
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
block|{
typedef|typedef
name|_Res
name|result_type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
expr|struct
name|_Weak_result_type_impl
operator|<
name|_Res
argument_list|(
operator|&
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
block|{
typedef|typedef
name|_Res
name|result_type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
expr|struct
name|_Weak_result_type_impl
operator|<
name|_Res
argument_list|(
operator|*
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
block|{
typedef|typedef
name|_Res
name|result_type
typedef|;
block|}
empty_stmt|;
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|>
literal|0
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
expr|struct
name|_Weak_result_type_impl
operator|<
name|_Res
argument_list|(
name|_Class
operator|::
operator|*
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
argument_list|)
operator|>
block|{
typedef|typedef
name|_Res
name|result_type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
expr|struct
name|_Weak_result_type_impl
operator|<
name|_Res
argument_list|(
argument|_Class::*
argument_list|)
operator|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
operator|)
specifier|const
operator|>
block|{
typedef|typedef
name|_Res
name|result_type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
expr|struct
name|_Weak_result_type_impl
operator|<
name|_Res
argument_list|(
name|_Class
operator|::
operator|*
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
argument_list|)
specifier|volatile
operator|>
block|{
typedef|typedef
name|_Res
name|result_type
typedef|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
expr|struct
name|_Weak_result_type_impl
operator|<
name|_Res
argument_list|(
argument|_Class::*
argument_list|)
operator|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
operator|)
specifier|const
specifier|volatile
operator|>
block|{
typedef|typedef
name|_Res
name|result_type
typedef|;
block|}
empty_stmt|;
endif|#
directive|endif
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|result_of
operator|<
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|:
name|public
name|_Result_of_impl
operator|<
name|_Has_result_type
operator|<
name|_Weak_result_type
operator|<
name|_Functor
operator|>
expr|>
operator|::
name|value
operator|,
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
block|{ }
expr_stmt|;
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
expr|struct
name|_Result_of_impl
operator|<
name|true
operator|,
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
block|{
typedef|typedef
name|typename
name|_Weak_result_type
operator|<
name|_Functor
operator|>
operator|::
name|result_type
name|type
expr_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
expr|struct
name|_Result_of_impl
operator|<
name|false
operator|,
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
block|{
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|>
literal|0
typedef|typedef
name|typename
name|_Functor
operator|::
name|template
name|result
operator|<
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|type
name|type
expr_stmt|;
else|#
directive|else
typedef|typedef
name|void
name|type
typedef|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**  * @if maint  * Invoke a function object, which may be either a member pointer or a  * function object. The first parameter will tell which.  * @endif  */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
specifier|inline
name|typename
name|__gnu_cxx
operator|::
name|__enable_if
operator|<
operator|(
operator|!
name|is_member_pointer
operator|<
name|_Functor
operator|>
operator|::
name|value
operator|&&
operator|!
name|is_function
operator|<
name|_Functor
operator|>
operator|::
name|value
operator|&&
operator|!
name|is_function
operator|<
name|typename
name|remove_pointer
operator|<
name|_Functor
operator|>
operator|::
name|type
operator|>
operator|::
name|value
operator|)
operator|,
name|typename
name|result_of
operator|<
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|type
operator|>
operator|::
name|__type
name|__invoke
argument_list|(
argument|_Functor& __f _GLIBCXX_COMMA _GLIBCXX_REF_PARAMS
argument_list|)
block|{
return|return
name|__f
argument_list|(
name|_GLIBCXX_ARGS
argument_list|)
return|;
block|}
end_expr_stmt

begin_if
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|>
literal|0
end_if

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
specifier|inline
name|typename
name|__gnu_cxx
operator|::
name|__enable_if
operator|<
operator|(
name|is_member_pointer
operator|<
name|_Functor
operator|>
operator|::
name|value
operator|&&
operator|!
name|is_function
operator|<
name|_Functor
operator|>
operator|::
name|value
operator|&&
operator|!
name|is_function
operator|<
name|typename
name|remove_pointer
operator|<
name|_Functor
operator|>
operator|::
name|type
operator|>
operator|::
name|value
operator|)
operator|,
name|typename
name|result_of
operator|<
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|type
operator|>
operator|::
name|__type
name|__invoke
argument_list|(
argument|_Functor& __f _GLIBCXX_COMMA _GLIBCXX_REF_PARAMS
argument_list|)
block|{
return|return
name|mem_fn
argument_list|(
name|__f
argument_list|)
argument_list|(
name|_GLIBCXX_ARGS
argument_list|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// To pick up function references (that will become function pointers)
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
specifier|inline
name|typename
name|__gnu_cxx
operator|::
name|__enable_if
operator|<
operator|(
name|is_pointer
operator|<
name|_Functor
operator|>
operator|::
name|value
operator|&&
name|is_function
operator|<
name|typename
name|remove_pointer
operator|<
name|_Functor
operator|>
operator|::
name|type
operator|>
operator|::
name|value
operator|)
operator|,
name|typename
name|result_of
operator|<
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|type
operator|>
operator|::
name|__type
name|__invoke
argument_list|(
argument|_Functor __f _GLIBCXX_COMMA _GLIBCXX_REF_PARAMS
argument_list|)
block|{
return|return
name|__f
argument_list|(
name|_GLIBCXX_ARGS
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/**  * @if maint  * Implementation of reference_wrapper::operator()  * @endif */
end_comment

begin_if
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|>
literal|0
end_if

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|template
operator|<
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|typename
name|result_of
operator|<
name|typename
name|reference_wrapper
operator|<
name|_Tp
operator|>
operator|::
name|_M_func_type
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|type
name|reference_wrapper
operator|<
name|_Tp
operator|>
operator|::
name|operator
argument_list|()
operator|(
name|_GLIBCXX_REF_PARAMS
operator|)
specifier|const
block|{
return|return
name|__invoke
argument_list|(
name|get
argument_list|()
argument_list|,
name|_GLIBCXX_ARGS
argument_list|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|>
literal|0
end_if

begin_expr_stmt
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
name|class
name|_Mem_fn
operator|<
name|_Res
argument_list|(
name|_Class
operator|::
operator|*
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
argument_list|)
operator|>
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|==
literal|1
operator|:
name|public
name|unary_function
operator|<
name|_Class
operator|*
operator|,
name|_Res
operator|>
elif|#
directive|elif
name|_GLIBCXX_NUM_ARGS
operator|==
literal|2
operator|:
name|public
name|binary_function
operator|<
name|_Class
operator|*
operator|,
name|_T1
operator|,
name|_Res
operator|>
endif|#
directive|endif
block|{
typedef|typedef
name|_Res
argument_list|(
name|_Class
operator|::
operator|*
name|_Functor
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
argument_list|)
expr_stmt|;
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __object
argument_list|,
argument|const volatile _Class * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __ptr
argument_list|,
argument|const volatile void * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
operator|(
operator|*
name|__ptr
operator|)
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|_Res
name|result_type
typedef|;
end_typedef

begin_macro
name|explicit
end_macro

begin_macro
name|_Mem_fn
argument_list|(
argument|_Functor __pf
argument_list|)
end_macro

begin_macro
unit|:
name|__pmf
argument_list|(
argument|__pf
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|// Handle objects
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
name|_Class
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle pointers
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
name|_Class
operator|*
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|->*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle smart pointers, references and pointers to derived
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
name|_M_call
argument_list|(
argument|__object
argument_list|,
argument|&__object _GLIBCXX_COMMA_SHIFTED                        _GLIBCXX_ARGS_SHIFTED
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|_Functor
name|__pmf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
name|class
name|_Mem_fn
operator|<
name|_Res
argument_list|(
argument|_Class::*
argument_list|)
operator|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
operator|)
specifier|const
operator|>
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|==
literal|1
operator|:
name|public
name|unary_function
operator|<
specifier|const
name|_Class
operator|*
operator|,
name|_Res
operator|>
elif|#
directive|elif
name|_GLIBCXX_NUM_ARGS
operator|==
literal|2
operator|:
name|public
name|binary_function
operator|<
specifier|const
name|_Class
operator|*
operator|,
name|_T1
operator|,
name|_Res
operator|>
endif|#
directive|endif
block|{
typedef|typedef
name|_Res
argument_list|(
argument|_Class::*_Functor
argument_list|)
operator|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
operator|)
specifier|const
expr_stmt|;
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __object
argument_list|,
argument|const volatile _Class * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __ptr
argument_list|,
argument|const volatile void * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
operator|(
operator|*
name|__ptr
operator|)
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|_Res
name|result_type
typedef|;
end_typedef

begin_macro
name|explicit
end_macro

begin_macro
name|_Mem_fn
argument_list|(
argument|_Functor __pf
argument_list|)
end_macro

begin_macro
unit|:
name|__pmf
argument_list|(
argument|__pf
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|// Handle objects
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
specifier|const
name|_Class
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle pointers
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
specifier|const
name|_Class
operator|*
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|->*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle smart pointers, references and pointers to derived
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
name|_M_call
argument_list|(
argument|__object
argument_list|,
argument|&__object _GLIBCXX_COMMA_SHIFTED                        _GLIBCXX_ARGS_SHIFTED
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|_Functor
name|__pmf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
name|class
name|_Mem_fn
operator|<
name|_Res
argument_list|(
name|_Class
operator|::
operator|*
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
argument_list|)
specifier|volatile
operator|>
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|==
literal|1
operator|:
name|public
name|unary_function
operator|<
specifier|volatile
name|_Class
operator|*
operator|,
name|_Res
operator|>
elif|#
directive|elif
name|_GLIBCXX_NUM_ARGS
operator|==
literal|2
operator|:
name|public
name|binary_function
operator|<
specifier|volatile
name|_Class
operator|*
operator|,
name|_T1
operator|,
name|_Res
operator|>
endif|#
directive|endif
block|{
typedef|typedef
name|_Res
argument_list|(
name|_Class
operator|::
operator|*
name|_Functor
argument_list|)
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
argument_list|)
specifier|volatile
expr_stmt|;
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __object
argument_list|,
argument|const volatile _Class * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __ptr
argument_list|,
argument|const volatile void * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
operator|(
operator|*
name|__ptr
operator|)
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|_Res
name|result_type
typedef|;
end_typedef

begin_macro
name|explicit
end_macro

begin_macro
name|_Mem_fn
argument_list|(
argument|_Functor __pf
argument_list|)
end_macro

begin_macro
unit|:
name|__pmf
argument_list|(
argument|__pf
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|// Handle objects
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
specifier|volatile
name|_Class
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle pointers
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
specifier|volatile
name|_Class
operator|*
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|->*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle smart pointers, references and pointers to derived
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
name|_M_call
argument_list|(
argument|__object
argument_list|,
argument|&__object _GLIBCXX_COMMA_SHIFTED                        _GLIBCXX_ARGS_SHIFTED
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|_Functor
name|__pmf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Class
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_TEMPLATE_PARAMS_SHIFTED
operator|>
name|class
name|_Mem_fn
operator|<
name|_Res
argument_list|(
argument|_Class::*
argument_list|)
operator|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
operator|)
specifier|const
specifier|volatile
operator|>
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|==
literal|1
operator|:
name|public
name|unary_function
operator|<
specifier|const
specifier|volatile
name|_Class
operator|*
operator|,
name|_Res
operator|>
elif|#
directive|elif
name|_GLIBCXX_NUM_ARGS
operator|==
literal|2
operator|:
name|public
name|binary_function
operator|<
specifier|const
specifier|volatile
name|_Class
operator|*
operator|,
name|_T1
operator|,
name|_Res
operator|>
endif|#
directive|endif
block|{
typedef|typedef
name|_Res
argument_list|(
argument|_Class::*_Functor
argument_list|)
operator|(
name|_GLIBCXX_TEMPLATE_ARGS_SHIFTED
operator|)
specifier|const
specifier|volatile
expr_stmt|;
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __object
argument_list|,
argument|const volatile _Class * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|_M_call
argument_list|(
argument|_Tp& __ptr
argument_list|,
argument|const volatile void * _GLIBCXX_COMMA_SHIFTED               _GLIBCXX_PARAMS_SHIFTED
argument_list|)
specifier|const
block|{
return|return
operator|(
operator|(
operator|*
name|__ptr
operator|)
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|_Res
name|result_type
typedef|;
end_typedef

begin_macro
name|explicit
end_macro

begin_macro
name|_Mem_fn
argument_list|(
argument|_Functor __pf
argument_list|)
end_macro

begin_macro
unit|:
name|__pmf
argument_list|(
argument|__pf
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|// Handle objects
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
specifier|const
specifier|volatile
name|_Class
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|.*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle pointers
end_comment

begin_expr_stmt
name|_Res
name|operator
argument_list|()
operator|(
specifier|const
specifier|volatile
name|_Class
operator|*
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
operator|(
name|__object
operator|->*
name|__pmf
operator|)
operator|(
name|_GLIBCXX_ARGS_SHIFTED
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Handle smart pointers, references and pointers to derived
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|_Res
name|operator
argument_list|()
operator|(
name|_Tp
operator|&
name|__object
name|_GLIBCXX_COMMA_SHIFTED
name|_GLIBCXX_PARAMS_SHIFTED
operator|)
specifier|const
block|{
return|return
name|_M_call
argument_list|(
argument|__object
argument_list|,
argument|&__object _GLIBCXX_COMMA_SHIFTED                        _GLIBCXX_ARGS_SHIFTED
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|_Functor
name|__pmf
decl_stmt|;
end_decl_stmt

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|>
literal|0
end_if

begin_decl_stmt
name|namespace
name|placeholders
block|{
name|namespace
block|{
name|_Placeholder
operator|<
name|_GLIBCXX_NUM_ARGS
operator|>
name|_GLIBCXX_JOIN
argument_list|(
name|_
argument_list|,
name|_GLIBCXX_NUM_ARGS
argument_list|)
expr_stmt|;
block|}
comment|// anonymous namespace
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Bind
operator|<
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|:
name|public
name|_Weak_result_type
operator|<
name|_Functor
operator|>
block|{
typedef|typedef
name|_Bind
name|__self_type
typedef|;
name|_Functor
name|_M_f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_GLIBCXX_BIND_MEMBERS
name|public
range|:
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|==
literal|0
name|explicit
endif|#
directive|endif
name|_Bind
argument_list|(
argument|_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__f
argument_list|)
name|_GLIBCXX_COMMA
name|_GLIBCXX_BIND_MEMBERS_INIT
block|{ }
end_decl_stmt

begin_define
define|#
directive|define
name|_GLIBCXX_BIND_REPEAT_HEADER
value|<tr1/bind_iterate.h>
end_define

begin_include
include|#
directive|include
file|<tr1/bind_repeat.h>
end_include

begin_undef
undef|#
directive|undef
name|_GLIBCXX_BIND_REPEAT_HEADER
end_undef

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Result
operator|,
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Bind_result
operator|<
name|_Result
operator|,
name|_Functor
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
block|{
name|_Functor
name|_M_f
block|;
name|_GLIBCXX_BIND_MEMBERS
name|public
operator|:
typedef|typedef
name|_Result
name|result_type
typedef|;
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|==
literal|0
name|explicit
endif|#
directive|endif
name|_Bind_result
argument_list|(
argument|_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
operator|:
name|_M_f
argument_list|(
argument|__f
argument_list|)
name|_GLIBCXX_COMMA
name|_GLIBCXX_BIND_MEMBERS_INIT
block|{ }
end_expr_stmt

begin_define
define|#
directive|define
name|_GLIBCXX_BIND_REPEAT_HEADER
value|<tr1/bind_iterate.h>
end_define

begin_define
define|#
directive|define
name|_GLIBCXX_BIND_HAS_RESULT_TYPE
end_define

begin_include
include|#
directive|include
file|<tr1/bind_repeat.h>
end_include

begin_undef
undef|#
directive|undef
name|_GLIBCXX_BIND_HAS_RESULT_TYPE
end_undef

begin_undef
undef|#
directive|undef
name|_GLIBCXX_BIND_REPEAT_HEADER
end_undef

begin_comment
unit|};
comment|// Handle arbitrary function objects
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
specifier|inline
name|_Bind
operator|<
name|typename
name|_Maybe_wrap_member_pointer
operator|<
name|_Functor
operator|>
operator|::
name|type
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
name|bind
argument_list|(
argument|_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
block|{
typedef|typedef
name|_Maybe_wrap_member_pointer
operator|<
name|_Functor
operator|>
name|__maybe_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|__maybe_type
operator|::
name|type
name|__functor_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Bind
operator|<
name|__functor_type
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
name|__result_type
expr_stmt|;
end_typedef

begin_return
return|return
name|__result_type
argument_list|(
argument|__maybe_type::__do_wrap(__f)                        _GLIBCXX_COMMA _GLIBCXX_ARGS
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|_Result
operator|,
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
specifier|inline
name|_Bind_result
operator|<
name|_Result
operator|,
name|typename
name|_Maybe_wrap_member_pointer
operator|<
name|_Functor
operator|>
operator|::
name|type
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
name|bind
argument_list|(
argument|_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
block|{
typedef|typedef
name|_Maybe_wrap_member_pointer
operator|<
name|_Functor
operator|>
name|__maybe_type
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|__maybe_type
operator|::
name|type
name|__functor_type
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Bind_result
operator|<
name|_Result
operator|,
name|__functor_type
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
name|__result_type
expr_stmt|;
end_typedef

begin_return
return|return
name|__result_type
argument_list|(
argument|__maybe_type::__do_wrap(__f)                        _GLIBCXX_COMMA _GLIBCXX_ARGS
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Function_handler
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|_Functor
operator|>
operator|:
name|public
name|_Function_base
operator|::
name|_Base_manager
operator|<
name|_Functor
operator|>
block|{
typedef|typedef
name|_Function_base
operator|::
name|_Base_manager
operator|<
name|_Functor
operator|>
name|_Base
expr_stmt|;
name|public
operator|:
specifier|static
name|_Res
name|_M_invoke
argument_list|(
argument|const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
block|{
return|return
operator|(
operator|*
name|_Base
operator|::
name|_M_get_pointer
argument_list|(
name|__functor
argument_list|)
operator|)
operator|(
name|_GLIBCXX_ARGS
operator|)
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Function_handler
operator|<
name|void
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|_Functor
operator|>
operator|:
name|public
name|_Function_base
operator|::
name|_Base_manager
operator|<
name|_Functor
operator|>
block|{
typedef|typedef
name|_Function_base
operator|::
name|_Base_manager
operator|<
name|_Functor
operator|>
name|_Base
expr_stmt|;
name|public
operator|:
specifier|static
name|void
name|_M_invoke
argument_list|(
argument|const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
block|{
operator|(
operator|*
name|_Base
operator|::
name|_M_get_pointer
argument_list|(
name|__functor
argument_list|)
operator|)
operator|(
name|_GLIBCXX_ARGS
operator|)
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Res
operator|,
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Function_handler
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|reference_wrapper
operator|<
name|_Functor
operator|>
expr|>
operator|:
name|public
name|_Function_base
operator|::
name|_Ref_manager
operator|<
name|_Functor
operator|>
block|{
typedef|typedef
name|_Function_base
operator|::
name|_Ref_manager
operator|<
name|_Functor
operator|>
name|_Base
expr_stmt|;
name|public
operator|:
specifier|static
name|_Res
name|_M_invoke
argument_list|(
argument|const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
block|{
return|return
name|__callable_functor
argument_list|(
operator|*
operator|*
name|_Base
operator|::
name|_M_get_pointer
argument_list|(
name|__functor
argument_list|)
argument_list|)
argument_list|(
name|_GLIBCXX_ARGS
argument_list|)
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Function_handler
operator|<
name|void
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|reference_wrapper
operator|<
name|_Functor
operator|>
expr|>
operator|:
name|public
name|_Function_base
operator|::
name|_Ref_manager
operator|<
name|_Functor
operator|>
block|{
typedef|typedef
name|_Function_base
operator|::
name|_Ref_manager
operator|<
name|_Functor
operator|>
name|_Base
expr_stmt|;
name|public
operator|:
specifier|static
name|void
name|_M_invoke
argument_list|(
argument|const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
block|{
name|__callable_functor
argument_list|(
operator|*
operator|*
name|_Base
operator|::
name|_M_get_pointer
argument_list|(
name|__functor
argument_list|)
argument_list|)
argument_list|(
name|_GLIBCXX_ARGS
argument_list|)
block|;   }
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Class
operator|,
name|typename
name|_Member
operator|,
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Function_handler
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|_Member
name|_Class
operator|::
operator|*
operator|>
operator|:
name|public
name|_Function_handler
operator|<
name|void
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|_Member
name|_Class
operator|::
operator|*
operator|>
block|{
typedef|typedef
name|_Function_handler
operator|<
name|void
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|_Member
name|_Class
operator|::
operator|*
operator|>
name|_Base
expr_stmt|;
name|public
operator|:
specifier|static
name|_Res
name|_M_invoke
argument_list|(
argument|const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS
argument_list|)
block|{
return|return
name|std
operator|::
name|tr1
operator|::
name|mem_fn
argument_list|(
name|_Base
operator|::
name|_M_get_pointer
argument_list|(
name|__functor
argument_list|)
operator|->
name|__value
argument_list|)
argument_list|(
name|_GLIBCXX_ARGS
argument_list|)
return|;
block|}
block|}
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Class
operator|,
name|typename
name|_Member
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|_Function_handler
operator|<
name|void
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|,
name|_Member
name|_Class
operator|::
operator|*
operator|>
operator|:
name|public
name|_Function_base
operator|::
name|_Base_manager
operator|<
name|_Simple_type_wrapper
operator|<
name|_Member
name|_Class
operator|::
operator|*
operator|>
expr|>
block|{
typedef|typedef
name|_Member
name|_Class
operator|::
operator|*
name|_Functor
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Simple_type_wrapper
operator|<
name|_Functor
operator|>
name|_Wrapper
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|_Function_base
operator|::
name|_Base_manager
operator|<
name|_Wrapper
operator|>
name|_Base
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_function
specifier|static
name|bool
name|_M_manager
parameter_list|(
name|_Any_data
modifier|&
name|__dest
parameter_list|,
specifier|const
name|_Any_data
modifier|&
name|__source
parameter_list|,
name|_Manager_operation
name|__op
parameter_list|)
block|{
switch|switch
condition|(
name|__op
condition|)
block|{
case|case
name|__get_type_info
case|:
name|__dest
operator|.
name|_M_access
operator|<
specifier|const
name|type_info
operator|*
operator|>
operator|(
operator|)
operator|=
operator|&
name|typeid
argument_list|(
name|_Functor
argument_list|)
expr_stmt|;
break|break;
case|case
name|__get_functor_ptr
case|:
name|__dest
operator|.
name|_M_access
operator|<
name|_Functor
operator|*
operator|>
operator|(
operator|)
operator|=
operator|&
name|_Base
operator|::
name|_M_get_pointer
argument_list|(
name|__source
argument_list|)
operator|->
name|__value
expr_stmt|;
break|break;
default|default:
name|_Base
operator|::
name|_M_manager
argument_list|(
name|__dest
argument_list|,
name|__source
argument_list|,
name|__op
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_M_invoke
parameter_list|(
specifier|const
name|_Any_data
modifier|&
name|__functor
name|_GLIBCXX_COMMA
name|_GLIBCXX_PARAMS
parameter_list|)
block|{
name|std
operator|::
name|tr1
operator|::
name|mem_fn
argument_list|(
name|_Base
operator|::
name|_M_get_pointer
argument_list|(
name|__functor
argument_list|)
operator|->
name|__value
argument_list|)
argument_list|(
name|_GLIBCXX_ARGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|class
name|function
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
if|#
directive|if
name|_GLIBCXX_NUM_ARGS
operator|==
literal|1
operator|:
name|public
name|unary_function
operator|<
name|_T1
operator|,
name|_Res
operator|>
operator|,
name|private
name|_Function_base
elif|#
directive|elif
name|_GLIBCXX_NUM_ARGS
operator|==
literal|2
operator|:
name|public
name|binary_function
operator|<
name|_T1
operator|,
name|_T2
operator|,
name|_Res
operator|>
operator|,
name|private
name|_Function_base
else|#
directive|else
operator|:
name|private
name|_Function_base
endif|#
directive|endif
block|{
comment|/**    *  @if maint    *  This class is used to implement the safe_bool idiom.    *  @endif    */
block|struct
name|_Hidden_type
block|{
name|_Hidden_type
operator|*
name|_M_bool
block|;   }
block|;
comment|/**    *  @if maint    *  This typedef is used to implement the safe_bool idiom.    *  @endif    */
typedef|typedef
name|_Hidden_type
operator|*
name|_Hidden_type
operator|::
operator|*
name|_Safe_bool
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Res
name|_Signature_type
parameter_list|(
name|_GLIBCXX_TEMPLATE_ARGS
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|_Useless
block|{}
struct|;
end_struct

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|_Res
name|result_type
typedef|;
end_typedef

begin_comment
comment|// [3.7.2.1] construct/copy/destroy
end_comment

begin_comment
comment|/**    *  @brief Default construct creates an empty function call wrapper.    *  @post @c !(bool)*this    */
end_comment

begin_expr_stmt
name|function
argument_list|()
operator|:
name|_Function_base
argument_list|()
block|{ }
comment|/**    *  @brief Default construct creates an empty function call wrapper.    *  @post @c !(bool)*this    */
name|function
argument_list|(
name|_M_clear_type
operator|*
argument_list|)
operator|:
name|_Function_base
argument_list|()
block|{ }
comment|/**    *  @brief %Function copy constructor.    *  @param x A %function object with identical call signature.    *  @pre @c (bool)*this == (bool)x    *    *  The newly-created %function contains a copy of the target of @a    *  x (if it has one).    */
name|function
argument_list|(
specifier|const
name|function
operator|&
name|__x
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**    *  @brief Builds a %function that targets a copy of the incoming    *  function object.    *  @param f A %function object that is callable with parameters of    *  type @c T1, @c T2, ..., @c TN and returns a value convertible    *  to @c Res.    *    *  The newly-created %function object will target a copy of @a    *  f. If @a f is @c reference_wrapper<F>, then this function    *  object will contain a reference to the function object @c    *  f.get(). If @a f is a NULL function pointer or NULL    *  pointer-to-member, the newly-created object will be empty.    *    *  If @a f is a non-NULL function pointer or an object of type @c    *  reference_wrapper<F>, this function will not throw.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
operator|>
name|function
argument_list|(
argument|_Functor __f
argument_list|,
argument|typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value
argument_list|,
argument|_Useless>::__type = _Useless()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**    *  @brief %Function assignment operator.    *  @param x A %function with identical call signature.    *  @post @c (bool)*this == (bool)x    *  @returns @c *this    *    *  The target of @a x is copied to @c *this. If @a x has no    *  target, then @c *this will be empty.    *    *  If @a x targets a function pointer or a reference to a function    *  object, then this operation will not throw an exception.    */
end_comment

begin_decl_stmt
name|function
modifier|&
name|operator
init|=
operator|(
specifier|const
name|function
operator|&
name|__x
operator|)
block|{
name|function
argument_list|(
name|__x
argument_list|)
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/**    *  @brief %Function assignment to zero.    *  @post @c !(bool)*this    *  @returns @c *this    *    *  The target of @a *this is deallocated, leaving it empty.    */
end_comment

begin_decl_stmt
name|function
modifier|&
name|operator
init|=
operator|(
name|_M_clear_type
operator|*
operator|)
block|{
if|if
condition|(
name|_M_manager
condition|)
block|{
name|_M_manager
argument_list|(
name|_M_functor
argument_list|,
name|_M_functor
argument_list|,
name|__destroy_functor
argument_list|)
expr_stmt|;
name|_M_manager
operator|=
literal|0
expr_stmt|;
name|_M_invoker
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/**    *  @brief %Function assignment to a new target.    *  @param f A %function object that is callable with parameters of    *  type @c T1, @c T2, ..., @c TN and returns a value convertible    *  to @c Res.    *  @return @c *this    *    *  This  %function object wrapper will target a copy of @a    *  f. If @a f is @c reference_wrapper<F>, then this function    *  object will contain a reference to the function object @c    *  f.get(). If @a f is a NULL function pointer or NULL    *  pointer-to-member, @c this object will be empty.    *    *  If @a f is a non-NULL function pointer or an object of type @c    *  reference_wrapper<F>, this function will not throw.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
operator|>
name|typename
name|__gnu_cxx
operator|::
name|__enable_if
operator|<
operator|!
name|is_integral
operator|<
name|_Functor
operator|>
operator|::
name|value
operator|,
name|function
operator|&
operator|>
operator|::
name|__type
name|operator
operator|=
operator|(
name|_Functor
name|__f
operator|)
block|{
name|function
argument_list|(
name|__f
argument_list|)
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|// [3.7.2.2] function modifiers
end_comment

begin_comment
comment|/**    *  @brief Swap the targets of two %function objects.    *  @param f A %function with identical call signature.    *    *  Swap the targets of @c this function object and @a f. This    *  function will not throw an exception.    */
end_comment

begin_function
name|void
name|swap
parameter_list|(
name|function
modifier|&
name|__x
parameter_list|)
block|{
name|_Any_data
name|__old_functor
init|=
name|_M_functor
decl_stmt|;
name|_M_functor
operator|=
name|__x
operator|.
name|_M_functor
expr_stmt|;
name|__x
operator|.
name|_M_functor
operator|=
name|__old_functor
expr_stmt|;
name|_Manager_type
name|__old_manager
init|=
name|_M_manager
decl_stmt|;
name|_M_manager
operator|=
name|__x
operator|.
name|_M_manager
expr_stmt|;
name|__x
operator|.
name|_M_manager
operator|=
name|__old_manager
expr_stmt|;
name|_Invoker_type
name|__old_invoker
init|=
name|_M_invoker
decl_stmt|;
name|_M_invoker
operator|=
name|__x
operator|.
name|_M_invoker
expr_stmt|;
name|__x
operator|.
name|_M_invoker
operator|=
name|__old_invoker
expr_stmt|;
block|}
end_function

begin_comment
comment|// [3.7.2.3] function capacity
end_comment

begin_comment
comment|/**    *  @brief Determine if the %function wrapper has a target.    *    *  @return @c true when this %function object contains a target,    *  or @c false when it is empty.    *    *  This function will not throw an exception.    */
end_comment

begin_expr_stmt
name|operator
name|_Safe_bool
argument_list|()
specifier|const
block|{
if|if
condition|(
name|_M_empty
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
operator|&
name|_Hidden_type
operator|::
name|_M_bool
return|;
block|}
end_else

begin_comment
unit|}
comment|// [3.7.2.4] function invocation
end_comment

begin_comment
comment|/**    *  @brief Invokes the function targeted by @c *this.    *  @returns the result of the target.    *  @throws bad_function_call when @c !(bool)*this    *    *  The function call operator invokes the target function object    *  stored by @c this.    */
end_comment

begin_macro
unit|_Res
name|operator
argument_list|()
end_macro

begin_expr_stmt
operator|(
name|_GLIBCXX_PARAMS
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|// [3.7.2.5] function target access
end_comment

begin_comment
comment|/**    *  @brief Determine the type of the target of this function object    *  wrapper.    *    *  @returns the type identifier of the target function object, or    *  @c typeid(void) if @c !(bool)*this.    *    *  This function will not throw an exception.    */
end_comment

begin_expr_stmt
specifier|const
name|type_info
operator|&
name|target_type
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**    *  @brief Access the stored target function object.    *    *  @return Returns a pointer to the stored target function object,    *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL    *  pointer.    *    * This function will not throw an exception.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
operator|>
name|_Functor
operator|*
name|target
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**    *  @overload    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Functor
operator|>
specifier|const
name|_Functor
operator|*
name|target
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_comment
comment|// [3.7.2.6] undefined operators
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Function
operator|>
name|void
name|operator
operator|==
operator|(
specifier|const
name|function
operator|<
name|_Function
operator|>
operator|&
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Function
operator|>
name|void
name|operator
operator|!=
operator|(
specifier|const
name|function
operator|<
name|_Function
operator|>
operator|&
operator|)
specifier|const
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|_Res
function_decl|(
modifier|*
name|_Invoker_type
function_decl|)
parameter_list|(
specifier|const
name|_Any_data
modifier|&
name|_GLIBCXX_COMMA
name|_GLIBCXX_PARAMS
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
name|_Invoker_type
name|_M_invoker
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|function
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|function
argument_list|(
specifier|const
name|function
operator|&
name|__x
argument_list|)
operator|:
name|_Function_base
argument_list|()
block|{
if|if
condition|(
name|__x
condition|)
block|{
name|_M_invoker
operator|=
name|__x
operator|.
name|_M_invoker
expr_stmt|;
name|_M_manager
operator|=
name|__x
operator|.
name|_M_manager
expr_stmt|;
name|__x
operator|.
name|_M_manager
argument_list|(
name|_M_functor
argument_list|,
name|__x
operator|.
name|_M_functor
argument_list|,
name|__clone_functor
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|template
operator|<
name|typename
name|_Functor
operator|>
name|function
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|function
argument_list|(
argument|_Functor __f
argument_list|,
argument|typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value
argument_list|,
argument|_Useless>::__type
argument_list|)
operator|:
name|_Function_base
argument_list|()
block|{
typedef|typedef
name|_Function_handler
operator|<
name|_Signature_type
operator|,
name|_Functor
operator|>
name|_My_handler
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_My_handler
operator|::
name|_M_not_empty_function
argument_list|(
name|__f
argument_list|)
condition|)
block|{
name|_M_invoker
operator|=
operator|&
name|_My_handler
operator|::
name|_M_invoke
expr_stmt|;
name|_M_manager
operator|=
operator|&
name|_My_handler
operator|::
name|_M_manager
expr_stmt|;
name|_My_handler
operator|::
name|_M_init_functor
argument_list|(
name|_M_functor
argument_list|,
name|__f
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|_Res
name|function
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|operator
argument_list|()
operator|(
name|_GLIBCXX_PARAMS
operator|)
specifier|const
block|{
if|if
condition|(
name|_M_empty
argument_list|()
condition|)
block|{
if|#
directive|if
name|__EXCEPTIONS
name|throw
name|bad_function_call
parameter_list|()
function_decl|;
else|#
directive|else
name|std
operator|::
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_return
return|return
name|_M_invoker
argument_list|(
argument|_M_functor _GLIBCXX_COMMA _GLIBCXX_ARGS
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
specifier|const
name|type_info
operator|&
name|function
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|target_type
argument_list|()
specifier|const
block|{
if|if
condition|(
name|_M_manager
condition|)
block|{
name|_Any_data
name|__typeinfo_result
decl_stmt|;
name|_M_manager
argument_list|(
name|__typeinfo_result
argument_list|,
name|_M_functor
argument_list|,
name|__get_type_info
argument_list|)
expr_stmt|;
return|return
operator|*
name|__typeinfo_result
operator|.
name|_M_access
operator|<
specifier|const
name|type_info
operator|*
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
name|typeid
argument_list|(
name|void
argument_list|)
return|;
block|}
end_else

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|template
operator|<
name|typename
name|_Functor
operator|>
name|_Functor
operator|*
name|function
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|target
argument_list|()
block|{
if|if
condition|(
name|typeid
argument_list|(
name|_Functor
argument_list|)
operator|==
name|target_type
argument_list|()
operator|&&
name|_M_manager
condition|)
block|{
name|_Any_data
name|__ptr
decl_stmt|;
if|if
condition|(
name|_M_manager
argument_list|(
name|__ptr
argument_list|,
name|_M_functor
argument_list|,
name|__get_functor_ptr
argument_list|)
operator|&&
operator|!
name|is_const
operator|<
name|_Functor
operator|>
operator|::
name|value
condition|)
return|return
literal|0
return|;
else|else
return|return
name|__ptr
operator|.
name|_M_access
operator|<
name|_Functor
operator|*
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
literal|0
return|;
block|}
end_else

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|_Res
name|_GLIBCXX_COMMA
name|_GLIBCXX_TEMPLATE_PARAMS
operator|>
name|template
operator|<
name|typename
name|_Functor
operator|>
specifier|const
name|_Functor
operator|*
name|function
operator|<
name|_Res
argument_list|(
name|_GLIBCXX_TEMPLATE_ARGS
argument_list|)
operator|>
operator|::
name|target
argument_list|()
specifier|const
block|{
if|if
condition|(
name|typeid
argument_list|(
name|_Functor
argument_list|)
operator|==
name|target_type
argument_list|()
operator|&&
name|_M_manager
condition|)
block|{
name|_Any_data
name|__ptr
decl_stmt|;
name|_M_manager
argument_list|(
name|__ptr
argument_list|,
name|_M_functor
argument_list|,
name|__get_functor_ptr
argument_list|)
expr_stmt|;
return|return
name|__ptr
operator|.
name|_M_access
operator|<
specifier|const
name|_Functor
operator|*
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
literal|0
return|;
block|}
end_else

unit|}  _GLIBCXX_END_NAMESPACE }
end_unit

