begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//<tr1/boost_shared_ptr.h> -*- C++ -*-
end_comment

begin_comment
comment|// Copyright (C) 2005, 2006 Free Software Foundation, Inc.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is part of the GNU ISO C++ Library.  This library is free
end_comment

begin_comment
comment|// software; you can redistribute it and/or modify it under the
end_comment

begin_comment
comment|// terms of the GNU General Public License as published by the
end_comment

begin_comment
comment|// Free Software Foundation; either version 2, or (at your option)
end_comment

begin_comment
comment|// any later version.
end_comment

begin_comment
comment|// This library is distributed in the hope that it will be useful,
end_comment

begin_comment
comment|// but WITHOUT ANY WARRANTY; without even the implied warranty of
end_comment

begin_comment
comment|// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
end_comment

begin_comment
comment|// GNU General Public License for more details.
end_comment

begin_comment
comment|// You should have received a copy of the GNU General Public License along
end_comment

begin_comment
comment|// with this library; see the file COPYING.  If not, write to the Free
end_comment

begin_comment
comment|// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
end_comment

begin_comment
comment|// USA.
end_comment

begin_comment
comment|// As a special exception, you may use this file as part of a free software
end_comment

begin_comment
comment|// library without restriction.  Specifically, if other files instantiate
end_comment

begin_comment
comment|// templates or use macros or inline functions from this file, or you compile
end_comment

begin_comment
comment|// this file and link it with other files to produce an executable, this
end_comment

begin_comment
comment|// file does not by itself cause the resulting executable to be covered by
end_comment

begin_comment
comment|// the GNU General Public License.  This exception does not however
end_comment

begin_comment
comment|// invalidate any other reasons why the executable file might be covered by
end_comment

begin_comment
comment|// the GNU General Public License.
end_comment

begin_comment
comment|//  shared_count.hpp
end_comment

begin_comment
comment|//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
end_comment

begin_comment
comment|//  shared_ptr.hpp
end_comment

begin_comment
comment|//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.
end_comment

begin_comment
comment|//  Copyright (C) 2001, 2002, 2003 Peter Dimov
end_comment

begin_comment
comment|//  weak_ptr.hpp
end_comment

begin_comment
comment|//  Copyright (C) 2001, 2002, 2003 Peter Dimov
end_comment

begin_comment
comment|//  enable_shared_from_this.hpp
end_comment

begin_comment
comment|//  Copyright (C) 2002 Peter Dimov
end_comment

begin_comment
comment|// Distributed under the Boost Software License, Version 1.0. (See
end_comment

begin_comment
comment|// accompanying file LICENSE_1_0.txt or copy at
end_comment

begin_comment
comment|// http://www.boost.org/LICENSE_1_0.txt)
end_comment

begin_comment
comment|// GCC Note:  based on version 1.32.0 of the Boost library.
end_comment

begin_comment
comment|/** @file tr1/boost_shared_ptr.h  *  This is an internal header file, included by other library headers.  *  You should not attempt to use it directly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_BOOST_SHARED_PTR_H
end_ifndef

begin_define
define|#
directive|define
name|_BOOST_SHARED_PTR_H
value|1
end_define

begin_decl_stmt
name|namespace
name|std
block|{
name|_GLIBCXX_BEGIN_NAMESPACE
argument_list|(
argument|tr1
argument_list|)
name|class
name|bad_weak_ptr
range|:
name|public
name|std
operator|::
name|exception
block|{
name|public
operator|:
name|virtual
name|char
specifier|const
operator|*
name|what
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
literal|"tr1::bad_weak_ptr"
return|;
block|}
expr|}
block|;
comment|// Substitute for bad_weak_ptr object in the case of -fno-exceptions.
specifier|inline
name|void
name|__throw_bad_weak_ptr
argument_list|()
block|{
if|#
directive|if
name|__EXCEPTIONS
name|throw
name|bad_weak_ptr
argument_list|()
block|;
else|#
directive|else
name|std
operator|::
name|abort
argument_list|()
block|;
endif|#
directive|endif
block|}
name|using
name|__gnu_cxx
operator|::
name|_Lock_policy
block|;
name|using
name|__gnu_cxx
operator|::
name|__default_lock_policy
block|;
name|using
name|__gnu_cxx
operator|::
name|_S_single
block|;
name|using
name|__gnu_cxx
operator|::
name|_S_mutex
block|;
name|using
name|__gnu_cxx
operator|::
name|_S_atomic
block|;
name|template
operator|<
name|typename
name|_Tp
operator|>
expr|struct
name|_Sp_deleter
block|{
typedef|typedef
name|void
name|result_type
typedef|;
typedef|typedef
name|_Tp
modifier|*
name|argument_type
typedef|;
name|void
name|operator
argument_list|()
operator|(
name|_Tp
operator|*
name|__p
operator|)
specifier|const
block|{
name|delete
name|__p
block|; }
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Empty helper class except when the template argument is _S_mutex.
end_comment

begin_expr_stmt
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|>
name|class
name|_Mutex_base
block|{ }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
operator|>
name|class
name|_Mutex_base
operator|<
name|_S_mutex
operator|>
operator|:
name|public
name|__gnu_cxx
operator|::
name|__mutex
block|{ }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|=
name|__default_lock_policy
operator|>
name|class
name|_Sp_counted_base
operator|:
name|public
name|_Mutex_base
operator|<
name|_Lp
operator|>
block|{
name|public
operator|:
name|_Sp_counted_base
argument_list|()
operator|:
name|_M_use_count
argument_list|(
literal|1
argument_list|)
block|,
name|_M_weak_count
argument_list|(
literal|1
argument_list|)
block|{ }
name|virtual
operator|~
name|_Sp_counted_base
argument_list|()
comment|// nothrow
block|{ }
comment|// Called when _M_use_count drops to zero, to release the resources
comment|// managed by *this.
name|virtual
name|void
name|_M_dispose
argument_list|()
operator|=
literal|0
block|;
comment|// nothrow
comment|// Called when _M_weak_count drops to zero.
name|virtual
name|void
name|_M_destroy
argument_list|()
comment|// nothrow
block|{
name|delete
name|this
block|; }
name|virtual
name|void
operator|*
name|_M_get_deleter
argument_list|(
specifier|const
name|std
operator|::
name|type_info
operator|&
argument_list|)
operator|=
literal|0
block|;
name|void
name|_M_add_ref_copy
argument_list|()
block|{
name|__gnu_cxx
operator|::
name|__atomic_add_dispatch
argument_list|(
operator|&
name|_M_use_count
argument_list|,
literal|1
argument_list|)
block|; }
name|void
name|_M_add_ref_lock
argument_list|()
block|;
name|void
name|_M_release
argument_list|()
comment|// nothrow
block|{
if|if
condition|(
name|__gnu_cxx
operator|::
name|__exchange_and_add_dispatch
argument_list|(
operator|&
name|_M_use_count
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|_M_dispose
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__GTHREADS
name|_GLIBCXX_READ_MEM_BARRIER
expr_stmt|;
name|_GLIBCXX_WRITE_MEM_BARRIER
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__gnu_cxx
operator|::
name|__exchange_and_add_dispatch
argument_list|(
operator|&
name|_M_weak_count
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|_M_destroy
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|_M_weak_add_ref
argument_list|()
comment|// nothrow
block|{
name|__gnu_cxx
operator|::
name|__atomic_add_dispatch
argument_list|(
operator|&
name|_M_weak_count
argument_list|,
literal|1
argument_list|)
block|; }
name|void
name|_M_weak_release
argument_list|()
comment|// nothrow
block|{
if|if
condition|(
name|__gnu_cxx
operator|::
name|__exchange_and_add_dispatch
argument_list|(
operator|&
name|_M_weak_count
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|__GTHREADS
name|_GLIBCXX_READ_MEM_BARRIER
expr_stmt|;
name|_GLIBCXX_WRITE_MEM_BARRIER
expr_stmt|;
endif|#
directive|endif
name|_M_destroy
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|}          long
name|_M_get_use_count
argument_list|()
end_macro

begin_expr_stmt
specifier|const
comment|// nothrow
block|{
return|return
name|_M_use_count
return|;
block|}
end_expr_stmt

begin_comment
comment|// XXX is this MT safe?
end_comment

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|_Sp_counted_base
argument_list|(
name|_Sp_counted_base
specifier|const
operator|&
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Sp_counted_base
modifier|&
name|operator
init|=
operator|(
name|_Sp_counted_base
specifier|const
operator|&
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Atomic_word
name|_M_use_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|// #shared
end_comment

begin_decl_stmt
name|_Atomic_word
name|_M_weak_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|// #weak + (#shared != 0)
end_comment

begin_expr_stmt
unit|};
name|template
operator|<
operator|>
specifier|inline
name|void
name|_Sp_counted_base
operator|<
name|_S_single
operator|>
operator|::
name|_M_add_ref_lock
argument_list|()
block|{
if|if
condition|(
name|__gnu_cxx
operator|::
name|__exchange_and_add_dispatch
argument_list|(
operator|&
name|_M_use_count
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_M_use_count
operator|=
literal|0
expr_stmt|;
name|__throw_bad_weak_ptr
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|__GTHREADS
end_ifdef

begin_expr_stmt
unit|template
operator|<
operator|>
specifier|inline
name|void
name|_Sp_counted_base
operator|<
name|_S_mutex
operator|>
operator|::
name|_M_add_ref_lock
argument_list|()
block|{
name|__gnu_cxx
operator|::
name|__scoped_lock
name|sentry
argument_list|(
operator|*
name|this
argument_list|)
block|;
if|if
condition|(
name|__gnu_cxx
operator|::
name|__exchange_and_add_dispatch
argument_list|(
operator|&
name|_M_use_count
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_M_use_count
operator|=
literal|0
expr_stmt|;
name|__throw_bad_weak_ptr
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|template
operator|<
operator|>
specifier|inline
name|void
name|_Sp_counted_base
operator|<
name|_S_atomic
operator|>
operator|::
name|_M_add_ref_lock
argument_list|()
block|{
comment|// Perform lock-free add-if-not-zero operation.
name|_Atomic_word
name|__count
block|;
do|do
block|{
name|__count
operator|=
name|_M_use_count
expr_stmt|;
if|if
condition|(
name|__count
operator|==
literal|0
condition|)
name|__throw_bad_weak_ptr
argument_list|()
expr_stmt|;
comment|// Replace the current counter value with the old value + 1, as
comment|// long as it's not changed meanwhile.
block|}
end_expr_stmt

begin_while
while|while
condition|(
operator|!
name|__sync_bool_compare_and_swap
argument_list|(
operator|&
name|_M_use_count
argument_list|,
name|__count
argument_list|,
name|__count
operator|+
literal|1
argument_list|)
condition|)
empty_stmt|;
end_while

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|_Ptr
operator|,
name|typename
name|_Deleter
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|class
name|_Sp_counted_base_impl
operator|:
name|public
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
block|{
name|public
operator|:
comment|/**        *  @brief           *  @pre     __d(__p) must not throw.        */
name|_Sp_counted_base_impl
argument_list|(
argument|_Ptr __p
argument_list|,
argument|_Deleter __d
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|__p
argument_list|)
block|,
name|_M_del
argument_list|(
argument|__d
argument_list|)
block|{ }
name|virtual
name|void
name|_M_dispose
argument_list|()
comment|// nothrow
block|{
name|_M_del
argument_list|(
name|_M_ptr
argument_list|)
block|; }
name|virtual
name|void
operator|*
name|_M_get_deleter
argument_list|(
argument|const std::type_info& __ti
argument_list|)
block|{
return|return
name|__ti
operator|==
name|typeid
argument_list|(
name|_Deleter
argument_list|)
operator|?
operator|&
name|_M_del
operator|:
literal|0
return|;
block|}
name|private
operator|:
name|_Sp_counted_base_impl
argument_list|(
specifier|const
name|_Sp_counted_base_impl
operator|&
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|_Sp_counted_base_impl
modifier|&
name|operator
init|=
operator|(
specifier|const
name|_Sp_counted_base_impl
operator|&
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Ptr
name|_M_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// copy constructor must not throw
end_comment

begin_decl_stmt
name|_Deleter
name|_M_del
decl_stmt|;
end_decl_stmt

begin_comment
comment|// copy constructor must not throw
end_comment

begin_expr_stmt
unit|};
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|=
name|__default_lock_policy
operator|>
name|class
name|__weak_count
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|=
name|__default_lock_policy
operator|>
name|class
name|__shared_count
block|{
name|public
operator|:
name|__shared_count
argument_list|()
operator|:
name|_M_pi
argument_list|(
literal|0
argument_list|)
comment|// nothrow
block|{ }
name|template
operator|<
name|typename
name|_Ptr
block|,
name|typename
name|_Deleter
operator|>
name|__shared_count
argument_list|(
argument|_Ptr __p
argument_list|,
argument|_Deleter __d
argument_list|)
operator|:
name|_M_pi
argument_list|(
literal|0
argument_list|)
block|{
name|try
block|{
name|_M_pi
operator|=
name|new
name|_Sp_counted_base_impl
operator|<
name|_Ptr
block|,
name|_Deleter
block|,
name|_Lp
operator|>
operator|(
name|__p
operator|,
name|__d
operator|)
block|; 	    }
name|catch
argument_list|(
argument|...
argument_list|)
block|{
name|__d
argument_list|(
name|__p
argument_list|)
block|;
comment|// Call _Deleter on __p.
name|__throw_exception_again
block|; 	    }
block|}
comment|// Special case for auto_ptr<_Tp> to provide the strong guarantee.
name|template
operator|<
name|typename
name|_Tp
operator|>
name|explicit
name|__shared_count
argument_list|(
name|std
operator|::
name|auto_ptr
operator|<
name|_Tp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_pi
argument_list|(
argument|new _Sp_counted_base_impl<_Tp*
argument_list|,
argument|_Sp_deleter<_Tp>
argument_list|,
argument|_Lp>(__r.get(), _Sp_deleter<_Tp>())
argument_list|)
block|{
name|__r
operator|.
name|release
argument_list|()
block|; }
comment|// Throw bad_weak_ptr when __r._M_get_use_count() == 0.
name|explicit
name|__shared_count
argument_list|(
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
block|;
operator|~
name|__shared_count
argument_list|()
comment|// nothrow
block|{
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_release
argument_list|()
expr_stmt|;
block|}
name|__shared_count
argument_list|(
specifier|const
name|__shared_count
operator|&
name|__r
argument_list|)
operator|:
name|_M_pi
argument_list|(
argument|__r._M_pi
argument_list|)
comment|// nothrow
block|{
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_add_ref_copy
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_decl_stmt
name|__shared_count
modifier|&
name|operator
init|=
operator|(
specifier|const
name|__shared_count
operator|&
name|__r
operator|)
comment|// nothrow
block|{
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
name|__tmp
operator|=
name|__r
operator|.
name|_M_pi
block|;
if|if
condition|(
name|__tmp
operator|!=
name|_M_pi
condition|)
block|{
if|if
condition|(
name|__tmp
operator|!=
literal|0
condition|)
name|__tmp
operator|->
name|_M_add_ref_copy
argument_list|()
expr_stmt|;
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_release
argument_list|()
expr_stmt|;
name|_M_pi
operator|=
name|__tmp
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_function
name|void
name|_M_swap
parameter_list|(
name|__shared_count
modifier|&
name|__r
parameter_list|)
comment|// nothrow
block|{
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
name|__tmp
operator|=
name|__r
operator|.
name|_M_pi
expr_stmt|;
name|__r
operator|.
name|_M_pi
operator|=
name|_M_pi
expr_stmt|;
name|_M_pi
operator|=
name|__tmp
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|long
name|_M_get_use_count
argument_list|()
specifier|const
comment|// nothrow
block|{
return|return
name|_M_pi
operator|!=
literal|0
operator|?
name|_M_pi
operator|->
name|_M_get_use_count
argument_list|()
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|_M_unique
argument_list|()
specifier|const
comment|// nothrow
block|{
return|return
name|this
operator|->
name|_M_get_use_count
argument_list|()
operator|==
literal|1
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__shared_count
operator|&
name|__a
operator|,
specifier|const
name|__shared_count
operator|&
name|__b
operator|)
block|{
return|return
name|__a
operator|.
name|_M_pi
operator|==
name|__b
operator|.
name|_M_pi
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__shared_count
operator|&
name|__a
operator|,
specifier|const
name|__shared_count
operator|&
name|__b
operator|)
block|{
return|return
name|std
operator|::
name|less
operator|<
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
operator|>
operator|(
operator|)
operator|(
name|__a
operator|.
name|_M_pi
operator|,
name|__b
operator|.
name|_M_pi
operator|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|_M_get_deleter
argument_list|(
specifier|const
name|std
operator|::
name|type_info
operator|&
name|__ti
argument_list|)
decl|const
block|{
return|return
name|_M_pi
condition|?
name|_M_pi
operator|->
name|_M_get_deleter
argument_list|(
name|__ti
argument_list|)
else|:
literal|0
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|friend
name|class
name|__weak_count
operator|<
name|_Lp
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
name|_M_pi
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|>
name|class
name|__weak_count
block|{
name|public
operator|:
name|__weak_count
argument_list|()
operator|:
name|_M_pi
argument_list|(
literal|0
argument_list|)
comment|// nothrow
block|{ }
name|__weak_count
argument_list|(
specifier|const
name|__shared_count
operator|<
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_pi
argument_list|(
argument|__r._M_pi
argument_list|)
comment|// nothrow
block|{
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_weak_add_ref
argument_list|()
expr_stmt|;
block|}
name|__weak_count
argument_list|(
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_pi
argument_list|(
argument|__r._M_pi
argument_list|)
comment|// nothrow
block|{
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_weak_add_ref
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
operator|~
name|__weak_count
argument_list|()
comment|// nothrow
block|{
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_weak_release
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__shared_count
operator|<
name|_Lp
operator|>
operator|&
name|__r
operator|)
comment|// nothrow
block|{
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
name|__tmp
operator|=
name|__r
operator|.
name|_M_pi
block|;
if|if
condition|(
name|__tmp
operator|!=
literal|0
condition|)
name|__tmp
operator|->
name|_M_weak_add_ref
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_weak_release
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|_M_pi
operator|=
name|__tmp
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_expr_stmt
unit|}              __weak_count
operator|<
name|_Lp
operator|>
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__r
operator|)
comment|// nothrow
block|{
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
name|__tmp
operator|=
name|__r
operator|.
name|_M_pi
block|;
if|if
condition|(
name|__tmp
operator|!=
literal|0
condition|)
name|__tmp
operator|->
name|_M_weak_add_ref
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_weak_release
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|_M_pi
operator|=
name|__tmp
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|*
name|this
return|;
end_return

begin_macro
unit|}        void
name|_M_swap
argument_list|(
argument|__weak_count<_Lp>& __r
argument_list|)
end_macro

begin_comment
comment|// nothrow
end_comment

begin_block
block|{
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
name|__tmp
operator|=
name|__r
operator|.
name|_M_pi
expr_stmt|;
name|__r
operator|.
name|_M_pi
operator|=
name|_M_pi
expr_stmt|;
name|_M_pi
operator|=
name|__tmp
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|long
name|_M_get_use_count
argument_list|()
specifier|const
comment|// nothrow
block|{
return|return
name|_M_pi
operator|!=
literal|0
operator|?
name|_M_pi
operator|->
name|_M_get_use_count
argument_list|()
operator|:
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__a
operator|,
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__b
operator|)
block|{
return|return
name|__a
operator|.
name|_M_pi
operator|==
name|__b
operator|.
name|_M_pi
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|friend
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__a
operator|,
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__b
operator|)
block|{
return|return
name|std
operator|::
name|less
operator|<
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
operator|>
operator|(
operator|)
operator|(
name|__a
operator|.
name|_M_pi
operator|,
name|__b
operator|.
name|_M_pi
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|friend
name|class
name|__shared_count
operator|<
name|_Lp
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_Sp_counted_base
operator|<
name|_Lp
operator|>
operator|*
name|_M_pi
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|>
specifier|inline
name|__shared_count
operator|<
name|_Lp
operator|>
operator|::
name|__shared_count
argument_list|(
specifier|const
name|__weak_count
operator|<
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_pi
argument_list|(
argument|__r._M_pi
argument_list|)
block|{
if|if
condition|(
name|_M_pi
operator|!=
literal|0
condition|)
name|_M_pi
operator|->
name|_M_add_ref_lock
argument_list|()
expr_stmt|;
else|else
name|__throw_bad_weak_ptr
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Forward declarations.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|=
name|__default_lock_policy
operator|>
name|class
name|__shared_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|=
name|__default_lock_policy
operator|>
name|class
name|__weak_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|=
name|__default_lock_policy
operator|>
name|class
name|__enable_shared_from_this
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|shared_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|weak_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|enable_shared_from_this
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Support for enable_shared_from_this.
end_comment

begin_comment
comment|// Friend of __enable_shared_from_this.
end_comment

begin_expr_stmt
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|,
name|typename
name|_Tp1
operator|,
name|typename
name|_Tp2
operator|>
name|void
name|__enable_shared_from_this_helper
argument_list|(
specifier|const
name|__shared_count
operator|<
name|_Lp
operator|>
operator|&
argument_list|,
specifier|const
name|__enable_shared_from_this
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|*
argument_list|,
specifier|const
name|_Tp2
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Friend of enable_shared_from_this.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|typename
name|_Tp2
operator|>
name|void
name|__enable_shared_from_this_helper
argument_list|(
specifier|const
name|__shared_count
operator|<
operator|>
operator|&
argument_list|,
specifier|const
name|enable_shared_from_this
operator|<
name|_Tp1
operator|>
operator|*
argument_list|,
specifier|const
name|_Tp2
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|_Lock_policy
name|_Lp
operator|>
specifier|inline
name|void
name|__enable_shared_from_this_helper
argument_list|(
argument|const __shared_count<_Lp>&
argument_list|,
argument|...
argument_list|)
block|{ }
expr|struct
name|__static_cast_tag
block|{ }
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|__const_cast_tag
block|{ }
struct|;
end_struct

begin_struct
struct|struct
name|__dynamic_cast_tag
block|{ }
struct|;
end_struct

begin_comment
comment|/**    *  @class shared_ptr<tr1/memory>    *    *  A smart pointer with reference-counted copy semantics.    *  The object pointed to is deleted when the last shared_ptr pointing to    *  it is destroyed or reset.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|class
name|__shared_ptr
block|{
name|public
operator|:
typedef|typedef
name|_Tp
name|element_type
typedef|;
comment|/** @brief  Construct an empty %__shared_ptr.        *  @post   use_count()==0&& get()==0        */
name|__shared_ptr
argument_list|()
operator|:
name|_M_ptr
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_refcount
argument_list|()
comment|// never throws
block|{ }
comment|/** @brief  Construct a %__shared_ptr that owns the pointer @a __p.        *  @param  __p  A pointer that is convertible to element_type*.        *  @post   use_count() == 1&& get() == __p        *  @throw  std::bad_alloc, in which case @c delete @a __p is called.        */
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|explicit
name|__shared_ptr
argument_list|(
name|_Tp1
operator|*
name|__p
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|__p
argument_list|)
operator|,
name|_M_refcount
argument_list|(
argument|__p
argument_list|,
argument|_Sp_deleter<_Tp1>()
argument_list|)
block|{
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp1*
argument_list|,
argument|_Tp*>
argument_list|)
comment|// __glibcxx_function_requires(_CompleteConcept<_Tp1*>)
name|__enable_shared_from_this_helper
argument_list|(
name|_M_refcount
argument_list|,
name|__p
argument_list|,
name|__p
argument_list|)
block|; 	}
comment|//
comment|// Requirements: _Deleter' copy constructor and destructor must not throw
comment|//
comment|// __shared_ptr will release __p by calling __d(__p)
comment|//
comment|/** @brief  Construct a %__shared_ptr that owns the pointer @a __p        *          and the deleter @a __d.        *  @param  __p  A pointer.        *  @param  __d  A deleter.        *  @post   use_count() == 1&& get() == __p        *  @throw  std::bad_alloc, in which case @a __d(__p) is called.        */
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|typename
name|_Deleter
operator|>
name|__shared_ptr
argument_list|(
argument|_Tp1* __p
argument_list|,
argument|_Deleter __d
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|__p
argument_list|)
operator|,
name|_M_refcount
argument_list|(
argument|__p
argument_list|,
argument|__d
argument_list|)
block|{
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp1*
argument_list|,
argument|_Tp*>
argument_list|)
comment|// TODO requires _Deleter CopyConstructible and __d(__p) well-formed
name|__enable_shared_from_this_helper
argument_list|(
name|_M_refcount
argument_list|,
name|__p
argument_list|,
name|__p
argument_list|)
block|; 	}
comment|//  generated copy constructor, assignment, destructor are fine.
comment|/** @brief  If @a __r is empty, constructs an empty %__shared_ptr;        *          otherwise construct a %__shared_ptr that shares ownership        *          with @a __r.        *  @param  __r  A %__shared_ptr.        *  @post   get() == __r.get()&& use_count() == __r.use_count()        *  @throw  std::bad_alloc, in which case         */
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__shared_ptr
argument_list|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|__r
operator|.
name|_M_ptr
argument_list|)
operator|,
name|_M_refcount
argument_list|(
argument|__r._M_refcount
argument_list|)
comment|// never throws
block|{
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp1*
argument_list|,
argument|_Tp*>
argument_list|)
block|}
comment|/** @brief  Constructs a %__shared_ptr that shares ownership with @a __r        *          and stores a copy of the pointer stored in @a __r.        *  @param  __r  A weak_ptr.        *  @post   use_count() == __r.use_count()        *  @throw  bad_weak_ptr when __r.expired(),        *          in which case the constructor has no effect.        */
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|explicit
name|__shared_ptr
argument_list|(
specifier|const
name|__weak_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_refcount
argument_list|(
argument|__r._M_refcount
argument_list|)
comment|// may throw
block|{
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp1*
argument_list|,
argument|_Tp*>
argument_list|)
comment|// It is now safe to copy __r._M_ptr, as _M_refcount(__r._M_refcount)
comment|// did not throw.
name|_M_ptr
operator|=
name|__r
operator|.
name|_M_ptr
block|; 	}
comment|/**        * @post use_count() == 1 and __r.get() == 0        */
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|explicit
name|__shared_ptr
argument_list|(
name|std
operator|::
name|auto_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|__r
operator|.
name|get
argument_list|()
argument_list|)
operator|,
name|_M_refcount
argument_list|()
block|{
comment|// TODO requires __r.release() convertible to _Tp*, _Tp1 is complete,
comment|// delete __r.release() well-formed
name|_Tp1
operator|*
name|__tmp
operator|=
name|__r
operator|.
name|get
argument_list|()
block|;
name|_M_refcount
operator|=
name|__shared_count
operator|<
name|_Lp
operator|>
operator|(
name|__r
operator|)
block|;
name|__enable_shared_from_this_helper
argument_list|(
name|_M_refcount
argument_list|,
name|__tmp
argument_list|,
name|__tmp
argument_list|)
block|; 	}
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__shared_ptr
argument_list|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|&
name|__r
argument_list|,
name|__static_cast_tag
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|static_cast
operator|<
name|element_type
operator|*
operator|>
operator|(
name|__r
operator|.
name|_M_ptr
operator|)
argument_list|)
operator|,
name|_M_refcount
argument_list|(
argument|__r._M_refcount
argument_list|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__shared_ptr
argument_list|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|&
name|__r
argument_list|,
name|__const_cast_tag
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|const_cast
operator|<
name|element_type
operator|*
operator|>
operator|(
name|__r
operator|.
name|_M_ptr
operator|)
argument_list|)
operator|,
name|_M_refcount
argument_list|(
argument|__r._M_refcount
argument_list|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__shared_ptr
argument_list|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|&
name|__r
argument_list|,
name|__dynamic_cast_tag
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|dynamic_cast
operator|<
name|element_type
operator|*
operator|>
operator|(
name|__r
operator|.
name|_M_ptr
operator|)
argument_list|)
operator|,
name|_M_refcount
argument_list|(
argument|__r._M_refcount
argument_list|)
block|{
if|if
condition|(
name|_M_ptr
operator|==
literal|0
condition|)
comment|// need to allocate new counter -- the cast failed
name|_M_refcount
operator|=
name|__shared_count
operator|<
name|_Lp
operator|>
operator|(
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__shared_ptr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
operator|,
name|_Lp
operator|>
operator|&
name|__r
operator|)
comment|// never throws
block|{
name|_M_ptr
operator|=
name|__r
operator|.
name|_M_ptr
block|;
name|_M_refcount
operator|=
name|__r
operator|.
name|_M_refcount
block|;
comment|// __shared_count::op= doesn't throw
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__shared_ptr
operator|&
name|operator
operator|=
operator|(
name|std
operator|::
name|auto_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
operator|)
block|{
name|__shared_ptr
argument_list|(
name|__r
argument_list|)
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_function
name|void
name|reset
parameter_list|()
comment|// never throws
block|{
name|__shared_ptr
argument_list|()
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|void
name|reset
argument_list|(
argument|_Tp1* __p
argument_list|)
comment|// _Tp1 must be complete.
block|{
comment|// Catch self-reset errors.
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|__p
operator|==
literal|0
operator|||
name|__p
operator|!=
name|_M_ptr
argument_list|)
block|;
name|__shared_ptr
argument_list|(
name|__p
argument_list|)
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
block|; 	}
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|typename
name|_Deleter
operator|>
name|void
name|reset
argument_list|(
argument|_Tp1* __p
argument_list|,
argument|_Deleter __d
argument_list|)
block|{
name|__shared_ptr
argument_list|(
name|__p
argument_list|,
name|__d
argument_list|)
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
block|; }
comment|// Allow class instantiation when _Tp is [cv-qual] void.
name|typename
name|add_reference
operator|<
name|_Tp
operator|>
operator|::
name|type
name|operator
operator|*
operator|(
operator|)
specifier|const
comment|// never throws
block|{
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|_M_ptr
operator|!=
literal|0
argument_list|)
block|;
return|return
operator|*
name|_M_ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Tp
operator|*
name|operator
operator|->
expr|(
end_expr_stmt

begin_expr_stmt
unit|)
specifier|const
comment|// never throws
block|{
name|_GLIBCXX_DEBUG_ASSERT
argument_list|(
name|_M_ptr
operator|!=
literal|0
argument_list|)
block|;
return|return
name|_M_ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|_Tp
operator|*
name|get
argument_list|()
specifier|const
comment|// never throws
block|{
return|return
name|_M_ptr
return|;
block|}
end_expr_stmt

begin_comment
comment|// Implicit conversion to "bool"
end_comment

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|_Tp
operator|*
name|__shared_ptr
operator|::
operator|*
name|__unspecified_bool_type
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|operator
name|__unspecified_bool_type
argument_list|()
specifier|const
comment|// never throws
block|{
return|return
name|_M_ptr
operator|==
literal|0
operator|?
literal|0
operator|:
operator|&
name|__shared_ptr
operator|::
name|_M_ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|unique
argument_list|()
specifier|const
comment|// never throws
block|{
return|return
name|_M_refcount
operator|.
name|_M_unique
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|long
name|use_count
argument_list|()
specifier|const
comment|// never throws
block|{
return|return
name|_M_refcount
operator|.
name|_M_get_use_count
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|swap
argument_list|(
name|__shared_ptr
operator|<
name|_Tp
argument_list|,
name|_Lp
operator|>
operator|&
name|__other
argument_list|)
comment|// never throws
block|{
name|std
operator|::
name|swap
argument_list|(
name|_M_ptr
argument_list|,
name|__other
operator|.
name|_M_ptr
argument_list|)
expr_stmt|;
name|_M_refcount
operator|.
name|_M_swap
argument_list|(
name|__other
operator|.
name|_M_refcount
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|void
modifier|*
name|_M_get_deleter
argument_list|(
specifier|const
name|std
operator|::
name|type_info
operator|&
name|__ti
argument_list|)
decl|const
block|{
return|return
name|_M_refcount
operator|.
name|_M_get_deleter
argument_list|(
name|__ti
argument_list|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp1
operator|>
name|bool
name|_M_less
argument_list|(
argument|const __shared_ptr<_Tp1
argument_list|,
argument|_Lp1>& __rhs
argument_list|)
specifier|const
block|{
return|return
name|_M_refcount
operator|<
name|__rhs
operator|.
name|_M_refcount
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp1
operator|>
name|friend
name|class
name|__shared_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp1
operator|>
name|friend
name|class
name|__weak_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Del
operator|,
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp1
operator|>
name|friend
name|_Del
operator|*
name|get_deleter
argument_list|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp1
operator|>
operator|&
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Friends injected into enclosing namespace and found by ADL:
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|friend
specifier|inline
name|bool
name|operator
operator|==
operator|(
specifier|const
name|__shared_ptr
operator|&
name|__a
operator|,
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
operator|,
name|_Lp
operator|>
operator|&
name|__b
operator|)
block|{
return|return
name|__a
operator|.
name|get
argument_list|()
operator|==
name|__b
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|friend
specifier|inline
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|__shared_ptr
operator|&
name|__a
operator|,
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
operator|,
name|_Lp
operator|>
operator|&
name|__b
operator|)
block|{
return|return
name|__a
operator|.
name|get
argument_list|()
operator|!=
name|__b
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|friend
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__shared_ptr
operator|&
name|__a
operator|,
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
operator|,
name|_Lp
operator|>
operator|&
name|__b
operator|)
block|{
return|return
name|__a
operator|.
name|_M_less
argument_list|(
name|__b
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|_Tp
modifier|*
name|_M_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Contained pointer.
end_comment

begin_expr_stmt
name|__shared_count
operator|<
name|_Lp
operator|>
name|_M_refcount
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Reference counter.
end_comment

begin_comment
unit|};
comment|// 2.2.3.8 shared_ptr specialized algorithms.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|__shared_ptr<_Tp
argument_list|,
argument|_Lp>& __a
argument_list|,
argument|__shared_ptr<_Tp
argument_list|,
argument|_Lp>& __b
argument_list|)
block|{
name|__a
operator|.
name|swap
argument_list|(
name|__b
argument_list|)
block|; }
comment|// 2.2.3.9 shared_ptr casts
comment|/** @warning The seemingly equivalent    *<code>shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))</code>    *           will eventually result in undefined behaviour,    *           attempting to delete the same object twice.    */
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
name|static_pointer_cast
argument_list|(
argument|const __shared_ptr<_Tp1
argument_list|,
argument|_Lp>& __r
argument_list|)
block|{
return|return
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
operator|(
name|__r
operator|,
name|__static_cast_tag
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/** @warning The seemingly equivalent    *<code>shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))</code>    *           will eventually result in undefined behaviour,    *           attempting to delete the same object twice.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
name|const_pointer_cast
argument_list|(
argument|const __shared_ptr<_Tp1
argument_list|,
argument|_Lp>& __r
argument_list|)
block|{
return|return
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
operator|(
name|__r
operator|,
name|__const_cast_tag
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/** @warning The seemingly equivalent    *<code>shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))</code>    *           will eventually result in undefined behaviour,    *           attempting to delete the same object twice.    */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
name|dynamic_pointer_cast
argument_list|(
argument|const __shared_ptr<_Tp1
argument_list|,
argument|_Lp>& __r
argument_list|)
block|{
return|return
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
operator|(
name|__r
operator|,
name|__dynamic_cast_tag
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// 2.2.3.7 shared_ptr I/O
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Ch
operator|,
name|typename
name|_Tr
operator|,
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|std
operator|::
name|basic_ostream
operator|<
name|_Ch
operator|,
name|_Tr
operator|>
operator|&
name|operator
operator|<<
operator|(
name|std
operator|::
name|basic_ostream
operator|<
name|_Ch
operator|,
name|_Tr
operator|>
operator|&
name|__os
operator|,
specifier|const
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
operator|&
name|__p
operator|)
block|{
name|__os
operator|<<
name|__p
operator|.
name|get
argument_list|()
block|;
return|return
name|__os
return|;
block|}
end_expr_stmt

begin_comment
comment|// 2.2.3.10 shared_ptr get_deleter (experimental)
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Del
operator|,
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|>
specifier|inline
name|_Del
operator|*
name|get_deleter
argument_list|(
argument|const __shared_ptr<_Tp
argument_list|,
argument|_Lp>& __p
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|_Del
operator|*
operator|>
operator|(
name|__p
operator|.
name|_M_get_deleter
argument_list|(
name|typeid
argument_list|(
name|_Del
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|class
name|__weak_ptr
block|{
name|public
operator|:
typedef|typedef
name|_Tp
name|element_type
typedef|;
name|__weak_ptr
argument_list|()
operator|:
name|_M_ptr
argument_list|(
literal|0
argument_list|)
operator|,
name|_M_refcount
argument_list|()
comment|// never throws
block|{ }
comment|// Generated copy constructor, assignment, destructor are fine.
comment|// The "obvious" converting constructor implementation:
comment|//
comment|//  template<typename _Tp1>
comment|//    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
comment|//    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws
comment|//    { }
comment|//
comment|// has a serious problem.
comment|//
comment|//  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)
comment|//  conversion may require access to *__r._M_ptr (virtual inheritance).
comment|//
comment|// It is not possible to avoid spurious access violations since
comment|// in multithreaded programs __r._M_ptr may be invalidated at any point.
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__weak_ptr
argument_list|(
specifier|const
name|__weak_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_refcount
argument_list|(
argument|__r._M_refcount
argument_list|)
comment|// never throws
block|{
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp1*
argument_list|,
argument|_Tp*>
argument_list|)
name|_M_ptr
operator|=
name|__r
operator|.
name|lock
argument_list|()
operator|.
name|get
argument_list|()
block|; 	}
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__weak_ptr
argument_list|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
argument_list|,
name|_Lp
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|_M_ptr
argument_list|(
name|__r
operator|.
name|_M_ptr
argument_list|)
operator|,
name|_M_refcount
argument_list|(
argument|__r._M_refcount
argument_list|)
comment|// never throws
block|{
name|__glibcxx_function_requires
argument_list|(
argument|_ConvertibleConcept<_Tp1*
argument_list|,
argument|_Tp*>
argument_list|)
block|}
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__weak_ptr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__weak_ptr
operator|<
name|_Tp1
operator|,
name|_Lp
operator|>
operator|&
name|__r
operator|)
comment|// never throws
block|{
name|_M_ptr
operator|=
name|__r
operator|.
name|lock
argument_list|()
operator|.
name|get
argument_list|()
block|;
name|_M_refcount
operator|=
name|__r
operator|.
name|_M_refcount
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|__weak_ptr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__shared_ptr
operator|<
name|_Tp1
operator|,
name|_Lp
operator|>
operator|&
name|__r
operator|)
comment|// never throws
block|{
name|_M_ptr
operator|=
name|__r
operator|.
name|_M_ptr
block|;
name|_M_refcount
operator|=
name|__r
operator|.
name|_M_refcount
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
name|lock
argument_list|()
specifier|const
comment|// never throws
block|{
ifdef|#
directive|ifdef
name|__GTHREADS
comment|// Optimization: avoid throw overhead.
if|if
condition|(
name|expired
argument_list|()
condition|)
return|return
name|__shared_ptr
operator|<
name|element_type
operator|,
name|_Lp
operator|>
operator|(
operator|)
return|;
name|try
block|{
return|return
name|__shared_ptr
operator|<
name|element_type
operator|,
name|_Lp
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
name|catch
argument_list|(
argument|const bad_weak_ptr&
argument_list|)
block|{
comment|// Q: How can we get here?
comment|// A: Another thread may have invalidated r after the
comment|//    use_count test above.
return|return
name|__shared_ptr
operator|<
name|element_type
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|// Optimization: avoid try/catch overhead when single threaded.
end_comment

begin_return
return|return
name|expired
argument_list|()
condition|?
name|__shared_ptr
operator|<
name|element_type
operator|,
name|_Lp
operator|>
operator|(
operator|)
operator|:
name|__shared_ptr
operator|<
name|element_type
operator|,
name|_Lp
operator|>
operator|(
operator|*
name|this
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|// XXX MT
end_comment

begin_macro
unit|long
name|use_count
argument_list|()
end_macro

begin_expr_stmt
specifier|const
comment|// never throws
block|{
return|return
name|_M_refcount
operator|.
name|_M_get_use_count
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|expired
argument_list|()
specifier|const
comment|// never throws
block|{
return|return
name|_M_refcount
operator|.
name|_M_get_use_count
argument_list|()
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_function
name|void
name|reset
parameter_list|()
comment|// never throws
block|{
name|__weak_ptr
argument_list|()
operator|.
name|swap
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swap
parameter_list|(
name|__weak_ptr
modifier|&
name|__s
parameter_list|)
comment|// never throws
block|{
name|std
operator|::
name|swap
argument_list|(
name|_M_ptr
argument_list|,
name|__s
operator|.
name|_M_ptr
argument_list|)
expr_stmt|;
name|_M_refcount
operator|.
name|_M_swap
argument_list|(
name|__s
operator|.
name|_M_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_comment
comment|// Used by __enable_shared_from_this.
end_comment

begin_decl_stmt
name|void
name|_M_assign
argument_list|(
name|_Tp
operator|*
name|__ptr
argument_list|,
specifier|const
name|__shared_count
operator|<
name|_Lp
operator|>
operator|&
name|__refcount
argument_list|)
block|{
name|_M_ptr
operator|=
name|__ptr
expr_stmt|;
name|_M_refcount
operator|=
name|__refcount
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|bool
name|_M_less
argument_list|(
argument|const __weak_ptr<_Tp1
argument_list|,
argument|_Lp>& __rhs
argument_list|)
specifier|const
block|{
return|return
name|_M_refcount
operator|<
name|__rhs
operator|.
name|_M_refcount
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp1
operator|>
name|friend
name|class
name|__shared_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|,
name|_Lock_policy
name|_Lp1
operator|>
name|friend
name|class
name|__weak_ptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|__enable_shared_from_this
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|friend
name|class
name|enable_shared_from_this
operator|<
name|_Tp
operator|>
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Friend injected into namespace and found by ADL.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|friend
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|__weak_ptr
operator|&
name|__lhs
operator|,
specifier|const
name|__weak_ptr
operator|<
name|_Tp1
operator|,
name|_Lp
operator|>
operator|&
name|__rhs
operator|)
block|{
return|return
name|__lhs
operator|.
name|_M_less
argument_list|(
name|__rhs
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|_Tp
modifier|*
name|_M_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Contained pointer.
end_comment

begin_expr_stmt
name|__weak_count
operator|<
name|_Lp
operator|>
name|_M_refcount
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Reference counter.
end_comment

begin_comment
unit|};
comment|// 2.2.4.7 weak_ptr specialized algorithms.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|>
specifier|inline
name|void
name|swap
argument_list|(
argument|__weak_ptr<_Tp
argument_list|,
argument|_Lp>& __a
argument_list|,
argument|__weak_ptr<_Tp
argument_list|,
argument|_Lp>& __b
argument_list|)
block|{
name|__a
operator|.
name|swap
argument_list|(
name|__b
argument_list|)
block|; }
name|template
operator|<
name|typename
name|_Tp
operator|,
name|_Lock_policy
name|_Lp
operator|>
name|class
name|__enable_shared_from_this
block|{
name|protected
operator|:
name|__enable_shared_from_this
argument_list|()
block|{ }
name|__enable_shared_from_this
argument_list|(
argument|const __enable_shared_from_this&
argument_list|)
block|{ }
name|__enable_shared_from_this
operator|&
name|operator
operator|=
operator|(
specifier|const
name|__enable_shared_from_this
operator|&
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
operator|~
name|__enable_shared_from_this
argument_list|()
block|{ }
name|public
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
name|shared_from_this
argument_list|()
block|{
return|return
name|__shared_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
operator|(
name|this
operator|->
name|_M_weak_this
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|__shared_ptr
operator|<
specifier|const
name|_Tp
operator|,
name|_Lp
operator|>
name|shared_from_this
argument_list|()
specifier|const
block|{
return|return
name|__shared_ptr
operator|<
specifier|const
name|_Tp
operator|,
name|_Lp
operator|>
operator|(
name|this
operator|->
name|_M_weak_this
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|void
name|_M_weak_assign
argument_list|(
argument|_Tp1* __p
argument_list|,
argument|const __shared_count<_Lp>& __n
argument_list|)
specifier|const
block|{
name|_M_weak_this
operator|.
name|_M_assign
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|)
block|; }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|friend
name|void
name|__enable_shared_from_this_helper
argument_list|(
argument|const __shared_count<_Lp>& __pn
argument_list|,
argument|const __enable_shared_from_this* __pe
argument_list|,
argument|const _Tp1* __px
argument_list|)
block|{
if|if
condition|(
name|__pe
operator|!=
literal|0
condition|)
name|__pe
operator|->
name|_M_weak_assign
argument_list|(
name|const_cast
operator|<
name|_Tp1
operator|*
operator|>
operator|(
name|__px
operator|)
argument_list|,
name|__pn
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|mutable
name|__weak_ptr
operator|<
name|_Tp
operator|,
name|_Lp
operator|>
name|_M_weak_this
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|// The actual TR1 shared_ptr, with forwarding constructors and
end_comment

begin_comment
comment|// assignment operators.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|shared_ptr
operator|:
name|public
name|__shared_ptr
operator|<
name|_Tp
operator|>
block|{
name|public
operator|:
name|shared_ptr
argument_list|()
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|explicit
name|shared_ptr
argument_list|(
name|_Tp1
operator|*
name|__p
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__p
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
block|,
name|typename
name|_Deleter
operator|>
name|shared_ptr
argument_list|(
argument|_Tp1* __p
argument_list|,
argument|_Deleter __d
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__p
operator|,
name|__d
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|shared_ptr
argument_list|(
specifier|const
name|shared_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|explicit
name|shared_ptr
argument_list|(
specifier|const
name|weak_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|explicit
name|shared_ptr
argument_list|(
name|std
operator|::
name|auto_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|shared_ptr
argument_list|(
specifier|const
name|shared_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|,
name|__static_cast_tag
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|,
name|__static_cast_tag
argument_list|()
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|shared_ptr
argument_list|(
specifier|const
name|shared_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|,
name|__const_cast_tag
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|,
name|__const_cast_tag
argument_list|()
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|shared_ptr
argument_list|(
specifier|const
name|shared_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|,
name|__dynamic_cast_tag
argument_list|)
operator|:
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|,
name|__dynamic_cast_tag
argument_list|()
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|shared_ptr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|shared_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
operator|)
comment|// never throws
block|{
name|this
operator|->
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|::
name|operator
operator|=
operator|(
name|__r
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|shared_ptr
operator|&
name|operator
operator|=
operator|(
name|std
operator|::
name|auto_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
operator|)
block|{
name|this
operator|->
name|__shared_ptr
operator|<
name|_Tp
operator|>
operator|::
name|operator
operator|=
operator|(
name|__r
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|>
name|shared_ptr
operator|<
name|_Tp
operator|>
name|static_pointer_cast
argument_list|(
argument|const shared_ptr<_Tp1>& __r
argument_list|)
block|{
return|return
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|,
name|__static_cast_tag
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|>
name|shared_ptr
operator|<
name|_Tp
operator|>
name|const_pointer_cast
argument_list|(
argument|const shared_ptr<_Tp1>& __r
argument_list|)
block|{
return|return
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|,
name|__const_cast_tag
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|,
name|typename
name|_Tp1
operator|>
name|shared_ptr
operator|<
name|_Tp
operator|>
name|dynamic_pointer_cast
argument_list|(
argument|const shared_ptr<_Tp1>& __r
argument_list|)
block|{
return|return
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|,
name|__dynamic_cast_tag
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// The actual TR1 weak_ptr, with forwarding constructors and
end_comment

begin_comment
comment|// assignment operators.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|weak_ptr
operator|:
name|public
name|__weak_ptr
operator|<
name|_Tp
operator|>
block|{
name|public
operator|:
name|weak_ptr
argument_list|()
operator|:
name|__weak_ptr
operator|<
name|_Tp
operator|>
operator|(
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|weak_ptr
argument_list|(
specifier|const
name|weak_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|__weak_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|weak_ptr
argument_list|(
specifier|const
name|shared_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
argument_list|)
operator|:
name|__weak_ptr
operator|<
name|_Tp
operator|>
operator|(
name|__r
operator|)
block|{ }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|weak_ptr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|weak_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
operator|)
comment|// never throws
block|{
name|this
operator|->
name|__weak_ptr
operator|<
name|_Tp
operator|>
operator|::
name|operator
operator|=
operator|(
name|__r
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|weak_ptr
operator|&
name|operator
operator|=
operator|(
specifier|const
name|shared_ptr
operator|<
name|_Tp1
operator|>
operator|&
name|__r
operator|)
comment|// never throws
block|{
name|this
operator|->
name|__weak_ptr
operator|<
name|_Tp
operator|>
operator|::
name|operator
operator|=
operator|(
name|__r
operator|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|shared_ptr
operator|<
name|_Tp
operator|>
name|lock
argument_list|()
specifier|const
comment|// never throws
block|{
ifdef|#
directive|ifdef
name|__GTHREADS
if|if
condition|(
name|this
operator|->
name|expired
argument_list|()
condition|)
return|return
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
operator|)
return|;
name|try
block|{
return|return
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
name|catch
argument_list|(
argument|const bad_weak_ptr&
argument_list|)
block|{
return|return
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_return
return|return
name|this
operator|->
name|expired
argument_list|()
condition|?
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
operator|)
else|:
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
operator|*
name|this
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_empty_stmt
unit|}     }
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp
operator|>
name|class
name|enable_shared_from_this
block|{
name|protected
operator|:
name|enable_shared_from_this
argument_list|()
block|{ }
name|enable_shared_from_this
argument_list|(
argument|const enable_shared_from_this&
argument_list|)
block|{ }
name|enable_shared_from_this
operator|&
name|operator
operator|=
operator|(
specifier|const
name|enable_shared_from_this
operator|&
operator|)
block|{
return|return
operator|*
name|this
return|;
block|}
operator|~
name|enable_shared_from_this
argument_list|()
block|{ }
name|public
operator|:
name|shared_ptr
operator|<
name|_Tp
operator|>
name|shared_from_this
argument_list|()
block|{
return|return
name|shared_ptr
operator|<
name|_Tp
operator|>
operator|(
name|this
operator|->
name|_M_weak_this
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|shared_ptr
operator|<
specifier|const
name|_Tp
operator|>
name|shared_from_this
argument_list|()
specifier|const
block|{
return|return
name|shared_ptr
operator|<
specifier|const
name|_Tp
operator|>
operator|(
name|this
operator|->
name|_M_weak_this
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|void
name|_M_weak_assign
argument_list|(
argument|_Tp1* __p
argument_list|,
argument|const __shared_count<>& __n
argument_list|)
specifier|const
block|{
name|_M_weak_this
operator|.
name|_M_assign
argument_list|(
name|__p
argument_list|,
name|__n
argument_list|)
block|; }
name|template
operator|<
name|typename
name|_Tp1
operator|>
name|friend
name|void
name|__enable_shared_from_this_helper
argument_list|(
argument|const __shared_count<>& __pn
argument_list|,
argument|const enable_shared_from_this* __pe
argument_list|,
argument|const _Tp1* __px
argument_list|)
block|{
if|if
condition|(
name|__pe
operator|!=
literal|0
condition|)
name|__pe
operator|->
name|_M_weak_assign
argument_list|(
name|const_cast
operator|<
name|_Tp1
operator|*
operator|>
operator|(
name|__px
operator|)
argument_list|,
name|__pn
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|mutable
name|weak_ptr
operator|<
name|_Tp
operator|>
name|_M_weak_this
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|_GLIBCXX_END_NAMESPACE
end_expr_stmt

begin_comment
unit|}
comment|// namespace std
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

