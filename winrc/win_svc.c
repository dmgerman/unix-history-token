begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * winrc/win_svc.c - windows services API implementation for unbound  *  * Copyright (c) 2009, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains functions to integrate with the windows services API.  * This means it handles the commandline switches to install and remove  * the service (via CreateService and DeleteService), it handles  * the ServiceMain() main service entry point when started as a service,  * and it handles the Handler[_ex]() to process requests to the service  * (such as start and stop and status).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"winrc/win_svc.h"
end_include

begin_include
include|#
directive|include
file|"winrc/w_inst.h"
end_include

begin_include
include|#
directive|include
file|"daemon/daemon.h"
end_include

begin_include
include|#
directive|include
file|"daemon/worker.h"
end_include

begin_include
include|#
directive|include
file|"daemon/remote.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/netevent.h"
end_include

begin_include
include|#
directive|include
file|"util/winsock_event.h"
end_include

begin_comment
comment|/** global service status */
end_comment

begin_decl_stmt
specifier|static
name|SERVICE_STATUS
name|service_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** global service status handle */
end_comment

begin_decl_stmt
specifier|static
name|SERVICE_STATUS_HANDLE
name|service_status_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** global service stop event */
end_comment

begin_decl_stmt
specifier|static
name|WSAEVENT
name|service_stop_event
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** event struct for stop callbacks */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|event
name|service_stop_ev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** if stop even means shutdown or restart */
end_comment

begin_decl_stmt
specifier|static
name|int
name|service_stop_shutdown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** config file to open. global communication to service_main() */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|service_cfgfile
init|=
name|CONFIGFILE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** commandline verbosity. global communication to service_main() */
end_comment

begin_decl_stmt
specifier|static
name|int
name|service_cmdline_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** the cron callback */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|comm_timer
modifier|*
name|service_cron
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** the cron thread */
end_comment

begin_decl_stmt
specifier|static
name|ub_thread_t
name|cron_thread
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** if cron has already done its quick check */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cron_was_quick
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Report current service status to service control manager  * @param state: current state  * @param exitcode: error code (when stopped)  * @param wait: pending operation estimated time in milliseconds.  */
end_comment

begin_function
specifier|static
name|void
name|report_status
parameter_list|(
name|DWORD
name|state
parameter_list|,
name|DWORD
name|exitcode
parameter_list|,
name|DWORD
name|wait
parameter_list|)
block|{
specifier|static
name|DWORD
name|checkpoint
init|=
literal|1
decl_stmt|;
name|service_status
operator|.
name|dwCurrentState
operator|=
name|state
expr_stmt|;
name|service_status
operator|.
name|dwWin32ExitCode
operator|=
name|exitcode
expr_stmt|;
name|service_status
operator|.
name|dwWaitHint
operator|=
name|wait
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SERVICE_START_PENDING
condition|)
name|service_status
operator|.
name|dwControlsAccepted
operator|=
literal|0
expr_stmt|;
else|else
name|service_status
operator|.
name|dwControlsAccepted
operator|=
name|SERVICE_ACCEPT_STOP
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SERVICE_RUNNING
operator|||
name|state
operator|==
name|SERVICE_STOPPED
condition|)
name|service_status
operator|.
name|dwCheckPoint
operator|=
literal|0
expr_stmt|;
else|else
name|service_status
operator|.
name|dwCheckPoint
operator|=
name|checkpoint
operator|++
expr_stmt|;
name|SetServiceStatus
argument_list|(
name|service_status_handle
argument_list|,
operator|&
name|service_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Service control handler. Called by serviceControlManager when a control  * code is sent to the service (with ControlService).  * @param ctrl: control code  */
end_comment

begin_function
specifier|static
name|void
name|hdlr
parameter_list|(
name|DWORD
name|ctrl
parameter_list|)
block|{
if|if
condition|(
name|ctrl
operator|==
name|SERVICE_CONTROL_STOP
condition|)
block|{
name|report_status
argument_list|(
name|SERVICE_STOP_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|service_stop_shutdown
operator|=
literal|1
expr_stmt|;
comment|/* send signal to stop */
if|if
condition|(
operator|!
name|WSASetEvent
argument_list|(
name|service_stop_event
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"Could not WSASetEvent: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* ctrl == SERVICE_CONTROL_INTERROGATE or whatever */
comment|/* update status */
name|report_status
argument_list|(
name|service_status
operator|.
name|dwCurrentState
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * report event to system event log  * For use during startup and shutdown.  * @param str: the error  */
end_comment

begin_function
specifier|static
name|void
name|reportev
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
name|b
index|[
literal|256
index|]
decl_stmt|;
name|char
name|e
index|[
literal|256
index|]
decl_stmt|;
name|HANDLE
modifier|*
name|s
decl_stmt|;
name|LPCTSTR
name|msg
init|=
name|b
decl_stmt|;
comment|/* print quickly to keep GetLastError value */
name|wsvc_err2str
argument_list|(
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|e
argument_list|)
argument_list|,
name|str
argument_list|,
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
literal|"%s: %s"
argument_list|,
name|SERVICE_NAME
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|s
operator|=
name|RegisterEventSource
argument_list|(
name|NULL
argument_list|,
name|SERVICE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return;
name|ReportEvent
argument_list|(
name|s
argument_list|,
comment|/* event log */
name|EVENTLOG_ERROR_TYPE
argument_list|,
comment|/* event type */
literal|0
argument_list|,
comment|/* event category */
name|MSG_GENERIC_ERR
argument_list|,
comment|/* event ID (from gen_msg.mc) */
name|NULL
argument_list|,
comment|/* user security context */
literal|1
argument_list|,
comment|/* numstrings */
literal|0
argument_list|,
comment|/* binary size */
operator|&
name|msg
argument_list|,
comment|/* strings */
name|NULL
argument_list|)
expr_stmt|;
comment|/* binary data */
name|DeregisterEventSource
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Obtain registry string (if it exists).  * @param key: key string  * @param name: name of value to fetch.  * @return malloced string with the result or NULL if it did not  * exist on an error (logged) was encountered.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookup_reg_str
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|HKEY
name|hk
init|=
name|NULL
decl_stmt|;
name|DWORD
name|type
init|=
literal|0
decl_stmt|;
name|BYTE
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|DWORD
name|len
init|=
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|LONG
name|ret
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
name|RegOpenKeyEx
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|hk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERROR_FILE_NOT_FOUND
condition|)
return|return
name|NULL
return|;
comment|/* key does not exist */
elseif|else
if|if
condition|(
name|ret
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|reportev
argument_list|(
literal|"RegOpenKeyEx failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|RegQueryValueEx
argument_list|(
name|hk
argument_list|,
operator|(
name|LPCTSTR
operator|)
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RegCloseKey
argument_list|(
name|hk
argument_list|)
condition|)
name|reportev
argument_list|(
literal|"RegCloseKey"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERROR_FILE_NOT_FOUND
condition|)
return|return
name|NULL
return|;
comment|/* name does not exist */
elseif|else
if|if
condition|(
name|ret
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|reportev
argument_list|(
literal|"RegQueryValueEx failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|type
operator|==
name|REG_SZ
operator|||
name|type
operator|==
name|REG_MULTI_SZ
operator|||
name|type
operator|==
name|REG_EXPAND_SZ
condition|)
block|{
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* for multi_sz */
name|result
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|reportev
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Obtain registry integer (if it exists).  * @param key: key string  * @param name: name of value to fetch.  * @return integer value (if it exists), or 0 on error.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_reg_int
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|HKEY
name|hk
init|=
name|NULL
decl_stmt|;
name|DWORD
name|type
init|=
literal|0
decl_stmt|;
name|BYTE
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|DWORD
name|len
init|=
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|LONG
name|ret
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|RegOpenKeyEx
argument_list|(
name|HKEY_LOCAL_MACHINE
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
name|KEY_READ
argument_list|,
operator|&
name|hk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERROR_FILE_NOT_FOUND
condition|)
return|return
literal|0
return|;
comment|/* key does not exist */
elseif|else
if|if
condition|(
name|ret
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|reportev
argument_list|(
literal|"RegOpenKeyEx failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ret
operator|=
name|RegQueryValueEx
argument_list|(
name|hk
argument_list|,
operator|(
name|LPCTSTR
operator|)
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|type
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RegCloseKey
argument_list|(
name|hk
argument_list|)
condition|)
name|reportev
argument_list|(
literal|"RegCloseKey"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERROR_FILE_NOT_FOUND
condition|)
return|return
literal|0
return|;
comment|/* name does not exist */
elseif|else
if|if
condition|(
name|ret
operator|!=
name|ERROR_SUCCESS
condition|)
block|{
name|reportev
argument_list|(
literal|"RegQueryValueEx failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|type
operator|==
name|REG_SZ
operator|||
name|type
operator|==
name|REG_MULTI_SZ
operator|||
name|type
operator|==
name|REG_EXPAND_SZ
condition|)
block|{
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* for multi_sz */
name|result
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|REG_DWORD
condition|)
block|{
name|DWORD
name|r
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|r
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/** wait for unbound-anchor process to finish */
end_comment

begin_function
specifier|static
name|void
name|waitforubanchor
parameter_list|(
name|PROCESS_INFORMATION
modifier|*
name|pinfo
parameter_list|)
block|{
comment|/* we have 5 seconds scheduled for it, usually it will be very fast, 	 * with only a UDP message or two (100 msec or so), but the https 	 * connections could take some time */
name|DWORD
name|count
init|=
literal|7900
decl_stmt|;
name|DWORD
name|ret
init|=
name|WAIT_TIMEOUT
decl_stmt|;
comment|/* decrease timer every 1/10 second, we are still starting up */
while|while
condition|(
name|ret
operator|==
name|WAIT_TIMEOUT
condition|)
block|{
name|ret
operator|=
name|WaitForSingleObject
argument_list|(
name|pinfo
operator|->
name|hProcess
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|4000
condition|)
name|count
operator|-=
literal|100
expr_stmt|;
else|else
name|count
operator|--
expr_stmt|;
comment|/* go slow, it is taking long */
if|if
condition|(
name|count
operator|>
literal|3000
condition|)
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"unbound-anchor done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
return|return;
comment|/* did not end successfully */
block|}
if|if
condition|(
operator|!
name|GetExitCodeProcess
argument_list|(
name|pinfo
operator|->
name|hProcess
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"GetExitCodeProcess failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"unbound-anchor exit code is %d"
argument_list|,
operator|(
name|int
operator|)
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|log_info
argument_list|(
literal|"The root trust anchor has been updated."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Perform root anchor update if so configured, by calling that process  */
end_comment

begin_function
specifier|static
name|void
name|call_root_update
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|rootanchor
decl_stmt|;
name|rootanchor
operator|=
name|lookup_reg_str
argument_list|(
literal|"Software\\Unbound"
argument_list|,
literal|"RootAnchor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootanchor
operator|&&
name|strlen
argument_list|(
name|rootanchor
argument_list|)
operator|>
literal|0
condition|)
block|{
name|STARTUPINFO
name|sinfo
decl_stmt|;
name|PROCESS_INFORMATION
name|pinfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sinfo
argument_list|)
argument_list|)
expr_stmt|;
name|sinfo
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|sinfo
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"rootanchor: %s"
argument_list|,
name|rootanchor
argument_list|)
expr_stmt|;
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|8000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CreateProcess
argument_list|(
name|NULL
argument_list|,
name|rootanchor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|CREATE_NO_WINDOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sinfo
argument_list|,
operator|&
name|pinfo
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"CreateProcess error for unbound-anchor.exe"
argument_list|)
expr_stmt|;
else|else
block|{
name|waitforubanchor
argument_list|(
operator|&
name|pinfo
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hProcess
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hThread
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rootanchor
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Init service. Keeps calling status pending to tell service control  * manager that this process is not hanging.  * @param r: restart, true on restart  * @param d: daemon returned here.  * @param c: config file returned here.  * @return false if failed.  */
end_comment

begin_function
specifier|static
name|int
name|service_init
parameter_list|(
name|int
name|r
parameter_list|,
name|struct
name|daemon
modifier|*
modifier|*
name|d
parameter_list|,
name|struct
name|config_file
modifier|*
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|config_file
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|daemon
modifier|*
name|daemon
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|service_cfgfile
condition|)
block|{
name|char
modifier|*
name|newf
init|=
name|lookup_reg_str
argument_list|(
literal|"Software\\Unbound"
argument_list|,
literal|"ConfigFile"
argument_list|)
decl_stmt|;
if|if
condition|(
name|newf
condition|)
name|service_cfgfile
operator|=
name|newf
expr_stmt|;
else|else
name|service_cfgfile
operator|=
name|strdup
argument_list|(
name|CONFIGFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service_cfgfile
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
comment|/* create daemon */
if|if
condition|(
name|r
condition|)
name|daemon
operator|=
operator|*
name|d
expr_stmt|;
else|else
name|daemon
operator|=
name|daemon_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|daemon
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|r
condition|)
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|2800
argument_list|)
expr_stmt|;
comment|/* read config */
name|cfg
operator|=
name|config_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cfg
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|config_read
argument_list|(
name|cfg
argument_list|,
name|service_cfgfile
argument_list|,
name|daemon
operator|->
name|chroot
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|log_err
argument_list|(
literal|"error in config file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_warn
argument_list|(
literal|"could not open config file, using defaults"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
condition|)
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|2600
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"winservice - apply settings"
argument_list|)
expr_stmt|;
comment|/* apply settings and init */
name|verbosity
operator|=
name|cfg
operator|->
name|verbosity
operator|+
name|service_cmdline_verbose
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|directory
operator|&&
name|cfg
operator|->
name|directory
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|cfg
operator|->
name|directory
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"could not chdir to %s: %s"
argument_list|,
name|cfg
operator|->
name|directory
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
return|return
literal|0
return|;
name|log_warn
argument_list|(
literal|"could not change directory - continuing"
argument_list|)
expr_stmt|;
block|}
else|else
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"chdir to %s"
argument_list|,
name|cfg
operator|->
name|directory
argument_list|)
expr_stmt|;
block|}
name|log_init
argument_list|(
name|cfg
operator|->
name|logfile
argument_list|,
name|cfg
operator|->
name|use_syslog
argument_list|,
name|cfg
operator|->
name|chrootdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|2400
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"winservice - apply cfg"
argument_list|)
expr_stmt|;
name|daemon_apply_cfg
argument_list|(
name|daemon
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|2300
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|daemon
operator|->
name|rc
operator|=
name|daemon_remote_create
argument_list|(
name|cfg
argument_list|)
operator|)
condition|)
block|{
name|log_err
argument_list|(
literal|"could not set up remote-control"
argument_list|)
expr_stmt|;
name|daemon_delete
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
name|config_delete
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* open ports */
comment|/* keep reporting that we are busy starting */
if|if
condition|(
operator|!
name|r
condition|)
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|2200
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"winservice - open ports"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|daemon_open_shared_ports
argument_list|(
name|daemon
argument_list|)
condition|)
return|return
literal|0
return|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"winservice - ports opened"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
operator|*
name|d
operator|=
name|daemon
expr_stmt|;
operator|*
name|c
operator|=
name|cfg
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Deinit the service  */
end_comment

begin_function
specifier|static
name|void
name|service_deinit
parameter_list|(
name|struct
name|daemon
modifier|*
name|daemon
parameter_list|,
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|)
block|{
name|daemon_cleanup
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
name|config_delete
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|daemon_delete
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * The main function for the service.  * Called by the services API when starting unbound on windows in background.  * Arguments could have been present in the string 'path'.  * @param argc: nr args  * @param argv: arg text.  */
end_comment

begin_function
specifier|static
name|void
name|service_main
parameter_list|(
name|DWORD
name|ATTR_UNUSED
parameter_list|(
name|argc
parameter_list|)
parameter_list|,
name|LPTSTR
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|argv
parameter_list|)
parameter_list|)
block|{
name|struct
name|config_file
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|daemon
modifier|*
name|daemon
init|=
name|NULL
decl_stmt|;
name|service_status_handle
operator|=
name|RegisterServiceCtrlHandler
argument_list|(
name|SERVICE_NAME
argument_list|,
operator|(
name|LPHANDLER_FUNCTION
operator|)
name|hdlr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service_status_handle
condition|)
block|{
name|reportev
argument_list|(
literal|"Could not RegisterServiceCtrlHandler"
argument_list|)
expr_stmt|;
return|return;
block|}
name|service_status
operator|.
name|dwServiceType
operator|=
name|SERVICE_WIN32_OWN_PROCESS
expr_stmt|;
name|service_status
operator|.
name|dwServiceSpecificExitCode
operator|=
literal|0
expr_stmt|;
comment|/* see if we have root anchor update enabled */
name|call_root_update
argument_list|()
expr_stmt|;
comment|/* we are now starting up */
name|report_status
argument_list|(
name|SERVICE_START_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|3000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service_init
argument_list|(
literal|0
argument_list|,
operator|&
name|daemon
argument_list|,
operator|&
name|cfg
argument_list|)
condition|)
block|{
name|reportev
argument_list|(
literal|"Could not service_init"
argument_list|)
expr_stmt|;
name|report_status
argument_list|(
name|SERVICE_STOPPED
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* event that gets signalled when we want to quit; it 	 * should get registered in the worker-0 waiting loop. */
name|service_stop_event
operator|=
name|WSACreateEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|service_stop_event
operator|==
name|WSA_INVALID_EVENT
condition|)
block|{
name|log_err
argument_list|(
literal|"WSACreateEvent: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|reportev
argument_list|(
literal|"Could not WSACreateEvent"
argument_list|)
expr_stmt|;
name|report_status
argument_list|(
name|SERVICE_STOPPED
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|WSAResetEvent
argument_list|(
name|service_stop_event
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"WSAResetEvent: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* SetServiceStatus SERVICE_RUNNING;*/
name|report_status
argument_list|(
name|SERVICE_RUNNING
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"winservice - init complete"
argument_list|)
expr_stmt|;
comment|/* daemon performs work */
while|while
condition|(
operator|!
name|service_stop_shutdown
condition|)
block|{
name|daemon_fork
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service_stop_shutdown
condition|)
block|{
name|daemon_cleanup
argument_list|(
name|daemon
argument_list|)
expr_stmt|;
name|config_delete
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|cfg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|service_init
argument_list|(
literal|1
argument_list|,
operator|&
name|daemon
argument_list|,
operator|&
name|cfg
argument_list|)
condition|)
block|{
name|reportev
argument_list|(
literal|"Could not service_init"
argument_list|)
expr_stmt|;
name|report_status
argument_list|(
name|SERVICE_STOPPED
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* exit */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"winservice - cleanup."
argument_list|)
expr_stmt|;
name|report_status
argument_list|(
name|SERVICE_STOP_PENDING
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|service_deinit
argument_list|(
name|daemon
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|service_cfgfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|service_stop_event
condition|)
operator|(
name|void
operator|)
name|WSACloseEvent
argument_list|(
name|service_stop_event
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"winservice - full stop"
argument_list|)
expr_stmt|;
name|report_status
argument_list|(
name|SERVICE_STOPPED
argument_list|,
name|NO_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** start the service */
end_comment

begin_function
specifier|static
name|void
name|service_start
parameter_list|(
specifier|const
name|char
modifier|*
name|cfgfile
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|SERVICE_TABLE_ENTRY
name|myservices
index|[
literal|2
index|]
init|=
block|{
block|{
name|SERVICE_NAME
block|,
operator|(
name|LPSERVICE_MAIN_FUNCTION
operator|)
name|service_main
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|verbosity
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
name|VERB_QUERY
condition|)
block|{
comment|/* log to file about start sequence */
name|fclose
argument_list|(
name|fopen
argument_list|(
literal|"C:\\unbound.log"
argument_list|,
literal|"w"
argument_list|)
argument_list|)
expr_stmt|;
name|log_init
argument_list|(
literal|"C:\\unbound.log"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"open logfile"
argument_list|)
expr_stmt|;
block|}
else|else
name|log_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* otherwise, use Application log */
if|if
condition|(
name|c
condition|)
block|{
name|service_cfgfile
operator|=
name|strdup
argument_list|(
name|cfgfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service_cfgfile
condition|)
name|fatal_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
else|else
name|service_cfgfile
operator|=
name|NULL
expr_stmt|;
name|service_cmdline_verbose
operator|=
name|v
expr_stmt|;
comment|/* this call returns when service has stopped. */
if|if
condition|(
operator|!
name|StartServiceCtrlDispatcher
argument_list|(
name|myservices
argument_list|)
condition|)
block|{
name|reportev
argument_list|(
literal|"Could not StartServiceCtrlDispatcher"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|wsvc_command_option
parameter_list|(
specifier|const
name|char
modifier|*
name|wopt
parameter_list|,
specifier|const
name|char
modifier|*
name|cfgfile
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|wopt
argument_list|,
literal|"install"
argument_list|)
operator|==
literal|0
condition|)
name|wsvc_install
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|wopt
argument_list|,
literal|"remove"
argument_list|)
operator|==
literal|0
condition|)
name|wsvc_remove
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|wopt
argument_list|,
literal|"service"
argument_list|)
operator|==
literal|0
condition|)
name|service_start
argument_list|(
name|cfgfile
argument_list|,
name|v
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|wopt
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
name|wsvc_rc_start
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|wopt
argument_list|,
literal|"stop"
argument_list|)
operator|==
literal|0
condition|)
name|wsvc_rc_stop
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|else
name|fatal_exit
argument_list|(
literal|"unknown option: %s"
argument_list|,
name|wopt
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_win_stop_cb
parameter_list|(
name|int
name|ATTR_UNUSED
parameter_list|(
name|fd
parameter_list|)
parameter_list|,
name|short
name|ATTR_UNUSED
parameter_list|(
name|ev
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"caught stop signal (wsaevent)"
argument_list|)
expr_stmt|;
name|worker
operator|->
name|need_to_exit
operator|=
literal|1
expr_stmt|;
name|comm_base_exit
argument_list|(
name|worker
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** wait for cron process to finish */
end_comment

begin_function
specifier|static
name|void
name|waitforit
parameter_list|(
name|PROCESS_INFORMATION
modifier|*
name|pinfo
parameter_list|)
block|{
name|DWORD
name|ret
init|=
name|WaitForSingleObject
argument_list|(
name|pinfo
operator|->
name|hProcess
argument_list|,
name|INFINITE
argument_list|)
decl_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cronaction done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|WAIT_OBJECT_0
condition|)
block|{
return|return;
comment|/* did not end successfully */
block|}
if|if
condition|(
operator|!
name|GetExitCodeProcess
argument_list|(
name|pinfo
operator|->
name|hProcess
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"GetExitCodeProcess failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"exit code is %d"
argument_list|,
operator|(
name|int
operator|)
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|WSASetEvent
argument_list|(
name|service_stop_event
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"Could not WSASetEvent: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Do the cron action and wait for result exit value */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|win_do_cron
parameter_list|(
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|int
name|mynum
init|=
literal|65
decl_stmt|;
name|char
modifier|*
name|cronaction
decl_stmt|;
name|log_thread_set
argument_list|(
operator|&
name|mynum
argument_list|)
expr_stmt|;
name|cronaction
operator|=
name|lookup_reg_str
argument_list|(
literal|"Software\\Unbound"
argument_list|,
literal|"CronAction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cronaction
operator|&&
name|strlen
argument_list|(
name|cronaction
argument_list|)
operator|>
literal|0
condition|)
block|{
name|STARTUPINFO
name|sinfo
decl_stmt|;
name|PROCESS_INFORMATION
name|pinfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sinfo
argument_list|)
argument_list|)
expr_stmt|;
name|sinfo
operator|.
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|sinfo
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cronaction: %s"
argument_list|,
name|cronaction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CreateProcess
argument_list|(
name|NULL
argument_list|,
name|cronaction
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|CREATE_NO_WINDOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sinfo
argument_list|,
operator|&
name|pinfo
argument_list|)
condition|)
name|log_err
argument_list|(
literal|"CreateProcess error"
argument_list|)
expr_stmt|;
else|else
block|{
name|waitforit
argument_list|(
operator|&
name|pinfo
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hProcess
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|pinfo
operator|.
name|hThread
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cronaction
argument_list|)
expr_stmt|;
comment|/* stop self */
name|CloseHandle
argument_list|(
name|cron_thread
argument_list|)
expr_stmt|;
name|cron_thread
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** Set the timer for cron for the next wake up */
end_comment

begin_function
specifier|static
name|void
name|set_cron_timer
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|crontime
decl_stmt|;
if|if
condition|(
name|cron_was_quick
operator|==
literal|0
condition|)
block|{
name|cron_was_quick
operator|=
literal|1
expr_stmt|;
name|crontime
operator|=
literal|3600
expr_stmt|;
comment|/* first update some time after boot */
block|}
else|else
block|{
name|crontime
operator|=
name|lookup_reg_int
argument_list|(
literal|"Software\\Unbound"
argument_list|,
literal|"CronTime"
argument_list|)
expr_stmt|;
if|if
condition|(
name|crontime
operator|==
literal|0
condition|)
name|crontime
operator|=
literal|60
operator|*
literal|60
operator|*
literal|24
expr_stmt|;
comment|/* 24 hours */
block|}
name|memset
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|crontime
expr_stmt|;
name|comm_timer_set
argument_list|(
name|service_cron
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wsvc_cron_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|worker
modifier|*
name|worker
init|=
operator|(
expr|struct
name|worker
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* perform cronned operation */
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"cron timer callback"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cron_thread
operator|==
name|NULL
condition|)
block|{
comment|/* create new thread to do it */
name|ub_thread_create
argument_list|(
operator|&
name|cron_thread
argument_list|,
name|win_do_cron
argument_list|,
name|worker
argument_list|)
expr_stmt|;
block|}
comment|/* reschedule */
name|set_cron_timer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wsvc_setup_worker
parameter_list|(
name|struct
name|worker
modifier|*
name|worker
parameter_list|)
block|{
comment|/* if not started with -w service, do nothing */
if|if
condition|(
operator|!
name|service_stop_event
condition|)
return|return;
if|if
condition|(
operator|!
name|winsock_register_wsaevent
argument_list|(
name|comm_base_internal
argument_list|(
name|worker
operator|->
name|base
argument_list|)
argument_list|,
operator|&
name|service_stop_ev
argument_list|,
name|service_stop_event
argument_list|,
operator|&
name|worker_win_stop_cb
argument_list|,
name|worker
argument_list|)
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"could not register wsaevent"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|service_cron
condition|)
block|{
name|service_cron
operator|=
name|comm_timer_create
argument_list|(
name|worker
operator|->
name|base
argument_list|,
name|wsvc_cron_cb
argument_list|,
name|worker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service_cron
condition|)
name|fatal_exit
argument_list|(
literal|"could not create cron timer"
argument_list|)
expr_stmt|;
name|set_cron_timer
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|wsvc_desetup_worker
argument_list|(
expr|struct
name|worker
operator|*
name|ATTR_UNUSED
argument_list|(
name|worker
argument_list|)
argument_list|)
block|{
name|comm_timer_delete
argument_list|(
name|service_cron
argument_list|)
expr_stmt|;
name|service_cron
operator|=
name|NULL
expr_stmt|;
block|}
end_decl_stmt

end_unit

