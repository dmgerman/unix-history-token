begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Part one of the mined editor.  */
end_comment

begin_comment
comment|/*  * Ported to FreeBSD by Andrzej Bialecki<abial@freebsd.org>, Oct 1998  *  * Added a help screen, and remapped some of the wildest keybindings...  */
end_comment

begin_comment
comment|/*  * Author: Michiel Huisjes.  *   * 1. General remarks.  *   *   Mined is a screen editor designed for the MINIX operating system.  *   It is meant to be used on files not larger than 50K and to be fast.  *   When mined starts up, it reads the file into its memory to minimize  *   disk access. The only time that disk access is needed is when certain  *   save, write or copy commands are given.  *   *   Mined has the style of Emacs or Jove, that means that there are no modes.  *   Each character has its own entry in an 256 pointer to function array,  *   which is called when that character is typed. Only ASCII characters are  *   connected with a function that inserts that character at the current  *   location in the file. Two execptions are<linefeed> and<tab> which are  *   inserted as well. Note that the mapping between commands and functions  *   called is implicit in the table. Changing the mapping just implies  *   changing the pointers in this table.  *   *   The display consists of SCREENMAX + 1 lines and XMAX + 1 characters. When  *   a line is larger (or gets larger during editing) than XBREAK characters,  *   the line is either shifted SHIFT_SIZE characters to the left (which means  *   that the first SHIFT_SIZE characters are not printed) or the end of the  *   line is marked with the SHIFT_MARK character and the rest of the line is  *   not printed.  A line can never exceed MAX_CHARS characters. Mined will  *   always try to keep the cursor on the same line and same (relative)  *   x-coordinate if nothing changed. So if you scroll one line up, the cursor  *   stays on the same line, or when you move one line down, the cursor will  *   move to the same place on the line as it was on the previous.  *   Every character on the line is available for editing including the  *   linefeed at the the of the line. When the linefeed is deleted, the current  *   line and the next line are joined. The last character of the file (which  *   is always a linefeed) can never be deleted.  *   The bottomline (as indicated by YMAX + 1) is used as a status line during  *   editing. This line is usually blank or contains information mined needs  *   during editing. This information (or rather questions) is displayed in  *   reverse video.  *   *   The terminal modes are changed completely. All signals like start/stop,  *   interrupt etc. are unset. The only signal that remains is the quit signal.  *   The quit signal (^\) is the general abort signal for mined. Typing a ^\  *   during searching or when mined is asking for filenames, etc. will abort  *   the function and mined will return to the main loop.  Sending a quit  *   signal during the main loop will abort the session (after confirmation)  *   and the file is not (!) saved.  *   The session will also be aborted when an unrecoverable error occurs. E.g  *   when there is no more memory available. If the file has been modified,  *   mined will ask if the file has to be saved or not.  *   If there is no more space left on the disk, mined will just give an error   *   message and continue.  *   *   The number of system calls are minized. This is done to keep the editor  *   as fast as possible. I/O is done in SCREEN_SIZE reads/writes. Accumulated  *   output is also flushed at the end of each character typed.  *   * 2. Regular expressions  *     *   Mined has a build in regular expression matcher, which is used for  *   searching and replace routines. A regular expression consists of a  *   sequence of:  *   *      1. A normal character matching that character.  *      2. A . matching any character.  *      3. A ^ matching the begin of a line.  *      4. A $ (as last character of the pattern) mathing the end of a line.  *      5. A \<character> matching<character>.  *      6. A number of characters enclosed in [] pairs matching any of these  *        characters. A list of characters can be indicated by a '-'. So  *        [a-z] matches any letter of the alphabet. If the first character  *        after the '[' is a '^' then the set is negated (matching none of  *        the characters).   *        A ']', '^' or '-' can be escaped by putting a '\' in front of it.  *        Of course this means that a \ must be represented by \\.  *      7. If one of the expressions as described in 1-6 is followed by a  *        '*' than that expressions matches a sequence of 0 or more of  *        that expression.  *   *   Parsing of regular expression is done in two phases. In the first phase  *   the expression is compiled into a more comprehensible form. In the second  *   phase the actual matching is done. For more details see 3.6.  *   *   * 3. Implementation of mined.  *   *   3.1 Data structures.  *   *      The main data structures are as follows. The whole file is kept in a  *      double linked list of lines. The LINE structure looks like this:  *   *         typedef struct Line {  *              struct Line *next;  *              struct Line *prev;  *              char *text;  *              unsigned char shift_count;  *         } LINE;  *   *      Each line entry contains a pointer to the next line, a pointer to the  *      previous line and a pointer to the text of that line. A special field  *      shift_count contains the number of shifts (in units of SHIFT_SIZE)  *      that is performed on that line. The total size of the structure is 7  *      bytes so a file consisting of 1000 empty lines will waste a lot of  *      memory. A LINE structure is allocated for each line in the file. After  *      that the number of characters of the line is counted and sufficient  *      space is allocated to store them (including a linefeed and a '\0').  *      The resulting address is assigned to the text field in the structure.  *   *      A special structure is allocated and its address is assigned to the  *      variable header as well as the variable tail. The text field of this  *      structure is set to NIL_PTR. The tail->prev of this structure points  *      to the last LINE of the file and the header->next to the first LINE.  *      Other LINE *variables are top_line and bot_line which point to the  *      first line resp. the last line on the screen.  *      Two other variables are important as well. First the LINE *cur_line,  *      which points to the LINE currently in use and the char *cur_text,  *      which points to the character at which the cursor stands.  *      Whenever an ASCII character is typed, a new line is build with this  *      character inserted. Then the old data space (pointed to by  *      cur_line->text) is freed, data space for the new line is allocated and  *      assigned to cur_line->text.  *   *      Two global variables called x and y represent the x and y coordinates  *      from the cursor. The global variable nlines contains the number of  *      lines in the file. Last_y indicates the maximum y coordinate of the  *      screen (which is usually SCREENMAX).  *   *      A few strings must be initialized by hand before compiling mined.  *      These string are enter_string, which is printed upon entering mined,  *      rev_video (turn on reverse video), normal_video, rev_scroll (perform a  *      reverse scroll) and pos_string. The last string should hold the  *      absolute position string to be printed for cursor motion. The #define  *      X_PLUS and Y_PLUS should contain the characters to be added to the  *      coordinates x and y (both starting at 0) to finish cursor positioning.  *   *   3.2 Starting up.  *        *      Mined can be called with or without argument and the function  *      load_file () is called with these arguments. load_file () checks  *      if the file exists if it can be read and if it is writable and  *      sets the writable flag accordingly. If the file can be read,   *      load_file () reads a line from the file and stores this line into  *      a structure by calling install_line () and line_insert () which  *      installs the line into the double linked list, until the end of the  *      file is reached.  *      Lines are read by the function get_line (), which buffers the  *      reading in blocks of SCREEN_SIZE. Load_file () also initializes the  *      LINE *variables described above.  *   *   3.3 Moving around.  *   *      Several commands are implemented for moving through the file.  *      Moving up (UP), down (DN) left (LF) and right (RT) are done by the  *      arrow keys. Moving one line below the screen scrolls the screen one  *      line up. Moving one line above the screen scrolls the screen one line  *      down. The functions forward_scroll () and reverse_scroll () take care  *      of that.  *      Several other move functions exist: move to begin of line (BL), end of  *      line (EL) top of screen (HIGH), bottom of screen (LOW), top of file  *      (HO), end of file (EF), scroll one page down (PD), scroll one page up  *      (PU), scroll one line down (SD), scroll one line up (SU) and move to a  *      certain line number (GOTO).  *      Two functions called MN () and MP () each move one word further or   *      backwards. A word is a number of non-blanks seperated by a space, a  *      tab or a linefeed.  *   *   3.4 Modifying text.  *   *      The modifying commands can be separated into two modes. The first  *      being inserting text, and the other deleting text. Two functions are  *      created for these purposes: insert () and delete (). Both are capable  *      of deleting or inserting large amounts of text as well as one  *      character. Insert () must be given the line and location at which  *      the text must be inserted. Is doesn't make any difference whether this  *      text contains linefeeds or not. Delete () must be given a pointer to  *      the start line, a pointer from where deleting should start on that  *      line and the same information about the end position. The last  *      character of the file will never be deleted. Delete () will make the  *      necessary changes to the screen after deleting, but insert () won't.  *      The functions for modifying text are: insert one char (S), insert a  *      file (file_insert (fd)), insert a linefeed and put cursor back to  *      end of line (LIB), delete character under the cursor (DCC), delete  *      before cursor (even linefeed) (DPC), delete next word (DNW), delete  *      previous word (DPC) and delete to end of line (if the cursor is at  *      a linefeed delete line) (DLN).  *   *   3.5 Yanking.  *   *      A few utilities are provided for yanking pieces of text. The function  *      MA () marks the current position in the file. This is done by setting   *      LINE *mark_line and char *mark_text to the current position. Yanking  *      of text can be done in two modes. The first mode just copies the text  *      from the mark to the current position (or visa versa) into a buffer  *      (YA) and the second also deletes the text (DT). Both functions call  *      the function set_up () with the delete flag on or off. Set_up ()  *      checks if the marked position is still a valid one (by using  *      check_mark () and legal ()), and then calls the function yank () with  *      a start and end position in the file. This function copies the text  *      into a scratch_file as indicated by the variable yank_file. This  *      scratch_file is made uniq by the function scratch_file (). At the end  *      of copying yank will (if necessary) delete the text. A global flag  *      called yank_status keeps track of the buffer (or file) status. It is  *      initialized on NOT_VALID and set to EMPTY (by set_up ()) or VALID (by  *      yank ()). Several things can be done with the buffer. It can be  *      inserted somewhere else in the file (PT) or it can be copied into  *      another file (WB), which will be prompted for.  *   *   3.6 Search and replace routines.  *   *      Searching for strings and replacing strings are done by regular  *      expressions. For any expression the function compile () is called  *      with as argument the expression to compile. Compile () returns a  *      pointer to a structure which looks like this:  *   *         typedef struct regex {  *              union {  *                    char *err_mess;  *                    int *expression;  *              } result;  *              char status;  *              char *start_ptr;  *              char *end_ptr;  *         } REGEX;  *        *    If something went wrong during compiling (e.g. an illegal expression  *    was given), the function reg_error () is called, which sets the status  *    field to REG_ERROR and the err_mess field to the error message. If the  *    match must be anchored at the beginning of the line (end of line), the  *    status field is set to BEGIN_LINE (END_LINE). If none of these special  *    cases are true, the field is set to 0 and the function finished () is  *    called.  Finished () allocates space to hold the compiled expression  *    and copies this expression into the expression field of the union  *    (bcopy ()). Matching is done by the routines match() and line_check().  *    Match () takes as argument the REGEX *program, a pointer to the  *    startposition on the current line, and a flag indicating FORWARD or  *    REVERSE search.  Match () checks out the whole file until a match is  *    found. If match is found it returns a pointer to the line in which the  *    match was found else it returns a NIL_LINE. Line_check () takes the  *    same arguments, but return either MATCH or NO_MATCH.  *    During checking, the start_ptr and end_ptr fields of the REGEX  *    structure are assigned to the start and end of the match.   *    Both functions try to find a match by walking through the line  *    character by character. For each possibility, the function  *    check_string () is called with as arguments the REGEX *program and the  *    string to search in. It starts walking through the expression until  *    the end of the expression or the end of the string is reached.  *    Whenever a * is encountered, this position of the string is marked,  *    the maximum number of matches are performed and the function star ()  *    is called in order to try to find the longest match possible. Star ()  *    takes as arguments the REGEX program, the current position of the  *    string, the marked position and the current position of the expression  *    Star () walks from the current position of the string back to the  *    marked position, and calls string_check () in order to find a match.  *    It returns MATCH or NO_MATCH, just as string_check () does.  *    Searching is now easy. Both search routines (forward (SF) and  *    backwards search (SR)) call search () with an apropiate message and a  *    flag indicating FORWARD or REVERSE search. Search () will get an  *    expression from the user by calling get_expression(). Get_expression()  *    returns a pointer to a REGEX structure or NIL_REG upon errors and  *    prompts for the expression. If no expression if given, the previous is  *    used instead. After that search will call match (), and if a match is  *    found, we can move to that place in the file by the functions find_x()  *    and find_y () which will find display the match on the screen.  *    Replacing can be done in two ways. A global replace (GR) or a line  *    replace (LR). Both functions call change () with a message an a flag  *    indicating global or line replacement. Change () will prompt for the  *    expression and for the replacement. Every& in the replacement pattern  *    means substitute the match instead. An& can be escaped by a \. When  *    a match is found, the function substitute () will perform the  *    substitution.  *   *  3.6 Miscellaneous commands.  *   *    A few commands haven't be discussed yet. These are redraw the screen  *    (RD) fork a shell (SH), print file status (FS), write file to disc  *    (WT), insert a file at current position (IF), leave editor (XT) and  *    visit another file (VI). The last two functions will check if the file  *    has been modified. If it has, they will ask if you want to save the  *    file by calling ask_save ().  *    The function ESC () will repeat a command n times. It will prompt for  *    the number. Aborting the loop can be done by sending the ^\ signal.  *   *  3.7 Utility functions.  *   *    Several functions exists for internal use. First allocation routines:  *    alloc (bytes) and newline () will return a pointer to free data space  *    if the given size. If there is no more memory available, the function  *    panic () is called.  *    Signal handling: The only signal that can be send to mined is the   *    SIGQUIT signal. This signal, functions as a general abort command.  *    Mined will abort if the signal is given during the main loop. The   *    function abort_mined () takes care of that.  *    Panic () is a function with as argument a error message. It will print  *    the message and the error number set by the kernel (errno) and will  *    ask if the file must be saved or not. It resets the terminal  *    (raw_mode ()) and exits.  *    String handling routines like copy_string(to, from), length_of(string)  *    and build_string (buffer, format, arg1, arg2, ...). The latter takes  *    a description of the string out out the format field and puts the  *    result in the buffer. (It works like printf (3), but then into a  *    string). The functions status_line (string1, string2), error (string1,  *    string2), clear_status () and bottom_line () all print information on  *    the status line.  *    Get_string (message, buffer) reads a string and getchar () reads one  *    character from the terminal.  *    Num_out ((long) number) prints the number into a 11 digit field  *    without leading zero's. It returns a pointer to the resulting string.  *    File_status () prints all file information on the status line.  *    Set_cursor (x, y) prints the string to put the cursor at coordinates  *    x and y.  *    Output is done by four functions: writeline(fd,string), clear_buffer()  *    write_char (fd, c) and flush_buffer (fd). Three defines are provided  *    to write on filedescriptor STD_OUT (terminal) which is used normally:  *    string_print (string), putchar (c) and flush (). All these functions  *    use the global I/O buffer screen and the global index for this array  *    called out_count. In this way I/O can be buffered, so that reads or  *    writes can be done in blocks of SCREEN_SIZE size.  *    The following functions all handle internal line maintenance. The  *    function proceed (start_line, count) returns the count'th line after  *    start_line.  If count is negative, the count'th line before the  *    start_line is returned. If header or tail is encountered then that  *    will be returned. Display (x, y, start_line, count) displays count  *    lines starting at coordinates [x, y] and beginning at start_line. If  *    the header or tail is encountered, empty lines are displayed instead.  *    The function reset (head_line, ny) reset top_line, last_y, bot_line,  *    cur_line and y-coordinate. This is not a neat way to do the  *    maintenance, but it sure saves a lot of code. It is usually used in  *    combination with display ().  *    Put_line(line, offset, clear_line), prints a line (skipping characters  *    according to the line->shift_size field) until XBREAK - offset  *    characters are printed or a '\n' is encountered. If clear_line is  *	  TRUE, spaces are printed until XBREAK - offset characters.  *	  Line_print (line) is a #define from put_line (line, 0, TRUE).  *    Moving is done by the functions move_to (x, y), move_addres (address)  *    and move (x, adress, y). This function is the most important one in  *    mined. New_y must be between 0 and last_y, new_x can be about  *    anything, address must be a pointer to an character on the current  *    line (or y). Move_to () first adjust the y coordinate together with  *    cur_line. If an address is given, it finds the corresponding  *    x-coordinate. If an new x-coordinate was given, it will try to locate  *    the corresponding character. After that it sets the shift_count field  *    of cur_line to an apropiate number according to new_x. The only thing  *    left to do now is to assign the new values to cur_line, cur_text, x  *    and y.  *   * 4. Summary of commands.  *    *  CURSOR MOTION  *    up-arrow  Move cursor 1 line up.  At top of screen, reverse scroll  *    down-arrow  Move cursor 1 line down.  At bottom, scroll forward.  *    left-arrow  Move cursor 1 character left or to end of previous line  *    right-arrow Move cursor 1 character right or to start of next line  *    CTRL-A   Move cursor to start of current line  *    CTRL-Z   Move cursor to end of current line  *    CTRL-^   Move cursor to top of screen  *    CTRL-_   Move cursor to bottom of screen  *    CTRL-F   Forward to start of next word (even to next line)  *    CTRL-B   Backward to first character of previous word  *     *  SCREEN MOTION  *    Home key  Move cursor to first character of file  *    End key   Move cursor to last character of file  *    PgUp    Scroll backward 1 page. Bottom line becomes top line  *    PgD    Scroll backward 1 page. Top line becomes bottom line  *    CTRL-D   Scroll screen down one line (reverse scroll)  *    CTRL-U   Scroll screen up one line (forward scroll)  *     *  MODIFYING TEXT  *    ASCII char  Self insert character at cursor  *    tab    Insert tab at cursor  *    backspace  Delete the previous char (left of cursor), even line feed  *    Del    Delete the character under the cursor  *    CTRL-N   Delete next word  *    CTRL-P   Delete previous word  *    CTRL-O   Insert line feed at cursor and back up 1 character  *    CTRL-T   Delete tail of line (cursor to end); if empty, delete line  *    CTRL-@   Set the mark (remember the current location)  *    CTRL-K   Delete text from the mark to current position save on file  *    CTRL-C   Save the text from the mark to the current position  *    CTRL-Y   Insert the contents of the save file at current position  *    CTRL-Q   Insert the contents of the save file into a new file  *    CTRL-G   Insert a file at the current position  *     *  MISCELLANEOUS  *    CTRL-E   Erase and redraw the screen  *    CTRL-V   Visit file (read a new file); complain if old one changed  *    CTRL-W   Write the current file back to the disk  *    numeric +  Search forward (prompt for regular expression)  *    numeric -  Search backward (prompt for regular expression)  *    numeric 5  Print the current status of the file  *    CTRL-R   (Global) Replace str1 by str2 (prompts for each string)  *    CTRL-L   (Line) Replace string1 by string2  *    CTRL-S   Fork off a shell and wait for it to finish  *    CTRL-X   EXIT (prompt if file modified)  *    CTRL-]   Go to a line. Prompts for linenumber  *    CTRL-\   Abort whatever editor was doing and start again  *    escape key  Repeat a command count times; (prompts for count)  */
end_comment

begin_comment
comment|/*  ========================================================================  *  *				Utilities				      *	  *  ========================================================================  */
end_comment

begin_include
include|#
directive|include
file|"mined.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ymax
init|=
name|YMAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|screenmax
init|=
name|SCREENMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print file status.  */
end_comment

begin_function
name|void
name|FS
parameter_list|()
block|{
name|fstatus
argument_list|(
name|file_name
index|[
literal|0
index|]
condition|?
literal|""
else|:
literal|"[buffer]"
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Visit (edit) another file. If the file has been modified, ask the user if  * he wants to save it.  */
end_comment

begin_function
name|void
name|VI
parameter_list|()
block|{
name|char
name|new_file
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Buffer to hold new file name */
if|if
condition|(
name|modified
operator|==
name|TRUE
operator|&&
name|ask_save
argument_list|()
operator|==
name|ERRORS
condition|)
return|return;
comment|/* Get new file name */
if|if
condition|(
name|get_file
argument_list|(
literal|"Visit file:"
argument_list|,
name|new_file
argument_list|)
operator|==
name|ERRORS
condition|)
return|return;
comment|/* Free old linked list, initialize global variables and load new file */
name|initialize
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|CL
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|enter_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|load_file
argument_list|(
name|new_file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
name|NIL_PTR
else|:
name|new_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write file in core to disc.  */
end_comment

begin_function
name|int
name|WT
parameter_list|()
block|{
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
specifier|register
name|long
name|count
init|=
literal|0L
decl_stmt|;
comment|/* Nr of chars written */
name|char
name|file
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Buffer for new file name */
name|int
name|fd
decl_stmt|;
comment|/* Filedescriptor of file */
if|if
condition|(
name|modified
operator|==
name|FALSE
condition|)
block|{
name|error
argument_list|(
literal|"Write not necessary."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return
name|FINE
return|;
block|}
comment|/* Check if file_name is valid and if file can be written */
if|if
condition|(
name|file_name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|writable
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|get_file
argument_list|(
literal|"Enter file name:"
argument_list|,
name|file
argument_list|)
operator|!=
name|FINE
condition|)
return|return
name|ERRORS
return|;
name|copy_string
argument_list|(
name|file_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Save file name */
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|file_name
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Empty file */
name|error
argument_list|(
literal|"Cannot create "
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|writable
operator|=
name|FALSE
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
else|else
name|writable
operator|=
name|TRUE
expr_stmt|;
name|clear_buffer
argument_list|()
expr_stmt|;
name|status_line
argument_list|(
literal|"Writing "
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
name|header
operator|->
name|next
init|;
name|line
operator|!=
name|tail
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
block|{
if|if
condition|(
name|line
operator|->
name|shift_count
operator|&
name|DUMMY
condition|)
block|{
if|if
condition|(
name|line
operator|->
name|next
operator|==
name|tail
operator|&&
name|line
operator|->
name|text
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
continue|continue;
block|}
if|if
condition|(
name|writeline
argument_list|(
name|fd
argument_list|,
name|line
operator|->
name|text
argument_list|)
operator|==
name|ERRORS
condition|)
block|{
name|count
operator|=
operator|-
literal|1L
expr_stmt|;
break|break;
block|}
name|count
operator|+=
operator|(
name|long
operator|)
name|length_of
argument_list|(
name|line
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0L
operator|&&
name|flush_buffer
argument_list|(
name|fd
argument_list|)
operator|==
name|ERRORS
condition|)
name|count
operator|=
operator|-
literal|1L
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1L
condition|)
return|return
name|ERRORS
return|;
name|modified
operator|=
name|FALSE
expr_stmt|;
name|rpipe
operator|=
name|FALSE
expr_stmt|;
comment|/* File name is now assigned */
comment|/* Display how many chars (and lines) were written */
name|fstatus
argument_list|(
literal|"Wrote"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|FINE
return|;
block|}
end_function

begin_comment
comment|/* Call WT and discard value returned. */
end_comment

begin_function
name|void
name|XWT
parameter_list|()
block|{
operator|(
name|void
operator|)
name|WT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call an interactive shell.  */
end_comment

begin_function
name|void
name|SH
parameter_list|()
block|{
specifier|register
name|int
name|w
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|shell
decl_stmt|;
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NIL_PTR
condition|)
name|shell
operator|=
literal|"/bin/sh"
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error */
name|error
argument_list|(
literal|"Cannot fork."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* This is the child */
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|raw_mode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpipe
condition|)
block|{
comment|/* Fix stdin */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|126
argument_list|)
expr_stmt|;
block|}
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
comment|/* Exit with 127 */
default|default :
comment|/* This is the parent */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
do|do
block|{
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
operator|-
literal|1
operator|&&
name|w
operator|!=
name|pid
condition|)
do|;
block|}
name|raw_mode
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|RD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|>>
literal|8
operator|)
operator|==
literal|127
condition|)
comment|/* Child died with 127 */
name|error
argument_list|(
literal|"Cannot exec "
argument_list|,
name|shell
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|status
operator|>>
literal|8
operator|)
operator|==
literal|126
condition|)
name|error
argument_list|(
literal|"Cannot open /dev/tty as fd #0"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Proceed returns the count'th line after `line'. When count is negative  * it returns the count'th line before `line'. When the next (previous)  * line is the tail (header) indicating EOF (tof) it stops.  */
end_comment

begin_function
name|LINE
modifier|*
name|proceed
parameter_list|(
name|line
parameter_list|,
name|count
parameter_list|)
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
while|while
condition|(
name|count
operator|++
operator|<
literal|0
operator|&&
name|line
operator|!=
name|header
condition|)
name|line
operator|=
name|line
operator|->
name|prev
expr_stmt|;
else|else
while|while
condition|(
name|count
operator|--
operator|>
literal|0
operator|&&
name|line
operator|!=
name|tail
condition|)
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_comment
comment|/*  * Show concatenation of s1 and s2 on the status line (bottom of screen)  * If revfl is TRUE, turn on reverse video on both strings. Set stat_visible  * only if bottom_line is visible.  */
end_comment

begin_function
name|int
name|bottom_line
parameter_list|(
name|revfl
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|inbuf
parameter_list|,
name|statfl
parameter_list|)
name|FLAG
name|revfl
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|inbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLAG
name|statfl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
init|=
name|FINE
decl_stmt|;
name|char
name|buf
index|[
name|LINE_LEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|NIL_PTR
condition|)
while|while
condition|(
operator|*
name|p
operator|=
operator|*
name|s1
operator|++
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|s2
operator|!=
name|NIL_PTR
condition|)
while|while
condition|(
operator|*
name|p
operator|=
operator|*
name|s2
operator|++
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|revfl
operator|==
name|ON
operator|&&
name|stat_visible
operator|==
name|TRUE
condition|)
name|clear_status
argument_list|()
expr_stmt|;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
if|if
condition|(
name|revfl
operator|==
name|ON
condition|)
block|{
comment|/* Print rev. start sequence */
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|SO
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|rev_video
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|stat_visible
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
comment|/* Used as clear_status() */
name|stat_visible
operator|=
name|FALSE
expr_stmt|;
name|string_print
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuf
operator|!=
name|NIL_PTR
condition|)
name|ret
operator|=
name|input
argument_list|(
name|inbuf
argument_list|,
name|statfl
argument_list|)
expr_stmt|;
comment|/* Print normal video */
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|SE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|normal_video
argument_list|)
expr_stmt|;
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
comment|/* Clear the rest of the line */
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|inbuf
operator|!=
name|NIL_PTR
condition|)
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
else|else
name|set_cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Set cursor back to old position */
name|flush
argument_list|()
expr_stmt|;
comment|/* Perform the actual write */
if|if
condition|(
name|ret
operator|!=
name|FINE
condition|)
name|clear_status
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/*  * Count_chars() count the number of chars that the line would occupy on the  * screen. Counting starts at the real x-coordinate of the line.  */
end_comment

begin_function
name|int
name|count_chars
parameter_list|(
name|line
parameter_list|)
name|LINE
modifier|*
name|line
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
init|=
name|get_shift
argument_list|(
name|line
operator|->
name|shift_count
argument_list|)
operator|*
operator|-
name|SHIFT_SIZE
decl_stmt|;
specifier|register
name|char
modifier|*
name|textp
init|=
name|line
operator|->
name|text
decl_stmt|;
comment|/* Find begin of line on screen */
while|while
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|is_tab
argument_list|(
operator|*
name|textp
operator|++
argument_list|)
condition|)
name|cnt
operator|=
name|tab
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* Count number of chars left */
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|textp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|is_tab
argument_list|(
operator|*
name|textp
operator|++
argument_list|)
condition|)
name|cnt
operator|=
name|tab
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|++
expr_stmt|;
block|}
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/*  * Move to coordinates nx, ny at screen.  The caller must check that scrolling  * is not needed.  * If new_x is lower than 0 or higher than XBREAK, move_to() will check if  * the line can be shifted. If it can it sets(or resets) the shift_count field  * of the current line accordingly.  * Move also sets cur_text to the right char.  * If we're moving to the same x coordinate, try to move the the x-coordinate  * used on the other previous call.  */
end_comment

begin_function
name|void
name|move
parameter_list|(
name|new_x
parameter_list|,
name|new_address
parameter_list|,
name|new_y
parameter_list|)
specifier|register
name|int
name|new_x
decl_stmt|;
name|int
name|new_y
decl_stmt|;
name|char
modifier|*
name|new_address
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|line
init|=
name|cur_line
decl_stmt|;
comment|/* For building new cur_line */
name|int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* How many shifts to make */
specifier|static
name|int
name|rel_x
init|=
literal|0
decl_stmt|;
comment|/* Remember relative x position */
name|int
name|tx
init|=
name|x
decl_stmt|;
comment|/* Check for illegal values */
if|if
condition|(
name|new_y
operator|<
literal|0
operator|||
name|new_y
operator|>
name|last_y
condition|)
return|return;
comment|/* Adjust y-coordinate and cur_line */
if|if
condition|(
name|new_y
operator|<
name|y
condition|)
while|while
condition|(
name|y
operator|!=
name|new_y
condition|)
block|{
if|if
condition|(
name|line
operator|->
name|shift_count
operator|>
literal|0
condition|)
block|{
name|line
operator|->
name|shift_count
operator|=
literal|0
expr_stmt|;
name|move_to
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|y
operator|--
expr_stmt|;
name|line
operator|=
name|line
operator|->
name|prev
expr_stmt|;
block|}
else|else
while|while
condition|(
name|y
operator|!=
name|new_y
condition|)
block|{
if|if
condition|(
name|line
operator|->
name|shift_count
operator|>
literal|0
condition|)
block|{
name|line
operator|->
name|shift_count
operator|=
literal|0
expr_stmt|;
name|move_to
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|y
operator|++
expr_stmt|;
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
block|}
comment|/* Set or unset relative x-coordinate */
if|if
condition|(
name|new_address
operator|==
name|NIL_PTR
condition|)
block|{
name|new_address
operator|=
name|find_address
argument_list|(
name|line
argument_list|,
operator|(
name|new_x
operator|==
name|x
operator|)
condition|?
name|rel_x
else|:
name|new_x
argument_list|,
operator|&
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_x
operator|!=
name|x
condition|)
name|rel_x
operator|=
name|tx
expr_stmt|;
name|new_x
operator|=
name|tx
expr_stmt|;
block|}
else|else
block|{
name|rel_x
operator|=
name|new_x
operator|=
name|find_x
argument_list|(
name|line
argument_list|,
name|new_address
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust shift_count if new_x lower than 0 or higher than XBREAK */
if|if
condition|(
name|new_x
operator|<
literal|0
operator|||
name|new_x
operator|>=
name|XBREAK
condition|)
block|{
if|if
condition|(
name|new_x
operator|>
name|XBREAK
operator|||
operator|(
name|new_x
operator|==
name|XBREAK
operator|&&
operator|*
name|new_address
operator|!=
literal|'\n'
operator|)
condition|)
name|shift
operator|=
operator|(
name|new_x
operator|-
name|XBREAK
operator|)
operator|/
name|SHIFT_SIZE
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|shift
operator|=
name|new_x
operator|/
name|SHIFT_SIZE
expr_stmt|;
if|if
condition|(
name|new_x
operator|%
name|SHIFT_SIZE
condition|)
name|shift
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
block|{
name|line
operator|->
name|shift_count
operator|+=
name|shift
expr_stmt|;
name|new_x
operator|=
name|find_x
argument_list|(
name|line
argument_list|,
name|new_address
argument_list|)
expr_stmt|;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|rel_x
operator|=
name|new_x
expr_stmt|;
block|}
block|}
comment|/* Assign and position cursor */
name|x
operator|=
name|new_x
expr_stmt|;
name|cur_text
operator|=
name|new_address
expr_stmt|;
name|cur_line
operator|=
name|line
expr_stmt|;
name|set_cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find_x() returns the x coordinate belonging to address.  * (Tabs are expanded).  */
end_comment

begin_function
name|int
name|find_x
parameter_list|(
name|line
parameter_list|,
name|address
parameter_list|)
name|LINE
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|address
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|line
operator|->
name|text
decl_stmt|;
specifier|register
name|int
name|nx
init|=
name|get_shift
argument_list|(
name|line
operator|->
name|shift_count
argument_list|)
operator|*
operator|-
name|SHIFT_SIZE
decl_stmt|;
while|while
condition|(
name|textp
operator|!=
name|address
operator|&&
operator|*
name|textp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|is_tab
argument_list|(
operator|*
name|textp
operator|++
argument_list|)
condition|)
comment|/* Expand tabs */
name|nx
operator|=
name|tab
argument_list|(
name|nx
argument_list|)
expr_stmt|;
else|else
name|nx
operator|++
expr_stmt|;
block|}
return|return
name|nx
return|;
block|}
end_function

begin_comment
comment|/*  * Find_address() returns the pointer in the line with offset x_coord.  * (Tabs are expanded).  */
end_comment

begin_function
name|char
modifier|*
name|find_address
parameter_list|(
name|line
parameter_list|,
name|x_coord
parameter_list|,
name|old_x
parameter_list|)
name|LINE
modifier|*
name|line
decl_stmt|;
name|int
name|x_coord
decl_stmt|;
name|int
modifier|*
name|old_x
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|line
operator|->
name|text
decl_stmt|;
specifier|register
name|int
name|tx
init|=
name|get_shift
argument_list|(
name|line
operator|->
name|shift_count
argument_list|)
operator|*
operator|-
name|SHIFT_SIZE
decl_stmt|;
while|while
condition|(
name|tx
operator|<
name|x_coord
operator|&&
operator|*
name|textp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|is_tab
argument_list|(
operator|*
name|textp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|old_x
operator|-
name|x_coord
operator|==
literal|1
operator|&&
name|tab
argument_list|(
name|tx
argument_list|)
operator|>
name|x_coord
condition|)
break|break;
comment|/* Moving left over tab */
else|else
name|tx
operator|=
name|tab
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
name|tx
operator|++
expr_stmt|;
name|textp
operator|++
expr_stmt|;
block|}
operator|*
name|old_x
operator|=
name|tx
expr_stmt|;
return|return
name|textp
return|;
block|}
end_function

begin_comment
comment|/*  * Length_of() returns the number of characters int the string `string'  * excluding the '\0'.  */
end_comment

begin_function
name|int
name|length_of
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
operator|!=
name|NIL_PTR
condition|)
block|{
while|while
condition|(
operator|*
name|string
operator|++
operator|!=
literal|'\0'
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Copy_string() copies the string `from' into the string `to'. `To' must be  * long enough to hold `from'.  */
end_comment

begin_function
name|void
name|copy_string
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset assigns bot_line, top_line and cur_line according to `head_line'  * which must be the first line of the screen, and an y-coordinate,  * which will be the current y-coordinate (if it isn't larger than last_y)  */
end_comment

begin_function
name|void
name|reset
parameter_list|(
name|head_line
parameter_list|,
name|screen_y
parameter_list|)
name|LINE
modifier|*
name|head_line
decl_stmt|;
name|int
name|screen_y
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
name|top_line
operator|=
name|line
operator|=
name|head_line
expr_stmt|;
comment|/* Search for bot_line (might be last line in file) */
for|for
control|(
name|last_y
operator|=
literal|0
init|;
name|last_y
operator|<
name|nlines
operator|-
literal|1
operator|&&
name|last_y
operator|<
name|screenmax
operator|&&
name|line
operator|->
name|next
operator|!=
name|tail
condition|;
name|last_y
operator|++
control|)
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
name|bot_line
operator|=
name|line
expr_stmt|;
name|y
operator|=
operator|(
name|screen_y
operator|>
name|last_y
operator|)
condition|?
name|last_y
else|:
name|screen_y
expr_stmt|;
comment|/* Set cur_line according to the new y value */
name|cur_line
operator|=
name|proceed
argument_list|(
name|top_line
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set cursor at coordinates x, y.  */
end_comment

begin_function
name|void
name|set_cursor
parameter_list|(
name|nx
parameter_list|,
name|ny
parameter_list|)
name|int
name|nx
decl_stmt|,
name|ny
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|UNIX
specifier|extern
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|text_buffer
index|[
literal|10
index|]
decl_stmt|;
name|build_string
argument_list|(
name|text_buffer
argument_list|,
name|pos_string
argument_list|,
name|ny
operator|+
literal|1
argument_list|,
name|nx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string_print
argument_list|(
name|text_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
block|}
end_function

begin_comment
comment|/*  * Routine to open terminal when mined is used in a pipeline.  */
end_comment

begin_function
name|void
name|open_device
parameter_list|()
block|{
if|if
condition|(
operator|(
name|input_fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"Cannot open /dev/tty for read"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Getchar() reads one character from the terminal. The character must be  * masked with 0377 to avoid sign extension.  */
end_comment

begin_function
name|int
name|getchar
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|UNIX
return|return
operator|(
name|_getchar
argument_list|()
operator|&
literal|0377
operator|)
return|;
else|#
directive|else
name|char
name|c
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|input_fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|&&
name|quit
operator|==
name|FALSE
condition|)
name|panic
argument_list|(
literal|"Can't read one char from fd #0"
argument_list|)
expr_stmt|;
return|return
name|c
operator|&
literal|0377
return|;
endif|#
directive|endif
comment|/* UNIX */
block|}
end_function

begin_comment
comment|/*  * Display() shows count lines on the terminal starting at the given  * coordinates. When the tail of the list is encountered it will fill the  * rest of the screen with blank_line's.  * When count is negative, a backwards print from `line' will be done.  */
end_comment

begin_function
name|void
name|display
parameter_list|(
name|x_coord
parameter_list|,
name|y_coord
parameter_list|,
name|line
parameter_list|,
name|count
parameter_list|)
name|int
name|x_coord
decl_stmt|,
name|y_coord
decl_stmt|;
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
block|{
name|set_cursor
argument_list|(
name|x_coord
argument_list|,
name|y_coord
argument_list|)
expr_stmt|;
comment|/* Find new startline if count is negative */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|line
operator|=
name|proceed
argument_list|(
name|line
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
name|count
expr_stmt|;
block|}
comment|/* Print the lines */
while|while
condition|(
name|line
operator|!=
name|tail
operator|&&
name|count
operator|--
operator|>=
literal|0
condition|)
block|{
name|line
operator|->
name|shift_count
operator|=
literal|0
expr_stmt|;
name|line_print
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
block|}
comment|/* Print the blank lines (if any) */
if|if
condition|(
name|loading
operator|==
name|FALSE
condition|)
block|{
while|while
condition|(
name|count
operator|--
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Write_char does a buffered output.   */
end_comment

begin_function
name|int
name|write_char
parameter_list|(
name|fd
parameter_list|,
name|c
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
name|c
decl_stmt|;
block|{
name|screen
index|[
name|out_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|out_count
operator|==
name|SCREEN_SIZE
condition|)
comment|/* Flush on SCREEN_SIZE chars */
return|return
name|flush_buffer
argument_list|(
name|fd
argument_list|)
return|;
return|return
name|FINE
return|;
block|}
end_function

begin_comment
comment|/*  * Writeline writes the given string on the given filedescriptor.  */
end_comment

begin_function
name|int
name|writeline
parameter_list|(
name|fd
parameter_list|,
name|text
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|text
condition|)
if|if
condition|(
name|write_char
argument_list|(
name|fd
argument_list|,
operator|*
name|text
operator|++
argument_list|)
operator|==
name|ERRORS
condition|)
return|return
name|ERRORS
return|;
return|return
name|FINE
return|;
block|}
end_function

begin_comment
comment|/*  * Put_line print the given line on the standard output. If offset is not zero  * printing will start at that x-coordinate. If the FLAG clear_line is TRUE,  * then (screen) line will be cleared when the end of the line has been  * reached.  */
end_comment

begin_function
name|void
name|put_line
parameter_list|(
name|line
parameter_list|,
name|offset
parameter_list|,
name|clear_line
parameter_list|)
name|LINE
modifier|*
name|line
decl_stmt|;
comment|/* Line to print */
name|int
name|offset
decl_stmt|;
comment|/* Offset to start */
name|FLAG
name|clear_line
decl_stmt|;
comment|/* Clear to eoln if TRUE */
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|line
operator|->
name|text
decl_stmt|;
specifier|register
name|int
name|count
init|=
name|get_shift
argument_list|(
name|line
operator|->
name|shift_count
argument_list|)
operator|*
operator|-
name|SHIFT_SIZE
decl_stmt|;
name|int
name|tab_count
decl_stmt|;
comment|/* Used in tab expansion */
comment|/* Skip all chars as indicated by the offset and the shift_count field */
while|while
condition|(
name|count
operator|<
name|offset
condition|)
block|{
if|if
condition|(
name|is_tab
argument_list|(
operator|*
name|textp
operator|++
argument_list|)
condition|)
name|count
operator|=
name|tab
argument_list|(
name|count
argument_list|)
expr_stmt|;
else|else
name|count
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|textp
operator|!=
literal|'\n'
operator|&&
name|count
operator|<
name|XBREAK
condition|)
block|{
if|if
condition|(
name|is_tab
argument_list|(
operator|*
name|textp
argument_list|)
condition|)
block|{
comment|/* Expand tabs to spaces */
name|tab_count
operator|=
name|tab
argument_list|(
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|XBREAK
operator|&&
name|count
operator|<
name|tab_count
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|textp
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|textp
operator|>=
literal|'\01'
operator|&&
operator|*
name|textp
operator|<=
literal|'\037'
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|SO
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|rev_video
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|putchar
argument_list|(
operator|*
name|textp
operator|++
operator|+
literal|'\100'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|SE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|normal_video
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
block|}
else|else
name|putchar
argument_list|(
operator|*
name|textp
operator|++
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* If line is longer than XBREAK chars, print the shift_mark */
if|if
condition|(
name|count
operator|==
name|XBREAK
operator|&&
operator|*
name|textp
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
name|textp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|?
operator|*
name|textp
else|:
name|SHIFT_MARK
argument_list|)
expr_stmt|;
comment|/* Clear the rest of the line is clear_line is TRUE */
if|if
condition|(
name|clear_line
operator|==
name|TRUE
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Flush the I/O buffer on filedescriptor fd.  */
end_comment

begin_function
name|int
name|flush_buffer
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|out_count
operator|<=
literal|0
condition|)
comment|/* There is nothing to flush */
return|return
name|FINE
return|;
ifdef|#
directive|ifdef
name|UNIX
if|if
condition|(
name|fd
operator|==
name|STD_OUT
condition|)
block|{
name|printf
argument_list|(
literal|"%.*s"
argument_list|,
name|out_count
argument_list|,
name|screen
argument_list|)
expr_stmt|;
name|_flush
argument_list|()
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|screen
argument_list|,
name|out_count
argument_list|)
operator|!=
name|out_count
condition|)
block|{
name|bad_write
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
name|clear_buffer
argument_list|()
expr_stmt|;
comment|/* Empty buffer */
return|return
name|FINE
return|;
block|}
end_function

begin_comment
comment|/*  * Bad_write() is called when a write failed. Notify the user.  */
end_comment

begin_function
name|void
name|bad_write
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|fd
operator|==
name|STD_OUT
condition|)
comment|/* Cannot write to terminal? */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|clear_buffer
argument_list|()
expr_stmt|;
name|build_string
argument_list|(
name|text_buffer
argument_list|,
literal|"Command aborted: %s (File incomplete)"
argument_list|,
operator|(
name|errno
operator|==
name|ENOSPC
operator|||
name|errno
operator|==
operator|-
name|ENOSPC
operator|)
condition|?
literal|"No space on device"
else|:
literal|"Write error"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|text_buffer
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Catch the SIGQUIT signal (^\) send to mined. It turns on the quitflag.  */
end_comment

begin_function
name|void
name|catch
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* Reset the signal */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
name|quit
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort_mined() will leave mined. Confirmation is asked first.  */
end_comment

begin_function
name|void
name|abort_mined
parameter_list|()
block|{
name|quit
operator|=
name|FALSE
expr_stmt|;
comment|/* Ask for confirmation */
name|status_line
argument_list|(
literal|"Really abort? "
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'y'
condition|)
block|{
name|clear_status
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Reset terminal */
name|raw_mode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
block|}
end_function

begin_define
define|#
directive|define
name|UNDEF
value|_POSIX_VDISABLE
end_define

begin_comment
comment|/*  * Set and reset tty into CBREAK or old mode according to argument `state'. It  * also sets all signal characters (except for ^\) to UNDEF. ^\ is caught.  */
end_comment

begin_function
name|void
name|raw_mode
parameter_list|(
name|state
parameter_list|)
name|FLAG
name|state
decl_stmt|;
block|{
specifier|static
name|struct
name|termios
name|old_tty
decl_stmt|;
specifier|static
name|struct
name|termios
name|new_tty
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|OFF
condition|)
block|{
name|tcsetattr
argument_list|(
name|input_fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|old_tty
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Save old tty settings */
name|tcgetattr
argument_list|(
name|input_fd
argument_list|,
operator|&
name|old_tty
argument_list|)
expr_stmt|;
comment|/* Set tty to CBREAK mode */
name|tcgetattr
argument_list|(
name|input_fd
argument_list|,
operator|&
name|new_tty
argument_list|)
expr_stmt|;
name|new_tty
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator||
name|ECHONL
operator|)
expr_stmt|;
name|new_tty
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IXON
operator||
name|IXOFF
operator|)
expr_stmt|;
comment|/* Unset signal chars, leave only SIGQUIT set to ^\ */
name|new_tty
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|new_tty
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
name|UNDEF
expr_stmt|;
name|new_tty
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
literal|'\\'
operator|&
literal|037
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
comment|/* Which is caught */
name|tcsetattr
argument_list|(
name|input_fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|new_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Panic() is called with an error number and a message. It is called when  * something unrecoverable has happened.  * It writes the message to the terminal, resets the tty and exits.  * Ask the user if he wants to save his file.  */
end_comment

begin_function
name|void
name|panic
parameter_list|(
name|message
parameter_list|)
specifier|register
name|char
modifier|*
name|message
decl_stmt|;
block|{
specifier|extern
name|char
name|yank_file
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|CL
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
name|build_string
argument_list|(
name|text_buffer
argument_list|,
literal|"%s\nError code %d\n"
argument_list|,
name|message
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|build_string
argument_list|(
name|text_buffer
argument_list|,
literal|"%s%s\nError code %d\n"
argument_list|,
name|enter_string
argument_list|,
name|message
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
operator|(
name|void
operator|)
name|write
argument_list|(
name|STD_OUT
argument_list|,
name|text_buffer
argument_list|,
name|length_of
argument_list|(
name|text_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loading
operator|==
name|FALSE
condition|)
name|XT
argument_list|()
expr_stmt|;
comment|/* Check if file can be saved */
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|yank_file
argument_list|)
expr_stmt|;
name|raw_mode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
block|}
end_function

begin_function
name|char
modifier|*
name|alloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NIL_PTR
condition|)
block|{
if|if
condition|(
name|loading
operator|==
name|TRUE
condition|)
name|panic
argument_list|(
literal|"File too big."
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Out of memory."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_space
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  ========================================================================  *  *				Main loops				      *  *  ========================================================================  */
end_comment

begin_comment
comment|/* The mapping between input codes and functions. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|key_map
index|[
literal|256
index|]
function_decl|)
parameter_list|()
init|=
block|{
comment|/* map ASCII characters to functions */
comment|/* 000-017 */
name|MA
operator|,
function_decl|BL
operator|,
function_decl|MP
operator|,
function_decl|YA
operator|,
function_decl|SD
operator|,
function_decl|RD
operator|,
function_decl|MN
operator|,
function_decl|IF
operator|,
function_decl|DPC
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|DT
operator|,
function_decl|LR
operator|,
function_decl|S
operator|,
function_decl|DNW
operator|,
function_decl|LIB
operator|,
comment|/* 020-037 */
function_decl|DPW
operator|,
function_decl|WB
operator|,
function_decl|GR
operator|,
function_decl|SH
operator|,
function_decl|DLN
operator|,
function_decl|SU
operator|,
function_decl|VI
operator|,
function_decl|XWT
operator|,
function_decl|XT
operator|,
function_decl|PT
operator|,
function_decl|EL
operator|,
function_decl|ESC
operator|,
function_decl|I
operator|,
function_decl|GOTO
operator|,
function_decl|HIGH
operator|,
function_decl|LOW
operator|,
comment|/* 040-057 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 060-077 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 100-117 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 120-137 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 140-157 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 160-177 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|DCC
operator|,
comment|/* 200-217 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 220-237 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 240-257 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 260-277 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 300-317 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 320-337 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 340-357 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
comment|/* 360-377 */
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
function_decl|S
operator|,
end_function_decl

begin_decl_stmt
unit|};
name|int
name|nlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines in file */
end_comment

begin_decl_stmt
name|LINE
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of line list */
end_comment

begin_decl_stmt
name|LINE
modifier|*
name|tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last line in line list */
end_comment

begin_decl_stmt
name|LINE
modifier|*
name|cur_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line in use */
end_comment

begin_decl_stmt
name|LINE
modifier|*
name|top_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line of screen */
end_comment

begin_decl_stmt
name|LINE
modifier|*
name|bot_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last line of screen */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cur_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current char on current line in use */
end_comment

begin_decl_stmt
name|int
name|last_y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last y of screen. Usually SCREENMAX */
end_comment

begin_decl_stmt
name|char
name|screen
index|[
name|SCREEN_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output buffer for "writes" and "reads" */
end_comment

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* x, y coordinates on screen */
end_comment

begin_decl_stmt
name|FLAG
name|modified
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when file is modified */
end_comment

begin_decl_stmt
name|FLAG
name|stat_visible
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if status_line is visible */
end_comment

begin_decl_stmt
name|FLAG
name|writable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if file cannot be written */
end_comment

begin_decl_stmt
name|FLAG
name|loading
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if we are loading a file. */
end_comment

begin_decl_stmt
name|FLAG
name|quit
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when quit character is typed */
end_comment

begin_decl_stmt
name|FLAG
name|rpipe
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if file should be read from stdin */
end_comment

begin_decl_stmt
name|int
name|input_fd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fd for command input */
end_comment

begin_decl_stmt
name|int
name|out_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in output buffer */
end_comment

begin_decl_stmt
name|char
name|file_name
index|[
name|LINE_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of file in use */
end_comment

begin_decl_stmt
name|char
name|text_buffer
index|[
name|MAX_CHARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for modifying text */
end_comment

begin_comment
comment|/* Escape sequences. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|CE
decl_stmt|,
modifier|*
name|VS
decl_stmt|,
modifier|*
name|SO
decl_stmt|,
modifier|*
name|SE
decl_stmt|,
modifier|*
name|CL
decl_stmt|,
modifier|*
name|AL
decl_stmt|,
modifier|*
name|CM
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|enter_string
init|=
literal|"\033[H\033[J"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String printed on entering mined */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pos_string
init|=
literal|"\033[%d;%dH"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Absolute cursor position */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rev_scroll
init|=
literal|"\033M"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String for reverse scrolling */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rev_video
init|=
literal|"\033[7m"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String for starting reverse video */
end_comment

begin_decl_stmt
name|char
modifier|*
name|normal_video
init|=
literal|"\033[m"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String for leaving reverse video */
end_comment

begin_decl_stmt
name|char
modifier|*
name|blank_line
init|=
literal|"\033[K"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear line to end */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_comment
comment|/*   * Yank variables.  */
end_comment

begin_decl_stmt
name|FLAG
name|yank_status
init|=
name|NOT_VALID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status of yank_file */
end_comment

begin_decl_stmt
name|char
name|yank_file
index|[]
init|=
literal|"/tmp/mined.XXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|chars_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nr of chars in buffer */
end_comment

begin_comment
comment|/*  * Initialize is called when a another file is edited. It free's the allocated  * space and sets modified back to FALSE and fixes the header/tail pointer.  */
end_comment

begin_function
name|void
name|initialize
parameter_list|()
block|{
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|,
modifier|*
name|next_line
decl_stmt|;
comment|/* Delete the whole list */
for|for
control|(
name|line
operator|=
name|header
operator|->
name|next
init|;
name|line
operator|!=
name|tail
condition|;
name|line
operator|=
name|next_line
control|)
block|{
name|next_line
operator|=
name|line
operator|->
name|next
expr_stmt|;
name|free_space
argument_list|(
name|line
operator|->
name|text
argument_list|)
expr_stmt|;
name|free_space
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* header and tail should point to itself */
name|line
operator|->
name|next
operator|=
name|line
operator|->
name|prev
operator|=
name|line
expr_stmt|;
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
name|rpipe
operator|=
name|modified
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Basename() finds the absolute name of the file out of a given path_name.  */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|last
init|=
name|NIL_PTR
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
name|last
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NIL_PTR
condition|)
return|return
name|path
return|;
if|if
condition|(
operator|*
operator|(
name|last
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* E.g. /usr/tmp/pipo/ */
operator|*
name|last
operator|=
literal|'\0'
expr_stmt|;
return|return
name|basename
argument_list|(
name|path
argument_list|)
return|;
comment|/* Try again */
block|}
return|return
name|last
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Load_file loads the file `file' into core. If file is a NIL_PTR or the file  * couldn't be opened, just some initializations are done, and a line consisting  * of a `\n' is installed.  */
end_comment

begin_function
name|void
name|load_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|line
init|=
name|header
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|long
name|nr_of_chars
init|=
literal|0L
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Filedescriptor for file */
name|nlines
operator|=
literal|0
expr_stmt|;
comment|/* Zero lines to start with */
comment|/* Open file */
name|writable
operator|=
name|TRUE
expr_stmt|;
comment|/* Benefit of the doubt */
if|if
condition|(
name|file
operator|==
name|NIL_PTR
condition|)
block|{
if|if
condition|(
name|rpipe
operator|==
name|FALSE
condition|)
name|status_line
argument_list|(
literal|"No file."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
else|else
block|{
name|fd
operator|=
literal|0
expr_stmt|;
name|file
operator|=
literal|"standard input"
expr_stmt|;
block|}
name|file_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|copy_string
argument_list|(
name|file_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Save file name */
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
comment|/* Cannot access file. */
name|status_line
argument_list|(
literal|"New file "
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|status_line
argument_list|(
literal|"Cannot open "
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Set write flag */
name|writable
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Read file */
name|loading
operator|=
name|TRUE
expr_stmt|;
comment|/* Loading file, so set flag */
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|status_line
argument_list|(
literal|"Reading "
argument_list|,
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|get_line
argument_list|(
name|fd
argument_list|,
name|text_buffer
argument_list|)
operator|)
operator|!=
name|ERRORS
condition|)
block|{
name|line
operator|=
name|line_insert
argument_list|(
name|line
argument_list|,
name|text_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nr_of_chars
operator|+=
operator|(
name|long
operator|)
name|len
expr_stmt|;
block|}
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
comment|/* The file was empty! */
name|line
operator|=
name|line_insert
argument_list|(
name|line
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clear_buffer
argument_list|()
expr_stmt|;
comment|/* Clear output buffer */
name|cur_line
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|fstatus
argument_list|(
literal|"Read"
argument_list|,
name|nr_of_chars
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Close file */
block|}
else|else
comment|/* Just install a "\n" */
operator|(
name|void
operator|)
name|line_insert
argument_list|(
name|line
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reset
argument_list|(
name|header
operator|->
name|next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize pointers */
comment|/* Print screen */
name|display
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|header
operator|->
name|next
argument_list|,
name|last_y
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Flush buffer */
name|loading
operator|=
name|FALSE
expr_stmt|;
comment|/* Stop loading, reset flag */
block|}
end_function

begin_comment
comment|/*  * Get_line reads one line from filedescriptor fd. If EOF is reached on fd,  * get_line() returns ERRORS, else it returns the length of the string.  */
end_comment

begin_function
name|int
name|get_line
parameter_list|(
name|fd
parameter_list|,
name|buffer
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|last
init|=
name|NIL_PTR
decl_stmt|;
specifier|static
name|char
modifier|*
name|current
init|=
name|NIL_PTR
decl_stmt|;
specifier|static
name|int
name|read_chars
decl_stmt|;
specifier|register
name|char
modifier|*
name|cur_pos
init|=
name|current
decl_stmt|;
name|char
modifier|*
name|begin
init|=
name|buffer
decl_stmt|;
do|do
block|{
if|if
condition|(
name|cur_pos
operator|==
name|last
condition|)
block|{
if|if
condition|(
operator|(
name|read_chars
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|screen
argument_list|,
name|SCREEN_SIZE
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
name|last
operator|=
operator|&
name|screen
index|[
name|read_chars
index|]
expr_stmt|;
name|cur_pos
operator|=
name|screen
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cur_pos
operator|==
literal|'\0'
condition|)
operator|*
name|cur_pos
operator|=
literal|' '
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|buffer
operator|++
operator|=
operator|*
name|cur_pos
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
do|;
name|current
operator|=
name|cur_pos
expr_stmt|;
if|if
condition|(
name|read_chars
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|buffer
operator|==
name|begin
condition|)
return|return
name|ERRORS
return|;
if|if
condition|(
operator|*
operator|(
name|buffer
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|loading
operator|==
name|TRUE
condition|)
comment|/* Add '\n' to last line of file */
operator|*
name|buffer
operator|++
operator|=
literal|'\n'
expr_stmt|;
else|else
block|{
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|NO_LINE
return|;
block|}
block|}
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
operator|-
name|begin
return|;
block|}
end_function

begin_comment
comment|/*  * Install_line installs the buffer into a LINE structure It returns a pointer  * to the allocated structure.  */
end_comment

begin_function
name|LINE
modifier|*
name|install_line
parameter_list|(
name|buffer
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|new_line
init|=
operator|(
name|LINE
operator|*
operator|)
name|alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LINE
argument_list|)
argument_list|)
decl_stmt|;
name|new_line
operator|->
name|text
operator|=
name|alloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_line
operator|->
name|shift_count
operator|=
literal|0
expr_stmt|;
name|copy_string
argument_list|(
name|new_line
operator|->
name|text
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|new_line
return|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
comment|/* mined is the Minix editor. */
specifier|register
name|int
name|index
decl_stmt|;
comment|/* Index in key table */
name|struct
name|winsize
name|winsize
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|get_term
argument_list|()
expr_stmt|;
name|tputs
argument_list|(
name|VS
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|CL
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|enter_string
argument_list|)
expr_stmt|;
comment|/* Hello world */
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|ioctl
argument_list|(
name|STD_OUT
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|winsize
argument_list|)
operator|==
literal|0
operator|&&
name|winsize
operator|.
name|ws_row
operator|!=
literal|0
condition|)
block|{
name|ymax
operator|=
name|winsize
operator|.
name|ws_row
operator|-
literal|1
expr_stmt|;
name|screenmax
operator|=
name|ymax
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|/* Reading from pipe */
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Cannot find terminal.\n"
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rpipe
operator|=
name|TRUE
expr_stmt|;
name|modified
operator|=
name|TRUE
expr_stmt|;
comment|/* Set modified so he can write */
name|open_device
argument_list|()
expr_stmt|;
block|}
name|raw_mode
argument_list|(
name|ON
argument_list|)
expr_stmt|;
comment|/* Set tty to appropriate mode */
name|header
operator|=
name|tail
operator|=
operator|(
name|LINE
operator|*
operator|)
name|alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LINE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make header of list*/
name|header
operator|->
name|text
operator|=
name|NIL_PTR
expr_stmt|;
name|header
operator|->
name|next
operator|=
name|tail
operator|->
name|prev
operator|=
name|header
expr_stmt|;
comment|/* Load the file (if any) */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|load_file
argument_list|(
name|NIL_PTR
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|get_file
argument_list|(
name|NIL_PTR
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Truncate filename */
name|load_file
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Main loop of the editor. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|index
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat_visible
operator|==
name|TRUE
condition|)
name|clear_status
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit
operator|==
name|TRUE
condition|)
name|abort_mined
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* Call the function for this key */
call|(
modifier|*
name|key_map
index|[
name|index
index|]
call|)
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Flush output (if any) */
if|if
condition|(
name|quit
operator|==
name|TRUE
condition|)
name|quit
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  ========================================================================  *  *				Miscellaneous				      *  *  ========================================================================  */
end_comment

begin_comment
comment|/*  * Redraw the screen  */
end_comment

begin_function
name|void
name|RD
parameter_list|()
block|{
comment|/* Clear screen */
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|VS
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|CL
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|enter_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
comment|/* Print first page */
name|display
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|top_line
argument_list|,
name|last_y
argument_list|)
expr_stmt|;
comment|/* Clear last line */
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|move_to
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ignore this keystroke.  */
end_comment

begin_function
name|void
name|I
parameter_list|()
block|{ }
end_function

begin_comment
comment|/*  * Leave editor. If the file has changed, ask if the user wants to save it.  */
end_comment

begin_function
name|void
name|XT
parameter_list|()
block|{
if|if
condition|(
name|modified
operator|==
name|TRUE
operator|&&
name|ask_save
argument_list|()
operator|==
name|ERRORS
condition|)
return|return;
name|raw_mode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|yank_file
argument_list|)
expr_stmt|;
comment|/* Might not be necessary */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|void
argument_list|(
argument|*escfunc(c)
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|#
directive|if
operator|(
name|CHIP
operator|==
name|M68000
operator|)
ifndef|#
directive|ifndef
name|COMPAT
name|int
name|ch
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
comment|/* Start of ASCII escape sequence. */
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|CHIP
operator|==
name|M68000
operator|)
ifndef|#
directive|ifndef
name|COMPAT
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* ch is either a tilde or a second digit */
endif|#
directive|endif
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'H'
case|:
return|return
operator|(
name|HO
operator|)
return|;
case|case
literal|'A'
case|:
return|return
operator|(
name|UP
operator|)
return|;
case|case
literal|'B'
case|:
return|return
operator|(
name|DN
operator|)
return|;
case|case
literal|'C'
case|:
return|return
operator|(
name|RT
operator|)
return|;
case|case
literal|'D'
case|:
return|return
operator|(
name|LF
operator|)
return|;
if|#
directive|if
operator|(
name|CHIP
operator|==
name|M68000
operator|)
ifndef|#
directive|ifndef
name|COMPAT
comment|/* F1 = ESC [ 1 ~ */
comment|/* F2 = ESC [ 2 ~ */
comment|/* F3 = ESC [ 3 ~ */
comment|/* F4 = ESC [ 4 ~ */
comment|/* F5 = ESC [ 5 ~ */
comment|/* F6 = ESC [ 6 ~ */
comment|/* F7 = ESC [ 17 ~ */
comment|/* F8 = ESC [ 18 ~ */
case|case
literal|'1'
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'~'
case|:
return|return
operator|(
name|SF
operator|)
return|;
case|case
literal|'7'
case|:
operator|(
name|void
operator|)
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|MA
operator|)
return|;
case|case
literal|'8'
case|:
operator|(
name|void
operator|)
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|CTL
operator|)
return|;
block|}
case|case
literal|'2'
case|:
return|return
operator|(
name|SR
operator|)
return|;
case|case
literal|'3'
case|:
return|return
operator|(
name|PD
operator|)
return|;
case|case
literal|'4'
case|:
return|return
operator|(
name|PU
operator|)
return|;
case|case
literal|'5'
case|:
return|return
operator|(
name|FS
operator|)
return|;
case|case
literal|'6'
case|:
return|return
operator|(
name|EF
operator|)
return|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|(
name|CHIP
operator|==
name|INTEL
operator|)
ifdef|#
directive|ifdef
name|ASSUME_CONS25
case|case
literal|'G'
case|:
return|return
operator|(
name|PD
operator|)
return|;
case|case
literal|'I'
case|:
return|return
operator|(
name|PU
operator|)
return|;
case|case
literal|'F'
case|:
return|return
operator|(
name|EF
operator|)
return|;
comment|/* F1 - help */
case|case
literal|'M'
case|:
return|return
operator|(
name|HLP
operator|)
return|;
comment|/* F2 - file status */
case|case
literal|'N'
case|:
return|return
operator|(
name|FS
operator|)
return|;
comment|/* F3 - search fwd */
case|case
literal|'O'
case|:
return|return
operator|(
name|SF
operator|)
return|;
comment|/* Shift-F3 - search back */
case|case
literal|'a'
case|:
return|return
operator|(
name|SR
operator|)
return|;
comment|/* F4 - global replace */
case|case
literal|'P'
case|:
return|return
operator|(
name|GR
operator|)
return|;
comment|/* Shift-F4 - line replace */
case|case
literal|'b'
case|:
return|return
operator|(
name|LR
operator|)
return|;
else|#
directive|else
case|case
literal|'G'
case|:
return|return
operator|(
name|FS
operator|)
return|;
case|case
literal|'S'
case|:
return|return
operator|(
name|SR
operator|)
return|;
case|case
literal|'T'
case|:
return|return
operator|(
name|SF
operator|)
return|;
case|case
literal|'U'
case|:
return|return
operator|(
name|PD
operator|)
return|;
case|case
literal|'V'
case|:
return|return
operator|(
name|PU
operator|)
return|;
case|case
literal|'Y'
case|:
return|return
operator|(
name|EF
operator|)
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
return|return
operator|(
name|I
operator|)
return|;
block|}
if|#
directive|if
operator|(
name|CHIP
operator|==
name|M68000
operator|)
ifdef|#
directive|ifdef
name|COMPAT
if|if
condition|(
name|c
operator|==
literal|'O'
condition|)
block|{
comment|/* Start of ASCII function key escape sequence. */
switch|switch
condition|(
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'P'
case|:
return|return
operator|(
name|SF
operator|)
return|;
case|case
literal|'Q'
case|:
return|return
operator|(
name|SR
operator|)
return|;
case|case
literal|'R'
case|:
return|return
operator|(
name|PD
operator|)
return|;
case|case
literal|'S'
case|:
return|return
operator|(
name|PU
operator|)
return|;
case|case
literal|'T'
case|:
return|return
operator|(
name|FS
operator|)
return|;
case|case
literal|'U'
case|:
return|return
operator|(
name|EF
operator|)
return|;
case|case
literal|'V'
case|:
return|return
operator|(
name|MA
operator|)
return|;
case|case
literal|'W'
case|:
return|return
operator|(
name|CTL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|I
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * ESC() wants a count and a command after that. It repeats the   * command count times. If a ^\ is given during repeating, stop looping and  * return to main loop.  */
end_comment

begin_function
name|void
name|ESC
parameter_list|()
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|index
operator|>=
literal|'0'
operator|&&
name|index
operator|<=
literal|'9'
operator|&&
name|quit
operator|==
name|FALSE
condition|)
block|{
name|count
operator|*=
literal|10
expr_stmt|;
name|count
operator|+=
name|index
operator|-
literal|'0'
expr_stmt|;
name|index
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|func
operator|=
name|escfunc
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
operator|=
name|key_map
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|ESC
condition|)
name|func
operator|=
name|escfunc
argument_list|(
name|getchar
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|==
name|I
condition|)
block|{
comment|/* Function assigned? */
name|clear_status
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
operator|--
operator|>
literal|0
operator|&&
name|quit
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|stat_visible
operator|==
name|TRUE
condition|)
name|clear_status
argument_list|()
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|quit
operator|==
name|TRUE
condition|)
comment|/* Abort has been given */
name|error
argument_list|(
literal|"Aborted"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ask the user if he wants to save his file or not.  */
end_comment

begin_function
name|int
name|ask_save
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|status_line
argument_list|(
name|file_name
index|[
literal|0
index|]
condition|?
name|basename
argument_list|(
name|file_name
argument_list|)
else|:
literal|"[buffer]"
argument_list|,
literal|" has been modified. Save? (y/n)"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'y'
operator|&&
name|c
operator|!=
literal|'n'
operator|&&
name|quit
operator|==
name|FALSE
condition|)
block|{
name|ring_bell
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|clear_status
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
condition|)
return|return
name|WT
argument_list|()
return|;
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
return|return
name|FINE
return|;
name|quit
operator|=
name|FALSE
expr_stmt|;
comment|/* Abort character has been given */
return|return
name|ERRORS
return|;
block|}
end_function

begin_comment
comment|/*  * Line_number() finds the line number we're on.  */
end_comment

begin_function
name|int
name|line_number
parameter_list|()
block|{
specifier|register
name|LINE
modifier|*
name|line
init|=
name|header
operator|->
name|next
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|line
operator|!=
name|cur_line
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Display a line telling how many chars and lines the file contains. Also tell  * whether the file is readonly and/or modified.  */
end_comment

begin_function
name|void
name|file_status
parameter_list|(
name|message
parameter_list|,
name|count
parameter_list|,
name|file
parameter_list|,
name|lines
parameter_list|,
name|writefl
parameter_list|,
name|changed
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
specifier|register
name|long
name|count
decl_stmt|;
comment|/* Contains number of characters in file */
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|lines
decl_stmt|;
name|FLAG
name|writefl
decl_stmt|,
name|changed
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
name|char
name|msg
index|[
name|LINE_LEN
operator|+
literal|40
index|]
decl_stmt|;
comment|/* Buffer to hold line */
name|char
name|yank_msg
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Buffer for msg of yank_file */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
comment|/* Not valid. Count chars in file */
for|for
control|(
name|line
operator|=
name|header
operator|->
name|next
init|;
name|line
operator|!=
name|tail
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
name|count
operator|+=
name|length_of
argument_list|(
name|line
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|yank_status
operator|!=
name|NOT_VALID
condition|)
comment|/* Append buffer info */
name|build_string
argument_list|(
name|yank_msg
argument_list|,
literal|" Buffer: %D char%s."
argument_list|,
name|chars_saved
argument_list|,
operator|(
name|chars_saved
operator|==
literal|1L
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
else|else
name|yank_msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|build_string
argument_list|(
name|msg
argument_list|,
literal|"%s %s%s%s %d line%s %D char%s.%s Line %d"
argument_list|,
name|message
argument_list|,
operator|(
name|rpipe
operator|==
name|TRUE
operator|&&
operator|*
name|message
operator|!=
literal|'['
operator|)
condition|?
literal|"standard input"
else|:
name|basename
argument_list|(
name|file
argument_list|)
argument_list|,
operator|(
name|changed
operator|==
name|TRUE
operator|)
condition|?
literal|"*"
else|:
literal|""
argument_list|,
operator|(
name|writefl
operator|==
name|FALSE
operator|)
condition|?
literal|" (Readonly)"
else|:
literal|""
argument_list|,
name|lines
argument_list|,
operator|(
name|lines
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|count
argument_list|,
operator|(
name|count
operator|==
literal|1L
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|yank_msg
argument_list|,
name|line_number
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|length_of
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
operator|>
name|LINE_LEN
operator|-
literal|4
condition|)
block|{
name|msg
index|[
name|LINE_LEN
operator|-
literal|4
index|]
operator|=
name|SHIFT_MARK
expr_stmt|;
comment|/* Overflow on status line */
name|msg
index|[
name|LINE_LEN
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|status_line
argument_list|(
name|msg
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
comment|/* Print the information */
block|}
end_function

begin_comment
comment|/*  * Build_string() prints the arguments as described in fmt, into the buffer.  * %s indicates an argument string, %d indicated an argument number.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|build_string
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
else|#
directive|else
name|void
name|build_string
parameter_list|(
name|buf
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
name|va_dcl
block|{
endif|#
directive|endif
name|va_list
name|argptr
decl_stmt|;
name|char
modifier|*
name|scanp
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|argptr
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|fmt
condition|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
name|scanp
operator|=
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|scanp
operator|=
name|num_out
argument_list|(
operator|(
name|long
operator|)
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|scanp
operator|=
name|num_out
argument_list|(
operator|(
name|long
operator|)
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|long
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default :
name|scanp
operator|=
literal|""
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|buf
operator|++
operator|=
operator|*
name|scanp
operator|++
condition|)
empty_stmt|;
name|buf
operator|--
expr_stmt|;
block|}
else|else
operator|*
name|buf
operator|++
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*  * Output an (unsigned) long in a 10 digit field without leading zeros.  * It returns a pointer to the first digit in the buffer.  */
name|char
modifier|*
name|num_out
parameter_list|(
name|number
parameter_list|)
name|long
name|number
decl_stmt|;
block|{
specifier|static
name|char
name|num_buf
index|[
literal|11
index|]
decl_stmt|;
comment|/* Buffer to build number */
specifier|register
name|long
name|digit
decl_stmt|;
comment|/* Next digit of number */
specifier|register
name|long
name|pow
init|=
literal|1000000000L
decl_stmt|;
comment|/* Highest ten power of long */
name|FLAG
name|digit_seen
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|digit
operator|=
name|number
operator|/
name|pow
expr_stmt|;
comment|/* Get next digit */
if|if
condition|(
name|digit
operator|==
literal|0L
operator|&&
name|digit_seen
operator|==
name|FALSE
operator|&&
name|i
operator|!=
literal|9
condition|)
name|num_buf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
else|else
block|{
name|num_buf
index|[
name|i
index|]
operator|=
literal|'0'
operator|+
operator|(
name|char
operator|)
name|digit
expr_stmt|;
name|number
operator|-=
name|digit
operator|*
name|pow
expr_stmt|;
comment|/* Erase digit */
name|digit_seen
operator|=
name|TRUE
expr_stmt|;
block|}
name|pow
operator|/=
literal|10L
expr_stmt|;
comment|/* Get next digit */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|num_buf
index|[
name|i
index|]
operator|==
literal|' '
condition|;
name|i
operator|++
control|)
comment|/* Skip leading spaces */
empty_stmt|;
return|return
operator|(
operator|&
name|num_buf
index|[
name|i
index|]
operator|)
return|;
block|}
comment|/*  * Get_number() read a number from the terminal. The last character typed in is  * returned.  ERRORS is returned on a bad number. The resulting number is put  * into the integer the arguments points to.  */
name|int
name|get_number
parameter_list|(
name|message
parameter_list|,
name|result
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|int
modifier|*
name|result
decl_stmt|;
block|{
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
name|status_line
argument_list|(
name|message
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
name|index
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit
operator|==
name|FALSE
operator|&&
operator|(
name|index
operator|<
literal|'0'
operator|||
name|index
operator|>
literal|'9'
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Bad count"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
comment|/* Convert input to a decimal number */
while|while
condition|(
name|index
operator|>=
literal|'0'
operator|&&
name|index
operator|<=
literal|'9'
operator|&&
name|quit
operator|==
name|FALSE
condition|)
block|{
name|count
operator|*=
literal|10
expr_stmt|;
name|count
operator|+=
name|index
operator|-
literal|'0'
expr_stmt|;
name|index
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|quit
operator|==
name|TRUE
condition|)
block|{
name|clear_status
argument_list|()
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
operator|*
name|result
operator|=
name|count
expr_stmt|;
return|return
name|index
return|;
block|}
comment|/*  * Input() reads a string from the terminal.  When the KILL character is typed,  * it returns ERRORS.  */
name|int
name|input
parameter_list|(
name|inbuf
parameter_list|,
name|clearfl
parameter_list|)
name|char
modifier|*
name|inbuf
decl_stmt|;
name|FLAG
name|clearfl
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
comment|/* Character read */
name|ptr
operator|=
name|inbuf
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|quit
operator|==
name|FALSE
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'\b'
case|:
comment|/* Erase previous char */
if|if
condition|(
name|ptr
operator|>
name|inbuf
condition|)
block|{
name|ptr
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|SE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|normal_video
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|is_tab
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|string_print
argument_list|(
literal|" \b\b\b  \b\b"
argument_list|)
expr_stmt|;
else|else
name|string_print
argument_list|(
literal|" \b\b \b"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|SO
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|rev_video
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|string_print
argument_list|(
literal|" \b"
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|ring_bell
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* End of input */
comment|/* If inbuf is empty clear status_line */
return|return
operator|(
name|ptr
operator|==
name|inbuf
operator|&&
name|clearfl
operator|==
name|TRUE
operator|)
condition|?
name|NO_INPUT
else|:
name|FINE
return|;
default|default :
comment|/* Only read ASCII chars */
if|if
condition|(
operator|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
operator|)
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|string_print
argument_list|(
literal|"^I"
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|string_print
argument_list|(
literal|" \b"
argument_list|)
expr_stmt|;
block|}
else|else
name|ring_bell
argument_list|()
expr_stmt|;
block|}
block|}
name|quit
operator|=
name|FALSE
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
comment|/*  * Get_file() reads a filename from the terminal. Filenames longer than   * FILE_LENGHT chars are truncated.  */
name|int
name|get_file
parameter_list|(
name|message
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|,
decl|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|message
operator|==
name|NIL_PTR
operator|||
operator|(
name|ret
operator|=
name|get_string
argument_list|(
name|message
argument_list|,
name|file
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|FINE
condition|)
block|{
if|if
condition|(
name|length_of
argument_list|(
operator|(
name|ptr
operator|=
name|basename
argument_list|(
name|file
argument_list|)
operator|)
argument_list|)
operator|>
name|NAME_MAX
condition|)
name|ptr
index|[
name|NAME_MAX
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/*  ========================================================================  *  *				UNIX I/O Routines			      *  *  ========================================================================  */
ifdef|#
directive|ifdef
name|UNIX
undef|#
directive|undef
name|putchar
name|int
name|_getchar
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|input_fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|&&
name|quit
operator|==
name|FALSE
condition|)
name|panic
argument_list|(
literal|"Cannot read 1 byte from input"
argument_list|)
expr_stmt|;
return|return
name|c
operator|&
literal|0377
return|;
block|}
name|void
name|_flush
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|void
name|_putchar
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|write_char
argument_list|(
name|STD_OUT
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|void
name|get_term
parameter_list|()
block|{
specifier|static
name|char
name|termbuf
index|[
literal|50
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|tgetstr
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
name|char
modifier|*
name|loc
init|=
name|termbuf
decl_stmt|;
name|char
name|entry
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|tgetent
argument_list|(
name|entry
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown terminal.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|AL
operator|=
name|tgetstr
argument_list|(
literal|"al"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|CE
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|VS
operator|=
name|tgetstr
argument_list|(
literal|"vs"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|CL
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|SO
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|SE
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|CM
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|ymax
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|screenmax
operator|=
name|ymax
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|CE
operator|||
operator|!
name|SO
operator|||
operator|!
name|SE
operator|||
operator|!
name|CL
operator|||
operator|!
name|AL
operator|||
operator|!
name|CM
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, no mined on this type of terminal\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

end_unit

