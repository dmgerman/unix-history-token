begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Part 2 of the mined editor.  */
end_comment

begin_comment
comment|/*  ========================================================================  *  *				Move Commands				      *	  *  ========================================================================  */
end_comment

begin_include
include|#
directive|include
file|"mined.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  * Move one line up.  */
end_comment

begin_function
name|void
name|UP
parameter_list|()
block|{
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
comment|/* Top line of screen. Scroll one line */
operator|(
name|void
operator|)
name|reverse_scroll
argument_list|()
expr_stmt|;
name|move_to
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Move to previous line */
name|move_to
argument_list|(
name|x
argument_list|,
name|y
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|help_string
init|=
literal|"			Mined (Minix Editor), FreeBSD version.\n"
literal|"------------------------+-------------------------------+---------------------\n"
literal|"	CURSOR MOTION	|		EDITING		|	MISC\n"
literal|" Up			| ^N	Delete next word	| ^E	Erase& redraw\n"
literal|" Down	cursor keys	| ^P	Delete prev. word	|	screen\n"
literal|" Left			| ^T	Delete to EOL		| ^\\	Abort current\n"
literal|" Right			+-------------------------------+	operation\n"
literal|" ^A	start of line	|		BLOCKS		| Esc	repeat last\n"
literal|" ^Z	end of line	| ^@	Set mark		|	cmd # times\n"
literal|" ^^	screen top	| ^K	Delete mark<--> cursor	| F2	file status\n"
literal|" ^_	screen bottom	| ^C	Save mark<--> cursor	+=====================\n"
literal|" ^F	word fwd.	| ^Y	Insert the contents of	| ^X	EXIT\n"
literal|" ^B	word back	| 	the save file at cursor | ^S	run shell\n"
literal|"------------------------+ ^Q	Insert the contents of	+=====================\n"
literal|"	SCREEN MOTION	|	the save file into new	|   SEARCH& REPLACE\n"
literal|"  Home	file top	|	file			| F3	fwd. search\n"
literal|"  End	file bottom	+-------------------------------+ SF3	bck. search\n"
literal|"  PgUp	page up		|		FILES		| F4	Global replace\n"
literal|"  PgD	page down	| ^G	Insert a file at cursor | SF4	Line replace\n"
literal|"  ^D	rev. scroll	| ^V	Visit another file	+---------------------\n"
literal|"  ^U	fwd. scroll	| ^W	Write current file	| F1	HELP\n"
literal|"  ^]	goto line #	|				|\n"
literal|"------------------------+-------------------------------+---------------------\n"
literal|"Press any key to continue..."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Help  */
end_comment

begin_function
name|void
name|HLP
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|string_print
argument_list|(
name|enter_string
argument_list|)
expr_stmt|;
name|string_print
argument_list|(
name|help_string
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|RD
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Move one line down.  */
end_comment

begin_function
name|void
name|DN
parameter_list|()
block|{
if|if
condition|(
name|y
operator|==
name|last_y
condition|)
block|{
comment|/* Last line of screen. Scroll one line */
if|if
condition|(
name|bot_line
operator|->
name|next
operator|==
name|tail
operator|&&
name|bot_line
operator|->
name|text
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|dummy_line
argument_list|()
expr_stmt|;
comment|/* Create new empty line */
name|DN
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|forward_scroll
argument_list|()
expr_stmt|;
name|move_to
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Move to next line */
name|move_to
argument_list|(
name|x
argument_list|,
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move left one position.  */
end_comment

begin_function
name|void
name|LF
parameter_list|()
block|{
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|get_shift
argument_list|(
name|cur_line
operator|->
name|shift_count
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Begin of line */
if|if
condition|(
name|cur_line
operator|->
name|prev
operator|!=
name|header
condition|)
block|{
name|UP
argument_list|()
expr_stmt|;
comment|/* Move one line up */
name|move_to
argument_list|(
name|LINE_END
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|move_to
argument_list|(
name|x
operator|-
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move right one position.  */
end_comment

begin_function
name|void
name|RT
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cur_text
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|cur_line
operator|->
name|next
operator|!=
name|tail
condition|)
block|{
comment|/* Last char of file */
name|DN
argument_list|()
expr_stmt|;
comment|/* Move one line down */
name|move_to
argument_list|(
name|LINE_START
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|move_to
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move to coordinates [0, 0] on screen.  */
end_comment

begin_function
name|void
name|HIGH
parameter_list|()
block|{
name|move_to
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move to coordinates [0, YMAX] on screen.  */
end_comment

begin_function
name|void
name|LOW
parameter_list|()
block|{
name|move_to
argument_list|(
literal|0
argument_list|,
name|last_y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move to begin of line.  */
end_comment

begin_function
name|void
name|BL
parameter_list|()
block|{
name|move_to
argument_list|(
name|LINE_START
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move to end of line.  */
end_comment

begin_function
name|void
name|EL
parameter_list|()
block|{
name|move_to
argument_list|(
name|LINE_END
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GOTO() prompts for a linenumber and moves to that line.  */
end_comment

begin_function
name|void
name|GOTO
parameter_list|()
block|{
name|int
name|number
decl_stmt|;
name|LINE
modifier|*
name|line
decl_stmt|;
if|if
condition|(
name|get_number
argument_list|(
literal|"Please enter line number."
argument_list|,
operator|&
name|number
argument_list|)
operator|==
name|ERRORS
condition|)
return|return;
if|if
condition|(
name|number
operator|<=
literal|0
operator|||
operator|(
name|line
operator|=
name|proceed
argument_list|(
name|header
operator|->
name|next
argument_list|,
name|number
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|tail
condition|)
name|error
argument_list|(
literal|"Illegal line number: "
argument_list|,
name|num_out
argument_list|(
operator|(
name|long
operator|)
name|number
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|move_to
argument_list|(
name|x
argument_list|,
name|find_y
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scroll forward one page or to eof, whatever comes first. (Bot_line becomes   * top_line of display.) Try to leave the cursor on the same line. If this is  * not possible, leave cursor on the line halfway the page.  */
end_comment

begin_function
name|void
name|PD
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screenmax
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|forward_scroll
argument_list|()
operator|==
name|ERRORS
condition|)
break|break;
comment|/* EOF reached */
if|if
condition|(
name|y
operator|-
name|i
operator|<
literal|0
condition|)
comment|/* Line no longer on screen */
name|move_to
argument_list|(
literal|0
argument_list|,
name|screenmax
operator|>>
literal|1
argument_list|)
expr_stmt|;
else|else
name|move_to
argument_list|(
literal|0
argument_list|,
name|y
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scroll backwards one page or to top of file, whatever comes first. (Top_line  * becomes bot_line of display).  The very bottom line (YMAX) is always blank.  * Try to leave the cursor on the same line. If this is not possible, leave  * cursor on the line halfway the page.  */
end_comment

begin_function
name|void
name|PU
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screenmax
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reverse_scroll
argument_list|()
operator|==
name|ERRORS
condition|)
break|break;
comment|/* Top of file reached */
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
comment|/* Erase very bottom line */
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|y
operator|+
name|i
operator|>
name|screenmax
condition|)
comment|/* line no longer on screen */
name|move_to
argument_list|(
literal|0
argument_list|,
name|screenmax
operator|>>
literal|1
argument_list|)
expr_stmt|;
else|else
name|move_to
argument_list|(
literal|0
argument_list|,
name|y
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Go to top of file, scrolling if possible, else redrawing screen.  */
end_comment

begin_function
name|void
name|HO
parameter_list|()
block|{
if|if
condition|(
name|proceed
argument_list|(
name|top_line
argument_list|,
operator|-
name|screenmax
argument_list|)
operator|==
name|header
condition|)
name|PU
argument_list|()
expr_stmt|;
comment|/* It fits. Let PU do it */
else|else
block|{
name|reset
argument_list|(
name|header
operator|->
name|next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset top_line, etc. */
name|RD
argument_list|()
expr_stmt|;
comment|/* Display full page */
block|}
name|move_to
argument_list|(
name|LINE_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Go to last line of file, scrolling if possible, else redrawing screen  */
end_comment

begin_function
name|void
name|EF
parameter_list|()
block|{
if|if
condition|(
name|tail
operator|->
name|prev
operator|->
name|text
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|dummy_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|proceed
argument_list|(
name|bot_line
argument_list|,
name|screenmax
argument_list|)
operator|==
name|tail
condition|)
name|PD
argument_list|()
expr_stmt|;
comment|/* It fits. Let PD do it */
else|else
block|{
name|reset
argument_list|(
name|proceed
argument_list|(
name|tail
operator|->
name|prev
argument_list|,
operator|-
name|screenmax
argument_list|)
argument_list|,
name|screenmax
argument_list|)
expr_stmt|;
name|RD
argument_list|()
expr_stmt|;
comment|/* Display full page */
block|}
name|move_to
argument_list|(
name|LINE_START
argument_list|,
name|last_y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scroll one line up. Leave the cursor on the same line (if possible).  */
end_comment

begin_function
name|void
name|SU
parameter_list|()
block|{
if|if
condition|(
name|top_line
operator|->
name|prev
operator|==
name|header
condition|)
comment|/* Top of file. Can't scroll */
return|return;
operator|(
name|void
operator|)
name|reverse_scroll
argument_list|()
expr_stmt|;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
comment|/* Erase very bottom line */
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|CE
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|blank_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|move_to
argument_list|(
name|x
argument_list|,
operator|(
name|y
operator|==
name|screenmax
operator|)
condition|?
name|screenmax
else|:
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scroll one line down. Leave the cursor on the same line (if possible).  */
end_comment

begin_function
name|void
name|SD
parameter_list|()
block|{
if|if
condition|(
name|forward_scroll
argument_list|()
operator|!=
name|ERRORS
condition|)
name|move_to
argument_list|(
name|x
argument_list|,
operator|(
name|y
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|y
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|set_cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform a forward scroll. It returns ERRORS if we're at the last line of the  * file.  */
end_comment

begin_function
name|int
name|forward_scroll
parameter_list|()
block|{
if|if
condition|(
name|bot_line
operator|->
name|next
operator|==
name|tail
condition|)
comment|/* Last line of file. No dice */
return|return
name|ERRORS
return|;
name|top_line
operator|=
name|top_line
operator|->
name|next
expr_stmt|;
name|bot_line
operator|=
name|bot_line
operator|->
name|next
expr_stmt|;
name|cur_line
operator|=
name|cur_line
operator|->
name|next
expr_stmt|;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|bot_line
argument_list|)
expr_stmt|;
return|return
name|FINE
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a backwards scroll. It returns ERRORS if we're at the first line  * of the file.  */
end_comment

begin_function
name|int
name|reverse_scroll
parameter_list|()
block|{
if|if
condition|(
name|top_line
operator|->
name|prev
operator|==
name|header
condition|)
return|return
name|ERRORS
return|;
comment|/* Top of file. Can't scroll */
if|if
condition|(
name|last_y
operator|!=
name|screenmax
condition|)
comment|/* Reset last_y if necessary */
name|last_y
operator|++
expr_stmt|;
else|else
name|bot_line
operator|=
name|bot_line
operator|->
name|prev
expr_stmt|;
comment|/* Else adjust bot_line */
name|top_line
operator|=
name|top_line
operator|->
name|prev
expr_stmt|;
name|cur_line
operator|=
name|cur_line
operator|->
name|prev
expr_stmt|;
comment|/* Perform the scroll */
name|set_cursor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
name|tputs
argument_list|(
name|AL
argument_list|,
literal|0
argument_list|,
name|_putchar
argument_list|)
expr_stmt|;
else|#
directive|else
name|string_print
argument_list|(
name|rev_scroll
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|set_cursor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|top_line
argument_list|)
expr_stmt|;
return|return
name|FINE
return|;
block|}
end_function

begin_comment
comment|/*  * A word is defined as a number of non-blank characters separated by tabs  * spaces or linefeeds.  */
end_comment

begin_comment
comment|/*  * MP() moves to the start of the previous word. A word is defined as a  * number of non-blank characters separated by tabs spaces or linefeeds.  */
end_comment

begin_function
name|void
name|MP
parameter_list|()
block|{
name|move_previous_word
argument_list|(
name|NO_DELETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|move_previous_word
parameter_list|(
name|remove
parameter_list|)
name|FLAG
name|remove
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|begin_line
decl_stmt|;
specifier|register
name|char
modifier|*
name|textp
decl_stmt|;
name|char
name|start_char
init|=
operator|*
name|cur_text
decl_stmt|;
name|char
modifier|*
name|start_pos
init|=
name|cur_text
decl_stmt|;
comment|/* Fist check if we're at the beginning of line. */
if|if
condition|(
name|cur_text
operator|==
name|cur_line
operator|->
name|text
condition|)
block|{
if|if
condition|(
name|cur_line
operator|->
name|prev
operator|==
name|header
condition|)
return|return;
name|start_char
operator|=
literal|'\0'
expr_stmt|;
block|}
name|LF
argument_list|()
expr_stmt|;
name|begin_line
operator|=
name|cur_line
operator|->
name|text
expr_stmt|;
name|textp
operator|=
name|cur_text
expr_stmt|;
comment|/* Check if we're in the middle of a word. */
if|if
condition|(
operator|!
name|alpha
argument_list|(
operator|*
name|textp
argument_list|)
operator|||
operator|!
name|alpha
argument_list|(
name|start_char
argument_list|)
condition|)
block|{
while|while
condition|(
name|textp
operator|!=
name|begin_line
operator|&&
operator|(
name|white_space
argument_list|(
operator|*
name|textp
argument_list|)
operator|||
operator|*
name|textp
operator|==
literal|'\n'
operator|)
condition|)
name|textp
operator|--
expr_stmt|;
block|}
comment|/* Now we're at the end of previous word. Skip non-blanks until a blank comes */
while|while
condition|(
name|textp
operator|!=
name|begin_line
operator|&&
name|alpha
argument_list|(
operator|*
name|textp
argument_list|)
condition|)
name|textp
operator|--
expr_stmt|;
comment|/* Go to the next char if we're not at the beginning of the line */
if|if
condition|(
name|textp
operator|!=
name|begin_line
operator|&&
operator|*
name|textp
operator|!=
literal|'\n'
condition|)
name|textp
operator|++
expr_stmt|;
comment|/* Find the x-coordinate of this address, and move to it */
name|move_address
argument_list|(
name|textp
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|==
name|DELETE
condition|)
name|delete
argument_list|(
name|cur_line
argument_list|,
name|textp
argument_list|,
name|cur_line
argument_list|,
name|start_pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MN() moves to the start of the next word. A word is defined as a number of  * non-blank characters separated by tabs spaces or linefeeds. Always keep in  * mind that the pointer shouldn't pass the '\n'.  */
end_comment

begin_function
name|void
name|MN
parameter_list|()
block|{
name|move_next_word
argument_list|(
name|NO_DELETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|move_next_word
parameter_list|(
name|remove
parameter_list|)
name|FLAG
name|remove
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|cur_text
decl_stmt|;
comment|/* Move to the end of the current word. */
while|while
condition|(
operator|*
name|textp
operator|!=
literal|'\n'
operator|&&
name|alpha
argument_list|(
operator|*
name|textp
argument_list|)
condition|)
name|textp
operator|++
expr_stmt|;
comment|/* Skip all white spaces */
while|while
condition|(
operator|*
name|textp
operator|!=
literal|'\n'
operator|&&
name|white_space
argument_list|(
operator|*
name|textp
argument_list|)
condition|)
name|textp
operator|++
expr_stmt|;
comment|/* If we're deleting. delete the text in between */
if|if
condition|(
name|remove
operator|==
name|DELETE
condition|)
block|{
name|delete
argument_list|(
name|cur_line
argument_list|,
name|cur_text
argument_list|,
name|cur_line
argument_list|,
name|textp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're at end of line. move to the first word on the next line. */
if|if
condition|(
operator|*
name|textp
operator|==
literal|'\n'
operator|&&
name|cur_line
operator|->
name|next
operator|!=
name|tail
condition|)
block|{
name|DN
argument_list|()
expr_stmt|;
name|move_to
argument_list|(
name|LINE_START
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|textp
operator|=
name|cur_text
expr_stmt|;
while|while
condition|(
operator|*
name|textp
operator|!=
literal|'\n'
operator|&&
name|white_space
argument_list|(
operator|*
name|textp
argument_list|)
condition|)
name|textp
operator|++
expr_stmt|;
block|}
name|move_address
argument_list|(
name|textp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  ========================================================================  *  *				Modify Commands				      *  *  ========================================================================  */
end_comment

begin_comment
comment|/*  * DCC deletes the character under the cursor.  If this character is a '\n' the  * current line is joined with the next one.  * If this character is the only character of the line, the current line will  * be deleted.  */
end_comment

begin_function
name|void
name|DCC
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cur_text
operator|==
literal|'\n'
condition|)
name|delete
argument_list|(
name|cur_line
argument_list|,
name|cur_text
argument_list|,
name|cur_line
operator|->
name|next
argument_list|,
name|cur_line
operator|->
name|next
operator|->
name|text
argument_list|)
expr_stmt|;
else|else
name|delete
argument_list|(
name|cur_line
argument_list|,
name|cur_text
argument_list|,
name|cur_line
argument_list|,
name|cur_text
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DPC deletes the character on the left side of the cursor.  If the cursor is  * at the beginning of the line, the last character if the previous line is  * deleted.   */
end_comment

begin_function
name|void
name|DPC
parameter_list|()
block|{
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|cur_line
operator|->
name|prev
operator|==
name|header
condition|)
return|return;
comment|/* Top of file */
name|LF
argument_list|()
expr_stmt|;
comment|/* Move one left */
name|DCC
argument_list|()
expr_stmt|;
comment|/* Delete character under cursor */
block|}
end_function

begin_comment
comment|/*  * DLN deletes all characters until the end of the line. If the current  * character is a '\n', then delete that char.  */
end_comment

begin_function
name|void
name|DLN
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cur_text
operator|==
literal|'\n'
condition|)
name|DCC
argument_list|()
expr_stmt|;
else|else
name|delete
argument_list|(
name|cur_line
argument_list|,
name|cur_text
argument_list|,
name|cur_line
argument_list|,
name|cur_text
operator|+
name|length_of
argument_list|(
name|cur_text
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DNW() deletes the next word (as described in MN())  */
end_comment

begin_function
name|void
name|DNW
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cur_text
operator|==
literal|'\n'
condition|)
name|DCC
argument_list|()
expr_stmt|;
else|else
name|move_next_word
argument_list|(
name|DELETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DPW() deletes the next word (as described in MP())  */
end_comment

begin_function
name|void
name|DPW
parameter_list|()
block|{
if|if
condition|(
name|cur_text
operator|==
name|cur_line
operator|->
name|text
condition|)
name|DPC
argument_list|()
expr_stmt|;
else|else
name|move_previous_word
argument_list|(
name|DELETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert character `character' at current location.  */
end_comment

begin_function
name|void
name|S
parameter_list|(
name|character
parameter_list|)
specifier|register
name|char
name|character
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
literal|2
index|]
decl_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|character
expr_stmt|;
comment|/* Insert the character */
if|if
condition|(
name|insert
argument_list|(
name|cur_line
argument_list|,
name|cur_text
argument_list|,
name|buffer
argument_list|)
operator|==
name|ERRORS
condition|)
return|return;
comment|/* Fix screen */
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|screenmax
condition|)
block|{
comment|/* Can't use display */
name|line_print
argument_list|(
name|cur_line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|forward_scroll
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|reset
argument_list|(
name|top_line
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Reset pointers */
name|display
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|cur_line
argument_list|,
name|last_y
operator|-
name|y
argument_list|)
expr_stmt|;
block|}
name|move_to
argument_list|(
literal|0
argument_list|,
operator|(
name|y
operator|==
name|screenmax
operator|)
condition|?
name|y
else|:
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|+
literal|1
operator|==
name|XBREAK
condition|)
comment|/* If line must be shifted, just call move_to*/
name|move_to
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* else display rest of line */
name|put_line
argument_list|(
name|cur_line
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
name|x
operator|+
literal|1
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * CTL inserts a control-char at the current location. A message that this  * function is called is displayed at the status line.  */
end_comment

begin_function
name|void
name|CTL
parameter_list|()
block|{
specifier|register
name|char
name|ctrl
decl_stmt|;
name|status_line
argument_list|(
literal|"Enter control character."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl
operator|=
name|getchar
argument_list|()
operator|)
operator|>=
literal|'\01'
operator|&&
name|ctrl
operator|<=
literal|'\037'
condition|)
block|{
name|S
argument_list|(
name|ctrl
argument_list|)
expr_stmt|;
comment|/* Insert the char */
name|clear_status
argument_list|()
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unknown control character"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LIB insert a line at the current position and moves back to the end of  * the previous line.  */
end_comment

begin_function
name|void
name|LIB
parameter_list|()
block|{
name|S
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Insert the line */
name|UP
argument_list|()
expr_stmt|;
comment|/* Move one line up */
name|move_to
argument_list|(
name|LINE_END
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Move to end of this line */
block|}
end_function

begin_comment
comment|/*  * Line_insert() inserts a new line with text pointed to by `string'.  * It returns the address of the new line.  */
end_comment

begin_function
name|LINE
modifier|*
name|line_insert
parameter_list|(
name|line
parameter_list|,
name|string
parameter_list|,
name|len
parameter_list|)
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|new_line
decl_stmt|;
comment|/* Allocate space for LINE structure and text */
name|new_line
operator|=
name|install_line
argument_list|(
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Install the line into the double linked list */
name|new_line
operator|->
name|prev
operator|=
name|line
expr_stmt|;
name|new_line
operator|->
name|next
operator|=
name|line
operator|->
name|next
expr_stmt|;
name|line
operator|->
name|next
operator|=
name|new_line
expr_stmt|;
name|new_line
operator|->
name|next
operator|->
name|prev
operator|=
name|new_line
expr_stmt|;
comment|/* Increment nlines */
name|nlines
operator|++
expr_stmt|;
return|return
name|new_line
return|;
block|}
end_function

begin_comment
comment|/*  * Insert() insert the string `string' at the given line and location.  */
end_comment

begin_function
name|int
name|insert
parameter_list|(
name|line
parameter_list|,
name|location
parameter_list|,
name|string
parameter_list|)
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|location
decl_stmt|,
decl|*
name|string
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|bufp
init|=
name|text_buffer
decl_stmt|;
comment|/* Buffer for building line */
specifier|register
name|char
modifier|*
name|textp
init|=
name|line
operator|->
name|text
decl_stmt|;
if|if
condition|(
name|length_of
argument_list|(
name|textp
argument_list|)
operator|+
name|length_of
argument_list|(
name|string
argument_list|)
operator|>=
name|MAX_CHARS
condition|)
block|{
name|error
argument_list|(
literal|"Line too long"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
name|modified
operator|=
name|TRUE
expr_stmt|;
comment|/* File has been modified */
comment|/* Copy part of line until `location' has been reached */
while|while
condition|(
name|textp
operator|!=
name|location
condition|)
operator|*
name|bufp
operator|++
operator|=
operator|*
name|textp
operator|++
expr_stmt|;
comment|/* Insert string at this location */
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
operator|*
name|bufp
operator|++
operator|=
operator|*
name|string
operator|++
expr_stmt|;
operator|*
name|bufp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|string
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
comment|/* Insert a new line */
operator|(
name|void
operator|)
name|line_insert
argument_list|(
name|line
argument_list|,
name|location
argument_list|,
name|length_of
argument_list|(
name|location
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Append last part of line */
name|copy_string
argument_list|(
name|bufp
argument_list|,
name|location
argument_list|)
expr_stmt|;
comment|/* Install the new text in this line */
name|free_space
argument_list|(
name|line
operator|->
name|text
argument_list|)
expr_stmt|;
name|line
operator|->
name|text
operator|=
name|alloc
argument_list|(
name|length_of
argument_list|(
name|text_buffer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copy_string
argument_list|(
name|line
operator|->
name|text
argument_list|,
name|text_buffer
argument_list|)
expr_stmt|;
return|return
name|FINE
return|;
block|}
end_block

begin_comment
comment|/*  * Line_delete() deletes the argument line out of the line list. The pointer to  * the next line is returned.  */
end_comment

begin_function
name|LINE
modifier|*
name|line_delete
parameter_list|(
name|line
parameter_list|)
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|next_line
init|=
name|line
operator|->
name|next
decl_stmt|;
comment|/* Delete the line */
name|line
operator|->
name|prev
operator|->
name|next
operator|=
name|line
operator|->
name|next
expr_stmt|;
name|line
operator|->
name|next
operator|->
name|prev
operator|=
name|line
operator|->
name|prev
expr_stmt|;
comment|/* Free allocated space */
name|free_space
argument_list|(
name|line
operator|->
name|text
argument_list|)
expr_stmt|;
name|free_space
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
comment|/* Decrement nlines */
name|nlines
operator|--
expr_stmt|;
return|return
name|next_line
return|;
block|}
end_function

begin_comment
comment|/*  * Delete() deletes all the characters (including newlines) between the  * startposition and endposition and fixes the screen accordingly. It  * returns the number of lines deleted.  */
end_comment

begin_function
name|void
name|delete
parameter_list|(
name|start_line
parameter_list|,
name|start_textp
parameter_list|,
name|end_line
parameter_list|,
name|end_textp
parameter_list|)
specifier|register
name|LINE
modifier|*
name|start_line
decl_stmt|;
name|LINE
modifier|*
name|end_line
decl_stmt|;
name|char
modifier|*
name|start_textp
decl_stmt|,
decl|*
name|end_textp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|start_line
operator|->
name|text
decl_stmt|;
specifier|register
name|char
modifier|*
name|bufp
init|=
name|text_buffer
decl_stmt|;
comment|/* Storage for new line->text */
name|LINE
modifier|*
name|line
decl_stmt|,
modifier|*
name|stop
decl_stmt|;
name|int
name|line_cnt
init|=
literal|0
decl_stmt|;
comment|/* Nr of lines deleted */
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* Used in shift calculation */
name|int
name|nx
init|=
name|x
decl_stmt|;
name|modified
operator|=
name|TRUE
expr_stmt|;
comment|/* File has been modified */
comment|/* Set up new line. Copy first part of start line until start_position. */
while|while
condition|(
name|textp
operator|<
name|start_textp
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
operator|*
name|textp
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Check if line doesn't exceed MAX_CHARS */
if|if
condition|(
name|count
operator|+
name|length_of
argument_list|(
name|end_textp
argument_list|)
operator|>=
name|MAX_CHARS
condition|)
block|{
name|error
argument_list|(
literal|"Line too long"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy last part of end_line if end_line is not tail */
name|copy_string
argument_list|(
name|bufp
argument_list|,
operator|(
name|end_textp
operator|!=
name|NIL_PTR
operator|)
condition|?
name|end_textp
else|:
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Delete all lines between start and end_position (including end_line) */
name|line
operator|=
name|start_line
operator|->
name|next
expr_stmt|;
name|stop
operator|=
name|end_line
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|line
operator|!=
name|stop
operator|&&
name|line
operator|!=
name|tail
condition|)
block|{
name|line
operator|=
name|line_delete
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line_cnt
operator|++
expr_stmt|;
block|}
comment|/* Check if last line of file should be deleted */
if|if
condition|(
name|end_textp
operator|==
name|NIL_PTR
operator|&&
name|length_of
argument_list|(
name|start_line
operator|->
name|text
argument_list|)
operator|==
literal|1
operator|&&
name|nlines
operator|>
literal|1
condition|)
block|{
name|start_line
operator|=
name|start_line
operator|->
name|prev
expr_stmt|;
operator|(
name|void
operator|)
name|line_delete
argument_list|(
name|start_line
operator|->
name|next
argument_list|)
expr_stmt|;
name|line_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Install new text */
name|free_space
argument_list|(
name|start_line
operator|->
name|text
argument_list|)
expr_stmt|;
name|start_line
operator|->
name|text
operator|=
name|alloc
argument_list|(
name|length_of
argument_list|(
name|text_buffer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copy_string
argument_list|(
name|start_line
operator|->
name|text
argument_list|,
name|text_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Fix screen. First check if line is shifted. Perhaps we should shift it back*/
if|if
condition|(
name|get_shift
argument_list|(
name|start_line
operator|->
name|shift_count
argument_list|)
condition|)
block|{
name|shift
operator|=
operator|(
name|XBREAK
operator|-
name|count_chars
argument_list|(
name|start_line
argument_list|)
operator|)
operator|/
name|SHIFT_SIZE
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
comment|/* Shift line `shift' back */
if|if
condition|(
name|shift
operator|>=
name|get_shift
argument_list|(
name|start_line
operator|->
name|shift_count
argument_list|)
condition|)
name|start_line
operator|->
name|shift_count
operator|=
literal|0
expr_stmt|;
else|else
name|start_line
operator|->
name|shift_count
operator|-=
name|shift
expr_stmt|;
name|nx
operator|+=
name|shift
operator|*
name|SHIFT_SIZE
expr_stmt|;
comment|/* Reset x value */
block|}
block|}
if|if
condition|(
name|line_cnt
operator|==
literal|0
condition|)
block|{
comment|/* Check if only one line changed */
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
comment|/* Reprint whole line */
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|start_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just display last part of line */
name|set_cursor
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|put_line
argument_list|(
name|start_line
argument_list|,
name|x
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|move_to
argument_list|(
name|nx
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Reset cur_text */
return|return;
block|}
name|shift
operator|=
name|last_y
expr_stmt|;
comment|/* Save value */
name|reset
argument_list|(
name|top_line
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|display
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|start_line
argument_list|,
name|shift
operator|-
name|y
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
operator|(
name|line_cnt
operator|==
literal|1
operator|)
condition|?
name|nx
else|:
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  ========================================================================  *  *				Yank Commands				      *	  *  ========================================================================  */
end_comment

begin_decl_stmt
name|LINE
modifier|*
name|mark_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For marking position. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mark_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lines_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nr of lines in buffer */
end_comment

begin_comment
comment|/*  * PT() inserts the buffer at the current location.  */
end_comment

begin_function
name|void
name|PT
parameter_list|()
block|{
specifier|register
name|int
name|fd
decl_stmt|;
comment|/* File descriptor for buffer */
if|if
condition|(
operator|(
name|fd
operator|=
name|scratch_file
argument_list|(
name|READ
argument_list|)
operator|)
operator|==
name|ERRORS
condition|)
name|error
argument_list|(
literal|"Buffer is empty."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
else|else
block|{
name|file_insert
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Insert the buffer */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * IF() prompt for a filename and inserts the file at the current location   * in the file.  */
end_comment

begin_function
name|void
name|IF
parameter_list|()
block|{
specifier|register
name|int
name|fd
decl_stmt|;
comment|/* File descriptor of file */
name|char
name|name
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Buffer for file name */
comment|/* Get the file name */
if|if
condition|(
name|get_file
argument_list|(
literal|"Get and insert file:"
argument_list|,
name|name
argument_list|)
operator|!=
name|FINE
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot open "
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|file_insert
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Insert the file */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * File_insert() inserts a an opened file (as given by filedescriptor fd)  * at the current location.  */
end_comment

begin_function
name|void
name|file_insert
parameter_list|(
name|fd
parameter_list|,
name|old_pos
parameter_list|)
name|int
name|fd
decl_stmt|;
name|FLAG
name|old_pos
decl_stmt|;
block|{
name|char
name|line_buffer
index|[
name|MAX_CHARS
index|]
decl_stmt|;
comment|/* Buffer for next line */
specifier|register
name|LINE
modifier|*
name|line
init|=
name|cur_line
decl_stmt|;
specifier|register
name|int
name|line_count
init|=
name|nlines
decl_stmt|;
comment|/* Nr of lines inserted */
name|LINE
modifier|*
name|page
init|=
name|cur_line
decl_stmt|;
name|int
name|ret
init|=
name|ERRORS
decl_stmt|;
comment|/* Get the first piece of text (might be ended with a '\n') from fd */
if|if
condition|(
name|get_line
argument_list|(
name|fd
argument_list|,
name|line_buffer
argument_list|)
operator|==
name|ERRORS
condition|)
return|return;
comment|/* Empty file */
comment|/* Insert this text at the current location. */
if|if
condition|(
name|insert
argument_list|(
name|line
argument_list|,
name|cur_text
argument_list|,
name|line_buffer
argument_list|)
operator|==
name|ERRORS
condition|)
return|return;
comment|/* Repeat getting lines (and inserting lines) until EOF is reached */
while|while
condition|(
operator|(
name|ret
operator|=
name|get_line
argument_list|(
name|fd
argument_list|,
name|line_buffer
argument_list|)
operator|)
operator|!=
name|ERRORS
operator|&&
name|ret
operator|!=
name|NO_LINE
condition|)
name|line
operator|=
name|line_insert
argument_list|(
name|line
argument_list|,
name|line_buffer
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NO_LINE
condition|)
block|{
comment|/* Last line read not ended by a '\n' */
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
operator|(
name|void
operator|)
name|insert
argument_list|(
name|line
argument_list|,
name|line
operator|->
name|text
argument_list|,
name|line_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate nr of lines added */
name|line_count
operator|=
name|nlines
operator|-
name|line_count
expr_stmt|;
comment|/* Fix the screen */
if|if
condition|(
name|line_count
operator|==
literal|0
condition|)
block|{
comment|/* Only one line changed */
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
operator|(
name|old_pos
operator|==
name|TRUE
operator|)
condition|?
name|x
else|:
name|x
operator|+
name|length_of
argument_list|(
name|line_buffer
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Several lines changed */
name|reset
argument_list|(
name|top_line
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Reset pointers */
while|while
condition|(
name|page
operator|!=
name|line
operator|&&
name|page
operator|!=
name|bot_line
operator|->
name|next
condition|)
name|page
operator|=
name|page
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|page
operator|!=
name|bot_line
operator|->
name|next
operator|||
name|old_pos
operator|==
name|TRUE
condition|)
name|display
argument_list|(
literal|0
argument_list|,
name|y
argument_list|,
name|cur_line
argument_list|,
name|screenmax
operator|-
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_pos
operator|==
name|TRUE
condition|)
name|move_to
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|NO_LINE
condition|)
name|move_to
argument_list|(
name|length_of
argument_list|(
name|line_buffer
argument_list|)
argument_list|,
name|find_y
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|move_to
argument_list|(
literal|0
argument_list|,
name|find_y
argument_list|(
name|line
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If nr of added line>= REPORT, print the count */
if|if
condition|(
name|line_count
operator|>=
name|REPORT
condition|)
name|status_line
argument_list|(
name|num_out
argument_list|(
operator|(
name|long
operator|)
name|line_count
argument_list|)
argument_list|,
literal|" lines added."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * WB() writes the buffer (yank_file) into another file, which  * is prompted for.  */
end_comment

begin_function
name|void
name|WB
parameter_list|()
block|{
specifier|register
name|int
name|new_fd
decl_stmt|;
comment|/* Filedescriptor to copy file */
name|int
name|yank_fd
decl_stmt|;
comment|/* Filedescriptor to buffer */
specifier|register
name|int
name|cnt
decl_stmt|;
comment|/* Count check for read/write */
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* Error check for write */
name|char
name|file
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Output file */
comment|/* Checkout the buffer */
if|if
condition|(
operator|(
name|yank_fd
operator|=
name|scratch_file
argument_list|(
name|READ
argument_list|)
operator|)
operator|==
name|ERRORS
condition|)
block|{
name|error
argument_list|(
literal|"Buffer is empty."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get file name */
if|if
condition|(
name|get_file
argument_list|(
literal|"Write buffer to file:"
argument_list|,
name|file
argument_list|)
operator|!=
name|FINE
condition|)
return|return;
comment|/* Creat the new file */
if|if
condition|(
operator|(
name|new_fd
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot create "
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|status_line
argument_list|(
literal|"Writing "
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Copy buffer into file */
while|while
condition|(
operator|(
name|cnt
operator|=
name|read
argument_list|(
name|yank_fd
argument_list|,
name|text_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|text_buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|new_fd
argument_list|,
name|text_buffer
argument_list|,
name|cnt
argument_list|)
operator|!=
name|cnt
condition|)
block|{
name|bad_write
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ERRORS
expr_stmt|;
break|break;
block|}
comment|/* Clean up open files and status_line */
operator|(
name|void
operator|)
name|close
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|yank_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ERRORS
condition|)
comment|/* Bad write */
name|file_status
argument_list|(
literal|"Wrote"
argument_list|,
name|chars_saved
argument_list|,
name|file
argument_list|,
name|lines_saved
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MA sets mark_line (mark_text) to the current line (text pointer).   */
end_comment

begin_function
name|void
name|MA
parameter_list|()
block|{
name|mark_line
operator|=
name|cur_line
expr_stmt|;
name|mark_text
operator|=
name|cur_text
expr_stmt|;
name|status_line
argument_list|(
literal|"Mark set"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * YA() puts the text between the marked position and the current  * in the buffer.  */
end_comment

begin_function
name|void
name|YA
parameter_list|()
block|{
name|set_up
argument_list|(
name|NO_DELETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DT() is essentially the same as YA(), but in DT() the text is deleted.  */
end_comment

begin_function
name|void
name|DT
parameter_list|()
block|{
name|set_up
argument_list|(
name|DELETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set_up is an interface to the actual yank. It calls checkmark () to check  * if the marked position is still valid. If it is, yank is called with the  * arguments in the right order.  */
end_comment

begin_function
name|void
name|set_up
parameter_list|(
name|remove
parameter_list|)
name|FLAG
name|remove
decl_stmt|;
comment|/* DELETE if text should be deleted */
block|{
switch|switch
condition|(
name|checkmark
argument_list|()
condition|)
block|{
case|case
name|NOT_VALID
case|:
name|error
argument_list|(
literal|"Mark not set."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return;
case|case
name|SMALLER
case|:
name|yank
argument_list|(
name|mark_line
argument_list|,
name|mark_text
argument_list|,
name|cur_line
argument_list|,
name|cur_text
argument_list|,
name|remove
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIGGER
case|:
name|yank
argument_list|(
name|cur_line
argument_list|,
name|cur_text
argument_list|,
name|mark_line
argument_list|,
name|mark_text
argument_list|,
name|remove
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAME
case|:
comment|/* Ignore stupid behaviour */
name|yank_status
operator|=
name|EMPTY
expr_stmt|;
name|chars_saved
operator|=
literal|0L
expr_stmt|;
name|status_line
argument_list|(
literal|"0 characters saved in buffer."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Check_mark() checks if mark_line and mark_text are still valid pointers. If  * they are it returns SMALLER if the marked position is before the current,  * BIGGER if it isn't or SAME if somebody didn't get the point.  * NOT_VALID is returned when mark_line and/or mark_text are no longer valid.  * Legal() checks if mark_text is valid on the mark_line.  */
end_comment

begin_function
name|FLAG
name|checkmark
parameter_list|()
block|{
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
name|FLAG
name|cur_seen
init|=
name|FALSE
decl_stmt|;
comment|/* Special case: check is mark_line and cur_line are the same. */
if|if
condition|(
name|mark_line
operator|==
name|cur_line
condition|)
block|{
if|if
condition|(
name|mark_text
operator|==
name|cur_text
condition|)
comment|/* Even same place */
return|return
name|SAME
return|;
if|if
condition|(
name|legal
argument_list|()
operator|==
name|ERRORS
condition|)
comment|/* mark_text out of range */
return|return
name|NOT_VALID
return|;
return|return
operator|(
name|mark_text
operator|<
name|cur_text
operator|)
condition|?
name|SMALLER
else|:
name|BIGGER
return|;
block|}
comment|/* Start looking for mark_line in the line structure */
for|for
control|(
name|line
operator|=
name|header
operator|->
name|next
init|;
name|line
operator|!=
name|tail
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
block|{
if|if
condition|(
name|line
operator|==
name|cur_line
condition|)
name|cur_seen
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|line
operator|==
name|mark_line
condition|)
break|break;
block|}
comment|/* If we found mark_line (line != tail) check for legality of mark_text */
if|if
condition|(
name|line
operator|==
name|tail
operator|||
name|legal
argument_list|()
operator|==
name|ERRORS
condition|)
return|return
name|NOT_VALID
return|;
comment|/* cur_seen is TRUE if cur_line is before mark_line */
return|return
operator|(
name|cur_seen
operator|==
name|TRUE
operator|)
condition|?
name|BIGGER
else|:
name|SMALLER
return|;
block|}
end_function

begin_comment
comment|/*  * Legal() checks if mark_text is still a valid pointer.  */
end_comment

begin_function
name|int
name|legal
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|mark_line
operator|->
name|text
decl_stmt|;
comment|/* Locate mark_text on mark_line */
while|while
condition|(
name|textp
operator|!=
name|mark_text
operator|&&
operator|*
name|textp
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
return|return
operator|(
operator|*
name|textp
operator|==
literal|'\0'
operator|)
condition|?
name|ERRORS
else|:
name|FINE
return|;
block|}
end_function

begin_comment
comment|/*  * Yank puts all the text between start_position and end_position into  * the buffer.  * The caller must check that the arguments to yank() are valid. (E.g. in  * the right order)  */
end_comment

begin_function
name|void
name|yank
parameter_list|(
name|start_line
parameter_list|,
name|start_textp
parameter_list|,
name|end_line
parameter_list|,
name|end_textp
parameter_list|,
name|remove
parameter_list|)
name|LINE
modifier|*
name|start_line
decl_stmt|,
decl|*
name|end_line
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|start_textp
decl_stmt|,
modifier|*
name|end_textp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLAG
name|remove
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DELETE if text should be deleted */
end_comment

begin_block
block|{
specifier|register
name|LINE
modifier|*
name|line
init|=
name|start_line
decl_stmt|;
specifier|register
name|char
modifier|*
name|textp
init|=
name|start_textp
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Creat file to hold buffer */
if|if
condition|(
operator|(
name|fd
operator|=
name|scratch_file
argument_list|(
name|WRITE
argument_list|)
operator|)
operator|==
name|ERRORS
condition|)
return|return;
name|chars_saved
operator|=
literal|0L
expr_stmt|;
name|lines_saved
operator|=
literal|0
expr_stmt|;
name|status_line
argument_list|(
literal|"Saving text."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
comment|/* Keep writing chars until the end_location is reached. */
while|while
condition|(
name|textp
operator|!=
name|end_textp
condition|)
block|{
if|if
condition|(
name|write_char
argument_list|(
name|fd
argument_list|,
operator|*
name|textp
argument_list|)
operator|==
name|ERRORS
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|textp
operator|++
operator|==
literal|'\n'
condition|)
block|{
comment|/* Move to the next line */
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
name|textp
operator|=
name|line
operator|->
name|text
expr_stmt|;
name|lines_saved
operator|++
expr_stmt|;
block|}
name|chars_saved
operator|++
expr_stmt|;
block|}
comment|/* Flush the I/O buffer and close file */
if|if
condition|(
name|flush_buffer
argument_list|(
name|fd
argument_list|)
operator|==
name|ERRORS
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|yank_status
operator|=
name|VALID
expr_stmt|;
comment|/*  * Check if the text should be deleted as well. If it should, the following  * hack is used to save a lot of code. First move back to the start_position.  * (This might be the location we're on now!) and them delete the text.  * It might be a bit confusing the first time somebody uses it.  * Delete() will fix the screen.  */
if|if
condition|(
name|remove
operator|==
name|DELETE
condition|)
block|{
name|move_to
argument_list|(
name|find_x
argument_list|(
name|start_line
argument_list|,
name|start_textp
argument_list|)
argument_list|,
name|find_y
argument_list|(
name|start_line
argument_list|)
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|start_line
argument_list|,
name|start_textp
argument_list|,
name|end_line
argument_list|,
name|end_textp
argument_list|)
expr_stmt|;
block|}
name|status_line
argument_list|(
name|num_out
argument_list|(
name|chars_saved
argument_list|)
argument_list|,
literal|" characters saved in buffer."
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Scratch_file() creates a uniq file in /usr/tmp. If the file couldn't  * be created other combinations of files are tried until a maximum  * of MAXTRAILS times. After MAXTRAILS times, an error message is given  * and ERRORS is returned.  */
end_comment

begin_define
define|#
directive|define
name|MAXTRAILS
value|26
end_define

begin_function
name|int
name|scratch_file
parameter_list|(
name|mode
parameter_list|)
name|FLAG
name|mode
decl_stmt|;
comment|/* Can be READ or WRITE permission */
block|{
specifier|static
name|int
name|trials
init|=
literal|0
decl_stmt|;
comment|/* Keep track of trails */
specifier|register
name|char
modifier|*
name|y_ptr
decl_stmt|,
modifier|*
name|n_ptr
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Filedescriptor to buffer */
comment|/* If yank_status == NOT_VALID, scratch_file is called for the first time */
if|if
condition|(
name|yank_status
operator|==
name|NOT_VALID
operator|&&
name|mode
operator|==
name|WRITE
condition|)
block|{
comment|/* Create new file */
comment|/* Generate file name. */
name|y_ptr
operator|=
operator|&
name|yank_file
index|[
literal|11
index|]
expr_stmt|;
name|n_ptr
operator|=
name|num_out
argument_list|(
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|y_ptr
operator|=
operator|*
name|n_ptr
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|y_ptr
operator|++
expr_stmt|;
operator|*
name|y_ptr
operator|++
operator|=
literal|'a'
operator|+
name|trials
expr_stmt|;
operator|*
name|y_ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check file existence */
if|if
condition|(
name|access
argument_list|(
name|yank_file
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|yank_file
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|trials
operator|++
operator|>=
name|MAXTRAILS
condition|)
block|{
name|error
argument_list|(
literal|"Unable to creat scratchfile."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
else|else
return|return
name|scratch_file
argument_list|(
name|mode
argument_list|)
return|;
comment|/* Have another go */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|mode
operator|==
name|READ
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|yank_file
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|==
name|WRITE
operator|&&
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|yank_file
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
name|yank_status
operator|=
name|NOT_VALID
expr_stmt|;
return|return
name|ERRORS
return|;
block|}
name|clear_buffer
argument_list|()
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  ========================================================================  *  *				Search Routines				      *	  *  ========================================================================  */
end_comment

begin_comment
comment|/*  * A regular expression consists of a sequence of:  * 	1. A normal character matching that character.  * 	2. A . matching any character.  * 	3. A ^ matching the begin of a line.  * 	4. A $ (as last character of the pattern) mathing the end of a line.  * 	5. A \<character> matching<character>.  * 	6. A number of characters enclosed in [] pairs matching any of these  * 	   characters. A list of characters can be indicated by a '-'. So  * 	   [a-z] matches any letter of the alphabet. If the first character  * 	   after the '[' is a '^' then the set is negated (matching none of  * 	   the characters).   * 	   A ']', '^' or '-' can be escaped by putting a '\' in front of it.  * 	7. If one of the expressions as described in 1-6 is followed by a  * 	   '*' than that expressions matches a sequence of 0 or more of  * 	   that expression.  */
end_comment

begin_decl_stmt
name|char
name|typed_expression
index|[
name|LINE_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds previous expr. */
end_comment

begin_comment
comment|/*  * SF searches forward for an expression.  */
end_comment

begin_function
name|void
name|SF
parameter_list|()
block|{
name|search
argument_list|(
literal|"Search forward:"
argument_list|,
name|FORWARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SF searches backwards for an expression.  */
end_comment

begin_function
name|void
name|SR
parameter_list|()
block|{
name|search
argument_list|(
literal|"Search reverse:"
argument_list|,
name|REVERSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get_expression() prompts for an expression. If just a return is typed, the  * old expression is used. If the expression changed, compile() is called and  * the returning REGEX structure is returned. It returns NIL_REG upon error.  * The save flag indicates whether the expression should be appended at the  * message pointer.  */
end_comment

begin_function
name|REGEX
modifier|*
name|get_expression
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
specifier|static
name|REGEX
name|program
decl_stmt|;
comment|/* Program of expression */
name|char
name|exp_buf
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Buffer for new expr. */
if|if
condition|(
name|get_string
argument_list|(
name|message
argument_list|,
name|exp_buf
argument_list|,
name|FALSE
argument_list|)
operator|==
name|ERRORS
condition|)
return|return
name|NIL_REG
return|;
if|if
condition|(
name|exp_buf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|typed_expression
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"No previous expression."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return
name|NIL_REG
return|;
block|}
if|if
condition|(
name|exp_buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* A new expr. is typed */
name|copy_string
argument_list|(
name|typed_expression
argument_list|,
name|exp_buf
argument_list|)
expr_stmt|;
comment|/* Save expr. */
name|compile
argument_list|(
name|exp_buf
argument_list|,
operator|&
name|program
argument_list|)
expr_stmt|;
comment|/* Compile new expression */
block|}
if|if
condition|(
name|program
operator|.
name|status
operator|==
name|REG_ERROR
condition|)
block|{
comment|/* Error during compiling */
name|error
argument_list|(
name|program
operator|.
name|result
operator|.
name|err_mess
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return
name|NIL_REG
return|;
block|}
return|return
operator|&
name|program
return|;
block|}
end_function

begin_comment
comment|/*  * GR() a replaces all matches from the current position until the end  * of the file.  */
end_comment

begin_function
name|void
name|GR
parameter_list|()
block|{
name|change
argument_list|(
literal|"Global replace:"
argument_list|,
name|VALID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LR() replaces all matches on the current line.  */
end_comment

begin_function
name|void
name|LR
parameter_list|()
block|{
name|change
argument_list|(
literal|"Line replace:"
argument_list|,
name|NOT_VALID
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change() prompts for an expression and a substitution pattern and changes  * all matches of the expression into the substitution. change() start looking  * for expressions at the current line and continues until the end of the file  * if the FLAG file is VALID.  */
end_comment

begin_function
name|void
name|change
parameter_list|(
name|message
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
comment|/* Message to prompt for expression */
name|FLAG
name|file
decl_stmt|;
block|{
name|char
name|mess_buf
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Buffer to hold message */
name|char
name|replacement
index|[
name|LINE_LEN
index|]
decl_stmt|;
comment|/* Buffer to hold subst. pattern */
name|REGEX
modifier|*
name|program
decl_stmt|;
comment|/* Program resulting from compilation */
specifier|register
name|LINE
modifier|*
name|line
init|=
name|cur_line
decl_stmt|;
specifier|register
name|char
modifier|*
name|textp
decl_stmt|;
name|long
name|lines
init|=
literal|0L
decl_stmt|;
comment|/* Nr of lines on which subs occurred */
name|long
name|subs
init|=
literal|0L
decl_stmt|;
comment|/* Nr of subs made */
name|int
name|page
init|=
name|y
decl_stmt|;
comment|/* Index to check if line is on screen*/
comment|/* Save message and get expression */
name|copy_string
argument_list|(
name|mess_buf
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|program
operator|=
name|get_expression
argument_list|(
name|mess_buf
argument_list|)
operator|)
operator|==
name|NIL_REG
condition|)
return|return;
comment|/* Get substitution pattern */
name|build_string
argument_list|(
name|mess_buf
argument_list|,
literal|"%s %s by:"
argument_list|,
name|mess_buf
argument_list|,
name|typed_expression
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_string
argument_list|(
name|mess_buf
argument_list|,
name|replacement
argument_list|,
name|FALSE
argument_list|)
operator|==
name|ERRORS
condition|)
return|return;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Substitute until end of file */
do|do
block|{
if|if
condition|(
name|line_check
argument_list|(
name|program
argument_list|,
name|line
operator|->
name|text
argument_list|,
name|FORWARD
argument_list|)
condition|)
block|{
name|lines
operator|++
expr_stmt|;
comment|/* Repeat sub. on this line as long as we find a match*/
do|do
block|{
name|subs
operator|++
expr_stmt|;
comment|/* Increment subs */
if|if
condition|(
operator|(
name|textp
operator|=
name|substitute
argument_list|(
name|line
argument_list|,
name|program
argument_list|,
name|replacement
argument_list|)
operator|)
operator|==
name|NIL_PTR
condition|)
return|return;
comment|/* Line too long */
block|}
do|while
condition|(
operator|(
name|program
operator|->
name|status
operator|&
name|BEGIN_LINE
operator|)
operator|!=
name|BEGIN_LINE
operator|&&
operator|(
name|program
operator|->
name|status
operator|&
name|END_LINE
operator|)
operator|!=
name|END_LINE
operator|&&
name|line_check
argument_list|(
name|program
argument_list|,
name|textp
argument_list|,
name|FORWARD
argument_list|)
condition|)
do|;
comment|/* Check to see if we can print the result */
if|if
condition|(
name|page
operator|<=
name|screenmax
condition|)
block|{
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|line_print
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|page
operator|<=
name|screenmax
condition|)
name|page
operator|++
expr_stmt|;
name|line
operator|=
name|line
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|line
operator|!=
name|tail
operator|&&
name|file
operator|==
name|VALID
operator|&&
name|quit
operator|==
name|FALSE
condition|)
do|;
name|copy_string
argument_list|(
name|mess_buf
argument_list|,
operator|(
name|quit
operator|==
name|TRUE
operator|)
condition|?
literal|"(Aborted) "
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* Fix the status line */
if|if
condition|(
name|subs
operator|==
literal|0L
operator|&&
name|quit
operator|==
name|FALSE
condition|)
name|error
argument_list|(
literal|"Pattern not found."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lines
operator|>=
name|REPORT
operator|||
name|quit
operator|==
name|TRUE
condition|)
block|{
name|build_string
argument_list|(
name|mess_buf
argument_list|,
literal|"%s %D substitutions on %D lines."
argument_list|,
name|mess_buf
argument_list|,
name|subs
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|status_line
argument_list|(
name|mess_buf
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file
operator|==
name|NOT_VALID
operator|&&
name|subs
operator|>=
name|REPORT
condition|)
name|status_line
argument_list|(
name|num_out
argument_list|(
name|subs
argument_list|)
argument_list|,
literal|" substitutions."
argument_list|)
expr_stmt|;
else|else
name|clear_status
argument_list|()
expr_stmt|;
name|move_to
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Substitute() replaces the match on this line by the substitute pattern  * as indicated by the program. Every '&' in the replacement is replaced by   * the original match. A \ in the replacement escapes the next character.  */
end_comment

begin_function
name|char
modifier|*
name|substitute
parameter_list|(
name|line
parameter_list|,
name|program
parameter_list|,
name|replacement
parameter_list|)
name|LINE
modifier|*
name|line
decl_stmt|;
name|REGEX
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|replacement
decl_stmt|;
comment|/* Contains replacement pattern */
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|text_buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|subp
init|=
name|replacement
decl_stmt|;
name|char
modifier|*
name|linep
init|=
name|line
operator|->
name|text
decl_stmt|;
name|char
modifier|*
name|amp
decl_stmt|;
name|modified
operator|=
name|TRUE
expr_stmt|;
comment|/* Copy part of line until the beginning of the match */
while|while
condition|(
name|linep
operator|!=
name|program
operator|->
name|start_ptr
condition|)
operator|*
name|textp
operator|++
operator|=
operator|*
name|linep
operator|++
expr_stmt|;
comment|/*  * Replace the match by the substitution pattern. Each occurrence of '&' is  * replaced by the original match. A \ escapes the next character.  */
while|while
condition|(
operator|*
name|subp
operator|!=
literal|'\0'
operator|&&
name|textp
operator|<
operator|&
name|text_buffer
index|[
name|MAX_CHARS
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|subp
operator|==
literal|'&'
condition|)
block|{
comment|/* Replace the original match */
name|amp
operator|=
name|program
operator|->
name|start_ptr
expr_stmt|;
while|while
condition|(
name|amp
operator|<
name|program
operator|->
name|end_ptr
operator|&&
name|textp
operator|<
operator|&
name|text_buffer
index|[
name|MAX_CHARS
index|]
condition|)
operator|*
name|textp
operator|++
operator|=
operator|*
name|amp
operator|++
expr_stmt|;
name|subp
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|subp
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|subp
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|subp
operator|++
expr_stmt|;
operator|*
name|textp
operator|++
operator|=
operator|*
name|subp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Check for line length not exceeding MAX_CHARS */
if|if
condition|(
name|length_of
argument_list|(
name|text_buffer
argument_list|)
operator|+
name|length_of
argument_list|(
name|program
operator|->
name|end_ptr
argument_list|)
operator|>=
name|MAX_CHARS
condition|)
block|{
name|error
argument_list|(
literal|"Substitution result: line too big"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return
name|NIL_PTR
return|;
block|}
comment|/* Append last part of line to the new build line */
name|copy_string
argument_list|(
name|textp
argument_list|,
name|program
operator|->
name|end_ptr
argument_list|)
expr_stmt|;
comment|/* Free old line and install new one */
name|free_space
argument_list|(
name|line
operator|->
name|text
argument_list|)
expr_stmt|;
name|line
operator|->
name|text
operator|=
name|alloc
argument_list|(
name|length_of
argument_list|(
name|text_buffer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copy_string
argument_list|(
name|line
operator|->
name|text
argument_list|,
name|text_buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|line
operator|->
name|text
operator|+
operator|(
name|textp
operator|-
name|text_buffer
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search() calls get_expression to fetch the expression. If this went well,  * the function match() is called which returns the line with the next match.  * If this line is the NIL_LINE, it means that a match could not be found.  * Find_x() and find_y() display the right page on the screen, and return  * the right coordinates for x and y. These coordinates are passed to move_to()  */
end_comment

begin_function
name|void
name|search
parameter_list|(
name|message
parameter_list|,
name|method
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|FLAG
name|method
decl_stmt|;
block|{
specifier|register
name|REGEX
modifier|*
name|program
decl_stmt|;
specifier|register
name|LINE
modifier|*
name|match_line
decl_stmt|;
comment|/* Get the expression */
if|if
condition|(
operator|(
name|program
operator|=
name|get_expression
argument_list|(
name|message
argument_list|)
operator|)
operator|==
name|NIL_REG
condition|)
return|return;
name|set_cursor
argument_list|(
literal|0
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Find the match */
if|if
condition|(
operator|(
name|match_line
operator|=
name|match
argument_list|(
name|program
argument_list|,
name|cur_text
argument_list|,
name|method
argument_list|)
operator|)
operator|==
name|NIL_LINE
condition|)
block|{
if|if
condition|(
name|quit
operator|==
name|TRUE
condition|)
name|status_line
argument_list|(
literal|"Aborted"
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
else|else
name|status_line
argument_list|(
literal|"Pattern not found."
argument_list|,
name|NIL_PTR
argument_list|)
expr_stmt|;
return|return;
block|}
name|move
argument_list|(
literal|0
argument_list|,
name|program
operator|->
name|start_ptr
argument_list|,
name|find_y
argument_list|(
name|match_line
argument_list|)
argument_list|)
expr_stmt|;
name|clear_status
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find_y() checks if the matched line is on the current page.  If it is, it  * returns the new y coordinate, else it displays the correct page with the  * matched line in the middle and returns the new y value;  */
end_comment

begin_function
name|int
name|find_y
parameter_list|(
name|match_line
parameter_list|)
name|LINE
modifier|*
name|match_line
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Check if match_line is on the same page as currently displayed. */
for|for
control|(
name|line
operator|=
name|top_line
init|;
name|line
operator|!=
name|match_line
operator|&&
name|line
operator|!=
name|bot_line
operator|->
name|next
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|bot_line
operator|->
name|next
condition|)
return|return
name|count
return|;
comment|/* Display new page, with match_line in center. */
if|if
condition|(
operator|(
name|line
operator|=
name|proceed
argument_list|(
name|match_line
argument_list|,
operator|-
operator|(
name|screenmax
operator|>>
literal|1
operator|)
argument_list|)
operator|)
operator|==
name|header
condition|)
block|{
comment|/* Can't display in the middle. Make first line of file top_line */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|line
operator|=
name|header
operator|->
name|next
init|;
name|line
operator|!=
name|match_line
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
name|count
operator|++
expr_stmt|;
name|line
operator|=
name|header
operator|->
name|next
expr_stmt|;
block|}
else|else
comment|/* New page is displayed. Set cursor to middle of page */
name|count
operator|=
name|screenmax
operator|>>
literal|1
expr_stmt|;
comment|/* Reset pointers and redraw the screen */
name|reset
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RD
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Opcodes for characters */
end_comment

begin_define
define|#
directive|define
name|NORMAL
value|0x0200
end_define

begin_define
define|#
directive|define
name|DOT
value|0x0400
end_define

begin_define
define|#
directive|define
name|EOLN
value|0x0800
end_define

begin_define
define|#
directive|define
name|STAR
value|0x1000
end_define

begin_define
define|#
directive|define
name|BRACKET
value|0x2000
end_define

begin_define
define|#
directive|define
name|NEGATE
value|0x0100
end_define

begin_define
define|#
directive|define
name|DONE
value|0x4000
end_define

begin_comment
comment|/* Mask for opcodes and characters */
end_comment

begin_define
define|#
directive|define
name|LOW_BYTE
value|0x00FF
end_define

begin_define
define|#
directive|define
name|HIGH_BYTE
value|0xFF00
end_define

begin_comment
comment|/* Previous is the contents of the previous address (ptr) points to */
end_comment

begin_define
define|#
directive|define
name|previous
parameter_list|(
name|ptr
parameter_list|)
value|(*((ptr) - 1))
end_define

begin_comment
comment|/* Buffer to store outcome of compilation */
end_comment

begin_decl_stmt
name|int
name|exp_buffer
index|[
name|BLOCK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Errors often used */
end_comment

begin_decl_stmt
name|char
modifier|*
name|too_long
init|=
literal|"Regular expression too long"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reg_error() is called by compile() is something went wrong. It set the  * status of the structure to error, and assigns the error field of the union.  */
end_comment

begin_define
define|#
directive|define
name|reg_error
parameter_list|(
name|str
parameter_list|)
value|program->status = REG_ERROR, \   					program->result.err_mess = (str)
end_define

begin_comment
comment|/*  * Finished() is called when everything went right during compilation. It  * allocates space for the expression, and copies the expression buffer into  * this field.  */
end_comment

begin_function
name|void
name|finished
parameter_list|(
name|program
parameter_list|,
name|last_exp
parameter_list|)
specifier|register
name|REGEX
modifier|*
name|program
decl_stmt|;
name|int
modifier|*
name|last_exp
decl_stmt|;
block|{
specifier|register
name|int
name|length
init|=
operator|(
name|last_exp
operator|-
name|exp_buffer
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate space */
name|program
operator|->
name|result
operator|.
name|expression
operator|=
operator|(
name|int
operator|*
operator|)
name|alloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* Copy expression. (expression consists of ints!) */
name|bcopy
argument_list|(
name|exp_buffer
argument_list|,
name|program
operator|->
name|result
operator|.
name|expression
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compile compiles the pattern into a more comprehensible form and returns a   * REGEX structure. If something went wrong, the status field of the structure  * is set to REG_ERROR and an error message is set into the err_mess field of  * the union. If all went well the expression is saved and the expression  * pointer is set to the saved (and compiled) expression.  */
end_comment

begin_function
name|void
name|compile
parameter_list|(
name|pattern
parameter_list|,
name|program
parameter_list|)
specifier|register
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* Pointer to pattern */
name|REGEX
modifier|*
name|program
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|expression
init|=
name|exp_buffer
decl_stmt|;
name|int
modifier|*
name|prev_char
decl_stmt|;
comment|/* Pointer to previous compiled atom */
name|int
modifier|*
name|acct_field
decl_stmt|;
comment|/* Pointer to last BRACKET start */
name|FLAG
name|negate
decl_stmt|;
comment|/* Negate flag for BRACKET */
name|char
name|low_char
decl_stmt|;
comment|/* Index for chars in BRACKET */
name|char
name|c
decl_stmt|;
comment|/* Check for begin of line */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'^'
condition|)
block|{
name|program
operator|->
name|status
operator|=
name|BEGIN_LINE
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
block|}
else|else
block|{
name|program
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* If the first character is a '*' we have to assign it here. */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'*'
condition|)
block|{
operator|*
name|expression
operator|++
operator|=
literal|'*'
operator|+
name|NORMAL
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|pattern
operator|++
condition|)
block|{
case|case
literal|'.'
case|:
operator|*
name|expression
operator|++
operator|=
name|DOT
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/*   		 * Only means EOLN if it is the last char of the pattern   		 */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|expression
operator|++
operator|=
name|EOLN
operator||
name|DONE
expr_stmt|;
name|program
operator|->
name|status
operator||=
name|END_LINE
expr_stmt|;
name|finished
argument_list|(
name|program
argument_list|,
name|expression
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
operator|*
name|expression
operator|++
operator|=
name|NORMAL
operator|+
literal|'$'
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|*
name|expression
operator|++
operator|=
name|DONE
expr_stmt|;
name|finished
argument_list|(
name|program
argument_list|,
name|expression
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\\'
case|:
comment|/* If last char, it must! mean a normal '\' */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
operator|*
name|expression
operator|++
operator|=
name|NORMAL
operator|+
literal|'\\'
expr_stmt|;
else|else
operator|*
name|expression
operator|++
operator|=
name|NORMAL
operator|+
operator|*
name|pattern
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/*   		 * If the previous expression was a [] find out the   		 * begin of the list, and adjust the opcode.   		 */
name|prev_char
operator|=
name|expression
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|prev_char
operator|&
name|BRACKET
condition|)
operator|*
operator|(
name|expression
operator|-
operator|(
operator|*
name|acct_field
operator|&
name|LOW_BYTE
operator|)
operator|)
operator||=
name|STAR
expr_stmt|;
else|else
operator|*
name|prev_char
operator||=
name|STAR
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/*   		 * First field in expression gives information about   		 * the list.   		 * The opcode consists of BRACKET and if necessary   		 * NEGATE to indicate that the list should be negated   		 * and/or STAR to indicate a number of sequence of this    		 * list.   		 * The lower byte contains the length of the list.   		 */
name|acct_field
operator|=
name|expression
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'^'
condition|)
block|{
comment|/* List must be negated */
name|pattern
operator|++
expr_stmt|;
name|negate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|negate
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|pattern
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
name|reg_error
argument_list|(
literal|"Missing ]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
name|pattern
operator|++
expr_stmt|;
operator|*
name|expression
operator|++
operator|=
operator|*
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'-'
condition|)
block|{
comment|/* Make list of chars */
name|low_char
operator|=
name|previous
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
comment|/* Skip '-' */
if|if
condition|(
name|low_char
operator|++
operator|>
operator|*
name|pattern
condition|)
block|{
name|reg_error
argument_list|(
literal|"Bad range in [a-z]"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Build list */
while|while
condition|(
name|low_char
operator|<=
operator|*
name|pattern
condition|)
operator|*
name|expression
operator|++
operator|=
name|low_char
operator|++
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|expression
operator|>=
operator|&
name|exp_buffer
index|[
name|BLOCK_SIZE
index|]
condition|)
block|{
name|reg_error
argument_list|(
name|too_long
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|pattern
operator|++
expr_stmt|;
comment|/* Skip ']' */
comment|/* Assign length of list in acct field */
if|if
condition|(
operator|(
operator|*
name|acct_field
operator|=
operator|(
name|expression
operator|-
name|acct_field
operator|)
operator|)
operator|==
literal|1
condition|)
block|{
name|reg_error
argument_list|(
literal|"Empty []"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Assign negate and bracket field */
operator|*
name|acct_field
operator||=
name|BRACKET
expr_stmt|;
if|if
condition|(
name|negate
operator|==
name|TRUE
condition|)
operator|*
name|acct_field
operator||=
name|NEGATE
expr_stmt|;
comment|/*   		 * Add BRACKET to opcode of last char in field because   		 * a '*' may be following the list.   		 */
name|previous
argument_list|(
name|expression
argument_list|)
operator||=
name|BRACKET
expr_stmt|;
break|break;
default|default :
operator|*
name|expression
operator|++
operator|=
name|c
operator|+
name|NORMAL
expr_stmt|;
block|}
if|if
condition|(
name|expression
operator|==
operator|&
name|exp_buffer
index|[
name|BLOCK_SIZE
index|]
condition|)
block|{
name|reg_error
argument_list|(
name|too_long
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Match gets as argument the program, pointer to place in current line to   * start from and the method to search for (either FORWARD or REVERSE).  * Match() will look through the whole file until a match is found.  * NIL_LINE is returned if no match could be found.  */
end_comment

begin_function
name|LINE
modifier|*
name|match
parameter_list|(
name|program
parameter_list|,
name|string
parameter_list|,
name|method
parameter_list|)
name|REGEX
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|FLAG
name|method
decl_stmt|;
block|{
specifier|register
name|LINE
modifier|*
name|line
init|=
name|cur_line
decl_stmt|;
name|char
name|old_char
decl_stmt|;
comment|/* For saving chars */
comment|/* Corrupted program */
if|if
condition|(
name|program
operator|->
name|status
operator|==
name|REG_ERROR
condition|)
return|return
name|NIL_LINE
return|;
comment|/* Check part of text first */
if|if
condition|(
operator|!
operator|(
name|program
operator|->
name|status
operator|&
name|BEGIN_LINE
operator|)
condition|)
block|{
if|if
condition|(
name|method
operator|==
name|FORWARD
condition|)
block|{
if|if
condition|(
name|line_check
argument_list|(
name|program
argument_list|,
name|string
operator|+
literal|1
argument_list|,
name|method
argument_list|)
operator|==
name|MATCH
condition|)
return|return
name|cur_line
return|;
comment|/* Match found */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|program
operator|->
name|status
operator|&
name|END_LINE
operator|)
condition|)
block|{
name|old_char
operator|=
operator|*
name|string
expr_stmt|;
comment|/* Save char and */
operator|*
name|string
operator|=
literal|'\n'
expr_stmt|;
comment|/* Assign '\n' for line_check */
if|if
condition|(
name|line_check
argument_list|(
name|program
argument_list|,
name|line
operator|->
name|text
argument_list|,
name|method
argument_list|)
operator|==
name|MATCH
condition|)
block|{
operator|*
name|string
operator|=
name|old_char
expr_stmt|;
comment|/* Restore char */
return|return
name|cur_line
return|;
comment|/* Found match */
block|}
operator|*
name|string
operator|=
name|old_char
expr_stmt|;
comment|/* No match, but restore char */
block|}
block|}
comment|/* No match in last (or first) part of line. Check out rest of file */
do|do
block|{
name|line
operator|=
operator|(
name|method
operator|==
name|FORWARD
operator|)
condition|?
name|line
operator|->
name|next
else|:
name|line
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|text
operator|==
name|NIL_PTR
condition|)
comment|/* Header/tail */
continue|continue;
if|if
condition|(
name|line_check
argument_list|(
name|program
argument_list|,
name|line
operator|->
name|text
argument_list|,
name|method
argument_list|)
operator|==
name|MATCH
condition|)
return|return
name|line
return|;
block|}
do|while
condition|(
name|line
operator|!=
name|cur_line
operator|&&
name|quit
operator|==
name|FALSE
condition|)
do|;
comment|/* No match found. */
return|return
name|NIL_LINE
return|;
block|}
end_function

begin_comment
comment|/*  * Line_check() checks the line (or rather string) for a match. Method  * indicates FORWARD or REVERSE search. It scans through the whole string  * until a match is found, or the end of the string is reached.  */
end_comment

begin_function
name|int
name|line_check
parameter_list|(
name|program
parameter_list|,
name|string
parameter_list|,
name|method
parameter_list|)
specifier|register
name|REGEX
modifier|*
name|program
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|FLAG
name|method
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|textp
init|=
name|string
decl_stmt|;
comment|/* Assign start_ptr field. We might find a match right away! */
name|program
operator|->
name|start_ptr
operator|=
name|textp
expr_stmt|;
comment|/* If the match must be anchored, just check the string. */
if|if
condition|(
name|program
operator|->
name|status
operator|&
name|BEGIN_LINE
condition|)
return|return
name|check_string
argument_list|(
name|program
argument_list|,
name|string
argument_list|,
name|NIL_INT
argument_list|)
return|;
if|if
condition|(
name|method
operator|==
name|REVERSE
condition|)
block|{
comment|/* First move to the end of the string */
for|for
control|(
name|textp
operator|=
name|string
init|;
operator|*
name|textp
operator|!=
literal|'\n'
condition|;
name|textp
operator|++
control|)
empty_stmt|;
comment|/* Start checking string until the begin of the string is met */
while|while
condition|(
name|textp
operator|>=
name|string
condition|)
block|{
name|program
operator|->
name|start_ptr
operator|=
name|textp
expr_stmt|;
if|if
condition|(
name|check_string
argument_list|(
name|program
argument_list|,
name|textp
operator|--
argument_list|,
name|NIL_INT
argument_list|)
condition|)
return|return
name|MATCH
return|;
block|}
block|}
else|else
block|{
comment|/* Move through the string until the end of is found */
while|while
condition|(
name|quit
operator|==
name|FALSE
operator|&&
operator|*
name|textp
operator|!=
literal|'\0'
condition|)
block|{
name|program
operator|->
name|start_ptr
operator|=
name|textp
expr_stmt|;
if|if
condition|(
name|check_string
argument_list|(
name|program
argument_list|,
name|textp
argument_list|,
name|NIL_INT
argument_list|)
condition|)
return|return
name|MATCH
return|;
if|if
condition|(
operator|*
name|textp
operator|==
literal|'\n'
condition|)
break|break;
name|textp
operator|++
expr_stmt|;
block|}
block|}
return|return
name|NO_MATCH
return|;
block|}
end_function

begin_comment
comment|/*  * Check() checks of a match can be found in the given string. Whenever a STAR  * is found during matching, then the begin position of the string is marked  * and the maximum number of matches is performed. Then the function star()  * is called which starts to finish the match from this position of the string  * (and expression). Check() return MATCH for a match, NO_MATCH is the string   * couldn't be matched or REG_ERROR for an illegal opcode in expression.  */
end_comment

begin_function
name|int
name|check_string
parameter_list|(
name|program
parameter_list|,
name|string
parameter_list|,
name|expression
parameter_list|)
name|REGEX
modifier|*
name|program
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|expression
decl_stmt|;
block|{
specifier|register
name|int
name|opcode
decl_stmt|;
comment|/* Holds opcode of next expr. atom */
name|char
name|c
decl_stmt|;
comment|/* Char that must be matched */
name|char
modifier|*
name|mark
decl_stmt|;
comment|/* For marking position */
name|int
name|star_fl
decl_stmt|;
comment|/* A star has been born */
if|if
condition|(
name|expression
operator|==
name|NIL_INT
condition|)
name|expression
operator|=
name|program
operator|->
name|result
operator|.
name|expression
expr_stmt|;
comment|/* Loop until end of string or end of expression */
while|while
condition|(
name|quit
operator|==
name|FALSE
operator|&&
operator|!
operator|(
operator|*
name|expression
operator|&
name|DONE
operator|)
operator|&&
operator|*
name|string
operator|!=
literal|'\0'
operator|&&
operator|*
name|string
operator|!=
literal|'\n'
condition|)
block|{
name|c
operator|=
operator|*
name|expression
operator|&
name|LOW_BYTE
expr_stmt|;
comment|/* Extract match char */
name|opcode
operator|=
operator|*
name|expression
operator|&
name|HIGH_BYTE
expr_stmt|;
comment|/* Extract opcode */
if|if
condition|(
name|star_fl
operator|=
operator|(
name|opcode
operator|&
name|STAR
operator|)
condition|)
block|{
comment|/* Check star occurrence */
name|opcode
operator|&=
operator|~
name|STAR
expr_stmt|;
comment|/* Strip opcode */
name|mark
operator|=
name|string
expr_stmt|;
comment|/* Mark current position */
block|}
name|expression
operator|++
expr_stmt|;
comment|/* Increment expr. */
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|NORMAL
case|:
if|if
condition|(
name|star_fl
condition|)
while|while
condition|(
operator|*
name|string
operator|++
operator|==
name|c
condition|)
comment|/* Skip all matches */
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|string
operator|++
operator|!=
name|c
condition|)
return|return
name|NO_MATCH
return|;
break|break;
case|case
name|DOT
case|:
name|string
operator|++
expr_stmt|;
if|if
condition|(
name|star_fl
condition|)
comment|/* Skip to eoln */
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
operator|&&
operator|*
name|string
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
name|NEGATE
operator||
name|BRACKET
case|:
case|case
name|BRACKET
case|:
if|if
condition|(
name|star_fl
condition|)
while|while
condition|(
name|in_list
argument_list|(
name|expression
argument_list|,
operator|*
name|string
operator|++
argument_list|,
name|c
argument_list|,
name|opcode
argument_list|)
operator|==
name|MATCH
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|in_list
argument_list|(
name|expression
argument_list|,
operator|*
name|string
operator|++
argument_list|,
name|c
argument_list|,
name|opcode
argument_list|)
operator|==
name|NO_MATCH
condition|)
return|return
name|NO_MATCH
return|;
name|expression
operator|+=
name|c
operator|-
literal|1
expr_stmt|;
comment|/* Add length of list */
break|break;
default|default :
name|panic
argument_list|(
literal|"Corrupted program in check_string()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|star_fl
condition|)
return|return
name|star
argument_list|(
name|program
argument_list|,
name|mark
argument_list|,
name|string
argument_list|,
name|expression
argument_list|)
return|;
block|}
if|if
condition|(
operator|*
name|expression
operator|&
name|DONE
condition|)
block|{
name|program
operator|->
name|end_ptr
operator|=
name|string
expr_stmt|;
comment|/* Match ends here */
comment|/*   	 * We might have found a match. The last thing to do is check   	 * whether a '$' was given at the end of the expression, or   	 * the match was found on a null string. (E.g. [a-z]* always   	 * matches) unless a ^ or $ was included in the pattern.   	 */
if|if
condition|(
operator|(
operator|*
name|expression
operator|&
name|EOLN
operator|)
operator|&&
operator|*
name|string
operator|!=
literal|'\n'
operator|&&
operator|*
name|string
operator|!=
literal|'\0'
condition|)
return|return
name|NO_MATCH
return|;
if|if
condition|(
name|string
operator|==
name|program
operator|->
name|start_ptr
operator|&&
operator|!
operator|(
name|program
operator|->
name|status
operator|&
name|BEGIN_LINE
operator|)
operator|&&
operator|!
operator|(
operator|*
name|expression
operator|&
name|EOLN
operator|)
condition|)
return|return
name|NO_MATCH
return|;
return|return
name|MATCH
return|;
block|}
return|return
name|NO_MATCH
return|;
block|}
end_function

begin_comment
comment|/*  * Star() calls check_string() to find out the longest match possible.  * It searches backwards until the (in check_string()) marked position  * is reached, or a match is found.  */
end_comment

begin_function
name|int
name|star
parameter_list|(
name|program
parameter_list|,
name|end_position
parameter_list|,
name|string
parameter_list|,
name|expression
parameter_list|)
name|REGEX
modifier|*
name|program
decl_stmt|;
specifier|register
name|char
modifier|*
name|end_position
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|expression
decl_stmt|;
block|{
do|do
block|{
name|string
operator|--
expr_stmt|;
if|if
condition|(
name|check_string
argument_list|(
name|program
argument_list|,
name|string
argument_list|,
name|expression
argument_list|)
condition|)
return|return
name|MATCH
return|;
block|}
do|while
condition|(
name|string
operator|!=
name|end_position
condition|)
do|;
return|return
name|NO_MATCH
return|;
block|}
end_function

begin_comment
comment|/*  * In_list() checks if the given character is in the list of []. If it is  * it returns MATCH. if it isn't it returns NO_MATCH. These returns values  * are reversed when the NEGATE field in the opcode is present.  */
end_comment

begin_function
name|int
name|in_list
parameter_list|(
name|list
parameter_list|,
name|c
parameter_list|,
name|list_length
parameter_list|,
name|opcode
parameter_list|)
specifier|register
name|int
modifier|*
name|list
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|list_length
decl_stmt|;
name|int
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|==
literal|'\n'
condition|)
comment|/* End of string, never matches */
return|return
name|NO_MATCH
return|;
while|while
condition|(
name|list_length
operator|--
operator|>
literal|1
condition|)
block|{
comment|/*> 1, don't check acct_field */
if|if
condition|(
operator|(
operator|*
name|list
operator|&
name|LOW_BYTE
operator|)
operator|==
name|c
condition|)
return|return
operator|(
name|opcode
operator|&
name|NEGATE
operator|)
condition|?
name|NO_MATCH
else|:
name|MATCH
return|;
name|list
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|opcode
operator|&
name|NEGATE
operator|)
condition|?
name|MATCH
else|:
name|NO_MATCH
return|;
block|}
end_function

begin_comment
comment|/*  * Dummy_line() adds an empty line at the end of the file. This is sometimes  * useful in combination with the EF and DN command in combination with the  * Yank command set.  */
end_comment

begin_function
name|void
name|dummy_line
parameter_list|()
block|{
operator|(
name|void
operator|)
name|line_insert
argument_list|(
name|tail
operator|->
name|prev
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tail
operator|->
name|prev
operator|->
name|shift_count
operator|=
name|DUMMY
expr_stmt|;
if|if
condition|(
name|last_y
operator|!=
name|screenmax
condition|)
block|{
name|last_y
operator|++
expr_stmt|;
name|bot_line
operator|=
name|bot_line
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

