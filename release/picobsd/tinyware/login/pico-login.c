begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1987, 1988, 1991, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char copyright[] = "@(#) Copyright (c) 1980, 1987, 1988, 1991, 1993, 1994\n\ 	The Regents of the University of California.  All rights reserved.\n";
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)login.c	8.4 (Berkeley) 4/2/94";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$ #endif /* not lint */  /*  * login [ name ]  * login -h hostname	(for telnetd, etc.)  * login -f name	(for pre-authenticated login: datakit, xterm, etc.)  */  #include<sys/copyright.h> #include<sys/param.h> #include<sys/stat.h> #include<sys/socket.h> #include<sys/time.h> #include<sys/resource.h> #include<sys/file.h> #include<netinet/in.h> #include<arpa/inet.h>  #include<err.h> #include<errno.h> #include<grp.h> #include<libutil.h> #include<login_cap.h> #include<netdb.h> #include<pwd.h> #include<setjmp.h> #include<signal.h> #include<stdio.h> #include<stdlib.h> #include<string.h> #include<syslog.h> #include<ttyent.h> #include<unistd.h> #include<utmp.h>  #ifdef USE_PAM #include<security/pam_appl.h> #include<security/pam_misc.h> #include<sys/wait.h> #endif /* USE_PAM */  #include "
name|pathnames
operator|.
name|h
literal|"  /* wrapper for KAME-special getnameinfo() */ #ifndef NI_WITHSCOPEID #define	NI_WITHSCOPEID	0 #endif  void	 badlogin __P((char *)); void	 checknologin __P((void)); void	 dolastlog __P((int)); void	 getloginname __P((void)); void	 motd __P((char *)); int	 rootterm __P((char *)); void	 sigint __P((int)); void	 sleepexit __P((int)); void	 refused __P((char *,char *,int)); char	*stypeof __P((char *)); void	 timedout __P((int)); int	 login_access __P((char *, char *)); void     login_fbtab __P((char *, uid_t, gid_t));  #ifdef USE_PAM static int auth_pam __P((void)); static int export_pam_environment __P((void)); static int ok_to_export __P((const char *));  static pam_handle_t *pamh = NULL; static char **environ_pam;  #define PAM_END { \ 	if ((e = pam_setcred(pamh, PAM_DELETE_CRED)) != PAM_SUCCESS) \ 		syslog(LOG_ERR, "
name|pam_setcred
operator|:
operator|%
name|s
literal|", pam_strerror(pamh, e)); \ 	if ((e = pam_close_session(pamh,0)) != PAM_SUCCESS) \ 		syslog(LOG_ERR, "
name|pam_close_session
operator|:
operator|%
name|s
literal|", pam_strerror(pamh, e)); \ 	if ((e = pam_end(pamh, e)) != PAM_SUCCESS) \ 		syslog(LOG_ERR, "
name|pam_end
operator|:
operator|%
name|s
literal|", pam_strerror(pamh, e)); \ } #endif  static int auth_traditional __P((void)); extern void login __P((struct utmp *)); static void usage __P((void));  #define	TTYGRPNAME	"
name|tty
literal|"		/* name of group to own ttys */ #define	DEFAULT_BACKOFF	3 #define	DEFAULT_RETRIES	10 #define	DEFAULT_PROMPT		"
name|login
operator|:
literal|" #define	DEFAULT_PASSWD_PROMPT	"
name|Password
operator|:
literal|"  /*  * This bounds the time given to login.  Not a define so it can  * be patched on machines where it's too small.  */ u_int	timeout = 300;  /* Buffer for signal handling of timeout */ jmp_buf timeout_buf;  struct	passwd *pwd; int	failures; char	*term, *envinit[1], *hostname, *passwd_prompt, *prompt, *tty, *username; char    full_hostname[MAXHOSTNAMELEN];  int main(argc, argv) 	int argc; 	char *argv[]; { 	extern char **environ; 	struct group *gr; 	struct stat st; 	struct timeval tp; 	struct utmp utmp; 	int rootok, retries, backoff; 	int ask, ch, cnt, fflag, hflag, pflag, quietlog, rootlogin, rval; 	int changepass; 	time_t warntime; 	uid_t uid, euid; 	gid_t egid; 	char *p, *ttyn; 	char tbuf[MAXPATHLEN + 2]; 	char tname[sizeof(_PATH_TTY) + 10]; 	char *shell = NULL; 	login_cap_t *lc = NULL; #ifdef USE_PAM 	pid_t pid; 	int e; #endif /* USE_PAM */  	(void)signal(SIGQUIT, SIG_IGN); 	(void)signal(SIGINT, SIG_IGN); 	(void)signal(SIGHUP, SIG_IGN); 	if (setjmp(timeout_buf)) { 		if (failures) 			badlogin(tbuf); 		(void)fprintf(stderr, "
name|Login
name|timed
name|out
name|after
operator|%
name|d
name|seconds
operator|\
name|n
literal|", 		    timeout); 		exit(0); 	} 	(void)signal(SIGALRM, timedout); 	(void)alarm(timeout); 	(void)setpriority(PRIO_PROCESS, 0, 0);  	openlog("
name|login
literal|", LOG_ODELAY, LOG_AUTH);  	/* 	 * -p is used by getty to tell login not to destroy the environment 	 * -f is used to skip a second login authentication 	 * -h is used by other servers to pass the name of the remote 	 *    host to login so that it may be placed in utmp and wtmp 	 */ 	*full_hostname = '\0'; 	term = NULL;  	fflag = hflag = pflag = 0; 	uid = getuid(); 	euid = geteuid(); 	egid = getegid(); 	while ((ch = getopt(argc, argv, "
name|fh
operator|:
name|p
literal|")) != -1) 		switch (ch) { 		case 'f': 			fflag = 1; 			break; 		case 'h': 			if (uid) 				errx(1, "
operator|-
name|h
name|option
operator|:
operator|%
name|s
literal|", strerror(EPERM)); 			hflag = 1; 			if (strlcpy(full_hostname, optarg, 			    sizeof(full_hostname))>= sizeof(full_hostname)) 				errx(1, "
operator|-
name|h
name|option
operator|:
operator|%
name|s
operator|:
name|exceeds
name|maximum
literal|" 				    "
name|hostname
name|size
literal|", optarg);  			trimdomain(optarg, UT_HOSTSIZE);  			if (strlen(optarg)> UT_HOSTSIZE) { 				struct addrinfo hints, *res; 				int ga_err; 				 				memset(&hints, 0, sizeof(hints)); 				hints.ai_family = AF_UNSPEC; 				ga_err = getaddrinfo(optarg, NULL,&hints,&res); 				if (ga_err == 0) { 					char hostbuf[MAXHOSTNAMELEN];  					getnameinfo(res->ai_addr, 					    res->ai_addrlen, 					    hostbuf, 					    sizeof(hostbuf), NULL, 0, 					    NI_NUMERICHOST| 					    NI_WITHSCOPEID); 					optarg = strdup(hostbuf); 					if (optarg == NULL) { 						syslog(LOG_NOTICE, 						    "
name|strdup
argument_list|()
operator|:
operator|%
name|m
literal|"); 						sleepexit(1); 					} 				} else 					optarg = "
name|invalid
name|hostname
literal|"; 				if (res != NULL) 					freeaddrinfo(res); 			} 			hostname = optarg; 			break; 		case 'p': 			pflag = 1; 			break; 		case '?': 		default: 			if (!uid) 				syslog(LOG_ERR, "
name|invalid
name|flag
operator|%
name|c
literal|", ch); 			usage(); 		} 	argc -= optind; 	argv += optind;  	if (*argv) { 		username = *argv; 		ask = 0; 	} else 		ask = 1;  	for (cnt = getdtablesize(); cnt> 2; cnt--) 		(void)close(cnt);  	ttyn = ttyname(STDIN_FILENO); 	if (ttyn == NULL || *ttyn == '\0') { 		(void)snprintf(tname, sizeof(tname), "
operator|%
name|s
operator|??
literal|", _PATH_TTY); 		ttyn = tname; 	} 	if ((tty = strrchr(ttyn, '/')) != NULL) 		++tty; 	else 		tty = ttyn;  	/* 	 * Get "
name|login
operator|-
name|retries
literal|"& "
name|login
operator|-
name|backoff
literal|" from default class 	 */ 	lc = login_getclass(NULL); 	prompt = login_getcapstr(lc, "
name|prompt
literal|", DEFAULT_PROMPT, DEFAULT_PROMPT); 	passwd_prompt = login_getcapstr(lc, "
name|passwd_prompt
literal|", 	    DEFAULT_PASSWD_PROMPT, DEFAULT_PASSWD_PROMPT); 	retries = login_getcapnum(lc, "
name|login
operator|-
name|retries
literal|", DEFAULT_RETRIES, 	    DEFAULT_RETRIES); 	backoff = login_getcapnum(lc, "
name|login
operator|-
name|backoff
literal|", DEFAULT_BACKOFF, 	    DEFAULT_BACKOFF); 	login_close(lc); 	lc = NULL;  	for (cnt = 0;; ask = 1) { 		if (ask) { 			fflag = 0; 			getloginname(); 		} 		rootlogin = 0; 		rootok = rootterm(tty); /* Default (auth may change) */  		if (strlen(username)> UT_NAMESIZE) 			username[UT_NAMESIZE] = '\0';  		/* 		 * Note if trying multiple user names; log failures for 		 * previous user name, but don't bother logging one failure 		 * for nonexistent name (mistyped username). 		 */ 		if (failures&& strcmp(tbuf, username)) { 			if (failures> (pwd ? 0 : 1)) 				badlogin(tbuf); 		} 		(void)strlcpy(tbuf, username, sizeof(tbuf));  		pwd = getpwnam(username);  		/* 		 * if we have a valid account name, and it doesn't have a 		 * password, or the -f option was specified and the caller 		 * is root or the caller isn't changing their uid, don't 		 * authenticate. 		 */ 		if (pwd != NULL) { 			if (pwd->pw_uid == 0) 				rootlogin = 1;  			if (fflag&& (uid == (uid_t)0 || 			    uid == (uid_t)pwd->pw_uid)) { 				/* already authenticated */ 				break; 			} else if (pwd->pw_passwd[0] == '\0') { 				if (!rootlogin || rootok) { 					/* pretend password okay */ 					rval = 0; 					goto ttycheck; 				} 			} 		}  		fflag = 0;  		(void)setpriority(PRIO_PROCESS, 0, -4);  #ifdef USE_PAM 		/* 		 * Try to authenticate using PAM.  If a PAM system error 		 * occurs, perhaps because of a botched configuration, 		 * then fall back to using traditional Unix authentication. 		 */ 		if ((rval = auth_pam()) == -1) #endif /* USE_PAM */ 			rval = auth_traditional();  		(void)setpriority(PRIO_PROCESS, 0, 0);  #ifdef USE_PAM 		/* 		 * PAM authentication may have changed "
name|pwd
literal|" to the 		 * entry for the template user.  Check again to see if 		 * this is a root login after all. 		 */ 		if (pwd != NULL&& pwd->pw_uid == 0) 			rootlogin = 1; #endif /* USE_PAM */  	ttycheck: 		/* 		 * If trying to log in as root without Kerberos, 		 * but with insecure terminal, refuse the login attempt. 		 */ 		if (pwd&& !rval) { 			if (rootlogin&& !rootok) 				refused(NULL, "
name|NOROOT
literal|", 0); 			else	/* valid password& authenticated */ 				break; 		}  		(void)printf("
name|Login
name|incorrect
operator|\
name|n
literal|"); 		failures++;  		/* 		 * we allow up to 'retry' (10) tries, 		 * but after 'backoff' (3) we start backing off 		 */ 		if (++cnt> backoff) { 			if (cnt>= retries) { 				badlogin(username); 				sleepexit(1); 			} 			sleep((u_int)((cnt - backoff) * 5)); 		} 	}  	/* committed to login -- turn off timeout */ 	(void)alarm((u_int)0); 	(void)signal(SIGHUP, SIG_DFL);  	endpwent();  	/* 	 * Establish the login class. 	 */ 	lc = login_getpwclass(pwd);  	/* if user not super-user, check for disabled logins */ 	if (!rootlogin) 		auth_checknologin(lc);  	quietlog = login_getcapbool(lc, "
name|hushlogin
literal|", 0); 	/* 	 * Switching needed for NFS with root access disabled. 	 * 	 * XXX: This change fails to modify the additional groups for the 	 * process, and as such, may restrict rights normally granted 	 * through those groups. 	 */ 	(void)setegid(pwd->pw_gid); 	(void)seteuid(rootlogin ? 0 : pwd->pw_uid); 	if (!*pwd->pw_dir || chdir(pwd->pw_dir)< 0) { 		if (login_getcapbool(lc, "
name|requirehome
literal|", 0)) 			refused("
name|Home
name|directory
name|not
name|available
literal|", "
name|HOMEDIR
literal|", 1); 		if (chdir("
operator|/
literal|")< 0)  			refused("
name|Cannot
name|find
name|root
name|directory
literal|", "
name|ROOTDIR
literal|", 1); 		if (!quietlog || *pwd->pw_dir) 			printf("
name|No
name|home
name|directory
operator|.
expr|\
name|nLogging
name|in
name|with
name|home
operator|=
operator|\
literal|"/\".\n"
init|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pwd
operator|->
name|pw_dir
operator|=
literal|"/"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 	(
name|void
end_expr_stmt

begin_expr_stmt
unit|)
name|seteuid
argument_list|(
name|euid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|setegid
argument_list|(
name|egid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|quietlog
condition|)
name|quietlog
operator|=
name|access
argument_list|(
name|_PATH_HUSHLOGIN
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|||
name|pwd
operator|->
name|pw_expire
condition|)
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
end_if

begin_define
define|#
directive|define
name|DEFAULT_WARN
value|(2L * 7L * 86400L)
end_define

begin_comment
comment|/* Two weeks */
end_comment

begin_expr_stmt
name|warntime
operator|=
name|login_getcaptime
argument_list|(
name|lc
argument_list|,
literal|"warnexpire"
argument_list|,
name|DEFAULT_WARN
argument_list|,
name|DEFAULT_WARN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pwd
operator|->
name|pw_expire
condition|)
block|{
if|if
condition|(
name|tp
operator|.
name|tv_sec
operator|>=
name|pwd
operator|->
name|pw_expire
condition|)
block|{
name|refused
argument_list|(
literal|"Sorry -- your account has expired"
argument_list|,
literal|"EXPIRED"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pwd
operator|->
name|pw_expire
operator|-
name|tp
operator|.
name|tv_sec
operator|<
name|warntime
operator|&&
operator|!
name|quietlog
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Warning: your account expires on %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_expire
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|warntime
operator|=
name|login_getcaptime
argument_list|(
name|lc
argument_list|,
literal|"warnpassword"
argument_list|,
name|DEFAULT_WARN
argument_list|,
name|DEFAULT_WARN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|changepass
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pwd
operator|->
name|pw_change
condition|)
block|{
if|if
condition|(
name|tp
operator|.
name|tv_sec
operator|>=
name|pwd
operator|->
name|pw_change
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Sorry -- your password has expired.\n"
argument_list|)
expr_stmt|;
name|changepass
operator|=
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s Password expired - forcing change"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|-
name|tp
operator|.
name|tv_sec
operator|<
name|warntime
operator|&&
operator|!
name|quietlog
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Warning: your password expires on %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_change
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|lc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hostname
condition|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|ga_err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ga_err
operator|=
name|getaddrinfo
argument_list|(
name|full_hostname
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ga_err
operator|==
literal|0
condition|)
block|{
name|char
name|hostbuf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|getnameinfo
argument_list|(
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|,
name|hostbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_WITHSCOPEID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optarg
operator|=
name|strdup
argument_list|(
name|hostbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"strdup(): %m"
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|optarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth_hostok
argument_list|(
name|lc
argument_list|,
name|full_hostname
argument_list|,
name|optarg
argument_list|)
condition|)
name|refused
argument_list|(
literal|"Permission denied"
argument_list|,
literal|"HOST"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|auth_ttyok
argument_list|(
name|lc
argument_list|,
name|tty
argument_list|)
condition|)
name|refused
argument_list|(
literal|"Permission denied"
argument_list|,
literal|"TTY"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth_timeok
argument_list|(
name|lc
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
condition|)
name|refused
argument_list|(
literal|"Logins not available right now"
argument_list|,
literal|"TIME"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|shell
operator|=
name|login_getcapstr
argument_list|(
name|lc
argument_list|,
literal|"shell"
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|pwd
operator|->
name|pw_shell
operator|==
literal|'\0'
condition|)
name|pwd
operator|->
name|pw_shell
operator|=
name|_PATH_BSHELL
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|*
name|shell
operator|==
literal|'\0'
condition|)
comment|/* Not overridden */
name|shell
operator|=
name|pwd
operator|->
name|pw_shell
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|shell
operator|=
name|strdup
argument_list|(
name|shell
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"strdup(): %m"
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|LOGIN_ACCESS
end_ifdef

begin_if
if|if
condition|(
name|login_access
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|hostname
condition|?
name|full_hostname
else|:
name|tty
argument_list|)
operator|==
literal|0
condition|)
name|refused
argument_list|(
literal|"Permission denied"
argument_list|,
literal|"ACCESS"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOGIN_ACCESS */
end_comment

begin_comment
comment|/* Nothing else left to fail -- really log in. */
end_comment

begin_expr_stmt
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|utmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|utmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|hostname
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|login
argument_list|(
operator|&
name|utmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dolastlog
argument_list|(
name|quietlog
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Set device protections, depending on what terminal the 	 * user is logged in. This feature is used on Suns to give 	 * console users better privacy. 	 */
end_comment

begin_expr_stmt
name|login_fbtab
argument_list|(
name|tty
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Clear flags of the tty.  None should be set, and when the 	 * user sets them otherwise, this can cause the chown to fail. 	 * Since it isn't clear that flags are useful on character 	 * devices, we just clear them. 	 */
end_comment

begin_if
if|if
condition|(
name|chflags
argument_list|(
name|ttyn
argument_list|,
literal|0
argument_list|)
operator|&&
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chmod(%s): %m"
argument_list|,
name|ttyn
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|chown
argument_list|(
name|ttyn
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
operator|(
name|gr
operator|=
name|getgrnam
argument_list|(
name|TTYGRPNAME
argument_list|)
operator|)
condition|?
name|gr
operator|->
name|gr_gid
else|:
name|pwd
operator|->
name|pw_gid
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chmod(%s): %m"
argument_list|,
name|ttyn
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	 * Preserve TERM if it happens to be already set. 	 */
end_comment

begin_if
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|term
operator|=
name|strdup
argument_list|(
name|term
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"strdup(): %m"
argument_list|)
expr_stmt|;
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* 	 * Exclude cons/vt/ptys only, assume dialup otherwise 	 * TODO: Make dialup tty determination a library call 	 * for consistency (finger etc.) 	 */
end_comment

begin_if
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|isdialuptty
argument_list|(
name|tty
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DIALUP %s, %s"
argument_list|,
name|tty
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|LOGALL
end_ifdef

begin_comment
comment|/* 	 * Syslog each successful login, so we don't have to watch hundreds 	 * of wtmp or lastlogin files. 	 */
end_comment

begin_if
if|if
condition|(
name|hostname
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"login from %s on %s as %s"
argument_list|,
name|full_hostname
argument_list|,
name|tty
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"login on %s as %s"
argument_list|,
name|tty
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	 * If fflag is on, assume caller/authenticator has logged root login. 	 */
end_comment

begin_if
if|if
condition|(
name|rootlogin
operator|&&
name|fflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hostname
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN (%s) ON %s FROM %s"
argument_list|,
name|username
argument_list|,
name|tty
argument_list|,
name|full_hostname
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN (%s) ON %s"
argument_list|,
name|username
argument_list|,
name|tty
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	 * Destroy environment unless user has requested its preservation. 	 * We need to do this before setusercontext() because that may 	 * set or reset some environment variables. 	 */
end_comment

begin_if
if|if
condition|(
operator|!
name|pflag
condition|)
name|environ
operator|=
name|envinit
expr_stmt|;
end_if

begin_comment
comment|/* 	 * PAM modules might add supplementary groups during pam_setcred(). 	 */
end_comment

begin_if
if|if
condition|(
name|setusercontext
argument_list|(
name|lc
argument_list|,
name|pwd
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|LOGIN_SETGROUP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setusercontext() failed - exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PAM
end_ifdef

begin_if
if|if
condition|(
name|pamh
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|pam_open_session
argument_list|(
name|pamh
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_open_session: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|e
operator|=
name|pam_setcred
argument_list|(
name|pamh
argument_list|,
name|PAM_ESTABLISH_CRED
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_setcred: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	         * Add any environmental variables that the 	         * PAM modules may have set. 		 * Call *after* opening session! 		 */
if|if
condition|(
name|pamh
condition|)
block|{
name|environ_pam
operator|=
name|pam_getenvlist
argument_list|(
name|pamh
argument_list|)
expr_stmt|;
if|if
condition|(
name|environ_pam
condition|)
name|export_pam_environment
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * We must fork() before setuid() because we need to call 		 * pam_close_session() as root. 		 */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
name|PAM_END
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
condition|)
block|{
comment|/* parent - wait for child to finish, then cleanup 			   session */
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|PAM_END
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|pam_end
argument_list|(
name|pamh
argument_list|,
name|PAM_DATA_SILENT
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_end: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PAM */
end_comment

begin_comment
comment|/* 	 * We don't need to be root anymore, so 	 * set the user and session context 	 */
end_comment

begin_if
if|if
condition|(
name|setlogin
argument_list|(
name|username
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setlogin(%s): %m - exiting"
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|setusercontext
argument_list|(
name|lc
argument_list|,
name|pwd
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|LOGIN_SETALL
operator|&
operator|~
operator|(
name|LOGIN_SETLOGIN
operator||
name|LOGIN_SETGROUP
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setusercontext() failed - exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"SHELL"
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"HOME"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|term
operator|!=
name|NULL
operator|&&
operator|*
name|term
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"TERM"
argument_list|,
name|term
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Preset overrides */
else|else
block|{
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"TERM"
argument_list|,
name|stypeof
argument_list|(
name|tty
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fallback doesn't */
block|}
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"LOGNAME"
argument_list|,
name|username
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"USER"
argument_list|,
name|username
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
name|rootlogin
condition|?
name|_PATH_STDPATH
else|:
name|_PATH_DEFPATH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|quietlog
condition|)
block|{
name|char
modifier|*
name|cw
decl_stmt|;
name|cw
operator|=
name|login_getcapstr
argument_list|(
name|lc
argument_list|,
literal|"copyright"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|!=
name|NULL
operator|&&
name|access
argument_list|(
name|cw
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
name|motd
argument_list|(
name|cw
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n\t%s %s\n"
argument_list|,
literal|"Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994"
argument_list|,
literal|"The Regents of the University of California. "
argument_list|,
literal|"All rights reserved."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cw
operator|=
name|login_getcapstr
argument_list|(
name|lc
argument_list|,
literal|"welcome"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|==
name|NULL
operator|||
name|access
argument_list|(
name|cw
argument_list|,
name|F_OK
argument_list|)
operator|!=
literal|0
condition|)
name|cw
operator|=
name|_PATH_MOTDFILE
expr_stmt|;
name|motd
argument_list|(
name|cw
argument_list|)
expr_stmt|;
name|cw
operator|=
name|getenv
argument_list|(
literal|"MAIL"
argument_list|)
expr_stmt|;
comment|/* $MAIL may have been set by class */
if|if
condition|(
name|cw
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|tbuf
argument_list|,
name|cw
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_size
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"You have %smail.\n"
argument_list|,
operator|(
name|st
operator|.
name|st_mtime
operator|>
name|st
operator|.
name|st_atime
operator|)
condition|?
literal|"new "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Login shells have a leading '-' in front of argv[0] 	 */
end_comment

begin_if
if|if
condition|(
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"-%s"
argument_list|,
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|?
name|p
operator|+
literal|1
else|:
name|pwd
operator|->
name|pw_shell
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"user: %s: shell exceeds maximum pathname size"
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"shell exceeds maximum pathname size"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|execlp
argument_list|(
name|shell
argument_list|,
name|tbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|shell
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|int
name|auth_traditional
parameter_list|()
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|salt
decl_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
name|salt
operator|=
name|pwd
operator|!=
name|NULL
condition|?
name|pwd
operator|->
name|pw_passwd
else|:
literal|"xx"
expr_stmt|;
name|p
operator|=
name|getpass
argument_list|(
name|passwd_prompt
argument_list|)
expr_stmt|;
name|ep
operator|=
name|crypt
argument_list|(
name|p
argument_list|,
name|salt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
condition|)
block|{
if|if
condition|(
operator|!
name|p
index|[
literal|0
index|]
operator|&&
name|pwd
operator|->
name|pw_passwd
index|[
literal|0
index|]
condition|)
name|ep
operator|=
literal|":"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ep
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
operator|==
literal|0
condition|)
name|rval
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clear entered password */
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PAM
end_ifdef

begin_comment
comment|/*  * Attempt to authenticate the user using PAM.  Returns 0 if the user is  * authenticated, or 1 if not authenticated.  If some sort of PAM system  * error occurs (e.g., the "/etc/pam.conf" file is missing) then this  * function returns -1.  This can be used as an indication that we should  * fall back to a different authentication mechanism.  */
end_comment

begin_function
specifier|static
name|int
name|auth_pam
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|tmpl_user
decl_stmt|;
specifier|const
name|void
modifier|*
name|item
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|e
decl_stmt|;
specifier|static
name|struct
name|pam_conv
name|conv
init|=
block|{
name|misc_conv
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|pam_start
argument_list|(
literal|"login"
argument_list|,
name|username
argument_list|,
operator|&
name|conv
argument_list|,
operator|&
name|pamh
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_start: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_TTY
argument_list|,
name|tty
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_set_item(PAM_TTY): %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hostname
operator|!=
name|NULL
operator|&&
operator|(
name|e
operator|=
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_RHOST
argument_list|,
name|full_hostname
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_set_item(PAM_RHOST): %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|e
operator|=
name|pam_authenticate
argument_list|(
name|pamh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|PAM_SUCCESS
case|:
comment|/* 		 * With PAM we support the concept of a "template" 		 * user.  The user enters a login name which is 		 * authenticated by PAM, usually via a remote service 		 * such as RADIUS or TACACS+.  If authentication 		 * succeeds, a different but related "template" name 		 * is used for setting the credentials, shell, and 		 * home directory.  The name the user enters need only 		 * exist on the remote authentication server, but the 		 * template name must be present in the local password 		 * database. 		 * 		 * This is supported by two various mechanisms in the 		 * individual modules.  However, from the application's 		 * point of view, the template user is always passed 		 * back as a changed value of the PAM_USER item. 		 */
if|if
condition|(
operator|(
name|e
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_USER
argument_list|,
operator|&
name|item
argument_list|)
operator|)
operator|==
name|PAM_SUCCESS
condition|)
block|{
name|tmpl_user
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|item
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|username
argument_list|,
name|tmpl_user
argument_list|)
operator|!=
literal|0
condition|)
name|pwd
operator|=
name|getpwnam
argument_list|(
name|tmpl_user
argument_list|)
expr_stmt|;
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Couldn't get PAM_USER: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PAM_AUTH_ERR
case|:
case|case
name|PAM_USER_UNKNOWN
case|:
case|case
name|PAM_MAXTRIES
case|:
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_authenticate: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|e
operator|=
name|pam_acct_mgmt
argument_list|(
name|pamh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|PAM_NEW_AUTHTOK_REQD
condition|)
block|{
name|e
operator|=
name|pam_chauthtok
argument_list|(
name|pamh
argument_list|,
name|PAM_CHANGE_EXPIRED_AUTHTOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_chauthtok: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|rval
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|pam_end
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|PAM_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pam_end: %s"
argument_list|,
name|pam_strerror
argument_list|(
name|pamh
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pamh
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|export_pam_environment
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|environ_pam
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|ok_to_export
argument_list|(
operator|*
name|pp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putenv
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Sanity checks on PAM environmental variables:  * - Make sure there is an '=' in the string.  * - Make sure the string doesn't run on too long.  * - Do not export certain variables.  This list was taken from the  *   Solaris pam_putenv(3) man page.  */
end_comment

begin_function
specifier|static
name|int
name|ok_to_export
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|noexport
index|[]
init|=
block|{
literal|"SHELL"
block|,
literal|"HOME"
block|,
literal|"LOGNAME"
block|,
literal|"MAIL"
block|,
literal|"CDPATH"
block|,
literal|"IFS"
block|,
literal|"PATH"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
literal|1024
operator|||
name|strchr
argument_list|(
name|s
argument_list|,
literal|'='
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"LD_"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|pp
operator|=
name|noexport
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
name|n
operator|=
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|n
index|]
operator|==
literal|'='
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
operator|*
name|pp
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PAM */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: login [-fp] [-h hostname] [username]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow for authentication style and/or kerberos instance  */
end_comment

begin_define
define|#
directive|define
name|NBUFSIZ
value|UT_NAMESIZE + 64
end_define

begin_function
name|void
name|getloginname
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|nbuf
index|[
name|NBUFSIZ
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nbuf
init|;
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|;
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|badlogin
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|nbuf
operator|+
operator|(
name|NBUFSIZ
operator|-
literal|1
operator|)
condition|)
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>
name|nbuf
condition|)
block|{
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"login names may not start with '-'.\n"
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|username
operator|=
name|nbuf
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|rootterm
parameter_list|(
name|ttyn
parameter_list|)
name|char
modifier|*
name|ttyn
decl_stmt|;
block|{
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
return|return
operator|(
operator|(
name|t
operator|=
name|getttynam
argument_list|(
name|ttyn
argument_list|)
operator|)
operator|&&
name|t
operator|->
name|ty_status
operator|&
name|TTY_SECURE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|volatile
name|int
name|motdinterrupt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sigint
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
name|__unused
decl_stmt|;
block|{
name|motdinterrupt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|motd
parameter_list|(
name|motdfile
parameter_list|)
name|char
modifier|*
name|motdfile
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|nchars
decl_stmt|;
name|sig_t
name|oldint
decl_stmt|;
name|char
name|tbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|motdfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|motdinterrupt
operator|=
literal|0
expr_stmt|;
name|oldint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nchars
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|!
name|motdinterrupt
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|tbuf
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldint
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|timedout
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|timeout_buf
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dolastlog
parameter_list|(
name|quiet
parameter_list|)
name|int
name|quiet
decl_stmt|;
block|{
name|struct
name|lastlog
name|ll
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_LASTLOG
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
operator|&&
name|ll
operator|.
name|ll_time
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Last login: %.*s "
argument_list|,
literal|24
operator|-
literal|5
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ctime
argument_list|(
operator|&
name|ll
operator|.
name|ll_time
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ll
operator|.
name|ll_host
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"from %.*s\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_host
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"on %.*s\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_line
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ll
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|ll
operator|.
name|ll_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot open %s: %m"
argument_list|,
name|_PATH_LASTLOG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|badlogin
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|failures
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hostname
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s FROM %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|full_hostname
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_AUTHPRIV
operator||
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s FROM %s, %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|full_hostname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s ON %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_AUTHPRIV
operator||
name|LOG_NOTICE
argument_list|,
literal|"%d LOGIN FAILURE%s ON %s, %s"
argument_list|,
name|failures
argument_list|,
name|failures
operator|>
literal|1
condition|?
literal|"S"
else|:
literal|""
argument_list|,
name|tty
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|failures
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|UNKNOWN
end_undef

begin_define
define|#
directive|define
name|UNKNOWN
value|"su"
end_define

begin_function
name|char
modifier|*
name|stypeof
parameter_list|(
name|ttyid
parameter_list|)
name|char
modifier|*
name|ttyid
decl_stmt|;
block|{
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ttyid
operator|!=
name|NULL
operator|&&
operator|*
name|ttyid
operator|!=
literal|'\0'
condition|)
block|{
name|t
operator|=
name|getttynam
argument_list|(
name|ttyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|ty_type
operator|!=
name|NULL
condition|)
return|return
operator|(
name|t
operator|->
name|ty_type
operator|)
return|;
block|}
return|return
operator|(
name|UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|void
name|refused
parameter_list|(
name|msg
parameter_list|,
name|rtype
parameter_list|,
name|lout
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
name|int
name|lout
decl_stmt|;
block|{
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s.\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"LOGIN %s REFUSED (%s) FROM %s ON TTY %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|rtype
argument_list|,
name|full_hostname
argument_list|,
name|tty
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"LOGIN %s REFUSED (%s) ON TTY %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|rtype
argument_list|,
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|lout
condition|)
name|sleepexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sleepexit
parameter_list|(
name|eval
parameter_list|)
name|int
name|eval
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

