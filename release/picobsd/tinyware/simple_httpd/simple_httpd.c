begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Simple_HTTPd v1.1 - a very small, barebones HTTP server  *   * Copyright (c) 1998-1999 Marc Nicholas<marc@netstor.com>  * All rights reserved.  *  * Major rewrite by William Lloyd<wlloyd@slap.net>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
name|int
name|http_port
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|daemonize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|http_sock
decl_stmt|,
name|con_sock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fetch_mode
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|homedir
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|logfile
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|adate
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|hostent
modifier|*
name|hst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|source
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* HTTP basics */
end_comment

begin_decl_stmt
specifier|static
name|char
name|httpd_server_ident
index|[]
init|=
literal|"Server: FreeBSD/PicoBSD simple_httpd 1.1\r"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|http_200
index|[]
init|=
literal|"HTTP/1.0 200 OK\r"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two parts, HTTP Header and then HTML */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|http_404
index|[
literal|2
index|]
init|=
block|{
literal|"HTTP/1.0 404 Not found\r\n"
block|,
literal|"<HTML><HEAD><TITLE>Error</TITLE></HEAD><BODY><H1>Error 404</H1>\ Not found - file doesn't exist or you do not have permission.\n</BODY></HTML>\r\n"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|http_405
index|[
literal|2
index|]
init|=
block|{
literal|"HTTP/1.0 405 Method Not allowed\r\nAllow: GET,HEAD\r\n"
block|,
literal|"<HTML><HEAD><TITLE>Error</TITLE></HEAD><BODY><H1>Error 405</H1>\ This server only supports GET and HEAD requests.\n</BODY></HTML>\r\n"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Only called on initial invocation  */
end_comment

begin_function
name|void
name|init_servconnection
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|server
decl_stmt|;
comment|/* Create a socket */
name|http_sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|http_sock
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|http_port
argument_list|)
expr_stmt|;
name|server
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|http_sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"bind socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"simple_httpd:%d\n"
argument_list|,
name|http_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait here until we see an incoming http request  */
end_comment

begin_function
name|void
name|wait_connection
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|lg
decl_stmt|;
name|lg
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|con_sock
operator|=
name|accept
argument_list|(
name|http_sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|source
argument_list|,
operator|&
name|lg
argument_list|)
expr_stmt|;
if|if
condition|(
name|con_sock
operator|<=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print timestamp for HTTP HEAD and GET  */
end_comment

begin_function
name|void
name|http_date
parameter_list|(
name|void
parameter_list|)
block|{
name|time_t
name|tl
decl_stmt|;
name|char
name|buff
index|[
literal|50
index|]
decl_stmt|;
name|tl
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|buff
argument_list|,
literal|50
argument_list|,
literal|"Date: %a, %d %h %Y %H:%M:%S %Z\r\n"
argument_list|,
name|gmtime
argument_list|(
operator|&
name|tl
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|con_sock
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
comment|//return(buff);
block|}
end_function

begin_comment
comment|/*  * Send data to the open socket  */
end_comment

begin_function
name|void
name|http_output
parameter_list|(
name|char
modifier|*
name|html
parameter_list|)
block|{
name|write
argument_list|(
name|con_sock
argument_list|,
name|html
argument_list|,
name|strlen
argument_list|(
name|html
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|con_sock
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create and write the log information to file  * Log file format is one line per entry  */
end_comment

begin_function
name|void
name|log_line
parameter_list|(
name|char
modifier|*
name|req
parameter_list|)
block|{
name|char
name|log_buff
index|[
literal|256
index|]
decl_stmt|;
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|env_host
index|[
literal|80
index|]
decl_stmt|,
name|env_addr
index|[
literal|80
index|]
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|FILE
modifier|*
name|log
decl_stmt|;
name|strcpy
argument_list|(
name|log_buff
argument_list|,
name|inet_ntoa
argument_list|(
name|source
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|env_addr
argument_list|,
literal|"REMOTE_ADDR=%s"
argument_list|,
name|log_buff
argument_list|)
expr_stmt|;
name|addr
operator|=
name|inet_addr
argument_list|(
name|log_buff
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|msg
argument_list|,
name|adate
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|hst
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
comment|/* If DNS hostname exists */
if|if
condition|(
name|hst
condition|)
block|{
name|strcat
argument_list|(
name|msg
argument_list|,
name|hst
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|env_host
argument_list|,
literal|"REMOTE_HOST=%s"
argument_list|,
name|hst
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|msg
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|log_buff
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
literal|")   "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|daemonize
condition|)
block|{
name|log
operator|=
name|fopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* This is for CGI scripts */
name|putenv
argument_list|(
name|env_addr
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|env_host
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have a connection.  Identify what type of request GET, HEAD, CGI, etc   * and do what needs to be done  */
end_comment

begin_function
name|void
name|http_request
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|lg
decl_stmt|,
name|i
decl_stmt|;
name|int
name|cmd
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|par
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|struct
name|stat
name|file_status
decl_stmt|;
name|char
name|req
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|buff
index|[
literal|8192
index|]
decl_stmt|;
name|lg
operator|=
name|read
argument_list|(
name|con_sock
argument_list|,
name|req
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|strstr
argument_list|(
name|req
argument_list|,
literal|"\n"
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|strstr
argument_list|(
name|req
argument_list|,
literal|"\r"
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|log_line
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|c
operator|=
name|strtok
argument_list|(
name|req
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* Error msg if request is nothing */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|http_output
argument_list|(
name|http_404
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|http_404
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|end_request
goto|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|c
argument_list|,
literal|"GET"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|cmd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|c
argument_list|,
literal|"HEAD"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|cmd
operator|=
literal|2
expr_stmt|;
comment|/* Do error msg for any other type of request */
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
block|{
name|http_output
argument_list|(
name|http_405
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|http_405
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|end_request
goto|;
block|}
name|filename
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|c
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_mode
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|fetch_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|filename
argument_list|)
operator|==
literal|1
condition|)
name|filename
operator|=
literal|"/index.html"
expr_stmt|;
while|while
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|filename
operator|++
expr_stmt|;
comment|/* CGI handling.  Untested */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|filename
argument_list|,
literal|"cgi-bin/"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|par
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|par
operator|=
name|strstr
argument_list|(
name|filename
argument_list|,
literal|"?"
argument_list|)
condition|)
block|{
operator|*
name|par
operator|=
literal|0
expr_stmt|;
name|par
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
name|X_OK
argument_list|)
condition|)
goto|goto
name|conti
goto|;
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|file_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|file_status
operator|.
name|st_uid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|seteuid
argument_list|(
name|file_status
operator|.
name|st_uid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|con_sock
argument_list|)
expr_stmt|;
comment|//printf("HTTP/1.0 200 OK\nContent-type: text/html\n\n\n");
name|printf
argument_list|(
literal|"HTTP/1.0 200 OK\r\n"
argument_list|)
expr_stmt|;
comment|/* Plug in environment variable, others in log_line */
name|putenv
argument_list|(
literal|"SERVER_SOFTWARE=FreeBSD/PicoBSD"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|filename
argument_list|,
name|filename
argument_list|,
name|par
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|wait
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|conti
label|:
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|http_output
argument_list|(
name|http_405
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|http_405
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|end_request
goto|;
block|}
comment|/* End of CGI handling */
comment|/* Reject any request with '..' in it, bad hacker */
name|c
operator|=
name|filename
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|c
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|http_output
argument_list|(
name|http_404
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|http_404
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|end_request
goto|;
block|}
else|else
name|c
operator|++
expr_stmt|;
comment|/* Open filename */
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|http_output
argument_list|(
name|http_404
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|http_404
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|end_request
goto|;
block|}
comment|/* Get file status information */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|file_status
argument_list|)
operator|<
literal|0
condition|)
block|{
name|http_output
argument_list|(
name|http_404
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|http_404
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|end_request
goto|;
block|}
comment|/* Is it a regular file? */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|file_status
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|http_output
argument_list|(
name|http_404
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|http_404
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|end_request
goto|;
block|}
comment|/* Past this point we are serving either a GET or HEAD */
comment|/* Print all the header info */
name|http_output
argument_list|(
name|http_200
argument_list|)
expr_stmt|;
name|http_output
argument_list|(
name|httpd_server_ident
argument_list|)
expr_stmt|;
name|http_date
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Content-length: %lld\r\n"
argument_list|,
name|file_status
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|filename
argument_list|,
literal|".txt"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"Content-type: text/plain\r\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|filename
argument_list|,
literal|".html"
argument_list|)
operator|||
name|strstr
argument_list|(
name|filename
argument_list|,
literal|".htm"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"Content-type: text/html\r\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|filename
argument_list|,
literal|".gif"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"Content-type: image/gif\r\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|filename
argument_list|,
literal|".jpg"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"Content-type: image/jpeg\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Take a guess at content if we don't have something already */
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"Content-type: "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buff
argument_list|,
name|strstr
argument_list|(
name|filename
argument_list|,
literal|"."
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|con_sock
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|buff
argument_list|,
literal|50
argument_list|,
literal|"Last-Modified: %a, %d %h %Y %H:%M:%S %Z\r\n\r\n"
argument_list|,
name|gmtime
argument_list|(
operator|&
name|file_status
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|con_sock
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send data only if GET request */
if|if
condition|(
name|cmd
operator|==
literal|1
condition|)
block|{
while|while
condition|(
name|lg
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
literal|8192
argument_list|)
condition|)
name|write
argument_list|(
name|con_sock
argument_list|,
name|buff
argument_list|,
name|lg
argument_list|)
expr_stmt|;
block|}
name|end_request
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|con_sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Simple httpd server for use in PicoBSD or other embedded application.   * Should satisfy simple httpd needs.  For more demanding situations  * apache is probably a better (but much larger) choice.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|ld
decl_stmt|;
name|int
name|httpd_group
init|=
literal|65534
decl_stmt|;
name|pid_t
name|server_pid
decl_stmt|;
comment|/* Default for html directory */
name|strcpy
argument_list|(
name|homedir
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|geteuid
argument_list|()
condition|)
name|strcpy
argument_list|(
name|homedir
argument_list|,
literal|"/httphome"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|homedir
argument_list|,
literal|"/httphome"
argument_list|)
expr_stmt|;
comment|/* Defaults for log file */
if|if
condition|(
name|geteuid
argument_list|()
condition|)
block|{
name|strcpy
argument_list|(
name|logfile
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|logfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|logfile
argument_list|,
literal|"jhttp.log"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|logfile
argument_list|,
literal|"/var/log/jhttpd.log"
argument_list|)
expr_stmt|;
comment|/* Parse command line arguments */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:f:g:l:p:vDh"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|strcpy
argument_list|(
name|homedir
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|daemonize
operator|=
literal|0
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|fetch_mode
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|httpd_group
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|strcpy
argument_list|(
name|logfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|http_port
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|daemonize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
default|default:
name|printf
argument_list|(
literal|"usage: simple_httpd [[-d directory][-g grpid][-l logfile][-p port][-vD]]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* Not running as root and no port supplied, assume 1080 */
if|if
condition|(
operator|(
name|http_port
operator|==
literal|80
operator|)
operator|&&
name|geteuid
argument_list|()
condition|)
block|{
name|http_port
operator|=
literal|1080
expr_stmt|;
block|}
comment|/* Do we really have rights in the html directory? */
if|if
condition|(
name|fetch_mode
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|homedir
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"chdir"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|homedir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create log file if it doesn't exit */
if|if
condition|(
operator|(
name|access
argument_list|(
name|logfile
argument_list|,
name|W_OK
argument_list|)
operator|)
operator|&&
name|daemonize
condition|)
block|{
name|ld
operator|=
name|open
argument_list|(
name|logfile
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|logfile
argument_list|,
literal|00600
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ld
argument_list|)
expr_stmt|;
block|}
name|init_servconnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"Server started with options \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"port: %d\n"
argument_list|,
name|http_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_mode
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"html home: %s\n"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|daemonize
condition|)
name|printf
argument_list|(
literal|"logfile: %s\n"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
block|}
comment|/* httpd is spawned */
if|if
condition|(
name|daemonize
condition|)
block|{
if|if
condition|(
name|server_pid
operator|=
name|fork
argument_list|()
condition|)
block|{
name|wait3
argument_list|(
literal|0
argument_list|,
name|WNOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"pid: %d\n"
argument_list|,
name|server_pid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|wait3
argument_list|(
literal|0
argument_list|,
name|WNOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fetch_mode
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|httpd_group
argument_list|)
expr_stmt|;
comment|/* How many connections do you want?  	 * Keep this lower than the available number of processes 	 */
if|if
condition|(
name|listen
argument_list|(
name|http_sock
argument_list|,
literal|15
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|label
label|:
name|wait_connection
argument_list|()
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
condition|)
block|{
name|wait3
argument_list|(
literal|0
argument_list|,
name|WNOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|con_sock
argument_list|)
expr_stmt|;
goto|goto
name|label
goto|;
block|}
name|http_request
argument_list|()
expr_stmt|;
name|wait3
argument_list|(
literal|0
argument_list|,
name|WNOHANG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|adate
parameter_list|()
block|{
specifier|static
name|char
name|out
index|[
literal|50
index|]
decl_stmt|;
name|long
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|out
argument_list|,
literal|"%02d:%02d:%02d %02d/%02d/%02d"
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_year
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

end_unit

