begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|Extern
value|extern
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|_NSIG
value|NSIG
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_comment
comment|/* -------- eval.c -------- */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_comment
comment|/* #include "word.h" */
end_comment

begin_comment
comment|/*  * ${}  * `command`  * blank interpretation  * quoting  * glob  */
end_comment

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int expand
argument_list|,
argument|(char *cp, struct wdblock **wbp, int f )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
name|char
operator|*
name|blank
argument_list|,
operator|(
name|int
name|f
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int dollar
argument_list|,
argument|(int quoted )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int grave
argument_list|,
argument|(int quoted )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void globname
argument_list|,
argument|(char *we, char *pp )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
name|char
operator|*
name|generate
argument_list|,
operator|(
name|char
operator|*
name|start1
operator|,
name|char
operator|*
name|end1
operator|,
name|char
operator|*
name|middle
operator|,
name|char
operator|*
name|end
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int anyspcl
argument_list|,
argument|(struct wdblock *wb )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int xstrcmp
argument_list|,
argument|(char *p1, char *p2 )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void glob0
argument_list|,
argument|(char *a0, unsigned int a1, int a2, int (*a3)(char *, char *))
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void glob1
argument_list|,
argument|(char *base, char *lim )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void glob2
argument_list|,
argument|(char *i, char *j )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void glob3
argument_list|,
argument|(char *i, char *j, char *k )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
name|char
operator|*
name|memcopy
argument_list|,
operator|(
name|char
operator|*
name|ato
operator|,
name|char
operator|*
name|from
operator|,
name|int
name|nb
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|char
modifier|*
modifier|*
name|eval
parameter_list|(
name|ap
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|f
decl_stmt|;
block|{
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
name|char
modifier|*
modifier|*
name|wp
decl_stmt|;
name|char
modifier|*
modifier|*
name|wf
decl_stmt|;
name|jmp_buf
name|ev
decl_stmt|;
name|wp
operator|=
name|NULL
expr_stmt|;
name|wb
operator|=
name|NULL
expr_stmt|;
name|wf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newenv
argument_list|(
name|setjmp
argument_list|(
name|errpt
operator|=
name|ev
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|ap
operator|&&
name|isassign
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
name|expand
argument_list|(
operator|*
name|ap
operator|++
argument_list|,
operator|&
name|wb
argument_list|,
name|f
operator|&
operator|~
name|DOGLOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
index|[
literal|'k'
index|]
condition|)
block|{
for|for
control|(
name|wf
operator|=
name|ap
init|;
operator|*
name|wf
condition|;
name|wf
operator|++
control|)
block|{
if|if
condition|(
name|isassign
argument_list|(
operator|*
name|wf
argument_list|)
condition|)
name|expand
argument_list|(
operator|*
name|wf
argument_list|,
operator|&
name|wb
argument_list|,
name|f
operator|&
operator|~
name|DOGLOB
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|wb
operator|=
name|addword
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|wb
argument_list|)
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|flag
index|[
literal|'k'
index|]
operator|||
operator|!
name|isassign
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
name|expand
argument_list|(
operator|*
name|ap
argument_list|,
operator|&
name|wb
argument_list|,
name|f
operator|&
operator|~
name|DOKEY
argument_list|)
expr_stmt|;
block|}
name|wb
operator|=
name|addword
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|wb
argument_list|)
expr_stmt|;
name|wp
operator|=
name|getwords
argument_list|(
name|wb
argument_list|)
expr_stmt|;
name|quitenv
argument_list|()
expr_stmt|;
block|}
else|else
name|gflg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|gflg
condition|?
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
else|:
name|wp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make the exported environment from the exported  * names in the dictionary. Keyword assignments  * will already have been done.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|makenv
parameter_list|()
block|{
specifier|register
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
specifier|register
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|wb
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|vlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
if|if
condition|(
name|vp
operator|->
name|status
operator|&
name|EXPORT
condition|)
name|wb
operator|=
name|addword
argument_list|(
name|vp
operator|->
name|name
argument_list|,
name|wb
argument_list|)
expr_stmt|;
name|wb
operator|=
name|addword
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|wb
argument_list|)
expr_stmt|;
return|return
operator|(
name|getwords
argument_list|(
name|wb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|evalstr
parameter_list|(
name|cp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|f
decl_stmt|;
block|{
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
name|wb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|expand
argument_list|(
name|cp
argument_list|,
operator|&
name|wb
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|wb
operator|==
name|NULL
operator|||
name|wb
operator|->
name|w_nword
operator|==
literal|0
operator|||
operator|(
name|cp
operator|=
name|wb
operator|->
name|w_words
index|[
literal|0
index|]
operator|)
operator|==
name|NULL
condition|)
name|cp
operator|=
literal|""
expr_stmt|;
name|DELETE
argument_list|(
name|wb
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|expand
parameter_list|(
name|cp
parameter_list|,
name|wbp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|wdblock
modifier|*
modifier|*
name|wbp
decl_stmt|;
name|int
name|f
decl_stmt|;
block|{
name|jmp_buf
name|ev
decl_stmt|;
name|gflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|anys
argument_list|(
literal|"$`'\""
argument_list|,
name|cp
argument_list|)
operator|&&
operator|!
name|anys
argument_list|(
name|ifs
operator|->
name|value
argument_list|,
name|cp
argument_list|)
operator|&&
operator|(
operator|(
name|f
operator|&
name|DOGLOB
operator|)
operator|==
literal|0
operator|||
operator|!
name|anys
argument_list|(
literal|"[*?"
argument_list|,
name|cp
argument_list|)
operator|)
condition|)
block|{
name|cp
operator|=
name|strsave
argument_list|(
name|cp
argument_list|,
name|areanum
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|DOTRIM
condition|)
name|unquote
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|*
name|wbp
operator|=
name|addword
argument_list|(
name|cp
argument_list|,
operator|*
name|wbp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|newenv
argument_list|(
name|setjmp
argument_list|(
name|errpt
operator|=
name|ev
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PUSHIO
argument_list|(
name|aword
argument_list|,
name|cp
argument_list|,
name|strchar
argument_list|)
expr_stmt|;
name|e
operator|.
name|iobase
operator|=
name|e
operator|.
name|iop
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|blank
argument_list|(
name|f
argument_list|)
operator|)
operator|&&
name|gflg
operator|==
literal|0
condition|)
block|{
name|e
operator|.
name|linep
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strsave
argument_list|(
name|cp
argument_list|,
name|areanum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|DOGLOB
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|&
name|DOTRIM
condition|)
name|unquote
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|*
name|wbp
operator|=
name|addword
argument_list|(
name|cp
argument_list|,
operator|*
name|wbp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|wbp
operator|=
name|glob
argument_list|(
name|cp
argument_list|,
operator|*
name|wbp
argument_list|)
expr_stmt|;
block|}
name|quitenv
argument_list|()
expr_stmt|;
block|}
else|else
name|gflg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|gflg
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Blank interpretation and quoting  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|blank
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|c
operator|,
name|c1
expr_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|scanequals
decl_stmt|,
name|foundequals
decl_stmt|;
name|sp
operator|=
name|e
operator|.
name|linep
expr_stmt|;
name|scanequals
operator|=
name|f
operator|&
name|DOKEY
expr_stmt|;
name|foundequals
operator|=
literal|0
expr_stmt|;
name|loop
label|:
switch|switch
condition|(
name|c
operator|=
name|subgetc
argument_list|(
literal|'"'
argument_list|,
name|foundequals
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|sp
operator|==
name|e
operator|.
name|linep
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
default|default:
if|if
condition|(
name|f
operator|&
name|DOBLANK
operator|&&
name|any
argument_list|(
name|c
argument_list|,
name|ifs
operator|->
name|value
argument_list|)
condition|)
goto|goto
name|loop
goto|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|scanequals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|INSUB
argument_list|()
condition|)
break|break;
for|for
control|(
name|c1
operator|=
name|c
init|;
operator|(
name|c
operator|=
name|subgetc
argument_list|(
name|c1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|c1
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
operator|!
name|any
argument_list|(
name|c
argument_list|,
literal|"$`\""
argument_list|)
condition|)
name|c
operator||=
name|QUOTE
expr_stmt|;
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
block|}
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|letter
argument_list|(
name|c
argument_list|)
condition|)
name|scanequals
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|subgetc
argument_list|(
literal|'"'
argument_list|,
name|foundequals
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|f
operator|&
operator|(
name|DOBLANK
operator|&&
name|any
argument_list|(
name|c
argument_list|,
name|ifs
operator|->
name|value
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|INSUB
argument_list|()
operator|&&
name|any
argument_list|(
name|c
argument_list|,
literal|"\"'"
argument_list|)
operator|)
condition|)
block|{
name|scanequals
operator|=
literal|0
expr_stmt|;
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
name|c
argument_list|,
literal|"\"'"
argument_list|)
condition|)
goto|goto
name|loop
goto|;
break|break;
block|}
if|if
condition|(
name|scanequals
condition|)
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
name|foundequals
operator|=
literal|1
expr_stmt|;
name|scanequals
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|letnum
argument_list|(
name|c
argument_list|)
condition|)
name|scanequals
operator|=
literal|0
expr_stmt|;
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get characters, substituting for ` and $  */
end_comment

begin_function
name|int
name|subgetc
parameter_list|(
name|ec
parameter_list|,
name|quoted
parameter_list|)
specifier|register
name|char
name|ec
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|again
label|:
name|c
operator|=
name|getc
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSUB
argument_list|()
operator|&&
name|ec
operator|!=
literal|'\''
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'`'
condition|)
block|{
if|if
condition|(
name|grave
argument_list|(
name|quoted
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|e
operator|.
name|iop
operator|->
name|task
operator|=
name|XGRAVE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
operator|(
name|c
operator|=
name|dollar
argument_list|(
name|quoted
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|e
operator|.
name|iop
operator|->
name|task
operator|=
name|XDOLL
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare to generate the string returned by ${} substitution.  */
end_comment

begin_function
specifier|static
name|int
name|dollar
parameter_list|(
name|quoted
parameter_list|)
name|int
name|quoted
decl_stmt|;
block|{
name|int
name|otask
decl_stmt|;
name|struct
name|io
modifier|*
name|oiop
decl_stmt|;
name|char
modifier|*
name|dolp
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
name|s
operator|=
name|e
operator|.
name|linep
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'{'
condition|)
block|{
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|letter
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|readc
argument_list|()
operator|)
operator|!=
literal|0
operator|&&
name|letnum
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
name|e
operator|.
name|linep
operator|<
name|elinep
condition|)
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|oiop
operator|=
name|e
operator|.
name|iop
expr_stmt|;
name|otask
operator|=
name|e
operator|.
name|iop
operator|->
name|task
expr_stmt|;
name|e
operator|.
name|iop
operator|->
name|task
operator|=
name|XOTHER
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|subgetc
argument_list|(
literal|'"'
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|e
operator|.
name|linep
operator|<
name|elinep
condition|)
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|oiop
operator|==
name|e
operator|.
name|iop
condition|)
name|e
operator|.
name|iop
operator|->
name|task
operator|=
name|otask
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'}'
condition|)
block|{
name|err
argument_list|(
literal|"unclosed ${"
argument_list|)
expr_stmt|;
name|gflg
operator|++
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
if|if
condition|(
name|e
operator|.
name|linep
operator|>=
name|elinep
condition|)
block|{
name|err
argument_list|(
literal|"string in ${} too long"
argument_list|)
expr_stmt|;
name|gflg
operator|++
expr_stmt|;
name|e
operator|.
name|linep
operator|-=
literal|10
expr_stmt|;
block|}
operator|*
name|e
operator|.
name|linep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
for|for
control|(
name|cp
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|"=-+?"
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'*'
operator|||
operator|*
name|s
operator|==
literal|'@'
operator|)
condition|)
block|{
if|if
condition|(
name|dolc
operator|>
literal|1
condition|)
block|{
comment|/* currently this does not distinguish $* and $@ */
comment|/* should check dollar */
name|e
operator|.
name|linep
operator|=
name|s
expr_stmt|;
name|PUSHIO
argument_list|(
name|awordlist
argument_list|,
name|dolv
operator|+
literal|1
argument_list|,
name|dolchar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* trap the nasty ${=} */
name|s
index|[
literal|0
index|]
operator|=
literal|'1'
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|vp
operator|=
name|lookup
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dolp
operator|=
name|vp
operator|->
name|value
operator|)
operator|==
name|null
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
if|if
condition|(
name|digit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"cannot use ${...=...} with $n"
argument_list|)
expr_stmt|;
name|gflg
operator|++
expr_stmt|;
break|break;
block|}
name|setval
argument_list|(
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dolp
operator|=
name|vp
operator|->
name|value
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|dolp
operator|=
name|strsave
argument_list|(
name|cp
argument_list|,
name|areanum
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"missing value for "
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|gflg
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|dolp
operator|=
name|strsave
argument_list|(
name|cp
argument_list|,
name|areanum
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
index|[
literal|'u'
index|]
operator|&&
name|dolp
operator|==
name|null
condition|)
block|{
name|prs
argument_list|(
literal|"unset variable: "
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|gflg
operator|++
expr_stmt|;
block|}
name|e
operator|.
name|linep
operator|=
name|s
expr_stmt|;
name|PUSHIO
argument_list|(
name|aword
argument_list|,
name|dolp
argument_list|,
name|quoted
condition|?
name|qstrchar
else|:
name|strchar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the command in `...` and read its output.  */
end_comment

begin_function
specifier|static
name|int
name|grave
parameter_list|(
name|quoted
parameter_list|)
name|int
name|quoted
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pf
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|e
operator|.
name|iop
operator|->
name|argp
operator|->
name|aword
init|;
operator|*
name|cp
operator|!=
literal|'`'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"no closing `"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|openpipe
argument_list|(
name|pf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|closepipe
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"try again"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|e
operator|.
name|iop
operator|->
name|argp
operator|->
name|aword
operator|=
operator|++
name|cp
expr_stmt|;
name|close
argument_list|(
name|pf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|PUSHIO
argument_list|(
name|afile
argument_list|,
name|remap
argument_list|(
name|pf
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|quoted
condition|?
name|qgravechar
else|:
name|gravechar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* allow trapped signals */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|_NSIG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ourtrap
index|[
name|i
index|]
operator|&&
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pf
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|closepipe
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|flag
index|[
literal|'e'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'v'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'n'
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|strsave
argument_list|(
name|e
operator|.
name|iop
operator|->
name|argp
operator|->
name|aword
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|areanum
operator|=
literal|1
expr_stmt|;
name|freehere
argument_list|(
name|areanum
argument_list|)
expr_stmt|;
name|freearea
argument_list|(
name|areanum
argument_list|)
expr_stmt|;
comment|/* free old space */
name|e
operator|.
name|oenv
operator|=
name|NULL
expr_stmt|;
name|e
operator|.
name|iop
operator|=
operator|(
name|e
operator|.
name|iobase
operator|=
name|iostack
operator|)
operator|-
literal|1
expr_stmt|;
name|unquote
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|talking
operator|=
literal|0
expr_stmt|;
name|PUSHIO
argument_list|(
name|aword
argument_list|,
name|cp
argument_list|,
name|nlchar
argument_list|)
expr_stmt|;
name|onecommand
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|unquote
parameter_list|(
name|as
parameter_list|)
specifier|register
name|char
modifier|*
name|as
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|as
operator|)
operator|!=
name|NULL
condition|)
while|while
condition|(
operator|*
name|s
condition|)
operator|*
name|s
operator|++
operator|&=
operator|~
name|QUOTE
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------- glob.c -------- */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_comment
comment|/*  * glob  */
end_comment

begin_define
define|#
directive|define
name|scopy
parameter_list|(
name|x
parameter_list|)
value|strsave((x), areanum)
end_define

begin_define
define|#
directive|define
name|BLKSIZ
value|512
end_define

begin_define
define|#
directive|define
name|NDENT
value|((BLKSIZ+sizeof(struct dirent)-1)/sizeof(struct dirent))
end_define

begin_decl_stmt
specifier|static
name|struct
name|wdblock
modifier|*
name|cl
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|spcl
index|[]
init|=
literal|"[?*"
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|wdblock
modifier|*
name|glob
parameter_list|(
name|cp
parameter_list|,
name|wb
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
name|wb
operator|)
return|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|cp
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|any
argument_list|(
operator|*
name|pp
argument_list|,
name|spcl
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|any
argument_list|(
operator|*
name|pp
operator|&
operator|~
name|QUOTE
argument_list|,
name|spcl
argument_list|)
condition|)
operator|*
name|pp
operator|&=
operator|~
name|QUOTE
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cl
operator|=
name|addword
argument_list|(
name|scopy
argument_list|(
name|cp
argument_list|)
argument_list|,
operator|(
expr|struct
name|wdblock
operator|*
operator|)
literal|0
argument_list|)
init|;
name|anyspcl
argument_list|(
name|cl
argument_list|)
condition|;
name|cl
operator|=
name|nl
control|)
block|{
name|nl
operator|=
name|newword
argument_list|(
name|cl
operator|->
name|w_nword
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl
operator|->
name|w_nword
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each argument */
for|for
control|(
name|pp
operator|=
name|cl
operator|->
name|w_words
index|[
name|i
index|]
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|any
argument_list|(
operator|*
name|pp
argument_list|,
name|spcl
argument_list|)
condition|)
block|{
name|globname
argument_list|(
name|cl
operator|->
name|w_words
index|[
name|i
index|]
argument_list|,
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|pp
operator|==
literal|'\0'
condition|)
name|nl
operator|=
name|addword
argument_list|(
name|scopy
argument_list|(
name|cl
operator|->
name|w_words
index|[
name|i
index|]
argument_list|)
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl
operator|->
name|w_nword
condition|;
name|i
operator|++
control|)
name|DELETE
argument_list|(
name|cl
operator|->
name|w_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DELETE
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl
operator|->
name|w_nword
condition|;
name|i
operator|++
control|)
name|unquote
argument_list|(
name|cl
operator|->
name|w_words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|glob0
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cl
operator|->
name|w_words
argument_list|,
name|cl
operator|->
name|w_nword
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|xstrcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|w_nword
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl
operator|->
name|w_nword
condition|;
name|i
operator|++
control|)
name|wb
operator|=
name|addword
argument_list|(
name|cl
operator|->
name|w_words
index|[
name|i
index|]
argument_list|,
name|wb
argument_list|)
expr_stmt|;
name|DELETE
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb
operator|)
return|;
block|}
block|}
name|wb
operator|=
name|addword
argument_list|(
name|unquote
argument_list|(
name|cp
argument_list|)
argument_list|,
name|wb
argument_list|)
expr_stmt|;
return|return
operator|(
name|wb
operator|)
return|;
block|}
end_function

begin_function
name|void
name|globname
parameter_list|(
name|we
parameter_list|,
name|pp
parameter_list|)
name|char
modifier|*
name|we
decl_stmt|;
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|gp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|dn
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|k
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
name|char
name|dname
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|dbuf
decl_stmt|;
for|for
control|(
name|np
operator|=
name|we
init|;
name|np
operator|!=
name|pp
condition|;
name|pp
operator|--
control|)
if|if
condition|(
name|pp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
for|for
control|(
name|dp
operator|=
name|cp
operator|=
name|space
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pp
operator|-
name|np
argument_list|)
operator|+
literal|3
argument_list|)
init|;
name|np
operator|<
name|pp
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|np
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|cp
operator|=
name|space
argument_list|(
name|strlen
argument_list|(
name|pp
argument_list|)
operator|+
literal|1
argument_list|)
init|;
operator|*
name|np
operator|&&
operator|*
name|np
operator|!=
literal|'/'
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|np
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
literal|0
condition|)
block|{
name|DELETE
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DELETE
argument_list|(
name|gp
argument_list|)
expr_stmt|;
return|return;
block|}
name|dname
index|[
name|NAME_MAX
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX Hmmm... What this could be? (abial) */
comment|/* 		if (ent[j].d_ino == 0) 			continue; 		*/
name|strncpy
argument_list|(
name|dname
argument_list|,
name|de
operator|->
name|d_name
argument_list|,
name|NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
if|if
condition|(
operator|*
name|gp
operator|!=
literal|'.'
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NAME_MAX
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|any
argument_list|(
name|dname
index|[
name|k
index|]
argument_list|,
name|spcl
argument_list|)
condition|)
name|dname
index|[
name|k
index|]
operator||=
name|QUOTE
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|dname
argument_list|,
name|gp
argument_list|)
condition|)
block|{
name|name
operator|=
name|generate
argument_list|(
name|we
argument_list|,
name|pp
argument_list|,
name|dname
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|&&
operator|!
name|anys
argument_list|(
name|np
argument_list|,
name|spcl
argument_list|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|dbuf
argument_list|)
condition|)
block|{
name|DELETE
argument_list|(
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|nl
operator|=
name|addword
argument_list|(
name|name
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|DELETE
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|DELETE
argument_list|(
name|gp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generate a pathname as below.  * start..end1 / middle end  * the slashes come for free  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|generate
parameter_list|(
name|start1
parameter_list|,
name|end1
parameter_list|,
name|middle
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|start1
decl_stmt|;
specifier|register
name|char
modifier|*
name|end1
decl_stmt|;
name|char
modifier|*
name|middle
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|op
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|p
operator|=
name|op
operator|=
name|space
argument_list|(
call|(
name|int
call|)
argument_list|(
name|end1
operator|-
name|start1
argument_list|)
operator|+
name|strlen
argument_list|(
name|middle
argument_list|)
operator|+
name|strlen
argument_list|(
name|end
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|start1
init|;
name|xp
operator|!=
name|end1
condition|;
control|)
operator|*
name|op
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|middle
init|;
operator|(
operator|*
name|op
operator|++
operator|=
operator|*
name|xp
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
control|)
empty_stmt|;
name|op
operator|--
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|end
init|;
operator|(
operator|*
name|op
operator|++
operator|=
operator|*
name|xp
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
control|)
empty_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|anyspcl
parameter_list|(
name|wb
parameter_list|)
specifier|register
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|wd
decl_stmt|;
name|wd
operator|=
name|wb
operator|->
name|w_words
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wb
operator|->
name|w_nword
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|anys
argument_list|(
name|spcl
argument_list|,
operator|*
name|wd
operator|++
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xstrcmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|char
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|p1
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|p2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* -------- word.c -------- */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_comment
comment|/* #include "word.h" */
end_comment

begin_define
define|#
directive|define
name|NSTART
value|16
end_define

begin_comment
comment|/* default number of words to allow for initially */
end_comment

begin_function
name|struct
name|wdblock
modifier|*
name|newword
parameter_list|(
name|nw
parameter_list|)
specifier|register
name|int
name|nw
decl_stmt|;
block|{
specifier|register
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
name|wb
operator|=
operator|(
expr|struct
name|wdblock
operator|*
operator|)
name|space
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wb
argument_list|)
operator|+
name|nw
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|wb
operator|->
name|w_bsize
operator|=
name|nw
expr_stmt|;
name|wb
operator|->
name|w_nword
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|wb
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|wdblock
modifier|*
name|addword
parameter_list|(
name|wd
parameter_list|,
name|wb
parameter_list|)
name|char
modifier|*
name|wd
decl_stmt|;
specifier|register
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
block|{
specifier|register
name|struct
name|wdblock
modifier|*
name|wb2
decl_stmt|;
specifier|register
name|nw
expr_stmt|;
if|if
condition|(
name|wb
operator|==
name|NULL
condition|)
name|wb
operator|=
name|newword
argument_list|(
name|NSTART
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nw
operator|=
name|wb
operator|->
name|w_nword
operator|)
operator|>=
name|wb
operator|->
name|w_bsize
condition|)
block|{
name|wb2
operator|=
name|newword
argument_list|(
name|nw
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wb2
operator|->
name|w_words
argument_list|,
operator|(
name|char
operator|*
operator|)
name|wb
operator|->
name|w_words
argument_list|,
name|nw
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|wb2
operator|->
name|w_nword
operator|=
name|nw
expr_stmt|;
name|DELETE
argument_list|(
name|wb
argument_list|)
expr_stmt|;
name|wb
operator|=
name|wb2
expr_stmt|;
block|}
name|wb
operator|->
name|w_words
index|[
name|wb
operator|->
name|w_nword
operator|++
index|]
operator|=
name|wd
expr_stmt|;
return|return
operator|(
name|wb
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|getwords
parameter_list|(
name|wb
parameter_list|)
specifier|register
name|struct
name|wdblock
modifier|*
name|wb
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|wd
decl_stmt|;
specifier|register
name|nb
expr_stmt|;
if|if
condition|(
name|wb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|wb
operator|->
name|w_nword
operator|==
literal|0
condition|)
block|{
name|DELETE
argument_list|(
name|wb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|wd
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|space
argument_list|(
name|nb
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wd
argument_list|)
operator|*
name|wb
operator|->
name|w_nword
argument_list|)
expr_stmt|;
name|memcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|wb
operator|->
name|w_words
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|DELETE
argument_list|(
name|wb
argument_list|)
expr_stmt|;
comment|/* perhaps should done by caller */
return|return
operator|(
name|wd
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|globv
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|glob0
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
name|char
modifier|*
name|a0
decl_stmt|;
name|unsigned
name|a1
decl_stmt|;
name|int
name|a2
decl_stmt|;
function_decl|_PROTOTYPE
parameter_list|(
function_decl|int
parameter_list|(
function_decl|*a3
end_function_decl

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_block
block|{
name|func
operator|=
name|a3
expr_stmt|;
name|globv
operator|=
name|a2
expr_stmt|;
name|glob1
argument_list|(
name|a0
argument_list|,
name|a0
operator|+
name|a1
operator|*
name|a2
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|glob1
parameter_list|(
name|base
parameter_list|,
name|lim
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|,
decl|*
name|lim
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
name|int
name|v2
decl_stmt|;
name|char
modifier|*
name|lptr
decl_stmt|,
modifier|*
name|hptr
decl_stmt|;
name|int
name|c
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|v2
operator|=
name|globv
expr_stmt|;
name|top
label|:
if|if
condition|(
operator|(
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|lim
operator|-
name|base
argument_list|)
operator|)
operator|<=
name|v2
condition|)
return|return;
name|n
operator|=
name|v2
operator|*
operator|(
name|n
operator|/
operator|(
literal|2
operator|*
name|v2
operator|)
operator|)
expr_stmt|;
name|hptr
operator|=
name|lptr
operator|=
name|base
operator|+
name|n
expr_stmt|;
name|i
operator|=
name|base
expr_stmt|;
name|j
operator|=
name|lim
operator|-
name|v2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|<
name|lptr
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|i
argument_list|,
name|lptr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|glob2
argument_list|(
name|i
argument_list|,
name|lptr
operator|-=
name|v2
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|i
operator|+=
name|v2
expr_stmt|;
continue|continue;
block|}
block|}
name|begin
label|:
if|if
condition|(
name|j
operator|>
name|hptr
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|hptr
argument_list|,
name|j
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|glob2
argument_list|(
name|hptr
operator|+=
name|v2
argument_list|,
name|j
argument_list|)
expr_stmt|;
goto|goto
name|begin
goto|;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|lptr
condition|)
block|{
name|glob3
argument_list|(
name|i
argument_list|,
name|hptr
operator|+=
name|v2
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|i
operator|=
name|lptr
operator|+=
name|v2
expr_stmt|;
goto|goto
name|begin
goto|;
block|}
name|glob2
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|j
operator|-=
name|v2
expr_stmt|;
name|i
operator|+=
name|v2
expr_stmt|;
continue|continue;
block|}
name|j
operator|-=
name|v2
expr_stmt|;
goto|goto
name|begin
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|lptr
condition|)
block|{
if|if
condition|(
name|lptr
operator|-
name|base
operator|>=
name|lim
operator|-
name|hptr
condition|)
block|{
name|glob1
argument_list|(
name|hptr
operator|+
name|v2
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|lim
operator|=
name|lptr
expr_stmt|;
block|}
else|else
block|{
name|glob1
argument_list|(
name|base
argument_list|,
name|lptr
argument_list|)
expr_stmt|;
name|base
operator|=
name|hptr
operator|+
name|v2
expr_stmt|;
block|}
goto|goto
name|top
goto|;
block|}
name|glob3
argument_list|(
name|j
argument_list|,
name|lptr
operator|-=
name|v2
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|hptr
operator|-=
name|v2
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|glob2
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|char
modifier|*
name|i
decl_stmt|,
decl|*
name|j
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|index1
decl_stmt|,
modifier|*
name|index2
decl_stmt|,
name|c
decl_stmt|;
name|int
name|m
decl_stmt|;
name|m
operator|=
name|globv
expr_stmt|;
name|index1
operator|=
name|i
expr_stmt|;
name|index2
operator|=
name|j
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|index1
expr_stmt|;
operator|*
name|index1
operator|++
operator|=
operator|*
name|index2
expr_stmt|;
operator|*
name|index2
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|m
condition|)
do|;
block|}
end_block

begin_function
name|void
name|glob3
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|,
name|k
parameter_list|)
name|char
modifier|*
name|i
decl_stmt|,
decl|*
name|j
decl_stmt|,
modifier|*
name|k
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|index1
decl_stmt|,
modifier|*
name|index2
decl_stmt|,
modifier|*
name|index3
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|m
decl_stmt|;
name|m
operator|=
name|globv
expr_stmt|;
name|index1
operator|=
name|i
expr_stmt|;
name|index2
operator|=
name|j
expr_stmt|;
name|index3
operator|=
name|k
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|index1
expr_stmt|;
operator|*
name|index1
operator|++
operator|=
operator|*
name|index3
expr_stmt|;
operator|*
name|index3
operator|++
operator|=
operator|*
name|index2
expr_stmt|;
operator|*
name|index2
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|m
condition|)
do|;
block|}
end_block

begin_function
name|char
modifier|*
name|memcopy
parameter_list|(
name|ato
parameter_list|,
name|from
parameter_list|,
name|nb
parameter_list|)
specifier|register
name|char
modifier|*
name|ato
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|nb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
name|to
operator|=
name|ato
expr_stmt|;
while|while
condition|(
operator|--
name|nb
operator|>=
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
return|return
operator|(
name|ato
operator|)
return|;
block|}
end_block

end_unit

