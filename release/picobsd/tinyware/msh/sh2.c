begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|Extern
value|extern
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|_NSIG
value|NSIG
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_comment
comment|/* -------- csyn.c -------- */
end_comment

begin_comment
comment|/*  * shell: syntax (C version)  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
modifier|*
name|wp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|op
modifier|*
name|o
decl_stmt|;
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_define
define|#
directive|define
name|WORD
value|256
end_define

begin_define
define|#
directive|define
name|LOGAND
value|257
end_define

begin_define
define|#
directive|define
name|LOGOR
value|258
end_define

begin_define
define|#
directive|define
name|BREAK
value|259
end_define

begin_define
define|#
directive|define
name|IF
value|260
end_define

begin_define
define|#
directive|define
name|THEN
value|261
end_define

begin_define
define|#
directive|define
name|ELSE
value|262
end_define

begin_define
define|#
directive|define
name|ELIF
value|263
end_define

begin_define
define|#
directive|define
name|FI
value|264
end_define

begin_define
define|#
directive|define
name|CASE
value|265
end_define

begin_define
define|#
directive|define
name|ESAC
value|266
end_define

begin_define
define|#
directive|define
name|FOR
value|267
end_define

begin_define
define|#
directive|define
name|WHILE
value|268
end_define

begin_define
define|#
directive|define
name|UNTIL
value|269
end_define

begin_define
define|#
directive|define
name|DO
value|270
end_define

begin_define
define|#
directive|define
name|DONE
value|271
end_define

begin_define
define|#
directive|define
name|IN
value|272
end_define

begin_define
define|#
directive|define
name|YYERRCODE
value|300
end_define

begin_comment
comment|/* flags to yylex */
end_comment

begin_define
define|#
directive|define
name|CONTIN
value|01
end_define

begin_comment
comment|/* skip new lines to complete command */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_define
define|#
directive|define
name|SYNTAXERR
value|zzerr()
end_define

begin_decl_stmt
specifier|static
name|int
name|startl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|peeksym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iounit
init|=
name|IODEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|pipeline
argument_list|,
operator|(
name|int
name|cf
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|andor
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|c_list
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int synio
argument_list|,
argument|(int cf )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void musthave
argument_list|,
argument|(int c, int cf )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|simple
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|nested
argument_list|,
operator|(
name|int
name|type
operator|,
name|int
name|mark
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|command
argument_list|,
operator|(
name|int
name|cf
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|dogroup
argument_list|,
operator|(
name|int
name|onlydone
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|thenpart
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|elsepart
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|caselist
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|casepart
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
name|char
operator|*
operator|*
name|pattern
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
name|char
operator|*
operator|*
name|wordlist
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|list
argument_list|,
operator|(
expr|struct
name|op
operator|*
name|t1
operator|,
expr|struct
name|op
operator|*
name|t2
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|block
argument_list|,
operator|(
name|int
name|type
operator|,
expr|struct
name|op
operator|*
name|t1
operator|,
expr|struct
name|op
operator|*
name|t2
operator|,
name|char
operator|*
operator|*
name|wp
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|newtp
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|namelist
argument_list|,
operator|(
expr|struct
name|op
operator|*
name|t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
name|char
operator|*
operator|*
name|copyw
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void word
argument_list|,
argument|(char *cp )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|ioword
operator|*
operator|*
name|copyio
argument_list|,
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|ioword
operator|*
name|io
argument_list|,
operator|(
name|int
name|u
operator|,
name|int
name|f
operator|,
name|char
operator|*
name|cp
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void zzerr
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void yyerror
argument_list|,
argument|(char *s )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int yylex
argument_list|,
argument|(int cf )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int collect
argument_list|,
argument|(int c, int c1 )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dual
argument_list|,
argument|(int c )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void diag
argument_list|,
argument|(int ec )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
name|char
operator|*
name|tree
argument_list|,
operator|(
name|unsigned
name|size
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void printf
argument_list|,
argument|(char *s )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|int
name|yyparse
parameter_list|()
block|{
name|startl
operator|=
literal|1
expr_stmt|;
name|peeksym
operator|=
literal|0
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|outtree
operator|=
name|c_list
argument_list|()
expr_stmt|;
name|musthave
argument_list|(
literal|'\n'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|yynerrs
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|pipeline
parameter_list|(
name|cf
parameter_list|)
name|int
name|cf
decl_stmt|;
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|t
operator|=
name|command
argument_list|(
name|cf
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|command
argument_list|(
name|CONTIN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|SYNTAXERR
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|!=
name|TPAREN
operator|&&
name|t
operator|->
name|type
operator|!=
name|TCOM
condition|)
block|{
comment|/* shell statement */
name|t
operator|=
name|block
argument_list|(
name|TPAREN
argument_list|,
name|t
argument_list|,
name|NOBLOCK
argument_list|,
name|NOWORDS
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|block
argument_list|(
name|TPIPE
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|NOWORDS
argument_list|)
expr_stmt|;
block|}
name|peeksym
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|andor
parameter_list|()
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|t
operator|=
name|pipeline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|LOGAND
operator|||
name|c
operator|==
name|LOGOR
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|pipeline
argument_list|(
name|CONTIN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|SYNTAXERR
expr_stmt|;
name|t
operator|=
name|block
argument_list|(
name|c
operator|==
name|LOGAND
condition|?
name|TAND
else|:
name|TOR
argument_list|,
name|t
argument_list|,
name|p
argument_list|,
name|NOWORDS
argument_list|)
expr_stmt|;
block|}
name|peeksym
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|c_list
parameter_list|()
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|t
operator|=
name|andor
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|peeksym
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|'&'
condition|)
name|t
operator|=
name|block
argument_list|(
name|TASYNC
argument_list|,
name|t
argument_list|,
name|NOBLOCK
argument_list|,
name|NOWORDS
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'&'
operator|||
operator|(
name|multiline
operator|&&
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|andor
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|t
operator|)
return|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|'&'
condition|)
name|p
operator|=
name|block
argument_list|(
name|TASYNC
argument_list|,
name|p
argument_list|,
name|NOBLOCK
argument_list|,
name|NOWORDS
argument_list|)
expr_stmt|;
name|t
operator|=
name|list
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|peeksym
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|synio
parameter_list|(
name|cf
parameter_list|)
name|int
name|cf
decl_stmt|;
block|{
specifier|register
name|struct
name|ioword
modifier|*
name|iop
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
name|cf
argument_list|)
operator|)
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'>'
condition|)
block|{
name|peeksym
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|=
name|yylval
operator|.
name|i
expr_stmt|;
name|musthave
argument_list|(
name|WORD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iop
operator|=
name|io
argument_list|(
name|iounit
argument_list|,
name|i
argument_list|,
name|yylval
operator|.
name|cp
argument_list|)
expr_stmt|;
name|iounit
operator|=
name|IODEFAULT
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|IOHERE
condition|)
name|markhere
argument_list|(
name|yylval
operator|.
name|cp
argument_list|,
name|iop
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|musthave
parameter_list|(
name|c
parameter_list|,
name|cf
parameter_list|)
name|int
name|c
decl_stmt|,
name|cf
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|peeksym
operator|=
name|yylex
argument_list|(
name|cf
argument_list|)
operator|)
operator|!=
name|c
condition|)
name|SYNTAXERR
expr_stmt|;
name|peeksym
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|simple
parameter_list|()
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|peeksym
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
operator|(
name|void
operator|)
name|synio
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|WORD
case|:
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|TCOM
expr_stmt|;
block|}
name|peeksym
operator|=
literal|0
expr_stmt|;
name|word
argument_list|(
name|yylval
operator|.
name|cp
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|t
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|nested
parameter_list|(
name|type
parameter_list|,
name|mark
parameter_list|)
name|int
name|type
decl_stmt|,
name|mark
decl_stmt|;
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|multiline
operator|++
expr_stmt|;
name|t
operator|=
name|c_list
argument_list|()
expr_stmt|;
name|musthave
argument_list|(
name|mark
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multiline
operator|--
expr_stmt|;
return|return
operator|(
name|block
argument_list|(
name|type
argument_list|,
name|t
argument_list|,
name|NOBLOCK
argument_list|,
name|NOWORDS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|command
parameter_list|(
name|cf
parameter_list|)
name|int
name|cf
decl_stmt|;
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|struct
name|wdblock
modifier|*
name|iosave
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|iosave
operator|=
name|iolist
expr_stmt|;
name|iolist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|multiline
condition|)
name|cf
operator||=
name|CONTIN
expr_stmt|;
while|while
condition|(
name|synio
argument_list|(
name|cf
argument_list|)
condition|)
name|cf
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|yylex
argument_list|(
name|cf
argument_list|)
condition|)
block|{
default|default:
name|peeksym
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|simple
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|iolist
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
expr|struct
name|op
operator|*
operator|)
name|NULL
operator|)
return|;
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|TCOM
expr_stmt|;
block|}
break|break;
case|case
literal|'('
case|:
name|t
operator|=
name|nested
argument_list|(
name|TPAREN
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|t
operator|=
name|nested
argument_list|(
name|TBRACE
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOR
case|:
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|TFOR
expr_stmt|;
name|musthave
argument_list|(
name|WORD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|startl
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|str
operator|=
name|yylval
operator|.
name|cp
expr_stmt|;
name|multiline
operator|++
expr_stmt|;
name|t
operator|->
name|words
operator|=
name|wordlist
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
name|peeksym
operator|=
name|c
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|dogroup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|multiline
operator|--
expr_stmt|;
break|break;
case|case
name|WHILE
case|:
case|case
name|UNTIL
case|:
name|multiline
operator|++
expr_stmt|;
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|c
operator|==
name|WHILE
condition|?
name|TWHILE
else|:
name|TUNTIL
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|c_list
argument_list|()
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|dogroup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|words
operator|=
name|NULL
expr_stmt|;
name|multiline
operator|--
expr_stmt|;
break|break;
case|case
name|CASE
case|:
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|TCASE
expr_stmt|;
name|musthave
argument_list|(
name|WORD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|str
operator|=
name|yylval
operator|.
name|cp
expr_stmt|;
name|startl
operator|++
expr_stmt|;
name|multiline
operator|++
expr_stmt|;
name|musthave
argument_list|(
name|IN
argument_list|,
name|CONTIN
argument_list|)
expr_stmt|;
name|startl
operator|++
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|caselist
argument_list|()
expr_stmt|;
name|musthave
argument_list|(
name|ESAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multiline
operator|--
expr_stmt|;
break|break;
case|case
name|IF
case|:
name|multiline
operator|++
expr_stmt|;
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|TIF
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|c_list
argument_list|()
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|thenpart
argument_list|()
expr_stmt|;
name|musthave
argument_list|(
name|FI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multiline
operator|--
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|synio
argument_list|(
literal|0
argument_list|)
condition|)
empty_stmt|;
name|t
operator|=
name|namelist
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|iolist
operator|=
name|iosave
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|dogroup
parameter_list|(
name|onlydone
parameter_list|)
name|int
name|onlydone
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|op
modifier|*
name|list
decl_stmt|;
name|c
operator|=
name|yylex
argument_list|(
name|CONTIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|DONE
operator|&&
name|onlydone
condition|)
return|return
operator|(
operator|(
expr|struct
name|op
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|c
operator|!=
name|DO
condition|)
name|SYNTAXERR
expr_stmt|;
name|list
operator|=
name|c_list
argument_list|()
expr_stmt|;
name|musthave
argument_list|(
name|DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|thenpart
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|THEN
condition|)
block|{
name|peeksym
operator|=
name|c
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|op
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|c_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|left
operator|==
name|NULL
condition|)
name|SYNTAXERR
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|elsepart
argument_list|()
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|elsepart
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
name|ELSE
case|:
if|if
condition|(
operator|(
name|t
operator|=
name|c_list
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|SYNTAXERR
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
case|case
name|ELIF
case|:
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|TELIF
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|c_list
argument_list|()
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|thenpart
argument_list|()
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
default|default:
name|peeksym
operator|=
name|c
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|op
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|caselist
parameter_list|()
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|peeksym
operator|=
name|yylex
argument_list|(
name|CONTIN
argument_list|)
operator|)
operator|!=
name|ESAC
condition|)
name|t
operator|=
name|list
argument_list|(
name|t
argument_list|,
name|casepart
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|casepart
parameter_list|()
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|TPAT
expr_stmt|;
name|t
operator|->
name|words
operator|=
name|pattern
argument_list|()
expr_stmt|;
name|musthave
argument_list|(
literal|')'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|c_list
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|yylex
argument_list|(
name|CONTIN
argument_list|)
operator|)
operator|!=
name|ESAC
condition|)
name|musthave
argument_list|(
name|BREAK
argument_list|,
name|CONTIN
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|pattern
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|cf
decl_stmt|;
name|cf
operator|=
name|CONTIN
expr_stmt|;
do|do
block|{
name|musthave
argument_list|(
name|WORD
argument_list|,
name|cf
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|yylval
operator|.
name|cp
argument_list|)
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|'|'
condition|)
do|;
name|peeksym
operator|=
name|c
expr_stmt|;
name|word
argument_list|(
name|NOWORD
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyw
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|wordlist
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|IN
condition|)
block|{
name|peeksym
operator|=
name|c
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|startl
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|yylex
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|WORD
condition|)
name|word
argument_list|(
name|yylval
operator|.
name|cp
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|NOWORD
argument_list|)
expr_stmt|;
name|peeksym
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|copyw
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * supporting functions  */
end_comment

begin_function
specifier|static
name|struct
name|op
modifier|*
name|list
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t1
decl_stmt|,
decl|*
name|t2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
return|return
operator|(
name|t2
operator|)
return|;
if|if
condition|(
name|t2
operator|==
name|NULL
condition|)
return|return
operator|(
name|t1
operator|)
return|;
return|return
operator|(
name|block
argument_list|(
name|TLIST
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|NOWORDS
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|struct
name|op
modifier|*
name|block
parameter_list|(
name|type
parameter_list|,
name|t1
parameter_list|,
name|t2
parameter_list|,
name|wp
parameter_list|)
name|int
name|type
decl_stmt|;
name|struct
name|op
modifier|*
name|t1
decl_stmt|,
decl|*
name|t2
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|newtp
argument_list|()
expr_stmt|;
name|t
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|t1
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|t2
expr_stmt|;
name|t
operator|->
name|words
operator|=
name|wp
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|res
block|{
name|char
modifier|*
name|r_name
decl_stmt|;
name|int
name|r_val
decl_stmt|;
block|}
name|restab
index|[]
init|=
block|{
literal|"for"
block|,
name|FOR
block|,
literal|"case"
block|,
name|CASE
block|,
literal|"esac"
block|,
name|ESAC
block|,
literal|"while"
block|,
name|WHILE
block|,
literal|"do"
block|,
name|DO
block|,
literal|"done"
block|,
name|DONE
block|,
literal|"if"
block|,
name|IF
block|,
literal|"in"
block|,
name|IN
block|,
literal|"then"
block|,
name|THEN
block|,
literal|"else"
block|,
name|ELSE
block|,
literal|"elif"
block|,
name|ELIF
block|,
literal|"until"
block|,
name|UNTIL
block|,
literal|"fi"
block|,
name|FI
block|,
literal|";;"
block|,
name|BREAK
block|,
literal|"||"
block|,
name|LOGOR
block|,
literal|"&&"
block|,
name|LOGAND
block|,
literal|"{"
block|,
literal|'{'
block|,
literal|"}"
block|,
literal|'}'
block|,
literal|0
block|, }
struct|;
end_struct

begin_function
name|int
name|rlookup
parameter_list|(
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|res
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|restab
init|;
name|rp
operator|->
name|r_name
condition|;
name|rp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rp
operator|->
name|r_name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rp
operator|->
name|r_val
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|newtp
parameter_list|()
block|{
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|op
operator|*
operator|)
name|tree
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|words
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|ioact
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|str
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|namelist
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
name|iolist
condition|)
block|{
name|iolist
operator|=
name|addword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|iolist
argument_list|)
expr_stmt|;
name|t
operator|->
name|ioact
operator|=
name|copyio
argument_list|()
expr_stmt|;
block|}
else|else
name|t
operator|->
name|ioact
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|!=
name|TCOM
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|type
operator|!=
name|TPAREN
operator|&&
name|t
operator|->
name|ioact
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|block
argument_list|(
name|TPAREN
argument_list|,
name|t
argument_list|,
name|NOBLOCK
argument_list|,
name|NOWORDS
argument_list|)
expr_stmt|;
name|t
operator|->
name|ioact
operator|=
name|t
operator|->
name|left
operator|->
name|ioact
expr_stmt|;
name|t
operator|->
name|left
operator|->
name|ioact
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
name|word
argument_list|(
name|NOWORD
argument_list|)
expr_stmt|;
name|t
operator|->
name|words
operator|=
name|copyw
argument_list|()
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|copyw
parameter_list|()
block|{
specifier|register
name|char
modifier|*
modifier|*
name|wd
decl_stmt|;
name|wd
operator|=
name|getwords
argument_list|(
name|wdlist
argument_list|)
expr_stmt|;
name|wdlist
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|wd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|word
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|wdlist
operator|=
name|addword
argument_list|(
name|cp
argument_list|,
name|wdlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ioword
modifier|*
modifier|*
name|copyio
parameter_list|()
block|{
specifier|register
name|struct
name|ioword
modifier|*
modifier|*
name|iop
decl_stmt|;
name|iop
operator|=
operator|(
expr|struct
name|ioword
operator|*
operator|*
operator|)
name|getwords
argument_list|(
name|iolist
argument_list|)
expr_stmt|;
name|iolist
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ioword
modifier|*
name|io
parameter_list|(
name|u
parameter_list|,
name|f
parameter_list|,
name|cp
parameter_list|)
name|int
name|u
decl_stmt|;
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|struct
name|ioword
modifier|*
name|iop
decl_stmt|;
name|iop
operator|=
operator|(
expr|struct
name|ioword
operator|*
operator|)
name|tree
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iop
argument_list|)
argument_list|)
expr_stmt|;
name|iop
operator|->
name|io_unit
operator|=
name|u
expr_stmt|;
name|iop
operator|->
name|io_flag
operator|=
name|f
expr_stmt|;
name|iop
operator|->
name|io_name
operator|=
name|cp
expr_stmt|;
name|iolist
operator|=
name|addword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iop
argument_list|,
name|iolist
argument_list|)
expr_stmt|;
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zzerr
parameter_list|()
block|{
name|yyerror
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|yyerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|yynerrs
operator|++
expr_stmt|;
if|if
condition|(
name|talking
operator|&&
name|e
operator|.
name|iop
operator|<=
name|iostack
condition|)
block|{
name|multiline
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|eofc
argument_list|()
operator|==
literal|0
operator|&&
name|yylex
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
name|err
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|yylex
parameter_list|(
name|cf
parameter_list|)
name|int
name|cf
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|c1
decl_stmt|;
name|int
name|atstart
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|peeksym
operator|)
operator|>
literal|0
condition|)
block|{
name|peeksym
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|startl
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|nlseen
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|linep
operator|=
name|line
expr_stmt|;
name|atstart
operator|=
name|startl
expr_stmt|;
name|startl
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|loop
label|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
if|if
condition|(
name|any
argument_list|(
name|c
argument_list|,
literal|"0123456789"
argument_list|)
condition|)
block|{
name|unget
argument_list|(
name|c1
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'<'
operator|||
name|c1
operator|==
literal|'>'
condition|)
block|{
name|iounit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|c1
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|0
case|:
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'$'
case|:
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
literal|'{'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|collect
argument_list|(
name|c
argument_list|,
literal|'}'
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|c
operator|)
return|;
goto|goto
name|pack
goto|;
block|}
break|break;
case|case
literal|'`'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|collect
argument_list|(
name|c
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|c
operator|)
return|;
goto|goto
name|pack
goto|;
case|case
literal|'|'
case|:
case|case
literal|'&'
case|:
case|case
literal|';'
case|:
if|if
condition|(
operator|(
name|c1
operator|=
name|dual
argument_list|(
name|c
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|startl
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|c1
operator|)
return|;
block|}
name|startl
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'^'
case|:
name|startl
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|'|'
operator|)
return|;
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
name|diag
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'\n'
case|:
name|nlseen
operator|++
expr_stmt|;
name|gethere
argument_list|()
expr_stmt|;
name|startl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|multiline
operator|||
name|cf
operator|&
name|CONTIN
condition|)
block|{
if|if
condition|(
name|talking
operator|&&
name|e
operator|.
name|iop
operator|<=
name|iostack
condition|)
name|prs
argument_list|(
name|cprompt
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|&
name|CONTIN
condition|)
goto|goto
name|loop
goto|;
block|}
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'('
case|:
case|case
literal|')'
case|:
name|startl
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pack
label|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|any
argument_list|(
name|c
argument_list|,
literal|"`$ '\"\t;&<>()|^\n"
argument_list|)
condition|)
if|if
condition|(
name|e
operator|.
name|linep
operator|>=
name|elinep
condition|)
name|err
argument_list|(
literal|"word too long"
argument_list|)
expr_stmt|;
else|else
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|any
argument_list|(
name|c
argument_list|,
literal|"\"'`$"
argument_list|)
condition|)
goto|goto
name|loop
goto|;
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|atstart
operator|&&
operator|(
name|c
operator|=
name|rlookup
argument_list|(
name|line
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|startl
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|yylval
operator|.
name|cp
operator|=
name|strsave
argument_list|(
name|line
argument_list|,
name|areanum
argument_list|)
expr_stmt|;
return|return
operator|(
name|WORD
operator|)
return|;
block|}
end_function

begin_function
name|int
name|collect
parameter_list|(
name|c
parameter_list|,
name|c1
parameter_list|)
function|register c
operator|,
function|c1;
end_function

begin_block
block|{
name|char
name|s
index|[
literal|2
index|]
decl_stmt|;
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|c1
argument_list|)
operator|)
operator|!=
name|c1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|s
index|[
literal|0
index|]
operator|=
name|c1
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prs
argument_list|(
literal|"no closing "
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|YYERRCODE
operator|)
return|;
block|}
if|if
condition|(
name|talking
operator|&&
name|c
operator|==
literal|'\n'
operator|&&
name|e
operator|.
name|iop
operator|<=
name|iostack
condition|)
name|prs
argument_list|(
name|cprompt
operator|->
name|value
argument_list|)
expr_stmt|;
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|e
operator|.
name|linep
operator|++
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|dual
argument_list|(
name|c
argument_list|)
decl|register
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|s
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|s
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|rlookup
argument_list|(
name|s
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|unget
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|diag
parameter_list|(
name|ec
parameter_list|)
specifier|register
name|int
name|ec
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
operator|||
name|c
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|ec
condition|)
name|zzerr
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|ec
operator|==
literal|'>'
condition|?
name|IOWRITE
operator||
name|IOCAT
else|:
name|IOHERE
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|yylval
operator|.
name|i
operator|=
name|ec
operator|==
literal|'>'
condition|?
name|IOWRITE
else|:
name|IOREAD
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'&'
operator|||
name|yylval
operator|.
name|i
operator|==
name|IOHERE
condition|)
name|unget
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|i
operator||=
name|IODUP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tree
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|getcell
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|prs
argument_list|(
literal|"command line too complicated\n"
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VARARGS1 */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|printf
parameter_list|(
name|s
parameter_list|)
comment|/* yyparse calls it */
name|char
modifier|*
name|s
decl_stmt|;
block|{ }
end_function

end_unit

