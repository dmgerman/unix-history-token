begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|Extern
value|extern
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|_NSIG
value|NSIG
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_comment
comment|/* -------- io.c -------- */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_comment
comment|/*  * shell IO  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|iobuf
name|sharedbuf
init|=
block|{
name|AFID_NOBUF
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|iobuf
name|mainbuf
init|=
block|{
name|AFID_NOBUF
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|bufid
init|=
name|AFID_ID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer id counter */
end_comment

begin_decl_stmt
name|struct
name|ioarg
name|temparg
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|AFID_NOBUF
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void readhere
argument_list|,
argument|(char **name, char *s, int ec )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void pushio
argument_list|,
argument|(struct ioarg *argp, int (*fn)())
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int xxchar
argument_list|,
argument|(struct ioarg *ap )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void tempname
argument_list|,
argument|(char *tname )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|int
name|getc
parameter_list|(
name|ec
parameter_list|)
specifier|register
name|int
name|ec
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|linep
operator|>
name|elinep
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|readc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
condition|)
empty_stmt|;
name|err
argument_list|(
literal|"input line too long"
argument_list|)
expr_stmt|;
name|gflg
operator|++
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|ec
operator|!=
literal|'\''
operator|&&
name|e
operator|.
name|iop
operator|->
name|task
operator|!=
name|XGRAVE
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|ec
operator|!=
literal|'\"'
condition|)
return|return
operator|(
name|getc
argument_list|(
name|ec
argument_list|)
operator|)
return|;
name|c
operator||=
name|QUOTE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|void
name|unget
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|.
name|iop
operator|>=
name|e
operator|.
name|iobase
condition|)
name|e
operator|.
name|iop
operator|->
name|peekc
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
name|int
name|eofc
parameter_list|()
block|{
return|return
name|e
operator|.
name|iop
operator|<
name|e
operator|.
name|iobase
operator|||
operator|(
name|e
operator|.
name|iop
operator|->
name|peekc
operator|==
literal|0
operator|&&
name|e
operator|.
name|iop
operator|->
name|prev
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|readc
parameter_list|()
block|{
specifier|register
name|c
expr_stmt|;
for|for
control|(
init|;
name|e
operator|.
name|iop
operator|>=
name|e
operator|.
name|iobase
condition|;
name|e
operator|.
name|iop
operator|--
control|)
if|if
condition|(
operator|(
name|c
operator|=
name|e
operator|.
name|iop
operator|->
name|peekc
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|e
operator|.
name|iop
operator|->
name|peekc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|.
name|iop
operator|->
name|prev
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
call|(
modifier|*
name|e
operator|.
name|iop
operator|->
name|iofn
call|)
argument_list|(
name|e
operator|.
name|iop
operator|->
name|argp
argument_list|,
name|e
operator|.
name|iop
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|e
operator|.
name|iop
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|e
operator|.
name|iop
operator|==
name|iostack
condition|)
name|ioecho
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|.
name|iop
operator|->
name|prev
operator|=
name|c
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|iop
operator|->
name|task
operator|==
name|XIO
operator|&&
name|e
operator|.
name|iop
operator|->
name|prev
operator|!=
literal|'\n'
condition|)
block|{
name|e
operator|.
name|iop
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|iop
operator|==
name|iostack
condition|)
name|ioecho
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
block|}
if|if
condition|(
name|e
operator|.
name|iop
operator|->
name|task
operator|==
name|XIO
condition|)
block|{
if|if
condition|(
name|multiline
condition|)
return|return
name|e
operator|.
name|iop
operator|->
name|prev
operator|=
literal|0
return|;
if|if
condition|(
name|talking
operator|&&
name|e
operator|.
name|iop
operator|==
name|iostack
operator|+
literal|1
condition|)
name|prs
argument_list|(
name|prompt
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|.
name|iop
operator|>=
name|iostack
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|leave
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|void
name|ioecho
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|flag
index|[
literal|'v'
index|]
condition|)
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|pushio
argument_list|(
name|argp
argument_list|,
name|fn
argument_list|)
decl|struct
name|ioarg
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
operator|++
name|e
operator|.
name|iop
operator|>=
operator|&
name|iostack
index|[
name|NPUSH
index|]
condition|)
block|{
name|e
operator|.
name|iop
operator|--
expr_stmt|;
name|err
argument_list|(
literal|"Shell input nested too deeply"
argument_list|)
expr_stmt|;
name|gflg
operator|++
expr_stmt|;
return|return;
block|}
name|e
operator|.
name|iop
operator|->
name|iofn
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|afid
operator|!=
name|AFID_NOBUF
condition|)
name|e
operator|.
name|iop
operator|->
name|argp
operator|=
name|argp
expr_stmt|;
else|else
block|{
name|e
operator|.
name|iop
operator|->
name|argp
operator|=
name|ioargstack
operator|+
operator|(
name|e
operator|.
name|iop
operator|-
name|iostack
operator|)
expr_stmt|;
operator|*
name|e
operator|.
name|iop
operator|->
name|argp
operator|=
operator|*
name|argp
expr_stmt|;
name|e
operator|.
name|iop
operator|->
name|argp
operator|->
name|afbuf
operator|=
name|e
operator|.
name|iop
operator|==
operator|&
name|iostack
index|[
literal|0
index|]
condition|?
operator|&
name|mainbuf
else|:
operator|&
name|sharedbuf
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|e
operator|.
name|iop
operator|->
name|argp
operator|->
name|afile
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|e
operator|.
name|iop
operator|==
operator|&
name|iostack
index|[
literal|0
index|]
operator|||
name|lseek
argument_list|(
name|e
operator|.
name|iop
operator|->
name|argp
operator|->
name|afile
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|bufid
operator|==
name|AFID_NOBUF
condition|)
name|bufid
operator|=
name|AFID_ID
expr_stmt|;
name|e
operator|.
name|iop
operator|->
name|argp
operator|->
name|afid
operator|=
name|bufid
expr_stmt|;
block|}
block|}
name|e
operator|.
name|iop
operator|->
name|prev
operator|=
operator|~
literal|'\n'
expr_stmt|;
name|e
operator|.
name|iop
operator|->
name|peekc
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|iop
operator|->
name|xchar
operator|=
literal|0
expr_stmt|;
name|e
operator|.
name|iop
operator|->
name|nlcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|filechar
operator|||
name|fn
operator|==
name|linechar
condition|)
name|e
operator|.
name|iop
operator|->
name|task
operator|=
name|XIO
expr_stmt|;
elseif|else
if|if
condition|(
name|fn
operator|==
name|gravechar
operator|||
name|fn
operator|==
name|qgravechar
condition|)
name|e
operator|.
name|iop
operator|->
name|task
operator|=
name|XGRAVE
expr_stmt|;
else|else
name|e
operator|.
name|iop
operator|->
name|task
operator|=
name|XOTHER
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|io
modifier|*
name|setbase
parameter_list|(
name|ip
parameter_list|)
name|struct
name|io
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|struct
name|io
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
name|e
operator|.
name|iobase
expr_stmt|;
name|e
operator|.
name|iobase
operator|=
name|ip
expr_stmt|;
return|return
operator|(
name|xp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Input generating functions  */
end_comment

begin_comment
comment|/*  * Produce the characters of a string, then a newline, then EOF.  */
end_comment

begin_function
name|int
name|nlchar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|aword
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|ap
operator|->
name|aword
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|ap
operator|->
name|aword
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|'\n'
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a list of words, produce the characters  * in them, with a space after each word.  */
end_comment

begin_function
name|int
name|wdchar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|wl
decl_stmt|;
if|if
condition|(
operator|(
name|wl
operator|=
name|ap
operator|->
name|awordlist
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|wl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
operator|*
name|wl
operator|)
operator|++
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|c
operator|&
literal|0177
operator|)
return|;
name|ap
operator|->
name|awordlist
operator|++
expr_stmt|;
return|return
operator|(
literal|' '
operator|)
return|;
block|}
name|ap
operator|->
name|awordlist
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|'\n'
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the characters of a list of words,  * producing a space between them.  */
end_comment

begin_function
name|int
name|dolchar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|wp
decl_stmt|;
if|if
condition|(
operator|(
name|wp
operator|=
operator|*
name|ap
operator|->
name|awordlist
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PUSHIO
argument_list|(
name|aword
argument_list|,
name|wp
argument_list|,
operator|*
name|ap
operator|->
name|awordlist
operator|==
name|NULL
condition|?
name|strchar
else|:
name|xxchar
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xxchar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|aword
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|ap
operator|->
name|aword
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|ap
operator|->
name|aword
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|' '
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Produce the characters from a single word (string).  */
end_comment

begin_function
name|int
name|strchar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|aword
operator|==
name|NULL
operator|||
operator|(
name|c
operator|=
operator|*
name|ap
operator|->
name|aword
operator|++
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Produce quoted characters from a single word (string).  */
end_comment

begin_function
name|int
name|qstrchar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|aword
operator|==
name|NULL
operator|||
operator|(
name|c
operator|=
operator|*
name|ap
operator|->
name|aword
operator|++
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|c
operator||
name|QUOTE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the characters from a file.  */
end_comment

begin_function
name|int
name|filechar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|iobuf
modifier|*
name|bp
init|=
name|ap
operator|->
name|afbuf
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|afid
operator|!=
name|AFID_NOBUF
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|ap
operator|->
name|afid
operator|!=
name|bp
operator|->
name|id
operator|)
operator|||
name|bp
operator|->
name|bufp
operator|==
name|bp
operator|->
name|ebufp
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|lseek
argument_list|(
name|ap
operator|->
name|afile
argument_list|,
name|ap
operator|->
name|afpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|i
operator|=
name|read
argument_list|(
name|ap
operator|->
name|afile
argument_list|,
name|bp
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|closef
argument_list|(
name|ap
operator|->
name|afile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bp
operator|->
name|id
operator|=
name|ap
operator|->
name|afid
expr_stmt|;
name|bp
operator|->
name|ebufp
operator|=
operator|(
name|bp
operator|->
name|bufp
operator|=
name|bp
operator|->
name|buf
operator|)
operator|+
name|i
expr_stmt|;
block|}
name|ap
operator|->
name|afpos
operator|++
expr_stmt|;
return|return
operator|*
name|bp
operator|->
name|bufp
operator|++
operator|&
literal|0177
return|;
block|}
do|do
block|{
name|i
operator|=
name|read
argument_list|(
name|ap
operator|->
name|afile
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
return|return
operator|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|c
argument_list|)
condition|?
name|c
operator|&
literal|0177
else|:
operator|(
name|closef
argument_list|(
name|ap
operator|->
name|afile
argument_list|)
operator|,
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the characters from a here temp file.  */
end_comment

begin_function
name|int
name|herechar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|ap
operator|->
name|afile
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|ap
operator|->
name|afile
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the characters produced by a process (`...`).  * Quote them if required, and remove any trailing newline characters.  */
end_comment

begin_function
name|int
name|gravechar
parameter_list|(
name|ap
parameter_list|,
name|iop
parameter_list|)
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
name|struct
name|io
modifier|*
name|iop
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|qgravechar
argument_list|(
name|ap
argument_list|,
name|iop
argument_list|)
operator|&
operator|~
name|QUOTE
operator|)
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|qgravechar
parameter_list|(
name|ap
parameter_list|,
name|iop
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
name|struct
name|io
modifier|*
name|iop
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|iop
operator|->
name|xchar
condition|)
block|{
if|if
condition|(
name|iop
operator|->
name|nlcount
condition|)
block|{
name|iop
operator|->
name|nlcount
operator|--
expr_stmt|;
return|return
operator|(
literal|'\n'
operator||
name|QUOTE
operator|)
return|;
block|}
name|c
operator|=
name|iop
operator|->
name|xchar
expr_stmt|;
name|iop
operator|->
name|xchar
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|filechar
argument_list|(
name|ap
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|iop
operator|->
name|nlcount
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|filechar
argument_list|(
name|ap
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
name|iop
operator|->
name|nlcount
operator|++
expr_stmt|;
name|iop
operator|->
name|xchar
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|iop
operator|->
name|nlcount
operator|--
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|!=
literal|0
condition|?
name|c
operator||
name|QUOTE
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a single command (usually the first line) from a file.  */
end_comment

begin_function
name|int
name|linechar
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|struct
name|ioarg
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|filechar
argument_list|(
name|ap
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|multiline
condition|)
block|{
name|closef
argument_list|(
name|ap
operator|->
name|afile
argument_list|)
expr_stmt|;
name|ap
operator|->
name|afile
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* illegal value */
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prs
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|s
condition|)
name|write
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|putc
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prn
parameter_list|(
name|u
parameter_list|)
name|unsigned
name|u
decl_stmt|;
block|{
name|prs
argument_list|(
name|itoa
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|closef
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|>
literal|2
condition|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|closeall
parameter_list|()
block|{
specifier|register
name|u
expr_stmt|;
for|for
control|(
name|u
operator|=
name|NUFILE
init|;
name|u
operator|<
name|NOFILE
condition|;
control|)
name|close
argument_list|(
name|u
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remap fd into Shell's fd space  */
end_comment

begin_function
name|int
name|remap
parameter_list|(
name|fd
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|map
index|[
name|NOFILE
index|]
decl_stmt|;
if|if
condition|(
name|fd
operator|<
name|e
operator|.
name|iofd
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
name|map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|map
index|[
name|fd
index|]
operator|=
literal|1
expr_stmt|;
name|fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<
name|e
operator|.
name|iofd
condition|)
do|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|map
index|[
name|i
index|]
condition|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|"too many files open in shell"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_function
name|int
name|openpipe
parameter_list|(
name|pv
parameter_list|)
specifier|register
name|int
modifier|*
name|pv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|pipe
argument_list|(
name|pv
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|"can't create pipe - try again"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|void
name|closepipe
parameter_list|(
name|pv
parameter_list|)
specifier|register
name|int
modifier|*
name|pv
decl_stmt|;
block|{
if|if
condition|(
name|pv
operator|!=
name|NULL
condition|)
block|{
name|close
argument_list|(
operator|*
name|pv
operator|++
argument_list|)
expr_stmt|;
name|close
argument_list|(
operator|*
name|pv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* -------- here.c -------- */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_comment
comment|/*  * here documents  */
end_comment

begin_struct
struct|struct
name|here
block|{
name|char
modifier|*
name|h_tag
decl_stmt|;
name|int
name|h_dosub
decl_stmt|;
name|struct
name|ioword
modifier|*
name|h_iop
decl_stmt|;
name|struct
name|here
modifier|*
name|h_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|here
modifier|*
name|inhere
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of hear docs while parsing */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|here
modifier|*
name|acthere
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of active here documents */
end_comment

begin_function
name|void
name|markhere
parameter_list|(
name|s
parameter_list|,
name|iop
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|ioword
modifier|*
name|iop
decl_stmt|;
block|{
specifier|register
name|struct
name|here
modifier|*
name|h
decl_stmt|,
modifier|*
name|lh
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|here
operator|*
operator|)
name|space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|here
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
return|return;
name|h
operator|->
name|h_tag
operator|=
name|evalstr
argument_list|(
name|s
argument_list|,
name|DOSUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_tag
operator|==
literal|0
condition|)
return|return;
name|h
operator|->
name|h_iop
operator|=
name|iop
expr_stmt|;
name|iop
operator|->
name|io_name
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|h_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inhere
operator|==
literal|0
condition|)
name|inhere
operator|=
name|h
expr_stmt|;
else|else
for|for
control|(
name|lh
operator|=
name|inhere
init|;
name|lh
operator|!=
name|NULL
condition|;
name|lh
operator|=
name|lh
operator|->
name|h_next
control|)
if|if
condition|(
name|lh
operator|->
name|h_next
operator|==
literal|0
condition|)
block|{
name|lh
operator|->
name|h_next
operator|=
name|h
expr_stmt|;
break|break;
block|}
name|iop
operator|->
name|io_flag
operator||=
name|IOHERE
operator||
name|IOXHERE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|h
operator|->
name|h_tag
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|&
name|QUOTE
condition|)
block|{
name|iop
operator|->
name|io_flag
operator|&=
operator|~
name|IOXHERE
expr_stmt|;
operator|*
name|s
operator|&=
operator|~
name|QUOTE
expr_stmt|;
block|}
name|h
operator|->
name|h_dosub
operator|=
name|iop
operator|->
name|io_flag
operator|&
name|IOXHERE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gethere
parameter_list|()
block|{
specifier|register
name|struct
name|here
modifier|*
name|h
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
comment|/* Scan here files first leaving inhere list in place */
for|for
control|(
name|hp
operator|=
name|h
operator|=
name|inhere
init|;
name|h
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|h
operator|,
name|h
operator|=
name|h
operator|->
name|h_next
control|)
name|readhere
argument_list|(
operator|&
name|h
operator|->
name|h_iop
operator|->
name|io_name
argument_list|,
name|h
operator|->
name|h_tag
argument_list|,
name|h
operator|->
name|h_dosub
condition|?
literal|0
else|:
literal|'\''
argument_list|)
expr_stmt|;
comment|/* Make inhere list active - keep list intact for scraphere */
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|hp
operator|->
name|h_next
operator|=
name|acthere
expr_stmt|;
name|acthere
operator|=
name|inhere
expr_stmt|;
name|inhere
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|readhere
parameter_list|(
name|name
parameter_list|,
name|s
parameter_list|,
name|ec
parameter_list|)
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ec
decl_stmt|;
block|{
name|int
name|tf
decl_stmt|;
name|char
name|tname
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|jmp_buf
name|ev
decl_stmt|;
name|char
name|line
index|[
name|LINELIM
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|tempname
argument_list|(
name|tname
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|strsave
argument_list|(
name|tname
argument_list|,
name|areanum
argument_list|)
expr_stmt|;
name|tf
operator|=
name|creat
argument_list|(
name|tname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|newenv
argument_list|(
name|setjmp
argument_list|(
name|errpt
operator|=
name|ev
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
else|else
block|{
name|pushio
argument_list|(
name|e
operator|.
name|iop
operator|->
name|argp
argument_list|,
name|e
operator|.
name|iop
operator|->
name|iofn
argument_list|)
expr_stmt|;
name|e
operator|.
name|iobase
operator|=
name|e
operator|.
name|iop
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|talking
operator|&&
name|e
operator|.
name|iop
operator|<=
name|iostack
condition|)
name|prs
argument_list|(
name|cprompt
operator|->
name|value
argument_list|)
expr_stmt|;
name|next
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ec
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
condition|)
block|{
if|if
condition|(
name|ec
operator|==
literal|'\''
condition|)
name|c
operator|&=
operator|~
name|QUOTE
expr_stmt|;
if|if
condition|(
name|next
operator|>=
operator|&
name|line
index|[
name|LINELIM
index|]
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|next
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|line
argument_list|)
operator|==
literal|0
operator|||
name|c
operator|==
literal|0
condition|)
break|break;
operator|*
name|next
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|write
argument_list|(
name|tf
argument_list|,
name|line
argument_list|,
call|(
name|int
call|)
argument_list|(
name|next
operator|-
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"here document `"
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"' unclosed"
argument_list|)
expr_stmt|;
block|}
name|quitenv
argument_list|()
expr_stmt|;
block|}
name|close
argument_list|(
name|tf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * open here temp file.  * if unquoted here, expand here temp file into second temp file.  */
end_comment

begin_function
name|int
name|herein
parameter_list|(
name|hname
parameter_list|,
name|xdoll
parameter_list|)
name|char
modifier|*
name|hname
decl_stmt|;
name|int
name|xdoll
decl_stmt|;
block|{
specifier|register
name|hf
operator|,
name|tf
expr_stmt|;
if|if
condition|(
name|hname
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hf
operator|=
name|open
argument_list|(
name|hname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|xdoll
condition|)
block|{
name|char
name|c
decl_stmt|;
name|char
name|tname
index|[
literal|30
index|]
decl_stmt|;
name|jmp_buf
name|ev
decl_stmt|;
name|tempname
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|=
name|creat
argument_list|(
name|tname
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|newenv
argument_list|(
name|setjmp
argument_list|(
name|errpt
operator|=
name|ev
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|PUSHIO
argument_list|(
name|afile
argument_list|,
name|hf
argument_list|,
name|herechar
argument_list|)
expr_stmt|;
name|setbase
argument_list|(
name|e
operator|.
name|iop
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|subgetc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|c
operator|&=
operator|~
name|QUOTE
expr_stmt|;
name|write
argument_list|(
name|tf
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
expr_stmt|;
block|}
name|quitenv
argument_list|()
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|tf
operator|=
name|open
argument_list|(
name|tname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|tf
operator|)
return|;
block|}
else|else
return|return
operator|(
name|hf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scraphere
parameter_list|()
block|{
specifier|register
name|struct
name|here
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|inhere
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_next
control|)
block|{
if|if
condition|(
name|h
operator|->
name|h_iop
operator|&&
name|h
operator|->
name|h_iop
operator|->
name|io_name
condition|)
name|unlink
argument_list|(
name|h
operator|->
name|h_iop
operator|->
name|io_name
argument_list|)
expr_stmt|;
block|}
name|inhere
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unlink here temp files before a freearea(area) */
end_comment

begin_function
name|void
name|freehere
parameter_list|(
name|area
parameter_list|)
name|int
name|area
decl_stmt|;
block|{
specifier|register
name|struct
name|here
modifier|*
name|h
decl_stmt|,
modifier|*
name|hl
decl_stmt|;
name|hl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|h
operator|=
name|acthere
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_next
control|)
if|if
condition|(
name|getarea
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
argument_list|)
operator|>=
name|area
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_iop
operator|->
name|io_name
operator|!=
name|NULL
condition|)
name|unlink
argument_list|(
name|h
operator|->
name|h_iop
operator|->
name|io_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|==
name|NULL
condition|)
name|acthere
operator|=
name|h
operator|->
name|h_next
expr_stmt|;
else|else
name|hl
operator|->
name|h_next
operator|=
name|h
operator|->
name|h_next
expr_stmt|;
block|}
else|else
name|hl
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tempname
parameter_list|(
name|tname
parameter_list|)
name|char
modifier|*
name|tname
decl_stmt|;
block|{
specifier|static
name|int
name|inc
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|tname
operator|,
name|lp
operator|=
literal|"/tmp/shtm"
init|;
operator|(
operator|*
name|cp
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
name|lp
operator|=
name|putn
argument_list|(
name|getpid
argument_list|()
operator|*
literal|1000
operator|+
name|inc
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|cp
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
block|}
end_function

end_unit

