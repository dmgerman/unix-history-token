begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|Extern
value|extern
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|_NSIG
value|NSIG
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_comment
comment|/* -------- exec.c -------- */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_comment
comment|/*  * execute tree  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|signame
index|[]
init|=
block|{
literal|"Signal 0"
block|,
literal|"Hangup"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
comment|/* interrupt */
literal|"Quit"
block|,
literal|"Illegal instruction"
block|,
literal|"Trace/BPT trap"
block|,
literal|"Abort"
block|,
literal|"EMT trap"
block|,
literal|"Floating exception"
block|,
literal|"Killed"
block|,
literal|"Bus error"
block|,
literal|"Memory fault"
block|,
literal|"Bad system call"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
comment|/* broken pipe */
literal|"Alarm clock"
block|,
literal|"Terminated"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSIGNAL
value|(sizeof(signame)/sizeof(signame[0]))
end_define

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int forkexec
argument_list|,
argument|(struct op *t, int *pin, int *pout, int act, char **wp, int *pforked )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int parent
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int iosetup
argument_list|,
argument|(struct ioword *iop, int pipein, int pipeout )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void echo
argument_list|,
argument|(char **wp )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
operator|*
name|find1case
argument_list|,
operator|(
expr|struct
name|op
operator|*
name|t
operator|,
name|char
operator|*
name|w
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
specifier|static
expr|struct
name|op
operator|*
name|findcase
argument_list|,
operator|(
expr|struct
name|op
operator|*
name|t
operator|,
name|char
operator|*
name|w
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void brkset
argument_list|,
argument|(struct brkcon *bc )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dolabel
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dochdir
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doshift
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dologin
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doumask
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doexec
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dodot
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dowait
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doread
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doeval
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dotrap
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int getsig
argument_list|,
argument|(char *s )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void setsig
argument_list|,
argument|(int n, void (*f)())
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int getn
argument_list|,
argument|(char *as )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dobreak
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int docontinue
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static int brkcontin
argument_list|,
argument|(char *cp, int val )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doexit
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doexport
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doreadonly
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void rdexp
argument_list|,
argument|(char **wp, void (*f)(), int key)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|static void badid
argument_list|,
argument|(char *s )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int doset
argument_list|,
argument|(struct op *t )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|void varput
argument_list|,
argument|(char *s, int out )
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|_PROTOTYPE
argument_list|(
argument|int dotimes
argument_list|,
argument|(void)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|int
name|execute
parameter_list|(
name|t
parameter_list|,
name|pin
parameter_list|,
name|pout
parameter_list|,
name|act
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|int
modifier|*
name|pin
decl_stmt|,
decl|*
name|pout
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|act
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|op
modifier|*
name|t1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pv
index|[
literal|2
index|]
decl_stmt|,
name|rv
decl_stmt|,
name|child
decl_stmt|,
name|a
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|wp
decl_stmt|,
modifier|*
modifier|*
name|wp2
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|struct
name|brkcon
name|bc
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rv
operator|=
literal|0
expr_stmt|;
name|a
operator|=
name|areanum
operator|++
expr_stmt|;
name|wp
operator|=
operator|(
name|wp2
operator|=
name|t
operator|->
name|words
operator|)
operator|!=
name|NULL
condition|?
name|eval
argument_list|(
name|wp2
argument_list|,
name|t
operator|->
name|type
operator|==
name|TCOM
condition|?
name|DOALL
else|:
name|DOALL
operator|&
operator|~
name|DOKEY
argument_list|)
else|:
name|NULL
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|type
condition|)
block|{
case|case
name|TPAREN
case|:
case|case
name|TCOM
case|:
name|rv
operator|=
name|forkexec
argument_list|(
name|t
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
name|act
argument_list|,
name|wp
argument_list|,
operator|&
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
block|{
name|exstat
operator|=
name|rv
expr_stmt|;
name|leave
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TPIPE
case|:
if|if
condition|(
operator|(
name|rv
operator|=
name|openpipe
argument_list|(
name|pv
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
name|pv
index|[
literal|0
index|]
operator|=
name|remap
argument_list|(
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pv
index|[
literal|1
index|]
operator|=
name|remap
argument_list|(
name|pv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execute
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|pin
argument_list|,
name|pv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rv
operator|=
name|execute
argument_list|(
name|t
operator|->
name|right
argument_list|,
name|pv
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
operator|(
name|void
operator|)
name|execute
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rv
operator|=
name|execute
argument_list|(
name|t
operator|->
name|right
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TASYNC
case|:
name|i
operator|=
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|setval
argument_list|(
name|lookup
argument_list|(
literal|"!"
argument_list|)
argument_list|,
name|putn
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pin
operator|!=
name|NULL
condition|)
name|closepipe
argument_list|(
name|pin
argument_list|)
expr_stmt|;
if|if
condition|(
name|talking
condition|)
block|{
name|prs
argument_list|(
name|putn
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
name|setstatus
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|talking
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|talking
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pin
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|execute
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
name|FEXEC
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TOR
case|:
case|case
name|TAND
case|:
name|rv
operator|=
name|execute
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|t
operator|->
name|right
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|rv
operator|==
literal|0
operator|)
operator|==
operator|(
name|t
operator|->
name|type
operator|==
name|TAND
operator|)
condition|)
name|rv
operator|=
name|execute
argument_list|(
name|t1
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TFOR
case|:
if|if
condition|(
name|wp
operator|==
name|NULL
condition|)
block|{
name|wp
operator|=
name|dolv
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|dolc
operator|)
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|wp
operator|++
operator|!=
name|NULL
condition|)
empty_stmt|;
block|}
name|vp
operator|=
name|lookup
argument_list|(
name|t
operator|->
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
name|setjmp
argument_list|(
name|bc
operator|.
name|brkpt
argument_list|)
condition|)
if|if
condition|(
name|isbreak
condition|)
goto|goto
name|broken
goto|;
name|brkset
argument_list|(
operator|&
name|bc
argument_list|)
expr_stmt|;
for|for
control|(
name|t1
operator|=
name|t
operator|->
name|left
init|;
name|i
operator|--
operator|&&
operator|*
name|wp
operator|!=
name|NULL
condition|;
control|)
block|{
name|setval
argument_list|(
name|vp
argument_list|,
operator|*
name|wp
operator|++
argument_list|)
expr_stmt|;
name|rv
operator|=
name|execute
argument_list|(
name|t1
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|brklist
operator|=
name|brklist
operator|->
name|nextlev
expr_stmt|;
break|break;
case|case
name|TWHILE
case|:
case|case
name|TUNTIL
case|:
while|while
condition|(
name|setjmp
argument_list|(
name|bc
operator|.
name|brkpt
argument_list|)
condition|)
if|if
condition|(
name|isbreak
condition|)
goto|goto
name|broken
goto|;
name|brkset
argument_list|(
operator|&
name|bc
argument_list|)
expr_stmt|;
name|t1
operator|=
name|t
operator|->
name|left
expr_stmt|;
while|while
condition|(
operator|(
name|execute
argument_list|(
name|t1
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
operator|==
operator|(
name|t
operator|->
name|type
operator|==
name|TWHILE
operator|)
condition|)
name|rv
operator|=
name|execute
argument_list|(
name|t
operator|->
name|right
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|brklist
operator|=
name|brklist
operator|->
name|nextlev
expr_stmt|;
break|break;
case|case
name|TIF
case|:
case|case
name|TELIF
case|:
if|if
condition|(
name|t
operator|->
name|right
operator|!=
name|NULL
condition|)
block|{
name|rv
operator|=
operator|!
name|execute
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
condition|?
name|execute
argument_list|(
name|t
operator|->
name|right
operator|->
name|left
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
else|:
name|execute
argument_list|(
name|t
operator|->
name|right
operator|->
name|right
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TCASE
case|:
if|if
condition|(
operator|(
name|cp
operator|=
name|evalstr
argument_list|(
name|t
operator|->
name|str
argument_list|,
name|DOSUB
operator||
name|DOTRIM
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|cp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|findcase
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|cp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|rv
operator|=
name|execute
argument_list|(
name|t1
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBRACE
case|:
comment|/* 		if (iopp = t->ioact) 			while (*iopp) 				if (iosetup(*iopp++, pin!=NULL, pout!=NULL)) { 					rv = -1; 					break; 				} */
if|if
condition|(
name|rv
operator|>=
literal|0
operator|&&
operator|(
name|t1
operator|=
name|t
operator|->
name|left
operator|)
condition|)
name|rv
operator|=
name|execute
argument_list|(
name|t1
argument_list|,
name|pin
argument_list|,
name|pout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|broken
label|:
name|t
operator|->
name|words
operator|=
name|wp2
expr_stmt|;
name|isbreak
operator|=
literal|0
expr_stmt|;
name|freehere
argument_list|(
name|areanum
argument_list|)
expr_stmt|;
name|freearea
argument_list|(
name|areanum
argument_list|)
expr_stmt|;
name|areanum
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|talking
operator|&&
name|intr
condition|)
block|{
name|closeall
argument_list|()
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|trapset
operator|)
operator|!=
literal|0
condition|)
block|{
name|trapset
operator|=
literal|0
expr_stmt|;
name|runtrap
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|forkexec
parameter_list|(
name|t
parameter_list|,
name|pin
parameter_list|,
name|pout
parameter_list|,
name|act
parameter_list|,
name|wp
parameter_list|,
name|pforked
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|int
modifier|*
name|pin
decl_stmt|,
decl|*
name|pout
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|act
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pforked
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
argument_list|(
operator|*
name|shcom
argument_list|)
argument_list|()
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|ioword
modifier|*
modifier|*
name|iopp
decl_stmt|;
name|int
name|resetsig
decl_stmt|;
name|char
modifier|*
modifier|*
name|owp
decl_stmt|;
name|owp
operator|=
name|wp
expr_stmt|;
name|resetsig
operator|=
literal|0
expr_stmt|;
operator|*
name|pforked
operator|=
literal|0
expr_stmt|;
name|shcom
operator|=
name|NULL
expr_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* system-detected error */
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TCOM
condition|)
block|{
while|while
condition|(
operator|(
name|cp
operator|=
operator|*
name|wp
operator|++
operator|)
operator|!=
name|NULL
condition|)
empty_stmt|;
name|cp
operator|=
operator|*
name|wp
expr_stmt|;
comment|/* strip all initial assignments */
comment|/* not correct wrt PATH=yyy command  etc */
if|if
condition|(
name|flag
index|[
literal|'x'
index|]
condition|)
name|echo
argument_list|(
name|cp
condition|?
name|wp
else|:
name|owp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|&&
name|t
operator|->
name|ioact
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|cp
operator|=
operator|*
name|owp
operator|++
operator|)
operator|!=
name|NULL
operator|&&
name|assign
argument_list|(
name|cp
argument_list|,
name|COPYV
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
name|setstatus
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|shcom
operator|=
name|inbuilt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|words
operator|=
name|wp
expr_stmt|;
name|f
operator|=
name|act
expr_stmt|;
if|if
condition|(
name|shcom
operator|==
name|NULL
operator|&&
operator|(
name|f
operator|&
name|FEXEC
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|parent
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|pin
operator|!=
name|NULL
condition|)
name|closepipe
argument_list|(
name|pin
argument_list|)
expr_stmt|;
return|return
operator|(
name|pout
operator|==
name|NULL
condition|?
name|setstatus
argument_list|(
name|waitfor
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|talking
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|resetsig
operator|=
literal|1
expr_stmt|;
block|}
name|talking
operator|=
literal|0
expr_stmt|;
name|intr
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pforked
operator|)
operator|++
expr_stmt|;
name|brklist
operator|=
literal|0
expr_stmt|;
name|execflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|owp
operator|!=
name|NULL
condition|)
while|while
condition|(
operator|(
name|cp
operator|=
operator|*
name|owp
operator|++
operator|)
operator|!=
name|NULL
operator|&&
name|assign
argument_list|(
name|cp
argument_list|,
name|COPYV
argument_list|)
condition|)
if|if
condition|(
name|shcom
operator|==
name|NULL
condition|)
name|export
argument_list|(
name|lookup
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPIPE
if|if
condition|(
operator|(
name|pin
operator|!=
name|NULL
operator|||
name|pout
operator|!=
name|NULL
operator|)
operator|&&
name|shcom
operator|!=
name|NULL
operator|&&
name|shcom
operator|!=
name|doexec
condition|)
block|{
name|err
argument_list|(
literal|"piping to/from shell builtins not yet done"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pin
operator|!=
name|NULL
condition|)
block|{
name|dup2
argument_list|(
name|pin
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|closepipe
argument_list|(
name|pin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pout
operator|!=
name|NULL
condition|)
block|{
name|dup2
argument_list|(
name|pout
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|closepipe
argument_list|(
name|pout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iopp
operator|=
name|t
operator|->
name|ioact
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|shcom
operator|!=
name|NULL
operator|&&
name|shcom
operator|!=
name|doexec
condition|)
block|{
name|prs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|": cannot redirect shell command"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|iopp
condition|)
if|if
condition|(
name|iosetup
argument_list|(
operator|*
name|iopp
operator|++
argument_list|,
name|pin
operator|!=
name|NULL
argument_list|,
name|pout
operator|!=
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
if|if
condition|(
name|shcom
condition|)
return|return
operator|(
name|setstatus
argument_list|(
call|(
modifier|*
name|shcom
call|)
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
return|;
comment|/* should use FIOCEXCL */
for|for
control|(
name|i
operator|=
name|FDBASE
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|resetsig
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TPAREN
condition|)
name|exit
argument_list|(
name|execute
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|NOPIPE
argument_list|,
name|NOPIPE
argument_list|,
name|FEXEC
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rexecve
argument_list|(
name|wp
index|[
literal|0
index|]
argument_list|,
name|wp
argument_list|,
name|makenv
argument_list|()
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|wp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|execflg
condition|)
name|trap
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|leave
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * common actions when creating a new child  */
end_comment

begin_function
specifier|static
name|int
name|parent
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"try again"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 0< 1> are ignored as required  * within pipelines.  */
end_comment

begin_function
name|int
name|iosetup
parameter_list|(
name|iop
parameter_list|,
name|pipein
parameter_list|,
name|pipeout
parameter_list|)
specifier|register
name|struct
name|ioword
modifier|*
name|iop
decl_stmt|;
name|int
name|pipein
decl_stmt|,
name|pipeout
decl_stmt|;
block|{
specifier|register
name|u
expr_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|iop
operator|->
name|io_unit
operator|==
name|IODEFAULT
condition|)
comment|/* take default */
name|iop
operator|->
name|io_unit
operator|=
name|iop
operator|->
name|io_flag
operator|&
operator|(
name|IOREAD
operator||
name|IOHERE
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|pipein
operator|&&
name|iop
operator|->
name|io_unit
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pipeout
operator|&&
name|iop
operator|->
name|io_unit
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|msg
operator|=
name|iop
operator|->
name|io_flag
operator|&
operator|(
name|IOREAD
operator||
name|IOHERE
operator|)
condition|?
literal|"open"
else|:
literal|"create"
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|io_flag
operator|&
name|IOHERE
operator|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|iop
operator|->
name|io_name
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|evalstr
argument_list|(
name|cp
argument_list|,
name|DOSUB
operator||
name|DOTRIM
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|iop
operator|->
name|io_flag
operator|&
name|IODUP
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|||
operator|(
operator|!
name|digit
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|prs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|": illegal>& argument"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|iop
operator|->
name|io_flag
operator|=
name|IOCLOSE
expr_stmt|;
name|iop
operator|->
name|io_flag
operator|&=
operator|~
operator|(
name|IOREAD
operator||
name|IOWRITE
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|iop
operator|->
name|io_flag
condition|)
block|{
case|case
name|IOREAD
case|:
name|u
operator|=
name|open
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOHERE
case|:
case|case
name|IOHERE
operator||
name|IOXHERE
case|:
name|u
operator|=
name|herein
argument_list|(
name|iop
operator|->
name|io_name
argument_list|,
name|iop
operator|->
name|io_flag
operator|&
name|IOXHERE
argument_list|)
expr_stmt|;
name|cp
operator|=
literal|"here file"
expr_stmt|;
break|break;
case|case
name|IOWRITE
operator||
name|IOCAT
case|:
if|if
condition|(
operator|(
name|u
operator|=
name|open
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|u
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IOWRITE
case|:
name|u
operator|=
name|creat
argument_list|(
name|cp
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
break|break;
case|case
name|IODUP
case|:
name|u
operator|=
name|dup2
argument_list|(
operator|*
name|cp
operator|-
literal|'0'
argument_list|,
name|iop
operator|->
name|io_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOCLOSE
case|:
name|close
argument_list|(
name|iop
operator|->
name|io_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|u
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": cannot "
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|u
operator|!=
name|iop
operator|->
name|io_unit
condition|)
block|{
name|dup2
argument_list|(
name|u
argument_list|,
name|iop
operator|->
name|io_unit
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|echo
parameter_list|(
name|wp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|wp
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|prs
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|wp
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|prs
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|wp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
modifier|*
name|find1case
parameter_list|(
name|t
parameter_list|,
name|w
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|struct
name|op
modifier|*
name|t1
decl_stmt|;
name|struct
name|op
modifier|*
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|wp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
expr|struct
name|op
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|TLIST
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|find1case
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|w
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|tp
operator|)
return|;
name|t1
operator|=
name|t
operator|->
name|right
expr_stmt|;
comment|/* TPAT */
block|}
else|else
name|t1
operator|=
name|t
expr_stmt|;
for|for
control|(
name|wp
operator|=
name|t1
operator|->
name|words
init|;
operator|*
name|wp
condition|;
control|)
if|if
condition|(
operator|(
name|cp
operator|=
name|evalstr
argument_list|(
operator|*
name|wp
operator|++
argument_list|,
name|DOSUB
argument_list|)
operator|)
operator|&&
name|gmatch
argument_list|(
name|w
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
operator|&
name|t1
operator|->
name|left
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|op
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|op
modifier|*
name|findcase
parameter_list|(
name|t
parameter_list|,
name|w
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|struct
name|op
modifier|*
modifier|*
name|tp
decl_stmt|;
return|return
operator|(
operator|(
name|tp
operator|=
name|find1case
argument_list|(
name|t
argument_list|,
name|w
argument_list|)
operator|)
operator|!=
name|NULL
condition|?
operator|*
name|tp
else|:
operator|(
expr|struct
name|op
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a new loop level (marked for break/continue).  */
end_comment

begin_function
specifier|static
name|void
name|brkset
parameter_list|(
name|bc
parameter_list|)
name|struct
name|brkcon
modifier|*
name|bc
decl_stmt|;
block|{
name|bc
operator|->
name|nextlev
operator|=
name|brklist
expr_stmt|;
name|brklist
operator|=
name|bc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for the last process created.  * Print a message for each process found  * that was killed by a signal.  * Ignore interrupt signals while waiting  * unless `canintr' is true.  */
end_comment

begin_function
name|int
name|waitfor
parameter_list|(
name|lastpid
parameter_list|,
name|canintr
parameter_list|)
specifier|register
name|int
name|lastpid
decl_stmt|;
name|int
name|canintr
decl_stmt|;
block|{
specifier|register
name|int
name|pid
decl_stmt|,
name|rv
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|oheedint
init|=
name|heedint
decl_stmt|;
name|heedint
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|||
name|canintr
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rv
operator|=
name|WAITSIG
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rv
operator|<
name|NSIGNAL
condition|)
block|{
if|if
condition|(
name|signame
index|[
name|rv
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pid
operator|!=
name|lastpid
condition|)
block|{
name|prn
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|prs
argument_list|(
name|signame
index|[
name|rv
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pid
operator|!=
name|lastpid
condition|)
block|{
name|prn
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|prs
argument_list|(
literal|"Signal "
argument_list|)
expr_stmt|;
name|prn
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WAITCORE
argument_list|(
name|s
argument_list|)
condition|)
name|prs
argument_list|(
literal|" - core dumped"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|>=
name|NSIGNAL
operator|||
name|signame
index|[
name|rv
index|]
condition|)
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|rv
operator|=
name|WAITVAL
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pid
operator|!=
name|lastpid
condition|)
do|;
name|heedint
operator|=
name|oheedint
expr_stmt|;
if|if
condition|(
name|intr
condition|)
if|if
condition|(
name|talking
condition|)
block|{
if|if
condition|(
name|canintr
condition|)
name|intr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exstat
operator|==
literal|0
condition|)
name|exstat
operator|=
name|rv
expr_stmt|;
name|onintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|setstatus
parameter_list|(
name|s
parameter_list|)
specifier|register
name|int
name|s
decl_stmt|;
block|{
name|exstat
operator|=
name|s
expr_stmt|;
name|setval
argument_list|(
name|lookup
argument_list|(
literal|"?"
argument_list|)
argument_list|,
name|putn
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PATH-searching interface to execve.  * If getenv("PATH") were kept up-to-date,  * execvp might be used.  */
end_comment

begin_function
name|char
modifier|*
name|rexecve
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|,
name|envp
parameter_list|)
name|char
modifier|*
name|c
decl_stmt|,
decl|*
modifier|*
name|v
decl_stmt|,
modifier|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|int
name|eacces
init|=
literal|0
decl_stmt|,
name|asis
init|=
literal|0
decl_stmt|;
name|sp
operator|=
name|any
argument_list|(
literal|'/'
argument_list|,
name|c
argument_list|)
condition|?
literal|""
else|:
name|path
operator|->
name|value
expr_stmt|;
name|asis
operator|=
operator|*
name|sp
operator|==
literal|'\0'
expr_stmt|;
while|while
condition|(
name|asis
operator|||
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
name|asis
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|e
operator|.
name|linep
expr_stmt|;
for|for
control|(
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|tp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|tp
operator|=
operator|*
name|sp
operator|++
operator|)
operator|==
literal|':'
condition|)
block|{
name|asis
operator|=
operator|*
name|sp
operator|==
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tp
operator|!=
name|e
operator|.
name|linep
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|*
name|tp
operator|++
operator|=
name|c
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|'\0'
condition|;
control|)
empty_stmt|;
name|execve
argument_list|(
name|e
operator|.
name|linep
argument_list|,
name|v
argument_list|,
name|envp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOEXEC
case|:
operator|*
name|v
operator|=
name|e
operator|.
name|linep
expr_stmt|;
name|tp
operator|=
operator|*
operator|--
name|v
expr_stmt|;
operator|*
name|v
operator|=
name|e
operator|.
name|linep
expr_stmt|;
name|execve
argument_list|(
literal|"/bin/sh"
argument_list|,
name|v
argument_list|,
name|envp
argument_list|)
expr_stmt|;
operator|*
name|v
operator|=
name|tp
expr_stmt|;
return|return
operator|(
literal|"no Shell"
operator|)
return|;
case|case
name|ENOMEM
case|:
return|return
operator|(
literal|"program too big"
operator|)
return|;
case|case
name|E2BIG
case|:
return|return
operator|(
literal|"argument list too long"
operator|)
return|;
case|case
name|EACCES
case|:
name|eacces
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|errno
operator|==
name|ENOENT
condition|?
literal|"not found"
else|:
literal|"cannot execute"
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Run the command produced by generator `f'  * applied to stream `arg'.  */
end_comment

begin_decl_stmt
name|int
name|run
argument_list|(
name|argp
argument_list|,
name|f
argument_list|)
decl|struct
name|ioarg
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|op
modifier|*
name|otree
decl_stmt|;
name|struct
name|wdblock
modifier|*
name|swdlist
decl_stmt|;
name|struct
name|wdblock
modifier|*
name|siolist
decl_stmt|;
name|jmp_buf
name|ev
decl_stmt|,
name|rt
decl_stmt|;
name|xint
modifier|*
name|ofail
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|areanum
operator|++
expr_stmt|;
name|swdlist
operator|=
name|wdlist
expr_stmt|;
name|siolist
operator|=
name|iolist
expr_stmt|;
name|otree
operator|=
name|outtree
expr_stmt|;
name|ofail
operator|=
name|failpt
expr_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|newenv
argument_list|(
name|setjmp
argument_list|(
name|errpt
operator|=
name|ev
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wdlist
operator|=
literal|0
expr_stmt|;
name|iolist
operator|=
literal|0
expr_stmt|;
name|pushio
argument_list|(
name|argp
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|e
operator|.
name|iobase
operator|=
name|e
operator|.
name|iop
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|failpt
operator|=
name|rt
argument_list|)
operator|==
literal|0
operator|&&
name|yyparse
argument_list|()
operator|==
literal|0
condition|)
name|rv
operator|=
name|execute
argument_list|(
name|outtree
argument_list|,
name|NOPIPE
argument_list|,
name|NOPIPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quitenv
argument_list|()
expr_stmt|;
block|}
name|wdlist
operator|=
name|swdlist
expr_stmt|;
name|iolist
operator|=
name|siolist
expr_stmt|;
name|failpt
operator|=
name|ofail
expr_stmt|;
name|outtree
operator|=
name|otree
expr_stmt|;
name|freearea
argument_list|(
name|areanum
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_comment
comment|/* -------- do.c -------- */
end_comment

begin_comment
comment|/* #include "sh.h" */
end_comment

begin_comment
comment|/*  * built-in commands: doX  */
end_comment

begin_function
name|int
name|dolabel
parameter_list|()
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dochdir
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|er
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|cp
operator|=
name|homedir
operator|->
name|value
operator|)
operator|==
name|NULL
condition|)
name|er
operator|=
literal|": no home directory"
expr_stmt|;
elseif|else
if|if
condition|(
name|chdir
argument_list|(
name|cp
argument_list|)
operator|<
literal|0
condition|)
name|er
operator|=
literal|": bad directory"
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|prs
argument_list|(
name|cp
operator|!=
name|NULL
condition|?
name|cp
else|:
literal|"cd"
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|er
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doshift
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|n
expr_stmt|;
name|n
operator|=
name|t
operator|->
name|words
index|[
literal|1
index|]
condition|?
name|getn
argument_list|(
name|t
operator|->
name|words
index|[
literal|1
index|]
argument_list|)
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|dolc
operator|<
name|n
condition|)
block|{
name|err
argument_list|(
literal|"nothing to shift"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dolv
index|[
name|n
index|]
operator|=
name|dolv
index|[
literal|0
index|]
expr_stmt|;
name|dolv
operator|+=
name|n
expr_stmt|;
name|dolc
operator|-=
name|n
expr_stmt|;
name|setval
argument_list|(
name|lookup
argument_list|(
literal|"#"
argument_list|)
argument_list|,
name|putn
argument_list|(
name|dolc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * execute login and newgrp directly  */
end_comment

begin_function
name|int
name|dologin
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|talking
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|rexecve
argument_list|(
name|t
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|words
argument_list|,
name|makenv
argument_list|()
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|t
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doumask
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|3
operator|*
literal|4
init|;
operator|(
name|n
operator|-=
literal|3
operator|)
operator|>=
literal|0
condition|;
control|)
name|putc
argument_list|(
literal|'0'
operator|+
operator|(
operator|(
name|i
operator|>>
name|n
operator|)
operator|&
literal|07
operator|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|;
name|cp
operator|++
control|)
name|n
operator|=
name|n
operator|*
literal|8
operator|+
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
expr_stmt|;
name|umask
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doexec
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|jmp_buf
name|ex
decl_stmt|;
name|xint
modifier|*
name|ofail
decl_stmt|;
name|t
operator|->
name|ioact
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|t
operator|->
name|words
index|[
name|i
index|]
operator|=
name|t
operator|->
name|words
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|execflg
operator|=
literal|1
expr_stmt|;
name|ofail
operator|=
name|failpt
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|failpt
operator|=
name|ex
argument_list|)
operator|==
literal|0
condition|)
name|execute
argument_list|(
name|t
argument_list|,
name|NOPIPE
argument_list|,
name|NOPIPE
argument_list|,
name|FEXEC
argument_list|)
expr_stmt|;
name|failpt
operator|=
name|ofail
expr_stmt|;
name|execflg
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dodot
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|=
name|any
argument_list|(
literal|'/'
argument_list|,
name|cp
argument_list|)
condition|?
literal|":"
else|:
name|path
operator|->
name|value
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
name|tp
operator|=
name|e
operator|.
name|linep
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
operator|(
operator|*
name|tp
operator|=
operator|*
name|sp
operator|++
operator|)
operator|!=
literal|':'
condition|)
name|tp
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|e
operator|.
name|linep
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|*
name|tp
operator|++
operator|=
name|cp
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|'\0'
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|e
operator|.
name|linep
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|exstat
operator|=
literal|0
expr_stmt|;
name|next
argument_list|(
name|remap
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|exstat
operator|)
return|;
block|}
block|}
name|prs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|": not found"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dowait
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|getn
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|setstatus
argument_list|(
name|waitfor
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doread
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|wp
decl_stmt|;
specifier|register
name|nb
expr_stmt|;
specifier|register
name|int
name|nl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"Usage: read name ..."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|wp
operator|=
name|t
operator|->
name|words
operator|+
literal|1
init|;
operator|*
name|wp
condition|;
name|wp
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|e
operator|.
name|linep
init|;
operator|!
name|nl
operator|&&
name|cp
operator|<
name|elinep
operator|-
literal|1
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|(
name|nb
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
name|nl
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
operator|)
operator|||
operator|(
name|wp
index|[
literal|1
index|]
operator|&&
name|any
argument_list|(
operator|*
name|cp
argument_list|,
name|ifs
operator|->
name|value
argument_list|)
operator|)
condition|)
break|break;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nb
operator|<=
literal|0
condition|)
break|break;
name|setval
argument_list|(
name|lookup
argument_list|(
operator|*
name|wp
argument_list|)
argument_list|,
name|e
operator|.
name|linep
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nb
operator|<=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doeval
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
return|return
operator|(
name|RUN
argument_list|(
name|awordlist
argument_list|,
name|t
operator|->
name|words
operator|+
literal|1
argument_list|,
name|wdchar
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dotrap
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|int
name|resetsig
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|_NSIG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|trap
index|[
name|i
index|]
condition|)
block|{
name|prn
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|trap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|resetsig
operator|=
name|digit
argument_list|(
operator|*
name|t
operator|->
name|words
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|resetsig
condition|?
literal|1
else|:
literal|2
init|;
name|t
operator|->
name|words
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|n
operator|=
name|getsig
argument_list|(
name|t
operator|->
name|words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|trap
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|trap
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|resetsig
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|trap
index|[
name|n
index|]
operator|=
name|strsave
argument_list|(
name|t
operator|->
name|words
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setsig
argument_list|(
name|n
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
else|else
name|setsig
argument_list|(
name|n
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|talking
condition|)
if|if
condition|(
name|n
operator|==
name|SIGINT
condition|)
name|setsig
argument_list|(
name|n
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
else|else
name|setsig
argument_list|(
name|n
argument_list|,
name|n
operator|==
name|SIGQUIT
condition|?
name|SIG_IGN
else|:
name|SIG_DFL
argument_list|)
expr_stmt|;
else|else
name|setsig
argument_list|(
name|n
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|getsig
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|getn
argument_list|(
name|s
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|n
operator|>
name|_NSIG
condition|)
block|{
name|err
argument_list|(
literal|"trap: bad signal number"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|void
name|setsig
argument_list|(
name|n
argument_list|,
name|f
argument_list|)
decl|register
name|n
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|_PROTOTYPE
argument_list|(
name|void
argument_list|(
operator|*
name|f
argument_list|)
argument_list|,
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|signal
argument_list|(
name|n
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
operator|||
name|ourtrap
index|[
name|n
index|]
condition|)
block|{
name|ourtrap
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|n
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|getn
parameter_list|(
name|as
parameter_list|)
name|char
modifier|*
name|as
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|n
operator|,
name|m
expr_stmt|;
name|s
operator|=
name|as
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|m
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|digit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
name|n
operator|=
operator|(
name|n
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|prs
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|": bad number"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|*
name|m
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dobreak
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
return|return
operator|(
name|brkcontin
argument_list|(
name|t
operator|->
name|words
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|docontinue
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
return|return
operator|(
name|brkcontin
argument_list|(
name|t
operator|->
name|words
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|brkcontin
parameter_list|(
name|cp
parameter_list|,
name|val
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|struct
name|brkcon
modifier|*
name|bc
decl_stmt|;
specifier|register
name|nl
expr_stmt|;
name|nl
operator|=
name|cp
operator|==
name|NULL
condition|?
literal|1
else|:
name|getn
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|<=
literal|0
condition|)
name|nl
operator|=
literal|999
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|bc
operator|=
name|brklist
operator|)
operator|==
name|NULL
condition|)
break|break;
name|brklist
operator|=
name|bc
operator|->
name|nextlev
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nl
condition|)
do|;
if|if
condition|(
name|nl
condition|)
block|{
name|err
argument_list|(
literal|"bad break/continue level"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isbreak
operator|=
name|val
expr_stmt|;
name|longjmp
argument_list|(
name|bc
operator|->
name|brkpt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|doexit
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|execflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|)
operator|!=
name|NULL
condition|)
name|setstatus
argument_list|(
name|getn
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|leave
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|doexport
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
name|rdexp
argument_list|(
name|t
operator|->
name|words
operator|+
literal|1
argument_list|,
name|export
argument_list|,
name|EXPORT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doreadonly
parameter_list|(
name|t
parameter_list|)
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
name|rdexp
argument_list|(
name|t
operator|->
name|words
operator|+
literal|1
argument_list|,
name|ronly
argument_list|,
name|RONLY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|rdexp
argument_list|(
name|wp
argument_list|,
name|f
argument_list|,
name|key
argument_list|)
decl|register
name|char
modifier|*
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|wp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
operator|*
name|wp
operator|!=
name|NULL
condition|;
name|wp
operator|++
control|)
if|if
condition|(
name|checkname
argument_list|(
operator|*
name|wp
argument_list|)
condition|)
call|(
modifier|*
name|f
call|)
argument_list|(
name|lookup
argument_list|(
operator|*
name|wp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|badid
argument_list|(
operator|*
name|wp
argument_list|)
expr_stmt|;
block|}
else|else
name|putvlist
argument_list|(
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|badid
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|prs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|": bad identifier"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|doset
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|op
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|t
operator|->
name|words
index|[
literal|1
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|vp
operator|=
name|vlist
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
name|varput
argument_list|(
name|vp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
comment|/* bad: t->words++; */
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|t
operator|->
name|words
index|[
name|n
index|]
operator|=
name|t
operator|->
name|words
index|[
name|n
operator|+
literal|1
index|]
operator|)
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|0
condition|)
name|flag
index|[
literal|'x'
index|]
operator|=
name|flag
index|[
literal|'v'
index|]
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|talking
condition|)
name|flag
index|[
literal|'e'
index|]
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|cp
operator|>=
literal|'a'
operator|&&
operator|*
name|cp
operator|<=
literal|'z'
condition|)
name|flag
index|[
operator|*
name|cp
index|]
operator|++
expr_stmt|;
break|break;
block|}
name|setdash
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|words
index|[
literal|1
index|]
condition|)
block|{
name|t
operator|->
name|words
index|[
literal|0
index|]
operator|=
name|dolv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|t
operator|->
name|words
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
name|setarea
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|words
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dolc
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|dolv
operator|=
name|t
operator|->
name|words
expr_stmt|;
name|setval
argument_list|(
name|lookup
argument_list|(
literal|"#"
argument_list|)
argument_list|,
name|putn
argument_list|(
name|dolc
argument_list|)
argument_list|)
expr_stmt|;
name|setarea
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|dolv
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|varput
parameter_list|(
name|s
parameter_list|,
name|out
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|out
decl_stmt|;
block|{
if|if
condition|(
name|letnum
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|write
argument_list|(
name|out
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SECS
value|60L
end_define

begin_define
define|#
directive|define
name|MINS
value|3600L
end_define

begin_function
name|int
name|dotimes
parameter_list|()
block|{
name|struct
name|tms
name|tbuf
decl_stmt|;
name|times
argument_list|(
operator|&
name|tbuf
argument_list|)
expr_stmt|;
name|prn
argument_list|(
call|(
name|int
call|)
argument_list|(
name|tbuf
operator|.
name|tms_cutime
operator|/
name|MINS
argument_list|)
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"m"
argument_list|)
expr_stmt|;
name|prn
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|tbuf
operator|.
name|tms_cutime
operator|%
name|MINS
operator|)
operator|/
name|SECS
argument_list|)
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"s "
argument_list|)
expr_stmt|;
name|prn
argument_list|(
call|(
name|int
call|)
argument_list|(
name|tbuf
operator|.
name|tms_cstime
operator|/
name|MINS
argument_list|)
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"m"
argument_list|)
expr_stmt|;
name|prn
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|tbuf
operator|.
name|tms_cstime
operator|%
name|MINS
operator|)
operator|/
name|SECS
argument_list|)
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"s\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|builtin
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|builtin
name|builtin
index|[]
init|=
block|{
literal|":"
block|,
name|dolabel
block|,
literal|"cd"
block|,
name|dochdir
block|,
literal|"shift"
block|,
name|doshift
block|,
literal|"exec"
block|,
name|doexec
block|,
literal|"wait"
block|,
name|dowait
block|,
literal|"read"
block|,
name|doread
block|,
literal|"eval"
block|,
name|doeval
block|,
literal|"trap"
block|,
name|dotrap
block|,
literal|"break"
block|,
name|dobreak
block|,
literal|"continue"
block|,
name|docontinue
block|,
literal|"exit"
block|,
name|doexit
block|,
literal|"export"
block|,
name|doexport
block|,
literal|"readonly"
block|,
name|doreadonly
block|,
literal|"set"
block|,
name|doset
block|,
literal|"."
block|,
name|dodot
block|,
literal|"umask"
block|,
name|doumask
block|,
literal|"login"
block|,
name|dologin
block|,
literal|"newgrp"
block|,
name|dologin
block|,
literal|"times"
block|,
name|dotimes
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
argument_list|(
operator|*
name|inbuilt
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|()
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|builtin
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|builtin
init|;
name|bp
operator|->
name|command
operator|!=
name|NULL
condition|;
name|bp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|command
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|bp
operator|->
name|fn
operator|)
return|;
return|return
operator|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
operator|)
return|;
block|}
end_block

end_unit

