begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: install.c,v 1.71.2.19 1995/10/05 09:11:02 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function_decl
specifier|static
name|Boolean
name|copy_self
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|root_extract
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|Boolean
name|checkLabels
parameter_list|(
name|Chunk
modifier|*
modifier|*
name|rdev
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|,
modifier|*
name|usrdev
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|rdev
operator|=
name|rootdev
operator|=
name|swapdev
operator|=
name|usrdev
operator|=
name|NULL
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
block|{
if|if
condition|(
name|rootdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one root device set?!\nUsing the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rootdev
operator|=
name|c2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/usr"
argument_list|)
condition|)
block|{
if|if
condition|(
name|usrdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /usr filesystem.\nUsing the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|usrdev
operator|=
name|c2
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|swapdev
operator|=
name|c2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|rootdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n in the label editor."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|rootdev
operator|->
name|name
index|[
name|strlen
argument_list|(
name|rootdev
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'a'
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Invalid placement of root partition.  For now, we only support\nmounting root partitions on \"a\" partitions due to limitations\nin the FreeBSD boot code.  Please correct this and\ntry again."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|rdev
operator|=
name|rootdev
expr_stmt|;
if|if
condition|(
operator|!
name|swapdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No swap devices found - you must create at least one\nswap partition."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|usrdev
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  No /usr filesystem found.  This is not technically\nan error if your root filesystem is big enough (or you later\nintend to get your /usr filesystem over NFS), but it may otherwise\ncause you trouble and is not recommended procedure!"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to partition your disk before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If we refuse to proceed, bail. */
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\n"
literal|"If you're running this on an existing system, we STRONGLY\n"
literal|"encourage you to make proper backups before proceeding.\n"
literal|"We take no responsibility for lost disk contents!"
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|(
name|void
operator|)
name|diskPartitionWrite
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|installFilesystems
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't make filesystems properly.  Aborting."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|copy_self
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the boot floppy onto the root file system.\nAborting."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RUNNING_ON_ROOT
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
comment|/* stick a helpful shell over on the 4th VTY */
if|if
condition|(
name|OnVTY
operator|&&
operator|!
name|fork
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
specifier|extern
name|int
name|login_tty
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|msgDebug
argument_list|(
literal|"Starting an emergency holographic shell over on the 4th screen\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ttyv3"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Can't set controlling terminal"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Warning: This shell is chroot()'d to /mnt\n"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|installFixit
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|ufs_args
name|args
decl_stmt|;
name|pid_t
name|child
decl_stmt|;
name|int
name|waitstatus
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|fspec
operator|=
literal|"/dev/fd0"
expr_stmt|;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
literal|"/mnt2"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please insert a writable fixit floppy and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_UFS
argument_list|,
literal|"/mnt2"
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the fixit floppy - do you want to try again?"
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
name|dialog_update
argument_list|()
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|DialogActive
operator|=
name|FALSE
expr_stmt|;
comment|/* Try to leach a big /tmp off the fixit floppy */
if|if
condition|(
operator|!
name|file_executable
argument_list|(
literal|"/tmp"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/tmp"
argument_list|,
literal|"/tmp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/var"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/tmp"
argument_list|,
literal|"/var/tmp"
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/mnt2/tmp/vi.recover"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Link the spwd.db file */
name|Mkdir
argument_list|(
literal|"/etc"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/etc/spwd.db"
argument_list|,
literal|"/etc/spwd.db"
argument_list|)
expr_stmt|;
name|create_termcap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|waitstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
literal|"/bin:/sbin:/usr/bin:/usr/sbin:/stand:/mnt2/stand"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|DialogActive
operator|=
name|TRUE
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|dialog_update
argument_list|()
expr_stmt|;
name|unmount
argument_list|(
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the fixit floppy and press return"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|installUpgrade
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
comment|/* Storyboard:        1. Verify that user has mounted/newfs flagged all desired directories        for upgrading.  Should have selected a / at the very least, with        warning for no /usr.  If not, throw into partition/disklabel editors        with appropriate popup info in-between.         2. If BIN distribution selected, backup /etc to some location -        prompt user for this location.         3. Extract distributions.  Warn if BIN distribution not among those           selected.         4. If BIN extracted, do fixups - read in old sysconfig and try to        intelligently merge the old values into the new sysconfig (only replace        something if set in old and still defaulted or disabled in new).         Some fixups might be:  copy these files back from old:  passwd files, group file, fstab, exports, hosts,        make.conf, host.conf, ???         Spawn a shell and invite user to look around before exiting.        */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|installExpress
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|msgConfirm
argument_list|(
literal|"In the next menu, you will need to set up a DOS-style\n"
literal|"(\"fdisk\") partitioning scheme for your hard disk.  If you\n"
literal|"don't want to do anything special, just type `A' to use the\n"
literal|"whole disk and then `Q' to quit.  If you wish to share\n"
literal|"a disk with multiple operating systems, do NOT use the\n"
literal|"`A' command."
argument_list|)
expr_stmt|;
name|diskPartitionEditor
argument_list|(
literal|"express"
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Next, you need to lay out BSD partitions inside of the\n"
literal|"fdisk partition just created.  If you don't want to\n"
literal|"do anything special, just type `A' to use the default\n"
literal|"partitioning scheme and then `Q' to quit."
argument_list|)
expr_stmt|;
name|diskLabelEditor
argument_list|(
literal|"express"
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Now it is time to select an installation subset.  There\n"
literal|"are many different configurations, ranging from minimal\n"
literal|"installation sets to full X developer oriented configs.\n"
literal|"You can also select a custom software set if none of the\n"
literal|"default configurations are suitable."
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuInstallType
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dists
operator|||
operator|!
name|msgYesNo
argument_list|(
literal|"No distributions selected.  Are you sure you wish to continue?"
argument_list|)
condition|)
break|break;
block|}
name|msgConfirm
argument_list|(
literal|"Finally, you must specify an installation medium."
argument_list|)
expr_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMedia
argument_list|)
expr_stmt|;
name|installCommit
argument_list|(
literal|"express"
argument_list|)
expr_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuConfigure
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * What happens when we select "Commit" in the custom installation menu.  *  * This is broken into multiple stages so that the user can do a full installation but come back here  * again to load more distributions, perhaps from a different media type.  This would allow, for  * example, the user to load the majority of the system from CDROM and then use ftp to load just the  * DES dist.  */
end_comment

begin_function
name|int
name|installCommit
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RunningAsInit
condition|)
block|{
if|if
condition|(
operator|!
name|installInitial
argument_list|()
condition|)
return|return
literal|0
return|;
name|configFstab
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|RunningAsInit
operator|&&
operator|!
name|root_extract
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Failed to load the ROOT distribution.  Please correct\nthis problem and try again."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|distExtractAll
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|installFixup
argument_list|()
condition|)
return|return
literal|0
return|;
name|dialog_clear
argument_list|()
expr_stmt|;
comment|/* We get a NULL value for str if run from installExpress(), in which case we don't want to print the following */
if|if
condition|(
name|str
condition|)
block|{
if|if
condition|(
name|Dists
condition|)
name|msgConfirm
argument_list|(
literal|"Installation completed with some errors.  You may wish\nto scroll through the debugging messages on ALT-F2 with the scroll-lock\nfeature.  Press [ENTER] to return to the installation menu."
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"Installation completed successfully, now  press [ENTER] to return\nto the main menu. If you have any network devices you have not yet\nconfigured, see the Interface configuration item on the\nConfiguration menu."
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|Boolean
name|installFixup
parameter_list|(
name|void
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX At some point maybe we want to make the selection of kernel configurable here XXX */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/kernel"
argument_list|)
operator|&&
name|file_readable
argument_list|(
literal|"/kernel.GENERIC"
argument_list|)
condition|)
block|{
if|if
condition|(
name|vsystem
argument_list|(
literal|"ln -f /kernel.GENERIC /kernel"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to link /kernel into place!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Resurrect /dev after bin distribution screws it up */
if|if
condition|(
name|RunningAsInit
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Remaking all devices.. Please wait!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV all"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"MAKEDEV returned non-zero status"
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Resurrecting /dev entries for slices.."
argument_list|)
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devs
condition|)
name|msgFatal
argument_list|(
literal|"Couldn't get a disk device list!"
argument_list|)
expr_stmt|;
comment|/* Resurrect the slices that the former clobbered */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Disk
modifier|*
name|disk
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Making slice entries for %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV %sh"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make slice entries for %s!"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
block|}
comment|/* XXX Do all the last ugly work-arounds here which we'll try and excise someday right?? XXX */
comment|/* BOGON #1:  XFree86 extracting /usr/X11R6 with root-only perms */
if|if
condition|(
name|file_readable
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
name|chmod
argument_list|(
literal|"/usr/X11R6"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
comment|/* BOGON #2: We leave /etc in a bad state */
name|chmod
argument_list|(
literal|"/etc"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
end_comment

begin_function
name|Boolean
name|installFilesystems
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|char
name|dname
index|[
literal|40
index|]
decl_stmt|;
name|PartInfo
modifier|*
name|p
decl_stmt|;
name|Boolean
name|RootReadOnly
decl_stmt|;
if|if
condition|(
operator|!
name|checkLabels
argument_list|(
operator|&
name|rootdev
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|(
name|PartInfo
operator|*
operator|)
name|rootdev
operator|->
name|private
expr_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
comment|/* First, create and mount the root device */
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|,
name|p
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|newfs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/r%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"%s %s"
argument_list|,
name|p
operator|->
name|newfs_cmd
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem!  Command returned status %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|RootReadOnly
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|RootReadOnly
operator|=
name|TRUE
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Warning:  You have selected a Read-Only root device\nand may be unable to find the appropriate device entries on it\nif it is from an older pre-slice version of FreeBSD."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/r%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Checking integrity of existing %s filesystem"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"fsck -y %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: fsck returned status off %d - this partition may be\nunsafe to use."
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system!  Giving up."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make the proper device mount points in /mnt/dev */
if|if
condition|(
operator|!
operator|(
name|RootReadOnly
operator|&&
name|disk
operator|==
name|rootdev
operator|->
name|disk
operator|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|newfs
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"%s /mnt/dev/r%s"
argument_list|,
name|tmp
operator|->
name|newfs_cmd
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"fsck -y /mnt/dev/r%s"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|char
name|fname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"/mnt/dev/%s"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|swapon
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|msgNotify
argument_list|(
literal|"Added %s as a swap device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"Unable to add %s as a swap device: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|fat
operator|&&
name|c1
operator|->
name|private
operator|&&
operator|!
name|RootReadOnly
condition|)
block|{
name|char
name|name
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"/mnt%s"
argument_list|,
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private
operator|)
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Copy the boot floppy's dev files */
if|if
condition|(
name|vsystem
argument_list|(
literal|"find -x /dev | cpio -pdmv /mnt"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the /dev files!"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the boot floppy contents into /stand */
end_comment

begin_function
specifier|static
name|Boolean
name|copy_self
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Copying the boot floppy to /stand on root filesystem"
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"find -x /stand | cpio -pdmv /mnt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Copy returned error status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Copy the /etc files into their rightful place */
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /mnt/stand; find etc | cpio -pdmv /mnt"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't copy up the /etc files!"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function_decl
specifier|static
name|Boolean
name|loop_on_root_floppy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|Boolean
name|root_extract
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
specifier|static
name|Boolean
name|alreadyExtracted
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|alreadyExtracted
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mediaDevice
condition|)
block|{
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Attempting to extract root image from %s device\n"
argument_list|,
name|mediaDevice
operator|->
name|description
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mediaDevice
operator|->
name|type
condition|)
block|{
case|case
name|DEVICE_TYPE_FLOPPY
case|:
name|alreadyExtracted
operator|=
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
call|(
modifier|*
name|mediaDevice
operator|->
name|init
call|)
argument_list|(
name|mediaDevice
argument_list|)
condition|)
break|break;
name|fd
operator|=
call|(
modifier|*
name|mediaDevice
operator|->
name|get
call|)
argument_list|(
name|mediaDevice
argument_list|,
literal|"floppies/root.flp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't get root image from %s!\nWill try to get it from floppy."
argument_list|,
name|mediaDevice
operator|->
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|mediaDevice
operator|->
name|shutdown
call|)
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
name|alreadyExtracted
operator|=
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|msgNotify
argument_list|(
literal|"Loading root image from:\n%s"
argument_list|,
name|mediaDevice
operator|->
name|name
argument_list|)
expr_stmt|;
name|alreadyExtracted
operator|=
name|mediaExtractDist
argument_list|(
literal|"/"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
call|(
modifier|*
name|mediaDevice
operator|->
name|close
call|)
argument_list|(
name|mediaDevice
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
name|alreadyExtracted
operator|=
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
return|return
name|alreadyExtracted
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|loop_on_root_floppy
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|status
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fd
operator|=
name|getRootFloppy
argument_list|()
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Extracting root floppy.."
argument_list|)
expr_stmt|;
name|status
operator|=
name|mediaExtractDist
argument_list|(
literal|"/"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|caps
index|[]
init|=
block|{
name|termcap_vt100
block|,
name|termcap_cons25
block|,
name|termcap_cons25_m
block|,
name|termcap_cons25r
block|,
name|termcap_cons25r_m
block|,
name|termcap_cons25l1
block|,
name|termcap_cons25l1_m
block|,
name|NULL
block|,     }
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/usr/share/misc/termcap"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/usr/share/misc"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
literal|"/usr/share/misc/termcap"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to initialize termcap file. Some screen-oriented\n"
literal|"utilities may not work."
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|caps
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
operator|(
name|cp
operator|++
operator|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Specify which release to load from FTP or CD */
end_comment

begin_function
name|int
name|installSelectRelease
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|msgGetInput
argument_list|(
name|variable_get
argument_list|(
name|RELNAME
argument_list|)
argument_list|,
literal|"Please specify the release you wish to load"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|variable_set2
argument_list|(
name|RELNAME
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

