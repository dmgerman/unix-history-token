begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: install.c,v 1.71.2.41 1995/10/20 07:02:36 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_define
define|#
directive|define
name|MSDOSFS
end_define

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_undef
undef|#
directive|undef
name|MSDOSFS
end_undef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_function_decl
specifier|static
name|Boolean
name|copy_self
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|root_extract
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TERMCAP_FILE
value|"/usr/share/misc/termcap"
end_define

begin_function
specifier|static
name|Boolean
name|checkLabels
parameter_list|(
name|Chunk
modifier|*
modifier|*
name|rdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|sdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|udev
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Boolean
name|status
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|,
modifier|*
name|usrdev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|status
operator|=
name|TRUE
expr_stmt|;
operator|*
name|rdev
operator|=
operator|*
name|sdev
operator|=
operator|*
name|udev
operator|=
name|rootdev
operator|=
name|swapdev
operator|=
name|usrdev
operator|=
name|NULL
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
block|{
if|if
condition|(
name|rootdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one root device set?!\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rootdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found rootdev at %s!\n"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/usr"
argument_list|)
condition|)
block|{
if|if
condition|(
name|usrdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /usr filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|usrdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found usrdev at %s!\n"
argument_list|,
name|usrdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|swapdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found swapdev at %s!\n"
argument_list|,
name|swapdev
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
operator|*
name|rdev
operator|=
name|rootdev
expr_stmt|;
if|if
condition|(
operator|!
name|rootdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n"
literal|"in the label editor."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
operator|*
name|sdev
operator|=
name|swapdev
expr_stmt|;
if|if
condition|(
operator|!
name|swapdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No swap devices found - you must create at least one\n"
literal|"swap partition."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
operator|*
name|udev
operator|=
name|usrdev
expr_stmt|;
if|if
condition|(
operator|!
name|usrdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  No /usr filesystem found.  This is not technically\n"
literal|"an error if your root filesystem is big enough (or you later\n"
literal|"intend to mount your /usr filesystem over NFS), but it may otherwise\n"
literal|"cause you trouble if you're not exactly sure what you are doing!"
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If it's labelled, assume it's also partitioned */
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
name|variable_set2
argument_list|(
name|DISK_PARTITIONED
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
comment|/* If we refuse to proceed, bail. */
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\n"
literal|"If you're running this on a disk with data you wish to save\n"
literal|"then WE STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before\n"
literal|"proceeding!\n\n"
literal|"We can take no responsibility for lost disk contents!"
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|diskLabelCommit
argument_list|(
name|NULL
argument_list|)
operator|!=
name|RET_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't make filesystems properly.  Aborting."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|copy_self
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the boot floppy onto the root file system.\n"
literal|"Aborting."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to chroot to /mnt - this is bad!"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RUNNING_ON_ROOT
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
comment|/* stick a helpful shell over on the 4th VTY */
if|if
condition|(
name|OnVTY
condition|)
block|{
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|termios
name|foo
decl_stmt|;
specifier|extern
name|int
name|login_tty
argument_list|(
name|int
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|DebugFD
operator|=
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ttyv3"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"Doctor: I can't set the controlling terminal.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|foo
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|foo
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|'\010'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|foo
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"Doctor: I'm unable to set the erase character.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|msgDebug
argument_list|(
literal|"Doctor: I'm unable to get the terminal attributes!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: This shell is chroot()'d to /mnt\n"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Was unable to execute sh for Holographic shell!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|msgNotify
argument_list|(
literal|"Starting an emergency holographic shell on VTY4"
argument_list|)
expr_stmt|;
block|}
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|installFixit
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|ufs_args
name|args
decl_stmt|;
name|pid_t
name|child
decl_stmt|;
name|int
name|waitstatus
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|fspec
operator|=
literal|"/dev/fd0"
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/mnt2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please insert a writable fixit floppy and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_UFS
argument_list|,
literal|"/mnt2"
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the fixit floppy - do you want to try again?"
argument_list|)
condition|)
return|return
name|RET_FAIL
return|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
name|dialog_update
argument_list|()
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|DialogActive
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|directoryExists
argument_list|(
literal|"/tmp"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/tmp"
argument_list|,
literal|"/tmp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|directoryExists
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
condition|)
if|if
condition|(
name|Mkdir
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|,
name|NULL
argument_list|)
operator|!=
name|RET_SUCCESS
condition|)
name|msgConfirm
argument_list|(
literal|"Warning:  Was unable to create a /var/tmp/vi.recover directory.\n"
literal|"vi will kvetch and moan about it as a result but should still\n"
literal|"be essentially usable."
argument_list|)
expr_stmt|;
comment|/* Link the spwd.db file */
if|if
condition|(
name|Mkdir
argument_list|(
literal|"/etc"
argument_list|,
name|NULL
argument_list|)
operator|!=
name|RET_SUCCESS
condition|)
name|msgConfirm
argument_list|(
literal|"Unable to create an /etc directory!  Things are weird on this floppy.."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symlink
argument_list|(
literal|"/mnt2/etc/spwd.db"
argument_list|,
literal|"/etc/spwd.db"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgConfirm
argument_list|(
literal|"Couldn't symlink the /etc/spwd.db file!  I'm not sure I like this.."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
name|create_termcap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|struct
name|termios
name|foo
decl_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|foo
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|foo
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|'\010'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|foo
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to set erase character.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to get terminal attributes!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"When you're finished with this shell, please type exit.\n"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
literal|"/bin:/sbin:/usr/bin:/usr/sbin:/stand:/mnt2/stand"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"fixit shell: Failed to execute shell!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|waitstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DialogActive
operator|=
name|TRUE
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|dialog_update
argument_list|()
expr_stmt|;
name|unmount
argument_list|(
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the fixit floppy now."
argument_list|)
expr_stmt|;
return|return
name|RET_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installExpress
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|msgConfirm
argument_list|(
literal|"In the next menu, you will need to set up a DOS-style (\"fdisk\") partitioning\n"
literal|"scheme for your hard disk.  If you simply wish to devote all disk space\n"
literal|"to FreeBSD (overwritting anything else that might be on the disk(s) selected)\n"
literal|"then use the (A)ll command to select the default partitioning scheme followed\n"
literal|"by a (Q)uit.  If you wish to allocate only free space to FreeBSD, move to a\n"
literal|"partition marked \"unused\" and use the (C)reate command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskPartitionEditor
argument_list|(
literal|"express"
argument_list|)
operator|==
name|RET_FAIL
condition|)
return|return
name|RET_FAIL
return|;
name|msgConfirm
argument_list|(
literal|"Next, you need to create BSD partitions inside of the fdisk partition(s)\n"
literal|"just created.  If you have a reasonable amount of disk space (200MB or more)\n"
literal|"and don't have any special requirements, simply use the (A)uto command to\n"
literal|"allocate space automatically.  If you have more specific needs or just don't\n"
literal|"care for the layout chosen by (A)uto, press F1 for more information on\n"
literal|"manual layout."
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskLabelEditor
argument_list|(
literal|"express"
argument_list|)
operator|==
name|RET_FAIL
condition|)
return|return
name|RET_FAIL
return|;
name|msgConfirm
argument_list|(
literal|"Now it is time to select an installation subset.  There are a number of canned\n"
literal|"distributions, ranging from minimal installation sets to full X developer\n"
literal|"oriented configurations.  You can also select a custom software set if none\n"
literal|"of the provided configurations are suitable."
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuDistributions
argument_list|)
condition|)
return|return
name|RET_FAIL
return|;
if|if
condition|(
name|Dists
operator|||
operator|!
name|msgYesNo
argument_list|(
literal|"No distributions selected.  Are you sure you wish to continue?"
argument_list|)
condition|)
break|break;
block|}
name|msgConfirm
argument_list|(
literal|"Finally, you must specify an installation medium."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMedia
argument_list|)
condition|)
return|return
name|RET_FAIL
return|;
if|if
condition|(
name|installCommit
argument_list|(
literal|"express"
argument_list|)
operator|==
name|RET_FAIL
condition|)
return|return
name|RET_FAIL
return|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Since you're running the express installation, a few post-configuration\n"
literal|"questions will be asked at this point.\n\n"
literal|"The FreeBSD package collection is a collection of over 300 ready-to-run\n"
literal|"applications, from text editors to games to WEB servers.  If you've never\n"
literal|"done so, it's definitely worth browsing through.\n\n"
literal|"Would you like to do so now?"
argument_list|)
condition|)
name|configPackages
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure any additional network devices or services?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuNetworking
argument_list|)
expr_stmt|;
comment|/* XXX Put whatever other nice configuration questions you'd like to ask the user here XXX */
comment|/* Final menu of last resort */
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to go to the general configuration menu for any last\n"
literal|"additional configuration options?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuConfigure
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * What happens when we select "Commit" in the custom installation menu.  *  * This is broken into multiple stages so that the user can do a full installation but come back here  * again to load more distributions, perhaps from a different media type.  This would allow, for  * example, the user to load the majority of the system from CDROM and then use ftp to load just the  * DES dist.  */
end_comment

begin_function
name|int
name|installCommit
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|RET_FAIL
return|;
name|i
operator|=
name|RET_DONE
expr_stmt|;
if|if
condition|(
name|RunningAsInit
condition|)
block|{
if|if
condition|(
name|installInitial
argument_list|()
operator|==
name|RET_FAIL
condition|)
name|i
operator|=
name|RET_FAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|configFstab
argument_list|()
operator|==
name|RET_FAIL
condition|)
name|i
operator|=
name|RET_FAIL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|root_extract
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Failed to load the ROOT distribution.  Please correct\n"
literal|"this problem and try again."
argument_list|)
expr_stmt|;
name|i
operator|=
name|RET_FAIL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
name|RET_FAIL
operator|&&
name|distExtractAll
argument_list|(
name|NULL
argument_list|)
operator|==
name|RET_FAIL
condition|)
name|i
operator|=
name|RET_FAIL
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|RET_FAIL
operator|&&
name|installFixup
argument_list|()
operator|==
name|RET_FAIL
condition|)
name|i
operator|=
name|RET_FAIL
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|RET_FAIL
operator|&&
name|installFinal
argument_list|()
operator|==
name|RET_FAIL
condition|)
name|i
operator|=
name|RET_FAIL
expr_stmt|;
comment|/* Write out any changes to /etc/sysconfig */
if|if
condition|(
name|RunningAsInit
condition|)
name|configSysconfig
argument_list|()
expr_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_INSTALLED
argument_list|,
name|i
operator|==
name|RET_FAIL
condition|?
literal|"errors"
else|:
literal|"yes"
argument_list|)
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
comment|/* Don't print this if we're express installing */
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"express"
argument_list|)
condition|)
block|{
if|if
condition|(
name|Dists
operator|||
name|i
operator|==
name|RET_FAIL
condition|)
name|msgConfirm
argument_list|(
literal|"Installation completed with some errors.  You may wish to\n"
literal|"scroll through the debugging messages on VTY1 with the\n"
literal|"scroll-lock feature."
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"Installation completed successfully.\n\n"
literal|"If you have any network devices you have not yet configured,\n"
literal|"see the Interfaces configuration item on the Configuration menu."
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|installFixup
parameter_list|(
name|void
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/kernel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_readable
argument_list|(
literal|"/kernel.GENERIC"
argument_list|)
condition|)
block|{
if|if
condition|(
name|vsystem
argument_list|(
literal|"ln -f /kernel.GENERIC /kernel"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to link /kernel into place!"
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"Can't find a kernel image to link to on the root file system!\n"
literal|"You're going to have a hard time getting this system to\n"
literal|"boot from the hard disk, I'm afraid!"
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
block|}
comment|/* Resurrect /dev after bin distribution screws it up */
if|if
condition|(
name|RunningAsInit
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Remaking all devices.. Please wait!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV all"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"MAKEDEV returned non-zero status"
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
name|msgNotify
argument_list|(
literal|"Resurrecting /dev entries for slices.."
argument_list|)
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devs
condition|)
name|msgFatal
argument_list|(
literal|"Couldn't get a disk device list!"
argument_list|)
expr_stmt|;
comment|/* Resurrect the slices that the former clobbered */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Disk
modifier|*
name|disk
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Making slice entries for %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV %sh"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make slice entries for %s!"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
block|}
block|}
block|}
block|}
comment|/* XXX Do all the last ugly work-arounds here which we'll try and excise someday right?? XXX */
comment|/* BOGON #1:  XFree86 extracting /usr/X11R6 with root-only perms */
if|if
condition|(
name|directoryExists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
name|chmod
argument_list|(
literal|"/usr/X11R6"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
comment|/* BOGON #2: We leave /etc in a bad state */
name|chmod
argument_list|(
literal|"/etc"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
return|return
name|RET_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
end_comment

begin_function
name|int
name|installFilesystems
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|,
modifier|*
name|usrdev
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|PartInfo
modifier|*
name|root
decl_stmt|;
name|char
name|dname
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|int
name|MakeDevChunk
argument_list|(
name|Chunk
operator|*
name|c
argument_list|,
name|char
operator|*
name|n
argument_list|)
decl_stmt|;
name|Boolean
name|upgrade
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|checkLabels
argument_list|(
operator|&
name|rootdev
argument_list|,
operator|&
name|swapdev
argument_list|,
operator|&
name|usrdev
argument_list|)
condition|)
return|return
name|RET_FAIL
return|;
name|root
operator|=
operator|(
name|PartInfo
operator|*
operator|)
name|rootdev
operator|->
name|private
expr_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
name|upgrade
operator|=
operator|!
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|SYSTEM_INSTALLED
argument_list|)
argument_list|,
literal|"upgrade"
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* First, create and mount the root device */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MakeDevChunk
argument_list|(
name|rootdev
argument_list|,
literal|"/dev"
argument_list|)
operator|||
operator|!
name|file_readable
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make device node for %s in /dev!\n"
literal|"The installation will be aborted."
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|root
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|,
name|root
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|newfs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"%s /dev/r%s"
argument_list|,
name|root
operator|->
name|newfs_cmd
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem on /dev/r%s!\n"
literal|"Command returned status %d"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|upgrade
condition|)
name|msgConfirm
argument_list|(
literal|"Warning:  Root device is selected read-only.  It will be assumed\n"
literal|"that you have the appropriate device entries already in /dev.\n"
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Checking integrity of existing %s filesystem."
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"fsck -y /dev/r%s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: fsck returned status of %d for /dev/r%s.\n"
literal|"This partition may be unsafe to use."
argument_list|,
name|i
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system on %s!  Giving up."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
if|if
condition|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
decl_stmt|;
comment|/* Already did root */
if|if
condition|(
name|c2
operator|==
name|rootdev
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|newfs
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"%s /mnt/dev/r%s"
argument_list|,
name|tmp
operator|->
name|newfs_cmd
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"fsck -y /mnt/dev/r%s"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|char
name|fname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"/mnt/dev/%s"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|swapon
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|msgNotify
argument_list|(
literal|"Added %s as a swap device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"Unable to add %s as a swap device: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|fat
operator|&&
name|c1
operator|->
name|private
operator|&&
name|root
operator|->
name|newfs
condition|)
block|{
name|char
name|name
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"/mnt%s"
argument_list|,
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private
operator|)
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Copy the boot floppy's dev files */
if|if
condition|(
operator|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
operator|)
operator|&&
name|vsystem
argument_list|(
literal|"find -x /dev | cpio -pdmv /mnt"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the /dev files!"
argument_list|)
expr_stmt|;
return|return
name|RET_FAIL
return|;
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
return|return
name|RET_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* From the top menu - try to mount the floppy and read a configuration file from it */
end_comment

begin_function
name|int
name|installPreconfig
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|ufs_args
name|u_args
decl_stmt|;
name|struct
name|msdosfs_args
name|m_args
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|cfg_file
decl_stmt|;
name|memset
argument_list|(
operator|&
name|u_args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u_args
argument_list|)
argument_list|)
expr_stmt|;
name|u_args
operator|.
name|fspec
operator|=
literal|"/dev/fd0"
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/mnt2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|m_args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|m_args
argument_list|)
argument_list|)
expr_stmt|;
name|m_args
operator|.
name|fspec
operator|=
literal|"/dev/fd0"
expr_stmt|;
name|m_args
operator|.
name|uid
operator|=
name|m_args
operator|.
name|gid
operator|=
literal|0
expr_stmt|;
name|m_args
operator|.
name|mask
operator|=
literal|0777
expr_stmt|;
name|i
operator|=
name|RET_FAIL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cfg_file
operator|=
name|variable_get_value
argument_list|(
name|CONFIG_FILE
argument_list|,
literal|"Please insert the floppy containing this configuration file\n"
literal|"into drive A now and press [ENTER]."
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_UFS
argument_list|,
literal|"/mnt2"
argument_list|,
name|MNT_RDONLY
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|u_args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_MSDOS
argument_list|,
literal|"/mnt2"
argument_list|,
name|MNT_RDONLY
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|m_args
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the configuration floppy - do you want to try again?"
argument_list|)
condition|)
break|break;
else|else
continue|continue;
block|}
block|}
name|fnord
label|:
if|if
condition|(
operator|!
name|cfg_file
condition|)
break|break;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"/mnt2/%s"
argument_list|,
name|cfg_file
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Attempting to open configuration file: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to find the configuration file `%s' - do you want to\n"
literal|"try again?"
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|unmount
argument_list|(
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|fnord
goto|;
block|}
else|else
block|{
name|Attribs
modifier|*
name|cattr
init|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Attribs
argument_list|)
operator|*
name|MAX_ATTRIBS
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|attr_parse
argument_list|(
name|cattr
argument_list|,
name|fd
argument_list|)
operator|==
name|RET_FAIL
condition|)
name|msgConfirm
argument_list|(
literal|"Cannot parse configuration file %s!  Please verify your media."
argument_list|,
name|cfg_file
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|cattr
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
name|variable_set2
argument_list|(
name|cattr
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|cattr
index|[
name|j
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|i
operator|=
name|RET_SUCCESS
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Configuration file %s loaded successfully!\n"
literal|"Some parameters may now have new default values."
argument_list|,
name|cfg_file
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|safe_free
argument_list|(
name|cattr
argument_list|)
expr_stmt|;
name|unmount
argument_list|(
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|installVarDefaults
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set default startup options */
name|OptFlags
operator|=
name|OPT_DEFAULT_FLAGS
expr_stmt|;
name|variable_set2
argument_list|(
literal|"routedflags"
argument_list|,
literal|"-q"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RELNAME
argument_list|,
name|RELEASE_NAME
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|CPIO_VERBOSITY_LEVEL
argument_list|,
literal|"high"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|TAPE_BLOCKSIZE
argument_list|,
name|DEFAULT_TAPE_BLOCKSIZE
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|FTP_USER
argument_list|,
literal|"ftp"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|BROWSER_PACKAGE
argument_list|,
literal|"lynx-2.4.2"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|BROWSER_BINARY
argument_list|,
literal|"/usr/local/bin/lynx"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|CONFIG_FILE
argument_list|,
literal|"freebsd.cfg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpid
argument_list|()
operator|!=
literal|1
operator|&&
operator|!
name|variable_get
argument_list|(
name|SYSTEM_INSTALLED
argument_list|)
condition|)
name|variable_set2
argument_list|(
name|SYSTEM_INSTALLED
argument_list|,
literal|"update"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the boot floppy contents into /stand */
end_comment

begin_function
specifier|static
name|Boolean
name|copy_self
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Copying the boot floppy to /stand on root filesystem"
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"find -x /stand | cpio -pdmv /mnt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Copy returned error status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Copy the /etc files into their rightful place */
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /mnt/stand; find etc | cpio -pdmv /mnt"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't copy up the /etc files!"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function_decl
specifier|static
name|Boolean
name|loop_on_root_floppy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|Boolean
name|root_extract
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
specifier|static
name|Boolean
name|alreadyExtracted
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|alreadyExtracted
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mediaDevice
condition|)
block|{
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Attempting to extract root image from %s device\n"
argument_list|,
name|mediaDevice
operator|->
name|description
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mediaDevice
operator|->
name|type
condition|)
block|{
case|case
name|DEVICE_TYPE_FLOPPY
case|:
name|alreadyExtracted
operator|=
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|mediaDevice
operator|->
name|init
argument_list|(
name|mediaDevice
argument_list|)
condition|)
break|break;
name|fd
operator|=
name|mediaDevice
operator|->
name|get
argument_list|(
name|mediaDevice
argument_list|,
literal|"floppies/root.flp"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't get root image from %s!\n"
literal|"Will try to get it from floppy."
argument_list|,
name|mediaDevice
operator|->
name|name
argument_list|)
expr_stmt|;
name|mediaDevice
operator|->
name|shutdown
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
name|alreadyExtracted
operator|=
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|msgNotify
argument_list|(
literal|"Loading root image from:\n%s"
argument_list|,
name|mediaDevice
operator|->
name|name
argument_list|)
expr_stmt|;
name|alreadyExtracted
operator|=
name|mediaExtractDist
argument_list|(
literal|"/"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|mediaDevice
operator|->
name|close
argument_list|(
name|mediaDevice
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
name|alreadyExtracted
operator|=
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
return|return
name|alreadyExtracted
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|loop_on_root_floppy
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|status
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fd
operator|=
name|getRootFloppy
argument_list|()
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Extracting root floppy.."
argument_list|)
expr_stmt|;
name|status
operator|=
name|mediaExtractDist
argument_list|(
literal|"/"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|caps
index|[]
init|=
block|{
name|termcap_vt100
block|,
name|termcap_cons25
block|,
name|termcap_cons25_m
block|,
name|termcap_cons25r
block|,
name|termcap_cons25r_m
block|,
name|termcap_cons25l1
block|,
name|termcap_cons25l1_m
block|,
name|NULL
block|,     }
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/usr/share/misc"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|TERMCAP_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to initialize termcap file. Some screen-oriented\nutilities may not work."
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|caps
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
operator|(
name|cp
operator|++
operator|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

