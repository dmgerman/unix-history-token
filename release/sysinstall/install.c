begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: install.c,v 1.134.2.61 1997/10/12 16:22:20 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|"uc_main.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_define
define|#
directive|define
name|MSDOSFS
end_define

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_undef
undef|#
directive|undef
name|MSDOSFS
end_undef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function_decl
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SAVE_USERCONFIG
end_ifdef

begin_function_decl
specifier|static
name|void
name|save_userconfig_to_kernel
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TERMCAP_FILE
value|"/usr/share/misc/termcap"
end_define

begin_function_decl
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|Boolean
name|checkLabels
parameter_list|(
name|Boolean
name|whinge
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|rdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|sdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|udev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|vdev
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Boolean
name|status
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|,
modifier|*
name|usrdev
decl_stmt|,
modifier|*
name|vardev
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't allow whinging if noWarn is set */
if|if
condition|(
name|variable_get
argument_list|(
name|VAR_NO_WARN
argument_list|)
condition|)
name|whinge
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|TRUE
expr_stmt|;
operator|*
name|rdev
operator|=
operator|*
name|sdev
operator|=
operator|*
name|udev
operator|=
operator|*
name|vdev
operator|=
name|rootdev
operator|=
name|swapdev
operator|=
name|usrdev
operator|=
name|vardev
operator|=
name|NULL
expr_stmt|;
comment|/* We don't need to worry about root/usr/swap if we're already multiuser */
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|status
return|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private_data
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
block|{
if|if
condition|(
name|rootdev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one root device set?!\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|rootdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found rootdev at %s!\n"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/usr"
argument_list|)
condition|)
block|{
if|if
condition|(
name|usrdev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /usr filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|usrdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found usrdev at %s!\n"
argument_list|,
name|usrdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/var"
argument_list|)
condition|)
block|{
if|if
condition|(
name|vardev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /var filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|vardev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found vardev at %s!\n"
argument_list|,
name|vardev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
operator|&&
operator|!
name|swapdev
condition|)
block|{
name|swapdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found swapdev at %s!\n"
argument_list|,
name|swapdev
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Copy our values over */
operator|*
name|rdev
operator|=
name|rootdev
expr_stmt|;
operator|*
name|sdev
operator|=
name|swapdev
expr_stmt|;
operator|*
name|udev
operator|=
name|usrdev
expr_stmt|;
operator|*
name|vdev
operator|=
name|vardev
expr_stmt|;
if|if
condition|(
operator|!
name|rootdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n"
literal|"in the label editor."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|swapdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No swap devices found - you must create at least one\n"
literal|"swap partition."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|usrdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  No /usr filesystem found.  This is not technically\n"
literal|"an error if your root filesystem is big enough (or you later\n"
literal|"intend to mount your /usr filesystem over NFS), but it may otherwise\n"
literal|"cause you trouble if you're not exactly sure what you are doing!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vardev
operator|&&
name|whinge
operator|&&
name|variable_cmp
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"upgrade"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  No /var filesystem found.  This is not technically\n"
literal|"an error if your root filesystem is big enough (or you later\n"
literal|"intend to link /var to someplace else), but it may otherwise\n"
literal|"cause your root filesystem to fill up if you receive lots of mail\n"
literal|"or edit large temporary files."
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return
name|DITEM_SUCCESS
return|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\n"
literal|"the installation."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/* If it's labelled, assume it's also partitioned */
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
name|variable_set2
argument_list|(
name|DISK_PARTITIONED
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
comment|/* If we refuse to proceed, bail. */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\n"
literal|"If you're running this on a disk with data you wish to save\n"
literal|"then WE STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before\n"
literal|"proceeding!\n\n"
literal|"We can take no responsibility for lost disk contents!"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelCommit
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't make filesystems properly.  Aborting."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
elseif|else
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"installInitial: Scribbled successfully on the disk(s)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copySelf
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the boot floppy onto the root file system.\n"
literal|"Aborting."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to chroot to %s - this is bad!"
argument_list|,
literal|"/mnt"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RUNNING_ON_ROOT
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
name|configResolv
argument_list|()
expr_stmt|;
comment|/* stick a helpful shell over on the 4th VTY */
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installFixitHoloShell
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installFixitCDROM
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please insert the second FreeBSD CDROM and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|mediaSetCDROM
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
operator|||
operator|!
name|mediaDevice
operator|||
operator|!
name|mediaDevice
operator|->
name|init
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
comment|/* If we can't initialize it, it's probably not a FreeBSD CDROM so punt on it */
if|if
condition|(
name|mediaDevice
condition|)
block|{
name|mediaDevice
operator|->
name|shutdown
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
name|mediaDevice
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the CDROM - do you want to try again?"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
else|else
break|break;
block|}
comment|/* Since the fixit code expects everything to be in /mnt2, and the CDROM mounting stuff /dist, do      * a little kludge dance here..      */
if|if
condition|(
name|symlink
argument_list|(
literal|"/dist"
argument_list|,
literal|"/mnt2"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to symlink /mnt2 to the CDROM mount point.  Please report this\n"
literal|"unexpected failure to freebsd-bugs@FreeBSD.org."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/*      * If /tmp points to /mnt2/tmp from a previous fixit floppy session, it's      * not very good for us if we point it to the CDROM now.  Rather make it      * a directory in the root MFS then.  Experienced admins will still be      * able to mount their disk's /tmp over this if they need.      */
if|if
condition|(
name|lstat
argument_list|(
literal|"/tmp"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
comment|/*      * Since setuid binaries ignore LD_LIBRARY_PATH, we indeed need the      * ld.so.hints file.  Fortunately, it's fairly small (~ 3 KB).      */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/var/run/ld.so.hints"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/var/run"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"/mnt2/sbin/ldconfig -s /mnt2/usr/lib"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: ldconfig could not create the ld.so hints file.\n"
literal|"Dynamic executables from the CDROM likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Yet another iggly hardcoded pathname. */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/usr/libexec/ld.so"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/usr/libexec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
literal|"/mnt2/usr/libexec/ld.so"
argument_list|,
literal|"/usr/libexec/ld.so"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: could not create the symlink for ld.so.\n"
literal|"Dynamic executables from the CDROM likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
name|fixit_common
argument_list|()
expr_stmt|;
name|mediaDevice
operator|->
name|shutdown
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the FreeBSD CDROM now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installFixitFloppy
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|ufs_args
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|fspec
operator|=
literal|"/dev/fd0"
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please insert a writable fixit floppy and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_UFS
argument_list|,
literal|"/mnt2"
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
name|msgConfirm
argument_list|(
literal|"An attempt to mount the fixit floppy failed, maybe the filesystem\n"
literal|"is unclean.  Trying a forcible mount as a last resort..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_UFS
argument_list|,
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the fixit floppy - do you want to try again?"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/tmp"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/tmp"
argument_list|,
literal|"/tmp"
argument_list|)
expr_stmt|;
name|fixit_common
argument_list|()
expr_stmt|;
name|unmount
argument_list|(
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the fixit floppy now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * The common code for both fixit variants.  */
end_comment

begin_function
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|child
decl_stmt|;
name|int
name|waitstatus
decl_stmt|;
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
condition|)
block|{
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  Was unable to create a /var/tmp/vi.recover directory.\n"
literal|"vi will kvetch and moan about it as a result but should still\n"
literal|"be essentially usable."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/bin"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|Mkdir
argument_list|(
literal|"/bin"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/stand/sh"
argument_list|,
literal|"/bin/sh"
argument_list|)
expr_stmt|;
comment|/* Link the /etc/ files */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/etc"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
name|msgConfirm
argument_list|(
literal|"Unable to create an /etc directory!  Things are weird on this floppy.."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/spwd.db"
argument_list|,
literal|"/etc/spwd.db"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/protocols"
argument_list|,
literal|"/etc/protocols"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/services"
argument_list|,
literal|"/etc/services"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
name|msgConfirm
argument_list|(
literal|"Couldn't symlink the /etc/ files!  I'm not sure I like this.."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
name|create_termcap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|termios
name|foo
decl_stmt|;
specifier|extern
name|int
name|login_tty
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|getdtablesize
argument_list|()
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ttyv3"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DebugFD
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit: I can't set the controlling terminal.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|foo
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|foo
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|'\010'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|foo
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to set erase character.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to get terminal attributes!\n"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
literal|"/bin:/sbin:/usr/bin:/usr/sbin:/stand:"
literal|"/mnt2/stand:/mnt2/bin:/mnt2/sbin:/mnt2/usr/bin:/mnt2/usr/sbin"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* use the .profile from the fixit medium */
name|setenv
argument_list|(
literal|"HOME"
argument_list|,
literal|"/mnt2"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"fixit shell: Failed to execute shell!\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
else|else
block|{
name|msgNotify
argument_list|(
literal|"Waiting for fixit shell to exit.  Go to VTY4 now by\n"
literal|"typing ALT-F4.  When you are done, type ``exit'' to exit\n"
literal|"the fixit shell and be returned here."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|waitstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|installExpress
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"express"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
name|i
operator||=
name|DITEM_LEAVE_MENU
expr_stmt|;
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
block|}
return|return
name|i
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_comment
comment|/* Novice mode installation */
end_comment

begin_function
name|int
name|installNovice
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"novice"
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"In the next menu, you will need to set up a DOS-style (\"fdisk\") partitioning\n"
literal|"scheme for your hard disk.  If you simply wish to devote all disk space\n"
literal|"to FreeBSD (overwriting anything else that might be on the disk(s) selected)\n"
literal|"then use the (A)ll command to select the default partitioning scheme followed\n"
literal|"by a (Q)uit.  If you wish to allocate only free space to FreeBSD, move to a\n"
literal|"partition marked \"unused\" and use the (C)reate command."
argument_list|)
expr_stmt|;
name|nodisks
label|:
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
if|if
condition|(
name|diskGetSelectCount
argument_list|(
operator|&
name|devs
argument_list|)
operator|<=
literal|0
operator|&&
name|tries
operator|<
literal|3
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to select some disks to operate on!  Be sure to use SPACE\n"
literal|"instead of RETURN in the disk selection menu when selecting a disk."
argument_list|)
expr_stmt|;
operator|++
name|tries
expr_stmt|;
goto|goto
name|nodisks
goto|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Next, you need to create BSD partitions inside of the fdisk partition(s)\n"
literal|"just created.  If you have a reasonable amount of disk space (200MB or more)\n"
literal|"and don't have any special requirements, simply use the (A)uto command to\n"
literal|"allocate space automatically.  If you have more specific needs or just don't\n"
literal|"care for the layout chosen by (A)uto, press F1 for more information on\n"
literal|"manual layout."
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Installation completed with some errors.  You may wish to\n"
literal|"scroll through the debugging messages on VTY1 with the\n"
literal|"scroll-lock feature.  You can also chose \"No\" at the next\n"
literal|"prompt and go back into the installation menus to try and retry\n"
literal|"whichever operations have failed."
argument_list|)
expr_stmt|;
return|return
name|i
operator||
name|DITEM_RESTORE
return|;
block|}
else|else
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Congratulations!  You now have FreeBSD installed on your system.\n\n"
literal|"We will now move on to the final configuration questions.\n"
literal|"For any option you do not wish to configure, simply select\n"
literal|"No.\n\n"
literal|"If you wish to re-enter this utility after the system is up, you\n"
literal|"may do so by typing: /stand/sysinstall."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_FTP
operator|&&
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_NFS
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure any Ethernet or SLIP/PPP network devices?"
argument_list|)
condition|)
block|{
name|Device
modifier|*
name|tmp
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|tcpDeviceSelect
argument_list|()
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to bring the %s interface up right now?"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
condition|)
if|if
condition|(
operator|!
name|tmp
operator|->
name|init
argument_list|(
name|tmp
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Initialization of %s device failed."
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Will this machine be an IP gateway (e.g. will it forward packets\n"
literal|"between interfaces)?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"gateway"
argument_list|,
literal|"YES"
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Do you want to allow anonymous FTP connections to this machine?"
argument_list|)
condition|)
name|configAnonFTP
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Do you want to configure this machine as an NFS server?"
argument_list|)
condition|)
name|configNFSServer
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Do you want to configure this machine as an NFS client?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"nfs_client"
argument_list|,
literal|"YES"
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to customize your system console settings?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuSyscons
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to set this machine's time zone now?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|systemExecute
argument_list|(
literal|"tzsetup"
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Does this system have a mouse attached to it?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMouse
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
comment|/* Now would be a good time to checkpoint the configuration data */
name|configRC_conf
argument_list|(
literal|"/etc/rc.conf"
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_XIG_ENVIRONMENT
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure your X server at this time?"
argument_list|)
condition|)
name|configXEnvironment
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"The FreeBSD package collection is a collection of hundreds of ready-to-run\n"
literal|"applications, from text editors to games to WEB servers and more.  Would you\n"
literal|"like to browse the collection now?"
argument_list|)
condition|)
name|configPackages
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to add any initial user accounts to the system?\n"
literal|"Adding at least one account for yourself at this stage is suggested\n"
literal|"since working as the \"root\" user is dangerous (it is easy to do\n"
literal|"things which adversely affect the entire system)."
argument_list|)
condition|)
name|configUsers
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Now you must set the system manager's password.\n"
literal|"This is the password you'll use to log in as \"root\"."
argument_list|)
expr_stmt|;
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|systemExecute
argument_list|(
literal|"passwd root"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"root_password"
argument_list|,
literal|"YES"
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to register your FreeBSD system at this time?\n\n"
literal|"PLEASE, take just 5 minutes to do this.  If we're ever to get any\n"
literal|"significant base of commercial software for FreeBSD, we need to\n"
literal|"be able to provide more information about the size of our user community.\n"
literal|"This is where your registration can really help us, and you can also\n"
literal|"sign up for the new FreeBSD newsletter (its free!) at the same time.\n"
argument_list|)
condition|)
name|configRegister
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"OK, but if you should change your mind then you always can register\n"
literal|"later by typing ``/stand/sysinstall register'' or by simply visiting our\n"
literal|"web site at http://www.freebsd.org/register.html"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Put whatever other nice configuration questions you'd like to ask the user here XXX */
comment|/* Give user the option of one last configuration spree */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|DITEM_LEAVE_MENU
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_comment
comment|/* The version of commit we call from the Install Custom menu */
end_comment

begin_function
name|int
name|installCustomCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
name|msgConfirm
argument_list|(
literal|"The commit operation completed with errors.  Not\n"
literal|"updating /etc files."
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * What happens when we finally decide to going ahead with the installation.  *  * This is broken into multiple stages so that the user can do a full  * installation but come back here again to load more distributions,  * perhaps from a different media type.  This would allow, for  * example, the user to load the majority of the system from CDROM and  * then use ftp to load just the DES dist.  */
end_comment

begin_function
name|int
name|installCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|Boolean
name|need_bin
decl_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
name|distConfig
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
if|if
condition|(
operator|!
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuDistributions
argument_list|,
name|FALSE
argument_list|)
operator|&&
operator|!
name|Dists
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
name|str
operator|=
name|variable_get
argument_list|(
name|SYSTEM_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"installCommit: System state is `%s'\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|RunningAsInit
condition|)
block|{
comment|/* Do things we wouldn't do to a multi-user system */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installInitial
argument_list|()
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|configFstab
argument_list|()
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
block|}
name|try_media
label|:
if|if
condition|(
operator|!
name|mediaDevice
operator|->
name|init
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Unable to initialize selected media. Would you like to\n"
literal|"adjust your media configuration and try again?"
argument_list|)
condition|)
block|{
name|mediaDevice
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
else|else
goto|goto
name|try_media
goto|;
block|}
else|else
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
name|need_bin
operator|=
name|Dists
operator|&
name|DIST_BIN
expr_stmt|;
name|i
operator|=
name|distExtractAll
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
if|if
condition|(
name|need_bin
operator|&&
operator|!
operator|(
name|Dists
operator|&
name|DIST_BIN
operator|)
condition|)
name|i
operator|=
name|installFixup
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_FAILURE
condition|?
literal|"error-install"
else|:
literal|"full-install"
argument_list|)
expr_stmt|;
comment|/* We always try to install X with the XiG product */
ifdef|#
directive|ifdef
name|USE_XIG_ENVIRONMENT
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
name|configXEnvironment
argument_list|(
name|self
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|i
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Final menu of last resort */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Visit the general configuration menu for a chance to set\n"
literal|"any last options?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuConfigure
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|configRC_conf
argument_list|(
literal|"/etc/rc.conf"
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|installFixup
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/kernel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_readable
argument_list|(
literal|"/kernel.GENERIC"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SAVE_USERCONFIG
comment|/* Snapshot any boot -c changes back to the GENERIC kernel */
if|if
condition|(
operator|!
name|variable_cmp
argument_list|(
name|VAR_RELNAME
argument_list|,
name|RELEASE_NAME
argument_list|)
condition|)
name|save_userconfig_to_kernel
argument_list|(
literal|"/kernel.GENERIC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vsystem
argument_list|(
literal|"cp -p /kernel.GENERIC /kernel"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to link /kernel into place!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"Can't find a kernel image to link to on the root file system!\n"
literal|"You're going to have a hard time getting this system to\n"
literal|"boot from the hard disk, I'm afraid!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
comment|/* Resurrect /dev after bin distribution screws it up */
if|if
condition|(
name|RunningAsInit
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Remaking all devices.. Please wait!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV all"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"MAKEDEV returned non-zero status"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|msgNotify
argument_list|(
literal|"Resurrecting /dev entries for slices.."
argument_list|)
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devs
condition|)
name|msgFatal
argument_list|(
literal|"Couldn't get a disk device list!"
argument_list|)
expr_stmt|;
comment|/* Resurrect the slices that the former clobbered */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Disk
modifier|*
name|disk
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Making slice entries for %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV %sh"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make slice entries for %s!"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
block|}
block|}
comment|/* XXX Do all the last ugly work-arounds here which we'll try and excise someday right?? XXX */
name|msgNotify
argument_list|(
literal|"Fixing permissions.."
argument_list|)
expr_stmt|;
comment|/* BOGON #1:  XFree86 extracting /usr/X11R6 with root-only perms */
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
block|{
name|vsystem
argument_list|(
literal|"chmod -R a+r /usr/X11R6"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"find /usr/X11R6 -type d | xargs chmod a+x"
argument_list|)
expr_stmt|;
block|}
comment|/* BOGON #2: We leave /etc in a bad state */
name|chmod
argument_list|(
literal|"/etc"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
comment|/* BOGON #3: No /var/db/mountdtab complains */
name|Mkdir
argument_list|(
literal|"/var/db"
argument_list|)
expr_stmt|;
name|creat
argument_list|(
literal|"/var/db/mountdtab"
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
comment|/* BOGON #4: /compat created by default in root fs */
name|Mkdir
argument_list|(
literal|"/usr/compat"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"ln -s /usr/compat /compat"
argument_list|)
expr_stmt|;
comment|/* BOGON #5: aliases database not build for bin */
name|vsystem
argument_list|(
literal|"newaliases"
argument_list|)
expr_stmt|;
comment|/* BOGON #6: deal with new boot files */
name|vsystem
argument_list|(
literal|"touch /kernel.config"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"touch /boot.config"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_readable
argument_list|(
literal|"/stand/boot.help"
argument_list|)
operator|&&
operator|!
name|file_readable
argument_list|(
literal|"/boot.help"
argument_list|)
condition|)
name|vsystem
argument_list|(
literal|"mv /stand/boot.help /"
argument_list|)
expr_stmt|;
comment|/* Now run all the mtree stuff to fix things up */
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.root.dist -p /"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.var.dist -p /var"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.usr.dist -p /usr"
argument_list|)
expr_stmt|;
block|}
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
end_comment

begin_function
name|int
name|installFilesystems
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|,
modifier|*
name|usrdev
decl_stmt|,
modifier|*
name|vardev
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|PartInfo
modifier|*
name|root
decl_stmt|;
name|char
name|dname
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|int
name|MakeDevChunk
argument_list|(
name|Chunk
operator|*
name|c
argument_list|,
name|char
operator|*
name|n
argument_list|)
decl_stmt|;
name|Boolean
name|upgrade
init|=
name|FALSE
decl_stmt|;
comment|/* If we've already done this, bail out */
if|if
condition|(
operator|!
name|variable_cmp
argument_list|(
name|DISK_LABELLED
argument_list|,
literal|"written"
argument_list|)
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|upgrade
operator|=
operator|!
name|variable_cmp
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"upgrade"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkLabels
argument_list|(
name|TRUE
argument_list|,
operator|&
name|rootdev
argument_list|,
operator|&
name|swapdev
argument_list|,
operator|&
name|usrdev
argument_list|,
operator|&
name|vardev
argument_list|)
condition|)
return|return
name|DITEM_FAILURE
return|;
if|if
condition|(
name|rootdev
condition|)
name|root
operator|=
operator|(
name|PartInfo
operator|*
operator|)
name|rootdev
operator|->
name|private_data
expr_stmt|;
else|else
name|root
operator|=
name|NULL
expr_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|swapdev
operator|&&
name|RunningAsInit
condition|)
block|{
comment|/* As the very first thing, try to get ourselves some swap space */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|swapdev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
operator|&&
operator|(
operator|!
name|MakeDevChunk
argument_list|(
name|swapdev
argument_list|,
literal|"/dev"
argument_list|)
operator|||
operator|!
name|file_readable
argument_list|(
name|dname
argument_list|)
operator|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make device node for %s in /dev!\n"
literal|"The creation of filesystems will be aborted."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|Fake
condition|)
block|{
if|if
condition|(
operator|!
name|swapon
argument_list|(
name|dname
argument_list|)
condition|)
name|msgNotify
argument_list|(
literal|"Added %s as initial swap device"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"WARNING!  Unable to swap to %s: %s\n"
literal|"This may cause the installation to fail at some point\n"
literal|"if you don't have a lot of memory."
argument_list|,
name|dname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rootdev
operator|&&
name|RunningAsInit
condition|)
block|{
comment|/* Next, create and/or mount the root device */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/r%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
operator|&&
operator|(
operator|!
name|MakeDevChunk
argument_list|(
name|rootdev
argument_list|,
literal|"/dev"
argument_list|)
operator|||
operator|!
name|file_readable
argument_list|(
name|dname
argument_list|)
operator|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make device node for %s in /dev!\n"
literal|"The creation of filesystems will be aborted."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|root
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|,
name|root
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|newfs
operator|&&
operator|(
operator|!
name|upgrade
operator|||
operator|!
name|msgYesNo
argument_list|(
literal|"You are upgrading - are you SURE you want to newfs the root partition?"
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"%s %s"
argument_list|,
name|root
operator|->
name|newfs_cmd
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem on %s!\n"
literal|"Command returned status %d"
argument_list|,
name|dname
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|upgrade
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  Using existing root partition.  It will be assumed\n"
literal|"that you have the appropriate device entries already in /dev."
argument_list|)
expr_stmt|;
block|}
name|msgNotify
argument_list|(
literal|"Checking integrity of existing %s filesystem."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"fsck -y %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: fsck returned status of %d for %s.\n"
literal|"This partition may be unsafe to use."
argument_list|,
name|i
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
comment|/* Switch to block device */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system on %s!  Giving up."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
name|RunningAsInit
operator|&&
name|root
operator|&&
operator|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
operator|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
condition|)
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|RunningAsInit
operator|&&
operator|!
name|Fake
condition|)
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/dev"
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private_data
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
decl_stmt|;
comment|/* Already did root */
if|if
condition|(
name|c2
operator|==
name|rootdev
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|newfs
operator|&&
operator|(
operator|!
name|upgrade
operator|||
operator|!
name|msgYesNo
argument_list|(
literal|"You are upgradding - are you SURE you want to newfs /dev/%s?"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
operator|)
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"%s %s/dev/r%s"
argument_list|,
name|tmp
operator|->
name|newfs_cmd
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"fsck -y %s/dev/r%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|char
name|fname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c2
operator|==
name|swapdev
condition|)
continue|continue;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|Fake
operator|||
name|swapon
argument_list|(
name|fname
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|msgNotify
argument_list|(
literal|"Added %s as an additional swap device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"Unable to add %s as a swap device: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|fat
operator|&&
name|c1
operator|->
name|private_data
operator|&&
operator|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
operator|)
condition|)
block|{
name|char
name|name
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|RunningAsInit
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Copying initial device files.."
argument_list|)
expr_stmt|;
comment|/* Copy the boot floppy's dev files */
if|if
condition|(
operator|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
operator|)
operator|&&
name|vsystem
argument_list|(
literal|"find -x /dev | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the /dev files!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Initialize various user-settable values to their defaults */
end_comment

begin_function
name|int
name|installVarDefaults
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Set default startup options */
name|variable_set2
argument_list|(
name|VAR_ROUTER_ENABLE
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_RELNAME
argument_list|,
name|RELEASE_NAME
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_CPIO_VERBOSITY
argument_list|,
literal|"high"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_TAPE_BLOCKSIZE
argument_list|,
name|DEFAULT_TAPE_BLOCKSIZE
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_INSTALL_ROOT
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_INSTALL_CFG
argument_list|,
literal|"install.cfg"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|cp
operator|=
literal|"/usr/bin/ee"
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_EDITOR
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_FTP_USER
argument_list|,
literal|"ftp"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_BROWSER_PACKAGE
argument_list|,
name|PACKAGE_LYNX
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_BROWSER_BINARY
argument_list|,
literal|"/usr/local/bin/lynx"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_FTP_STATE
argument_list|,
literal|"passive"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NFS_SECURE
argument_list|,
literal|"YES"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_PKG_TMPDIR
argument_list|,
literal|"/usr/tmp"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_GATED_PKG
argument_list|,
name|PACKAGE_GATED
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_PCNFSD_PKG
argument_list|,
name|PACKAGE_PCNFSD
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_MEDIA_TIMEOUT
argument_list|,
name|itoa
argument_list|(
name|MEDIA_TIMEOUT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpid
argument_list|()
operator|!=
literal|1
condition|)
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"update"
argument_list|)
expr_stmt|;
else|else
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"init"
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Load the environment up from various system configuration files */
end_comment

begin_function
name|void
name|installEnvironment
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|file_readable
argument_list|(
literal|"/etc/rc.conf"
argument_list|)
condition|)
name|configEnvironmentRC_conf
argument_list|(
literal|"/etc/rc.conf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_readable
argument_list|(
literal|"/etc/resolv.conf"
argument_list|)
condition|)
name|configEnvironmentResolv
argument_list|(
literal|"/etc/resolv.conf"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the boot floppy contents into /stand */
end_comment

begin_function
name|Boolean
name|copySelf
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Copying the boot floppy to /stand on root filesystem"
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"find -x /stand | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Copy returned error status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Copy the /etc files into their rightful place */
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /mnt/stand; find etc | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't copy up the /etc files!"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|caps
index|[]
init|=
block|{
name|termcap_vt100
block|,
name|termcap_cons25
block|,
name|termcap_cons25_m
block|,
name|termcap_cons25r
block|,
name|termcap_cons25r_m
block|,
name|termcap_cons25l1
block|,
name|termcap_cons25l1_m
block|,
name|NULL
block|,     }
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/usr/share/misc"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|TERMCAP_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to initialize termcap file. Some screen-oriented\nutilities may not work."
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|caps
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
operator|(
name|cp
operator|++
operator|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SAVE_USERCONFIG
end_ifdef

begin_function
specifier|static
name|void
name|save_userconfig_to_kernel
parameter_list|(
name|char
modifier|*
name|kern
parameter_list|)
block|{
name|struct
name|kernel
modifier|*
name|core
decl_stmt|,
modifier|*
name|boot
decl_stmt|;
name|struct
name|list
modifier|*
name|c_isa
decl_stmt|,
modifier|*
name|b_isa
decl_stmt|,
modifier|*
name|c_dev
decl_stmt|,
modifier|*
name|b_dev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|core
operator|=
name|uc_open
argument_list|(
literal|"-incore"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgDebug
argument_list|(
literal|"save_userconf: Can't read in-core information for kernel.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|boot
operator|=
name|uc_open
argument_list|(
name|kern
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgDebug
argument_list|(
literal|"save_userconf: Can't read device information for kernel image %s\n"
argument_list|,
name|kern
argument_list|)
expr_stmt|;
return|return;
block|}
name|msgNotify
argument_list|(
literal|"Saving any boot -c changes to new kernel..."
argument_list|)
expr_stmt|;
name|c_isa
operator|=
name|uc_getdev
argument_list|(
name|core
argument_list|,
literal|"-isa"
argument_list|)
expr_stmt|;
name|b_isa
operator|=
name|uc_getdev
argument_list|(
name|boot
argument_list|,
literal|"-isa"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"save_userconf: got %d ISA device entries from core, %d from boot.\n"
argument_list|,
name|c_isa
operator|->
name|ac
argument_list|,
name|b_isa
operator|->
name|ac
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|c_isa
operator|->
name|ac
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"save_userconf: ISA device loop, c_isa->av[%d] = %s\n"
argument_list|,
name|d
argument_list|,
name|c_isa
operator|->
name|av
index|[
name|d
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|c_isa
operator|->
name|av
index|[
name|d
index|]
argument_list|,
literal|"npx0"
argument_list|)
condition|)
block|{
comment|/* special case npx0, which mucks with its id_irq member */
name|c_dev
operator|=
name|uc_getdev
argument_list|(
name|core
argument_list|,
name|c_isa
operator|->
name|av
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|b_dev
operator|=
name|uc_getdev
argument_list|(
name|boot
argument_list|,
name|b_isa
operator|->
name|av
index|[
name|d
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c_dev
operator|||
operator|!
name|b_dev
condition|)
block|{
name|msgDebug
argument_list|(
literal|"save_userconf: c_dev: %x b_dev: %x\n"
argument_list|,
name|c_dev
argument_list|,
name|b_dev
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"save_userconf: ISA device %s: %d config parameters (core), %d (boot)\n"
argument_list|,
name|c_isa
operator|->
name|av
index|[
name|d
index|]
argument_list|,
name|c_dev
operator|->
name|ac
argument_list|,
name|b_dev
operator|->
name|ac
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c_dev
operator|->
name|ac
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"save_userconf: c_dev->av[%d] = %s, b_dev->av[%d] = %s\n"
argument_list|,
name|i
argument_list|,
name|c_dev
operator|->
name|av
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|b_dev
operator|->
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|c_dev
operator|->
name|av
index|[
name|i
index|]
argument_list|,
name|b_dev
operator|->
name|av
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"save_userconf: %s (boot) -> %s (core)\n"
argument_list|,
name|c_dev
operator|->
name|av
index|[
name|i
index|]
argument_list|,
name|b_dev
operator|->
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isa_setdev
argument_list|(
name|boot
argument_list|,
name|c_dev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"skipping npx0\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Closing kernels\n"
argument_list|)
expr_stmt|;
name|uc_close
argument_list|(
name|core
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uc_close
argument_list|(
name|boot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

