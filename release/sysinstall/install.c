begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: install.c,v 1.27 1995/05/18 21:58:33 phk Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,   *    verbatim and that no modifications are made prior to this   *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
name|Boolean
name|SystemWasInstalled
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|make_filesystems
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cpio_extract
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_configuration_files
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_final_setup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|Boolean
name|preInstallCheck
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getenv
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to partition your disk before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|getenv
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|Dists
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You haven't told me what distributions to load yet!\nPlease select a distribution from the Distributions menu."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|installCommit
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|extern
name|u_char
name|boot1
index|[]
decl_stmt|,
name|boot2
index|[]
decl_stmt|;
specifier|extern
name|u_char
name|mbr
index|[]
decl_stmt|,
name|bteasy17
index|[]
decl_stmt|;
name|u_char
modifier|*
name|mbrContents
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If things aren't kosher, or we refuse to proceed, bail. */
if|if
condition|(
operator|!
name|preInstallCheck
argument_list|()
operator|||
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\nIf you're running this on an existing system, we STRONGLY\nencourage you to make proper backups before proceeding.\nWe take no responsibility for lost disk contents!"
argument_list|)
condition|)
return|return
literal|0
return|;
name|mbrContents
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to install a boot manager?\n\nThis will allow you to easily select between other operating systems\non the first disk, or boot from a disk other than the first."
argument_list|)
condition|)
name|mbrContents
operator|=
name|bteasy17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to remove an existing boot manager?"
argument_list|)
condition|)
name|mbrContents
operator|=
name|mbr
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Disk
modifier|*
name|d
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
name|mbrContents
condition|)
block|{
name|Set_Boot_Mgr
argument_list|(
name|d
argument_list|,
name|mbrContents
argument_list|)
expr_stmt|;
name|mbrContents
operator|=
name|NULL
expr_stmt|;
block|}
name|Set_Boot_Blocks
argument_list|(
name|d
argument_list|,
name|boot1
argument_list|,
name|boot2
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Writing partition information to drive %s"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|Write_Disk
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Now scan for bad blocks, if necessary */
for|for
control|(
name|c1
operator|=
name|d
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|flags
operator|&
name|CHUNK_BAD144
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|msgNotify
argument_list|(
literal|"Running bad block scan on partition %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsystem
argument_list|(
literal|"bad144 -v /dev/r%s 1234"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|msgConfirm
argument_list|(
literal|"Bad144 init on %s returned status of %d!"
argument_list|,
name|c1
operator|->
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsystem
argument_list|(
literal|"bad144 -v -s /dev/r%s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|msgConfirm
argument_list|(
literal|"Bad144 scan on %s returned status of %d!"
argument_list|,
name|c1
operator|->
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|make_filesystems
argument_list|()
expr_stmt|;
name|cpio_extract
argument_list|()
expr_stmt|;
name|distExtractAll
argument_list|()
expr_stmt|;
name|install_configuration_files
argument_list|()
expr_stmt|;
name|do_final_setup
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
end_comment

begin_function
specifier|static
name|void
name|make_filesystems
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First look for the root device and mount it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
operator|&&
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
block|{
name|char
name|dname
index|[
literal|40
index|]
decl_stmt|;
name|PartInfo
modifier|*
name|p
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|c2
operator|->
name|name
argument_list|,
name|p
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|->
name|newfs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/r%sa"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"newfs %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem!  Command returned status %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|msgConfirm
argument_list|(
literal|"Warning:  You have selected a Read-Only root device\nand may be unable to find the appropriate device entries on it\nif it is from an older pre-slice version of FreeBSD."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%sa"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system!  Giving up."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
specifier|extern
name|int
name|makedevs
argument_list|(
name|void
argument_list|)
decl_stmt|;
if|if
condition|(
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|,
name|NULL
argument_list|)
operator|||
name|chdir
argument_list|(
literal|"/mnt/dev"
argument_list|)
operator|||
name|makedevs
argument_list|()
condition|)
name|msgConfirm
argument_list|(
literal|"Failed to make some of the devices in /mnt!"
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Make the proper device mount points in /mnt/dev */
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|newfs
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"%s /mnt/dev/r%s"
argument_list|,
name|tmp
operator|->
name|newfs_cmd
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpio_extract
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|zpid
decl_stmt|,
name|cpid
decl_stmt|,
name|pfd
index|[
literal|2
index|]
decl_stmt|;
specifier|extern
name|int
name|wait
argument_list|(
name|int
operator|*
name|status
argument_list|)
decl_stmt|;
while|while
condition|(
name|CpioFD
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please Insert CPIO floppy in floppy drive 0"
argument_list|)
expr_stmt|;
name|CpioFD
operator|=
name|open
argument_list|(
literal|"/dev/rfd0"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
name|msgNotify
argument_list|(
literal|"Extracting contents of CPIO floppy..."
argument_list|)
expr_stmt|;
name|pipe
argument_list|(
name|pfd
argument_list|)
expr_stmt|;
name|zpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zpid
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|execl
argument_list|(
literal|"/stand/gunzip"
argument_list|,
literal|"/stand/gunzip"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"/stand/gunzip command returns %d status\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|cpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cpid
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
name|i
operator|=
name|execl
argument_list|(
literal|"/stand/cpio"
argument_list|,
literal|"/stand/cpio"
argument_list|,
literal|"-iduvm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"/stand/cpio command returns %d status\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|i
operator|=
name|wait
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|j
condition|)
name|msgFatal
argument_list|(
literal|"Pid %d, status %d, cpio=%d, gunzip=%d.\nerror:%s"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|cpid
argument_list|,
name|zpid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|wait
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|j
condition|)
name|msgFatal
argument_list|(
literal|"Pid %d, status %d, cpio=%d, gunzip=%d.\nerror:%s"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|cpid
argument_list|,
name|zpid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|install_configuration_files
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|do_final_setup
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

