begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: install.c,v 1.192 1997/07/16 05:22:40 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|"uc_main.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_define
define|#
directive|define
name|MSDOSFS
end_define

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/msdosfsmount.h>
end_include

begin_undef
undef|#
directive|undef
name|MSDOSFS
end_undef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function_decl
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SAVE_USERCONFIG
end_ifdef

begin_function_decl
specifier|static
name|void
name|save_userconfig_to_kernel
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TERMCAP_FILE
value|"/usr/share/misc/termcap"
end_define

begin_function_decl
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|Boolean
name|checkLabels
parameter_list|(
name|Boolean
name|whinge
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|rdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|sdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|udev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|vdev
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Boolean
name|status
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|,
modifier|*
name|usrdev
decl_stmt|,
modifier|*
name|vardev
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't allow whinging if noWarn is set */
if|if
condition|(
name|variable_get
argument_list|(
name|VAR_NO_WARN
argument_list|)
condition|)
name|whinge
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|TRUE
expr_stmt|;
operator|*
name|rdev
operator|=
operator|*
name|sdev
operator|=
operator|*
name|udev
operator|=
operator|*
name|vdev
operator|=
name|rootdev
operator|=
name|swapdev
operator|=
name|usrdev
operator|=
name|vardev
operator|=
name|NULL
expr_stmt|;
comment|/* We don't need to worry about root/usr/swap if we're already multiuser */
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|status
return|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private_data
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
block|{
if|if
condition|(
name|rootdev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one root device set?!\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|rootdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found rootdev at %s!\n"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/usr"
argument_list|)
condition|)
block|{
if|if
condition|(
name|usrdev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /usr filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|usrdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found usrdev at %s!\n"
argument_list|,
name|usrdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/var"
argument_list|)
condition|)
block|{
if|if
condition|(
name|vardev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /var filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|vardev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found vardev at %s!\n"
argument_list|,
name|vardev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
operator|&&
operator|!
name|swapdev
condition|)
block|{
name|swapdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found swapdev at %s!\n"
argument_list|,
name|swapdev
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Copy our values over */
operator|*
name|rdev
operator|=
name|rootdev
expr_stmt|;
operator|*
name|sdev
operator|=
name|swapdev
expr_stmt|;
operator|*
name|udev
operator|=
name|usrdev
expr_stmt|;
operator|*
name|vdev
operator|=
name|vardev
expr_stmt|;
if|if
condition|(
operator|!
name|rootdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n"
literal|"in the label editor."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|swapdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No swap devices found - you must create at least one\n"
literal|"swap partition."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|usrdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  No /usr filesystem found.  This is not technically\n"
literal|"an error if your root filesystem is big enough (or you later\n"
literal|"intend to mount your /usr filesystem over NFS), but it may otherwise\n"
literal|"cause you trouble if you're not exactly sure what you are doing!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vardev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"WARNING:  No /var filesystem found.  This is not technically\n"
literal|"an error if your root filesystem is big enough (or you later\n"
literal|"intend to link /var to someplace else), but it may otherwise\n"
literal|"cause your root filesystem to fill up if you receive lots of mail\n"
literal|"or edit large temporary files."
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return
name|DITEM_SUCCESS
return|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\n"
literal|"the installation."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/* If it's labelled, assume it's also partitioned */
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
name|variable_set2
argument_list|(
name|DISK_PARTITIONED
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
comment|/* If we refuse to proceed, bail. */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\n"
literal|"If you're running this on a disk with data you wish to save\n"
literal|"then WE STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before\n"
literal|"proceeding!\n\n"
literal|"We can take no responsibility for lost disk contents!"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelCommit
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't make filesystems properly.  Aborting."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
elseif|else
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"installInitial: Scribbled successfully on the disk(s)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copySelf
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the boot floppy onto the root file system.\n"
literal|"Aborting."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to chroot to %s - this is bad!"
argument_list|,
literal|"/mnt"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RUNNING_ON_ROOT
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
name|configResolv
argument_list|()
expr_stmt|;
comment|/* stick a helpful shell over on the 4th VTY */
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installFixitHoloShell
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installFixitCDROM
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please insert the second FreeBSD CDROM and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|mediaSetCDROM
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
operator|||
operator|!
name|mediaDevice
operator|||
operator|!
name|mediaDevice
operator|->
name|init
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
comment|/* If we can't initialize it, it's probably not a FreeBSD CDROM so punt on it */
if|if
condition|(
name|mediaDevice
condition|)
block|{
name|mediaDevice
operator|->
name|shutdown
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
name|mediaDevice
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the CDROM - do you want to try again?"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
else|else
break|break;
block|}
comment|/* Since the fixit code expects everything to be in /mnt2, and the CDROM mounting stuff /dist, do      * a little kludge dance here..      */
if|if
condition|(
name|symlink
argument_list|(
literal|"/dist"
argument_list|,
literal|"/mnt2"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to symlink /mnt2 to the CDROM mount point.  Please report this\n"
literal|"unexpected failure to freebsd-bugs@FreeBSD.org."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/*      * If /tmp points to /mnt2/tmp from a previous fixit floppy session, it's      * not very good for us if we point it to the CDROM now.  Rather make it      * a directory in the root MFS then.  Experienced admins will still be      * able to mount their disk's /tmp over this if they need.      */
if|if
condition|(
name|lstat
argument_list|(
literal|"/tmp"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
comment|/*      * Since setuid binaries ignore LD_LIBRARY_PATH, we indeed need the      * ld.so.hints file.  Fortunately, it's fairly small (~ 3 KB).      */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/var/run/ld.so.hints"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/var/run"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"/mnt2/sbin/ldconfig -s /mnt2/usr/lib"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: ldconfig could not create the ld.so hints file.\n"
literal|"Dynamic executables from the CDROM likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Yet another iggly hardcoded pathname. */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/usr/libexec/ld.so"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/usr/libexec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
literal|"/mnt2/usr/libexec/ld.so"
argument_list|,
literal|"/usr/libexec/ld.so"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: could not create the symlink for ld.so.\n"
literal|"Dynamic executables from the CDROM likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
name|fixit_common
argument_list|()
expr_stmt|;
name|mediaDevice
operator|->
name|shutdown
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the FreeBSD CDROM now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installFixitFloppy
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|ufs_args
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|fspec
operator|=
literal|"/dev/fd0"
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please insert a writable fixit floppy and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_UFS
argument_list|,
literal|"/mnt2"
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
name|msgConfirm
argument_list|(
literal|"An attempt to mount the fixit floppy failed, maybe the filesystem\n"
literal|"is unclean.  Trying a forcible mount as a last resort..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount
argument_list|(
name|MOUNT_UFS
argument_list|,
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the fixit floppy - do you want to try again?"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/tmp"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/tmp"
argument_list|,
literal|"/tmp"
argument_list|)
expr_stmt|;
name|fixit_common
argument_list|()
expr_stmt|;
name|unmount
argument_list|(
literal|"/mnt2"
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the fixit floppy now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * The common code for both fixit variants.  */
end_comment

begin_function
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|child
decl_stmt|;
name|int
name|waitstatus
decl_stmt|;
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
condition|)
block|{
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  Was unable to create a /var/tmp/vi.recover directory.\n"
literal|"vi will kvetch and moan about it as a result but should still\n"
literal|"be essentially usable."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/bin"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|Mkdir
argument_list|(
literal|"/bin"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/stand/sh"
argument_list|,
literal|"/bin/sh"
argument_list|)
expr_stmt|;
comment|/* Link the /etc/ files */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/etc"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
name|msgConfirm
argument_list|(
literal|"Unable to create an /etc directory!  Things are weird on this floppy.."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/spwd.db"
argument_list|,
literal|"/etc/spwd.db"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/protocols"
argument_list|,
literal|"/etc/protocols"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/services"
argument_list|,
literal|"/etc/services"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
name|msgConfirm
argument_list|(
literal|"Couldn't symlink the /etc/ files!  I'm not sure I like this.."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
name|create_termcap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|termios
name|foo
decl_stmt|;
specifier|extern
name|int
name|login_tty
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|getdtablesize
argument_list|()
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ttyv3"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DebugFD
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit: I can't set the controlling terminal.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|foo
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|foo
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|'\010'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|foo
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to set erase character.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to get terminal attributes!\n"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
literal|"/bin:/sbin:/usr/bin:/usr/sbin:/stand:"
literal|"/mnt2/stand:/mnt2/bin:/mnt2/sbin:/mnt2/usr/bin:/mnt2/usr/sbin"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* use the .profile from the fixit medium */
name|setenv
argument_list|(
literal|"HOME"
argument_list|,
literal|"/mnt2"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"fixit shell: Failed to execute shell!\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
else|else
block|{
name|msgNotify
argument_list|(
literal|"Waiting for fixit shell to exit.  Go to VTY4 now by\n"
literal|"typing ALT-F4.  When you are done, type ``exit'' to exit\n"
literal|"the fixit shell and be returned here."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|waitstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|installExpress
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"express"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
name|i
operator||=
name|DITEM_LEAVE_MENU
expr_stmt|;
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
block|}
return|return
name|i
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_comment
comment|/* Novice mode installation */
end_comment

begin_function
name|int
name|installNovice
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"novice"
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"In the next menu, you will need to set up a DOS-style (\"fdisk\") partitioning\n"
literal|"scheme for your hard disk.  If you simply wish to devote all disk space\n"
literal|"to FreeBSD (overwriting anything else that might be on the disk(s) selected)\n"
literal|"then use the (A)ll command to select the default partitioning scheme followed\n"
literal|"by a (Q)uit.  If you wish to allocate only free space to FreeBSD, move to a\n"
literal|"partition marked \"unused\" and use the (C)reate command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Next, you need to create BSD partitions inside of the fdisk partition(s)\n"
literal|"just created.  If you have a reasonable amount of disk space (200MB or more)\n"
literal|"and don't have any special requirements, simply use the (A)uto command to\n"
literal|"allocate space automatically.  If you have more specific needs or just don't\n"
literal|"care for the layout chosen by (A)uto, press F1 for more information on\n"
literal|"manual layout."
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Installation completed with some errors.  You may wish to\n"
literal|"scroll through the debugging messages on VTY1 with the\n"
literal|"scroll-lock feature.  You can also chose \"No\" at the next\n"
literal|"prompt and go back into the installation menus to try and retry\n"
literal|"whichever operations have failed."
argument_list|)
expr_stmt|;
return|return
name|i
operator||
name|DITEM_RESTORE
return|;
block|}
else|else
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Congratulations!  You now have FreeBSD installed on your system.\n\n"
literal|"We will now move on to the final configuration questions.\n"
literal|"For any option you do not wish to configure, simply select\n"
literal|"No.\n\n"
literal|"If you wish to re-enter this utility after the system is up, you\n"
literal|"may do so by typing: /stand/sysinstall."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_FTP
operator|&&
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_NFS
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure any Ethernet or SLIP/PPP network devices?"
argument_list|)
condition|)
block|{
name|Device
modifier|*
name|tmp
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|tcpDeviceSelect
argument_list|()
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to bring the %s interface up right now?"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
condition|)
if|if
condition|(
operator|!
name|tmp
operator|->
name|init
argument_list|(
name|tmp
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Initialization of %s device failed."
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Will this machine be an IP gateway (e.g. will it forward packets\n"
literal|"between interfaces)?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"gateway"
argument_list|,
literal|"YES"
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Do you want to allow anonymous FTP connections to this machine?"
argument_list|)
condition|)
name|configAnonFTP
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Do you want to configure this machine as an NFS server?"
argument_list|)
condition|)
name|configNFSServer
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Do you want to configure this machine as an NFS client?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"nfs_client"
argument_list|,
literal|"YES"
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to customize your system console settings?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuSyscons
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to set this machine's time zone now?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|systemExecute
argument_list|(
literal|"tzsetup"
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Does this system have a mouse attached to it?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMouse
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
comment|/* Now would be a good time to checkpoint the configuration data */
name|configRC_conf
argument_list|(
literal|"/etc/rc.conf"
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_XIG_ENVIRONMENT
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure your X server at this time?"
argument_list|)
condition|)
name|configXEnvironment
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"The FreeBSD package collection is a collection of hundreds of ready-to-run\n"
literal|"applications, from text editors to games to WEB servers and more.  Would you\n"
literal|"like to browse the collection now?"
argument_list|)
condition|)
name|configPackages
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to add any initial user accounts to the system?\n"
literal|"Adding at least one account for yourself at this stage is suggested\n"
literal|"since working as the \"root\" user is dangerous (it is easy to do\n"
literal|"things which adversely affect the entire system)."
argument_list|)
condition|)
name|configUsers
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Now you must set the system manager's password.\n"
literal|"This is the password you'll use to log in as \"root\"."
argument_list|)
expr_stmt|;
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|systemExecute
argument_list|(
literal|"passwd root"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"root_password"
argument_list|,
literal|"YES"
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to register your FreeBSD system at this time?\n\n"
literal|"PLEASE, take just 5 minutes to do this.  If we're ever to get any\n"
literal|"significant base of commercial software for FreeBSD, we need to\n"
literal|"be able to provide more information about the size of our user community.\n"
literal|"This is where your registration can really help us, and you can also\n"
literal|"sign up for the new FreeBSD newsletter (its free!) at the same time.\n"
argument_list|)
condition|)
name|configRegister
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"OK, but if you should change your mind then you always can register\n"
literal|"later by typing ``/stand/sysinstall register'' or by simply visiting our\n"
literal|"web site at http://www.freebsd.org/register.html"
argument_list|)
expr_stmt|;
comment|/* XXX Put whatever other nice configuration questions you'd like to ask the user here XXX */
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|DITEM_LEAVE_MENU
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_comment
comment|/* The version of commit we call from the Install Custom menu */
end_comment

begin_function
name|int
name|installCustomCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
name|msgConfirm
argument_list|(
literal|"The commit operation completed with errors.  Not\n"
literal|"updating /etc files."
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * What happens when we finally decide to going ahead with the installation.  *  * This is broken into multiple stages so that the user can do a full  * installation but come back here again to load more distributions,  * perhaps from a different media type.  This would allow, for  * example, the user to load the majority of the system from CDROM and  * then use ftp to load just the DES dist.  */
end_comment

begin_function
name|int
name|installCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|Boolean
name|need_bin
decl_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
name|distConfig
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
if|if
condition|(
operator|!
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuDistributions
argument_list|,
name|FALSE
argument_list|)
operator|&&
operator|!
name|Dists
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
name|str
operator|=
name|variable_get
argument_list|(
name|SYSTEM_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"installCommit: System state is `%s'\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|RunningAsInit
condition|)
block|{
comment|/* Do things we wouldn't do to a multi-user system */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installInitial
argument_list|()
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|configFstab
argument_list|()
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
block|}
name|try_media
label|:
if|if
condition|(
operator|!
name|mediaDevice
operator|->
name|init
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Unable to initialize selected media. Would you like to\n"
literal|"adjust your media configuration and try again?"
argument_list|)
condition|)
block|{
name|mediaDevice
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
else|else
goto|goto
name|try_media
goto|;
block|}
else|else
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
name|need_bin
operator|=
name|Dists
operator|&
name|DIST_BIN
expr_stmt|;
name|i
operator|=
name|distExtractAll
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
if|if
condition|(
name|need_bin
operator|&&
operator|!
operator|(
name|Dists
operator|&
name|DIST_BIN
operator|)
condition|)
name|i
operator|=
name|installFixup
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_FAILURE
condition|?
literal|"error-install"
else|:
literal|"full-install"
argument_list|)
expr_stmt|;
comment|/* We always try to install X with the XiG product */
ifdef|#
directive|ifdef
name|USE_XIG_ENVIRONMENT
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
name|configXEnvironment
argument_list|(
name|self
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|i
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Final menu of last resort */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Visit the general configuration menu for a chance to set\n"
literal|"any last options?"
argument_list|)
condition|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|savescr
argument_list|()
decl_stmt|;
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuConfigure
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|restorescr
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|configRC_conf
argument_list|(
literal|"/etc/rc.conf"
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|installFixup
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/kernel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_readable
argument_list|(
literal|"/kernel.GENERIC"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SAVE_USERCONFIG
comment|/* Snapshot any boot -c changes back to the GENERIC kernel */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_RELNAME
argument_list|)
argument_list|,
name|RELEASE_NAME
argument_list|)
condition|)
name|save_userconfig_to_kernel
argument_list|(
literal|"/kernel.GENERIC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vsystem
argument_list|(
literal|"cp -p /kernel.GENERIC /kernel"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to link /kernel into place!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"Can't find a kernel image to link to on the root file system!\n"
literal|"You're going to have a hard time getting this system to\n"
literal|"boot from the hard disk, I'm afraid!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
comment|/* Resurrect /dev after bin distribution screws it up */
if|if
condition|(
name|RunningAsInit
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Remaking all devices.. Please wait!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV all"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"MAKEDEV returned non-zero status"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|msgNotify
argument_list|(
literal|"Resurrecting /dev entries for slices.."
argument_list|)
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devs
condition|)
name|msgFatal
argument_list|(
literal|"Couldn't get a disk device list!"
argument_list|)
expr_stmt|;
comment|/* Resurrect the slices that the former clobbered */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Disk
modifier|*
name|disk
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Making slice entries for %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV %sh"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make slice entries for %s!"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
block|}
block|}
comment|/* XXX Do all the last ugly work-arounds here which we'll try and excise someday right?? XXX */
name|msgNotify
argument_list|(
literal|"Fixing permissions.."
argument_list|)
expr_stmt|;
comment|/* BOGON #1:  XFree86 extracting /usr/X11R6 with root-only perms */
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
block|{
name|vsystem
argument_list|(
literal|"chmod -R a+r /usr/X11R6"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"find /usr/X11R6 -type d | xargs chmod a+x"
argument_list|)
expr_stmt|;
block|}
comment|/* BOGON #2: We leave /etc in a bad state */
name|chmod
argument_list|(
literal|"/etc"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
comment|/* BOGON #3: No /var/db/mountdtab complains */
name|Mkdir
argument_list|(
literal|"/var/db"
argument_list|)
expr_stmt|;
name|creat
argument_list|(
literal|"/var/db/mountdtab"
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
comment|/* BOGON #4: /compat created by default in root fs */
name|Mkdir
argument_list|(
argument|/usr/compat
literal|"); 	vsystem("
argument|ln -s /usr/compat /compat
literal|");  	/* Now run all the mtree stuff to fix things up */         vsystem("
argument|mtree -deU -f /etc/mtree/BSD.root.dist -p /
literal|");         vsystem("
argument|mtree -deU -f /etc/mtree/BSD.var.dist -p /var
literal|");         vsystem("
argument|mtree -deU -f /etc/mtree/BSD.usr.dist -p /usr
literal|");     }     return DITEM_SUCCESS; }  /* Go newfs and/or mount all the filesystems we've been asked to */ int installFilesystems(dialogMenuItem *self) {     int i;     Disk *disk;     Chunk *c1, *c2, *rootdev, *swapdev, *usrdev, *vardev;     Device **devs;     PartInfo *root;     char dname[80], *str;     extern int MakeDevChunk(Chunk *c, char *n);     Boolean upgrade = FALSE;      /* If we've already done this, bail out */     if ((str = variable_get(DISK_LABELLED))&& !strcmp(str, "
argument|written
literal|")) 	return DITEM_SUCCESS;      str = variable_get(SYSTEM_STATE);      if (!checkLabels(TRUE,&rootdev,&swapdev,&usrdev,&vardev)) 	return DITEM_FAILURE;      if (rootdev) 	root = (PartInfo *)rootdev->private_data;     else 	root = NULL;      command_clear();     upgrade = str&& !strcmp(str, "
argument|upgrade
literal|");      if (swapdev&& RunningAsInit) { 	/* As the very first thing, try to get ourselves some swap space */ 	sprintf(dname, "
argument|/dev/%s
literal|", swapdev->name); 	if (!Fake&& (!MakeDevChunk(swapdev, "
argument|/dev
literal|") || !file_readable(dname))) { 	    msgConfirm("
argument|Unable to make device node for %s in /dev!\n
literal|" 		       "
argument|The creation of filesystems will be aborted.
literal|", dname); 	    return DITEM_FAILURE; 	}  	if (!Fake) { 	    if (!swapon(dname)) 		msgNotify("
argument|Added %s as initial swap device
literal|", dname); 	    else 		msgConfirm("
argument|WARNING!  Unable to swap to %s: %s\n
literal|" 			   "
argument|This may cause the installation to fail at some point\n
literal|" 			   "
argument|if you don
literal|'t have a lot of memory.", dname, strerror(errno)); 	}     }      if (rootdev&& RunningAsInit) { 	/* Next, create and/or mount the root device */ 	sprintf(dname, "/dev/r%sa", rootdev->disk->name); 	if (!Fake&& (!MakeDevChunk(rootdev, "/dev") || !file_readable(dname))) { 	    msgConfirm("Unable to make device node for %s in /dev!\n" 		       "The creation of filesystems will be aborted.", dname); 	    return DITEM_FAILURE; 	} 	if (strcmp(root->mountpoint, "/")) 	    msgConfirm("Warning: %s is marked as a root partition but is mounted on %s", rootdev->name, root->mountpoint);  	if (root->newfs) { 	    int i;  	    msgNotify("Making a new root filesystem on %s", dname); 	    i = vsystem("%s %s", root->newfs_cmd, dname); 	    if (i) { 		msgConfirm("Unable to make new root filesystem on %s!\n" 			   "Command returned status %d", dname, i); 		return DITEM_FAILURE; 	    } 	} 	else { 	    if (!upgrade) { 		msgConfirm("Warning:  Using existing root partition.  It will be assumed\n" 			   "that you have the appropriate device entries already in /dev."); 	    } 	    msgNotify("Checking integrity of existing %s filesystem.", dname); 	    i = vsystem("fsck -y %s", dname); 	    if (i) 		msgConfirm("Warning: fsck returned status of %d for %s.\n" 			   "This partition may be unsafe to use.", i, dname); 	}  	/* Switch to block device */ 	sprintf(dname, "/dev/%sa", rootdev->disk->name); 	if (Mount("/mnt", dname)) { 	    msgConfirm("Unable to mount the root file system on %s!  Giving up.", dname); 	    return DITEM_FAILURE; 	}     }      /* Now buzz through the rest of the partitions and mount them too */     devs = deviceFind(NULL, DEVICE_TYPE_DISK);     for (i = 0; devs[i]; i++) { 	if (!devs[i]->enabled) 	    continue;  	disk = (Disk *)devs[i]->private; 	if (!disk->chunks) { 	    msgConfirm("No chunk list found for %s!", disk->name); 	    return DITEM_FAILURE; 	} 	if (RunningAsInit&& root&& (root->newfs || upgrade)) { 	    Mkdir("/mnt/dev"); 	    if (!Fake) 		MakeDevDisk(disk, "/mnt/dev"); 	} 	else if (!RunningAsInit&& !Fake) 	    MakeDevDisk(disk, "/dev");  	for (c1 = disk->chunks->part; c1; c1 = c1->next) { 	    if (c1->type == freebsd) { 		for (c2 = c1->part; c2; c2 = c2->next) { 		    if (c2->type == part&& c2->subtype != FS_SWAP&& c2->private_data) { 			PartInfo *tmp = (PartInfo *)c2->private_data;  			/* Already did root */ 			if (c2 == rootdev) 			    continue;  			if (tmp->newfs) 			    command_shell_add(tmp->mountpoint, "%s %s/dev/r%s", tmp->newfs_cmd, RunningAsInit ? "/mnt" : "", c2->name); 			else 			    command_shell_add(tmp->mountpoint, "fsck -y %s/dev/r%s", RunningAsInit ? "/mnt" : "", c2->name); 			command_func_add(tmp->mountpoint, Mount, c2->name); 		    } 		    else if (c2->type == part&& c2->subtype == FS_SWAP) { 			char fname[80]; 			int i;  			if (c2 == swapdev) 			    continue; 			sprintf(fname, "%s/dev/%s", RunningAsInit ? "/mnt" : "", c2->name); 			i = (Fake || swapon(fname)); 			if (!i) 			    msgNotify("Added %s as an additional swap device", fname); 			else 			    msgConfirm("Unable to add %s as a swap device: %s", fname, strerror(errno)); 		    } 		} 	    } 	    else if (c1->type == fat&& c1->private_data&& (root->newfs || upgrade)) { 		char name[FILENAME_MAX];  		sprintf(name, "%s/%s", RunningAsInit ? "/mnt" : "", ((PartInfo *)c1->private_data)->mountpoint); 		Mkdir(name); 	    } 	}     }      if (RunningAsInit) { 	msgNotify("Copying initial device files.."); 	/* Copy the boot floppy'
argument|s dev files */ 	if ((root->newfs || upgrade)&& vsystem(
literal|"find -x /dev | cpio %s -pdum /mnt"
argument|, cpioVerbosity())) { 	    msgConfirm(
literal|"Couldn't clone the /dev files!"
argument|); 	    return DITEM_FAILURE; 	}     }      command_sort();     command_execute();     return DITEM_SUCCESS; }
comment|/* Initialize various user-settable values to their defaults */
argument|int installVarDefaults(dialogMenuItem *self) {     char *cp;
comment|/* Set default startup options */
argument|variable_set2(VAR_ROUTER_ENABLE,
literal|"NO"
argument|);     variable_set2(VAR_RELNAME,			RELEASE_NAME);     variable_set2(VAR_CPIO_VERBOSITY,
literal|"high"
argument|);     variable_set2(VAR_TAPE_BLOCKSIZE,		DEFAULT_TAPE_BLOCKSIZE);     variable_set2(VAR_INSTALL_ROOT,
literal|"/"
argument|);     variable_set2(VAR_INSTALL_CFG,
literal|"install.cfg"
argument|);     cp = getenv(
literal|"EDITOR"
argument|);     if (!cp) 	cp =
literal|"/usr/bin/ee"
argument|;     variable_set2(VAR_EDITOR,			cp);     variable_set2(VAR_FTP_USER,
literal|"ftp"
argument|);     variable_set2(VAR_BROWSER_PACKAGE,		PACKAGE_LYNX);     variable_set2(VAR_BROWSER_BINARY,
literal|"/usr/local/bin/lynx"
argument|);     variable_set2(VAR_FTP_STATE,
literal|"passive"
argument|);     variable_set2(VAR_NFS_SECURE,
literal|"YES"
argument|);     variable_set2(VAR_PKG_TMPDIR,
literal|"/usr/tmp"
argument|);     variable_set2(VAR_GATED_PKG,		PACKAGE_GATED);     variable_set2(VAR_PCNFSD_PKG,		PACKAGE_PCNFSD);     variable_set2(VAR_MEDIA_TIMEOUT,		itoa(MEDIA_TIMEOUT));     if (getpid() !=
literal|1
argument|) 	variable_set2(SYSTEM_STATE,
literal|"update"
argument|);     else 	variable_set2(SYSTEM_STATE,
literal|"init"
argument|);     return DITEM_SUCCESS; }
comment|/* Load the environment up from various system configuration files */
argument|void installEnvironment(void) {     if (file_readable(
literal|"/etc/rc.conf"
argument|)) 	configEnvironmentRC_conf(
literal|"/etc/rc.conf"
argument|);     if (file_readable(
literal|"/etc/resolv.conf"
argument|)) 	configEnvironmentResolv(
literal|"/etc/resolv.conf"
argument|); }
comment|/* Copy the boot floppy contents into /stand */
argument|Boolean copySelf(void) {     int i;      msgWeHaveOutput(
literal|"Copying the boot floppy to /stand on root filesystem"
argument|);     i = vsystem(
literal|"find -x /stand | cpio %s -pdum /mnt"
argument|, cpioVerbosity());     if (i) { 	msgConfirm(
literal|"Copy returned error status of %d!"
argument|, i); 	return FALSE;     }
comment|/* Copy the /etc files into their rightful place */
argument|if (vsystem(
literal|"cd /mnt/stand; find etc | cpio %s -pdum /mnt"
argument|, cpioVerbosity())) { 	msgConfirm(
literal|"Couldn't copy up the /etc files!"
argument|); 	return TRUE;     }     return TRUE; }  static void create_termcap(void) {     FILE *fp;      const char *caps[] = { 	termcap_vt100
argument_list|,
argument|termcap_cons25
argument_list|,
argument|termcap_cons25_m
argument_list|,
argument|termcap_cons25r
argument_list|,
argument|termcap_cons25r_m
argument_list|,
argument|termcap_cons25l1
argument_list|,
argument|termcap_cons25l1_m
argument_list|,
argument|NULL
argument_list|,
argument|};     const char **cp;      if (!file_readable(TERMCAP_FILE)) { 	Mkdir(
literal|"/usr/share/misc"
argument|); 	fp = fopen(TERMCAP_FILE,
literal|"w"
argument|); 	if (!fp) { 	    msgConfirm(
literal|"Unable to initialize termcap file. Some screen-oriented\nutilities may not work."
argument|); 	    return; 	} 	cp = caps; 	while (*cp) 	    fprintf(fp,
literal|"%s\n"
argument|, *(cp++)); 	fclose(fp);     } }
ifdef|#
directive|ifdef
name|SAVE_USERCONFIG
argument|static void save_userconfig_to_kernel(char *kern) {     struct kernel *core
argument_list|,
argument|*boot;     struct list *c_isa
argument_list|,
argument|*b_isa
argument_list|,
argument|*c_dev
argument_list|,
argument|*b_dev;     int i
argument_list|,
argument|d;      if ((core = uc_open(
literal|"-incore"
argument|)) == NULL) { 	msgDebug(
literal|"save_userconf: Can't read in-core information for kernel.\n"
argument|); 	return;     }      if ((boot = uc_open(kern)) == NULL) { 	msgDebug(
literal|"save_userconf: Can't read device information for kernel image %s\n"
argument|, kern); 	return;     }      msgNotify(
literal|"Saving any boot -c changes to new kernel..."
argument|);     c_isa = uc_getdev(core,
literal|"-isa"
argument|);     b_isa = uc_getdev(boot,
literal|"-isa"
argument|);     if (isDebug()) 	msgDebug(
literal|"save_userconf: got %d ISA device entries from core, %d from boot.\n"
argument|, c_isa->ac, b_isa->ac);     for (d =
literal|0
argument|; d< c_isa->ac; d++) { 	if (isDebug()) 	    msgDebug(
literal|"save_userconf: ISA device loop, c_isa->av[%d] = %s\n"
argument|, d, c_isa->av[d]); 	if (strcmp(c_isa->av[d],
literal|"npx0"
argument|)) {
comment|/* special case npx0, which mucks with its id_irq member */
argument|c_dev = uc_getdev(core, c_isa->av[d]); 	    b_dev = uc_getdev(boot, b_isa->av[d]); 	    if (!c_dev || !b_dev) { 		msgDebug(
literal|"save_userconf: c_dev: %x b_dev: %x\n"
argument|, c_dev, b_dev); 		continue; 	    } 	    if (isDebug()) 		msgDebug(
literal|"save_userconf: ISA device %s: %d config parameters (core), %d (boot)\n"
argument|, 			 c_isa->av[d], c_dev->ac, b_dev->ac); 	    for (i =
literal|0
argument|; i< c_dev->ac; i++) { 		if (isDebug()) 		    msgDebug(
literal|"save_userconf: c_dev->av[%d] = %s, b_dev->av[%d] = %s\n"
argument|, i, c_dev->av[i], i, b_dev->av[i]); 		if (strcmp(c_dev->av[i], b_dev->av[i])) { 		    if (isDebug()) 			msgDebug(
literal|"save_userconf: %s (boot) -> %s (core)\n"
argument|, 				 c_dev->av[i], b_dev->av[i]); 		    isa_setdev(boot, c_dev); 		} 	    } 	} 	else { 	    if (isDebug()) 		msgDebug(
literal|"skipping npx0\n"
argument|); 	}     }     if (isDebug()) 	msgDebug(
literal|"Closing kernels\n"
argument|);     uc_close(core,
literal|0
argument|);     uc_close(boot,
literal|1
argument|); }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

