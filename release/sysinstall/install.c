begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $FreeBSD$  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_define
define|#
directive|define
name|MSDOSFS
end_define

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/msdosfsmount.h>
end_include

begin_undef
undef|#
directive|undef
name|MSDOSFS
end_undef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_comment
comment|/* Hack for rsaref package add, which displays interactive license.  * Used by package.c  */
end_comment

begin_decl_stmt
name|int
name|_interactiveHack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|FixItMode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TERMCAP_FILE
value|"/usr/share/misc/termcap"
end_define

begin_function_decl
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|Boolean
name|checkLabels
parameter_list|(
name|Boolean
name|whinge
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|rdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|sdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|udev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|vdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|tdev
parameter_list|,
name|Chunk
modifier|*
modifier|*
name|hdev
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Boolean
name|status
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|,
modifier|*
name|usrdev
decl_stmt|,
modifier|*
name|vardev
decl_stmt|,
modifier|*
name|tmpdev
decl_stmt|,
modifier|*
name|homedev
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't allow whinging if noWarn is set */
if|if
condition|(
name|variable_get
argument_list|(
name|VAR_NO_WARN
argument_list|)
condition|)
name|whinge
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|rdev
condition|)
operator|*
name|rdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sdev
condition|)
operator|*
name|sdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|udev
condition|)
operator|*
name|udev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vdev
condition|)
operator|*
name|vdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tdev
condition|)
operator|*
name|tdev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hdev
condition|)
operator|*
name|hdev
operator|=
name|NULL
expr_stmt|;
name|rootdev
operator|=
name|swapdev
operator|=
name|usrdev
operator|=
name|vardev
operator|=
name|tmpdev
operator|=
name|homedev
operator|=
name|NULL
expr_stmt|;
comment|/* We don't need to worry about root/usr/swap if we're already multiuser */
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|status
return|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private_data
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
block|{
if|if
condition|(
name|rootdev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one root device set?!\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|rootdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found rootdev at %s!\n"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/usr"
argument_list|)
condition|)
block|{
if|if
condition|(
name|usrdev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /usr filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|usrdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found usrdev at %s!\n"
argument_list|,
name|usrdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/var"
argument_list|)
condition|)
block|{
if|if
condition|(
name|vardev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /var filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|vardev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found vardev at %s!\n"
argument_list|,
name|vardev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/tmp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmpdev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /tmp filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|tmpdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found tmpdev at %s!\n"
argument_list|,
name|tmpdev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|,
literal|"/home"
argument_list|)
condition|)
block|{
if|if
condition|(
name|homedev
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /home filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|homedev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found homedev at %s!\n"
argument_list|,
name|homedev
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
operator|&&
operator|!
name|swapdev
condition|)
block|{
name|swapdev
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found swapdev at %s!\n"
argument_list|,
name|swapdev
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Copy our values over */
if|if
condition|(
name|rdev
condition|)
operator|*
name|rdev
operator|=
name|rootdev
expr_stmt|;
if|if
condition|(
name|sdev
condition|)
operator|*
name|sdev
operator|=
name|swapdev
expr_stmt|;
if|if
condition|(
name|udev
condition|)
operator|*
name|udev
operator|=
name|usrdev
expr_stmt|;
if|if
condition|(
name|vdev
condition|)
operator|*
name|vdev
operator|=
name|vardev
expr_stmt|;
if|if
condition|(
name|tdev
condition|)
operator|*
name|tdev
operator|=
name|tmpdev
expr_stmt|;
if|if
condition|(
name|hdev
condition|)
operator|*
name|hdev
operator|=
name|homedev
expr_stmt|;
if|if
condition|(
operator|!
name|rootdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n"
literal|"in the label editor."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|swapdev
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No swap devices found - you must create at least one\n"
literal|"swap partition."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
name|int
name|status
init|=
name|DITEM_SUCCESS
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return
name|DITEM_SUCCESS
return|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\n"
literal|"the installation."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/* If it's labelled, assume it's also partitioned */
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
name|variable_set2
argument_list|(
name|DISK_PARTITIONED
argument_list|,
literal|"yes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we refuse to proceed, bail. */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|VAR_NO_WARN
argument_list|)
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\n"
literal|"If you're running this on a disk with data you wish to save\n"
literal|"then WE STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before\n"
literal|"proceeding!\n\n"
literal|"We can take no responsibility for lost disk contents!"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelCommit
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't make filesystems properly.  Aborting."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|copySelf
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"installInitial: Couldn't clone the boot floppy onto the\n"
literal|"root file system.  Aborting!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|Restarting
operator|&&
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"installInitial: Unable to chroot to %s - this is bad!"
argument_list|,
literal|"/mnt"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RUNNING_ON_ROOT
argument_list|,
literal|"yes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure various files in /etc */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|configResolv
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
name|status
operator|=
name|DITEM_FAILURE
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|configFstab
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
name|status
operator|=
name|DITEM_FAILURE
expr_stmt|;
comment|/* stick a helpful shell over on the 4th VTY */
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|VAR_NO_HOLOSHELL
argument_list|)
condition|)
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|installFixitHoloShell
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|FixItMode
operator|=
literal|1
expr_stmt|;
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
name|FixItMode
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|installFixitCDROM
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please insert a FreeBSD live filesystem CD/DVD and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|mediaSetCDROM
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
operator|||
operator|!
name|mediaDevice
operator|||
operator|!
name|mediaDevice
operator|->
name|init
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
comment|/* If we can't initialize it, it's probably not a FreeBSD CDROM so punt on it */
name|mediaClose
argument_list|()
expr_stmt|;
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Unable to mount the CDROM - do you want to try again?"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
else|else
break|break;
block|}
comment|/* Since the fixit code expects everything to be in /mnt2, and the CDROM mounting stuff /dist, do      * a little kludge dance here..      */
if|if
condition|(
name|symlink
argument_list|(
literal|"/dist"
argument_list|,
literal|"/mnt2"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to symlink /mnt2 to the disc mount point.  Please report this\n"
literal|"unexpected failure to freebsd-bugs@FreeBSD.org."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/*      * If /tmp points to /mnt2/tmp from a previous fixit floppy session, it's      * not very good for us if we point it to the CDROM now.  Rather make it      * a directory in the root MFS then.  Experienced admins will still be      * able to mount their disk's /tmp over this if they need.      */
if|if
condition|(
name|lstat
argument_list|(
literal|"/tmp"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
comment|/*      * Since setuid binaries ignore LD_LIBRARY_PATH, we indeed need the      * ld.so.hints file.  Fortunately, it's fairly small (~ 3 KB).      */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/var/run/ld.so.hints"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/var/run"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"/mnt2/sbin/ldconfig -s /mnt2/usr/lib"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: ldconfig could not create the ld.so hints file.\n"
literal|"Dynamic executables from the disc likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Yet more iggly hardcoded pathnames. */
name|Mkdir
argument_list|(
literal|"/usr/libexec"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/usr/libexec/ld.so"
argument_list|)
operator|&&
name|file_readable
argument_list|(
literal|"/mnt2/usr/libexec/ld.so"
argument_list|)
condition|)
block|{
if|if
condition|(
name|symlink
argument_list|(
literal|"/mnt2/usr/libexec/ld.so"
argument_list|,
literal|"/usr/libexec/ld.so"
argument_list|)
condition|)
name|msgDebug
argument_list|(
literal|"Couldn't link to ld.so - not necessarily a problem for ELF\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/usr/libexec/ld-elf.so.1"
argument_list|)
condition|)
block|{
if|if
condition|(
name|symlink
argument_list|(
literal|"/mnt2/usr/libexec/ld-elf.so.1"
argument_list|,
literal|"/usr/libexec/ld-elf.so.1"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: could not create the symlink for ld-elf.so.1\n"
literal|"Dynamic executables from the disc likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* optional nicety */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/usr/bin/vi"
argument_list|)
condition|)
name|symlink
argument_list|(
literal|"/mnt2/usr/bin/vi"
argument_list|,
literal|"/usr/bin/vi"
argument_list|)
expr_stmt|;
name|fixit_common
argument_list|()
expr_stmt|;
name|mediaClose
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the FreeBSD fixit CDROM/DVD now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|installFixitFloppy
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|ufs_args
name|args
decl_stmt|;
specifier|extern
name|char
modifier|*
name|distWanted
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
comment|/* Try to open the floppy drive */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|mediaSetFloppy
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
operator|||
operator|!
name|mediaDevice
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to set media device to floppy."
argument_list|)
expr_stmt|;
name|mediaClose
argument_list|()
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|fspec
operator|=
name|mediaDevice
operator|->
name|devname
expr_stmt|;
name|mediaDevice
operator|->
name|private
operator|=
literal|"/mnt2"
expr_stmt|;
name|distWanted
operator|=
name|NULL
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|DEVICE_INIT
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"The attempt to mount the fixit floppy failed, bad floppy\n"
literal|"or unclean filesystem.  Do you want to try again?"
argument_list|)
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/tmp"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/tmp"
argument_list|,
literal|"/tmp"
argument_list|)
expr_stmt|;
name|fixit_common
argument_list|()
expr_stmt|;
name|mediaClose
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the fixit floppy now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * The common code for both fixit variants.  */
end_comment

begin_function
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|child
decl_stmt|;
name|int
name|waitstatus
decl_stmt|;
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
condition|)
block|{
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  Was unable to create a /var/tmp/vi.recover directory.\n"
literal|"vi will kvetch and moan about it as a result but should still\n"
literal|"be essentially usable."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/bin"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|Mkdir
argument_list|(
literal|"/bin"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/stand/sh"
argument_list|,
literal|"/bin/sh"
argument_list|)
expr_stmt|;
comment|/* Link the /etc/ files */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/etc"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
name|msgConfirm
argument_list|(
literal|"Unable to create an /etc directory!  Things are weird on this floppy.."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/spwd.db"
argument_list|,
literal|"/etc/spwd.db"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/protocols"
argument_list|,
literal|"/etc/protocols"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/services"
argument_list|,
literal|"/etc/services"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
name|msgConfirm
argument_list|(
literal|"Couldn't symlink the /etc/ files!  I'm not sure I like this.."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
name|create_termcap
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
name|systemSuspendDialog
argument_list|()
expr_stmt|;
comment|/* must be before the fork() */
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|termios
name|foo
decl_stmt|;
specifier|extern
name|int
name|login_tty
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|getdtablesize
argument_list|()
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/console"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ttyv3"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DebugFD
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit: I can't set the controlling terminal.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|foo
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|foo
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|'\010'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|foo
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to set erase character.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to get terminal attributes!\n"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
literal|"/bin:/sbin:/usr/bin:/usr/sbin:/stand:"
literal|"/mnt2/stand:/mnt2/bin:/mnt2/sbin:/mnt2/usr/bin:/mnt2/usr/sbin"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"MAKEDEVPATH"
argument_list|,
literal|"/sbin:/bin:/stand:"
literal|"/mnt2/sbin:/mnt2/bin:/mnt2/stand"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Waiting for fixit shell to exit.\n"
literal|"When you are done, type ``exit'' to exit\n"
literal|"the fixit shell and be returned here.\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* use the .profile from the fixit medium */
name|setenv
argument_list|(
literal|"HOME"
argument_list|,
literal|"/mnt2"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"fixit shell: Failed to execute shell!\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"standard"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Waiting for fixit shell to exit.  Go to VTY4 now by\n"
literal|"typing ALT-F4.  When you are done, type ``exit'' to exit\n"
literal|"the fixit shell and be returned here\n."
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|waitstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
name|systemResumeDialog
argument_list|()
expr_stmt|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|installExpress
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"express"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__alpha__
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
endif|#
directive|endif
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
name|i
operator||=
name|DITEM_LEAVE_MENU
expr_stmt|;
comment|/* Set default security level */
name|configSecurityModerate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Standard mode installation */
end_comment

begin_function
name|int
name|installStandard
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"standard"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|__alpha__
name|msgConfirm
argument_list|(
literal|"In the next menu, you will need to set up a DOS-style (\"fdisk\") partitioning\n"
literal|"scheme for your hard disk.  If you simply wish to devote all disk space\n"
literal|"to FreeBSD (overwriting anything else that might be on the disk(s) selected)\n"
literal|"then use the (A)ll command to select the default partitioning scheme followed\n"
literal|"by a (Q)uit.  If you wish to allocate only free space to FreeBSD, move to a\n"
literal|"partition marked \"unused\" and use the (C)reate command."
argument_list|)
expr_stmt|;
name|nodisks
label|:
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
if|if
condition|(
name|diskGetSelectCount
argument_list|(
operator|&
name|devs
argument_list|)
operator|<=
literal|0
operator|&&
name|tries
operator|<
literal|3
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to select some disks to operate on!  Be sure to use SPACE\n"
literal|"instead of RETURN in the disk selection menu when selecting a disk."
argument_list|)
expr_stmt|;
operator|++
name|tries
expr_stmt|;
goto|goto
name|nodisks
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__alpha__
name|msgConfirm
argument_list|(
literal|"Now you need to create BSD partitions on the disk which you are\n"
literal|"installing to.  If you have a reasonable amount of disk space (200MB or more)\n"
literal|"and don't have any special requirements, simply use the (A)uto command to\n"
literal|"allocate space automatically.  If you have more specific needs or just don't\n"
literal|"care for the layout chosen by (A)uto, press F1 for more information on\n"
literal|"manual layout."
argument_list|)
expr_stmt|;
else|#
directive|else
name|msgConfirm
argument_list|(
literal|"Now you need to create BSD partitions inside of the fdisk partition(s)\n"
literal|"just created.  If you have a reasonable amount of disk space (200MB or more)\n"
literal|"and don't have any special requirements, simply use the (A)uto command to\n"
literal|"allocate space automatically.  If you have more specific needs or just don't\n"
literal|"care for the layout chosen by (A)uto, press F1 for more information on\n"
literal|"manual layout."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
block|{
name|dialog_clear
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Installation completed with some errors.  You may wish to\n"
literal|"scroll through the debugging messages on VTY1 with the\n"
literal|"scroll-lock feature.  You can also choose \"No\" at the next\n"
literal|"prompt and go back into the installation menus to try and retry\n"
literal|"whichever operations have failed."
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
block|{
name|dialog_clear
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Congratulations!  You now have FreeBSD installed on your system.\n\n"
literal|"We will now move on to the final configuration questions.\n"
literal|"For any option you do not wish to configure, simply select\n"
literal|"No.\n\n"
literal|"If you wish to re-enter this utility after the system is up, you\n"
literal|"may do so by typing: /stand/sysinstall."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_FTP
operator|&&
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_NFS
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure any Ethernet or SLIP/PPP network devices?"
argument_list|)
condition|)
block|{
name|Device
modifier|*
name|tmp
init|=
name|tcpDeviceSelect
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
operator|!
operator|(
operator|(
name|DevInfo
operator|*
operator|)
name|tmp
operator|->
name|private
operator|)
operator|->
name|use_dhcp
operator|&&
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to bring the %s interface up right now?"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
condition|)
if|if
condition|(
operator|!
name|DEVICE_INIT
argument_list|(
name|tmp
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Initialization of %s device failed."
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want this machine to function as a network gateway?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"gateway_enable"
argument_list|,
literal|"YES"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to configure inetd and simple internet services?"
argument_list|)
condition|)
name|configInetd
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to have anonymous FTP access to this machine?"
argument_list|)
condition|)
name|configAnonFTP
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to configure this machine as an NFS server?"
argument_list|)
condition|)
name|configNFSServer
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to configure this machine as an NFS client?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"nfs_client_enable"
argument_list|,
literal|"YES"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to select a default security profile for\n"
literal|"this host (select No for \"moderate\" security)?"
argument_list|)
condition|)
name|configSecurityProfile
argument_list|(
name|self
argument_list|)
expr_stmt|;
else|else
name|configSecurityModerate
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Would you like to customize your system console settings?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuSyscons
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to set this machine's time zone now?"
argument_list|)
condition|)
name|systemExecute
argument_list|(
literal|"tzsetup"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to enable Linux binary compatibility?"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|configLinux
argument_list|(
name|self
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|msgNoYes
argument_list|(
literal|"Does this system have a USB mouse attached to it?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMouse
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Now would be a good time to checkpoint the configuration data */
name|configRC_conf
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure your X server at this time?"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|configXSetup
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"The FreeBSD package collection is a collection of thousands of ready-to-run\n"
literal|"applications, from text editors to games to WEB servers and more.  Would you\n"
literal|"like to browse the collection now?"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|configPackages
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to add any initial user accounts to the system?\n"
literal|"Adding at least one account for yourself at this stage is suggested\n"
literal|"since working as the \"root\" user is dangerous (it is easy to do\n"
literal|"things which adversely affect the entire system)."
argument_list|)
condition|)
operator|(
name|void
operator|)
name|configUsers
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Now you must set the system manager's password.\n"
literal|"This is the password you'll use to log in as \"root\"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|systemExecute
argument_list|(
literal|"passwd root"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"root_password"
argument_list|,
literal|"YES"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Put whatever other nice configuration questions you'd like to ask the user here XXX */
comment|/* Give user the option of one last configuration spree */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|DITEM_LEAVE_MENU
return|;
block|}
end_function

begin_comment
comment|/* The version of commit we call from the Install Custom menu */
end_comment

begin_function
name|int
name|installCustomCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
comment|/* Set default security level */
name|configSecurityModerate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
name|msgConfirm
argument_list|(
literal|"The commit operation completed with errors.  Not\n"
literal|"updating /etc files."
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * What happens when we finally decide to going ahead with the installation.  *  * This is broken into multiple stages so that the user can do a full  * installation but come back here again to load more distributions,  * perhaps from a different media type.  This would allow, for  * example, the user to load the majority of the system from CDROM and  * then use ftp to load just the CRYPTO dist.  */
end_comment

begin_function
name|int
name|installCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
name|distConfig
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
block|{
operator|(
name|void
operator|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuDistributions
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* select reasonable defaults if necessary */
if|if
condition|(
operator|!
name|Dists
condition|)
name|Dists
operator|=
name|_DIST_USER
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
return|;
name|str
operator|=
name|variable_get
argument_list|(
name|SYSTEM_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"installCommit: System state is `%s'\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Installation stuff we wouldn't do to a running system */
if|if
condition|(
name|RunningAsInit
operator|&&
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installInitial
argument_list|()
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
name|try_media
label|:
if|if
condition|(
operator|!
name|DEVICE_INIT
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Unable to initialize selected media. Would you like to\n"
literal|"adjust your media configuration and try again?"
argument_list|)
condition|)
block|{
name|mediaDevice
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
return|;
else|else
goto|goto
name|try_media
goto|;
block|}
else|else
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/* Now go get it all */
name|i
operator|=
name|distExtractAll
argument_list|(
name|self
argument_list|)
expr_stmt|;
comment|/* When running as init, *now* it's safe to grab the rc.foo vars */
name|installEnvironment
argument_list|()
expr_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_FAILURE
condition|?
literal|"error-install"
else|:
literal|"full-install"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Final menu of last resort */
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Visit the general configuration menu for a chance to set\n"
literal|"any last options?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuConfigure
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|configRC_conf
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|installFixupBin
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|kstat
init|=
literal|1
decl_stmt|;
comment|/* All of this is done only as init, just to be safe */
if|if
condition|(
name|RunningAsInit
condition|)
block|{
comment|/* Fix up kernel first */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/kernel"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|generic_kernel
init|=
literal|"/kernel.GENERIC"
decl_stmt|;
if|if
condition|(
name|file_readable
argument_list|(
name|generic_kernel
argument_list|)
condition|)
block|{
if|if
condition|(
name|vsystem
argument_list|(
literal|"cp -p %s /kernel"
argument_list|,
name|generic_kernel
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to copy /kernel into place!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|__i386__
comment|/* Snapshot any boot -c changes back to the new kernel */
name|cp
operator|=
name|variable_get
argument_list|(
name|VAR_KGET
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'Y'
operator|||
operator|*
name|cp
operator|==
literal|'y'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|kstat
operator|=
name|kget
argument_list|(
literal|"/boot/kernel.conf"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to save boot -c changes to new kernel,\n"
literal|"please see the debug screen (ALT-F2) for details."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
literal|"/boot/loader.conf"
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|kstat
operator|||
operator|!
name|OnVTY
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# -- sysinstall generated deltas -- #\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kstat
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"userconfig_script_load=\"YES\"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OnVTY
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"console=\"comconsole\"\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BOGON #1: Resurrect /dev after bin distribution screws it up */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Remaking all devices.. Please wait!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV all"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"MAKEDEV returned non-zero status"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Resurrecting /dev entries for slices.."
argument_list|)
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devs
condition|)
name|msgFatal
argument_list|(
literal|"Couldn't get a disk device list!"
argument_list|)
expr_stmt|;
comment|/* Resurrect the slices that the former clobbered */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Disk
modifier|*
name|disk
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Making slice entries for %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /dev; sh MAKEDEV %sh"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make slice entries for %s!"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
block|}
block|}
block|}
comment|/* BOGON #2: We leave /etc in a bad state */
name|chmod
argument_list|(
literal|"/etc"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
comment|/* BOGON #3: No /var/db/mountdtab complains */
name|Mkdir
argument_list|(
literal|"/var/db"
argument_list|)
expr_stmt|;
name|creat
argument_list|(
literal|"/var/db/mountdtab"
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
comment|/* BOGON #4: /compat created by default in root fs */
name|Mkdir
argument_list|(
literal|"/usr/compat"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"ln -s /usr/compat /compat"
argument_list|)
expr_stmt|;
comment|/* BOGON #5: aliases database not build for bin */
name|vsystem
argument_list|(
literal|"newaliases"
argument_list|)
expr_stmt|;
comment|/* Now run all the mtree stuff to fix things up */
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.root.dist -p /"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.var.dist -p /var"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.usr.dist -p /usr"
argument_list|)
expr_stmt|;
comment|/* Do all the last ugly work-arounds here */
block|}
return|return
name|DITEM_SUCCESS
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_comment
comment|/* Fix side-effects from the the XFree86 installation */
end_comment

begin_function
name|int
name|installFixupXFree
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
comment|/* BOGON #1:  XFree86 requires various specialized fixups */
if|if
condition|(
name|directory_exists
argument_list|(
literal|"/usr/X11R6"
argument_list|)
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Fixing permissions in XFree86 tree.."
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"chmod -R a+r /usr/X11R6"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"find /usr/X11R6 -type d | xargs chmod a+x"
argument_list|)
expr_stmt|;
comment|/* Also do bogus minimal package registration so ports don't whine */
if|if
condition|(
name|file_readable
argument_list|(
literal|"/usr/X11R6/lib/X11/pkgreg.tar.gz"
argument_list|)
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Installing package metainfo.."
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"tar xpzf /usr/X11R6/lib/X11/pkgreg.tar.gz -C /&& rm /usr/X11R6/lib/X11/pkgreg.tar.gz"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|DITEM_SUCCESS
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_comment
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
end_comment

begin_function
name|int
name|installFilesystems
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|rootdev
decl_stmt|,
modifier|*
name|swapdev
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|PartInfo
modifier|*
name|root
decl_stmt|;
name|char
name|dname
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|int
name|MakeDevChunk
argument_list|(
name|Chunk
operator|*
name|c
argument_list|,
name|char
operator|*
name|n
argument_list|)
decl_stmt|;
name|Boolean
name|upgrade
init|=
name|FALSE
decl_stmt|;
comment|/* If we've already done this, bail out */
if|if
condition|(
operator|!
name|variable_cmp
argument_list|(
name|DISK_LABELLED
argument_list|,
literal|"written"
argument_list|)
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|upgrade
operator|=
operator|!
name|variable_cmp
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"upgrade"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkLabels
argument_list|(
name|TRUE
argument_list|,
operator|&
name|rootdev
argument_list|,
operator|&
name|swapdev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|DITEM_FAILURE
return|;
if|if
condition|(
name|rootdev
condition|)
name|root
operator|=
operator|(
name|PartInfo
operator|*
operator|)
name|rootdev
operator|->
name|private_data
expr_stmt|;
else|else
name|root
operator|=
name|NULL
expr_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|swapdev
operator|&&
name|RunningAsInit
condition|)
block|{
comment|/* As the very first thing, try to get ourselves some swap space */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|swapdev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
operator|&&
operator|(
operator|!
name|MakeDevChunk
argument_list|(
name|swapdev
argument_list|,
literal|"/dev"
argument_list|)
operator|||
operator|!
name|file_readable
argument_list|(
name|dname
argument_list|)
operator|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make device node for %s in /dev!\n"
literal|"The creation of filesystems will be aborted."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|Fake
condition|)
block|{
if|if
condition|(
operator|!
name|swapon
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Added %s as initial swap device"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"WARNING!  Unable to swap to %s: %s\n"
literal|"This may cause the installation to fail at some point\n"
literal|"if you don't have a lot of memory."
argument_list|,
name|dname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rootdev
operator|&&
name|RunningAsInit
condition|)
block|{
comment|/* Next, create and/or mount the root device */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
operator|&&
operator|(
operator|!
name|MakeDevChunk
argument_list|(
name|rootdev
argument_list|,
literal|"/dev"
argument_list|)
operator|||
operator|!
name|file_readable
argument_list|(
name|dname
argument_list|)
operator|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make device node for %s in /dev!\n"
literal|"The creation of filesystems will be aborted."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|root
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|,
name|root
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|newfs
operator|&&
operator|(
operator|!
name|upgrade
operator|||
operator|!
name|msgNoYes
argument_list|(
literal|"You are upgrading - are you SURE you want to newfs the root partition?"
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"%s %s"
argument_list|,
name|root
operator|->
name|newfs_cmd
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem on %s!\n"
literal|"Command returned status %d"
argument_list|,
name|dname
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|upgrade
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  Using existing root partition.  It will be assumed\n"
literal|"that you have the appropriate device entries already in /dev."
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Checking integrity of existing %s filesystem."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"fsck -y %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: fsck returned status of %d for %s.\n"
literal|"This partition may be unsafe to use."
argument_list|,
name|i
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|root
operator|->
name|soft
condition|)
block|{
name|i
operator|=
name|vsystem
argument_list|(
literal|"tunefs -n enable %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning:  Unable to enable softupdates for root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
comment|/* Switch to block device */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system on %s!  Giving up."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
if|if
condition|(
name|RunningAsInit
operator|&&
name|root
operator|&&
operator|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
operator|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
condition|)
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|RunningAsInit
operator|&&
operator|!
name|Fake
condition|)
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/dev"
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private_data
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
decl_stmt|;
comment|/* Already did root */
if|if
condition|(
name|c2
operator|==
name|rootdev
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|newfs
operator|&&
operator|(
operator|!
name|upgrade
operator|||
operator|!
name|msgNoYes
argument_list|(
literal|"You are upgrading - are you SURE you want to newfs /dev/%s?"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
operator|)
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"%s %s/dev/%s"
argument_list|,
name|tmp
operator|->
name|newfs_cmd
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"fsck -y %s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|soft
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"tunefs -n enable %s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|char
name|fname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c2
operator|==
name|swapdev
condition|)
continue|continue;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|Fake
operator|||
name|swapon
argument_list|(
name|fname
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Added %s as an additional swap device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"Unable to add %s as a swap device: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|fat
operator|&&
name|c1
operator|->
name|private_data
operator|&&
operator|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
operator|)
condition|)
block|{
name|char
name|name
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|RunningAsInit
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Copying initial device files.."
argument_list|)
expr_stmt|;
comment|/* Copy the boot floppy's dev files */
if|if
condition|(
operator|(
name|root
operator|->
name|newfs
operator|||
name|upgrade
operator|)
operator|&&
name|vsystem
argument_list|(
literal|"find -x /dev | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't clone the /dev files!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
return|return
name|DITEM_SUCCESS
operator||
name|DITEM_RESTORE
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getRelname
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|sz
init|=
operator|(
sizeof|sizeof
name|buf
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"kern.osrelease"
argument_list|,
name|buf
argument_list|,
operator|&
name|sz
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
index|[
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
else|else
return|return
literal|"<unknown>"
return|;
block|}
end_function

begin_comment
comment|/* Initialize various user-settable values to their defaults */
end_comment

begin_function
name|int
name|installVarDefaults
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Set default startup options */
name|variable_set2
argument_list|(
name|VAR_RELNAME
argument_list|,
name|getRelname
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_CPIO_VERBOSITY
argument_list|,
literal|"high"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_KGET
argument_list|,
literal|"YES"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_TAPE_BLOCKSIZE
argument_list|,
name|DEFAULT_TAPE_BLOCKSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_INSTALL_ROOT
argument_list|,
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_INSTALL_CFG
argument_list|,
literal|"install.cfg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|cp
operator|=
literal|"/usr/bin/ee"
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_EDITOR
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_FTP_USER
argument_list|,
literal|"ftp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_BROWSER_PACKAGE
argument_list|,
literal|"lynx"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_BROWSER_BINARY
argument_list|,
literal|"/usr/local/bin/lynx"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_FTP_STATE
argument_list|,
literal|"passive"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NFS_SECURE
argument_list|,
literal|"NO"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OnVTY
condition|)
name|variable_set2
argument_list|(
name|VAR_FIXIT_TTY
argument_list|,
literal|"standard"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|variable_set2
argument_list|(
name|VAR_FIXIT_TTY
argument_list|,
literal|"serial"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_PKG_TMPDIR
argument_list|,
literal|"/usr/tmp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_MEDIA_TIMEOUT
argument_list|,
name|itoa
argument_list|(
name|MEDIA_TIMEOUT
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpid
argument_list|()
operator|!=
literal|1
condition|)
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"update"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"init"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NEWFS_ARGS
argument_list|,
literal|"-b 16384 -f 2048"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Load the environment up from various system configuration files */
end_comment

begin_function
name|void
name|installEnvironment
parameter_list|(
name|void
parameter_list|)
block|{
name|configEnvironmentRC_conf
argument_list|()
expr_stmt|;
if|if
condition|(
name|file_readable
argument_list|(
literal|"/etc/resolv.conf"
argument_list|)
condition|)
name|configEnvironmentResolv
argument_list|(
literal|"/etc/resolv.conf"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the boot floppy contents into /stand */
end_comment

begin_function
name|Boolean
name|copySelf
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file_readable
argument_list|(
literal|"/boot.help"
argument_list|)
condition|)
name|vsystem
argument_list|(
literal|"cp /boot.help /mnt"
argument_list|)
expr_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Copying the boot floppy to /stand on root filesystem"
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"find -x /stand | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Copy returned error status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Copy the /etc files into their rightful place */
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /mnt/stand; find etc | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't copy up the /etc files!"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|caps
index|[]
init|=
block|{
name|termcap_vt100
block|,
name|termcap_cons25
block|,
name|termcap_cons25_m
block|,
name|termcap_cons25r
block|,
name|termcap_cons25r_m
block|,
name|termcap_cons25l1
block|,
name|termcap_cons25l1_m
block|,
name|termcap_xterm
block|,
name|NULL
block|,     }
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/usr/share/misc"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|TERMCAP_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to initialize termcap file. Some screen-oriented\nutilities may not work."
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|caps
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
operator|(
name|cp
operator|++
operator|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

