begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: lndir.c,v 1.14 95/01/09 20:08:20 kaleb Exp $ */
end_comment

begin_comment
comment|/* $XFree86: xc/config/util/lndir.c,v 3.3 1995/01/28 15:41:09 dawes Exp $ */
end_comment

begin_comment
comment|/* Create shadow link tree (after X11R4 script of the same name)    Mark Reinhold (mbr@lcs.mit.edu)/3 January 1990 */
end_comment

begin_comment
comment|/* Hacked somewhat by Jordan Hubbard, The FreeBSD Project, to make it */
end_comment

begin_comment
comment|/* an invokable function from sysinstall rather than a stand-alone binary */
end_comment

begin_comment
comment|/*  Copyright (c) 1990,  X Consortium  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Except as contained in this notice, the name of the X Consortium shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization from the X Consortium.  */
end_comment

begin_comment
comment|/* From the original /bin/sh script:    Used to create a copy of the a directory tree that has links for all   non-directories (except those named RCS, SCCS or CVS.adm).  If you are   building the distribution on more than one machine, you should use   this technique.    If your master sources are located in /usr/local/src/X and you would like   your link tree to be in /usr/local/src/new-X, do the following:     	%  mkdir /usr/local/src/new-X 	%  cd /usr/local/src/new-X    	%  lndir ../X */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXPATHLEN
value|2048
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcurdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|curdir
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|equivalent
parameter_list|(
name|char
modifier|*
name|lname
parameter_list|,
name|char
modifier|*
name|rname
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lname
argument_list|,
name|rname
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|s
operator|=
name|lname
init|;
operator|*
name|s
operator|&&
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|;
name|s
operator|++
control|)
block|{
while|while
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|strcmp
argument_list|(
name|lname
argument_list|,
name|rname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recursively create symbolic links from the current directory to the "from"    directory.  Assumes that files described by fs and ts are directories. */
end_comment

begin_function
specifier|static
name|int
name|dodir
parameter_list|(
name|char
modifier|*
name|fn
parameter_list|,
name|struct
name|stat
modifier|*
name|fs
parameter_list|,
name|struct
name|stat
modifier|*
name|ts
parameter_list|,
name|int
name|rel
parameter_list|)
block|{
name|DIR
modifier|*
name|df
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|symbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|,
name|sc
decl_stmt|;
name|int
name|n_dirs
decl_stmt|;
name|int
name|symlen
decl_stmt|;
name|char
modifier|*
name|ocurdir
decl_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|st_dev
operator|==
name|ts
operator|->
name|st_dev
operator|)
operator|&&
operator|(
name|fs
operator|->
name|st_ino
operator|==
name|ts
operator|->
name|st_ino
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|rel
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"../"
argument_list|)
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|df
operator|=
name|opendir
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|msgDebug
argument_list|(
literal|"%s: Cannot opendir\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|n_dirs
operator|=
name|fs
operator|->
name|st_nlink
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|df
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'~'
condition|)
continue|continue;
name|strcpy
argument_list|(
name|p
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_dirs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"Can't stat: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* directory */
name|n_dirs
operator|--
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"RCS"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"SCCS"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"CVS"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"CVS.adm"
argument_list|)
condition|)
continue|continue;
name|ocurdir
operator|=
name|rcurdir
expr_stmt|;
name|rcurdir
operator|=
name|buf
expr_stmt|;
name|curdir
operator|=
name|isDebug
argument_list|()
condition|?
name|buf
else|:
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"%s:\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|sc
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ENOENT
operator|)
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|||
name|stat
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"Unable to make or stat: %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|curdir
operator|=
name|rcurdir
operator|=
name|ocurdir
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|readlink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|symbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"%s: is a link instead of a directory\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|curdir
operator|=
name|rcurdir
operator|=
name|ocurdir
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"Unable to chdir to: %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|curdir
operator|=
name|rcurdir
operator|=
name|ocurdir
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|dodir
argument_list|(
name|buf
argument_list|,
operator|&
name|sb
argument_list|,
operator|&
name|sc
argument_list|,
operator|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|".."
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"Unable to get back to ..\n"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|curdir
operator|=
name|rcurdir
operator|=
name|ocurdir
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* non-directory */
name|symlen
operator|=
name|readlink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|symbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlen
operator|>=
literal|0
condition|)
block|{
name|symbuf
index|[
name|symlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|equivalent
argument_list|(
name|symbuf
argument_list|,
name|buf
argument_list|)
condition|)
name|msgDebug
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|symbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symlink
argument_list|(
name|buf
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
operator|<
literal|0
condition|)
name|msgDebug
argument_list|(
literal|"Unable to create symlink: %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|df
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|lndir
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|stat
name|fs
decl_stmt|,
name|ts
decl_stmt|;
if|if
condition|(
operator|!
name|to
condition|)
name|to
operator|=
literal|"."
expr_stmt|;
comment|/* to directory */
if|if
condition|(
name|stat
argument_list|(
name|to
argument_list|,
operator|&
name|ts
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"Destination directory doesn't exist: %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|S_ISDIR
argument_list|(
name|ts
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|msgDebug
argument_list|(
literal|"%s: Not a directory\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|to
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"Unable to chdir to %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/* from directory */
if|if
condition|(
name|stat
argument_list|(
name|from
argument_list|,
operator|&
name|fs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgDebug
argument_list|(
literal|"From directory doesn't exist: %s\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|S_ISDIR
argument_list|(
name|fs
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|msgDebug
argument_list|(
literal|"%s: Not a directory\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
return|return
name|dodir
argument_list|(
name|from
argument_list|,
operator|&
name|fs
argument_list|,
operator|&
name|ts
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

