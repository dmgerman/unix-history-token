begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_expr_stmt
name|void
operator|*
name|The
name|new
name|sysinstall
name|program
operator|.
modifier|*
modifier|*
name|This
name|is
name|probably
name|the
name|last
name|program
name|in
name|the
operator|`
name|sysinstall
literal|' line - the next  * generation being essentially a complete rewrite.  *  * $Id: dist.c,v 1.35.2.3 1995/05/31 10:17:29 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'
literal|' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */  #include "sysinstall.h"  unsigned int Dists; unsigned int SrcDists; unsigned int XF86Dists; unsigned int XF86ServerDists; unsigned int XF86FontDists;  static int	distSetXF86(void);  int distReset(char *str) {     Dists = 0;     SrcDists = 0;     XF86Dists = 0;     XF86ServerDists = 0;     XF86FontDists = 0;     return 0; }  int distSetDeveloper(char *str) {     Dists = _DIST_DEVELOPER;     SrcDists = DIST_SRC_ALL;     return 0; }  int distSetXDeveloper(char *str) {     Dists = _DIST_DEVELOPER;     SrcDists = DIST_SRC_ALL;     distSetXF86();     return 0; }  int distSetUser(char *str) {     Dists = _DIST_USER;     return 0; }  int distSetXUser(char *str) {     Dists = _DIST_USER;     distSetXF86();     return 0; }  int distSetMinimum(char *str) {     Dists = DIST_BIN;     return 0; }  int distSetEverything(char *str) {     Dists = DIST_ALL;     SrcDists = DIST_SRC_ALL;     distSetXF86();     return 0; }  int distSetSrc(char *str) {     if (!dmenuOpenSimple(&MenuSrcDistributions)) 	return 0;     if (SrcDists) 	Dists |= DIST_SRC;     return 0; }  static int distSetXF86(void) {     if (!dmenuOpenSimple(&MenuXF86Select)) 	return 0;     if (XF86ServerDists) 	XF86Dists |= DIST_XF86_FONTS;     if (XF86FontDists) 	XF86Dists |= DIST_XF86_FONTS;     if (XF86Dists) 	Dists |= DIST_XF86;     return 0; }  typedef struct _dist {     char *my_name;     char *my_dir;     unsigned int *my_mask;     unsigned int my_bit;     struct _dist *my_dist; } Distribution;  extern Distribution SrcDistTable[]; extern Distribution XF86DistTable[]; extern Distribution XF86FontDistTable[]; extern Distribution XF86ServerDistTable[];   /* The top-level distribution categories */ static Distribution DistTable[] = { { "bin",	"/",&Dists,		DIST_BIN,		NULL		}, { "games",	"/",&Dists,		DIST_GAMES,		NULL		}, { "manpages",	"/",&Dists,		DIST_MANPAGES,		NULL		}, { "proflibs",	"/",&Dists,		DIST_PROFLIBS,		NULL		}, { "dict",	"/",&Dists,		DIST_DICT,		NULL		}, { "src",	"/",&Dists,		DIST_SRC,		SrcDistTable	}, { "des",	"/",&Dists,		DIST_DES,		NULL		}, { "compat1x",	"/",&Dists,		DIST_COMPAT1X,		NULL		}, { "compat20",	"/",&Dists,		DIST_COMPAT20,		NULL		}, { "XF86311",	"/usr",&Dists,		DIST_XF86,		XF86DistTable	}, { NULL }, };  /* The /usr/src distribution */ static Distribution SrcDistTable[] = { { "sbase",	"/usr/src",&SrcDists,	DIST_SRC_BASE,		NULL		}, { "sgnu",	"/usr/src",&SrcDists,	DIST_SRC_GNU,		NULL		}, { "setc",	"/usr/src",&SrcDists,	DIST_SRC_ETC,		NULL		}, { "sgames",	"/usr/src",&SrcDists,	DIST_SRC_GAMES,		NULL		}, { "sinclude",	"/usr/src",&SrcDists,	DIST_SRC_INCLUDE,	NULL		}, { "slib",	"/usr/src",&SrcDists,	DIST_SRC_LIB,		NULL		}, { "slibexec",	"/usr/src",&SrcDists,	DIST_SRC_LIBEXEC,	NULL		}, { "slkm",	"/usr/src",&SrcDists,	DIST_SRC_LKM,		NULL		}, { "srelease",	"/usr/src",&SrcDists,	DIST_SRC_RELEASE,	NULL		}, { "ssbin",	"/usr/src",&SrcDists,	DIST_SRC_SBIN,		NULL		}, { "sshare",	"/usr/src",&SrcDists,	DIST_SRC_SHARE,		NULL		}, { "ssys",	"/usr/src",&SrcDists,	DIST_SRC_SYS,		NULL		}, { "subin",	"/usr/src",&SrcDists,	DIST_SRC_UBIN,		NULL		}, { "susbin",	"/usr/src",&SrcDists,	DIST_SRC_USBIN,		NULL		}, { NULL }, };  /* The XFree86 distribution */ static Distribution XF86DistTable[] = { { "X311bin",	"/usr",&XF86Dists,	DIST_XF86_BIN,		NULL		}, { "X311lib",	"/usr",&XF86Dists,	DIST_XF86_LIB,		NULL		}, { "X311doc",	"/usr",&XF86Dists,	DIST_XF86_DOC,		NULL		}, { "XF86311",	"/usr",&XF86Dists,	DIST_XF86_FONTS,	XF86FontDistTable }, { "X311man",	"/usr",&XF86Dists,	DIST_XF86_MAN,		NULL		}, { "X311prog",	"/usr",&XF86Dists,	DIST_XF86_PROG,		NULL		}, { "X311link",	"/usr",&XF86Dists,	DIST_XF86_LINK,		NULL		}, { "X311pex",	"/usr",&XF86Dists,	DIST_XF86_PEX,		NULL		}, { "X311lbx",	"/usr",&XF86Dists,	DIST_XF86_LBX,		NULL		}, { "X311xicf",	"/usr",&XF86Dists,	DIST_XF86_XINIT,	NULL		}, { "X311xdcf",	"/usr",&XF86Dists,	DIST_XF86_XDMCF,	NULL		}, { "XF86311",	"/usr",&XF86Dists,	DIST_XF86_SERVER,	XF86ServerDistTable }, { "XF86-xc",	"/usr/X11R6/src",&XF86Dists,	DIST_XF86_SRC,		NULL		}, { "XF86-co",	"/usr/X11R6/src",&XF86Dists,	DIST_XF86_SRC,		NULL		}, { NULL }, };  /* The XFree86 server distribution */ static Distribution XF86ServerDistTable[] = { { "X3118514",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_8514,	NULL		}, { "X311AGX",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_AGX,	NULL		}, { "X311Mch3",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_MACH32,NULL		}, { "X311Mch8",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_MACH8,	NULL		}, { "X311Mono",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_MONO,	NULL		}, { "X311P9K",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_P9000,	NULL		}, { "X311S3",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_S3,	NULL		}, { "X311SVGA",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_SVGA,	NULL		}, { "X311VG16",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_VGA16,	NULL		}, { "X311W32",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_W32,	NULL		}, { "X311nest",	"/usr",&XF86ServerDists,	DIST_XF86_SERVER_NEST,	NULL		}, { NULL }, };  /* The XFree86 font distribution */ static Distribution XF86FontDistTable[] = { { "X311fnts",	"/usr",&XF86FontDists,		DIST_XF86_FONTS_MISC,	NULL		}, { "X311f100",	"/usr",&XF86FontDists,		DIST_XF86_FONTS_100,	NULL		}, { "X311fscl",	"/usr",&XF86FontDists,		DIST_XF86_FONTS_SCALE,	NULL		}, { "X311fnon",	"/usr",&XF86FontDists,		DIST_XF86_FONTS_NON,	NULL		}, { "X311fsrv",	"/usr",&XF86FontDists,		DIST_XF86_FONTS_SERVER,	NULL		}, { NULL }, };  static Boolean distExtract(char *parent, Distribution *me) {     int i, status;     int cpid, zpid, fd, fd2, chunk, numchunks;     char *path, *dist, buf[10240];     const char *tmp;     Attribs *dist_attr;      status = FALSE;     /* Loop through to see if we'
name|re
name|in
name|our
name|parent
literal|'s plans */     for (i = 0; me[i].my_name; i++) { 	/* If our bit isn'
name|t
name|set
operator|,
name|go
name|to
name|the
name|next
operator|*
operator|/
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|me
index|[
name|i
index|]
operator|.
name|my_bit
operator|&
operator|*
operator|(
name|me
index|[
name|i
index|]
operator|.
name|my_mask
operator|)
operator|)
condition|)
continue|continue;
end_if

begin_comment
comment|/* Recurse if actually have a sub-distribution */
end_comment

begin_if
if|if
condition|(
name|me
index|[
name|i
index|]
operator|.
name|my_dist
condition|)
block|{
name|status
operator|=
name|distExtract
argument_list|(
name|me
index|[
name|i
index|]
operator|.
name|my_name
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_dist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
goto|goto
name|done
goto|;
else|else
goto|goto
name|punt
goto|;
block|}
end_if

begin_expr_stmt
name|dist
operator|=
name|me
index|[
name|i
index|]
operator|.
name|my_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|path
operator|=
name|parent
condition|?
name|parent
else|:
name|me
index|[
name|i
index|]
operator|.
name|my_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|512
argument_list|,
literal|"%s/%s.tgz"
argument_list|,
name|path
argument_list|,
name|dist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fd
operator|=
call|(
modifier|*
name|mediaDevice
operator|->
name|get
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Extracting %s into %s directory..."
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_name
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_dir
argument_list|)
expr_stmt|;
name|status
operator|=
name|mediaExtractDist
argument_list|(
name|me
index|[
name|i
index|]
operator|.
name|my_dir
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mediaDevice
operator|->
name|close
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|close
call|)
argument_list|(
name|mediaDevice
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
end_if

begin_expr_stmt
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"/stand/info/%s/%s.inf"
argument_list|,
name|path
argument_list|,
name|dist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|access
argument_list|(
name|buf
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Parsing attributes file for %s\n"
argument_list|,
name|dist
argument_list|)
expr_stmt|;
name|dist_attr
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Attribs
argument_list|)
operator|*
name|MAX_ATTRIBS
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_parse
argument_list|(
operator|&
name|dist_attr
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Cannot load information file for %s distribution!\nPlease verify that your media is valid and try again."
argument_list|,
name|dist
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Looking for attribute `pieces'\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|attr_match
argument_list|(
name|dist_attr
argument_list|,
literal|"pieces"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|numchunks
operator|=
name|atoi
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|numchunks
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|numchunks
operator|=
literal|0
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Attempting to extract distribution from %u chunks.\n"
argument_list|,
name|numchunks
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|numchunks
operator|<
literal|2
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|512
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|numchunks
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|".aa"
argument_list|)
expr_stmt|;
name|fd
operator|=
call|(
modifier|*
name|mediaDevice
operator|->
name|get
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|msgNotify
argument_list|(
literal|"Extracting %s into %s directory..."
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_name
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_dir
argument_list|)
expr_stmt|;
name|status
operator|=
name|mediaExtractDist
argument_list|(
name|me
index|[
name|i
index|]
operator|.
name|my_dir
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mediaDevice
operator|->
name|close
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|close
call|)
argument_list|(
name|mediaDevice
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
end_if

begin_expr_stmt
name|mediaExtractDistBegin
argument_list|(
name|me
index|[
name|i
index|]
operator|.
name|my_dir
argument_list|,
operator|&
name|fd2
argument_list|,
operator|&
name|zpid
argument_list|,
operator|&
name|cpid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dialog_clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|chunk
operator|=
literal|0
init|;
name|chunk
operator|<
name|numchunks
condition|;
name|chunk
operator|++
control|)
block|{
name|int
name|n
decl_stmt|,
name|retval
decl_stmt|;
name|char
name|prompt
index|[
literal|80
index|]
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|512
argument_list|,
literal|"%s/%s.%c%c"
argument_list|,
name|path
argument_list|,
name|dist
argument_list|,
operator|(
name|chunk
operator|/
literal|26
operator|)
operator|+
literal|'a'
argument_list|,
operator|(
name|chunk
operator|%
literal|26
operator|)
operator|+
literal|'a'
argument_list|)
expr_stmt|;
name|retry
label|:
name|fd
operator|=
call|(
modifier|*
name|mediaDevice
operator|->
name|get
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|retries
operator|<
literal|5
condition|)
goto|goto
name|retry
goto|;
name|msgConfirm
argument_list|(
literal|"failed to retreive piece file %s after 5 retries!\nAborting the transfer"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|punt
goto|;
block|}
name|snprintf
argument_list|(
name|prompt
argument_list|,
literal|80
argument_list|,
literal|"Extracting %s into %s directory..."
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_name
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_dir
argument_list|)
expr_stmt|;
name|dialog_gauge
argument_list|(
literal|" Progress "
argument_list|,
name|prompt
argument_list|,
literal|8
argument_list|,
literal|15
argument_list|,
literal|6
argument_list|,
literal|50
argument_list|,
call|(
name|int
call|)
argument_list|(
call|(
name|float
call|)
argument_list|(
name|chunk
operator|+
literal|1
argument_list|)
operator|/
name|numchunks
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|retval
operator|=
name|write
argument_list|(
name|fd2
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|n
condition|)
block|{
if|if
condition|(
name|mediaDevice
operator|->
name|close
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|close
call|)
argument_list|(
name|mediaDevice
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Write failure on transfer! (wrote %d bytes of %d bytes)"
argument_list|,
name|retval
argument_list|,
name|n
argument_list|)
expr_stmt|;
goto|goto
name|punt
goto|;
block|}
block|}
if|if
condition|(
name|mediaDevice
operator|->
name|close
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|close
call|)
argument_list|(
name|mediaDevice
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|status
operator|=
name|mediaExtractDistEnd
argument_list|(
name|zpid
argument_list|,
name|cpid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|done
goto|;
end_goto

begin_label
name|punt
label|:
end_label

begin_expr_stmt
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mediaExtractDistEnd
argument_list|(
name|zpid
argument_list|,
name|cpid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|status
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_label
name|done
label|:
end_label

begin_if
if|if
condition|(
operator|!
name|status
condition|)
block|{
if|if
condition|(
name|getenv
argument_list|(
name|NO_CONFIRMATION
argument_list|)
condition|)
name|status
operator|=
name|TRUE
expr_stmt|;
else|else
name|status
operator|=
name|msgYesNo
argument_list|(
literal|"Unable to transfer the %s distribution from %s.\nDo you want to retry this distribution later?"
argument_list|,
name|me
index|[
name|i
index|]
operator|.
name|my_name
argument_list|,
name|mediaDevice
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Extract was successful, remove ourselves from further consideration */
end_comment

begin_if
if|if
condition|(
name|status
condition|)
operator|*
operator|(
name|me
index|[
name|i
index|]
operator|.
name|my_mask
operator|)
operator|&=
operator|~
operator|(
name|me
index|[
name|i
index|]
operator|.
name|my_bit
operator|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}     return
name|status
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  void
name|distExtractAll
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|int
name|retries
init|=
literal|0
decl_stmt|;
comment|/* First try to initialize the state of things */
if|if
condition|(
name|mediaDevice
operator|->
name|init
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|mediaDevice
operator|->
name|init
call|)
argument_list|(
name|mediaDevice
argument_list|)
condition|)
return|return;
comment|/* Try for 3 times around the loop, then give up. */
while|while
condition|(
name|Dists
operator|&&
operator|++
name|retries
operator|<
literal|3
condition|)
name|distExtract
argument_list|(
name|NULL
argument_list|,
name|DistTable
argument_list|)
expr_stmt|;
comment|/* Anything left? */
if|if
condition|(
name|Dists
condition|)
name|msgConfirm
argument_list|(
literal|"Couldn't extract all of the dists.  Residue: %0x"
argument_list|,
name|Dists
argument_list|)
expr_stmt|;
comment|/* Close up shop and go home */
if|if
condition|(
name|mediaDevice
operator|->
name|shutdown
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|shutdown
call|)
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

